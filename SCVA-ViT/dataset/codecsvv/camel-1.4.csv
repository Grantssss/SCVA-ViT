metric_name,file
org.apache.camel.AlreadyStoppedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Exception thrown in situations when a {@link Service} has already been stopped.
 *
 * @version $Revision: 659422 $
 */
public class AlreadyStoppedException extends CamelException {
    public AlreadyStoppedException() {
        super(""Already stopped"");
    }
}
"
org.apache.camel.AsyncCallback,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * The callback interface for an {@link AsyncProcessor} so that it can
 * notify you when an {@link Exchange} has completed. 
 */
public interface AsyncCallback {
    /**
     * This method is invoked once the Exchange is completed.  If an error 
     * occurred while processing the exchange, the exception field of the 
     * {@link Exchange} being processed will hold the error. 
     *  
     * @param doneSynchronously set to true if the processing of the exchange was completed synchronously thread.
     */
    void done(boolean doneSynchronously);    
}
"
org.apache.camel.AsyncProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A more complex version of {@link Processor} which supports asynchronous
 * processing of the {@link Exchange}.  Any processor can be coerced to
 * have an {@link AsyncProcessor} interface by using the
 * {@link org.apache.camel.impl.converter.AsyncProcessorTypeConverter#convert AsyncProcessorTypeConverter.covert}
 * method.
 * 
 * @version $Revision: 642753 $
 */
public interface AsyncProcessor extends Processor {
    /**
     * Processes the message exchange.  Similar to {@link Processor#process}, but
     * the caller supports having the exchange asynchronously processed.
     *
     * @param exchange the {@link Exchange} to process
     * @param  callback the {@link AsyncCallback} will be invoked when the processing
     *         of the exchange is completed. If the exchange is completed synchronously, then the 
     *         callback is also invoked synchronously.  The callback should therefore be careful of
     *         starting recursive loop.
     *         
     * @return true if the processing was completed synchronously.
     */
    boolean process(Exchange exchange, AsyncCallback callback);
}
"
org.apache.camel.Body,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being the body of an inbound {@link Message}
 * 
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Body {
}
"
org.apache.camel.BodyAndHeaderConvertTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.net.URL;
import javax.activation.DataHandler;
import javax.activation.URLDataSource;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import junit.framework.TestCase;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision: 652235 $
 */
public class BodyAndHeaderConvertTest extends TestCase {
    protected Exchange exchange;
    public void testConversionOfBody() throws Exception {
        Document document = exchange.getIn().getBody(Document.class);
        assertNotNull(document);
        Element element = document.getDocumentElement();
        assertEquals(""Root element name"", ""hello"", element.getLocalName());
    }
    public void testConversionOfExchangeProperties() throws Exception {
        String text = exchange.getProperty(""foo"", String.class);
        assertEquals(""foo property"", ""1234"", text);
        // TODO better conversion example when the property editor support is added
    }
    public void testConversionOfMessageHeaders() throws Exception {
        String text = exchange.getIn().getHeader(""bar"", String.class);
        assertEquals(""bar header"", ""567"", text);
        // TODO better conversion example when the property editor support is added
    }
    public void testConversionOfMessageAttachments() throws Exception {
        DataHandler handler = exchange.getIn().getAttachment(""att"");
        assertNotNull(""attachment got lost"", handler);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        exchange = new DefaultExchange(new DefaultCamelContext());
        exchange.setProperty(""foo"", 1234);
        Message message = exchange.getIn();
        message.setBody(""<hello>world!</hello>"");
        message.setHeader(""bar"", 567);
        message.addAttachment(""att"", new DataHandler(new URLDataSource(new URL(""http://activemq.apache.org/camel/message.html""))));
    }
}
"
org.apache.camel.CamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.Registry;
/**
 * Interface used to represent the context used to configure routes and the
 * policies to use during message exchanges between endpoints.
 *
 * @version $Revision: 670436 $
 */
public interface CamelContext extends Service {
    /**
     * Gets the name of the this context.
     */
    String getName();
    // Component Management Methods
    //-----------------------------------------------------------------------
    /**
     * Adds a component to the context.
     */
    void addComponent(String componentName, Component component);
    /**
     * Gets a component from the context by name.
     */
    Component getComponent(String componentName);
    /**
     * Gets a component from the context by name and specifying the expected type of component.
     */
    <T extends Component> T getComponent(String name, Class<T> componentType);
    /**
     * Removes a previously added component.
     *
     * @param componentName
     * @return the previously added component or null if it had not been previously added.
     */
    Component removeComponent(String componentName);
    /**
     * Gets the a previously added component by name or lazily creates the component
     * using the factory Callback.
     *
     * @param componentName the name of the component
     * @param factory       used to create a new component instance if the component was not previously added.
     * @return the component
     */
    Component getOrCreateComponent(String componentName, Callable<Component> factory);
    // Endpoint Management Methods
    //-----------------------------------------------------------------------
    /**
     * Resolves the given URI to an {@link Endpoint}.  If the URI has a singleton endpoint
     * registered, then the singleton is returned.  Otherwise, a new {@link Endpoint} is created
     * and if the endpoint is a singleton it is registered as a singleton endpoint.
     */
    Endpoint getEndpoint(String uri);
    /**
     * Resolves the given URI to an {@link Endpoint} of the specified type.
     * If the URI has a singleton endpoint registered, then the singleton is returned.
     * Otherwise, a new {@link Endpoint} is created and if the endpoint is a
     * singleton it is registered as a singleton endpoint.
     */
    <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType);
    /**
     * Returns the collection of all registered singleton endpoints.
     */
    Collection<Endpoint> getSingletonEndpoints();
    /**
     * Adds the endpoint to the context using the given URI.  The endpoint will be registered as a singleton.
     *
     * @param uri the URI to be used to resolve this endpoint
     * @param endpoint the endpoint to be added to the context
     * @return the old endpoint that was previously registered to the context if there was
     * already an endpoint for that URI
     * @throws Exception if the new endpoint could not be started or the old endpoint could not be stopped
     */
    Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception;
    /**
     * Removes the singleton endpoint with the given URI
     *
     * @param uri the URI to be used to remove
     * @return the endpoint that was removed or null if there is no endpoint for this URI
     * @throws Exception if endpoint could not be stopped
     */
    Endpoint removeSingletonEndpoint(String uri) throws Exception;
    // Route Management Methods
    //-----------------------------------------------------------------------
    /**
     * Returns a list of the current route definitions
     */
    List<RouteType> getRouteDefinitions();
    /**
     * Returns the current routes in this context
     */
    List<Route> getRoutes();
    /**
     * Sets the routes for this context, replacing any current routes
     *
     * @param routes the new routes to use
     */
    void setRoutes(List<Route> routes);
    /**
     * Adds a collection of routes to this context
     *
     * @param routes the routes to add
     */
    void addRoutes(Collection<Route> routes) throws Exception;
    /**
     * Adds a collection of routes to this context using the given builder
     * to build them
     *
     * @param builder the builder which will create the routes and add them to this context
     * @throws Exception if the routes could not be created for whatever reason
     */
    void addRoutes(Routes builder) throws Exception;
    /**
     * Adds a collection of route definitions to the context
     */
    void addRouteDefinitions(Collection<RouteType> routeDefinitions) throws Exception;
    // Properties
    //-----------------------------------------------------------------------
    /**
     * Returns the converter of exchanges from one type to another
     */
    ExchangeConverter getExchangeConverter();
    /**
     * Returns the type converter used to coerce types from one type to another
     */
    TypeConverter getTypeConverter();
    /**
     * Returns the registry used to lookup components by name and type such as the Spring ApplicationContext,
     * JNDI or the OSGi Service Registry
     */
    Registry getRegistry();
    /**
     * Returns the injector used to instantiate objects by type
     */
    Injector getInjector();
    /**
     * Returns the lifecycle strategy used to handle lifecycle notification
     */
    LifecycleStrategy getLifecycleStrategy();
    /**
     * Resolves a language for creating expressions
     */
    Language resolveLanguage(String language);
    /**
     * Creates a new ProducerTemplate
     */
    <E extends Exchange> ProducerTemplate<E> createProducerTemplate();
    void addInterceptStrategy(InterceptStrategy interceptStrategy);
}
"
org.apache.camel.CamelContextAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An interface to represent an object which wishes to be injected with
 * a {@link CamelContext} such as when working with Spring or Guice
 *
 * @version $Revision: 630591 $
 */
public interface CamelContextAware {
    /**
     * Injects the {@link CamelContext}
     *
     * @param camelContext
     */
    void setCamelContext(CamelContext camelContext);
}
"
org.apache.camel.CamelException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Base class for all Camel checked exceptions typically thrown by a {@link Processor}
 *
 * @version $Revision: 659422 $
 */
public class CamelException extends Exception {
    public CamelException() {
    }
    public CamelException(String message) {
        super(message);
    }
    public CamelException(String message, Throwable cause) {
        super(message, cause);
    }
    public CamelException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.CamelExchangeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception caused by a specific message {@link Exchange}
 *
 * @version $Revision: 642753 $
 */
public class CamelExchangeException extends CamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final Exchange exchange;
    public CamelExchangeException(String message, Exchange exchange) {
        super(createMessage(message, exchange));
        this.exchange = exchange;
    }
    public CamelExchangeException(String message, Exchange exchange, Throwable cause) {
        super(createMessage(message, exchange), cause);
        this.exchange = exchange;
    }
    /**
     * Returns the exchange which caused the exception
     */
    public Exchange getExchange() {
        return exchange;
    }
    protected static String createMessage(String message, Exchange exchange) {
        return message + "" on the exchange: "" + exchange;
    }
}
"
org.apache.camel.CamelTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.impl.DefaultProducerTemplate;
/**
 * A client helper object (named like Spring's TransactionTemplate & JmsTemplate
 * et al) for working with Camel and sending {@link Message} instances in an
 * {@link Exchange} to an {@link Endpoint}.
 *
 * @version $Revision: 663882 $
 * @deprecated use {@link ProducerTemplate} instead, can be created using {@link org.apache.camel.CamelContext#createProducerTemplate()}. Will be removed in Camel 2.0
 */
@Deprecated
public class CamelTemplate<E extends Exchange> extends DefaultProducerTemplate<E> {
    public CamelTemplate(CamelContext context) {
        super(context);
    }
    public CamelTemplate(CamelContext context, Endpoint defaultEndpoint) {
        super(context, defaultEndpoint);
    }
}
"
org.apache.camel.Component,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A <a href=""http://activemq.apache.org/camel/component.html"">component</a> is
 * a factory of {@link Endpoint} objects.
 * 
 * @version $Revision: 630591 $
 */
public interface Component<E extends Exchange> {
    /**
     * Returns the context
     * 
     * @return the context of this component
     */
    CamelContext getCamelContext();
    /**
     * The {@link CamelContext} is injected into the component when it is added
     * to it
     */
    void setCamelContext(CamelContext context);
    /**
     * Attempt to resolve an endpoint for the given URI if the component is
     * capable of handling the URI
     * 
     * @param uri the URI to create
     * @return a newly created endpoint or null if this component cannot create
     *         instances of the given uri
     */
    Endpoint<E> createEndpoint(String uri) throws Exception;
}
"
org.apache.camel.Consumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A consumer of message exchanges from an {@link Endpoint}
 *
 * @version $Revision: 630591 $
 */
public interface Consumer<E extends Exchange> extends Service {
}
"
org.apache.camel.ContextTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.List;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.JndiRegistry;
import org.apache.camel.management.JmxSystemPropertyKeys;
import org.apache.camel.spi.Language;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.jndi.JndiTest;
/**
 * A useful base class which creates a {@link CamelContext} with some routes
 * along with a {@link ProducerTemplate} for use in the test case
 *
 * @version $Revision: 673135 $
 */
public abstract class ContextTestSupport extends TestSupport {
    protected CamelContext context;
    protected ProducerTemplate<Exchange> template;
    private boolean useRouteBuilder = true;
    private Service camelContextService;
    public boolean isUseRouteBuilder() {
        return useRouteBuilder;
    }
    public void setUseRouteBuilder(boolean useRouteBuilder) {
        this.useRouteBuilder = useRouteBuilder;
    }
    public Service getCamelContextService() {
        return camelContextService;
    }
    /**
     * Allows a service to be registered a separate lifecycle service to start
     * and stop the context; such as for Spring when the ApplicationContext is
     * started and stopped, rather than directly stopping the CamelContext
     */
    public void setCamelContextService(Service camelContextService) {
        this.camelContextService = camelContextService;
    }
    @Override
    protected void setUp() throws Exception {
        context = createCamelContext();
        assertValidContext(context);
        template = context.createProducerTemplate();
        if (useRouteBuilder) {
            RouteBuilder[] builders = createRouteBuilders();
            for (RouteBuilder builder : builders) {
                log.debug(""Using created route builder: "" + builder);
                context.addRoutes(builder);
            }
        } else {
            log.debug(""Using route builder from the created context: "" + context);
        }
        startCamelContext();
        log.debug(""Routing Rules are: "" + context.getRoutes());
    }
    @Override
    protected void tearDown() throws Exception {
        log.debug(""tearDown test: "" + getName());
        template.stop();
        stopCamelContext();
    }
    protected void stopCamelContext() throws Exception {
        if (camelContextService != null) {
            camelContextService.stop();
        } else {
            context.stop();
        }
    }
    protected void startCamelContext() throws Exception {
        if (camelContextService != null) {
            camelContextService.start();
        } else {
            if (context instanceof DefaultCamelContext) {
                DefaultCamelContext defaultCamelContext = (DefaultCamelContext)context;
                if (!defaultCamelContext.isStarted()) {
                    defaultCamelContext.start();
                }
            } else {
                context.start();
            }
        }
    }
    protected CamelContext createCamelContext() throws Exception {
        return new DefaultCamelContext(createRegistry());
    }
    protected JndiRegistry createRegistry() throws Exception {
        return new JndiRegistry(createJndiContext());
    }
    protected Context createJndiContext() throws Exception {
        return JndiTest.createInitialContext();
    }
    /**
     * Factory method which derived classes can use to create a {@link RouteBuilder}
     * to define the routes for testing
     */
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
                // no routes added by default
            }
        };
    }
    /**
     * Factory method which derived classes can use to create an array of
     * {@link RouteBuilder}s to define the routes for testing
     *
     * @see #createRouteBuilder()
     */
    protected RouteBuilder[] createRouteBuilders() throws Exception {
        return new RouteBuilder[] {createRouteBuilder()};
    }
    /**
     * Resolves a mandatory endpoint for the given URI or an exception is thrown
     *
     * @param uri the Camel <a href="""">URI</a> to use to create or resolve an endpoint
     * @return the endpoint
     */
    protected Endpoint resolveMandatoryEndpoint(String uri) {
        return resolveMandatoryEndpoint(context, uri);
    }
    /**
     * Resolves a mandatory endpoint for the given URI and expected type or an exception is thrown
     *
     * @param uri the Camel <a href="""">URI</a> to use to create or resolve an endpoint
     * @return the endpoint
     */
    protected <T extends Endpoint> T resolveMandatoryEndpoint(String uri, Class<T> endpointType) {
        return resolveMandatoryEndpoint(context, uri, endpointType);
    }
    /**
     * Resolves the mandatory Mock endpoint using a URI of the form <code>mock:someName</code>
     *
     * @param uri the URI which typically starts with ""mock:"" and has some name
     * @return the mandatory mock endpoint or an exception is thrown if it could not be resolved
     */
    protected MockEndpoint getMockEndpoint(String uri) {
        return resolveMandatoryEndpoint(uri, MockEndpoint.class);
    }
    /**
     * Sends a message to the given endpoint URI with the body value
     *
     * @param endpointUri the URI of the endpoint to send to
     * @param body        the body for the message
     */
    protected void sendBody(String endpointUri, final Object body) {
        template.send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""testCase"", getName());
            }
        });
    }
    /**
     * Sends a message to the given endpoint URI with the body value and specified headers
     *
     * @param endpointUri the URI of the endpoint to send to
     * @param body        the body for the message
     * @param headers     any headers to set on the message
     */
    protected void sendBody(String endpointUri, final Object body, final Map<String, Object> headers) {
        template.send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""testCase"", getName());
                for (Map.Entry<String, Object> entry : headers.entrySet()) {
                    in.setHeader(entry.getKey(), entry.getValue());
                }
            }
        });
    }
    /**
     * Sends messages to the given endpoint for each of the specified bodies
     *
     * @param endpointUri the endpoint URI to send to
     * @param bodies      the bodies to send, one per message
     */
    protected void sendBodies(String endpointUri, Object... bodies) {
        for (Object body : bodies) {
            sendBody(endpointUri, body);
        }
    }
    /**
     * Creates an exchange with the given body
     */
    protected Exchange createExchangeWithBody(Object body) {
        return createExchangeWithBody(context, body);
    }
    /**
     * Asserts that the given language name and expression evaluates to the
     * given value on a specific exchange
     */
    protected void assertExpression(Exchange exchange, String languageName, String expressionText, Object expectedValue) {
        Language language = assertResolveLanguage(languageName);
        Expression<Exchange> expression = language.createExpression(expressionText);
        assertNotNull(""No Expression could be created for text: "" + expressionText + "" language: "" + language, expression);
        assertExpression(expression, exchange, expectedValue);
    }
    /**
     * Asserts that the given language name and predicate expression evaluates
     * to the expected value on the message exchange
     */
    protected void assertPredicate(String languageName, String expressionText, Exchange exchange, boolean expected) {
        Language language = assertResolveLanguage(languageName);
        Predicate<Exchange> predicate = language.createPredicate(expressionText);
        assertNotNull(""No Predicate could be created for text: "" + expressionText + "" language: "" + language, predicate);
        assertPredicate(predicate, exchange, expected);
    }
    /**
     * Asserts that the language name can be resolved
     */
    protected Language assertResolveLanguage(String languageName) {
        Language language = context.resolveLanguage(languageName);
        assertNotNull(""No language found for name: "" + languageName, language);
        return language;
    }
    /**
     * Asserts that all the expectations of the Mock endpoints are valid
     */
    protected void assertMockEndpointsSatisifed() throws InterruptedException {
        MockEndpoint.assertIsSatisfied(context);
    }
    protected void assertValidContext(CamelContext context) {
        assertNotNull(""No context found!"", context);
    }
    protected <T> List<T> getSingletonEndpoints(Class<T> type) {
        return CamelContextHelper.getSingletonEndpoints(context, type);
    }
    protected <T extends Endpoint> T getMandatoryEndpoint(String uri, Class<T> type) {
        T endpoint = context.getEndpoint(uri, type);
        assertNotNull(""No endpoint found for uri: "" + uri, endpoint);
        return endpoint;
    }
    protected Endpoint getMandatoryEndpoint(String uri) {
        Endpoint endpoint = context.getEndpoint(uri);
        assertNotNull(""No endpoint found for uri: "" + uri, endpoint);
        return endpoint;
    }
    /**
     * Disables the JMX agent. Must be called before the {@link #setUp()} method.
     */
    protected void disableJMX() {
        System.setProperty(JmxSystemPropertyKeys.DISABLED, ""true"");
    }
    /**
     * Enables the JMX agent. Must be called before the {@link #setUp()} method.
     */
    protected void enableJMX() {
        System.setProperty(JmxSystemPropertyKeys.DISABLED, ""false"");
    }
}
"
org.apache.camel.Converter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation used to mark classes and methods to indicate code capable of
 * converting from a type to another type which are then auto-discovered using
 * the <a href=""http://activemq.apache.org/camel/type-converter.html"">Type
 * Conversion Support</a>
 * 
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD })
public @interface Converter {
}
"
org.apache.camel.Endpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
/**
 * An <a href=""http://activemq.apache.org/camel/endpoint.html"">endpoint</a>
 * implements the <a
 * href=""http://activemq.apache.org/camel/message-endpoint.html"">Message
 * Endpoint</a> pattern and represents an endpoint that can send and receive
 * message exchanges
 *
 * @see Exchange
 * @see Message
 * @version $Revision: 670567 $
 */
public interface Endpoint<E extends Exchange> {
    /**
     * Returns if the endpoint should be a CamelContext singleton. If the
     * endpoint is a Singleton, then a single Endpoint instance will be shared
     * by all routes with the same URI. Because the endpoint is shared, it
     * should be treated as an immutable.
     */
    boolean isSingleton();
    /**
     * Returns the string representation of the endpoint URI
     */
    String getEndpointUri();
    /**
     * Create a new exchange for communicating with this endpoint
     */
    E createExchange();
    /**
     * Create a new exchange for communicating with this endpoint
     * with the specified {@link ExchangePattern} such as whether its going
     * to be an {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut} exchange
     *
     * @param pattern the message exchange pattern for the exchange
     */
    E createExchange(ExchangePattern pattern);
    /**
     * Creates a new exchange for communicating with this exchange using the
     * given exchange to pre-populate the values of the headers and messages
     */
    E createExchange(Exchange exchange);
    /**
     * Returns the context which created the endpoint
     *
     * @return the context which created the endpoint
     */
    CamelContext getCamelContext();
    /**
     * Creates a new producer which is used send messages into the endpoint
     *
     * @return a newly created producer
     */
    Producer<E> createProducer() throws Exception;
    /**
     * Creates a new <a
     * href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event
     * Driven Consumer</a> which consumes messages from the endpoint using the
     * given processor
     *
     * @return a newly created consumer
     */
    Consumer<E> createConsumer(Processor processor) throws Exception;
    /**
     * Creates a new <a
     * href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling
     * Consumer</a> so that the caller can poll message exchanges from the
     * consumer using {@link PollingConsumer#receive()},
     * {@link PollingConsumer#receiveNoWait()} or
     * {@link PollingConsumer#receive(long)} whenever it is ready to do so
     * rather than using the <a
     * href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event
     * Based Consumer</a> returned by {@link #createConsumer(Processor)}
     *
     * @return a newly created pull consumer
     * @throws Exception if the pull consumer could not be created
     */
    PollingConsumer<E> createPollingConsumer() throws Exception;
    void configureProperties(Map options);
    void setCamelContext(CamelContext context);
    @Deprecated
    CamelContext getContext();
    @Deprecated
    void setContext(CamelContext context);
}
"
org.apache.camel.EndpointInject,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.spi.Registry;
/**
 * Used to indicate an injection point of an {@link Endpoint}, {@link Producer} or
 * {@link ProducerTemplate} into a POJO.
 *
 * A <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an endpoint
 * can be specified on this annotation, or a name can be specified which is resolved in the
 * {@link Registry} such as in your Spring ApplicationContext.
 *
 * If no name or uri is specified then the name is defaulted from the field, property or method name.
 *
 * @version $Revision: 662986 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface EndpointInject {
    String uri() default """";
    String name() default """";
}
"
org.apache.camel.Exchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
import org.apache.camel.spi.UnitOfWork;
/**
 * The base message exchange interface providing access to the request, response
 * and fault {@link Message} instances. Different providers such as JMS, JBI,
 * CXF and HTTP can provide their own derived API to expose the underlying
 * transport semantics to avoid the leaky abstractions of generic APIs.
 *
 * @version $Revision: 673008 $
 */
public interface Exchange {
    /**
     * Returns the {@link ExchangePattern} (MEP) of this exchange.
     *
     * @return the message exchange pattern of this exchange
     */
    ExchangePattern getPattern();
    /**
     * Allows the {@link ExchangePattern} (MEP) of this exchange to be customized.
     *
     * This typically won't be required as an exchange can be created with a specific MEP
     * by calling {@link Endpoint#createExchange(ExchangePattern)} but it is here just in case
     * it is needed.
     */
    void setPattern(ExchangePattern pattern);
    /**
     * Returns a property associated with this exchange by name
     *
     * @param name the name of the property
     * @return the value of the given header or null if there is no property for
     *         the given name
     */
    Object getProperty(String name);
    /**
     * Returns a property associated with this exchange by name and specifying
     * the type required
     *
     * @param name the name of the property
     * @param type the type of the property
     * @return the value of the given header or null if there is no property for
     *         the given name or null if it cannot be converted to the given
     *         type
     */
    <T> T getProperty(String name, Class<T> type);
    /**
     * Sets a property on the exchange
     *
     * @param name  of the property
     * @param value to associate with the name
     */
    void setProperty(String name, Object value);
    /**
     * Removes the given property on the exchange
     *
     * @param name of the property
     * @return the old value of the property
     */
    Object removeProperty(String name);
    /**
     * Returns all of the properties associated with the exchange
     *
     * @return all the headers in a Map
     */
    Map<String, Object> getProperties();
    /**
     * Returns the inbound request message
     *
     * @return the message
     */
    Message getIn();
    /**
     * Sets the inbound message instance
     *
     * @param in the inbound message
     */
    void setIn(Message in);
    /**
     * Returns the outbound message, lazily creating one if one has not already
     * been associated with this exchange. If you want to inspect this property
     * but not force lazy creation then invoke the {@link #getOut(boolean)}
     * method passing in <tt>false</tt>
     *
     * @return the response
     */
    Message getOut();
    /**
     * Returns the outbound message; optionally lazily creating one if one has
     * not been associated with this exchange
     *
     * @return the response
     */
    Message getOut(boolean lazyCreate);
    /**
     * Sets the outbound message
     *
     * @param out the outbound message
     */
    void setOut(Message out);
    /**
     * Returns the fault message
     *
     * @return the fault
     */
    Message getFault();
    /**
     * Returns the fault message; optionally lazily creating one if one has
     * not been associated with this exchange
     *
     * @param lazyCreate <tt>true</tt> will lazy create the fault message
     *
     * @return the fault
     */
    Message getFault(boolean lazyCreate);
    /**
     * Returns the exception associated with this exchange
     *
     * @return the exception (or null if no faults)
     */
    Throwable getException();
    /**
     * Sets the exception associated with this exchange
     *
     * @param e  the caused exception
     */
    void setException(Throwable e);
    /**
     * Returns true if this exchange failed due to either an exception or fault
     *
     * @return true if this exchange failed due to either an exception or fault
     * @see Exchange#getException()
     * @see Exchange#getFault()
     */
    boolean isFailed();
    /**
     * Returns true if this exchange is transacted
     */
    boolean isTransacted();
    /**
     * Returns the container so that a processor can resolve endpoints from URIs
     *
     * @return the container which owns this exchange
     */
    CamelContext getContext();
    /**
     * Creates a new exchange instance with empty messages, headers and properties
     */
    Exchange newInstance();
    /**
     * Creates a copy of the current message exchange so that it can be
     * forwarded to another destination
     */
    Exchange copy();
    /**
     * Copies the data into this exchange from the given exchange
     * 
     * @param source is the source from which headers and messages will be copied
     */
    void copyFrom(Exchange source);
    /**
     * Returns the unit of work that this exchange belongs to; which may map to
     * zero, one or more physical transactions
     */
    UnitOfWork getUnitOfWork();
    /**
     * Sets the unit of work that this exchange belongs to; which may map to
     * zero, one or more physical transactions
     */
    void setUnitOfWork(UnitOfWork unitOfWork);
    /**
     * Returns the exchange id
     *
     * @return the unique id of the exchange
     */
    String getExchangeId();
    /**
     * Set the exchange id
     *
     * @param id
     */
    void setExchangeId(String id);
}
"
org.apache.camel.ExchangePattern,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.HashMap;
import java.util.Map;
/**
 * Represents the kind of message exchange pattern
 *
 * @version $Revision: 660275 $
 */
public enum ExchangePattern {
    InOnly, RobustInOnly, InOut, InOptionalOut, OutOnly, RobustOutOnly, OutIn, OutOptionalIn;
    protected static final Map<String, ExchangePattern> MAP = new HashMap<String, ExchangePattern>();
    /**
     * Returns the WSDL URI for this message exchange pattern
     */
    public String getWsdlUri() {
        switch (this) {
        case InOnly:
            return ""http://www.w3.org/ns/wsdl/in-only"";
        case InOptionalOut:
            return ""http://www.w3.org/ns/wsdl/in-optional-out"";
        case InOut:
            return ""http://www.w3.org/ns/wsdl/in-out"";
        case OutIn:
            return ""http://www.w3.org/ns/wsdl/out-in"";
        case OutOnly:
            return ""http://www.w3.org/ns/wsdl/out-only"";
        case OutOptionalIn:
            return ""http://www.w3.org/ns/wsdl/out-optional_in"";
        case RobustInOnly:
            return ""http://www.w3.org/ns/wsdl/robust-in-only"";
        case RobustOutOnly:
            return ""http://www.w3.org/ns/wsdl/robust-out-only"";
        default:
            throw new IllegalArgumentException(""Unknown message exchange pattern: "" + this);
        }
    }
    /**
     * Return true if there can be an IN message
     */
    public boolean isInCapable() {
        switch (this) {
        case OutOnly:
        case RobustOutOnly:
            return false;
        default:
            return true;
        }
    }
    /**
     * Return true if there can be an OUT message
     */
    public boolean isOutCapable() {
        switch (this) {
        case InOnly:
        case RobustInOnly:
            return false;
        default:
            return true;
        }
    }
    /**
     * Return true if there can be a FAULT message
     */
    public boolean isFaultCapable() {
        switch (this) {
        case InOnly:
        case OutOnly:
            return false;
        default:
            return true;
        }
    }
    /**
     * Converts the WSDL URI into a {@link ExchangePattern} instance
     */
    public static ExchangePattern fromWsdlUri(String wsdlUri) {
        return MAP.get(wsdlUri);
    }
    static {
        for (ExchangePattern mep : values()) {
            String uri = mep.getWsdlUri();
            MAP.put(uri, mep);
            String name = uri.substring(uri.lastIndexOf('/') + 1);
            MAP.put(""http://www.w3.org/2004/08/wsdl/"" + name, mep);
            MAP.put(""http://www.w3.org/2006/01/wsdl/"" + name, mep);
        }
    }
}
"
org.apache.camel.ExchangePatternTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import junit.framework.TestCase;
/**
 * @version $Revision: 640438 $
 */
public class ExchangePatternTest extends TestCase {
    public void testExchangePattern() throws Exception {
        ExchangePattern mep = ExchangePattern.InOut;
        assertEquals(""WSDL Uri"", ""http://www.w3.org/ns/wsdl/in-out"", mep.getWsdlUri());
    }
    public void testStringToMEP() throws Exception {
        ExchangePattern mep = ExchangePattern.fromWsdlUri(""http://www.w3.org/ns/wsdl/in-only"");
        assertEquals(""MEP"", ExchangePattern.InOnly, mep);
    }
}
"
org.apache.camel.ExchangeProperty,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * Represents an instance and a type safe registry of well known Camel Exchange properties.
 * <p/>
 * <b>Usage pattern:</b>
 * <br/>In your code register a property that you wish to pass via Camel Exchange:
 * <pre>
 *      public static final ExchangeProperty<Boolean> myProperty =
 *            new ExchangeProperty<Boolean>(""myProperty"", ""org.apache.myproject.mypackage.myproperty"", Boolean.class);
 *
 *  Then in your code set this property's value:
 *      myProperty.set(exchange, Boolean.TRUE);
 *
 *  Check the value of this property where required:
 *      ExchangeProperty<?> property = ExchangeProperty.get(""myProperty"");
 *      if (property != null && property.get(exchange) == Boolean.TRUE) {
 *           // do your thing ...
 *       }
 *  Or
 *      Boolean value = myProperty.get(exchange);
 *      if (value == Boolean.TRUE) {
 *          // do your thing
 *      }
 *
 *  When your code no longer requires this property then deregister it:
 *      ExchangeProperty.deregister(myProperty);
 *  Or
 *      ExchangeProperty.deregister(""myProperty"");
 *  </pre>
 *
 *  <b>Note:</b> that if ExchangeProperty instance get or set methods are used then type checks
 *  of property's value are performed and a runtime exception can be thrown if type
 *  safety is violated.
 */
public class ExchangeProperty<T> {
    private static final List<ExchangeProperty<?>> VALUES =
        new ArrayList<ExchangeProperty<?>>();
    private static final Map<String, ExchangeProperty<?>> LITERAL_MAP =
        new HashMap<String, ExchangeProperty<?>>();
    private static final Map<String, ExchangeProperty<?>> NAME_MAP =
        new HashMap<String, ExchangeProperty<?>>();
    private final String literal;
    private final String name;
    private final Class<T> type;
    public ExchangeProperty(String literal, String name, Class<T> type) {
        this.literal = literal;
        this.name = name;
        this.type = type;
        register(this);
    }
    public String literal() {
        return literal;
    }
    public String name() {
        return name;
    }
    public Class<T> type() {
        return type;
    }
    public T get(Exchange exchange) {
        return exchange.getProperty(name, type);
    }
    public static ExchangeProperty<?> get(String literal) {
        return LITERAL_MAP.get(literal);
    }
    public static ExchangeProperty<?> getByName(String name) {
        return NAME_MAP.get(name);
    }
    public T set(Exchange exchange, T value) {
        T oldValue = get(exchange);
        exchange.setProperty(name, value);
        return oldValue;
    }
    public T remove(Exchange exchange) {
        T oldValue = get(exchange);
        exchange.removeProperty(name);
        return oldValue;
    }
    @Override
    public String toString() {
        return type().getCanonicalName() + "" "" + name + "" ("" + literal() + "")"";
    }
    public static synchronized void register(ExchangeProperty<?> property) {
        ExchangeProperty<?> existingProperty = LITERAL_MAP.get(property.literal());
        if (existingProperty != null && existingProperty != property) {
            throw new RuntimeCamelException(""An Exchange Property '"" + property.literal()
                    + ""' has already been registered; its traits are: "" + existingProperty.toString());
        }
        VALUES.add(property);
        LITERAL_MAP.put(property.literal(), property);
        NAME_MAP.put(property.name(), property);
    }
    public static synchronized void deregister(ExchangeProperty<?> property) {
        if (property != null) {
            VALUES.remove(property);
            LITERAL_MAP.remove(property.literal());
            NAME_MAP.put(property.name(), property);
        }
    }
    public static synchronized void deregister(String literal) {
        ExchangeProperty<?> property = LITERAL_MAP.get(literal);
        if (property != null) {
            VALUES.remove(property);
            LITERAL_MAP.remove(property.literal());
            NAME_MAP.put(property.name(), property);
        }
    }
    public static synchronized ExchangeProperty<?>[] values() {
        return VALUES.toArray(new ExchangeProperty[0]);
    }
}
"
org.apache.camel.ExchangePropertyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.impl.DefaultExchange;
public class ExchangePropertyTest extends ExchangeTestSupport {
    protected static final String P1_NAME = ""org.apache.myproject.mypackage.myproperty1"";
    protected static final String P2_NAME = ""org.apache.myproject.mypackage.myproperty2"";
    protected Exchange exchange;
    public void testExchangePropertyRegistry() throws Exception {
        ExchangeProperty<Boolean> myProperty1 = 
            new ExchangeProperty<Boolean>(""myProperty1"", P1_NAME, Boolean.class);
        assertEquals(ExchangeProperty.get(""myProperty1""), myProperty1);
        assertEquals(ExchangeProperty.values().length, 1); 
        assertEquals(ExchangeProperty.values()[0], myProperty1);
        ExchangeProperty<Boolean> myProperty2 = 
            new ExchangeProperty<Boolean>(""myProperty2"", P2_NAME, Boolean.class);
        assertEquals(ExchangeProperty.get(""myProperty2""), myProperty2);
        assertEquals(ExchangeProperty.values().length, 2); 
        assertEquals(ExchangeProperty.values()[1], myProperty2);
        try {
            ExchangeProperty<Boolean> rejectedProperty = 
                new ExchangeProperty<Boolean>(""myProperty2"", P2_NAME, Boolean.class);
            fail(""Expected RuntimeCamelException to be thrown due to duplicate property ""
                 + "" registration attempt"");
        } catch (RuntimeCamelException e) {
            assertEquals(ExchangeProperty.values().length, 2);
        } catch (Throwable t) {
            fail(""Expected RuntimeCamelException to be thrown due to duplicate propery ""
                    + "" registration attempt"");
        }
        ExchangeProperty.deregister(myProperty1);
        assertEquals(ExchangeProperty.get(""myProperty1""), null);
        ExchangeProperty.deregister(""myProperty2"");
        assertEquals(ExchangeProperty.get(""myProperty2""), null);
        assertEquals(ExchangeProperty.values().length, 0);
    }
    public void testExchangePropertySetterGetter() throws Exception {
        Exchange exchange = createExchange();
        ExchangeProperty<Boolean> myProperty1 = 
            new ExchangeProperty<Boolean>(""myProperty1"", P1_NAME, Boolean.class);
        ExchangeProperty<String> myProperty2 = 
            new ExchangeProperty<String>(""myProperty2"", P2_NAME, String.class);
        myProperty1.set(exchange, Boolean.TRUE);
        assertTrue(""Unexpected property value"", 
                    myProperty1.get(exchange) == Boolean.TRUE);
        assertTrue(""Unexpected property value"", 
                    ExchangeProperty.get(""myProperty1"").get(exchange) == Boolean.TRUE);
        myProperty2.set(exchange, ""camel"");
        assertTrue(""Unexpected property value"", 
                    myProperty2.get(exchange).equals(""camel""));
        assertTrue(""Unexpected property value"", 
                    ExchangeProperty.get(""myProperty2"").get(exchange).equals(""camel""));
        ExchangeProperty.deregister(myProperty1);
        assertEquals(ExchangeProperty.get(""myProperty1""), null);
        ExchangeProperty.deregister(""myProperty2"");
        assertEquals(ExchangeProperty.get(""myProperty2""), null);
        assertEquals(ExchangeProperty.values().length, 0);
    }
    public void testExchangePropertyTypeSafety() throws Exception {
        Exchange exchange = createExchange();
        ExchangeProperty<Boolean> myProperty1 = 
            new ExchangeProperty<Boolean>(""myProperty1"", P1_NAME, Boolean.class);
        try {
            exchange.setProperty(P1_NAME, ""camel"");
            fail(""Expected RuntimeCamelException to be thrown due to property value type cast violation"");
        } catch (RuntimeCamelException e) {
            // complete
        } catch (Throwable t) {
            fail(""Expected RuntimeCamelException to be thrown due to property value type cast violation"");
        }
        myProperty1.set(exchange, Boolean.TRUE);
        assertTrue(""Unexpected property value"", 
                myProperty1.get(exchange) == Boolean.TRUE);
        assertTrue(""Unexpected property value"", 
                ExchangeProperty.get(""myProperty1"").get(exchange) == Boolean.TRUE);
        ExchangeProperty.deregister(myProperty1);
        assertEquals(ExchangeProperty.get(""myProperty1""), null);
        assertEquals(ExchangeProperty.values().length, 0);
    }
}
"
org.apache.camel.ExchangeTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.impl.DefaultExchange;
/**
 * A base class for a test which requires a {@link CamelContext} and
 * a populated {@link Exchange}
 *
 * @version $Revision: 640438 $
 */
public abstract class ExchangeTestSupport extends ContextTestSupport {
    protected Exchange exchange;
    /**
     * A factory method to create an Exchange implementation
     */
    protected Exchange createExchange() {
        return new DefaultExchange(context);
    }
    /**
     * A strategy method to populate an exchange with some example values for use
     * by language plugins
     */
    protected void populateExchange(Exchange exchange) {
        Message in = exchange.getIn();
        in.setHeader(""foo"", ""abc"");
        in.setHeader(""bar"", 123);
        in.setBody(""<hello id='m123'>world!</hello>"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        exchange = createExchange();
        assertNotNull(""No exchange created!"", exchange);
        populateExchange(exchange);
    }
}
"
org.apache.camel.ExchangeTimedOutException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception thrown if an InOut exchange times out receiving the OUT message
 *
 * @version $Revision: 630591 $
 */
public class ExchangeTimedOutException extends CamelExchangeException {
    private final long timeout;
    public ExchangeTimedOutException(Exchange exchange, long timeout) {
        super(""The OUT message was not received within: "" + timeout + "" millis"", exchange);
        this.timeout = timeout;
    }
    /**
     * Return the timeout which expired in milliseconds
     */
    public long getTimeout() {
        return timeout;
    }
}
"
org.apache.camel.ExpectedBodyTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if the body could not be converted to the required type
 * 
 * @version $Revision: 630591 $
 */
public class ExpectedBodyTypeException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Class expectedBodyType;
    public ExpectedBodyTypeException(Exchange exchange, Class expectedBodyType) {
        super(""Could not extract IN message body as type: "" + expectedBodyType + "" body is: ""
              + exchange.getIn().getBody());
        this.exchange = exchange;
        this.expectedBodyType = expectedBodyType;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public Class getExpectedBodyType() {
        return expectedBodyType;
    }
}
"
org.apache.camel.Expression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An <a href=""http://activemq.apache.org/camel/expression.html"">expression</a>
 * provides a plugin strategy for evaluating expressions on a message exchange to support things like
 * <a href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting languages</a>,
 * <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well
 * as any arbitrary Java expression.
 *
 *
 * @version $Revision: 630591 $
 */
public interface Expression<E extends Exchange> {
    /**
     * Returns the value of the expression on the given exchange
     *
     * @param exchange the message exchange on which to evaluate the expression
     * @return the value of the expression
     */
    Object evaluate(E exchange);
}
"
org.apache.camel.FailedToCreateProducerException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if Camel failed to create a producer for a given endpoint.
 *
 * @version $Revision: 659422 $
 */
public class FailedToCreateProducerException extends RuntimeCamelException {
    private final Endpoint endpoint;
    public FailedToCreateProducerException(Endpoint endpoint, Throwable cause) {
        super(""Failed to create Producer for endpoint: "" + endpoint + "". Reason: "" + cause, cause);
        this.endpoint = endpoint;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
}
"
org.apache.camel.Header,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being a header on an inbound {@link Message}
 *
 * @see Message#getHeader(String) 
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Header {
    String name();
}
"
org.apache.camel.Headers,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the headers of an inbound {@link Message}
 *
 * @see Message#getHeaders()
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Headers {
}
"
org.apache.camel.InjectorDefaultsToReflectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import junit.framework.TestCase;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.spi.Injector;
import org.apache.camel.util.ReflectionInjector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 659638 $
 */
public class InjectorDefaultsToReflectionTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(InjectorDefaultsToReflectionTest.class);
    public void testInjectorIsReflectionByDefault() throws Exception {
        Injector injector = new DefaultCamelContext().getInjector();
        assertTrue(""Injector should be reflection based but was: "" + injector,
                   injector instanceof ReflectionInjector);
        LOG.debug(""Found injector: "" + injector);
    }
}
"
org.apache.camel.Intercept,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An interface which provides the processing logic as a pluggable processor
 *
 * @version $Revision: 673954 $
 */
public interface Intercept {
    Processor getInterceptorLogic();
    void setInterceptorLogic(Processor interceptorLogic);
}
"
org.apache.camel.InvalidHeaderTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @deprecated use {@link InvalidTypeException}. Will be removed in Camel 2.0.
 * @version $Revision: 663882 $
 */
@Deprecated
public class InvalidHeaderTypeException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    private final Object headerValue;
    public InvalidHeaderTypeException(Throwable cause, Object headerValue) {
        super(cause.getMessage() + "" headerValue is: "" + headerValue + "" of type: "" + typeName(headerValue),
              cause);
        this.headerValue = headerValue;
    }
    public InvalidHeaderTypeException(String message, Object headerValue) {
        super(message);
        this.headerValue = headerValue;
    }
    /**
     * Returns the actual header value
     */
    public Object getHeaderValue() {
        return headerValue;
    }
    protected static String typeName(Object headerValue) {
        return (headerValue != null) ? headerValue.getClass().getName() : ""null"";
    }
}
"
org.apache.camel.InvalidPayloadException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Is thrown if the payload from the exchange could not be retrieve because of being null, wrong class type etc.
 *
 * @version $Revision: 659422 $
 */
public class InvalidPayloadException extends CamelExchangeException {
    private final Class<?> type;
    public InvalidPayloadException(Exchange exchange, Class<?> type) {
        this(exchange, type, exchange.getIn());
    }
    public InvalidPayloadException(Exchange exchange, Class<?> type, Message message) {
        super(""No in body available of type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(message.getBody()) + "" on: "" + message, exchange);
        this.type = type;
    }
    /**
     * The expected type of the body
     */
    public Class<?> getType() {
        return type;
    }
}
"
org.apache.camel.InvalidPayloadRuntimeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Runtime version of the {@link org.apache.camel.InvalidTypeException}.
 *
 * @version $Revision: 659422 $
 */
public class InvalidPayloadRuntimeException extends RuntimeExchangeException {
    private final Class<?> type;
    public InvalidPayloadRuntimeException(Exchange exchange, Class<?> type) {
        super(""No in body available of type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(exchange.getIn().getBody()), exchange);
        this.type = type;
    }
    /**
     * The expected type of the body
     */
    public Class<?> getType() {
        return type;
    }
}
"
org.apache.camel.InvalidTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Is thrown if type conversion failed.
 *
 * @version $Revision: 659422 $
 */
public class InvalidTypeException extends CamelExchangeException {
    private final Object value;
    private final Class<?> type;
    public InvalidTypeException(Exchange exchange, Object value, Class<?> type) {
        super(""Could not convert value: "" + value + "" to type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(value), exchange);
        this.value = value;
        this.type = type;
    }
    /**
     * The value
     */
    public Object getValue() {
        return value;
    }
    /**
     * The expected type of the value
     */
    public Class<?> getType() {
        return type;
    }
}
"
org.apache.camel.LanguageTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A useful base class for testing the language plugins in Camel
 * @version $Revision: 659842 $
 */
public abstract class LanguageTestSupport extends ExchangeTestSupport {
    protected abstract String getLanguageName();
    /**
     * Asserts that the given predicate expression evaluated on the current language and message
     * exchange evaluates to true
     */
    protected void assertPredicate(String expression) {
        assertPredicate(exchange, expression, true);
    }
    /**
     * Asserts that the given predicate expression evaluated on the current language and message
     * exchange evaluates to false
     */
    protected void assertPredicateFails(String expression) {
        assertPredicate(exchange, expression, false);
    }
    /**
     * Asserts that the given predicate expression evaluated on the current language and message
     * exchange evaluates to the expected value
     */
    protected void assertPredicate(String expression, boolean expected) {
        assertPredicate(exchange, expression, expected);
    }
    protected void assertPredicate(Exchange exchange, String expression, boolean expected) {
        assertPredicate(getLanguageName(), expression, exchange, expected);
    }
    /**
     * Asserts that this language expression evaluates to the given value on the given exchange
     */
    protected void assertExpression(Exchange exchange, String expressionText, Object expectedValue) {
        assertExpression(exchange, getLanguageName(), expressionText, expectedValue);
    }
    /**
     * Asserts that this language expression evaluates to the given value on the current exchange
     */
    protected void assertExpression(String expressionText, Object expectedValue) {
        assertExpression(exchange, expressionText, expectedValue);
    }
}
"
org.apache.camel.Message,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
import java.util.Set;
import javax.activation.DataHandler;
/**
 * Implements the <a
 * href=""http://activemq.apache.org/camel/message.html"">Message</a> pattern and
 * represents an inbound or outbound message as part of an {@link Exchange}
 *
 * @version $Revision: 653092 $
 */
public interface Message {
    /**
     * Returns the id of the message
     *
     * @return the id of the message
     */
    String getMessageId();
    /**
     * Sets the id of the message
     *
     * @param messageId
     */
    void setMessageId(String messageId);
    /**
     * Returns the exchange this message is related to
     */
    Exchange getExchange();
    /**
     * Accesses a specific header
     *
     * @param name  name of header
     * @return object header associated with the name
     */
    Object getHeader(String name);
    /**
     * Returns a header associated with this message by name and specifying the
     * type required
     *
     * @param name the name of the header
     * @param type the type of the header
     * @return the value of the given header or null if there is no property for
     *         the given name or it cannot be converted to the given type
     */
    <T> T getHeader(String name, Class<T> type);
    /**
     * Sets a header on the message
     *
     * @param name of the header
     * @param value to associate with the name
     */
    void setHeader(String name, Object value);
    /**
     * Removes the named header from this message
     *
     * @param name
     * @return the old value of the header
     */
    Object removeHeader(String name);
    /**
     * Returns all of the headers associated with the message
     *
     * @return all the headers in a Map
     */
    Map<String, Object> getHeaders();
    /**
     * Set all the headers associated with this message
     *
     * @param headers
     */
    void setHeaders(Map<String, Object> headers);
    /**
     * Returns the body of the message as a POJO
     *
     * @return the body of the message
     */
    Object getBody();
    /**
     * Returns the body as the specified type
     *
     * @param type the type that the body
     * @return the body of the message as the specified type
     */
    <T> T getBody(Class<T> type);
    /**
     * Sets the body of the message
     */
    void setBody(Object body);
    /**
     * Sets the body of the message as a specific type
     */
    <T> void setBody(Object body, Class<T> type);
    /**
     * Creates a copy of this message so that it can be used and possibly
     * modified further in another exchange
     *
     * @return a new message instance copied from this message
     */
    Message copy();
    /**
     * Copies the contents of the other message into this message
     */
    void copyFrom(Message message);
    /**
     * Returns the attachment specified by the id
     *
     * @param id        the id under which the attachment is stored
     * @return          the data handler for this attachment or null
     */
    DataHandler getAttachment(String id);
    /**
     * Returns a set of attachment names of the message
     *
     * @return  a set of attachment names
     */
    Set<String> getAttachmentNames();
    /**
     * Removes the attachment specified by the id
     *
     * @param id        the id of the attachment to remove
     */
    void removeAttachment(String id);
    /**
     * Adds an attachment to the message using the id
     *
     * @param id        the id to store the attachment under
     * @param content   the data handler for the attachment
     */
    void addAttachment(String id, DataHandler content);
    /**
     * Returns all attachments of the message
     *
     * @return  the attachments in a map or null
     */
    Map<String, DataHandler> getAttachments();
    /**
     * Set all the attachments associated with this message
     *
     * @param attachments
     */
    void setAttachments(Map<String, DataHandler> attachments);
    /**
     * Returns <tt>true</tt> if this message has any attachments.
     */
    boolean hasAttachments();
}
"
org.apache.camel.MessageDriven,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to indicate a method on a POJO which is used as a {@link Consumer} of
 * {@link Exchange} instances to process {@link Message} instances.
 * 
 * Either a <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an
 * endpoint should be configured, or a name of an endpoint which refers to a
 * Spring bean name in your Spring ApplicationContext.
 * 
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface MessageDriven {
    String uri() default """";
    String name() default """";
}
"
org.apache.camel.NoSuchBeanException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.spi.Registry;
/**
 * A runtime exception if a given bean could not be found in the {@link Registry}
 *
 * @version $Revision: 630591 $
 */
public class NoSuchBeanException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String name;
    public NoSuchBeanException(String name) {
        super(""No bean could be found in the registry for: "" + name);
        this.name = name;
    }
    public String getName() {
        return name;
    }
}
"
org.apache.camel.NoSuchEndpointException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if a routing processor such as a
 * {@link org.apache.camel.processor.RecipientList RecipientList} is unable to resolve an
 * {@link Endpoint} from a URI.
 *
 * @version $Revision: 642753 $
 */
public class NoSuchEndpointException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String uri;
    public NoSuchEndpointException(String uri) {
        super(""No endpoint could be found for: "" + uri);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.NoSuchHeaderException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.util.ExchangeHelper;
/**
 * An exception caused when a mandatory header is not available on a message
 * {@link Exchange}
 *
 * @see ExchangeHelper#getMandatoryHeader(Exchange, String, Class)
 *
 * @version $Revision: 633440 $
 */
public class NoSuchHeaderException extends CamelExchangeException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String headerName;
    private final Class<?> type;
    public NoSuchHeaderException(Exchange exchange, String headerName, Class<?> type) {
        super(""No '"" + headerName + ""' header available of type: "" + type.getName()
              + reason(exchange, headerName), exchange);
        this.headerName = headerName;
        this.type = type;
    }
    public String getHeaderName() {
        return headerName;
    }
    public Class<?> getType() {
        return type;
    }
    protected static String reason(Exchange exchange, String propertyName) {
        Object value = exchange.getProperty(propertyName);
        return valueDescription(value);
    }
    static String valueDescription(Object value) {
        if (value == null) {
            return """";
        }
        return "" but has value: "" + value + "" of type: "" + value.getClass().getName();
    }
}
"
org.apache.camel.NoSuchLanguageException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if an attempt is made to resolve an unknown
 * language definition.
 * 
 * @see org.apache.camel.CamelContext#resolveLanguage(String)
 * 
 * @version $Revision: 630591 $
 */
public class NoSuchLanguageException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String language;
    public NoSuchLanguageException(String language) {
        super(""No language could be found for: "" + language);
        this.language = language;
    }
    public String getLanguage() {
        return language;
    }
}
"
org.apache.camel.NoSuchPropertyException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.util.ExchangeHelper;
/**
 * An exception caused when a mandatory property is not available on a message
 * {@link Exchange}
 * 
 * @see ExchangeHelper#getMandatoryProperty(Exchange, String, Class)
 * 
 * @version $Revision: 633440 $
 */
public class NoSuchPropertyException extends CamelExchangeException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String propertyName;
    private final Class<?> type;
    public NoSuchPropertyException(Exchange exchange, String propertyName, Class<?> type) {
        super(""No '"" + propertyName + ""' property available of type: "" + type.getName()
              + reason(exchange, propertyName), exchange);
        this.propertyName = propertyName;
        this.type = type;
    }
    public String getPropertyName() {
        return propertyName;
    }
    public Class<?> getType() {
        return type;
    }
    protected static String reason(Exchange exchange, String propertyName) {
        Object value = exchange.getProperty(propertyName);
        return valueDescription(value);
    }
    static String valueDescription(Object value) {
        if (value == null) {
            return """";
        }
        return "" but has value: "" + value + "" of type: "" + value.getClass().getName();
    }
}
"
org.apache.camel.NoTypeConversionAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception thrown if a value could not be converted to the required type
 *
 * @version $Revision: 655720 $
 */
public class NoTypeConversionAvailableException extends RuntimeCamelException {
    private final Object value;
    private final Class type;
    public NoTypeConversionAvailableException(Object value, Class type) {
        super(""No type converter available to convert from type: "" + (value != null ? value.getClass() : null)
              + "" to the required type "" + type.getName() + "" with value "" + value);
        this.value = value;
        this.type = type;
    }
    /**
     * Returns the value which could not be converted
     */
    public Object getValue() {
        return value;
    }
    /**
     * Returns the required <tt>to</tt> type
     */
    public Class getType() {
        return type;
    }
    /**
     * Returns the required <tt>from</tt> type.
     * Returns <tt>null</tt> if the provided value was null.
     */
    public Class getFromType() {
        if (value != null) {
            return value.getClass();
        } else {
            return null;
        }
    }
}
"
org.apache.camel.OutHeaders,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the headers of an outbound {@link Message}
 *
 * @see Message#getHeaders()
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface OutHeaders {
}
"
org.apache.camel.PollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Represents a <a
 * href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling
 * Consumer</a> where the caller polls for messages when it is ready.
 * 
 * @version $Revision: 630591 $
 */
public interface PollingConsumer<E extends Exchange> extends Consumer<E> {
    /**
     * Waits until a message is available and then returns it. Warning that this
     * method could block indefinitely if no messages are available.
     * 
     * @return the message exchange received.
     */
    E receive();
    /**
     * Attempts to receive a message exchange immediately without waiting and
     * returning null if a message exchange is not available yet.
     * 
     * @return the message exchange if one is immediately available otherwise
     *         null
     */
    E receiveNoWait();
    /**
     * Attempts to receive a message exchange, waiting up to the given timeout
     * to expire if a message is not yet available
     * 
     * @param timeout the amount of time in milliseconds to wait for a message
     *                before timing out and returning null
     * 
     * @return the message exchange if one iwas available within the timeout
     *         period, or null if the timeout expired
     */
    E receive(long timeout);
}
"
org.apache.camel.Predicate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Evaluates a binary <a
 * href=""http://activemq.apache.org/camel/predicate.html"">predicate</a> on the
 * message exchange to support things like <a
 * href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting
 * languages</a>, <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well as
 * any arbitrary Java expression.
 * 
 * @version $Revision: 630591 $
 */
public interface Predicate<E> {
    /**
     * Evaluates the predicate on the message exchange and returns true if this
     * exchange matches the predicate
     * 
     * @param exchange the message exchange
     * @return true if the predicate matches
     */
    boolean matches(E exchange);
    /**
     * Allows this predicate to be used nicely in testing to generate a nicely
     * formatted exception and message if this predicate does not match for the
     * given exchange.
     * 
     * @param text the description to use in the exception message
     * @param exchange the exchange to evaluate the expression on
     * @throws AssertionError if the predicate does not match
     */
    void assertMatches(String text, E exchange) throws AssertionError;
}
"
org.apache.camel.Processor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A <a href=""http://activemq.apache.org/camel/processor.html"">processor</a> is
 * used to implement the 
 * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">
 * Event Driven Consumer</a> and 
 * <a href=""http://activemq.apache.org/camel/message-translator.html"">
 * Message Translator</a> patterns and to process message exchanges.
 * 
 * @version $Revision: 662664 $
 */
public interface Processor {
    /**
     * Processes the message exchange
     * 
     * @throws Exception if an internal processing error has occurred.
     */
    void process(Exchange exchange) throws Exception;
}
"
org.apache.camel.Producer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Provides a channel on which clients can create and invoke message exchanges
 * on an {@link Endpoint}
 * 
 * @version $Revision: 630591 $
 */
public interface Producer<E extends Exchange> extends Processor, Service {
    Endpoint<E> getEndpoint();
    /**
     * Creates a new exchange to send to this endpoint
     * 
     * @return a newly created exchange
     */
    E createExchange();
    /**
     * Creates a new exchange of the given pattern to send to this endpoint
     *
     * @return a newly created exchange
     */
    E createExchange(ExchangePattern pattern);
    /**
     * Creates a new exchange for communicating with this exchange using the
     * given exchange to pre-populate the values of the headers and messages
     */
    E createExchange(E exchange);
}
"
org.apache.camel.ProducerTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
/**
 * Template (named like Spring's TransactionTemplate & JmsTemplate
 * et al) for working with Camel and sending {@link Message} instances in an
 * {@link Exchange} to an {@link Endpoint}.
 *
 * @version $Revision: 659422 $
 */
public interface ProducerTemplate<E extends Exchange> extends Service {
    /**
     * Sends the exchange to the default endpoint
     *
     * @param exchange the exchange to send
     */
    E send(E exchange);
    /**
     * Sends an exchange to the default endpoint using a supplied
     *
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     */
    E send(Processor processor);
    /**
     * Sends the body to the default endpoint and returns the result content
     *
     * @param body the body to send
     * @return the returned message body
     */
    Object sendBody(Object body);
    /**
     * Sends the body to the default endpoint with a specified header and header
     * value
     *
     * @param body        the payload send
     * @param header      the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(Object body, String header, Object headerValue);
    /**
     * Sends the body to the default endpoint with the specified headers and
     * header values
     *
     * @param body the payload send
     * @return the result
     */
    Object sendBodyAndHeaders(Object body, Map<String, Object> headers);
    // Allow sending to arbitrary endpoints
    // -----------------------------------------------------------------------
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param exchange    the exchange to send
     */
    E send(String endpointUri, E exchange);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor   the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     */
    E send(String endpointUri, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param pattern     the message {@link ExchangePattern} such as
     *                    {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor   the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     */
    E send(String endpointUri, ExchangePattern pattern, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor   the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange.
     * @param callback    the callback will be called when the exchange is completed.
     */
    E send(String endpointUri, Processor processor, AsyncCallback callback);
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    E send(Endpoint<E> endpoint, E exchange);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     */
    E send(Endpoint<E> endpoint, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param pattern   the message {@link ExchangePattern} such as
     *                  {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange
     */
    E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied processor
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     * {@link Processor} to populate the exchange.
     * @param callback  the callback will be called when the exchange is completed.
     */
    E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint   the endpoint to send the exchange to
     * @param body       the payload
     * @return the result
     */
    Object sendBody(Endpoint<E> endpoint, Object body);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpointUri   the endpoint URI to send the exchange to
     * @param body          the payload
     * @return the result
     */
    Object sendBody(String endpointUri, Object body);
    /**
     * Send the body to an endpoint with the given {@link ExchangePattern}
     * returning any result output body
     *
     * @param endpoint      the endpoint to send the exchange to
     * @param body          the payload
     * @param pattern       the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @return the result
     */
    Object sendBody(Endpoint<E> endpoint, ExchangePattern pattern, Object body);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpointUri   the endpoint URI to send the exchange to
     * @param pattern       the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body          the payload
     * @return the result
     */
    Object sendBody(String endpointUri, ExchangePattern pattern, Object body);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpointUri the endpoint URI to send to
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(String endpointUri, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint to send to
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(Endpoint endpoint, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(Endpoint endpoint, ExchangePattern pattern, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint URI to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(String endpoint, ExchangePattern pattern, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpointUri the endpoint URI to send to
     * @param body the payload send
     * @return the result
     */
    Object sendBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpoint the endpoint URI to send to
     * @param body the payload send
     * @return the result
     */
    Object sendBodyAndHeaders(Endpoint endpoint, Object body, Map<String, Object> headers);
    // Methods using an InOut ExchangePattern
    // -----------------------------------------------------------------------
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpoint  the Endpoint to send to
     * @param processor the processor which will populate the exchange before sending
     * @return the result
     */
    E request(Endpoint<E> endpoint, Processor processor);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpoint the Endpoint to send to
     * @param body     the payload
     * @return the result
     */
    Object requestBody(Endpoint<E> endpoint, Object body);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpoint    the Endpoint to send to
     * @param body        the payload
     * @param header      the header name
     * @param headerValue the header value
     * @return the result
     */
    Object requestBodyAndHeader(Endpoint<E> endpoint, Object body, String header, Object headerValue);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpointUri the endpoint URI to send to
     * @param processor the processor which will populate the exchange before sending
     * @return the result
     */
    E request(String endpointUri, Processor processor);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpointUri the endpoint URI to send to
     * @param body        the payload
     * @return the result
     */
    Object requestBody(String endpointUri, Object body);
    /**
     * Send the body to an endpoint returning any result output body.
     * Uses an {@link ExchangePattern#InOut} message exchange pattern.
     *
     * @param endpointUri the endpoint URI to send to
     * @param body        the payload
     * @param header      the header name
     * @param headerValue the header value
     * @return the result
     */
    Object requestBodyAndHeader(String endpointUri, Object body, String header, Object headerValue);
}
"
org.apache.camel.Properties,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the properties of an {@link Exchange}
 *
 * @see Exchange#getProperties()  
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Properties {
}
"
org.apache.camel.Property,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of a property of an {@link Exchange}
 *
 * @see Exchange#getProperty(String)  
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Property {
    String name();
}
"
org.apache.camel.ResolveEndpointFailedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if an {@link Endpoint} can not be resolved via URI
 * 
 * @version $Revision: 655341 $
 */
public class ResolveEndpointFailedException extends RuntimeCamelException {
    private final String uri;
    public ResolveEndpointFailedException(String uri, Throwable cause) {
        super(""Failed to resolve endpoint: "" + uri + "" due to: "" + cause, cause);
        this.uri = uri;
    }
    public ResolveEndpointFailedException(String uri, String message) {
        super(""Failed to resolve endpoint: "" + uri + "" due to: "" + message);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.Route,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * A <a href=""http://activemq.apache.org/camel/routes.html"">Route</a>
 * defines the processing used on an inbound message exchange
 * from a specific {@link Endpoint} within a {@link CamelContext}
 *
 * @version $Revision: 642753 $
 */
public class Route<E extends Exchange> {
    public static final String PARENT_PROPERTY = ""parent"";
    public static final String GROUP_PROPERTY = ""group"";
    private final Map<String, Object> properties = new HashMap<String, Object>(16);
    private Endpoint<E> endpoint;
    private List<Service> services = new ArrayList<Service>();
    public Route(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    public Route(Endpoint<E> endpoint, Service... services) {
        this(endpoint);
        for (Service service : services) {
            addService(service);
        }
    }
    @Override
    public String toString() {
        return ""Route"";
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    /**
     * This property map is used to associate information about
     * the route.
     */
    public Map<String, Object> getProperties() {
        return properties;
    }
    public List<Service> getServicesForRoute() throws Exception {
        List<Service> servicesForRoute = new ArrayList<Service>(getServices());
        addServices(servicesForRoute);
        return servicesForRoute;
    }
    /**
     * Returns the additional services required for this particular route
     */
    public List<Service> getServices() {
        return services;
    }
    public void setServices(List<Service> services) {
        this.services = services;
    }
    public void addService(Service service) {
        getServices().add(service);
    }
    /**
     * Strategy method to allow derived classes to lazily load services for the route
     */
    protected void addServices(List<Service> services) throws Exception {
    }
}
"
org.apache.camel.Routes,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.List;
public interface Routes {
    CamelContext getContext();
    void setContext(CamelContext context);
    List<Route> getRouteList() throws Exception;
}
"
org.apache.camel.RuntimeCamelException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Base class for all Camel unchecked exceptions.
 *
 * @version $Revision: 659422 $
 */
public class RuntimeCamelException extends RuntimeException {
    private static final long serialVersionUID = 8046489554418284257L;
    public RuntimeCamelException() {
    }
    public RuntimeCamelException(String message) {
        super(message);
    }
    public RuntimeCamelException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeCamelException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.RuntimeExchangeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception caused by a specific message {@link Exchange}
 *
 * @version $Revision: 642753 $
 */
public class RuntimeExchangeException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final Exchange exchange;
    public RuntimeExchangeException(String message, Exchange exchange) {
        super(message + "" on the exchange: "" +  exchange);
        this.exchange = exchange;
    }
    public RuntimeExchangeException(Exception e, Exchange exchange) {
        super(e.getMessage(), e);
        this.exchange = exchange;
    }
    /**
     * Returns the exchange which caused the exception
     */
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.RuntimeExpressionException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if an expression evaluation fails
 * 
 * @version $Revision: 630591 $
 */
public class RuntimeExpressionException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    public RuntimeExpressionException(String message) {
        super(message);
    }
    public RuntimeExpressionException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeExpressionException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.RuntimeTransformException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if a message transformation fails
 * 
 * @version $Revision: 630591 $
 */
public class RuntimeTransformException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    public RuntimeTransformException(String message) {
        super(message);
    }
    public RuntimeTransformException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeTransformException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.Service,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Represents the core lifecycle API for POJOs which can be started and stopped
 * 
 * @version $Revision: 630591 $
 */
public interface Service {
    /**
     * Starts the service
     * 
     * @throws Exception
     */
    void start() throws Exception;
    /**
     * Stops the service
     * 
     * @throws Exception
     */
    void stop() throws Exception;
}
"
org.apache.camel.TestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.io.File;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.builder.Builder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.ValueBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.processor.DelegateAsyncProcessor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A bunch of useful testing methods
 *
 * @version $Revision: 655839 $
 */
public abstract class TestSupport extends TestCase {
    protected transient Log log = LogFactory.getLog(getClass());
    // Builder methods for expressions used when testing
    // -------------------------------------------------------------------------
    /**
     * Returns a value builder for the given header
     */
    public <E extends Exchange> ValueBuilder<E> header(String name) {
        return Builder.header(name);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public ValueBuilder body() {
        return Builder.body();
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> ValueBuilder bodyAs(Class<T> type) {
        return Builder.bodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public ValueBuilder outBody() {
        return Builder.outBody();
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> ValueBuilder outBodyAs(Class<T> type) {
        return Builder.outBodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public ValueBuilder faultBody() {
        return Builder.faultBody();
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public <T> ValueBuilder faultBodyAs(Class<T> type) {
        return Builder.faultBodyAs(type);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name) {
        return Builder.systemProperty(name);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name, String defaultValue) {
        return Builder.systemProperty(name, defaultValue);
    }
    // Assertions
    // -----------------------------------------------------------------------
    protected <T> T assertIsInstanceOf(Class<T> expectedType, Object value) {
        assertNotNull(""Expected an instance of type: "" + expectedType.getName() + "" but was null"", value);
        assertTrue(""object should be a "" + expectedType.getName() + "" but was: "" + value + "" with type: ""
                   + value.getClass().getName(), expectedType.isInstance(value));
        return expectedType.cast(value);
    }
    protected void assertEndpointUri(Endpoint<Exchange> endpoint, String uri) {
        assertNotNull(""Endpoint is null when expecting endpoint for: "" + uri, endpoint);
        assertEquals(""Endoint uri for: "" + endpoint, uri, endpoint.getEndpointUri());
    }
    /**
     * Asserts the In message on the exchange contains the expected value
     */
    protected Object assertInMessageHeader(Exchange exchange, String name, Object expected) {
        return assertMessageHeader(exchange.getIn(), name, expected);
    }
    /**
     * Asserts the Out message on the exchange contains the expected value
     */
    protected Object assertOutMessageHeader(Exchange exchange, String name, Object expected) {
        return assertMessageHeader(exchange.getOut(), name, expected);
    }
    /**
     * Asserts that the given exchange has an OUT message of the given body value
     * @param exchange the exchange which should have an OUT message
     * @param expected the expected value of the OUT message
     * @throws InvalidPayloadException
     */
    protected void assertInMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {
        assertNotNull(""Should have a response exchange!"", exchange);
        Object actual;
        if (expected == null) {
            actual = ExchangeHelper.getMandatoryInBody(exchange);
            assertEquals(""in body of: "" + exchange, expected, actual);
        } else {
            actual = ExchangeHelper.getMandatoryInBody(exchange, expected.getClass());
        }
        assertEquals(""in body of: "" + exchange, expected, actual);
        log.debug(""Received response: "" + exchange + "" with in: "" + exchange.getIn());
    }
    /**
     * Asserts that the given exchange has an OUT message of the given body value
     * @param exchange the exchange which should have an OUT message
     * @param expected the expected value of the OUT message
     * @throws InvalidPayloadException
     */
    protected void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {
        assertNotNull(""Should have a response exchange!"", exchange);
        Object actual;
        if (expected == null) {
            actual = ExchangeHelper.getMandatoryOutBody(exchange);
            assertEquals(""output body of: "" + exchange, expected, actual);
        } else {
            actual = ExchangeHelper.getMandatoryOutBody(exchange, expected.getClass());
        }
        assertEquals(""output body of: "" + exchange, expected, actual);
        log.debug(""Received response: "" + exchange + "" with out: "" + exchange.getOut());
    }
    protected Object assertMessageHeader(Message message, String name, Object expected) {
        Object value = message.getHeader(name);
        assertEquals(""Header: "" + name + "" on Message: "" + message, expected, value);
        return value;
    }
    /**
     * Asserts that the given expression when evaluated returns the given answer
     */
    protected Object assertExpression(Expression expression, Exchange exchange, Object expected) {
        Object value = expression.evaluate(exchange);
        // lets try convert to the type of the expected
        if (expected != null) {
            value = ExchangeHelper.convertToType(exchange, expected.getClass(), value);
        }
        log.debug(""Evaluated expression: "" + expression + "" on exchange: "" + exchange + "" result: "" + value);
        assertEquals(""Expression: "" + expression + "" on Exchange: "" + exchange, expected, value);
        return value;
    }
    /**
     * Asserts that the predicate returns the expected value on the exchange
     */
    protected void assertPredicateMatches(Predicate predicate, Exchange exchange) {
        assertPredicate(predicate, exchange, true);
    }
    /**
     * Asserts that the predicate returns the expected value on the exchange
     */
    protected void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {
        try {
            predicate.assertMatches(""Predicate should match"", exchange);
        } catch (AssertionError e) {
            log.debug(""Caught expected assertion error: "" + e);
        }
        assertPredicate(predicate, exchange, false);
    }
    /**
     * Asserts that the predicate returns the expected value on the exchange
     */
    protected boolean assertPredicate(Predicate predicate, Exchange exchange, boolean expected) {
        if (expected) {
            predicate.assertMatches(""Predicate failed"", exchange);
        }
        boolean value = predicate.matches(exchange);
        log.debug(""Evaluated predicate: "" + predicate + "" on exchange: "" + exchange + "" result: "" + value);
        assertEquals(""Predicate: "" + predicate + "" on Exchange: "" + exchange, expected, value);
        return value;
    }
    /**
     * Resolves an endpoint and asserts that it is found
     */
    protected Endpoint resolveMandatoryEndpoint(CamelContext context, String uri) {
        Endpoint endpoint = context.getEndpoint(uri);
        assertNotNull(""No endpoint found for URI: "" + uri, endpoint);
        return endpoint;
    }
    /**
     * Resolves an endpoint and asserts that it is found
     */
    protected <T extends Endpoint> T resolveMandatoryEndpoint(CamelContext context, String uri,
                                                              Class<T> endpointType) {
        T endpoint = context.getEndpoint(uri, endpointType);
        assertNotNull(""No endpoint found for URI: "" + uri, endpoint);
        return endpoint;
    }
    /**
     * Creates an exchange with the given body
     */
    protected Exchange createExchangeWithBody(CamelContext camelContext, Object body) {
        Exchange exchange = new DefaultExchange(camelContext);
        Message message = exchange.getIn();
        message.setHeader(""testName"", getName());
        message.setHeader(""testClass"", getClass().getName());
        message.setBody(body);
        return exchange;
    }
    protected <T> T assertOneElement(List<T> list) {
        assertEquals(""Size of list should be 1: "" + list, 1, list.size());
        return list.get(0);
    }
    /**
     * Asserts that a list is of the given size
     */
    protected <T> List<T> assertListSize(List<T> list, int size) {
        assertEquals(""List should be of size: "" + size + "" but is: "" + list, size, list.size());
        return list;
    }
    /**
     * A helper method to create a list of Route objects for a given route builder
     */
    protected List<Route> getRouteList(RouteBuilder builder) throws Exception {
        CamelContext context = new DefaultCamelContext();
        context.addRoutes(builder);
        context.start();
        List<Route> answer = context.getRoutes();
        context.stop();
        return answer;
    }
    /**
     * Asserts that the text contains the given string
     *
     * @param text the text to compare
     * @param containedText the text which must be contained inside the other text parameter
     */
    protected void assertStringContains(String text, String containedText) {
        assertNotNull(""Text should not be null!"", text);
        assertTrue(""Text: "" + text + "" does not contain: "" + containedText, text.contains(containedText));
    }
    /**
     * If a processor is wrapped with a bunch of DelegateProcessor or DelegateAsyncProcessor objects
     * this call will drill through them and return the wrapped Processor.
     *
     * @param processor
     * @return
     */
    protected Processor unwrap(Processor processor) {
        while (true) {
            if (processor instanceof DelegateAsyncProcessor) {
                processor = ((DelegateAsyncProcessor)processor).getProcessor();
            } else if (processor instanceof DelegateProcessor) {
                processor = ((DelegateProcessor)processor).getProcessor();
            } else {
                return processor;
            }
        }
    }
    /**
     * Recursively delete a directory, useful to zapping test data
     *
     * @param file the directory to be deleted
     */
    public static void deleteDirectory(String file) {
        deleteDirectory(new File(file));
    }
    /**
     * Recursively delete a directory, useful to zapping test data
     *
     * @param file the directory to be deleted
     */
    public static void deleteDirectory(File file) {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                deleteDirectory(files[i]);
            }
        }
        file.delete();
    }
}
"
org.apache.camel.TypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A pluggable strategy to be able to convert objects <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">to different
 * types</a> such as to and from String, InputStream/OutputStream,
 * Reader/Writer, Document, byte[], ByteBuffer etc
 * 
 * @version $Revision: 630591 $
 */
public interface TypeConverter {
    /**
     * Converts the value to the specified type
     * 
     * @param type the requested type
     * @param value the value to be converted
     * @return the converted value or null if it can not be converted
     */
    <T> T convertTo(Class<T> type, Object value);
}
"
org.apache.camel.ValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * The base class for any validation exception, such as
 * {@link org.apache.camel.processor.validation.SchemaValidationException} so
 * that it is easy to treat all validation errors in a similar way irrespective
 * of the particular validation technology used.
 * 
 * @version $Revision: 642272 $
 */
public class ValidationException extends CamelExchangeException {
    public ValidationException(Exchange exchange, String message) {
        super(message, exchange);
    }
    public ValidationException(String message, Exchange exchange, Throwable cause) {
        super(message, exchange, cause);
    }
}
"
org.apache.camel.builder.BinaryPredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A useful base class for {@link Predicate} implementations
 * 
 * @version $Revision: 663018 $
 */
public abstract class BinaryPredicateSupport<E extends Exchange> implements Predicate<E> {
    private final Expression<E> left;
    private final Expression<E> right;
    protected BinaryPredicateSupport(Expression<E> left, Expression<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        this.left = left;
        this.right = right;
    }
    @Override
    public String toString() {
        return left + "" "" + getOperationText() + "" "" + right;
    }
    public boolean matches(E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        return matches(exchange, leftValue, rightValue);
    }
    public void assertMatches(String text, E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        if (!matches(exchange, leftValue, rightValue)) {
            throw new AssertionError(text + assertionFailureMessage(exchange, leftValue, rightValue));
        }
    }
    protected abstract boolean matches(E exchange, Object leftValue, Object rightValue);
    protected abstract String getOperationText();
    protected String assertionFailureMessage(E exchange, Object leftValue, Object rightValue) {
        return this + "" failed on "" + exchange + "" with left value <"" + leftValue + ""> right value <""
               + rightValue + "">"";
    }
}
"
org.apache.camel.builder.Builder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A helper class for including portions of the <a
 * href=""http://activemq.apache.org/camel/expression.html"">expression</a> and
 * <a href=""http://activemq.apache.org/camel/predicate.html"">predicate</a> <a
 * href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 *
 * @version $Revision: 640438 $
 */
public final class Builder {
    /**
     * Utility classes should not have a public constructor.
     */
    private Builder() {
    }
    /**
     * Returns a constant expression
     */
    public static <E extends Exchange> ValueBuilder<E> constant(Object value) {
        Expression<E> expression = ExpressionBuilder.constantExpression(value);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> header(String name) {
        Expression<E> expression = ExpressionBuilder.headerExpression(name);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> body() {
        Expression<E> expression = ExpressionBuilder.bodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> bodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T> bodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public static <E extends Exchange> ValueBuilder<E> outBody() {
        Expression<E> expression = ExpressionBuilder.outBodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> outBodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T> outBodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public static <E extends Exchange> ValueBuilder<E> faultBody() {
        Expression<E> expression = ExpressionBuilder.faultBodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> faultBodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T> faultBodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name,
                                                                      final String defaultValue) {
        return new ValueBuilder<E>(ExpressionBuilder.<E> systemProperty(name, defaultValue));
    }
}
"
org.apache.camel.builder.BuilderSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Base class for implementation inheritance for different clauses in the <a
 * href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 *
 * @version $Revision: 660216 $
 */
public abstract class BuilderSupport {
    private CamelContext context;
    private ErrorHandlerBuilder errorHandlerBuilder;
    private boolean inheritErrorHandler = true;
    protected BuilderSupport(CamelContext context) {
        this.context = context;
    }
    protected BuilderSupport(BuilderSupport parent) {
        this.context = parent.getContext();
        this.inheritErrorHandler = parent.inheritErrorHandler;
        if (inheritErrorHandler && parent.errorHandlerBuilder != null) {
            this.errorHandlerBuilder = parent.errorHandlerBuilder.copy();
        }
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Returns a value builder for the given header
     */
    public ValueBuilder header(String name) {
        return Builder.header(name);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public ValueBuilder body() {
        return Builder.body();
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> ValueBuilder body(Class<T> type) {
        return Builder.bodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public ValueBuilder outBody() {
        return Builder.outBody();
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> ValueBuilder outBody(Class<T> type) {
        return Builder.outBodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public ValueBuilder faultBody() {
        return Builder.faultBody();
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public <T> ValueBuilder faultBodyAs(Class<T> type) {
        return Builder.faultBodyAs(type);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name) {
        return Builder.systemProperty(name);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name, String defaultValue) {
        return Builder.systemProperty(name, defaultValue);
    }
    /**
     * Returns a constant expression value builder
     */
    public ValueBuilder constant(Object value) {
        return Builder.constant(value);
    }
    /**
     * Resolves the given URI to an endpoint
     *
     * @throws NoSuchEndpointException if the endpoint URI could not be resolved
     */
    public Endpoint endpoint(String uri) throws NoSuchEndpointException {
        ObjectHelper.notNull(uri, ""uri"");
        Endpoint endpoint = getContext().getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
    /**
     * Resolves the given URI to an endpoint of the specified type
     *
     * @throws NoSuchEndpointException if the endpoint URI could not be resolved
     */
    public <T extends Endpoint> T endpoint(String uri, Class<T> type) throws NoSuchEndpointException {
        ObjectHelper.notNull(uri, ""uri"");
        T endpoint = getContext().getEndpoint(uri, type);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
    /**
     * Resolves the list of URIs into a list of {@link Endpoint} instances
     *
     * @throws NoSuchEndpointException if an endpoint URI could not be resolved
     */
    public List<Endpoint> endpoints(String... uris) throws NoSuchEndpointException {
        List<Endpoint> endpoints = new ArrayList<Endpoint>();
        for (String uri : uris) {
            endpoints.add(endpoint(uri));
        }
        return endpoints;
    }
    /**
     * Helper method to create a list of {@link Endpoint} instances
     */
    public List<Endpoint> endpoints(Endpoint... endpoints) {
        List<Endpoint> answer = new ArrayList<Endpoint>();
        answer.addAll(Arrays.asList(endpoints));
        return answer;
    }
    /**
     * Creates a disabled error handler for removing the default error handler
     */
    public NoErrorHandlerBuilder noErrorHandler() {
        return new NoErrorHandlerBuilder();
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler() {
        return new LoggingErrorHandlerBuilder();
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(String log) {
        return loggingErrorHandler(LogFactory.getLog(log));
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(Log log) {
        return new LoggingErrorHandlerBuilder(log);
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(Log log, LoggingLevel level) {
        return new LoggingErrorHandlerBuilder(log, level);
    }
    public DeadLetterChannelBuilder deadLetterChannel() {
        return new DeadLetterChannelBuilder();
    }
    public DeadLetterChannelBuilder deadLetterChannel(String deadLetterUri) {
        return deadLetterChannel(endpoint(deadLetterUri));
    }
    public DeadLetterChannelBuilder deadLetterChannel(Endpoint deadLetterEndpoint) {
        return new DeadLetterChannelBuilder(new SendProcessor(deadLetterEndpoint));
    }
    // Properties
    // -------------------------------------------------------------------------
    public CamelContext getContext() {
        return context;
    }
    public void setContext(CamelContext context) {
        this.context = context;
    }
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        if (errorHandlerBuilder == null) {
            errorHandlerBuilder = createErrorHandlerBuilder();
        }
        return errorHandlerBuilder;
    }
    protected ErrorHandlerBuilder createErrorHandlerBuilder() {
        if (isInheritErrorHandler()) {
            return new DeadLetterChannelBuilder();
        } else {
            return new NoErrorHandlerBuilder();
        }
    }
    /**
     * Sets the error handler to use with processors created by this builder
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    public boolean isInheritErrorHandler() {
        return inheritErrorHandler;
    }
    public void setInheritErrorHandler(boolean inheritErrorHandler) {
        this.inheritErrorHandler = inheritErrorHandler;
    }
}
"
org.apache.camel.builder.BuilderWithScopesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.Collections;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
import org.apache.camel.ValidationException;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.processor.DelegateProcessor;
/**
 * @version $Revision: 659849 $
 */
public class BuilderWithScopesTest extends TestSupport {
    final ArrayList<String> order = new ArrayList<String>();
    final DelegateProcessor interceptor1 = new DelegateProcessor() {
        @Override
        public void process(Exchange exchange) throws Exception {
            order.add(""START:1"");
            super.process(exchange);
            order.add(""END:1"");
        }
    };
    final DelegateProcessor interceptor2 = new DelegateProcessor() {
        @Override
        public void process(Exchange exchange) throws Exception {
            order.add(""START:2"");
            super.process(exchange);
            order.add(""END:2"");
        }
    };
    final Processor orderProcessor = new Processor() {
        public void process(Exchange exchange) {
            order.add(""INVOKED"");
        }
    };
    final Processor orderProcessor2 = new Processor() {
        public void process(Exchange exchange) {
            order.add(""INVOKED2"");
        }
    };
    final Processor orderProcessor3 = new Processor() {
        public void process(Exchange exchange) {
            order.add(""INVOKED3"");
        }
    };
    final Processor toProcessor = new Processor() {
        public void process(Exchange exchange) {
            order.add(""TO"");
        }
    };
    final Processor validator = new Processor() {
        public void process(Exchange exchange) throws Exception {
            order.add(""VALIDATE"");
            Object value = exchange.getIn().getHeader(""foo"");
            if (value == null) {
                throw new IllegalArgumentException(""The foo header is not present."");
            } else if (!value.equals(""bar"")) {
                throw new ValidationException(exchange, ""The foo header does not equal bar! Was: "" + value);
            }
        }
    };
    protected void runTest(RouteBuilder builder, ArrayList<String> expected) throws Exception {
        runTest(builder, expected, null);
    }
    protected void runTest(RouteBuilder builder, ArrayList<String> expected, String header) throws Exception {
        order.clear();
        CamelContext container = new DefaultCamelContext();
        container.addRoutes(builder);
        container.start();
        Endpoint endpoint = container.getEndpoint(""direct:a"");
        Exchange exchange = endpoint.createExchange();
        if (header != null) {
            exchange.getIn().setHeader(""foo"", header);
        }
        Producer producer = endpoint.createProducer();
        producer.process(exchange);
        log.debug(""Interceptor invocation order:"" + order);
        assertEquals(expected, order);
    }
    public void testRouteWithFilterEnd() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""TO"");
        runTest(new RouteBuilder() {
            public void configure() {
                from(""direct:a"").filter(header(""foo"").isEqualTo(""bar"")).process(orderProcessor).end()
                    .process(toProcessor);
            }
        }, expected, ""banana"");
    }
    public void testRouteWithFilterNoEnd() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        runTest(new RouteBuilder() {
            public void configure() {
                from(""direct:a"").filter(header(""foo"").isEqualTo(""bar"")).process(orderProcessor)
                    .process(toProcessor);
            }
        }, expected, ""banana"");
    }
    protected RouteBuilder createChoiceBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").choice().when(header(""foo"").isEqualTo(""bar"")).process(orderProcessor)
                    .when(header(""foo"").isEqualTo(""cheese"")).process(orderProcessor2).end()
                    .process(toProcessor);
            }
        };
    }
    public void testRouteWithChoice1() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""INVOKED"");
        expected.add(""TO"");
        runTest(createChoiceBuilder(), expected, ""bar"");
    }
    public void testRouteWithChoice2() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""INVOKED2"");
        expected.add(""TO"");
        runTest(createChoiceBuilder(), expected, ""cheese"");
    }
    public void testRouteWithChoice3() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""TO"");
        runTest(createChoiceBuilder(), expected, ""banana"");
    }
    public void testRouteWithChoiceNoEnd() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""INVOKED"");
        runTest(new RouteBuilder() {
            public void configure() {
                from(""direct:a"").choice().when(header(""foo"").isEqualTo(""bar"")).process(orderProcessor)
                    .when(header(""foo"").isEqualTo(""cheese"")).process(orderProcessor2).process(toProcessor); // continuation of the second when clause
            }
        }, expected, ""bar"");
    }
    protected RouteBuilder createChoiceWithOtherwiseBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").choice().when(header(""foo"").isEqualTo(""bar"")).process(orderProcessor)
                    .when(header(""foo"").isEqualTo(""cheese"")).process(orderProcessor2).otherwise()
                    .process(orderProcessor3).end().process(toProcessor);
            }
        };
    }
    public void testRouteWithChoiceOtherwise1() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""INVOKED"");
        expected.add(""TO"");
        runTest(createChoiceWithOtherwiseBuilder(), expected, ""bar"");
    }
    public void testRouteWithChoiceOtherwise2() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""INVOKED2"");
        expected.add(""TO"");
        runTest(createChoiceWithOtherwiseBuilder(), expected, ""cheese"");
    }
    public void testRouteWithChoiceOtherwise3() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""INVOKED3"");
        expected.add(""TO"");
        runTest(createChoiceWithOtherwiseBuilder(), expected, ""banana"");
    }
    public void testRouteWithChoiceOtherwiseNoEnd() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""INVOKED"");
        runTest(new RouteBuilder() {
            public void configure() {
                from(""direct:a"").choice().when(header(""foo"").isEqualTo(""bar"")).process(orderProcessor)
                    .when(header(""foo"").isEqualTo(""cheese"")).process(orderProcessor2).otherwise()
                    .process(orderProcessor3).process(toProcessor); // continuation of the otherwise clause
            }
        }, expected, ""bar"");
    }
    protected RouteBuilder createTryCatchNoEnd() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").tryBlock().process(validator).process(toProcessor)
                    .handle(ValidationException.class).process(orderProcessor).process(orderProcessor3); // continuation of the handle clause
            }
        };
    }
    public void testRouteWithTryCatchNoEndNoException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""TO"");
        runTest(createTryCatchNoEnd(), expected, ""bar"");
    }
    public void testRouteWithTryCatchNoEndWithCaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""INVOKED"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchNoEnd(), expected, ""banana"");
    }
    public void testRouteWithTryCatchNoEndWithUncaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.addAll(Collections.nCopies(6, ""VALIDATE""));
        runTest(createTryCatchNoEnd(), expected);
    }
    protected RouteBuilder createTryCatchEnd() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").tryBlock().process(validator).process(toProcessor)
                    .handle(ValidationException.class).process(orderProcessor).end().process(orderProcessor3);
            }
        };
    }
    public void testRouteWithTryCatchEndNoException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""TO"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchEnd(), expected, ""bar"");
    }
    public void testRouteWithTryCatchEndWithCaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""INVOKED"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchEnd(), expected, ""banana"");
    }
    public void testRouteWithTryCatchEndWithUncaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.addAll(Collections.nCopies(6, ""VALIDATE""));
        runTest(createTryCatchEnd(), expected);
    }
    protected RouteBuilder createTryCatchFinallyNoEnd() {
        return new RouteBuilder() {
            public void configure() {
                errorHandler(deadLetterChannel().maximumRedeliveries(2));
                from(""direct:a"").tryBlock().process(validator).process(toProcessor)
                    .handle(ValidationException.class).process(orderProcessor).finallyBlock()
                    .process(orderProcessor2).process(orderProcessor3); // continuation of the finallyBlock clause
            }
        };
    }
    public void testRouteWithTryCatchFinallyNoEndNoException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""TO"");
        expected.add(""INVOKED2"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchFinallyNoEnd(), expected, ""bar"");
    }
    public void testRouteWithTryCatchFinallyNoEndWithCaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""INVOKED"");
        expected.add(""INVOKED2"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchFinallyNoEnd(), expected, ""banana"");
    }
    public void testRouteWithTryCatchFinallyNoEndWithUncaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""INVOKED2"");
        expected.add(""INVOKED3"");
        // exchange should be processed twice for an uncaught exception and maximumRedeliveries(2)
        expected.add(""VALIDATE"");
        expected.add(""INVOKED2"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchFinallyNoEnd(), expected);
    }
    protected RouteBuilder createTryCatchFinallyEnd() {
        return new RouteBuilder() {
            public void configure() {
                errorHandler(deadLetterChannel().maximumRedeliveries(2));
                from(""direct:a"").tryBlock().process(validator).process(toProcessor)
                    .handle(ValidationException.class).process(orderProcessor).finallyBlock()
                    .process(orderProcessor2).end().process(orderProcessor3);
            }
        };
    };
    public void testRouteWithTryCatchFinallyEndNoException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""TO"");
        expected.add(""INVOKED2"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchFinallyEnd(), expected, ""bar"");
    }
    public void testRouteWithTryCatchFinallyEndWithCaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""INVOKED"");
        expected.add(""INVOKED2"");
        expected.add(""INVOKED3"");
        runTest(createTryCatchFinallyEnd(), expected, ""banana"");
    }
    public void testRouteWithTryCatchFinallyEndWithUncaughtException() throws Exception {
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""VALIDATE"");
        expected.add(""INVOKED2"");
        // exchange should be processed twice for an uncaught exception and maximumRedeliveries(2)
        expected.add(""VALIDATE"");
        expected.add(""INVOKED2"");
        // orderProcessor3 will not be invoked past end() with an uncaught exception
        runTest(createTryCatchFinallyEnd(), expected);
    }
}
"
org.apache.camel.builder.ConstantProcessorBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
/**
 * A builder wrapping a {@link Processor}.
 *
 * @version $Revision: 659760 $
 */
public class ConstantProcessorBuilder implements ProcessorFactory {
    private Processor processor;
    public ConstantProcessorBuilder(Processor processor) {
        this.processor = processor;
    }
    public Processor createProcessor() {
        return processor;
    }
}
"
org.apache.camel.builder.DataFormatClause,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.dataformat.ArtixDSContentType;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.CsvDataFormat;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.StringDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.model.dataformat.XStreamDataFormat;
import org.apache.camel.spi.DataFormat;
/**
 * An expression for constructing the different possible {@link DataFormat}
 * options.
 *
 * @version $Revision: 659760 $
 */
public class DataFormatClause<T extends ProcessorType> {
    private final T processorType;
    private final Operation operation;
    /**
     * {@link DataFormat} operations.
     */
    public enum Operation {
        Marshal, Unmarshal
    }
    public DataFormatClause(T processorType, Operation operation) {
        this.processorType = processorType;
        this.operation = operation;
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format for dealing with lots of different message formats such as SWIFT etc.
     */
    public T artixDS() {
        return dataFormat(new ArtixDSDataFormat());
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified type of ComplexDataObject
     * for marshalling and unmarshalling messages using the dataObject's default Source and Sink.
     */
    public T artixDS(Class<?> dataObjectType) {
        return dataFormat(new ArtixDSDataFormat(dataObjectType));
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified type of ComplexDataObject
     * for marshalling and unmarshalling messages using the dataObject's default Source and Sink.
     */
    public T artixDS(Class<?> elementType, ArtixDSContentType contentType) {
        return dataFormat(new ArtixDSDataFormat(elementType, contentType));
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified content type
     * for marshalling and unmarshalling messages
     */
    public T artixDS(ArtixDSContentType contentType) {
        return dataFormat(new ArtixDSDataFormat(contentType));
    }
    /**
     * Uses the CSV data format
     */
    public T csv() {
        return dataFormat(new CsvDataFormat());
    }
    /**
     * Uses the JAXB data format
     */
    public T jaxb() {
        return dataFormat(new JaxbDataFormat());
    }
    /**
     * Uses the JAXB data format turning pretty printing on or off
     */
    public T jaxb(boolean prettyPrint) {
        return dataFormat(new JaxbDataFormat(prettyPrint));
    }
    /**
     * Uses the Java Serialization data format
     */
    public T serialization() {
        return dataFormat(new SerializationDataFormat());
    }
    /**
     * Uses the String data format
     */
    public T string() {
        return string(null);
    }
    /**
     * Uses the String data format supporting encoding using given charset
     */
    public T string(String charset) {
        StringDataFormat sdf = new StringDataFormat();
        sdf.setCharset(charset);
        return dataFormat(sdf);
    }
    /**
     * Uses the JAXB data format
     */
    public T xmlBeans() {
        return dataFormat(new XMLBeansDataFormat());
    }
    /**
     * Uses the XStream data format
     */
    public T xstream() {
        return dataFormat(new XStreamDataFormat());
    }
    private T dataFormat(DataFormatType dataFormatType) {
        switch (operation) {
        case Unmarshal:
            return (T)processorType.unmarshal(dataFormatType);
        case Marshal:
            return (T)processorType.marshal(dataFormatType);
        default:
            throw new IllegalArgumentException(""Unknown DataFormat operation: "" + operation);
        }
    }
}
"
org.apache.camel.builder.DeadLetterChannelBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.processor.ErrorHandlerSupport;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A builder of a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a>
 *
 * @version $Revision: 674383 $
 */
public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport {
    private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
    private ExceptionPolicyStrategy exceptionPolicyStrategy = ErrorHandlerSupport.createDefaultExceptionPolicyStrategy();
    private ProcessorFactory deadLetterFactory;
    private Processor defaultDeadLetterEndpoint;
    private Expression defaultDeadLetterEndpointExpression;
    private String defaultDeadLetterEndpointUri = ""log:org.apache.camel.DeadLetterChannel?level=error"";
    private Logger logger = DeadLetterChannel.createDefaultLogger();
    public DeadLetterChannelBuilder() {
    }
    public DeadLetterChannelBuilder(Processor processor) {
        this(new ConstantProcessorBuilder(processor));
    }
    public DeadLetterChannelBuilder(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }
    public ErrorHandlerBuilder copy() {
        DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder(deadLetterFactory);
        answer.setRedeliveryPolicy(getRedeliveryPolicy().copy());
        return answer;
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {
        Processor deadLetter = getDeadLetterFactory().createProcessor();
        DeadLetterChannel answer = new DeadLetterChannel(processor, deadLetter, getRedeliveryPolicy(), getLogger(), getExceptionPolicyStrategy());
        configure(answer);
        return answer;
    }
    // Builder methods
    // -------------------------------------------------------------------------
    public DeadLetterChannelBuilder backOffMultiplier(double backOffMultiplier) {
        getRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    public DeadLetterChannelBuilder collisionAvoidancePercent(short collisionAvoidancePercent) {
        getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    public DeadLetterChannelBuilder initialRedeliveryDelay(long initialRedeliveryDelay) {
        getRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public DeadLetterChannelBuilder maximumRedeliveries(int maximumRedeliveries) {
        getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public DeadLetterChannelBuilder maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        getRedeliveryPolicy().maximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    public DeadLetterChannelBuilder useCollisionAvoidance() {
        getRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    public DeadLetterChannelBuilder useExponentialBackOff() {
        getRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
    /**
     * Sets the logger used for caught exceptions
     */
    public DeadLetterChannelBuilder logger(Logger logger) {
        setLogger(logger);
        return this;
    }
    /**
     * Sets the logging level of exceptions caught
     */
    public DeadLetterChannelBuilder loggingLevel(LoggingLevel level) {
        getLogger().setLevel(level);
        return this;
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Log log) {
        getLogger().setLog(log);
        return this;
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(String log) {
        return log(LogFactory.getLog(log));
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Class log) {
        return log(LogFactory.getLog(log));
    }
    /**
     * Sets the exception policy to use
     */
    public ErrorHandlerBuilderSupport exceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicyStrategy) {
        setExceptionPolicyStrategy(exceptionPolicyStrategy);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public ProcessorFactory getDeadLetterFactory() {
        if (deadLetterFactory == null) {
            deadLetterFactory = new ProcessorFactory() {
                public Processor createProcessor() {
                    return getDefaultDeadLetterEndpoint();
                }
            };
        }
        return deadLetterFactory;
    }
    /**
     * Sets the default dead letter queue factory
     */
    public void setDeadLetterFactory(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }
    public Processor getDefaultDeadLetterEndpoint() {
        if (defaultDeadLetterEndpoint == null) {
            defaultDeadLetterEndpoint = new RecipientList(getDefaultDeadLetterEndpointExpression());
        }
        return defaultDeadLetterEndpoint;
    }
    /**
     * Sets the default dead letter endpoint used
     */
    public void setDefaultDeadLetterEndpoint(Processor defaultDeadLetterEndpoint) {
        this.defaultDeadLetterEndpoint = defaultDeadLetterEndpoint;
    }
    public Expression getDefaultDeadLetterEndpointExpression() {
        if (defaultDeadLetterEndpointExpression == null) {
            defaultDeadLetterEndpointExpression = ExpressionBuilder
                .constantExpression(getDefaultDeadLetterEndpointUri());
        }
        return defaultDeadLetterEndpointExpression;
    }
    /**
     * Sets the expression used to decide the dead letter channel endpoint for
     * an exchange if no factory is provided via
     * {@link #setDeadLetterFactory(ProcessorFactory)}
     */
    public void setDefaultDeadLetterEndpointExpression(Expression defaultDeadLetterEndpointExpression) {
        this.defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression;
    }
    public String getDefaultDeadLetterEndpointUri() {
        return defaultDeadLetterEndpointUri;
    }
    /**
     * Sets the default dead letter endpoint URI used if no factory is provided
     * via {@link #setDeadLetterFactory(ProcessorFactory)} and no expression is
     * provided via {@link #setDefaultDeadLetterEndpointExpression(Expression)}
     *
     * @param defaultDeadLetterEndpointUri the default URI if no deadletter
     *                factory or expression is provided
     */
    public void setDefaultDeadLetterEndpointUri(String defaultDeadLetterEndpointUri) {
        this.defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri;
    }
    public Logger getLogger() {
        return logger;
    }
    public void setLogger(Logger logger) {
        this.logger = logger;
    }
    /**
     * Sets the exception policy strategy to use for resolving the {@link org.apache.camel.model.ExceptionType}
     * to use for a given thrown exception
     */
    public ExceptionPolicyStrategy getExceptionPolicyStrategy() {
        return exceptionPolicyStrategy;
    }
    public void setExceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicyStrategy) {
        this.exceptionPolicyStrategy = exceptionPolicyStrategy;
    }
}
"
org.apache.camel.builder.ErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.spi.RouteContext;
/**
 * A builder of a <a href=""http://activemq.apache.org/camel/error-handler.html"">Error Handler</a>
 *
 * @version $Revision: 674383 $
 */
public interface ErrorHandlerBuilder {
    /**
     * Creates a copy of this builder
     */
    ErrorHandlerBuilder copy();
    /**
     * Creates the error handler interceptor
     */
    Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception;
    /**
     * Adds error handler for the given exception type
     * @param exception  the exception to handle
     */
    void addErrorHandlers(ExceptionType exception);
}
"
org.apache.camel.builder.ErrorHandlerBuilderRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.List;
import org.apache.camel.Processor;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents a proxy to an error handler builder which is resolved by named reference
 *
 * @version $Revision: 674383 $
 */
public class ErrorHandlerBuilderRef extends ErrorHandlerBuilderSupport {
    private final String ref;
    private ErrorHandlerBuilder handler;
    public ErrorHandlerBuilderRef(String ref) {
        this.ref = ref;
    }
    public ErrorHandlerBuilder copy() {
        return new ErrorHandlerBuilderRef(ref);
    }
    @Override
    public void addErrorHandlers(ExceptionType exception) {
        if (handler != null) {
            handler.addErrorHandlers(exception);
        }
        super.addErrorHandlers(exception);
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {
        if (handler == null) {
            handler = routeContext.lookup(ref, ErrorHandlerBuilder.class);
            ObjectHelper.notNull(handler, ""error handler '"" + ref + ""'"");
            List<ExceptionType> list = getExceptions();
            for (ExceptionType exceptionType : list) {
                handler.addErrorHandlers(exceptionType);
            }
        }
        return handler.createErrorHandler(routeContext, processor);
    }
}
"
org.apache.camel.builder.ErrorHandlerBuilderSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.processor.ErrorHandlerSupport;
/**
 * Base class for builders of error handling.
 *
 * @version $Revision: 673837 $
 */
public abstract class ErrorHandlerBuilderSupport implements ErrorHandlerBuilder {
    private List<ExceptionType> exceptions = new ArrayList<ExceptionType>();
    public void addErrorHandlers(ExceptionType exception) {
        exceptions.add(exception);
    }
    protected void configure(ErrorHandlerSupport handler) {
        for (ExceptionType exception : exceptions) {
            handler.addExceptionPolicy(exception);
        }
    }
    public List<ExceptionType> getExceptions() {
        return exceptions;
    }
}
"
org.apache.camel.builder.ErrorHandlerTest,"outes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
            Processor processor = unwrap(consumerRoute.getProcessor());
            LoggingErrorHandler loggingProcessor = assertIsInstanceOf(LoggingErrorHandler.class, processor);
            if (Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {   
                processor = loggingProcessor.getOutput();
            } else {
                InstrumentationProcessor interceptor =
                    assertIsInstanceOf(InstrumentationProcessor.class, loggingProcessor.getOutput());
                processor = interceptor.getProcessor();
            }
            FilterProcessor filterProcessor = assertIsInstanceOf(FilterProcessor.class, processor);
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class, filterProcessor.getProcessor());
            log.debug(""Found sendProcessor: "" + sendProcessor);
        }
    }
}
"
org.apache.camel.builder.ExceptionBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.io.IOException;
import java.net.ConnectException;
import java.security.GeneralSecurityException;
import java.security.KeyException;
import java.security.KeyManagementException;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test to test exception configuration
 */
public class ExceptionBuilderTest extends ContextTestSupport {
    private static final String MESSAGE_INFO = ""messageInfo"";
    private static final String ERROR_QUEUE = ""mock:error"";
    private static final String BUSINESS_ERROR_QUEUE = ""mock:badBusiness"";
    private static final String SECURITY_ERROR_QUEUE = ""mock:securityError"";
    public void testNPE() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);
        mock.expectedMessageCount(1);
        mock.expectedHeaderReceived(MESSAGE_INFO, ""Damm a NPE"");
        template.sendBody(""direct:a"", ""Hello NPE"");
        mock.assertIsSatisfied();
    }
    public void testIOException() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);
        mock.expectedMessageCount(1);
        mock.expectedHeaderReceived(MESSAGE_INFO, ""Damm somekind of IO exception"");
        template.sendBody(""direct:a"", ""Hello IO"");
        mock.assertIsSatisfied();
    }
    public void testException() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);
        mock.expectedMessageCount(1);
        mock.expectedHeaderReceived(MESSAGE_INFO, ""Damm just exception"");
        template.sendBody(""direct:a"", ""Hello Exception"");
        mock.assertIsSatisfied();
    }
    public void testMyBusinessException() throws Exception {
        MockEndpoint mock = getMockEndpoint(BUSINESS_ERROR_QUEUE);
        mock.expectedMessageCount(1);
        mock.expectedHeaderReceived(MESSAGE_INFO, ""Damm my business is not going to well"");
        template.sendBody(""direct:a"", ""Hello business"");
        mock.assertIsSatisfied();
    }
    public void testSecurityConfiguredWithTwoExceptions() throws Exception {
        // test that we also handles a configuration with 2 or more exceptions
        MockEndpoint mock = getMockEndpoint(SECURITY_ERROR_QUEUE);
        mock.expectedMessageCount(1);
        mock.expectedHeaderReceived(MESSAGE_INFO, ""Damm some security error"");
        template.sendBody(""direct:a"", ""I am not allowed to do this"");
        mock.assertIsSatisfied();
    }
    public static class MyBaseBusinessException extends Exception {
    }
    public static class MyBusinessException extends MyBaseBusinessException {
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // START SNIPPET: exceptionBuilder1
                exception(NullPointerException.class)
                    .maximumRedeliveries(1)
                    .setHeader(MESSAGE_INFO, ""Damm a NPE"")
                    .to(ERROR_QUEUE);
                exception(IOException.class)
                    .initialRedeliveryDelay(5000L)
                    .maximumRedeliveries(3)
                    .backOffMultiplier(1.0)
                    .useExponentialBackOff()
                    .setHeader(MESSAGE_INFO, ""Damm somekind of IO exception"")
                    .to(ERROR_QUEUE);
                exception(Exception.class)
                    .initialRedeliveryDelay(1000L)
                    .maximumRedeliveries(2)
                    .setHeader(MESSAGE_INFO, ""Damm just exception"")
                    .to(ERROR_QUEUE);
                // END SNIPPET: exceptionBuilder1
                exception(MyBaseBusinessException.class)
                    .initialRedeliveryDelay(1000L)
                    .maximumRedeliveries(3)
                    .setHeader(MESSAGE_INFO, ""Damm my business is not going to well"")
                    .to(BUSINESS_ERROR_QUEUE);
                exception(GeneralSecurityException.class).exception(KeyException.class)
                    .maximumRedeliveries(1)
                    .setHeader(MESSAGE_INFO, ""Damm some security error"")
                    .to(SECURITY_ERROR_QUEUE);
                from(""direct:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        String s = exchange.getIn().getBody(String.class);
                        if (""Hello NPE"".equals(s)) {
                            throw new NullPointerException();
                        } else if (""Hello IO"".equals(s)) {
                            throw new ConnectException(""Forced for testing - can not connect to remote server"");
                        } else if (""Hello Exception"".equals(s)) {
                            throw new CamelExchangeException(""Forced for testing"", exchange);
                        } else if (""Hello business"".equals(s)) {
                            throw new MyBusinessException();
                        } else if (""I am not allowed to do this"".equals(s)) {
                            throw new KeyManagementException();
                        }
                        exchange.getOut().setBody(""Hello World"");
                    }
                }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.builder.ExpressionBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Pattern;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
/**
 * A helper class for working with <a href=""http://activemq.apache.org/camel/expression.html"">expressions</a>.
 *
 * @version $Revision: 659760 $
 */
public final class ExpressionBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExpressionBuilder() {
    }
    /**
     * Returns an expression for the header value with the given name
     *
     * @param headerName the name of the header the expression will return
     * @return an expression object which will return the header value
     */
    public static <E extends Exchange> Expression<E> headerExpression(final String headerName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object header = exchange.getIn().getHeader(headerName);
                if (header == null) {
                    // lets try the exchange header
                    header = exchange.getProperty(headerName);
                }
                return header;
            }
            @Override
            public String toString() {
                return ""header("" + headerName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the inbound message headers
     *
     * @see Message#getHeaders()
     * @return an expression object which will return the inbound headers
     */
    public static <E extends Exchange> Expression<E> headersExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeaders();
            }
            @Override
            public String toString() {
                return ""headers"";
            }
        };
    }
    /**
     * Returns an expression for the out header value with the given name
     *
     * @param headerName the name of the header the expression will return
     * @return an expression object which will return the header value
     */
    public static <E extends Exchange> Expression<E> outHeaderExpression(final String headerName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Message out = exchange.getOut(false);
                if (out == null) {
                    return null;
                }
                Object header = out.getHeader(headerName);
                if (header == null) {
                    // lets try the exchange header
                    header = exchange.getProperty(headerName);
                }
                return header;
            }
            @Override
            public String toString() {
                return ""outHeader("" + headerName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the outbound message headers
     *
     * @see Message#getHeaders()
     * @return an expression object which will return the inbound headers
     */
    public static <E extends Exchange> Expression<E> outHeadersExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getOut().getHeaders();
            }
            @Override
            public String toString() {
                return ""outHeaders"";
            }
        };
    }
    /**
     * Returns an expression for the property value with the given name
     *
     * @see Exchange#getProperty(String)
     * @param propertyName the name of the property the expression will return
     * @return an expression object which will return the property value
     */
    public static <E extends Exchange> Expression<E> propertyExpression(final String propertyName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getProperty(propertyName);
            }
            @Override
            public String toString() {
                return ""property("" + propertyName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the property value with the given name
     *
     * @see Exchange#getProperties()
     * @return an expression object which will return the properties
     */
    public static <E extends Exchange> Expression<E> propertiesExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getProperties();
            }
            @Override
            public String toString() {
                return ""properties"";
            }
        };
    }
    /**
     * Returns an expression for a system property value with the given name
     *
     * @param propertyName the name of the system property the expression will
     *                return
     * @return an expression object which will return the system property value
     */
    public static <E extends Exchange> Expression<E> systemPropertyExpression(final String propertyName) {
        return systemPropertyExpression(propertyName, null);
    }
    /**
     * Returns an expression for a system property value with the given name
     *
     * @param propertyName the name of the system property the expression will
     *                return
     * @return an expression object which will return the system property value
     */
    public static <E extends Exchange> Expression<E> systemPropertyExpression(final String propertyName,
                                                                              final String defaultValue) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return System.getProperty(propertyName, defaultValue);
            }
            @Override
            public String toString() {
                return ""systemProperty("" + propertyName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the constant value
     *
     * @param value the value the expression will return
     * @return an expression object which will return the constant value
     */
    public static <E extends Exchange> Expression<E> constantExpression(final Object value) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return value;
            }
            @Override
            public String toString() {
                return """" + value;
            }
        };
    }
    /**
     * Returns the expression for the exchanges inbound message body
     */
    public static <E extends Exchange> Expression<E> bodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody();
            }
            @Override
            public String toString() {
                return ""body"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges inbound message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> bodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody(type);
            }
            @Override
            public String toString() {
                return ""bodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the out messages body
     */
    public static <E extends Exchange> Expression<E> outBodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Message out = exchange.getOut(false);
                if (out == null) {
                    return null;
                }
                return out.getBody();
            }
            @Override
            public String toString() {
                return ""outBody"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges outbound message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> outBodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Message out = exchange.getOut(false);
                if (out == null) {
                    return null;
                }
                return out.getBody(type);
            }
            @Override
            public String toString() {
                return ""outBodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the fault messages body
     */
    public static <E extends Exchange> Expression<E> faultBodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getFault().getBody();
            }
            @Override
            public String toString() {
                return ""faultBody"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges fault message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> faultBodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getFault().getBody(type);
            }
            @Override
            public String toString() {
                return ""faultBodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the exchange
     */
    public static <E extends Exchange> Expression<E> exchangeExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange;
            }
            @Override
            public String toString() {
                return ""exchange"";
            }
        };
    }
    /**
     * Returns the expression for the IN message
     */
    public static <E extends Exchange> Expression<E> inMessageExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn();
            }
            @Override
            public String toString() {
                return ""inMessage"";
            }
        };
    }
    /**
     * Returns the expression for the OUT message
     */
    public static <E extends Exchange> Expression<E> outMessageExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getOut();
            }
            @Override
            public String toString() {
                return ""outMessage"";
            }
        };
    }
    /**
     * Returns an expression which converts the given expression to the given
     * type
     */
    public static <E extends Exchange> Expression<E> convertTo(final Expression expression, final Class type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object value = expression.evaluate(exchange);
                return exchange.getContext().getTypeConverter().convertTo(type, value);
            }
            @Override
            public String toString() {
                return """" + expression + "".convertTo("" + type.getName() + "".class)"";
            }
        };
    }
    /**
     * Returns a tokenize expression which will tokenize the string with the
     * given token
     */
    public static <E extends Exchange> Expression<E> tokenizeExpression(final Expression<E> expression,
                                                                        final String token) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                StringTokenizer iter = new StringTokenizer(text, token);
                List<String> answer = new ArrayList<String>();
                while (iter.hasMoreTokens()) {
                    answer.add(iter.nextToken());
                }
                return answer;
            }
            @Override
            public String toString() {
                return ""tokenize("" + expression + "", "" + token + "")"";
            }
        };
    }
    /**
     * Returns a tokenize expression which will tokenize the string with the
     * given regex
     */
    public static <E extends Exchange> Expression<E> regexTokenize(final Expression<E> expression,
                                                                   String regexTokenizer) {
        final Pattern pattern = Pattern.compile(regexTokenizer);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                return Arrays.asList(pattern.split(text));
            }
            @Override
            public String toString() {
                return ""regexTokenize("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Transforms the expression into a String then performs the regex
     * replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression,
                                                                     String regex, final String replacement) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }
            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Transforms the expression into a String then performs the regex
     * replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression,
                                                                     String regex,
                                                                     final Expression<E> replacementExpression) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                String replacement = evaluateStringExpression(replacementExpression, exchange);
                if (text == null || replacement == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }
            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Appends the String evaluations of the two expressions together
     */
    public static <E extends Exchange> Expression<E> append(final Expression<E> left,
                                                            final Expression<E> right) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return evaluateStringExpression(left, exchange) + evaluateStringExpression(right, exchange);
            }
            @Override
            public String toString() {
                return ""append("" + left + "", "" + right + "")"";
            }
        };
    }
    /**
     * Evaluates the expression on the given exchange and returns the String
     * representation
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the String representation of the expression or null if it could
     *         not be evaluated
     */
    public static <E extends Exchange> String evaluateStringExpression(Expression<E> expression, E exchange) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(String.class, value);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name,
                                                                    final String defaultValue) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return System.getProperty(name, defaultValue);
            }
        };
    }
    /**
     * Returns an expression which returns the string concatenation value of the various
     * expressions
     *
     * @param expressions the expression to be concatenated dynamically
     * @return an expression which when evaluated will return the concatenated values
     */
    public static <E extends Exchange> Expression<E> concatExpression(final Collection<Expression> expressions) {
        return concatExpression(expressions, null);
    }
    /**
     * Returns an expression which returns the string concatenation value of the various
     * expressions
     *
     * @param expressions the expression to be concatenated dynamically
     * @param expression the text description of the expression
     * @return an expression which when evaluated will return the concatenated values
     */
    public static <E extends Exchange> Expression<E> concatExpression(final Collection<Expression> expressions, final String expression) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                StringBuffer buffer = new StringBuffer();
                for (Expression<E> expression : expressions) {
                    String text = evaluateStringExpression(expression, exchange);
                    if (text != null) {
                        buffer.append(text);
                    }
                }
                return buffer.toString();
            }
            @Override
            public String toString() {
                if (expression != null) {
                    return expression;
                } else {
                    return ""concat"" + expressions;
                }
            }
        };
    }
}
"
org.apache.camel.builder.ExpressionBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.Arrays;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import static org.apache.camel.builder.ExpressionBuilder.constantExpression;
import static org.apache.camel.builder.ExpressionBuilder.headerExpression;
import static org.apache.camel.builder.ExpressionBuilder.regexReplaceAll;
import static org.apache.camel.builder.ExpressionBuilder.regexTokenize;
import static org.apache.camel.builder.PredicateBuilder.contains;
/**
 * @version $Revision: 630591 $
 */
public class ExpressionBuilderTest extends TestSupport {
    protected Exchange exchange = new DefaultExchange(new DefaultCamelContext());
    public void testRegexTokenize() throws Exception {
        Expression<Exchange> expression = regexTokenize(headerExpression(""location""), "","");
        assertExpression(expression, exchange, Arrays.asList(new String[] {""Islington"", ""London"", ""UK""}));
        Predicate<Exchange> predicate = contains(regexTokenize(headerExpression(""location""), "",""),
                                                 constantExpression(""London""));
        assertPredicate(predicate, exchange, true);
        predicate = contains(regexTokenize(headerExpression(""location""), "",""),
                             constantExpression(""Manchester""));
        assertPredicate(predicate, exchange, false);
    }
    public void testRegexReplaceAll() throws Exception {
        Expression<Exchange> expression = regexReplaceAll(headerExpression(""location""), ""London"",
                                                          ""Westminster"");
        assertExpression(expression, exchange, ""Islington,Westminster,UK"");
        expression = regexReplaceAll(headerExpression(""location""), ""London"", headerExpression(""name""));
        assertExpression(expression, exchange, ""Islington,James,UK"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Message in = exchange.getIn();
        in.setBody(""Hello there!"");
        in.setHeader(""name"", ""James"");
        in.setHeader(""location"", ""Islington,London,UK"");
    }
}
"
org.apache.camel.builder.ExpressionClause,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.Map;
import org.apache.camel.Expression;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.model.ExpressionNode;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.model.language.MethodCallExpression;
import org.apache.camel.model.language.XPathExpression;
import org.apache.camel.model.language.XQueryExpression;
/**
 * Represents an expression clause within the DSL which when the expression is complete
 * the clause continues to another part of the DSL
 *
 * @version $Revision: 640438 $
 */
public class ExpressionClause<T> extends ExpressionType {
    private T result;
    private String language;
    public ExpressionClause(T result) {
        this.result = result;
    }
    public static <T extends ExpressionNode> ExpressionClause<T> createAndSetExpression(T result) {
        ExpressionClause<T> clause = new ExpressionClause<T>(result);
        result.setExpression(clause);
        return clause;
    }
    // Helper expressions
    //-------------------------------------------------------------------------
    /**
     * Specify an {@link Expression} instance
     */
    public T expression(Expression expression) {
        setExpressionValue(expression);
        return result;
    }
    /**
     * Specify the constant expression value
     */
    public T constant(Object value) {
        return expression(ExpressionBuilder.constantExpression(value));
    }
    /**
     * An expression of the exchange
     */
    public T exchange() {
        return expression(ExpressionBuilder.exchangeExpression());
    }
    /**
     * An expression of an inbound message
     */
    public T inMessage() {
        return expression(ExpressionBuilder.inMessageExpression());
    }
    /**
     * An expression of an inbound message
     */
    public T outMessage() {
        return expression(ExpressionBuilder.outMessageExpression());
    }
    /**
     * An expression of an inbound message body
     */
    public T body() {
        return expression(ExpressionBuilder.bodyExpression());
    }
    /**
     * An expression of an inbound message body converted to the expected type
     */
    public T body(Class expectedType) {
        return expression(ExpressionBuilder.bodyExpression(expectedType));
    }
    /**
     * An expression of an outbound message body
     */
    public T outBody() {
        return expression(ExpressionBuilder.outBodyExpression());
    }
    /**
     * An expression of an outbound message body converted to the expected type
     */
    public T outBody(Class expectedType) {
        return expression(ExpressionBuilder.outBodyExpression(expectedType));
    }
    /**
     * An expression of an inbound message header of the given name
     */
    public T header(String name) {
        return expression(ExpressionBuilder.headerExpression(name));
    }
    /**
     * An expression of the inbound headers
     */
    public T headers() {
        return expression(ExpressionBuilder.headersExpression());
    }
    /**
     * An expression of an outbound message header of the given name
     */
    public T outHeader(String name) {
        return expression(ExpressionBuilder.outHeaderExpression(name));
    }
    /**
     * An expression of the outbound headers
     */
    public T outHeaders() {
        return expression(ExpressionBuilder.outHeadersExpression());
    }
    /**
     * An expression of an exchange property of the given name
     */
    public T property(String name) {
        return expression(ExpressionBuilder.propertyExpression(name));
    }
    /**
     * An expression of the exchange properties
     */
    public T properties() {
        return expression(ExpressionBuilder.propertiesExpression());
    }
    // Languages
    //-------------------------------------------------------------------------
    /**
     * Evaluates an expression using the
     * <a href=""http://activemq.apache.org/camel/bean-language.html>bean language</a>
     * which basically means the bean is invoked to determine the expression value.
     *
     * @param bean the name of the bean looked up the registry
     * @return the builder to continue processing the DSL
     */
    public T method(String bean) {
        MethodCallExpression expression = new MethodCallExpression(bean);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an expression using the
     * <a href=""http://activemq.apache.org/camel/bean-language.html>bean language</a>
     * which basically means the bean is invoked to determine the expression value.
     *
     * @param bean   the name of the bean looked up the registry
     * @param method the name of the method to invoke on the bean
     * @return the builder to continue processing the DSL
     */
    public T method(String bean, String method) {
        MethodCallExpression expression = new MethodCallExpression(bean, method);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates the  <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
     * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T el(String text) {
        return language(""el"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/groovy.html"">Groovy expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T groovy(String text) {
        return language(""groovy"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/java-script.html"">JavaScript expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T javaScript(String text) {
        return language(""js"", text);
    }
    /**
     * Evaluates a <a href=""http://commons.apache.org/jxpath/"">JXPath expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T jxpath(String text) {
        return language(""jxpath"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/ognl.html"">OGNL expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T ognl(String text) {
        return language(""ognl"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/php.html"">PHP expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T php(String text) {
        return language(""php"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/python.html"">Python expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T python(String text) {
        return language(""python"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/ruby.html"">Ruby expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T ruby(String text) {
        return language(""ruby"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/sql.html"">SQL expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T sql(String text) {
        return language(""sql"", text);
    }
    /**
     * Evaluates a <a href=""http://activemq.apache.org/camel/simple.html"">Simple expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T simple(String text) {
        return language(""simple"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text) {
        return language(""xpath"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified result type
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expressiopn
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Class resultType) {
        XPathExpression expression = new XPathExpression(text);
        expression.setResultType(resultType);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Class resultType, Namespaces namespaces) {
        return xpath(text, resultType, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Class resultType, Map<String, String> namespaces) {
        XPathExpression expression = new XPathExpression(text);
        expression.setResultType(resultType);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Namespaces namespaces) {
        return xpath(text, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xpath.html"">XPath expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text, Map<String, String> namespaces) {
        XPathExpression expression = new XPathExpression(text);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text) {
        return language(""xquery"", text);
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified result type
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expressiopn
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Class resultType) {
        XQueryExpression expression = new XQueryExpression(text);
        expression.setResultType(resultType);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Class resultType, Namespaces namespaces) {
        return xquery(text, resultType, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified result type and set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param resultType the return type expected by the expression
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Class resultType, Map<String, String> namespaces) {
        XQueryExpression expression = new XQueryExpression(text);
        expression.setResultType(resultType);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Namespaces namespaces) {
        return xquery(text, namespaces.getNamespaces());
    }
    /**
     * Evaluates an <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery expression</a>
     * with the specified set of namespace prefixes and URIs
     *
     * @param text       the expression to be evaluated
     * @param namespaces the namespace prefix and URIs to use
     * @return the builder to continue processing the DSL
     */
    public T xquery(String text, Map<String, String> namespaces) {
        XQueryExpression expression = new XQueryExpression(text);
        expression.setNamespaces(namespaces);
        setExpressionType(expression);
        return result;
    }
    /**
     * Evaluates a given language name with the expression text
     *
     * @param language   the name of the language
     * @param expression the expression in the given language
     * @return the builder to continue processing the DSL
     */
    public T language(String language, String expression) {
        setLanguage(language);
        setExpression(expression);
        return result;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getLanguage() {
        return language;
    }
    public void setLanguage(String language) {
        this.language = language;
    }
}
"
org.apache.camel.builder.InterceptorBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.processor.DelegateProcessor;
/**
 * @version $Revision: 630591 $
 */
public class InterceptorBuilderTest extends TestSupport {
    /**
     * Validates that interceptors are executed in the right order.
     * 
     * @throws Exception
     */
    public void testRouteWithInterceptor() throws Exception {
        CamelContext container = new DefaultCamelContext();
        final ArrayList<String> order = new ArrayList<String>();
        final DelegateProcessor interceptor1 = new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                order.add(""START:1"");
                super.process(exchange);
                order.add(""END:1"");
            }
        };
        final DelegateProcessor interceptor2 = new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                order.add(""START:2"");
                super.process(exchange);
                order.add(""END:2"");
            }
        };
        final Processor orderProcessor = new Processor() {
            public void process(Exchange exchange) {
                order.add(""INVOKED"");
            }
        };
        final Processor toProcessor = new Processor() {
            public void process(Exchange exchange) {
                order.add(""TO"");
            }
        };
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                //from(""direct:a"").intercept(interceptor1).intercept(interceptor2).to(""direct:d"");
                from(""direct:a"").intercept(interceptor1).process(orderProcessor).intercept(interceptor2).process(toProcessor);
                /*
                 * TODO keep old DSL? .intercept() .add(interceptor1)
                 * .add(interceptor2) .target().to(""direct:d"");
                 */
            }
        };
        container.addRoutes(builder);
        container.start();
        Endpoint endpoint = container.getEndpoint(""direct:a"");
        Exchange exchange = endpoint.createExchange();
        Producer producer = endpoint.createProducer();
        producer.process(exchange);
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""START:1"");
        expected.add(""INVOKED"");
        expected.add(""START:2"");
        expected.add(""TO"");
        expected.add(""END:2"");
        expected.add(""END:1"");
        log.debug(""Interceptor invocation order:"" + order);
        assertEquals(expected, order);
    }
}
"
org.apache.camel.builder.InterceptorBuilderWithEndTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.processor.DelegateProcessor;
/**
 * @version $Revision: 630591 $
 */
public class InterceptorBuilderWithEndTest extends TestSupport {
    /**
     * Validates that interceptors are executed in the right order.
     *
     * @throws Exception
     */
    public void testRouteWithInterceptor() throws Exception {
        CamelContext container = new DefaultCamelContext();
        final ArrayList<String> order = new ArrayList<String>();
        final DelegateProcessor interceptor1 = new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                order.add(""START:1"");
                super.process(exchange);
                order.add(""END:1"");
            }
        };
        final DelegateProcessor interceptor2 = new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                order.add(""START:2"");
                super.process(exchange);
                order.add(""END:2"");
            }
        };
        final Processor orderProcessor = new Processor() {
            public void process(Exchange exchange) {
                order.add(""INVOKED"");
            }
        };
        final Processor toProcessor = new Processor() {
            public void process(Exchange exchange) {
                order.add(""TO"");
            }
        };
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                //from(""direct:a"").intercept(interceptor1).intercept(interceptor2).to(""direct:d"");
                from(""direct:a"").intercept(interceptor1).process(orderProcessor).end().intercept(interceptor2).process(toProcessor);
                /*
                 * TODO keep old DSL? .intercept() .add(interceptor1)
                 * .add(interceptor2) .target().to(""direct:d"");
                 */
            }
        };
        container.addRoutes(builder);
        container.start();
        Endpoint endpoint = container.getEndpoint(""direct:a"");
        Exchange exchange = endpoint.createExchange();
        Producer producer = endpoint.createProducer();
        producer.process(exchange);
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""START:1"");
        expected.add(""INVOKED"");
        expected.add(""END:1"");
        expected.add(""START:2"");
        expected.add(""TO"");
        expected.add(""END:2"");
        log.debug(""Interceptor invocation order:"" + order);
        assertEquals(expected, order);
    }
}
"
org.apache.camel.builder.LoggingErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingErrorHandler;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Uses the {@link Logger} as an error handler
 *
 * @version $Revision: 674383 $
 */
public class LoggingErrorHandlerBuilder extends ErrorHandlerBuilderSupport {
    private Log log = LogFactory.getLog(Logger.class);
    private LoggingLevel level = LoggingLevel.INFO;
    public LoggingErrorHandlerBuilder() {
    }
    public LoggingErrorHandlerBuilder(Log log) {
        this.log = log;
    }
    public LoggingErrorHandlerBuilder(Log log, LoggingLevel level) {
        this.log = log;
        this.level = level;
    }
    public ErrorHandlerBuilder copy() {
        LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder();
        answer.setLog(getLog());
        answer.setLevel(getLevel());
        return answer;
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) {
        LoggingErrorHandler handler = new LoggingErrorHandler(processor, log, level);
        configure(handler);
        return handler;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
}
"
org.apache.camel.builder.MyInterceptorProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class MyInterceptorProcessor extends DelegateProcessor {
    private static final transient Log LOG = LogFactory.getLog(MyInterceptorProcessor.class);
    public void process(Exchange exchange) throws Exception {
        LOG.debug(""START of onExchange: "" + exchange);
        super.process(exchange);
        LOG.debug(""END of onExchange: "" + exchange);
    }
}
"
org.apache.camel.builder.MyProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class MyProcessor implements Processor {
    private static final transient Log LOG = LogFactory.getLog(MyProcessor.class);
    public void process(Exchange exchange) {
        LOG.debug(""Called with exchange: "" + exchange);
    }
    @Override
    public String toString() {
        return ""MyProcessor"";
    }
}
"
org.apache.camel.builder.NoErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * A builder to disable the use of an error handler so that any exceptions are thrown.
 * This not recommended in general, the
 * <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a> should be used
 * if you are unsure; however it can be useful sometimes to disable an error handler inside a complex route
 * so that exceptions bubble up to the parent {@link Processor}
 *
 * @version $Revision: 673837 $
 */
public class NoErrorHandlerBuilder extends ErrorHandlerBuilderSupport {
    public ErrorHandlerBuilder copy() {
        return this;
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) {
        return processor;
    }
}
"
org.apache.camel.builder.NoRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
/**
 * A helper class, usually used for testing which does not create any routes.
 *
 * @version $Revision: 663018 $
 */
public class NoRouteBuilder extends RouteBuilder {
    private static final NoRouteBuilder INSTANCE = new NoRouteBuilder();
    public static NoRouteBuilder getInstance() {
        return INSTANCE;
    }
    public void configure() throws Exception {
    }
}
"
org.apache.camel.builder.PredicateBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.compare;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A helper class for working with predicates
 *
 * @version $Revision: 663047 $
 */
public final class PredicateBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private PredicateBuilder() {
    }
    /**
     * Converts the given expression into an {@link Predicate}
     */
    public static <E extends Exchange> Predicate<E> toPredicate(final Expression<E> expression) {
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                return ObjectHelper.evaluateValuePredicate(value);
            }
            @Override
            public String toString() {
                return expression.toString();
            }
        };
    }
    /**
     * A helper method to return the logical not of the given predicate
     */
    public static <E extends Exchange> Predicate<E> not(final Predicate<E> predicate) {
        notNull(predicate, ""predicate"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return !predicate.matches(exchange);
            }
            @Override
            public String toString() {
                return ""not "" + predicate;
            }
        };
    }
    /**
     * A helper method to combine multiple predicates by a logical AND
     */
    public static <E extends Exchange> Predicate<E> and(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) && right.matches(exchange);
            }
            @Override
            public String toString() {
                return ""("" + left + "") and ("" + right + "")"";
            }
        };
    }
    /**
     * A helper method to combine multiple predicates by a logical OR
     */
    public static <E extends Exchange> Predicate<E> or(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) || right.matches(exchange);
            }
            @Override
            public String toString() {
                return ""("" + left + "") or ("" + right + "")"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isEqualTo(final Expression<E> left,
                                                              final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.equal(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""=="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isNotEqualTo(final Expression<E> left,
                                                                 final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return !ObjectHelper.equal(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""!="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isLessThan(final Expression<E> left,
                                                               final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) < 0;
            }
            protected String getOperationText() {
                return ""<"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isLessThanOrEqualTo(final Expression<E> left,
                                                                        final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) <= 0;
            }
            protected String getOperationText() {
                return ""<="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isGreaterThan(final Expression<E> left,
                                                                  final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) > 0;
            }
            protected String getOperationText() {
                return "">"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isGreaterThanOrEqualTo(final Expression<E> left,
                                                                           final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) >= 0;
            }
            protected String getOperationText() {
                return "">="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> contains(final Expression<E> left,
                                                             final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.contains(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""contains"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isNull(final Expression<E> expression) {
        return isEqualTo(expression, ExpressionBuilder.<E> constantExpression(null));
    }
    public static <E extends Exchange> Predicate<E> isNotNull(final Expression<E> expression) {
        return isNotEqualTo(expression, ExpressionBuilder.<E> constantExpression(null));
    }
    public static <E extends Exchange> Predicate<E> isInstanceOf(final Expression<E> expression,
                                                                 final Class type) {
        notNull(expression, ""expression"");
        notNull(type, ""type"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                return type.isInstance(value);
            }
            @Override
            public String toString() {
                return expression + "" instanceof "" + type.getName();
            }
            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange) + "" for <"" + expression.evaluate(exchange)
                       + "">"";
            }
        };
    }
    /**
     * Returns a predicate which is true if the expression matches the given
     * regular expression
     *
     * @param expression the expression to evaluate
     * @param regex the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression, final String regex) {
        return regex(expression, Pattern.compile(regex));
    }
    /**
     * Returns a predicate which is true if the expression matches the given
     * regular expression
     *
     * @param expression the expression to evaluate
     * @param pattern the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression,
                                                          final Pattern pattern) {
        notNull(expression, ""expression"");
        notNull(pattern, ""pattern"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                if (value != null) {
                    Matcher matcher = pattern.matcher(value.toString());
                    return matcher.matches();
                }
                return false;
            }
            @Override
            public String toString() {
                return expression + "".matches("" + pattern + "")"";
            }
            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange) + "" for <"" + expression.evaluate(exchange)
                       + "">"";
            }
        };
    }
}
"
org.apache.camel.builder.PredicateBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import static org.apache.camel.builder.Builder.constant;
/**
 * @version $Revision: 630591 $
 */
public class PredicateBuilderTest extends TestSupport {
    protected Exchange exchange = new DefaultExchange(new DefaultCamelContext());
    public void testRegexPredicates() throws Exception {
        assertMatches(header(""location"").regex(""[a-zA-Z]+,London,UK""));
        assertDoesNotMatch(header(""location"").regex(""[a-zA-Z]+,Westminster,[a-zA-Z]+""));
    }
    public void testPredicates() throws Exception {
        assertMatches(header(""name"").isEqualTo(constant(""James"")));
    }
    public void testFailingPredicates() throws Exception {
        assertDoesNotMatch(header(""name"").isEqualTo(constant(""Hiram"")));
        assertDoesNotMatch(header(""size"").isGreaterThan(constant(100)));
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Message in = exchange.getIn();
        in.setBody(""Hello there!"");
        in.setHeader(""name"", ""James"");
        in.setHeader(""location"", ""Islington,London,UK"");
        in.setHeader(""size"", 10);
    }
    protected void assertMatches(Predicate<Exchange> predicate) {
        assertPredicateMatches(predicate, exchange);
    }
    protected void assertDoesNotMatch(Predicate<Exchange> predicate) {
        assertPredicateDoesNotMatch(predicate, exchange);
    }
}
"
org.apache.camel.builder.PredicateFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A Factory of {@link Predicate} objects typically implemented by a builder such as
 * {@link org.apache.camel.builder.xml.XPathBuilder XPathBuilder}
 *
 * @version $Revision: 659760 $
 */
public interface PredicateFactory<E extends Exchange> {
    /**
     * Creates a predicate object
     *
     * @return the newly created expression object
     */
    Predicate<E> createPredicate();
}
"
org.apache.camel.builder.PredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A useful base class for {@link Predicate} implementations
 *
 * @version $Revision: 663018 $
 */
public abstract class PredicateSupport<E extends Exchange> implements Predicate<E> {
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(assertionFailureMessage(exchange)  + "" on "" + exchange);
        }
    }
    protected String assertionFailureMessage(E exchange) {
        return toString();
    }
}
"
org.apache.camel.builder.ProcessorBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
/**
 * A builder of a number of different {@link Processor} implementations
 *
 * @version $Revision: 642209 $
 */
public final class ProcessorBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private ProcessorBuilder() {
    }
    /**
     * Creates a processor which sets the body of the IN message to the value of the expression
     */
    public static Processor setBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getIn().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setBody("" + expression + "")"";
            }
        };
    }
    /**
     * Creates a processor which sets the body of the OUT message to the value of the expression
     */
    public static Processor setOutBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getOut().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setOutBody("" + expression + "")"";
            }
        };
    }
    /**
     * Creates a processor which sets the body of the FAULT message to the value of the expression
     */
    public static Processor setFaultBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getFault().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setFaultBody("" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the IN message
     */
    public static Processor setHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getIn().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the OUT message
     */
    public static Processor setOutHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getOut().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setOutHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the FAULT message
     */
    public static Processor setFaultHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getFault().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setFaultHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the property on the exchange
     */
    public static Processor setProperty(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.setProperty(name, value);
            }
            @Override
            public String toString() {
                return ""setProperty("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Removes the header on the IN message
     */
    public static Processor removeHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().removeHeader(name);
            }
            @Override
            public String toString() {
                return ""removeHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the header on the OUT message
     */
    public static Processor removeOutHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                Message out = exchange.getOut(false);
                if (out != null) {
                    out.removeHeader(name);
                }
            }
            @Override
            public String toString() {
                return ""removeOutHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the header on the FAULT message
     */
    public static Processor removeFaultHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.getFault().removeHeader(name);
            }
            @Override
            public String toString() {
                return ""removeFaultHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the property on the exchange
     */
    public static Processor removeProperty(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.removeProperty(name);
            }
            @Override
            public String toString() {
                return ""removeProperty("" + name +  "")"";
            }
        };
    }
    /**
     * Throws an exception
     */
    public static Processor throwException(final Exception ex) {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                throw ex;
            }
            @Override
            public String toString() {
                return ""throwException("" + ex.toString() +  "")"";
            }
        };
    }
}
"
org.apache.camel.builder.ProcessorFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
/**
 * An interface representing a builder of a {@link Processor}
 *
 * @version $Revision: 630591 $
 */
public interface ProcessorFactory {
    Processor createProcessor() throws Exception;
}
"
org.apache.camel.builder.RouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Predicate;
import org.apache.camel.Route;
import org.apache.camel.Routes;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.model.InterceptType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.RoutesType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
/**
 * A <a href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a> which is
 * used to build {@link Route} instances in a {@link CamelContext} for smart routing.
 *
 * @version $Revision: 662722 $
 */
public abstract class RouteBuilder extends BuilderSupport implements Routes {
    private AtomicBoolean initialized = new AtomicBoolean(false);
    private RoutesType routeCollection = new RoutesType();
    private List<Route> routes = new ArrayList<Route>();
    public RouteBuilder() {
        this(null);
    }
    public RouteBuilder(CamelContext context) {
        super(context);
    }
    @Override
    public String toString() {
        return routeCollection.toString();
    }
    /**
     * Called on initialization to to build the required destinationBuilders
     */
    public abstract void configure() throws Exception;
    /**
     * Creates a new route from the given URI input
     */
    public RouteType from(String uri) {
        RouteType answer = routeCollection.from(uri);
        configureRoute(answer);
        return answer;
    }
    /**
     * Creates a new route from the given endpoint
     */
    public RouteType from(Endpoint endpoint) {
        RouteType answer = routeCollection.from(endpoint);
        configureRoute(answer);
        return answer;
    }
    /**
     * Installs the given error handler builder
     *
     * @param errorHandlerBuilder the error handler to be used by default for
     *                all child routes
     * @return the current builder with the error handler configured
     */
    public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return this;
    }
    /**
     * Configures whether or not the error handler is inherited by every
     * processing node (or just the top most one)
     *
     * @param value the flag as to whether error handlers should be inherited or not
     * @return the current builder
     */
    public RouteBuilder inheritErrorHandler(boolean value) {
        routeCollection.setInheritErrorHandlerFlag(value);
        return this;
    }
    /**
     * Adds the given interceptor to this route
     */
    public RouteBuilder intercept(DelegateProcessor interceptor) {
        routeCollection.intercept(interceptor);
        return this;
    }
    /**
     * Adds a route for an interceptor; use the {@link ProcessorType#proceed()} method
     * to continue processing the underlying route being intercepted.
     */
    public InterceptType intercept() {
        return routeCollection.intercept();
    }
    /**
     * Applies a route for an interceptor if the given predicate is true
     * otherwise the interceptor route is not applied
     */
    public ChoiceType intercept(Predicate predicate) {
        return routeCollection.intercept(predicate);
    }
    /**
     * Adds an exception handler route for the given exception type
     */
    public ExceptionType exception(Class exceptionType) {
        return routeCollection.exception(exceptionType);
    }
    // Properties
    // -----------------------------------------------------------------------
    public CamelContext getContext() {
        CamelContext context = super.getContext();
        if (context == null) {
            context = createContainer();
            setContext(context);
        }
        return context;
    }
    /**
     * Returns the routing map from inbound endpoints to processors
     */
    public List<Route> getRouteList() throws Exception {
        checkInitialized();
        return routes;
    }
    @Override
    public void setInheritErrorHandler(boolean inheritErrorHandler) {
        super.setInheritErrorHandler(inheritErrorHandler);
        routeCollection.setInheritErrorHandlerFlag(inheritErrorHandler);
    }
    @Override
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        super.setErrorHandlerBuilder(errorHandlerBuilder);
        routeCollection.setErrorHandlerBuilder(getErrorHandlerBuilder());
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void checkInitialized() throws Exception {
        if (initialized.compareAndSet(false, true)) {
            configure();
            populateRoutes(routes);
        }
    }
    protected void populateRoutes(List<Route> routes) throws Exception {
        CamelContext camelContext = getContext();
        if (camelContext == null) {
            throw new IllegalArgumentException(""No CamelContext has been injected!"");
        }
        routeCollection.setCamelContext(camelContext);
        camelContext.addRouteDefinitions(routeCollection.getRoutes());
    }
    public void setRouteCollection(RoutesType routeCollection) {
        this.routeCollection = routeCollection;
    }
    public RoutesType getRouteCollection() {
        return this.routeCollection;
    }
    /**
     * Completely disable stream caching for all routes being defined in the same RouteBuilder after this. 
     */
    public void noStreamCaching() {
        StreamCachingInterceptor.noStreamCaching(routeCollection.getInterceptors());
    }
    /**
     * Enable stream caching for all routes being defined in the same RouteBuilder after this call.
     */
    public void streamCaching() {
        routeCollection.intercept(new StreamCachingInterceptor());
    }
    /**
     * Factory method
     */
    protected CamelContext createContainer() {
        return new DefaultCamelContext();
    }
    protected void configureRoute(RouteType route) {
        route.setGroup(getClass().getName());
    }
}
"
org.apache.camel.builder.RouteBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.Route;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.management.InstrumentationProcessor;
import org.apache.camel.management.JmxSystemPropertyKeys;
import org.apache.camel.processor.ChoiceProcessor;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.processor.MulticastProcessor;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.processor.Splitter;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MemoryMessageIdRepository;
import static org.apache.camel.processor.idempotent.MemoryMessageIdRepository.memoryMessageIdRepository;
/**
 * @version $Revision: 669756 $
 */
public class RouteBuilderTest extends TestSupport {
    protected Processor myProcessor = new MyProcessor();
    protected DelegateProcessor interceptor1;
    protected DelegateProcessor interceptor2;
    protected List<Route> buildSimpleRoute() throws Exception {
        // START SNIPPET: e1
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").to(""seda:b"");
            }
        };
        // END SNIPPET: e1
        return getRouteList(builder);
    }
    public void testSimpleRoute() throws Exception {
        List<Route> routes = buildSimpleRoute();
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route<Exchange> route : routes) {
            Endpoint<Exchange> key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            SendProcessor sendProcessor;
            if (Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                sendProcessor = assertIsInstanceOf(SendProcessor.class, processor);
            } else {
                InstrumentationProcessor interceptor =
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                sendProcessor = assertIsInstanceOf(SendProcessor.class, interceptor.getProcessor());
            }
            assertEquals(""Endpoint URI"", ""seda:b"", sendProcessor.getDestination().getEndpointUri());
        }
    }
    protected List<Route> buildSimpleRouteWithHeaderPredicate() throws Exception {
        // START SNIPPET: e2
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").filter(header(""foo"").isEqualTo(""bar"")).to(""seda:b"");
            }
        };
        // END SNIPPET: e2
        return getRouteList(builder);
    }
    public void testSimpleRouteWithHeaderPredicate() throws Exception {
        List<Route> routes = buildSimpleRouteWithHeaderPredicate();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            FilterProcessor filterProcessor = assertIsInstanceOf(FilterProcessor.class, processor);
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class,
                    unwrapErrorHandler(filterProcessor
                            .getProcessor()));
            assertEquals(""Endpoint URI"", ""seda:b"", sendProcessor.getDestination().getEndpointUri());
        }
    }
    protected List<Route> buildSimpleRouteWithChoice() throws Exception {
        // START SNIPPET: e3
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").choice().when(header(""foo"").isEqualTo(""bar"")).to(""seda:b"")
                    .when(header(""foo"").isEqualTo(""cheese"")).to(""seda:c"").otherwise().to(""seda:d"");
            }
        };
        // END SNIPPET: e3
        return getRouteList(builder);
    }
    public void testSimpleRouteWithChoice() throws Exception {
        List<Route> routes = buildSimpleRouteWithChoice();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            ChoiceProcessor choiceProcessor = assertIsInstanceOf(ChoiceProcessor.class, processor);
            List<FilterProcessor> filters = choiceProcessor.getFilters();
            assertEquals(""Should be two when clauses"", 2, filters.size());
            FilterProcessor filter1 = filters.get(0);
            assertSendTo(filter1.getProcessor(), ""seda:b"");
            FilterProcessor filter2 = filters.get(1);
            assertSendTo(filter2.getProcessor(), ""seda:c"");
            assertSendTo(choiceProcessor.getOtherwise(), ""seda:d"");
        }
    }
    protected List<Route> buildCustomProcessor() throws Exception {
        // START SNIPPET: e4
        myProcessor = new Processor() {
            public void process(Exchange exchange) {
                log.debug(""Called with exchange: "" + exchange);
            }
        };
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").process(myProcessor);
            }
        };
        // END SNIPPET: e4
        return getRouteList(builder);
    }
    public void testCustomProcessor() throws Exception {
        List<Route> routes = buildCustomProcessor();
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            assertEquals(""Should be called with my processor"", myProcessor, processor);
        }
    }
    protected List<Route> buildCustomProcessorWithFilter() throws Exception {
        // START SNIPPET: e5
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").filter(header(""foo"").isEqualTo(""bar"")).process(myProcessor);
            }
        };
        // END SNIPPET: e5
        return getRouteList(builder);
    }
    public void testCustomProcessorWithFilter() throws Exception {
        List<Route> routes = buildCustomProcessorWithFilter();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            FilterProcessor filterProcessor = assertIsInstanceOf(FilterProcessor.class, processor);
            assertEquals(""Should be called with my processor"", myProcessor,
                         unwrapErrorHandler(filterProcessor.getProcessor()));
        }
    }
    protected List<Route> buildWireTap() throws Exception {
        // START SNIPPET: e6
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").to(""seda:tap"", ""seda:b"");
            }
        };
        // END SNIPPET: e6
        return getRouteList(builder);
    }
    public void testWireTap() throws Exception {
        List<Route> routes = buildWireTap();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            MulticastProcessor multicastProcessor = assertIsInstanceOf(MulticastProcessor.class, processor);
            List<Processor> endpoints = new ArrayList<Processor>(multicastProcessor.getProcessors());
            assertEquals(""Should have 2 endpoints"", 2, endpoints.size());
            assertSendToProcessor(endpoints.get(0), ""seda:tap"");
            assertSendToProcessor(endpoints.get(1), ""seda:b"");
        }
    }
    protected List<Route> buildRouteWithInterceptor() throws Exception {
        interceptor1 = new DelegateProcessor() {
        };
        // START SNIPPET: e7
        interceptor2 = new MyInterceptorProcessor();
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").intercept(interceptor1).intercept(interceptor2).to(""seda:d"");
                /*
                 *
                 * TODO keep old DSL? .intercept() .add(interceptor1)
                 * .add(interceptor2) .target().to(""seda:d"");
                 */
            }
        };
        // END SNIPPET: e7
        return getRouteList(builder);
    }
    public void testRouteWithInterceptor() throws Exception {
        List<Route> routes = buildRouteWithInterceptor();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            DelegateProcessor p1 = assertIsInstanceOf(DelegateProcessor.class, processor);
            processor = p1.getProcessor();
            DelegateProcessor p2 = assertIsInstanceOf(DelegateProcessor.class, processor);
            assertSendTo(p2.getProcessor(), ""seda:d"");
        }
    }
    public void testComplexExpressions() throws Exception {
        // START SNIPPET: e7
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").filter(header(""foo"").isEqualTo(123)).to(""seda:b"");
                from(""seda:a"").filter(header(""bar"").isGreaterThan(45)).to(""seda:b"");
            }
        };
        // END SNIPPET: e7
        List<Route> routes = getRouteList(builder);
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 2, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            log.debug(""processor: "" + processor);
            /*
             * TODO FilterProcessor filterProcessor =
             * assertIsInstanceOf(FilterProcessor.class, processor);
             *
             * SendProcessor sendProcessor =
             * assertIsInstanceOf(SendProcessor.class,
             * filterProcessor.getProcessor()); assertEquals(""Endpoint URI"",
             * ""seda:b"", sendProcessor.getDestination().getEndpointUri());
             */
        }
    }
    protected List<Route> buildStaticRecipientList() throws Exception {
        // START SNIPPET: e8
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").to(""seda:b"", ""seda:c"", ""seda:d"");
            }
        };
        // END SNIPPET: e8
        return getRouteList(builder);
    }
    protected List<Route> buildDynamicRecipientList() throws Exception {
        // START SNIPPET: e9
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").recipientList(header(""foo""));
            }
        };
        // END SNIPPET: e9
        return getRouteList(builder);
    }
    public void testRouteDynamicReceipentList() throws Exception {
        List<Route> routes = buildDynamicRecipientList();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            RecipientList p1 = assertIsInstanceOf(RecipientList.class, processor);
        }
    }
    protected List<Route> buildSplitter() throws Exception {
        // START SNIPPET: splitter
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").splitter(bodyAs(String.class).tokenize(""\n"")).to(""seda:b"");
            }
        };
        // END SNIPPET: splitter
        return getRouteList(builder);
    }
    public void testSplitter() throws Exception {
        List<Route> routes = buildSplitter();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            Splitter p1 = assertIsInstanceOf(Splitter.class, processor);
        }
    }
    protected List<Route> buildIdempotentConsumer() throws Exception {
        // START SNIPPET: idempotent
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").idempotentConsumer(header(""myMessageId""), memoryMessageIdRepository(200))
                    .to(""seda:b"");
            }
        };
        // END SNIPPET: idempotent
        return getRouteList(builder);
    }
    public void testIdempotentConsumer() throws Exception {
        List<Route> routes = buildIdempotentConsumer();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
                InstrumentationProcessor interceptor = 
                    assertIsInstanceOf(InstrumentationProcessor.class, processor);
                processor = interceptor.getProcessor();
            }
            IdempotentConsumer idempotentConsumer = assertIsInstanceOf(IdempotentConsumer.class, processor);
            assertEquals(""messageIdExpression"", ""header(myMessageId)"", idempotentConsumer
                .getMessageIdExpression().toString());
            assertIsInstanceOf(MemoryMessageIdRepository.class, idempotentConsumer.getMessageIdRepository());
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class,
                                                             unwrapErrorHandler(idempotentConsumer
                                                                 .getNextProcessor()));
            assertEquals(""Endpoint URI"", ""seda:b"", sendProcessor.getDestination().getEndpointUri());
        }
    }
    protected void assertSendTo(Processor processor, String uri) {
        if (!(processor instanceof SendProcessor)) {
            processor = unwrapErrorHandler(processor);
        }
        SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class, processor);
        assertEquals(""Endpoint URI"", uri, sendProcessor.getDestination().getEndpointUri());
    }
    protected void assertSendToProcessor(Processor processor, String uri) {
        if (!(processor instanceof Producer)) {
            processor = unwrapErrorHandler(processor);
        }
        if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
            InstrumentationProcessor interceptor = 
                assertIsInstanceOf(InstrumentationProcessor.class, processor);
            processor = interceptor.getProcessor();
        }
        if (processor instanceof SendProcessor) {
            assertSendTo(processor, uri);
        } else {
            Producer producer = assertIsInstanceOf(Producer.class, processor);
            assertEquals(""Endpoint URI"", uri, producer.getEndpoint().getEndpointUri());
        }
    }
    /**
     * By default routes should be wrapped in the {@link DeadLetterChannel} so
     * lets unwrap that and return the actual processor
     */
    protected Processor getProcessorWithoutErrorHandler(Route route) {
        EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
        Processor processor = unwrap(consumerRoute.getProcessor());
        return unwrapErrorHandler(processor);
    }
    protected Processor unwrapErrorHandler(Processor processor) {
        if (processor instanceof DeadLetterChannel) {
            DeadLetterChannel deadLetter = (DeadLetterChannel)processor;
            return deadLetter.getOutput();
        } else {
            return processor;
        }
    }
}
"
org.apache.camel.builder.ValueBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * A builder of expressions or predicates based on values.
 * 
 * @version $Revision: 630591 $
 */
public class ValueBuilder<E extends Exchange> implements Expression<E> {
    private Expression<E> expression;
    public ValueBuilder(Expression<E> expression) {
        this.expression = expression;
    }
    public Object evaluate(E exchange) {
        return expression.evaluate(exchange);
    }
    public Expression<E> getExpression() {
        return expression;
    }
    @Override
    public String toString() {
        return expression.toString();
    }
    // Predicate builders
    // -------------------------------------------------------------------------
    public Predicate<E> isNotEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isNotEqualTo(expression, right));
    }
    public Predicate<E> isEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isEqualTo(expression, right));
    }
    public Predicate<E> isLessThan(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThan(expression, right));
    }
    public Predicate<E> isLessThanOrEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThanOrEqualTo(expression, right));
    }
    public Predicate<E> isGreaterThan(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThan(expression, right));
    }
    public Predicate<E> isGreaterThanOrEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThanOrEqualTo(expression, right));
    }
    public Predicate<E> isInstanceOf(Class type) {
        return onNewPredicate(PredicateBuilder.isInstanceOf(expression, type));
    }
    public Predicate<E> matchesRegex(String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }
    public Predicate<E> isNull() {
        return onNewPredicate(PredicateBuilder.isNull(expression));
    }
    public Predicate<E> isNotNull() {
        return onNewPredicate(PredicateBuilder.isNotNull(expression));
    }
    /**
     * Create a predicate that the left hand expression contains the value of
     * the right hand expression
     * 
     * @param value the element which is compared to be contained within this
     *                expression
     * @return a predicate which evaluates to true if the given value expression
     *         is contained within this expression value
     */
    public Predicate<E> contains(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.contains(expression, right));
    }
    /**
     * Creates a predicate which is true if this expression matches the given
     * regular expression
     * 
     * @param regex the regular expression to match
     * @return a predicate which evaluates to true if the expression matches the
     *         regex
     */
    public Predicate<E> regex(String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }
    // Expression builders
    // -------------------------------------------------------------------------
    public ValueBuilder<E> tokenize() {
        return tokenize(""\n"");
    }
    public ValueBuilder<E> tokenize(String token) {
        Expression<E> newExp = ExpressionBuilder.tokenizeExpression(expression, token);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Tokenizes the string conversion of this expression using the given
     * regular expression
     */
    public ValueBuilder<E> regexTokenize(String regex) {
        Expression<E> newExp = ExpressionBuilder.regexTokenize(expression, regex);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Replaces all occurrencies of the regular expression with the given
     * replacement
     */
    public ValueBuilder<E> regexReplaceAll(String regex, String replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Replaces all occurrencies of the regular expression with the given
     * replacement
     */
    public ValueBuilder<E> regexReplaceAll(String regex, Expression<E> replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Converts the current value to the given type using the registered type
     * converters
     * 
     * @param type the type to convert the value to
     * @return the current builder
     */
    public ValueBuilder<E> convertTo(Class type) {
        Expression<E> newExp = ExpressionBuilder.convertTo(expression, type);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Converts the current value a String using the registered type converters
     * 
     * @return the current builder
     */
    public ValueBuilder<E> convertToString() {
        return convertTo(String.class);
    }
    /**
     * Appends the string evaluation of this expression with the given value
     * 
     * @param value the value or expression to append
     * @return the current builder
     */
    public ValueBuilder<E> append(Object value) {
        return new ValueBuilder<E>(ExpressionBuilder.append(expression, asExpression(value)));
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A stategy method to allow derived classes to deal with the newly created
     * predicate in different ways
     */
    protected Predicate<E> onNewPredicate(Predicate<E> predicate) {
        return predicate;
    }
    protected Expression<E> asExpression(Object value) {
        if (value instanceof Expression) {
            return (Expression<E>)value;
        } else {
            return ExpressionBuilder.constantExpression(value);
        }
    }
}
"
org.apache.camel.builder.xml.DefaultNamespaceContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.xml.namespace.NamespaceContext;
import javax.xml.xpath.XPathFactory;
import org.apache.camel.spi.NamespaceAware;
/**
 * An implementation of {@link NamespaceContext} which uses a simple Map where
 * the keys are the prefixes and the values are the URIs
 *
 * @version $Revision: 640438 $
 */
public class DefaultNamespaceContext implements NamespaceContext, NamespaceAware {
    private final Map<String, String> map;
    private final NamespaceContext parent;
    public DefaultNamespaceContext() {
        this(XPathFactory.newInstance());
    }
    public DefaultNamespaceContext(XPathFactory factory) {
        this.parent = factory.newXPath().getNamespaceContext();
        this.map = new HashMap<String, String>();
    }
    public DefaultNamespaceContext(NamespaceContext parent, Map<String, String> map) {
        this.parent = parent;
        this.map = map;
    }
    /**
     * A helper method to make it easy to create newly populated instances
     */
    public DefaultNamespaceContext add(String prefix, String uri) {
        map.put(prefix, uri);
        return this;
    }
    public String getNamespaceURI(String prefix) {
        String answer = map.get(prefix);
        if (answer == null && parent != null) {
            return parent.getNamespaceURI(prefix);
        }
        return answer;
    }
    public String getPrefix(String namespaceURI) {
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                return (String) entry.getKey();
            }
        }
        if (parent != null) {
            return parent.getPrefix(namespaceURI);
        }
        return null;
    }
    public Iterator getPrefixes(String namespaceURI) {
        Set set = new HashSet();
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                set.add(entry.getKey());
            }
        }
        if (parent != null) {
            Iterator iter = parent.getPrefixes(namespaceURI);
            while (iter.hasNext()) {
                set.add(iter.next());
            }
        }
        return set.iterator();
    }
    public void setNamespaces(Map<String, String> namespaces) {
        map.putAll(namespaces);
    }
}
"
org.apache.camel.builder.xml.DomResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.transform.Result;
import javax.xml.transform.dom.DOMResult;
import org.apache.camel.Message;
/**
 * Uses DOM to handle results of the transformation
 *
 * @version $Revision: 630591 $
 */
public class DomResultHandler implements ResultHandler {
    private DOMResult result = new DOMResult();
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(result.getNode());
    }
}
"
org.apache.camel.builder.xml.DomResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link DomResultHandler}
 *
 * @version $Revision: 660275 $
 */
public class DomResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new DomResultHandler();
    }
}
"
org.apache.camel.builder.xml.InvalidXPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.xpath.XPathException;
import org.apache.camel.RuntimeExpressionException;
/**
 * An exception thrown if am XPath expression could not be parsed or evaluated
 *
 * @version $Revision: 630591 $
 */
public class InvalidXPathExpression extends RuntimeExpressionException {
    private final String xpath;
    public InvalidXPathExpression(String xpath, XPathException e) {
        super(""Invalid xpath: "" + xpath + "". Reason: "" + e, e);
        this.xpath = xpath;
    }
    public String getXpath() {
        return xpath;
    }
}
"
org.apache.camel.builder.xml.MessageVariableResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.xpath.XPathVariableResolver;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.builder.xml.Namespaces.ENVIRONMENT_VARIABLES;
import static org.apache.camel.builder.xml.Namespaces.EXCHANGE_PROPERTY;
import static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.SYSTEM_PROPERTIES_NAMESPACE;
/**
 * A variable resolver for XPath expressions which support properties on the
 * messge, exchange as well as making system properties and environment
 * properties available.
 * 
 * @version $Revision: 660275 $
 */
public class MessageVariableResolver implements XPathVariableResolver {
    private static final transient Log LOG = LogFactory.getLog(MessageVariableResolver.class);
    private Exchange exchange;
    private Map<String, Object> variables = new HashMap<String, Object>();
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    public Object resolveVariable(QName name) {
        String uri = name.getNamespaceURI();
        String localPart = name.getLocalPart();
        Object answer = null;
        Message in = exchange.getIn();
        if (uri == null || uri.length() == 0) {
            answer = variables.get(localPart);
            if (answer == null) {
                Message message = in;
                if (message != null) {
                    answer = message.getHeader(localPart);
                }
                if (answer == null) {
                    answer = exchange.getProperty(localPart);
                }
            }
        } else if (uri.equals(SYSTEM_PROPERTIES_NAMESPACE)) {
            try {
                answer = System.getProperty(localPart);
            } catch (Exception e) {
                LOG
                    .debug(""Security exception evaluating system property: "" + localPart + "". Reason: "" + e,
                           e);
            }
        } else if (uri.equals(ENVIRONMENT_VARIABLES)) {
            answer = System.getenv().get(localPart);
        } else if (uri.equals(EXCHANGE_PROPERTY)) {
            answer = exchange.getProperty(localPart);
        } else if (uri.equals(IN_NAMESPACE)) {
            answer = in.getHeader(localPart);
            if (answer == null && localPart.equals(""body"")) {
                answer = in.getBody();
            }
        } else if (uri.equals(OUT_NAMESPACE)) {
            Message out = exchange.getOut(false);
            if (out != null) {
                answer = out.getHeader(localPart);
                if (answer == null && localPart.equals(""body"")) {
                    answer = out.getBody();
                }
            }
        }
        // TODO support exposing CamelContext properties/resources via XPath?
        return answer;
    }
    public void addVariable(String localPart, Object value) {
        variables.put(localPart, value);
    }
}
"
org.apache.camel.builder.xml.Namespaces,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.Map;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.apache.camel.model.language.XPathExpression;
import org.apache.camel.model.language.XQueryExpression;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.util.ObjectHelper;
/**
 * A helper class for working with namespaces or creating namespace based expressions
 *
 * @version $Revision: 660275 $
 */
public class Namespaces {
    public static final String DEFAULT_NAMESPACE = ""http://activemq.apache.org/camel/schema/spring"";
    public static final String IN_NAMESPACE = ""http://camel.apache.org/xml/in/"";
    public static final String OUT_NAMESPACE = ""http://camel.apache.org/xml/out/"";
    public static final String SYSTEM_PROPERTIES_NAMESPACE = ""http://camel.apache.org/xml/variables/system-properties"";
    public static final String ENVIRONMENT_VARIABLES = ""http://camel.apache.org/xml/variables/environment-variables"";
    public static final String EXCHANGE_PROPERTY = ""http://camel.apache.org/xml/variables/exchange-property"";
    private Map<String, String> namespaces = new HashMap<String, String>();
    /**
     * Creates a namespaces object from the given XML element
     *
     * @param element the XML element representing the XPath namespace context
     */
    public Namespaces(Element element) {
        add(element);
    }
    /**
     * Creates a namespace context with a single prefix and URI
     */
    public Namespaces(String prefix, String uri) {
        add(prefix, uri);
    }
    /**
     * Returns true if the given namespaceURI is empty or if it matches the
     * given expected namespace
     */
    public static boolean isMatchingNamespaceOrEmptyNamespace(String namespaceURI, String expectedNamespace) {
        return ObjectHelper.isNullOrBlank(namespaceURI) || namespaceURI.equals(expectedNamespace);
    }
    public Namespaces add(String prefix, String uri) {
        namespaces.put(prefix, uri);
        return this;
    }
    public Namespaces add(Element element) {
        // lets set the parent first in case we overload a prefix here
        Node parentNode = element.getParentNode();
        if (parentNode instanceof org.w3c.dom.Element) {
            add((Element) parentNode);
        }
        NamedNodeMap attributes = element.getAttributes();
        int size = attributes.getLength();
        for (int i = 0; i < size; i++) {
            Attr node = (Attr) attributes.item(i);
            String name = node.getName();
            if (name.startsWith(""xmlns:"")) {
                String prefix = name.substring(""xmlns:"".length());
                String uri = node.getValue();
                add(prefix, uri);
            }
        }
        return this;
    }
    /**
     * Creates the XPath expression using the current namespace context
     */
    public XPathExpression xpath(String expression) {
        XPathExpression answer = new XPathExpression(expression);
        configure(answer);
        return answer;
    }
    /**
     * Creates the XPath expression using the current namespace context
     */
    public XPathExpression xpath(String expression, Class<?> resultType) {
        XPathExpression answer = xpath(expression);
        answer.setResultType(resultType);
        return answer;
    }
    /**
     * Creates the XQuery expression using the current namespace context
     */
    public XQueryExpression xquery(String expression) {
        XQueryExpression answer = new XQueryExpression(expression);
        configure(answer);
        return answer;
    }
    /**
     * Creates the XQuery expression using the current namespace context
     * and the given expected return type
     */
    public XQueryExpression xquery(String expression, Class<?> resultType) {
        XQueryExpression answer = new XQueryExpression(expression);
        answer.setResultType(resultType);
        configure(answer);
        return answer;
    }
    public Map<String, String> getNamespaces() {
        return namespaces;
    }
    /**
     * Configures the namespace aware object
     */
    public void configure(NamespaceAware namespaceAware) {
        namespaceAware.setNamespaces(getNamespaces());
    }
}
"
org.apache.camel.builder.xml.ResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.transform.Result;
import org.apache.camel.Message;
/**
 * A strategy for handling XSLT results
 *
 * @version $Revision: 660275 $
 */
public interface ResultHandler {
    Result getResult();
    void setBody(Message in);
}
"
org.apache.camel.builder.xml.ResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link org.apache.camel.builder.xml.ResultHandler}
 *
 * @version $Revision: 660275 $
 */
public interface ResultHandlerFactory {
    ResultHandler createResult();
}
"
org.apache.camel.builder.xml.StreamResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.ByteArrayOutputStream;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import org.apache.camel.Message;
/**
 * Processes the XSLT result as a byte[]
 *
 * @version $Revision: 630591 $
 */
public class StreamResultHandler implements ResultHandler {
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    StreamResult result = new StreamResult(buffer);
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(buffer.toByteArray());
    }
}
"
org.apache.camel.builder.xml.StreamResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link StreamResultHandler}
 *
 * @version $Revision: 660275 $
 */
public class StreamResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new StreamResultHandler();
    }
}
"
org.apache.camel.builder.xml.StringResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.StringWriter;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import org.apache.camel.Message;
/**
 * Processes the XSLT result as a String
 *
 * @version $Revision: 630591 $
 */
public class StringResultHandler implements ResultHandler {
    StringWriter buffer = new StringWriter();
    StreamResult result = new StreamResult(buffer);
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(buffer.toString());
    }
}
"
org.apache.camel.builder.xml.StringResultHandlerFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * Factory for {@link StringResultHandler}
 *
 * @version $Revision: 659760 $
 */
public class StringResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new StringResultHandler();
    }
}
"
org.apache.camel.builder.xml.XPathBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.StringReader;
import java.util.List;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.transform.dom.DOMSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathFactoryConfigurationException;
import javax.xml.xpath.XPathFunction;
import javax.xml.xpath.XPathFunctionException;
import javax.xml.xpath.XPathFunctionResolver;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.util.ExchangeHelper;
import static org.apache.camel.builder.xml.Namespaces.DEFAULT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.isMatchingNamespaceOrEmptyNamespace;
import static org.apache.camel.converter.ObjectConverter.toBoolean;
/**
 * Creates an XPath expression builder which creates a nodeset result by default.
 * If you want to evaluate a String expression then call {@link #stringResult()}
 *
 * @see XPathConstants#NODESET
 *
 * @version $Revision: 640438 $
 */
public class XPathBuilder<E extends Exchange> implements Expression<E>, Predicate<E>, NamespaceAware {
    private final String text;
    private XPathFactory xpathFactory;
    private Class documentType = Document.class;
    // For some reason the default expression of ""a/b"" on a document such as
    // <a><b>1</b><b>2</b></a>
    // will evaluate as just ""1"" by default which is bizarre. So by default
    // lets assume XPath expressions result in nodesets.
    private Class resultType;
    private QName resultQName = XPathConstants.NODESET;
    private String objectModelUri;
    private DefaultNamespaceContext namespaceContext;
    private XPathFunctionResolver functionResolver;
    private XPathExpression expression;
    private MessageVariableResolver variableResolver = new MessageVariableResolver();
    private E exchange;
    private XPathFunction bodyFunction;
    private XPathFunction headerFunction;
    private XPathFunction outBodyFunction;
    private XPathFunction outHeaderFunction;
    public XPathBuilder(String text) {
        this.text = text;
    }
    public static XPathBuilder xpath(String text) {
        return new XPathBuilder(text);
    }
    @Override
    public String toString() {
        return ""XPath: "" + text;
    }
    public boolean matches(E exchange) {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        return toBoolean(booleanResult);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        if (!toBoolean(booleanResult)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as returned <"" + booleanResult + "">"");
        }
    }
    public Object evaluate(E exchange) {
        Object answer = evaluateAs(exchange, resultQName);
        if (resultType != null) {
            return ExchangeHelper.convertToType(exchange, resultType, answer);
        }
        return answer;
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> booleanResult() {
        resultQName = XPathConstants.BOOLEAN;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> nodeResult() {
        resultQName = XPathConstants.NODE;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> nodeSetResult() {
        resultQName = XPathConstants.NODESET;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> numberResult() {
        resultQName = XPathConstants.NUMBER;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> stringResult() {
        resultQName = XPathConstants.STRING;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> resultType(Class resultType) {
        setResultType(resultType);
        return this;
    }
    /**
     * Sets the object model URI to use
     *
     * @return the current builder
     */
    public XPathBuilder<E> objectModel(String uri) {
        this.objectModelUri = uri;
        return this;
    }
    /**
     * Sets the {@link XPathFunctionResolver} instance to use on these XPath
     * expressions
     *
     * @return the current builder
     */
    public XPathBuilder<E> functionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
        return this;
    }
    /**
     * Registers the namespace prefix and URI with the builder so that the
     * prefix can be used in XPath expressions
     *
     * @param prefix is the namespace prefix that can be used in the XPath
     *                expressions
     * @param uri is the namespace URI to which the prefix refers
     * @return the current builder
     */
    public XPathBuilder<E> namespace(String prefix, String uri) {
        getNamespaceContext().add(prefix, uri);
        return this;
    }
    /**
     * Registers namespaces with the builder so that the registered
     * prefixes can be used in XPath expressions
     *
     * @param namespaces is namespaces object that should be used in the
     *                      XPath expression
     * @return the current builder
     */
    public XPathBuilder<E> namespaces(Namespaces namespaces) {
        namespaces.configure(this);
        return this;
    }
    /**
     * Registers a variable (in the global namespace) which can be referred to
     * from XPath expressions
     */
    public XPathBuilder<E> variable(String name, Object value) {
        variableResolver.addVariable(name, value);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public XPathFactory getXPathFactory() throws XPathFactoryConfigurationException {
        if (xpathFactory == null) {
            if (objectModelUri != null) {
                xpathFactory = XPathFactory.newInstance(objectModelUri);
            }
            xpathFactory = XPathFactory.newInstance();
        }
        return xpathFactory;
    }
    public void setXPathFactory(XPathFactory xpathFactory) {
        this.xpathFactory = xpathFactory;
    }
    public Class getDocumentType() {
        return documentType;
    }
    public void setDocumentType(Class documentType) {
        this.documentType = documentType;
    }
    public String getText() {
        return text;
    }
    public QName getResultQName() {
        return resultQName;
    }
    public void setResultQName(QName resultQName) {
        this.resultQName = resultQName;
    }
    public DefaultNamespaceContext getNamespaceContext() {
        if (namespaceContext == null) {
            try {
                DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext(getXPathFactory());
                populateDefaultNamespaces(defaultNamespaceContext);
                namespaceContext = defaultNamespaceContext;
            } catch (XPathFactoryConfigurationException e) {
                throw new RuntimeExpressionException(e);
            }
        }
        return namespaceContext;
    }
    public void setNamespaceContext(DefaultNamespaceContext namespaceContext) {
        this.namespaceContext = namespaceContext;
    }
    public XPathFunctionResolver getFunctionResolver() {
        return functionResolver;
    }
    public void setFunctionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
    }
    public XPathExpression getExpression() throws XPathFactoryConfigurationException,
        XPathExpressionException {
        if (expression == null) {
            expression = createXPathExpression();
        }
        return expression;
    }
    public void setNamespaces(Map<String, String> namespaces) {
        getNamespaceContext().setNamespaces(namespaces);
    }
    public XPathFunction getBodyFunction() {
        if (bodyFunction == null) {
            bodyFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange == null) {
                        return null;
                    }
                    return exchange.getIn().getBody();
                }
            };
        }
        return bodyFunction;
    }
    public void setBodyFunction(XPathFunction bodyFunction) {
        this.bodyFunction = bodyFunction;
    }
    public XPathFunction getHeaderFunction() {
        if (headerFunction == null) {
            headerFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null && !list.isEmpty()) {
                        Object value = list.get(0);
                        if (value != null) {
                            return exchange.getIn().getHeader(value.toString());
                        }
                    }
                    return null;
                }
            };
        }
        return headerFunction;
    }
    public void setHeaderFunction(XPathFunction headerFunction) {
        this.headerFunction = headerFunction;
    }
    public XPathFunction getOutBodyFunction() {
        if (outBodyFunction == null) {
            outBodyFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null) {
                        Message out = exchange.getOut(false);
                        if (out != null) {
                            return out.getBody();
                        }
                    }
                    return null;
                }
            };
        }
        return outBodyFunction;
    }
    public void setOutBodyFunction(XPathFunction outBodyFunction) {
        this.outBodyFunction = outBodyFunction;
    }
    public XPathFunction getOutHeaderFunction() {
        if (outHeaderFunction == null) {
            outHeaderFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null && !list.isEmpty()) {
                        Object value = list.get(0);
                        if (value != null) {
                            return exchange.getOut().getHeader(value.toString());
                        }
                    }
                    return null;
                }
            };
        }
        return outHeaderFunction;
    }
    public void setOutHeaderFunction(XPathFunction outHeaderFunction) {
        this.outHeaderFunction = outHeaderFunction;
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
        if (Number.class.isAssignableFrom(resultType)) {
            numberResult();
        } else if (String.class.isAssignableFrom(resultType)) {
            stringResult();
        } else if (Boolean.class.isAssignableFrom(resultType)) {
            booleanResult();
        } else if (Node.class.isAssignableFrom(resultType)) {
            nodeResult();
        } else if (NodeList.class.isAssignableFrom(resultType)) {
            nodeSetResult();
        }
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Evaluates the expression as the given result type
     */
    protected synchronized Object evaluateAs(E exchange, QName resultQName) {
        this.exchange = exchange;
        variableResolver.setExchange(exchange);
        try {
            Object document = getDocument(exchange);
            if (resultQName != null) {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource)document;
                    return getExpression().evaluate(inputSource, resultQName);
                } else if (document instanceof DOMSource) {
                    DOMSource source = (DOMSource) document;
                    return getExpression().evaluate(source.getNode(), resultQName);
                } else {
                    return getExpression().evaluate(document, resultQName);
                }
            } else {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource)document;
                    return getExpression().evaluate(inputSource);
                } else if (document instanceof DOMSource) {
                    DOMSource source = (DOMSource)document;
                    return getExpression().evaluate(source.getNode());
                } else {
                    return getExpression().evaluate(document);
                }
            }
        } catch (XPathExpressionException e) {
            throw new InvalidXPathExpression(getText(), e);
        } catch (XPathFactoryConfigurationException e) {
            throw new InvalidXPathExpression(getText(), e);
        }
    }
    protected XPathExpression createXPathExpression() throws XPathExpressionException,
        XPathFactoryConfigurationException {
        XPath xPath = getXPathFactory().newXPath();
        // lets now clear any factory references to avoid keeping them around
        xpathFactory = null;
        xPath.setNamespaceContext(getNamespaceContext());
        xPath.setXPathVariableResolver(variableResolver);
        XPathFunctionResolver parentResolver = getFunctionResolver();
        if (parentResolver == null) {
            parentResolver = xPath.getXPathFunctionResolver();
        }
        xPath.setXPathFunctionResolver(createDefaultFunctionResolver(parentResolver));
        return xPath.compile(text);
    }
    /**
     * Lets populate a number of standard prefixes if they are not already there
     */
    protected void populateDefaultNamespaces(DefaultNamespaceContext context) {
        setNamespaceIfNotPresent(context, ""in"", IN_NAMESPACE);
        setNamespaceIfNotPresent(context, ""out"", OUT_NAMESPACE);
        setNamespaceIfNotPresent(context, ""env"", Namespaces.ENVIRONMENT_VARIABLES);
        setNamespaceIfNotPresent(context, ""system"", Namespaces.SYSTEM_PROPERTIES_NAMESPACE);
    }
    protected void setNamespaceIfNotPresent(DefaultNamespaceContext context, String prefix, String uri) {
        if (context != null) {
            String current = context.getNamespaceURI(prefix);
            if (current == null) {
                context.add(prefix, uri);
            }
        }
    }
    protected XPathFunctionResolver createDefaultFunctionResolver(final XPathFunctionResolver parent) {
        return new XPathFunctionResolver() {
            public XPathFunction resolveFunction(QName qName, int argumentCount) {
                XPathFunction answer = null;
                if (parent != null) {
                    answer = parent.resolveFunction(qName, argumentCount);
                }
                if (answer == null) {
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), IN_NAMESPACE)
                        || isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""body"") && argumentCount == 0) {
                            return getBodyFunction();
                        }
                        if (localPart.equals(""header"") && argumentCount == 1) {
                            return getHeaderFunction();
                        }
                    }
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), OUT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""body"") && argumentCount == 0) {
                            return getOutBodyFunction();
                        }
                        if (localPart.equals(""header"") && argumentCount == 1) {
                            return getOutHeaderFunction();
                        }
                    }
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""out-body"") && argumentCount == 0) {
                            return getOutBodyFunction();
                        }
                        if (localPart.equals(""out-header"") && argumentCount == 1) {
                            return getOutHeaderFunction();
                        }
                    }
                }
                return answer;
            }
        };
    }
    /**
     * Strategy method to extract the document from the exchange
     */
    protected Object getDocument(E exchange) {
        Message in = exchange.getIn();
        Class type = getDocumentType();
        Object answer = null;
        if (type != null) {
            answer = in.getBody(type);
        }
        if (answer == null) {
            answer = in.getBody();
        }
        // lets try coerce some common types into something JAXP can deal with
        if (answer instanceof String) {
            answer = new InputSource(new StringReader(answer.toString()));
        }
        return answer;
    }
}
"
org.apache.camel.builder.xml.XPathLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.namespace.QName;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * XPath language.
 *
 * @version $Revision: 659760 $
 */
public class XPathLanguage implements Language {
    private QName resultType;
    public Predicate<Exchange> createPredicate(String expression) {
        XPathBuilder builder = XPathBuilder.xpath(expression);
        configureBuilder(builder);
        return builder;
    }
    public Expression<Exchange> createExpression(String expression) {
        XPathBuilder builder = XPathBuilder.xpath(expression);
        configureBuilder(builder);
        return builder;
    }
    public QName getResultType() {
        return resultType;
    }
    public void setResultType(QName resultType) {
        this.resultType = resultType;
    }
    protected void configureBuilder(XPathBuilder builder) {
        if (resultType != null) {
            builder.setResultQName(resultType);
        }
    }
}
"
org.apache.camel.builder.xml.XPathTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.xpath.XPathFunctionResolver;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 659842 $
 */
public class XPathTest extends TestSupport {
    public void testXPathExpressions() throws Exception {
        assertExpression(""/foo/bar/@xyz"", ""<foo><bar xyz='cheese'/></foo>"", ""cheese"");
        assertExpression(""$name"", ""<foo><bar xyz='cheese'/></foo>"", ""James"");
        assertExpression(""foo/bar"", ""<foo><bar>cheese</bar></foo>"", ""cheese"");
        assertExpression(""foo/bar/text()"", ""<foo><bar>cheese</bar></foo>"", ""cheese"");
        assertExpression(""/foo/@id"", ""<foo id='cheese'>hey</foo>"", ""cheese"");
    }
    public void testXPathPredicates() throws Exception {
        assertPredicate(""/foo/bar/@xyz"", ""<foo><bar xyz='cheese'/></foo>"", true);
        assertPredicate(""$name = 'James'"", ""<foo><bar xyz='cheese'/></foo>"", true);
        assertPredicate(""$name = 'Hiram'"", ""<foo><bar xyz='cheese'/></foo>"", false);
        assertPredicate(""/foo/notExist"", ""<foo><bar xyz='cheese'/></foo>"", false);
    }
    public void testXPathWithCustomVariable() throws Exception {
        assertExpression(xpath(""$name"").stringResult().variable(""name"", ""Hiram""), ""<foo/>"", ""Hiram"");
    }
    public void testUsingJavaExtensions() throws Exception {
        Object instance = null;
        // we may not have Xalan on the classpath
        try {
            instance = Class.forName(""org.apache.xalan.extensions.XPathFunctionResolverImpl"").newInstance();
        } catch (Throwable e) {
            log.debug(""Could not find Xalan on the classpath so ignoring this test case: "" + e);
        }
        if (instance instanceof XPathFunctionResolver) {
            XPathFunctionResolver functionResolver = (XPathFunctionResolver)instance;
            XPathBuilder builder = xpath(""java:"" + getClass().getName() + "".func(string(/header/value))"").namespace(""java"", ""http://xml.apache.org/xalan/java"").functionResolver(functionResolver);
            String xml = ""<header><value>12</value></header>"";
            Object value = assertExpression(builder, xml, ""modified12"");
            log.debug(""Evaluated xpath: "" + builder.getText() + "" on XML: "" + xml + "" result: "" + value);
        }
    }
    public static String func(String s) {
        return ""modified"" + s;
    }
    protected Object assertExpression(String xpath, String xml, String expected) {
        Expression expression = XPathBuilder.xpath(xpath).stringResult();
        return assertExpression(expression, xml, expected);
    }
    protected Object assertExpression(Expression expression, String xml, String expected) {
        return assertExpression(expression, createExchange(xml), expected);
    }
    protected void assertPredicate(String xpath, String xml, boolean expected) {
        Predicate predicate = XPathBuilder.xpath(xpath);
        assertPredicate(predicate, createExchange(xml), expected);
    }
    protected Exchange createExchange(String xml) {
        Exchange exchange = createExchangeWithBody(new DefaultCamelContext(), xml);
        exchange.getIn().setHeader(""name"", ""James"");
        return exchange;
    }
}
"
org.apache.camel.builder.xml.XPathWithNamespacesFromDomTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.apache.camel.ContextTestSupport;
/**
 * @version $Revision: 630591 $
 */
public class XPathWithNamespacesFromDomTest extends ContextTestSupport {
    public void testXPathUsingDomForNamespaces() throws Exception {
        Document document = context.getTypeConverter()
            .convertTo(Document.class, ""<x:foo xmlns:x='n1' xmlns:y='n2'><bar id='a' xmlns:y='n3'/></x:foo>"");
        Element element = (Element)document.getElementsByTagName(""bar"").item(0);
        assertNotNull(""Could not find element for id 'a'"", element);
        XPathBuilder builder = XPathBuilder.xpath(""//y:foo[@id='z']"");
        Namespaces ns = new Namespaces(element);
        ns.configure(builder);
        DefaultNamespaceContext namespaceContext = builder.getNamespaceContext();
        assertEquals(""y namespace"", ""n3"", namespaceContext.getNamespaceURI(""y""));
        assertPredicateMatches(builder, createExchangeWithBody(""<blah><foo xmlns='n3' id='z'/></blah>""));
        assertPredicateDoesNotMatch(builder, createExchangeWithBody(""<blah><foo xmlns='n2' id='z'/></blah>""));
    }
}
"
org.apache.camel.builder.xml.XsltBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.Exchange;
import org.apache.camel.ExpectedBodyTypeException;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeTransformException;
import org.apache.camel.converter.jaxp.XmlConverter;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Creates a <a href=""http://activemq.apache.org/camel/processor.html"">Processor</a>
 * which performs an XSLT transformation of the IN message body
 *
 * @version $Revision: 658768 $
 */
public class XsltBuilder implements Processor {
    private Map<String, Object> parameters = new HashMap<String, Object>();
    private XmlConverter converter = new XmlConverter();
    private Templates template;
    private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory();
    private boolean failOnNullBody = true;
    public XsltBuilder() {
    }
    public XsltBuilder(Templates templates) {
        this.template = templates;
    }
    @Override
    public String toString() {
        return ""XSLT["" + template + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        if (getTemplate() == null) {
            throw new IllegalArgumentException(""No template configured!"");
        }
        Transformer transformer = getTemplate().newTransformer();
        configureTransformer(transformer, exchange);
        Source source = getSource(exchange);
        ResultHandler resultHandler = resultHandlerFactory.createResult();
        Result result = resultHandler.getResult();
        // lets copy the headers before we invoke the transform in case they modify them
        Message out = exchange.getOut(true);
        out.copyFrom(exchange.getIn());
        transformer.transform(source, result);
        resultHandler.setBody(out);
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Creates an XSLT processor using the given templates instance
     */
    public static XsltBuilder xslt(Templates templates) {
        return new XsltBuilder(templates);
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(Source xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        XsltBuilder answer = new XsltBuilder();
        answer.setTransformerSource(xslt);
        return answer;
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(File xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(URL xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(xslt.openStream());
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(InputStream xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }
    /**
     * Sets the output as being a byte[]
     */
    public XsltBuilder outputBytes() {
        setResultHandlerFactory(new StreamResultHandlerFactory());
        return this;
    }
    /**
     * Sets the output as being a String
     */
    public XsltBuilder outputString() {
        setResultHandlerFactory(new StringResultHandlerFactory());
        return this;
    }
    /**
     * Sets the output as being a DOM
     */
    public XsltBuilder outputDOM() {
        setResultHandlerFactory(new DomResultHandlerFactory());
        return this;
    }
    public XsltBuilder parameter(String name, Object value) {
        parameters.put(name, value);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public Map<String, Object> getParameters() {
        return parameters;
    }
    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }
    public void setTemplate(Templates template) {
        this.template = template;
    }
    public Templates getTemplate() {
        return template;
    }
    public boolean isFailOnNullBody() {
        return failOnNullBody;
    }
    public void setFailOnNullBody(boolean failOnNullBody) {
        this.failOnNullBody = failOnNullBody;
    }
    public ResultHandlerFactory getResultHandlerFactory() {
        return resultHandlerFactory;
    }
    public void setResultHandlerFactory(ResultHandlerFactory resultHandlerFactory) {
        this.resultHandlerFactory = resultHandlerFactory;
    }
    /**
     * Sets the XSLT transformer from a Source
     *
     * @param source  the source
     * @throws TransformerConfigurationException is thrown if creating a XSLT transformer failed.
     */
    public void setTransformerSource(Source source) throws TransformerConfigurationException {
        // Check that the call to newTemplates() returns a valid template instance.
        // In case of an xslt parse error, it will return null and we should stop the
        // deployment and raise an exception as the route will not be setup properly.
        Templates templates = converter.getTransformerFactory().newTemplates(source);
        if (templates != null) {
            setTemplate(templates);
        } else {
            throw new TransformerConfigurationException(""Error creating XSLT template. ""
                    + ""This is most likely be caused by an XML parse error. ""
                    + ""Please verify your XSLT file configured."");
        }
    }
    /**
     * Sets the XSLT transformer from a File
     */
    public void setTransformerFile(File xslt) throws TransformerConfigurationException {
        setTransformerSource(new StreamSource(xslt));
    }
    /**
     * Sets the XSLT transformer from a URL
     */
    public void setTransformerURL(URL url) throws TransformerConfigurationException, IOException {
        notNull(url, ""url"");
        setTransformerInputStream(url.openStream());
    }
    /**
     * Sets the XSLT transformer from the given input stream
     */
    public void setTransformerInputStream(InputStream in) throws TransformerConfigurationException, IOException {
        notNull(in, ""in"");
        setTransformerSource(new StreamSource(in));
    }
    public XmlConverter getConverter() {
        return converter;
    }
    public void setConverter(XmlConverter converter) {
        this.converter = converter;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Converts the inbound body to a {@link Source}
     */
    protected Source getSource(Exchange exchange) {
        Message in = exchange.getIn();
        Source source = in.getBody(Source.class);
        if (source == null) {
            if (isFailOnNullBody()) {
                throw new ExpectedBodyTypeException(exchange, Source.class);
            } else {
                try {
                    source = converter.toSource(converter.createDocument());
                } catch (ParserConfigurationException e) {
                    throw new RuntimeTransformException(e);
                }
            }
        }
        return source;
    }
    /**
     * Configures the transformer with exchange specific parameters
     */
    protected void configureTransformer(Transformer transformer, Exchange exchange) {
        transformer.clearParameters();
        addParameters(transformer, exchange.getProperties());
        addParameters(transformer, exchange.getIn().getHeaders());
        addParameters(transformer, getParameters());
        transformer.setParameter(""exchange"", exchange);
        transformer.setParameter(""in"", exchange.getIn());
        transformer.setParameter(""out"", exchange.getOut());
    }
    protected void addParameters(Transformer transformer, Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value != null) {
                transformer.setParameter(key, value);
            }
        }
    }
}
"
org.apache.camel.builder.xml.XsltTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.net.URL;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.builder.xml.XsltBuilder.xslt;
/**
 * @version $Revision: 630591 $
 */
public class XsltTest extends ContextTestSupport {
    public void testXslt() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint
            .expectedBodiesReceived(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><goodbye>world!</goodbye>"");
        sendBody(""direct:start"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() throws Exception {
                URL styleSheet = getClass().getResource(""example.xsl"");
                from(""direct:start"").process(xslt(styleSheet)).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.bean.AmbiguousMethodCallException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Collection;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
/**
 * An exception thrown if an attempted method invocation resulted in an ambiguous method
 * such that multiple methods match the inbound message exchange
 *
 * @version $Revision: 640438 $
 */
public class AmbiguousMethodCallException extends CamelExchangeException {
    private final Collection<MethodInfo> methods;
    public AmbiguousMethodCallException(Exchange exchange, Collection<MethodInfo> methods) {
        super(""Ambiguous method invocations possible: "" + methods, exchange);
        this.methods = methods;
    }
    /**
     * The ambiguous methods for which a single method could not be chosen
     */
    public Collection<MethodInfo> getMethods() {
        return methods;
    }
}
"
org.apache.camel.component.bean.AnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.language.LanguageAnnotation;
/**
 * A factory which creates an {@link Expression} object from an annotation on a field, property or method parameter
 * of a specified type.
 *
 * @version $Revision: 640438 $
 */
public interface AnnotationExpressionFactory {
    Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType);
}
"
org.apache.camel.component.bean.BeanComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An alternative to the <a href=""http://activemq.apache.org/pojo.html"">POJO Component</a>
 * which implements the <a href=""http://activemq.apache.org/bean.html"">Bean Component</a>
 * which will look up the URI in the Spring ApplicationContext and use that to handle message dispatching.
 *
 * @version $Revision: 660275 $
 */
public class BeanComponent extends DefaultComponent {
    private static final transient Log LOG = LogFactory.getLog(BeanComponent.class);
    private ParameterMappingStrategy parameterMappingStrategy;
    public BeanComponent() {
    }
    /**
     * A helper method to create a new endpoint from a bean with a generated URI
     */
    public ProcessorEndpoint createEndpoint(Object bean) {
        String uri = ""bean:generated:"" + bean;
        return createEndpoint(bean, uri);
    }
    /**
     * A helper method to create a new endpoint from a bean with a given URI
     */
    public ProcessorEndpoint createEndpoint(Object bean, String uri) {
        BeanProcessor processor = new BeanProcessor(bean, getCamelContext(), getParameterMappingStrategy());
        return createEndpoint(uri, processor);
    }
    public ParameterMappingStrategy getParameterMappingStrategy() {
        if (parameterMappingStrategy == null) {
            parameterMappingStrategy = createParameterMappingStrategy();
        }
        return parameterMappingStrategy;
    }
    public void setParameterMappingStrategy(ParameterMappingStrategy parameterMappingStrategy) {
        this.parameterMappingStrategy = parameterMappingStrategy;
    }
    // Implementation methods
    //-----------------------------------------------------------------------
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        BeanEndpoint endpoint = new BeanEndpoint(uri, this);
        endpoint.setBeanName(remaining);
        endpoint.setCache(ObjectConverter.toBool(parameters.remove(""cache"")));
        Processor processor = endpoint.getProcessor();
        setProperties(processor, parameters);
        return endpoint;
    }
    protected BeanEndpoint createEndpoint(String uri, BeanProcessor processor) {
        return new BeanEndpoint(uri, this, processor);
    }
    protected ParameterMappingStrategy createParameterMappingStrategy() {
        return BeanInfo.createParameterMappingStrategy(getCamelContext());
    }
}
"
org.apache.camel.component.bean.BeanEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Component;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.impl.ProcessorEndpoint;
/**
 * Endpoint for the bean component.
 *
 * @version $Revision: 662301 $
 */
public class BeanEndpoint extends ProcessorEndpoint {
    private boolean cache;
    private String beanName;
    private String method;
    private BeanHolder beanHolder;
    public BeanEndpoint() {
        init();
    }
    public BeanEndpoint(String endpointUri) {
        super(endpointUri);
        init();
    }
    public BeanEndpoint(String endpointUri, BeanProcessor processor) {
        super(endpointUri, processor);
        init();
    }
    public BeanEndpoint(String endpointUri, Component component, BeanProcessor processor) {
        super(endpointUri, component, processor);
        init();
    }
    public BeanEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
        init();
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getBeanName() {
        return beanName;
    }
    public void setBeanName(String beanName) {
        this.beanName = beanName;
    }
    public boolean isCache() {
        return cache;
    }
    public void setCache(boolean cache) {
        this.cache = cache;
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    public BeanHolder getBeanHolder() {
        return beanHolder;
    }
    public void setBeanHolder(BeanHolder beanHolder) {
        this.beanHolder = beanHolder;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected String createEndpointUri() {
        return ""bean:"" + getBeanName() + (method != null ? ""?method="" + method : """");
    }
    private void init() {
        setExchangePattern(ExchangePattern.InOut);
    }
    @Override
    protected Processor createProcessor() throws Exception {
        BeanHolder holder = getBeanHolder();
        if (holder == null) {
            RegistryBean registryBean = new RegistryBean(getCamelContext(), beanName);
            if (cache) {
                holder = registryBean.createCacheHolder();
            } else {
                holder = registryBean;
            }
        }
        BeanProcessor processor = new BeanProcessor(holder);
        if (method != null) {
            processor.setMethod(method);
        }
        return processor;
    }
}
"
org.apache.camel.component.bean.BeanExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Exchange for the bean component.
 *
 * @version $Revision: 659771 $
 */
public class BeanExchange extends DefaultExchange {
    public BeanExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    public BeanExchange(DefaultExchange parent) {
        super(parent);
    }
    public BeanInvocation getInvocation() {
        return getIn().getBody(BeanInvocation.class);
    }
    public void setInvocation(BeanInvocation invocation) {
        getIn().setBody(invocation);
    }
    @Override
    public Exchange newInstance() {
        return new BeanExchange(this);
    }
}
"
org.apache.camel.component.bean.BeanExchangeAsReturnTypeNotAllowedTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
/**
 * Unit test to demonstrate that bean invocation must no return Exchange.
 */
public class BeanExchangeAsReturnTypeNotAllowedTest extends ContextTestSupport {
    public void testExchangeAsReturnTypeNotAllowed() throws Exception {
        MockEndpoint dead = getMockEndpoint(""mock:dead"");
        dead.expectedMessageCount(1);
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedMessageCount(0);
        template.sendBody(""direct:in"", ""Hello World"");
        dead.assertIsSatisfied();
        result.assertIsSatisfied();
    }
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", new MyBean());
        return answer;
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                errorHandler(deadLetterChannel(""mock:dead""));
                from(""direct:in"")
                    .to(""bean:myBean"")
                    .to(""mock:result"");
            }
        };
    }
    public static class MyBean {
        public Exchange doSomething(Exchange exchange) {
            // this method should not be called
            return exchange;
        }
    }
}
"
org.apache.camel.component.bean.BeanHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Processor;
/**
 * Object holder for a bean.
 *
 * @version $Revision: 660275 $
 */
public interface BeanHolder {
    Object getBean() throws Exception;
    Processor getProcessor();
    BeanInfo getBeanInfo();
}
"
org.apache.camel.component.bean.BeanInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.Body;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Header;
import org.apache.camel.Headers;
import org.apache.camel.Message;
import org.apache.camel.OutHeaders;
import org.apache.camel.Properties;
import org.apache.camel.Property;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ExchangeHelper.convertToType;
/**
 * Represents the metadata about a bean type created via a combination of
 * introspection and annotations together with some useful sensible defaults
 *
 * @version $Revision: 675938 $
 */
public class BeanInfo {
    private static final transient Log LOG = LogFactory.getLog(BeanInfo.class);
    private final CamelContext camelContext;
    private Class type;
    private ParameterMappingStrategy strategy;
    private Map<String, MethodInfo> operations = new ConcurrentHashMap<String, MethodInfo>();
    private MethodInfo defaultMethod;
    private List<MethodInfo> operationsWithBody = new ArrayList<MethodInfo>();
    private List<MethodInfo> operationsWithCustomAnnotation = new ArrayList<MethodInfo>();
    public BeanInfo(CamelContext camelContext, Class type) {
        this(camelContext, type, createParameterMappingStrategy(camelContext));
    }
    public BeanInfo(CamelContext camelContext, Class type, ParameterMappingStrategy strategy) {
        this.camelContext = camelContext;
        this.type = type;
        this.strategy = strategy;
        introspect(getType());
        if (operations.size() == 1) {
            Collection<MethodInfo> methodInfos = operations.values();
            for (MethodInfo methodInfo : methodInfos) {
                defaultMethod = methodInfo;
            }
        }
    }
    public Class getType() {
        return type;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public MethodInvocation createInvocation(Method method, Object pojo, Exchange exchange)
        throws RuntimeCamelException {
        MethodInfo methodInfo = introspect(type, method);
        if (methodInfo != null) {
            return methodInfo.createMethodInvocation(pojo, exchange);
        }
        return null;
    }
    public MethodInvocation createInvocation(Object pojo, Exchange exchange) throws RuntimeCamelException,
        AmbiguousMethodCallException {
        MethodInfo methodInfo = null;
        // TODO use some other mechanism?
        String name = exchange.getIn().getHeader(BeanProcessor.METHOD_NAME, String.class);
        if (name != null) {
            methodInfo = operations.get(name);
        }
        if (methodInfo == null) {
            methodInfo = chooseMethod(pojo, exchange);
        }
        if (methodInfo == null) {
            methodInfo = defaultMethod;
        }
        if (methodInfo != null) {
            return methodInfo.createMethodInvocation(pojo, exchange);
        }
        return null;
    }
    protected void introspect(Class clazz) {
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            if (isValidMethod(clazz, method)) {
                introspect(clazz, method);
            }
        }
        Class superclass = clazz.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            introspect(superclass);
        }
    }
    protected MethodInfo introspect(Class clazz, Method method) {
        Class[] parameterTypes = method.getParameterTypes();
        Annotation[][] parametersAnnotations = method.getParameterAnnotations();
        List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();
        List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();
        boolean hasCustomAnnotation = false;
        for (int i = 0; i < parameterTypes.length; i++) {
            Class parameterType = parameterTypes[i];
            Annotation[] parameterAnnotations = parametersAnnotations[i];
            Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType,
                                                                       parameterAnnotations);
            hasCustomAnnotation |= expression != null;
            ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations,
                                                            expression);
            parameters.add(parameterInfo);
            if (expression == null) {
                hasCustomAnnotation |= ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);
                if (bodyParameters.isEmpty()) {
                    // lets assume its the body
                    if (Exchange.class.isAssignableFrom(parameterType)) {
                        expression = ExpressionBuilder.exchangeExpression();
                    } else {
                        expression = ExpressionBuilder.bodyExpression(parameterType);
                    }
                    parameterInfo.setExpression(expression);
                    bodyParameters.add(parameterInfo);
                } else {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""No expression available for method: "" + method.toString()
                                  + "" which already has a body so ignoring parameter: "" + i
                                  + "" so ignoring method"");
                    }
                    return null;
                }
            }
        }
        // now lets add the method to the repository
        String opName = method.getName();
        // TODO allow an annotation to expose the operation name to use
        /* if (method.getAnnotation(Operation.class) != null) { String name =
         * method.getAnnotation(Operation.class).name(); if (name != null &&
         * name.length() > 0) { opName = name; } }
         */
        MethodInfo methodInfo = new MethodInfo(clazz, method, parameters, bodyParameters, hasCustomAnnotation);
        operations.put(opName, methodInfo);
        if (methodInfo.hasBodyParameter()) {
            operationsWithBody.add(methodInfo);
        }
        if (methodInfo.isHasCustomAnnotation() && !methodInfo.hasBodyParameter()) {
            operationsWithCustomAnnotation.add(methodInfo);
        }
        return methodInfo;
    }
    /**
     * Lets try choose one of the available methods to invoke if we can match
     * the message body to the body parameter
     *
     * @param pojo the bean to invoke a method on
     * @param exchange the message exchange
     * @return the method to invoke or null if no definitive method could be
     *         matched
     */
    protected MethodInfo chooseMethod(Object pojo, Exchange exchange) throws AmbiguousMethodCallException {
        if (operationsWithBody.size() == 1) {
            return operationsWithBody.get(0);
        } else if (!operationsWithBody.isEmpty()) {
            return chooseMethodWithMatchingBody(exchange, operationsWithBody);
        } else if (operationsWithCustomAnnotation.size() == 1) {
            return operationsWithCustomAnnotation.get(0);
        }
        return null;
    }
    protected MethodInfo chooseMethodWithMatchingBody(Exchange exchange, Collection<MethodInfo> operationList) throws AmbiguousMethodCallException {
        // lets see if we can find a method who's body param type matches the message body
        Message in = exchange.getIn();
        Object body = in.getBody();
        if (body != null) {
            Class bodyType = body.getClass();
            List<MethodInfo> possibles = new ArrayList<MethodInfo>();
            for (MethodInfo methodInfo : operationList) {
                // TODO: AOP proxies have additioan methods - consider having a static
                // method exclude list to skip all known AOP proxy methods
                // TODO: This class could use some TRACE logging
                // test for MEP pattern matching
                boolean out = exchange.getPattern().isOutCapable();
                if (out && methodInfo.isReturnTypeVoid()) {
                    // skip this method as the MEP is Out so the method must return someting
                    continue;
                }
                // try to match the arguments
                if (methodInfo.bodyParameterMatches(bodyType)) {
                    possibles.add(methodInfo);
                }
            }
            if (possibles.size() == 1) {
                return possibles.get(0);
            } else if (possibles.isEmpty()) {
                // lets try converting
                Object newBody = null;
                MethodInfo matched = null;
                for (MethodInfo methodInfo : operationList) {
                    Object value = convertToType(exchange, methodInfo.getBodyParameterType(), body);
                    if (value != null) {
                        if (newBody != null) {
                            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched,
                                                                                           methodInfo));
                        } else {
                            newBody = value;
                            matched = methodInfo;
                        }
                    }
                }
                if (matched != null) {
                    in.setBody(newBody);
                    return matched;
                }
            } else {
                // if we only have a single method with custom annotations, lets use that one
                if (operationsWithCustomAnnotation.size() == 1) {
                    return operationsWithCustomAnnotation.get(0);
                }
                return chooseMethodWithCustomAnnotations(exchange, possibles);
            }
        }
        // no match so return null
        return null;
    }
    protected MethodInfo chooseMethodWithCustomAnnotations(Exchange exchange, Collection<MethodInfo> possibles) throws AmbiguousMethodCallException {
        // if we have only one method with custom annotations lets choose that
        MethodInfo chosen = null;
        for (MethodInfo possible : possibles) {
            if (possible.isHasCustomAnnotation()) {
                if (chosen != null) {
                    chosen = null;
                    break;
                } else {
                    chosen = possible;
                }
            }
        }
        if (chosen != null) {
            return chosen;
        }
        throw new AmbiguousMethodCallException(exchange, possibles);
    }
    /**
     * Creates an expression for the given parameter type if the parameter can
     * be mapped automatically or null if the parameter cannot be mapped due to
     * unsufficient annotations or not fitting with the default type
     * conventions.
     */
    protected Expression createParameterUnmarshalExpression(Class clazz, Method method, Class parameterType,
                                                            Annotation[] parameterAnnotation) {
        // TODO look for a parameter annotation that converts into an expression
        for (Annotation annotation : parameterAnnotation) {
            Expression answer = createParameterUnmarshalExpressionForAnnotation(clazz, method, parameterType,
                                                                                annotation);
            if (answer != null) {
                return answer;
            }
        }
        return strategy.getDefaultParameterTypeExpression(parameterType);
    }
    protected boolean isPossibleBodyParameter(Annotation[] annotations) {
        if (annotations != null) {
            for (Annotation annotation : annotations) {
                if ((annotation instanceof Property)
                        || (annotation instanceof Header)
                        || (annotation instanceof Headers)
                        || (annotation instanceof OutHeaders)
                        || (annotation instanceof Properties)) {
                    return false;
                }
                LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(LanguageAnnotation.class);
                if (languageAnnotation != null) {
                    return false;
                }
            }
        }
        return true;
    }
    protected Expression createParameterUnmarshalExpressionForAnnotation(Class clazz, Method method,
                                                                         Class parameterType,
                                                                         Annotation annotation) {
        if (annotation instanceof Property) {
            Property propertyAnnotation = (Property)annotation;
            return ExpressionBuilder.propertyExpression(propertyAnnotation.name());
        } else if (annotation instanceof Properties) {
            return ExpressionBuilder.propertiesExpression();
        } else if (annotation instanceof Header) {
            Header headerAnnotation = (Header)annotation;
            return ExpressionBuilder.headerExpression(headerAnnotation.name());
        } else if (annotation instanceof Headers) {
            return ExpressionBuilder.headersExpression();
        } else if (annotation instanceof OutHeaders) {
            return ExpressionBuilder.outHeadersExpression();
        } else {
            LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(LanguageAnnotation.class);
            if (languageAnnotation != null) {
                Class<?> type = languageAnnotation.factory();
                Object object = camelContext.getInjector().newInstance(type);
                if (object instanceof AnnotationExpressionFactory) {
                    AnnotationExpressionFactory expressionFactory = (AnnotationExpressionFactory) object;
                    return expressionFactory.createExpression(camelContext, annotation, languageAnnotation, parameterType);
                } else {
                    LOG.error(""Ignoring bad annotation: "" + languageAnnotation + ""on method: "" + method
                            + "" which declares a factory: "" + type.getName()
                            + "" which does not implement "" + AnnotationExpressionFactory.class.getName());
                }
            }
        }
        return null;
    }
    protected boolean isValidMethod(Class clazz, Method method) {
        // must be a public method
        if (!Modifier.isPublic(method.getModifiers())) {
            return false;
        }
        // return type must not be an Exchange
        if (method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) {
            return false;
        }
        return true;
    }
    public static ParameterMappingStrategy createParameterMappingStrategy(CamelContext camelContext) {
        Registry registry = camelContext.getRegistry();
        ParameterMappingStrategy answer = registry.lookup(ParameterMappingStrategy.class.getName(),
                                                          ParameterMappingStrategy.class);
        if (answer == null) {
            answer = new DefaultParameterMappingStrategy();
        }
        return answer;
    }
}
"
org.apache.camel.component.bean.BeanInPipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.jndi.JndiContext;
/**
 * Unit test to demonstrate beans in pipelines.
 */
public class BeanInPipelineTest extends ContextTestSupport {
    public void testBeanInPipeline() throws Exception {
        Object response = template.requestBody(""direct:start"", ""Start:"");
        assertEquals(""Start:onetwothree"", response);
    }
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""one"", new MyBean(""one""));
        answer.bind(""two"", new MyBean(""two""));
        answer.bind(""three"", new MyBean(""three""));
        return answer;
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"")
                    .pipeline(""bean:one"", ""bean:two"", ""seda:x"", ""direct:y"", ""bean:three"");
            }
        };
    }
    public static class MyBean {
        private String postfix;
        public MyBean(String postfix) {
            this.postfix = postfix;
        }
        public String doSomething(String body) {
            return body + postfix;
        }
    }
}
"
org.apache.camel.component.bean.BeanInvocation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import org.apache.camel.Exchange;
import org.apache.camel.util.IOHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Invocation of beans that can handle being serialized.
 */
public class BeanInvocation implements Externalizable {
    private Object[] args;
    private MethodBean methodBean;
    private transient Method method;
    public BeanInvocation() {
    }
    public BeanInvocation(Method method, Object[] args) {
        this.method = method;
        this.args = args;
    }
    @Override
    public String toString() {
        Object list = null;
        if (args != null) {
            list = Arrays.asList(args);
        }
        return ""BeanInvocation "" + method + "" with "" + list + ""]"";
    }
    public Object[] getArgs() {
        return args;
    }
    public Method getMethod() {
        return method;
    }
    public void setMethod(Method method) {
        this.method = method;
    }
    public void setArgs(Object[] args) {
        this.args = args;
    }
    /**
     * This causes us to invoke the endpoint Pojo using reflection.
     *
     * @param pojo     the bean on which to perform this invocation
     * @param exchange the exchange carrying the method invocation
     */
    public void invoke(Object pojo, Exchange exchange) {
        try {
            Object response = getMethod().invoke(pojo, getArgs());
            exchange.getOut().setBody(response);
        } catch (InvocationTargetException e) {
            exchange.setException(e.getCause());
        } catch (RuntimeException e) {
            throw e;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {
        methodBean = ObjectHelper.cast(MethodBean.class, objectInput.readObject());
        try {
            method = methodBean.getMethod();
        } catch (NoSuchMethodException e) {
            throw IOHelper.createIOException(e);
        }
        args = ObjectHelper.cast(Object[].class, objectInput.readObject());
    }
    public void writeExternal(ObjectOutput objectOutput) throws IOException {
        if (methodBean == null) {
            methodBean = new MethodBean(method);
        }
        objectOutput.writeObject(methodBean);
        objectOutput.writeObject(args);
    }
}
"
org.apache.camel.component.bean.BeanInvocationSerializeTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Method;
import org.apache.camel.TestSupport;
/**
 * @version $Revision: 640438 $
 */
public class BeanInvocationSerializeTest extends TestSupport {
    public void testSerialize() throws Exception {
        Method method = getClass().getMethod(""cheese"", String.class, String.class);
        BeanInvocation invocation = new BeanInvocation(method, new Object[] {""a"", ""b""});
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(buffer);
        out.writeObject(invocation);
        out.close();
        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));
        Object object = in.readObject();
        BeanInvocation actual = assertIsInstanceOf(BeanInvocation.class, object);
        log.debug(""Received "" + actual);
    }
    public void cheese(String a, String b) {
        log.debug(""Called with a: "" + a + "" b: "" + b);
    }
}
"
org.apache.camel.component.bean.BeanMethodWithMultipleParametersTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 659842 $
 */
public class BeanMethodWithMultipleParametersTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testDummy() throws Exception {
    }
    //TODO fix this test
    public void xtestSendMessage() throws Exception {
        Object[] args = {""abc"", 5, ""def""};
        template.sendBodyAndHeader(""direct:in"", args, BeanProcessor.METHOD_NAME, ""myMethod"");
        assertEquals(""bean.foo"", ""abc"", myBean.foo);
        assertEquals(""bean.bar"", 5, myBean.bar);
        assertEquals(""bean.x"", ""def"", myBean.x);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").to(""bean:myBean?method=myMethod"");
            }
        };
    }
    public static class MyBean {
        public String foo;
        public int bar;
        public String x;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" bar: "" + bar + "" x: "" + x + ""]"";
        }
        public void myMethod(String foo, int bar, String x) {
            this.foo = foo;
            this.bar = bar;
            this.x = x;
            LOG.info(""myMethod() method called on "" + this);
        }
        public void anotherMethod(Object body) {
            fail(""Should not have called this method!"");
        }
    }
}
"
org.apache.camel.component.bean.BeanPipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Headers;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
/**
 * Unit test of bean can propogate headers in a pipleline
 */
public class BeanPipelineTest extends ContextTestSupport {
    public void testBeanInPipeline() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(""Hello World from James"");
        mock.expectedHeaderReceived(""from"", ""James"");
        template.sendBodyAndHeader(""direct:input"", ""Hello World"", ""from"", ""Claus"");
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:input"").
                    pipeline(""bean:foo"", ""bean:bar?methodName=usingExchange"", ""bean:baz"").
                    to(""mock:result"");
            }
        };
    }
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""foo"", new FooBean());
        answer.bind(""bar"", new BarBean());
        answer.bind(""baz"", new BazBean());
        return answer;
    }
    public static class FooBean {
        public void onlyPlainBody(Object body) {
            assertEquals(""Hello World"", body);
        }
    }
    public static class BarBean {
        public void doNotUseMe(String body) {
            fail(""Should not invoce me"");
        }
        public void usingExchange(Exchange exchange) {
            String body = exchange.getIn().getBody(String.class);
            assertEquals(""Hello World"", body);
            assertEquals(""Claus"", exchange.getIn().getHeader(""from""));
            exchange.getOut(true).setHeader(""from"", ""James"");
            exchange.getOut().setBody(""Hello World from James"");
        }
    }
    public static class BazBean {
        public void doNotUseMe(String body) {
            fail(""Should not invoce me"");
        }
        public void withAnnotations(@Headers Map headers, @Body String body) {
            assertEquals(""Hello World from James"", body);
            assertEquals(""James"", headers.get(""from""));
        }
    }
}
"
org.apache.camel.component.bean.BeanProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Processor} which converts the inbound exchange to a method
 * invocation on a POJO
 *
 * @version $Revision: 675500 $
 */
public class BeanProcessor extends ServiceSupport implements Processor {
    public static final String METHOD_NAME = ""org.apache.camel.MethodName"";
    private static final transient Log LOG = LogFactory.getLog(BeanProcessor.class);
    private Method methodObject;
    private String method;
    private BeanHolder beanHolder;
    public BeanProcessor(Object pojo, BeanInfo beanInfo) {
        this(new ConstantBeanHolder(pojo, beanInfo));
    }
    public BeanProcessor(Object pojo, CamelContext camelContext, ParameterMappingStrategy parameterMappingStrategy) {
        this(pojo, new BeanInfo(camelContext, pojo.getClass(), parameterMappingStrategy));
    }
    public BeanProcessor(Object pojo, CamelContext camelContext) {
        this(pojo, camelContext, BeanInfo.createParameterMappingStrategy(camelContext));
    }
    public BeanProcessor(BeanHolder beanHolder) {
        this.beanHolder = beanHolder;
    }
    @Override
    public String toString() {
        String description = methodObject != null ? "" "" + methodObject : """";
        return ""BeanProcessor["" + beanHolder + description + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> invoking method for: "" + exchange);
        }
        Object bean = beanHolder.getBean();
        exchange.setProperty(""org.apache.camel.bean.BeanHolder"", beanHolder);
        Processor processor = getProcessor();
        BeanInfo beanInfo = beanHolder.getBeanInfo();
        // do we have a custom adapter for this POJO to a Processor
        if (processor != null) {
            processor.process(exchange);
            return;
        }
        Message in = exchange.getIn();
        BeanInvocation beanInvoke = in.getBody(BeanInvocation.class);
        if (beanInvoke != null) {
            beanInvoke.invoke(bean, exchange);
            return;
        }
        boolean isExplicitMethod = false;
        String prevMethod = null;
        MethodInvocation invocation;
        if (methodObject != null) {
            invocation = beanInfo.createInvocation(methodObject, bean, exchange);
        } else {
            // we just override the bean's invocation method name here
            if (ObjectHelper.isNotNullAndNonEmpty(method)) {
                prevMethod = in.getHeader(METHOD_NAME, String.class);
                in.setHeader(METHOD_NAME, method);
                isExplicitMethod = true;
            }
            invocation = beanInfo.createInvocation(bean, exchange);
        }
        if (invocation == null) {
            throw new IllegalStateException(""No method invocation could be created, ""
                                            + ""no maching method could be found on: "" + bean);
        }
        try {
            Object value = invocation.proceed();
            if (value != null) {
                if (exchange.getPattern().isOutCapable()) {
                    // force out creating if not already created (as its lazy)
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Setting bean invocation value on OUT message: "" + value);
                    }
                    exchange.getOut(true).setBody(value);
                } else {
                    // if not out then set it on the in
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Setting bean invocation value on IN message: "" + value);
                    }
                    exchange.getIn().setBody(value);
                }
            }
        } catch (InvocationTargetException e) {
            // lets unwrap the exception
            Throwable cause = e.getCause();
            if (cause instanceof Exception) {
                throw (Exception) cause;
            } else {
                // do not handle errors!
                throw e;
            }
        } catch (Exception e) {
            throw e;
        } catch (Throwable throwable) {
            throw new Exception(throwable);
        } finally {
            if (isExplicitMethod) {
                in.setHeader(METHOD_NAME, prevMethod);
            }
        }
    }
    protected Processor getProcessor() {
        return beanHolder.getProcessor();
    }
    // Properties
    // -----------------------------------------------------------------------
    public Method getMethodObject() {
        return methodObject;
    }
    public void setMethodObject(Method methodObject) {
        this.methodObject = methodObject;
    }
    public String getMethod() {
        return method;
    }
    /**
     * Sets the method name to use
     */
    public void setMethod(String method) {
        this.method = method;
    }
    /**
     * Kept around for backwards compatibility, please use {@link #setMethod(String)}
     * in future instead.
     *
     * @deprecated use {@link #setMethod(String)}. Will be removed in Camel 2.0.
     */
    @Deprecated
    public void setMethodName(String method) {
        setMethod(method);
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startService(getProcessor());
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopService(getProcessor());
    }
}
"
org.apache.camel.component.bean.BeanWithAnnotationAndExchangeTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Header;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
/**
 * Unit test to demonstrate annotations combined with Exchange parameter.
 */
public class BeanWithAnnotationAndExchangeTest extends ContextTestSupport {
    public void testBeanWithAnnotationAndExchangeTest() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(""StartMyBean"");
        mock.expectedHeaderReceived(""foo"", ""bar"");
        mock.expectedHeaderReceived(""user"", ""admin"");
        template.requestBody(""direct:in"", ""Start"");
        mock.assertIsSatisfied();
    }
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", new MyBean());
        return answer;
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:in"")
                    .setHeader(""user"", ""admin"")
                    .to(""bean:myBean"")
                    .to(""mock:result"");
            }
        };
    }
    public static class MyBean {
        // START SNIPPET: e1
        public void doSomething(@Header(name = ""user"") String user, @Body String body, Exchange exchange) {
            assertEquals(""admin"", user);
            exchange.getIn().setBody(body + ""MyBean"");
        }
        // END SNIPPET: e1
    }
}
"
org.apache.camel.component.bean.BeanWithExpressionInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.language.Simple;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanWithExpressionInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, expectedBody, myBean.body);
        assertEquals(""bean foo: "" + myBean, ""bar"", myBean.foo);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        public String foo;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" body: "" + body + ""]"";
        }
        public void read(String body, @Simple(""header.foo"") String foo) {
            this.foo = foo;
            this.body = body;
            LOG.info(""read() method called on "" + this);
        }
    }
}
"
org.apache.camel.component.bean.BeanWithHeadersAndBodyInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Headers;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanWithHeadersAndBodyInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        template.send(""direct:in"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.setProperty(""p1"", ""abc"");
                exchange.setProperty(""p2"", 123);
                Message in = exchange.getIn();
                in.setHeader(""h1"", ""xyz"");
                in.setHeader(""h2"", 456);
                in.setBody(""TheBody"");
            }
        });
        Map foo = myBean.headers;
        assertNotNull(""myBean.foo"", foo);
        assertEquals(""foo.h1"", ""xyz"", foo.get(""h1""));
        assertEquals(""foo.h2"", 456, foo.get(""h2""));
        assertEquals(""body"", ""TheBody"", myBean.body);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").to(""bean:myBean?method=myMethod"");
            }
        };
    }
    public static class MyBean {
        public Map<String, Object> headers;
        public Object body;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + headers + "" body: "" + body + ""]"";
        }
        public void myMethod(@Headers Map<String, Object> headers, Object body) {
            this.headers = headers;
            this.body = body;
            LOG.info(""myMethod() method called on "" + this);
        }
        public void anotherMethod(@Headers Map<String, Object> headers, Object body) {
            fail(""Should not have called this method!"");
        }
    }
}
"
org.apache.camel.component.bean.BeanWithHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
/**
 * Unit test to demonstrate the headers can pass through beans.
 */
public class BeanWithHeaderTest extends ContextTestSupport {
    public void testBeanWithHeader() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedBodiesReceived(""StartMyBeanMyBean"");
        mock.expectedHeaderReceived(""foo"", ""bar"");
        mock.expectedHeaderReceived(""user"", ""admin"");
        template.requestBody(""direct:in"", ""Start"");
        mock.assertIsSatisfied();
    }
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", new MyBean());
        return answer;
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:in"")
                    .setHeader(""foo"", ""bar"")
                    .to(""bean:myBean"")
                    .to(""seda:a"");
                from(""seda:a"")
                    .to(""bean:myBean"")
                    .to(""mock:result"");
            }
        };
    }
    public static class MyBean {
        public void doSomething(Exchange exchange) {
            String body = exchange.getIn().getBody(String.class);
            exchange.getIn().setHeader(""user"", ""admin"");
            exchange.getIn().setBody(body + ""MyBean"");
        }
    }
}
"
org.apache.camel.component.bean.BeanWithPropertiesAndHeadersAndBodyInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Headers;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Properties;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.jndi.JndiContext;
/**
 * @version $Revision: 663912 $
 */
public class BeanWithPropertiesAndHeadersAndBodyInjectionTest extends ContextTestSupport {
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        Exchange out = template.send(""direct:in"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.setProperty(""p1"", ""abc"");
                exchange.setProperty(""p2"", 123);
                Message in = exchange.getIn();
                in.setHeader(""h1"", ""xyz"");
                in.setHeader(""h2"", 456);
                in.setBody(""TheBody"");
            }
        });
        assertEquals(""Should not fail"", false, out.isFailed());
        BeanHolder holder = out.getProperty(""org.apache.camel.bean.BeanHolder"", BeanHolder.class);
        assertNotNull(""BeanHolder is missing"", holder);
        assertEquals(myBean, holder.getBean());
        Map foo = myBean.foo;
        Map bar = myBean.bar;
        assertNotNull(""myBean.foo"", foo);
        assertNotNull(""myBean.bar"", bar);
        assertEquals(""foo.p1"", ""abc"", foo.get(""p1""));
        assertEquals(""foo.p2"", 123, foo.get(""p2""));
        assertEquals(""bar.h1"", ""xyz"", bar.get(""h1""));
        assertEquals(""bar.h2"", 456, bar.get(""h2""));
        assertEquals(""body"", ""TheBody"", myBean.body);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        private Map foo;
        private Map bar;
        private String body;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" bar: "" + bar + "" body: "" + body + ""]"";
        }
        public void myMethod(@Properties Map foo, @Headers Map bar, @Body String body) {
            this.foo = foo;
            this.bar = bar;
            this.body = body;
            assertNotNull(toString());
        }
    }
}
"
org.apache.camel.component.bean.BeanWithPropertiesAndHeadersInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Headers;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Properties;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanWithPropertiesAndHeadersInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        template.send(""direct:in"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.setProperty(""p1"", ""abc"");
                exchange.setProperty(""p2"", 123);
                Message in = exchange.getIn();
                in.setHeader(""h1"", ""xyz"");
                in.setHeader(""h2"", 456);
            }
        });
        Map foo = myBean.foo;
        Map bar = myBean.bar;
        assertNotNull(""myBean.foo"", foo);
        assertNotNull(""myBean.bar"", bar);
        assertEquals(""foo.p1"", ""abc"", foo.get(""p1""));
        assertEquals(""foo.p2"", 123, foo.get(""p2""));
        assertEquals(""bar.h1"", ""xyz"", bar.get(""h1""));
        assertEquals(""bar.h2"", 456, bar.get(""h2""));
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public Map foo;
        public Map bar;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" bar: "" + bar + ""]"";
        }
        public void myMethod(@Properties Map foo, @Headers Map bar) {
            this.foo = foo;
            this.bar = bar;
            LOG.info(""myMethod() method called on "" + this);
        }
    }
}
"
org.apache.camel.component.bean.BodyAnnotationToDisambiguateMethodsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BodyAnnotationToDisambiguateMethodsTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, expectedBody, myBean.body);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        public void bar(String body) {
            fail(""bar() called with: "" + body);
        }
        public void foo(@Body String body) {
            this.body = body;
            LOG.info(""foo() method called on "" + this);
        }
        public void wrongMethod(String body) {
            fail(""wrongMethod() called with: "" + body);
        }
    }
}
"
org.apache.camel.component.bean.CamelInvocationHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Producer;
/**
 * An {@link java.lang.reflect.InvocationHandler} which invokes a
 * message exchange on a camel {@link Endpoint}
 *
 * @version $Revision: 655516 $
 */
public class CamelInvocationHandler implements InvocationHandler {
    private final Endpoint endpoint;
    private final Producer producer;
    public CamelInvocationHandler(Endpoint endpoint, Producer producer) {
        this.endpoint = endpoint;
        this.producer = producer;
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        BeanInvocation invocation = new BeanInvocation(method, args);
        BeanExchange exchange = new BeanExchange(endpoint.getCamelContext(), ExchangePattern.InOut);
        exchange.setInvocation(invocation);
        producer.process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        return exchange.getOut(true).getBody();
    }
}
"
org.apache.camel.component.bean.ChainedBeanInvocationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.util.jndi.JndiContext;
import org.easymock.EasyMock;
public class ChainedBeanInvocationTest extends ContextTestSupport {
    protected MyBean beanMock;
    @Override
    protected void setUp() throws Exception {
        beanMock = EasyMock.createStrictMock(MyBean.class);
        super.setUp();
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext context = new JndiContext();
        context.bind(""myBean"", beanMock);
        return context;
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from(""direct:start"")
                    .to(""bean:myBean?methodName=a"")
                    .bean(beanMock, ""b"")
                    .beanRef(""myBean"", ""c"");
                from(""direct:start2"")
                    .to(""bean:myBean?methodName=a"")
                    .to(""bean:myBean"")
                    .bean(beanMock, ""b"")
                    .bean(beanMock)
                    .beanRef(""myBean"", ""c"")
                    .beanRef(""myBean"");
            }
        };
    }
    public void testNormalInvocation() throws Throwable {
        beanMock.a();
        beanMock.b();
        beanMock.c();
        EasyMock.replay(beanMock);
        Exchange result = template.send(""direct:start"", new DefaultExchange(context));
        if (result.getException() != null) {
            throw result.getException();
        }
        EasyMock.verify(beanMock);
    }
    public void testNoMethodSpecified() throws Throwable {
        beanMock.a();
        EasyMock.replay(beanMock);
        Exchange result = template.send(""direct:start2"", new DefaultExchange(context));
        assertNotNull(result.getException());
        assertEquals(result.getException().getClass(), IllegalStateException.class);
        EasyMock.verify(beanMock);
    }
    public void testMethodHeaderSet() throws Exception {
        beanMock.a();        
        beanMock.d();        
        beanMock.b();        
        beanMock.d();        
        beanMock.c();        
        beanMock.d();        
        EasyMock.replay(beanMock);
        template.sendBodyAndHeader(""direct:start2"", ""test"", BeanProcessor.METHOD_NAME, ""d"");
        EasyMock.verify(beanMock);
    }
    public interface MyBean {
        void a();
        void b();
        void c();
        void d();
    }
}
"
org.apache.camel.component.bean.ConstantBeanHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.Processor;
import org.apache.camel.util.CamelContextHelper;
/**
 * A constant (singleton) bean implementation of {@link BeanHolder}
 *
 * @version $Revision: 640438 $
 */
public class ConstantBeanHolder implements BeanHolder {
    private final Object bean;
    private Processor processor;
    private BeanInfo beanInfo;
    public ConstantBeanHolder(Object bean, BeanInfo beanInfo) {
        this.bean = bean;
        this.beanInfo = beanInfo;
        this.processor = CamelContextHelper.convertTo(beanInfo.getCamelContext(), Processor.class, bean);
    }
    public ConstantBeanHolder(Object bean, CamelContext context) {
        this(bean, new BeanInfo(context, bean.getClass()));
    }
    public ConstantBeanHolder(Object bean, CamelContext context, ParameterMappingStrategy parameterMappingStrategy) {
        this(bean, new BeanInfo(context, bean.getClass(), parameterMappingStrategy));
    }
    @Override
    public String toString() {
        return bean.toString();
    }
    public Object getBean()  {
        return bean;
    }
    public Processor getProcessor() {
        return processor;
    }
    public BeanInfo getBeanInfo() {
        return beanInfo;
    }
}
"
org.apache.camel.component.bean.DefaultAnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
/**
 * Default implementation of the {@link AnnotationExpressionFactory}.
 *
 * @version $Revision: 660275 $
 */
public class DefaultAnnotationExpressionFactory implements AnnotationExpressionFactory {
    public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String languageName = languageAnnotation.language();
        if (languageName == null) {
            throw new IllegalArgumentException(""Cannot determine the language from the annotation: "" + annotation);
        }
        Language language = camelContext.resolveLanguage(languageName);
        if (language == null) {
            throw new IllegalArgumentException(""Cannot find the language: "" + languageName + "" on the classpath"");
        }
        String expression = getExpressionFromAnnotation(annotation);
        return language.createExpression(expression);
    }
    protected String getExpressionFromAnnotation(Annotation annotation) {
        // lets try the 'value()' method
        try {
            Method method = annotation.getClass().getMethod(""value"");
            Object value = ObjectHelper.invokeMethod(method, annotation);
            if (value == null) {
                throw new IllegalArgumentException(""Cannot determine the expression from the annotation: "" + annotation);
            }
            return value.toString();
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException(""Cannot determine the expression of the annotation: "" + annotation + "" as it does not have an value() method"");
        }
    }
}
"
org.apache.camel.component.bean.DefaultParameterMappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.builder.ExpressionBuilder;
/**
 * Represents the strategy used to figure out how to map a message exchange to a POJO method invocation
 *
 * @version $Revision: 630591 $
 */
public class DefaultParameterMappingStrategy implements ParameterMappingStrategy {
    private Map<Class, Expression> parameterTypeToExpressionMap = new ConcurrentHashMap<Class, Expression>();
    public DefaultParameterMappingStrategy() {
        loadDefaultRegistry();
    }
    public synchronized Expression getDefaultParameterTypeExpression(Class parameterType) {
        return parameterTypeToExpressionMap.get(parameterType);
    }
    /**
     * Adds a default parameter type mapping to an expression
     */
    public synchronized void addParameterMapping(Class parameterType, Expression expression) {
        parameterTypeToExpressionMap.put(parameterType, expression);
    }
    /**
     * Creates an invocation on the given POJO using annotations to decide which method to invoke
     * and to figure out which parameters to use
     */
/*
    public MethodInvocation createInvocation(Object pojo,
                                             BeanInfo beanInfo, 
                                             Exchange messageExchange,
                                             Endpoint pojoEndpoint) throws RuntimeCamelException {
        return beanInfo.createInvocation(pojo, messageExchange);
    }
*/
    public void loadDefaultRegistry() {
        addParameterMapping(Exchange.class, ExpressionBuilder.exchangeExpression());
        addParameterMapping(Message.class, ExpressionBuilder.inMessageExpression());
    }
}
"
org.apache.camel.component.bean.ExpressionAnnotationToDisambiguateMethodsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.language.Simple;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class ExpressionAnnotationToDisambiguateMethodsTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        template.sendBodyAndHeader(""direct:in"", ""<hello>world!</hello>"", ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, ""bar"", myBean.bar);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String bar;
        public void bar(String body) {
            fail(""bar() called with: "" + body);
        }
        public void foo(@Simple(""header.foo"") String bar) {
            this.bar = bar;
            LOG.info(""foo() method called with: "" + bar);
        }
        public void wrongMethod(String body) {
            fail(""wrongMethod() called with: "" + body);
        }
    }
}
"
org.apache.camel.component.bean.MethodBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.io.Serializable;
import java.lang.reflect.Method;
/**
 * Represents a {@link Serializable} version of a {@link Method}
 *
 * @version $Revision: 640438 $
 */
public class MethodBean implements Serializable {
    private String name;
    private Class<?> type;
    private Class<?>[] parameterTypes;
    public MethodBean() {
    }
    public MethodBean(Method method) {
        this.name = method.getName();
        this.type = method.getDeclaringClass();
        this.parameterTypes = method.getParameterTypes();
    }
    public Method getMethod() throws NoSuchMethodException {
        return type.getMethod(name, parameterTypes);
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Class<?>[] getParameterTypes() {
        return parameterTypes;
    }
    public void setParameterTypes(Class<?>[] parameterTypes) {
        this.parameterTypes = parameterTypes;
    }
    public Class<?> getType() {
        return type;
    }
    public void setType(Class<?> type) {
        this.type = type;
    }
}
"
org.apache.camel.component.bean.MethodInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Information about a method to be used for invocation.
 *
 * @version $Revision: 672723 $
 */
public class MethodInfo {
    private Class type;
    private Method method;
    private final List<ParameterInfo> parameters;
    private final List<ParameterInfo> bodyParameters;
    private final boolean hasCustomAnnotation;
    private Expression parametersExpression;
    public MethodInfo(Class type, Method method, List<ParameterInfo> parameters, List<ParameterInfo> bodyParameters, boolean hasCustomAnnotation) {
        this.type = type;
        this.method = method;
        this.parameters = parameters;
        this.bodyParameters = bodyParameters;
        this.hasCustomAnnotation = hasCustomAnnotation;
        this.parametersExpression = createParametersExpression();
    }
    public String toString() {
        return method.toString();
    }
    public MethodInvocation createMethodInvocation(final Object pojo, final Exchange messageExchange) {
        final Object[] arguments = (Object[]) parametersExpression.evaluate(messageExchange);
        return new MethodInvocation() {
            public Method getMethod() {
                return method;
            }
            public Object[] getArguments() {
                return arguments;
            }
            public Object proceed() throws Throwable {
                return invoke(method, pojo, arguments, messageExchange);
            }
            public Object getThis() {
                return pojo;
            }
            public AccessibleObject getStaticPart() {
                return method;
            }
        };
    }
    public Class getType() {
        return type;
    }
    public Method getMethod() {
        return method;
    }
    public Expression getParametersExpression() {
        return parametersExpression;
    }
    public List<ParameterInfo> getBodyParameters() {
        return bodyParameters;
    }
    public Class getBodyParameterType() {
        ParameterInfo parameterInfo = bodyParameters.get(0);
        return parameterInfo.getType();
    }
    public boolean bodyParameterMatches(Class bodyType) {
        Class actualType = getBodyParameterType();
        return actualType != null && ObjectHelper.isAssignableFrom(bodyType, actualType);
    }
    public List<ParameterInfo> getParameters() {
        return parameters;
    }
    public boolean hasBodyParameter() {
        return !bodyParameters.isEmpty();
    }
    public boolean isHasCustomAnnotation() {
        return hasCustomAnnotation;
    }
    public boolean isReturnTypeVoid() {
        return method.getReturnType().getName().equals(""void"");
    }
    protected Object invoke(Method mth, Object pojo, Object[] arguments, Exchange exchange) throws IllegalAccessException, InvocationTargetException {
        return mth.invoke(pojo, arguments);
    }
    protected Expression createParametersExpression() {
        final int size = parameters.size();
        final Expression[] expressions = new Expression[size];
        for (int i = 0; i < size; i++) {
            Expression parameterExpression = parameters.get(i).getExpression();
            expressions[i] = parameterExpression;
        }
        return new Expression<Exchange>() {
            public Object evaluate(Exchange exchange) {
                Object[] answer = new Object[size];
                for (int i = 0; i < size; i++) {
                    Object value = expressions[i].evaluate(exchange);
                    // now lets try to coerce the value to the required type
                    Class expectedType = parameters.get(i).getType();
                    value = ExchangeHelper.convertToType(exchange, expectedType, value);
                    answer[i] = value;
                }
                return answer;
            }
            @Override
            public String toString() {
                return ""ParametersExpression: "" + Arrays.asList(expressions);
            }
        };
    }
}
"
org.apache.camel.component.bean.MethodInvocation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;
/**
 * Information used by Camel to perform method invocation.
 *
 * @version $Revision: 660275 $
 */
public interface MethodInvocation {
    Method getMethod();
    Object[] getArguments();
    Object proceed() throws Throwable;
    Object getThis();
    AccessibleObject getStaticPart();
}
"
org.apache.camel.component.bean.NewInstanceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.ExchangePattern;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 675468 $
 */
public class NewInstanceTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected JndiContext jndiContext;
    public void testSendMessageToDifferentBeans() throws Exception {
        MockEndpoint endpoint = getMockEndpoint(""mock:result"");
        endpoint.expectedBodiesReceived(1, 2);
        template.sendBody(""direct:start"", ExchangePattern.InOut, ""first"");
        // lets simulate spring's factory bean stuff
        jndiContext.unbind(""myBean"");
        jndiContext.bind(""myBean"", new MyBean());
        template.sendBody(""direct:start"", ExchangePattern.InOut, ""second"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected Context createJndiContext() throws Exception {
        jndiContext = new JndiContext();
        jndiContext.bind(""myBean"", new MyBean());
        return jndiContext;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").beanRef(""myBean"").to(""mock:result"");
            }
        };
    }
    public static class MyBean {
        private static int counter;
        private int id;
        public MyBean() {
            id = generateId();
        }
        protected static synchronized int generateId() {
            return ++counter;
        }
        @Override
        public String toString() {
            return ""MyBean["" + id + ""]"";
        }
        public int read(@Body String body) {
            LOG.info(""read() method called with: "" + body + "" on "" + this);
            return id;
        }
    }
}
"
org.apache.camel.component.bean.NoBeanAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelException;
/**
 * Exception thrown if the bean could not be found in the registry.
 *
 * @version $Revision: 659771 $
 */
public class NoBeanAvailableException extends CamelException {
    private final String name;
    public NoBeanAvailableException(String name) {
        super(""No bean available for endpoint: "" + name);
        this.name = name;
    }
    public String getName() {
        return name;
    }
}
"
org.apache.camel.component.bean.ParameterInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import org.apache.camel.Expression;
/**
 * Parameter information to be used for method invocation.
 *
 * @version $Revision: 659771 $
 */
public class ParameterInfo {
    private final int index;
    private final Class type;
    private final Annotation[] annotations;
    private Expression expression;
    public ParameterInfo(int index, Class type, Annotation[] annotations, Expression expression) {
        this.index = index;
        this.type = type;
        this.annotations = annotations;
        this.expression = expression;
    }
    public Annotation[] getAnnotations() {
        return annotations;
    }
    public Expression getExpression() {
        return expression;
    }
    public int getIndex() {
        return index;
    }
    public Class getType() {
        return type;
    }
    public void setExpression(Expression expression) {
        this.expression = expression;
    }
}
"
org.apache.camel.component.bean.ParameterMappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Expression;
/**
 * A strategy for creating a default parameter expression for a given type
 *
 * @version $Revision: 630591 $
 */
public interface ParameterMappingStrategy {
    Expression getDefaultParameterTypeExpression(Class parameterType);
}
"
org.apache.camel.component.bean.PredicateAsBeanTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 662301 $
 */
public class PredicateAsBeanTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyPredicate myPredicate = new MyPredicate();
    public void testSendMessage() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myPredicate, expectedBody, myPredicate.body);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myPredicate"", myPredicate);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").to(""bean:myPredicate"");
            }
        };
    }
    public static class MyPredicate implements Predicate<Exchange> {
        public String body;
        public boolean matches(Exchange exchange) {
            LOG.info(""matches(exchange) called with: "" + exchange);
            body = exchange.getIn().getBody(String.class);
            return (null != body) && (body.equals(""Wobble""));
        }
        public void assertMatches(String text, Exchange exchange) throws AssertionError {
            LOG.info(""assertMatches(text, exchange) called with: "" + text + "", "" + exchange);
        }
    }
}
"
org.apache.camel.component.bean.ProxyHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.Proxy;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
/**
 * A helper class for creating proxies which delegate to Camel
 *
 * @version $Revision: 640438 $
 */
public final class ProxyHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ProxyHelper() {
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    public static Object createProxy(final Endpoint endpoint, ClassLoader cl, Class interfaces[])
        throws Exception {
        final Producer producer = endpoint.createProducer();
        return Proxy.newProxyInstance(cl, interfaces, new CamelInvocationHandler(endpoint, producer));
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    public static Object createProxy(Endpoint endpoint, Class interfaces[]) throws Exception {
        if (interfaces.length < 1) {
            throw new IllegalArgumentException(""You must provide at least 1 interface class."");
        }
        return createProxy(endpoint, interfaces[0].getClassLoader(), interfaces);
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, ClassLoader cl, Class<T> interfaceClass)
        throws Exception {
        return (T)createProxy(endpoint, cl, new Class[] {interfaceClass});
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     *
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, Class<T> interfaceClass) throws Exception {
        return (T)createProxy(endpoint, new Class[] {interfaceClass});
    }
}
"
org.apache.camel.component.bean.RegistryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.Processor;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * An implementation of a {@link BeanHolder} which will look up a bean from the registry and act as a cache of its metadata
 *
 * @version $Revision: 656397 $
 */
public class RegistryBean implements BeanHolder {
    private final CamelContext context;
    private final String name;
    private final Registry registry;
    private Processor processor;
    private BeanInfo beanInfo;
    private Object bean;
    private ParameterMappingStrategy parameterMappingStrategy;
    public RegistryBean(CamelContext context, String name) {
        this.context = context;
        this.name = name;
        this.registry = context.getRegistry();
    }
    public RegistryBean(CamelContext context, String name, ParameterMappingStrategy parameterMappingStrategy) {
        this(context, name);
        this.parameterMappingStrategy = parameterMappingStrategy;
    }
    @Override
    public String toString() {
        return ""bean: "" + name;
    }
    public ConstantBeanHolder createCacheHolder() throws Exception {
        return new ConstantBeanHolder(getBean(), getBeanInfo());
    }
    public Object getBean() throws Exception {
        Object value = lookupBean();
        if (value == null) {
            throw new NoBeanAvailableException(name);
        }
        if (value != bean) {
            bean = value;
            processor = null;
            if (!ObjectHelper.equal(ObjectHelper.type(bean), ObjectHelper.type(value))) {
                beanInfo = null;
            }
        }
        return value;
    }
    public Processor getProcessor() {
        if (processor == null && bean != null) {
            processor = CamelContextHelper.convertTo(context, Processor.class, bean);
        }
        return processor;
    }
    public BeanInfo getBeanInfo() {
        if (beanInfo == null && bean != null) {
            this.beanInfo = createBeanInfo();
        }
        return beanInfo;
    }
    public String getName() {
        return name;
    }
    public Registry getRegistry() {
        return registry;
    }
    public CamelContext getContext() {
        return context;
    }
    public ParameterMappingStrategy getParameterMappingStrategy() {
        if (parameterMappingStrategy == null) {
            parameterMappingStrategy = createParameterMappingStrategy();
        }
        return parameterMappingStrategy;
    }
    public void setParameterMappingStrategy(ParameterMappingStrategy parameterMappingStrategy) {
        this.parameterMappingStrategy = parameterMappingStrategy;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected BeanInfo createBeanInfo() {
        return new BeanInfo(context, bean.getClass(), getParameterMappingStrategy());
    }
    protected ParameterMappingStrategy createParameterMappingStrategy() {
        return BeanInfo.createParameterMappingStrategy(context);
    }
    protected Object lookupBean() throws Exception {
        return registry.lookup(name);
    }
}
"
org.apache.camel.component.bean.SendBodyToBeanDirectlyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.jndi.JndiContext;
/**
 * Unit test to demonstrate routes initiated by sending a body to bean.
 */
public class SendBodyToBeanDirectlyTest extends ContextTestSupport {
    public void testSendBodyToBeanDirectly() throws Exception {
        // note: the route chain is newever invoked as bean:one will only call this bean
        // and not do a route
        Object response = template.sendBody(""bean:one"", ""Start:"");
        assertEquals(""Start:one"", response);
    }
    public void testSendBodyToBeanIndirectly() throws Exception {
        // note we must use pipeline in the route (check the builder)
        Object response = template.sendBody(""direct:start"", ""Start:"");
        assertEquals(""Start:onetwo"", response);
    }
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""one"", new MyBean(""one""));
        answer.bind(""two"", new MyBean(""two""));
        return answer;
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // this route will never happen
                from(""bean:one"").to(""bean:two"");
                // must use pipeline to force the route chains with beans to beans
                from(""direct:start"").pipeline(""bean:one"", ""bean:two"");
            }
        };
    }
    public static class MyBean {
        private String postfix;
        public MyBean(String postfix) {
            this.postfix = postfix;
        }
        public String doSomething(String body) {
            return body + postfix;
        }
    }
}
"
org.apache.camel.component.bean.XPathAnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.builder.xml.XPathBuilder;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.language.NamespacePrefix;
import org.apache.camel.language.XPath;
/**
 * Factory for the XPath expression annotations.
 *
 * @version $Revision: 660275 $
 */
public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
    @Override
    public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String xpath = getExpressionFromAnnotation(annotation);
        XPathBuilder builder = XPathBuilder.xpath(xpath);
        if (annotation instanceof XPath) {
            XPath xpathAnnotation = (XPath) annotation;
            NamespacePrefix[] namespaces = xpathAnnotation.namespaces();
            if (namespaces != null) {
                for (NamespacePrefix namespacePrefix : namespaces) {
                    builder = builder.namespace(namespacePrefix.prefix(), namespacePrefix.uri());
                }
            }
        }
        return builder;
    }
}
"
org.apache.camel.component.dataset.CustomDataSetTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.XPathBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 669090 $
 */
public class CustomDataSetTest extends ContextTestSupport {
    protected DataSet dataSet = new DataSetSupport() {
        Expression<Exchange> expression = new XPathBuilder<Exchange>(""/message/@index"").resultType(Long.class);
        @Override
        public void assertMessageExpected(DataSetEndpoint dataSetEndpoint, Exchange expected, Exchange actual, long index) throws Exception {
            // lets compare the XPath result
            Predicate<Exchange> predicate = PredicateBuilder.isEqualTo(expression, ExpressionBuilder.constantExpression(index));
            log.debug(""evaluating predicate: "" + predicate);
            predicate.assertMatches(""Actual: "" + actual, actual);
        }
        protected Object createMessageBody(long messageIndex) {
            return ""<message index='"" + messageIndex + ""'>someBody"" + messageIndex + ""</message>"";
        }
    };
    public void testUsingCustomDataSet() throws Exception {
        MockEndpoint endpoint = getMockEndpoint(""mock:results"");
        endpoint.expectedMessageCount((int) dataSet.getSize());
        assertMockEndpointsSatisifed();
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""foo"", dataSet);
        return context;
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""dataset:foo"").multicast().
                        to(""mock:results"").
                        to(""direct:foo"");
                from(""direct:foo"").to(""dataset:foo"");
            }
        };
    }
}
"
org.apache.camel.component.dataset.DataSet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import org.apache.camel.Exchange;
/**
 * Represents a strategy for testing endpoints with canned data.
 *
 * @version $Revision: 660275 $
 */
public interface DataSet {
    String INDEX_HEADER = ""camelDataSetIndex"";
    /**
     * Populates a message exchange when using the DataSet as a source of messages
     *
     * @param exchange
     */
    void populateMessage(Exchange exchange, long messageIndex) throws Exception;
    /**
     * Returns the size of the dataset
     */
    long getSize();
    /**
     * Asserts that the expected message has been received for the given index
     */
    void assertMessageExpected(DataSetEndpoint dataSetEndpoint, Exchange expected, Exchange actual, long index) throws Exception;
    /**
     * Returns the number of messages which should be received before reporting on the progress of the test
     */
    long getReportCount();
}
"
org.apache.camel.component.dataset.DataSetComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.CamelContextHelper;
/**
 * Component for <a href=""http://activemq.apache.org/camel/dataset.html"">DataSet</a>.
 *
 * @version $Revision: 659842 $
 */
public class DataSetComponent extends DefaultComponent<Exchange> {
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        DataSet dataSet = CamelContextHelper.mandatoryLookup(getCamelContext(), remaining, DataSet.class);
        return new DataSetEndpoint(uri, this, dataSet);
    }
}
"
org.apache.camel.component.dataset.DataSetConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.processor.ThroughputLogger;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * DataSet consumer.
 *
 * @version $Revision: 670452 $
 */
public class DataSetConsumer extends DefaultConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(DataSetConsumer.class);
    private DataSetEndpoint endpoint;
    private Processor reporter;
    public DataSetConsumer(DataSetEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (reporter == null) {
            reporter = createReporter();
        }
        final DataSet dataSet = endpoint.getDataSet();
        final long preloadSize = endpoint.getPreloadSize();
        sendMessages(0, preloadSize);
        endpoint.getExecutorService().execute(new Runnable() {
            public void run() {
                sendMessages(preloadSize, dataSet.getSize());
            }
        });
    }
    protected void sendMessages(long startIndex, long endIndex) {
        try {
            for (long i = startIndex; i < endIndex; i++) {
                Exchange exchange = endpoint.createExchange(i);
                getProcessor().process(exchange);
                try {
                    long delay = endpoint.getProduceDelay();
                    if (delay < 3) {
                        // if no delay set then we must sleep at lest for 3 millis to avoid concurrency
                        // issues with extremely high throughput
                        delay = 3;
                    }
                    Thread.sleep(delay);
                } catch (InterruptedException e) {
                    // ignore and just log to debug
                    LOG.debug(e);
                }
                if (reporter != null) {
                    reporter.process(exchange);
                }
            }
        } catch (Exception e) {
            LOG.error(e);
        }
    }
    protected ThroughputLogger createReporter() {
        ThroughputLogger answer = new ThroughputLogger(endpoint.getEndpointUri(), (int) endpoint.getDataSet().getReportCount());
        answer.setAction(""Sent"");
        return answer;
    }
}
"
org.apache.camel.component.dataset.DataSetConsumeTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
/**
 * @version $Revision: 659842 $
 */
public class DataSetConsumeTest extends ContextTestSupport {
    protected SimpleDataSet dataSet = new SimpleDataSet(20);
    public void testSendingMessagesExplicitlyToDataSetEndpoint() throws Exception {
        long size = dataSet.getSize();
        for (long i = 0; i < size; i++) {
            template.sendBodyAndHeader(""dataset:foo"", ""<hello>world!</hello>"", DataSet.INDEX_HEADER, i);
        }
        assertMockEndpointsSatisifed();
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""foo"", dataSet);
        return context;
    }
}
"
org.apache.camel.component.dataset.DataSetEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.EventDrivenPollingConsumer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Endpoint for DataSet.
 *
 * @version $Revision: 663826 $
 */
public class DataSetEndpoint extends MockEndpoint implements Service {
    private static final transient Log LOG = LogFactory.getLog(DataSetEndpoint.class);
    private DataSet dataSet;
    private AtomicInteger receivedCounter = new AtomicInteger();
    private long produceDelay = -1;
    private long consumeDelay = -1;
    private long startTime;
    private long preloadSize;
    public DataSetEndpoint(String endpointUri, Component component, DataSet dataSet) {
        super(endpointUri, component);
        this.dataSet = dataSet;
    }
    public DataSetEndpoint(String endpointUri, DataSet dataSet) {
        super(endpointUri);
        this.dataSet = dataSet;
    }
    public static void assertEquals(String description, Object expected, Object actual, Exchange exchange) {
        if (!ObjectHelper.equal(expected, actual)) {
            throw new AssertionError(description + "" does not match. Expected: "" + expected + "" but was: "" + actual + "" on "" + exchange + "" with headers: "" + exchange.getIn().getHeaders());
        }
    }
    @Override
    public PollingConsumer<Exchange> createPollingConsumer() throws Exception {
        return new EventDrivenPollingConsumer<Exchange>(this);
    }
    @Override
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new DataSetConsumer(this, processor);
    }
    @Override
    public void reset() {
        super.reset();
        receivedCounter.set(0);
    }
    @Override
    public int getReceivedCounter() {
        return receivedCounter.get();
    }
    /**
     * Creates a message exchange for the given index in the {@link DataSet}
     */
    public Exchange createExchange(long messageIndex) throws Exception {
        Exchange exchange = createExchange();
        getDataSet().populateMessage(exchange, messageIndex);
        Message in = exchange.getIn();
        in.setHeader(DataSet.INDEX_HEADER, messageIndex);
        return exchange;
    }
    @Override
    protected void waitForCompleteLatch() throws InterruptedException {
        // TODO lets do a much better version of this!
        long size = getDataSet().getSize();
        size *= 4000;
        setResultWaitTime(size);
        super.waitForCompleteLatch();
    }
    // Properties
    //-------------------------------------------------------------------------
    public DataSet getDataSet() {
        return dataSet;
    }
    public void setDataSet(DataSet dataSet) {
        this.dataSet = dataSet;
    }
    public long getPreloadSize() {
        return preloadSize;
    }
    /**
     * Sets how many messages should be preloaded (sent) before the route completes its initialisation
     */
    public void setPreloadSize(long preloadSize) {
        this.preloadSize = preloadSize;
    }
    public long getConsumeDelay() {
        return consumeDelay;
    }
    /**
     * Allows a delay to be specified which causes consumers to pause - to simulate slow consumers
     */
    public void setConsumeDelay(long consumeDelay) {
        this.consumeDelay = consumeDelay;
    }
    public long getProduceDelay() {
        return produceDelay;
    }
    /**
     * Allows a delay to be specified which causes producers to pause - to simpulate slow producers
     */
    public void setProduceDelay(long produceDelay) {
        this.produceDelay = produceDelay;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void performAssertions(Exchange actual) throws Exception {
        if (startTime == 0) {
            startTime = System.currentTimeMillis();
        }
        int receivedCount = receivedCounter.incrementAndGet();
        long index = receivedCount - 1;
        Exchange expected = createExchange(index);
        // now lets assert that they are the same
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Received message: "" + index + "" = "" + actual);
        }
        assertMessageExpected(index, expected, actual);
        if (consumeDelay > 0) {
            Thread.sleep(consumeDelay);
        }
        long group = getDataSet().getReportCount();
        if (receivedCount % group == 0) {
            reportProgress(actual, receivedCount);
        }
    }
    protected void reportProgress(Exchange actual, int receivedCount) {
        long time = System.currentTimeMillis();
        long elapsed = time - startTime;
        startTime = time;
        LOG.info(""Received: "" + receivedCount + "" messages so far. Last group took: "" + elapsed + "" millis"");
    }
    protected void assertMessageExpected(long index, Exchange expected, Exchange actual) throws Exception {
        long actualCounter = ExchangeHelper.getMandatoryHeader(actual, DataSet.INDEX_HEADER, Long.class);
        assertEquals(""Header: "" + DataSet.INDEX_HEADER, index, actualCounter, actual);
        getDataSet().assertMessageExpected(this, expected, actual, index);
    }
    public void start() throws Exception {
        long size = getDataSet().getSize();
        expectedMessageCount((int) size);
    }
    public void stop() throws Exception {
    }
}
"
org.apache.camel.component.dataset.DataSetSedaTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test to demonstrate high concurrency with seda. Offspring by CAMEL-605.
 */
public class DataSetSedaTest extends ContextTestSupport {
    private SimpleDataSet dataSet = new SimpleDataSet(500);
    public void test() throws Exception {
        MockEndpoint endpoint = getMockEndpoint(""dataset:foo"");
        endpoint.expectedMessageCount((int) dataSet.getSize());
        assertMockEndpointsSatisifed();
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""foo"", dataSet);
        return context;
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""dataset:foo"").to(""seda:queue:test"");
                from(""seda:queue:test"").to(""dataset:foo"");
            }
        };
    }
}
"
org.apache.camel.component.dataset.DataSetSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.util.ExchangeHelper;
/**
 * Base class for DataSet
 *
 * @version $Revision: 659771 $
 */
public abstract class DataSetSupport implements DataSet {
    private Map<String, Object> defaultHeaders;
    private Processor outputTransformer;
    private long size = 10;
    private long reportCount = -1;
    public DataSetSupport() {
    }
    public DataSetSupport(int size) {
        setSize(size);
    }
    public void populateMessage(Exchange exchange, long messageIndex) throws Exception {
        Message in = exchange.getIn();
        in.setBody(createMessageBody(messageIndex));
        in.setHeaders(getDefaultHeaders());
        applyHeaders(exchange, messageIndex);
        if (outputTransformer != null) {
            outputTransformer.process(exchange);
        }
    }
    public void assertMessageExpected(DataSetEndpoint dataSetEndpoint, Exchange expected, Exchange actual, long index) throws Exception {
        Object expectedBody = expected.getIn().getBody();
        Object actualBody = actual.getIn().getBody();
        if (expectedBody != null) {
            // lets coerce to the correct type
            actualBody = ExchangeHelper.getMandatoryInBody(actual, expectedBody.getClass());
        }
        DataSetEndpoint.assertEquals(""message body"", expectedBody, actualBody, actual);
    }
    // Properties
    //-------------------------------------------------------------------------
    public long getSize() {
        return size;
    }
    public void setSize(long size) {
        this.size = size;
    }
    public long getReportCount() {
        if (reportCount <= 0) {
            reportCount = getSize() / 5;
        }
        return reportCount;
    }
    /**
     * Sets the number of messages in a group on which we will report that messages have been received.
     */
    public void setReportCount(long reportCount) {
        this.reportCount = reportCount;
    }
    public Map<String, Object> getDefaultHeaders() {
        if (defaultHeaders == null) {
            defaultHeaders = new HashMap<String, Object>();
            populateDefaultHeaders(defaultHeaders);
        }
        return defaultHeaders;
    }
    public void setDefaultHeaders(Map<String, Object> defaultHeaders) {
        this.defaultHeaders = defaultHeaders;
    }
    public Processor getOutputTransformer() {
        return outputTransformer;
    }
    public void setOutputTransformer(Processor outputTransformer) {
        this.outputTransformer = outputTransformer;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected abstract Object createMessageBody(long messageIndex);
    /**
     * Allows derived classes to add some custom headers for a given message
     */
    protected void applyHeaders(Exchange exchange, long messageIndex) {
    }
    /**
     * Allows derived classes to customize a default set of properties
     */
    protected void populateDefaultHeaders(Map<String, Object> map) {
    }
}
"
org.apache.camel.component.dataset.DataSetTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 647890 $
 */
public class DataSetTest extends ContextTestSupport {
    protected SimpleDataSet dataSet = new SimpleDataSet(20);
    public void test() throws Exception {
        MockEndpoint endpoint = getMockEndpoint(""mock:results"");
        endpoint.expectedMessageCount((int) dataSet.getSize());
        assertMockEndpointsSatisifed();
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""foo"", dataSet);
        return context;
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""dataset:foo"").multicast().
                        to(""mock:results"").
                        to(""direct:foo"");
                from(""direct:foo"").to(""dataset:foo"");
            }
        };
    }
}
"
org.apache.camel.component.dataset.SimpleDataSet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.dataset;
import org.apache.camel.Processor;
/**
 * A simple DataSet that allows a static payload to be used to create each message exchange
 * along with using a pluggable transformer to randomize the message.
 *
 * @version $Revision: 647890 $
 */
public class SimpleDataSet extends DataSetSupport {
    private Object defaultBody = ""<hello>world!</hello>"";
    private Processor inputTransformer;
    public SimpleDataSet() {
    }
    public SimpleDataSet(int size) {
        super(size);
    }
    // Properties
    //-------------------------------------------------------------------------
    public Object getDefaultBody() {
        return defaultBody;
    }
    public void setDefaultBody(Object defaultBody) {
        this.defaultBody = defaultBody;
    }
    public Processor getInputTransformer() {
        return inputTransformer;
    }
    public void setInputTransformer(Processor inputTransformer) {
        this.inputTransformer = inputTransformer;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * Creates the message body for a given message
     */
    protected Object createMessageBody(long messageIndex) {
        return getDefaultBody();
    }
}
"
org.apache.camel.component.direct.DirectComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Represents the component that manages {@link DirectEndpoint}. It holds the
 * list of named direct endpoints.
 *
 * @version $Revision: 640438 $
 */
public class DirectComponent<E extends Exchange> extends DefaultComponent<E> {
    protected Endpoint<E> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Endpoint<E> endpoint = new DirectEndpoint<E>(uri, this);
        setProperties(endpoint, parameters);
        return endpoint;
    }
}
"
org.apache.camel.component.direct.DirectEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a direct endpoint that synchronously invokes the consumers of the
 * endpoint when a producer sends a message to it.
 *
 * @version $Revision: 660275 $
 */
public class DirectEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private static final transient Log LOG = LogFactory.getLog(DirectEndpoint.class);
    private boolean allowMultipleConsumers = true;
    private final CopyOnWriteArrayList<DefaultConsumer<E>> consumers = new CopyOnWriteArrayList<DefaultConsumer<E>>();
    public DirectEndpoint(String uri, DirectComponent<E> component) {
        super(uri, component);
    }
    public DirectEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer createProducer() throws Exception {
        return new DirectProducer<E>(this);
    }
    public Consumer<E> createConsumer(Processor processor) throws Exception {
        return new DefaultConsumer<E>(this, processor) {
            @Override
            public void start() throws Exception {
                if (!allowMultipleConsumers && !consumers.isEmpty()) {
                    throw new IllegalStateException(""Endpoint "" + getEndpointUri() + "" only allows 1 active consumer but you attempted to start a 2nd consumer."");
                }
                consumers.add(this);
                super.start();
            }
            @Override
            public void stop() throws Exception {
                super.stop();
                consumers.remove(this);
            }
        };
    }
    public boolean isAllowMultipleConsumers() {
        return allowMultipleConsumers;
    }
    public void setAllowMultipleConsumers(boolean allowMutlipleConsumers) {
        this.allowMultipleConsumers = allowMutlipleConsumers;
    }
    public boolean isSingleton() {
        return true;
    }
    public List<DefaultConsumer<E>> getConsumers() {
        return consumers;
    }
}
"
org.apache.camel.component.direct.DirectNoToTypeTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * Simple unit test based on user forum question.
 */
public class DirectNoToTypeTest extends ContextTestSupport {
    public void testNoToType() throws Exception {
        Object response = template.requestBody(""direct:in"", ""Hello"");
        assertEquals(""Hello World"", response);
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:in"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        String body = exchange.getIn().getBody(String.class);
                        exchange.getOut(true).setBody(body + "" World"");
                    }
                });
            }
        };
    }
}
"
org.apache.camel.component.direct.DirectProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The direct producer.
 *
 * @version $Revision: 659771 $
 */
public class DirectProducer<E extends Exchange> extends DefaultProducer implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(DirectProducer.class);
    private DirectEndpoint<E> endpoint;
    public DirectProducer(DirectEndpoint<E> endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) throws Exception {
        if (endpoint.getConsumers().isEmpty()) {
            LOG.warn(""No getConsumers() available on "" + this + "" for "" + exchange);
        } else {
            for (DefaultConsumer<E> consumer : endpoint.getConsumers()) {
                consumer.getProcessor().process(exchange);
            }
        }
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        int size = endpoint.getConsumers().size();
        if (size == 0) {
            LOG.warn(""No getConsumers() available on "" + this + "" for "" + exchange);
        } else if (size == 1) {
            DefaultConsumer<E> consumer = endpoint.getConsumers().get(0);
            AsyncProcessor processor = AsyncProcessorTypeConverter.convert(consumer.getProcessor());
            return processor.process(exchange, callback);
        } else if (size > 1) {
            // Too hard to do multiple async.. do it sync
            try {
                for (DefaultConsumer<E> consumer : endpoint.getConsumers()) {
                    consumer.getProcessor().process(exchange);
                }
            } catch (Throwable error) {
                exchange.setException(error);
            }
        }
        callback.done(true);
        return true;
    }
}
"
org.apache.camel.component.direct.DirectRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import java.util.concurrent.atomic.AtomicBoolean;
import junit.framework.TestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
/**
 * @version $Revision: 630568 $
 */
public class DirectRouteTest extends TestCase {
    public void testSedaQueue() throws Exception {
        CamelContext container = new DefaultCamelContext();
        final AtomicBoolean invoked = new AtomicBoolean();
        // lets add some routes
        container.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:test.a"").to(""direct:test.b"");
                from(""direct:test.b"").process(new Processor() {
                    public void process(Exchange e) {
                        invoked.set(true);
                    }
                });
            }
        });
        container.start();
        // now lets fire in a message
        Endpoint<Exchange> endpoint = container.getEndpoint(""direct:test.a"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setHeader(""cheese"", 123);
        Producer<Exchange> producer = endpoint.createProducer();
        producer.process(exchange);
        // now lets sleep for a while
        assertTrue(""Did not receive the message!"", invoked.get());
        container.stop();
    }
}
"
org.apache.camel.component.file.BeanToFileTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.util.jndi.JndiContext;
/**
 * Unit test that we can chain bean and file producer.
 */
public class BeanToFileTest extends ContextTestSupport {
    public void testBeanToFile() throws Exception {
        template.sendBody(""direct:in"", ""World"");
        // give Camel time to create the file
        Thread.sleep(1000);
        File file = new File(""target/BeanToFileTest.txt"");
        file = file.getAbsoluteFile();
        assertEquals(""Bye World"", IOConverter.toString(file));
    }
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", new MyBean());
        return answer;
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:in"").
                    to(""bean:myBean"").
                    setHeader(FileComponent.HEADER_FILE_NAME, ""BeanToFileTest.txt"").
                    to(""file://target/?append=false"");
            }
        };
    }
    public static class MyBean {
        public String doSomething(String input) {
            return ""Bye "" + input;
        }
    }
}
"
org.apache.camel.component.file.DirectoryCreateIssueTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.TestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
/**
 * @author Albert Moraal
 * @version $Revision: 666952 $
 */
public class DirectoryCreateIssueTest extends TestSupport {
    private CamelContext context;
    private ProducerTemplate template;
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context = new DefaultCamelContext();
        context.start();
        template = context.createProducerTemplate();
    }
    @Override
    protected void tearDown() throws Exception {
        context.stop();
        super.tearDown();
    }
    public void testFileCreatedAsDir() throws Exception {
        log.debug(""testFileCreatedAsDir"");
        final String path = ""target/a/b/c/d/e/f/g/h"";
        final int numFiles = 10;
        context.addRoutes(
            new RouteBuilder() {
                @Override
                public void configure() {
                    String[] destinations = new String[numFiles];
                    for (int i = 0; i < numFiles; i++) {
                        destinations[i] = ""seda:file"" + i;
                        from(""seda:file"" + i)
                            .setHeader(FileComponent.HEADER_FILE_NAME,
                                constant(""file"" + i + "".txt""))
                            .to(""file://"" + path + ""/?append=false&noop=true"");
                    }
                    from(""seda:testFileCreatedAsDir"")
                        .to(destinations);
                }
            }
        );
        deleteDirectory(new File(""a""));
        template.send(""seda:testFileCreatedAsDir"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""Contents of test file"");
            }
        });
        // must sleep for some time to make sure runs on all platforms
        Thread.sleep(8 * 1000);
        for (int i = 0; i < numFiles; i++) {
            assertTrue((new File(path + ""/file"" + i + "".txt"")).isFile());
        }
    }
}
"
org.apache.camel.component.file.FileAsyncRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 643934 $
 */
public class FileAsyncRouteTest extends ContextTestSupport {
    protected Object expectedBody = ""Hello there!"";
    protected String uri = ""file:target/test-async-inbox?delete=true"";
    CountDownLatch receivedLatch = new CountDownLatch(1);
    CountDownLatch processingLatch = new CountDownLatch(1);
    AtomicReference<File> file = new AtomicReference<File>();
    @Override
    protected void setUp() throws Exception {
        deleteDirectory(""target/test-async-inbox"");
        super.setUp();
    }
    @Override
    protected void tearDown() throws Exception {
        processingLatch.countDown();
        receivedLatch.countDown();
        super.tearDown();
    }
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedBodiesReceived(expectedBody);
        result.setResultWaitTime(5000);
        template.sendBodyAndHeader(uri, expectedBody, ""cheese"", 123);
        // Wait till the exchange is delivered to the processor
        assertTrue(""Async processor received exchange"", receivedLatch.await(5, TimeUnit.SECONDS));
        File file = this.file.get();
        // The file consumer support async processing of the exchange,
        // so the file should not get deleted until the exchange
        // finishes being asynchronously processed.
        Thread.sleep(1000);
        assertTrue(""File should exist"", file.exists());
        // Release the async processing thread so that the exchange completes
        // and the file
        // gets deleted.
        processingLatch.countDown();
        Thread.sleep(1000);
        assertFalse(""File should not exist"", file.exists());
        result.assertIsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(uri).thread(1).to(""direct:a"");
                from(""direct:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        file.set((File)exchange.getIn().getBody());
                        // Simulate a processing delay..
                        receivedLatch.countDown();
                        processingLatch.await();
                    }
                }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * The <a href=""http://activemq.apache.org/camel/file.html"">File Component</a>
 * for working with file systems
 *
 * @version $Revision: 676311 $
 */
public class FileComponent extends DefaultComponent<FileExchange> {
    /**
     * Header key holding the value: the fixed filename to use for producing files.
     */
    public static final String HEADER_FILE_NAME = ""org.apache.camel.file.name"";
    /**
     * Header key holding the value: absolute filepath for the actual file produced.
     * Value is set automatically by Camel
     */
    public static final String HEADER_FILE_NAME_PRODUCED = ""org.apache.camel.file.name.produced"";
    public FileComponent() {
    }
    public FileComponent(CamelContext context) {
        super(context);
    }
    protected Endpoint<FileExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        File file = new File(remaining);
        FileEndpoint result = new FileEndpoint(file, uri, this);
        setProperties(result, parameters);
        return result;
    }
}
"
org.apache.camel.component.file.FileConfigureTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultMessage;
/**
 * @version $Revision: 630591 $
 */
public class FileConfigureTest extends ContextTestSupport {
    private static final String EXPECT_PATH = ""target"" + File.separator + ""foo"" + File.separator + ""bar"";
    private static final String EXPECT_FILE = ""some"" + File.separator + ""nested"" + File.separator + ""filename.txt"";
    public void testUriConfigurations() throws Exception {
        assertFileEndpoint(""file://target/foo/bar"", EXPECT_PATH);
        assertFileEndpoint(""file://target/foo/bar?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar"", EXPECT_PATH);
        assertFileEndpoint(""file://target/foo/bar/"", EXPECT_PATH);
        assertFileEndpoint(""file://target/foo/bar/?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar/?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar/"", EXPECT_PATH);
        assertFileEndpoint(""file:/target/foo/bar/"", File.separator + EXPECT_PATH);        
        assertFileEndpoint(""file:/"", File.separator);
        assertFileEndpoint(""file:///"", File.separator);
    }
    private void assertFileEndpoint(String endpointUri, String expectedPath) {
        FileEndpoint endpoint = resolveMandatoryEndpoint(endpointUri, FileEndpoint.class);
        assertNotNull(""Could not find endpoint: "" + endpointUri, endpoint);
        File file = endpoint.getFile();
        String path = file.getPath();
        assertEquals(""For uri: "" + endpointUri + "" the file is not equal"", expectedPath, path);
        File consumedFile = new File(expectedPath + (expectedPath.endsWith(File.separator) ? """" : File.separator) + EXPECT_FILE);
        Message message = new DefaultMessage();
        endpoint.configureMessage(consumedFile, message);
        assertEquals(EXPECT_FILE, message.getHeader(FileComponent.HEADER_FILE_NAME));  
    }
}
"
org.apache.camel.component.file.FileConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * For consuming files.
 *
 * @version $Revision: 662314 $
 */
public class FileConsumer extends ScheduledPollConsumer<FileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FileConsumer.class);
    private FileEndpoint endpoint;
    private ConcurrentHashMap<File, File> filesBeingProcessed = new ConcurrentHashMap<File, File>();
    private ConcurrentHashMap<File, Long> fileSizes = new ConcurrentHashMap<File, Long>();
    private ConcurrentHashMap<File, Long> noopMap = new ConcurrentHashMap<File, Long>();
    private boolean generateEmptyExchangeWhenIdle;
    private boolean recursive = true;
    private String regexPattern = """";
    private long lastPollTime;
    private int unchangedDelay;
    private boolean unchangedSize;
    public FileConsumer(final FileEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    protected synchronized void poll() throws Exception {
        int rc = pollFileOrDirectory(endpoint.getFile(), isRecursive());
        if (rc == 0 && generateEmptyExchangeWhenIdle) {
            final FileExchange exchange = endpoint.createExchange((File)null);
            getAsyncProcessor().process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                }
            });
        }
        lastPollTime = System.currentTimeMillis();
    }
    /**
     * Pools the given file or directory for files to process.
     *
     * @param fileOrDirectory  file or directory
     * @param processDir  recursive
     * @return the number of files processed or being processed async.
     */
    protected int pollFileOrDirectory(File fileOrDirectory, boolean processDir) {
        if (!fileOrDirectory.isDirectory()) {
            return pollFile(fileOrDirectory); // process the file
        } else if (processDir) {
            int rc = 0;
            if (isValidFile(fileOrDirectory)) {
                LOG.debug(""Polling directory "" + fileOrDirectory);
                File[] files = fileOrDirectory.listFiles();
                for (File file : files) {
                    rc += pollFileOrDirectory(file, isRecursive()); // self-recursion
                }
            }
            return rc;
        } else {
            LOG.debug(""Skipping directory "" + fileOrDirectory);
            return 0;
        }
    }
    /**
     * Polls the given file
     *
     * @param file  the file
     * @return returns 1 if the file was processed, 0 otherwise.
     */
    protected int pollFile(final File file) {
        if (!file.exists()) {
            return 0;
        }
        if (!isValidFile(file)) {
            return 0;
        }
        // we only care about file modified times if we are not deleting/moving files
        if (!endpoint.isNoop()) {
            if (filesBeingProcessed.contains(file)) {
                return 1;
            }
            filesBeingProcessed.put(file, file);
        }
        final FileProcessStrategy processStrategy = endpoint.getFileStrategy();
        final FileExchange exchange = endpoint.createExchange(file);
        endpoint.configureMessage(file, exchange.getIn());
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""About to process file: "" + file + "" using exchange: "" + exchange);
            }
            if (processStrategy.begin(endpoint, exchange, file)) {
                // Use the async processor interface so that processing of
                // the exchange can happen asynchronously
                getAsyncProcessor().process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        boolean failed = exchange.isFailed();
                        boolean handled = DeadLetterChannel.isFailureHandled(exchange);
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Done processing file: "" + file + "". Status is: "" + (failed ? ""failed: "" + failed + "", handled by failure processor: "" + handled : ""OK""));
                        }
                        if (!failed || handled) {
                            // commit the file strategy if there was no failure or already handled by the DeadLetterChannel
                            processStrategyCommit(processStrategy, exchange, file, handled);
                        } else if (failed && !handled) {
                            // there was an exception but it was not handled by the DeadLetterChannel
                            handleException(exchange.getException());
                        }
                        filesBeingProcessed.remove(file);
                    }
                });
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(endpoint + "" cannot process file: "" + file);
                }
            }
        } catch (Throwable e) {
            handleException(e);
        }
        return 1;
    }
    /**
     * Strategy when the file was processed and a commit should be executed.
     *
     * @param processStrategy   the strategy to perform the commit
     * @param exchange          the exchange
     * @param file              the file processed
     * @param failureHandled    is <tt>false</tt> if the exchange was processed succesfully, <tt>true</tt> if
     * an exception occured during processing but it was handled by the failure processor (usually the
     * DeadLetterChannel).
     */
    protected void processStrategyCommit(FileProcessStrategy processStrategy, FileExchange exchange,
                                         File file, boolean failureHandled) {
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Committing file strategy: "" + processStrategy + "" for file: "" + file + (failureHandled ? "" that was handled by the failure processor."" : """"));
            }
            processStrategy.commit(endpoint, exchange, file);
        } catch (Exception e) {
            LOG.warn(""Error committing file strategy: "" + processStrategy, e);
            handleException(e);
        }
    }
    protected boolean isValidFile(File file) {
        boolean result = false;
        if (file != null && file.exists()) {
            // TODO: maybe use a configurable strategy instead of the hardcoded one based on last file change
            if (isMatched(file) && isChanged(file)) {
                result = true;
            }
        }
        return result;
    }
    protected boolean isChanged(File file) {
        if (file == null) {
            // Sanity check
            return false;
        } else if (file.isDirectory()) {
            // Allow recursive polling to descend into this directory
            return true;
        } else {
            boolean lastModifiedCheck = false;
            long modifiedDuration = 0;
            if (getUnchangedDelay() > 0) {
                modifiedDuration = System.currentTimeMillis() - file.lastModified();
                lastModifiedCheck = modifiedDuration >= getUnchangedDelay();
            }
            long fileModified = file.lastModified();
            Long previousModified = noopMap.get(file);
            noopMap.put(file, fileModified);
            if (previousModified == null || fileModified > previousModified) {
                lastModifiedCheck = true;
            }
            boolean sizeCheck = false;
            long sizeDifference = 0;
            if (isUnchangedSize()) {
                Long value = fileSizes.get(file);
                if (value == null) {
                    sizeCheck = true;
                } else {
                    sizeCheck = file.length() != value;
                }
            }
            boolean answer = lastModifiedCheck || sizeCheck;
            if (LOG.isDebugEnabled()) {
                LOG.debug(""file:"" + file + "" isChanged:"" + answer + "" "" + ""sizeCheck:"" + sizeCheck + ""(""
                          + sizeDifference + "") "" + ""lastModifiedCheck:"" + lastModifiedCheck + ""(""
                          + modifiedDuration + "")"");
            }
            if (isUnchangedSize()) {
                if (answer) {
                    fileSizes.put(file, file.length());
                } else {
                    fileSizes.remove(file);
                }
            }
            return answer;
        }
    }
    protected boolean isMatched(File file) {
        String name = file.getName();
        if (regexPattern != null && regexPattern.length() > 0) {
            if (!name.matches(getRegexPattern())) {
                return false;
            }
        }
        String[] prefixes = endpoint.getExcludedNamePrefixes();
        if (prefixes != null) {
            for (String prefix : prefixes) {
                if (name.startsWith(prefix)) {
                    return false;
                }
            }
        }
        String[] postfixes = endpoint.getExcludedNamePostfixes();
        if (postfixes != null) {
            for (String postfix : postfixes) {
                if (name.endsWith(postfix)) {
                    return false;
                }
            }
        }
        return true;
    }
    public boolean isRecursive() {
        return this.recursive;
    }
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    public String getRegexPattern() {
        return this.regexPattern;
    }
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isGenerateEmptyExchangeWhenIdle() {
        return generateEmptyExchangeWhenIdle;
    }
    public void setGenerateEmptyExchangeWhenIdle(boolean generateEmptyExchangeWhenIdle) {
        this.generateEmptyExchangeWhenIdle = generateEmptyExchangeWhenIdle;
    }
    public int getUnchangedDelay() {
        return unchangedDelay;
    }
    public void setUnchangedDelay(int unchangedDelay) {
        this.unchangedDelay = unchangedDelay;
    }
    public boolean isUnchangedSize() {
        return unchangedSize;
    }
    public void setUnchangedSize(boolean unchangedSize) {
        this.unchangedSize = unchangedSize;
    }
}
"
org.apache.camel.component.file.FileConsumerFailureHandledTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.file.strategy.FileProcessStrategySupport;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for consuming files but the exchange fails and is handled
 * by the failure handler (usually the DeadLetterChannel)
 */
public class FileConsumerFailureHandledTest extends ContextTestSupport {
    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        deleteDirectory(""target/messages"");
    }
    public void testParis() throws Exception {
        deleteDirectory(""target/messages"");
        MockEndpoint mock = getMockEndpoint(""mock:valid"");
        mock.expectedBodiesReceived(""Hello Paris"");
        template.sendBodyAndHeader(""file:target/messages/input/?delete=true"", ""Paris"", FileComponent.HEADER_FILE_NAME, ""paris.txt"");
        mock.assertIsSatisfied();
        // sleep otherwise the file assertions below could fail
        Thread.sleep(500);
        asserFiles(""paris.txt"");
    }
    public void testLondon() throws Exception {
        deleteDirectory(""target/messages"");
        MockEndpoint mock = getMockEndpoint(""mock:invalid"");
        // we get the original input so its not Hello London but only London
        mock.expectedBodiesReceived(""London"");
        template.sendBodyAndHeader(""file:target/messages/input/?delete=true"", ""London"", FileComponent.HEADER_FILE_NAME, ""london.txt"");
        mock.assertIsSatisfied();
        // sleep otherwise the file assertions below could fail
        Thread.sleep(500);
        asserFiles(""london.txt"");
    }
    public void testMadrid() throws Exception {
        deleteDirectory(""target/messages"");
        MockEndpoint mock = getMockEndpoint(""mock:error"");
        // we get the original input so its not Hello London but only London
        mock.expectedBodiesReceived(""Madrid"");
        template.sendBodyAndHeader(""file:target/messages/input/?delete=true"", ""Madrid"", FileComponent.HEADER_FILE_NAME, ""madrid.txt"");
        mock.assertIsSatisfied();
        // sleep otherwise the file assertions below could fail
        Thread.sleep(500);
        asserFiles(""madrid.txt"");
    }
    private static void asserFiles(String filename) {
        // file should be deleted as deleted=true in parameter in the route below
        File file = new File(""target/messages/input/"" + filename);
        assertEquals(""File "" + filename + "" should be deleted"", false, file.exists());
        // and no lock files
        file = new File(""target/messages/input/"" + filename + FileProcessStrategySupport.DEFAULT_LOCK_FILE_POSTFIX);
        assertEquals(""File "" + filename + "" lock should be deleted"", false, file.exists());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // make sure mock:error is the dead letter channel
                errorHandler(deadLetterChannel(""mock:error"").maximumRedeliveries(2));
                // special failure handler for ValidationException
                exception(ValidationException.class).to(""mock:invalid"");
                // our route logic to process files from the input folder
                from(""file:target/messages/input/?delete=true"").
                    process(new MyValidatorProcessor()).
                    to(""mock:valid"");
            }
        };
    }
    private class MyValidatorProcessor implements Processor {
        public void process(Exchange exchange) throws Exception {
            String body = exchange.getIn().getBody(String.class);
            if (""London"".equals(body)) {
                throw new ValidationException(exchange, ""Forced exception by unit test"");
            } else if (""Madrid"".equals(body)) {
                throw new RuntimeCamelException(""Madrid is not a supported city"");
            }
            exchange.getOut().setBody(""Hello "" + body);
        }
    }
}
"
org.apache.camel.component.file.FileConsumerProducerRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 643934 $
 */
public class FileConsumerProducerRouteTest extends ContextTestSupport {
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedMessageCount(2);
        result.setResultWaitTime(10000);
        result.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        deleteDirectory(""target/test-consumer-produer-inbox"");
        super.setUp(); 
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""file:src/main/data?noop=true"").to(""file:target/test-consumer-produer-inbox"");
                from(""file:target/test-consumer-produer-inbox"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileDeleteRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 643934 $
 */
public class FileDeleteRouteTest extends FileRouteTest {
    @Override
    protected void setUp() throws Exception {
        uri = ""file:target/test-delete-inbox?consumer.delay=1000&delete=true"";
        deleteDirectory(""target/test-delete-inbox"");
        super.setUp();
    }
    @Override
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedBodiesReceived(expectedBody);
        result.setResultWaitTime(5000);
        template.sendBodyAndHeader(uri, expectedBody, ""cheese"", 123);
        Thread.sleep(4000);
        result.assertIsSatisfied();
    }
}
"
org.apache.camel.component.file.FileEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Properties;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.component.file.strategy.FileProcessStrategySupport;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.UuidGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A <a href=""http://activemq.apache.org/camel/file.html"">File Endpoint</a> for
 * working with file systems
 *
 * @version $Revision: 664624 $
 */
public class FileEndpoint extends ScheduledPollEndpoint<FileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FileEndpoint.class);
    private static final String DEFAULT_STRATEGYFACTORY_CLASS =
        ""org.apache.camel.component.file.strategy.FileProcessStrategyFactory"";
    private File file;
    private FileProcessStrategy fileProcessStrategy;
    private boolean autoCreate = true;
    private boolean lock = true;
    private boolean delete;
    private boolean noop;
    private boolean append = true;
    private String moveNamePrefix;
    private String moveNamePostfix;
    private String[] excludedNamePrefixes = {"".""};
    private String[] excludedNamePostfixes = {FileProcessStrategySupport.DEFAULT_LOCK_FILE_POSTFIX};
    private int bufferSize = 128 * 1024;
    private boolean ignoreFileNameHeader;
    protected FileEndpoint(File file, String endpointUri, FileComponent component) {
        super(endpointUri, component);
        this.file = file;
    }
    public FileEndpoint(String endpointUri, File file) {
        super(endpointUri);
        this.file = file;
    }
    public FileEndpoint(File file) {
        this.file = file;
    }
    public FileEndpoint() {
    }
    public Producer<FileExchange> createProducer() throws Exception {
        Producer<FileExchange> result = new FileProducer(this);
        return result;
    }
    public Consumer<FileExchange> createConsumer(Processor processor) throws Exception {
        Consumer<FileExchange> result = new FileConsumer(this, processor);
        configureConsumer(result);
        return result;
    }
    /**
     * Create a new exchange for communicating with this endpoint
     *
     * @param file  the file
     * @return the created exchange
     */
    public FileExchange createExchange(File file) {
        return new FileExchange(getCamelContext(), getExchangePattern(), file);
    }
    @Override
    public FileExchange createExchange() {
        return createExchange(getFile());
    }
    @Override
    public FileExchange createExchange(ExchangePattern pattern) {
        return new FileExchange(getCamelContext(), pattern, file);
    }
    /**
     * Return the file name that will be auto-generated for the given message if none is provided
     */
    public String getGeneratedFileName(Message message) {
        return getFileFriendlyMessageId(message.getMessageId());
    }
    /**
     * Configures the given message with the file which sets the body to the file object
     * and sets the {@link FileComponent#HEADER_FILE_NAME} header.
     */
    public void configureMessage(File file, Message message) {
        message.setBody(file);
        String relativePath = file.getPath().substring(getFile().getPath().length());
        if (relativePath.startsWith(File.separator) || relativePath.startsWith(""/"")) {
            relativePath = relativePath.substring(1);
        }
        message.setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
    }
    public File getFile() {
        ObjectHelper.notNull(file, ""file"");
        if (autoCreate && !file.exists()) {
            file.mkdirs();
        }
        return file;
    }
    public void setFile(File file) {
        this.file = file;
    }
    public boolean isSingleton() {
        return true;
    }
    public boolean isAutoCreate() {
        return this.autoCreate;
    }
    public void setAutoCreate(boolean autoCreate) {
        this.autoCreate = autoCreate;
    }
    public FileProcessStrategy getFileStrategy() {
        if (fileProcessStrategy == null) {
            fileProcessStrategy = createFileStrategy();
            LOG.debug(""Using file process strategy: "" + fileProcessStrategy);
        }
        return fileProcessStrategy;
    }
    /**
     * Sets the strategy to be used when the file has been processed such as
     * deleting or renaming it etc.
     *
     * @param fileProcessStrategy the new strategy to use
     */
    public void setFileStrategy(FileProcessStrategy fileProcessStrategy) {
        this.fileProcessStrategy = fileProcessStrategy;
    }
    public boolean isDelete() {
        return delete;
    }
    public void setDelete(boolean delete) {
        this.delete = delete;
    }
    public boolean isLock() {
        return lock;
    }
    public void setLock(boolean lock) {
        this.lock = lock;
    }
    public String getMoveNamePostfix() {
        return moveNamePostfix;
    }
    /**
     * Sets the name postfix appended to moved files. For example to rename all
     * the files from <tt>*</tt> to <tt>*.done</tt> set this value to <tt>.done</tt>
     */
    public void setMoveNamePostfix(String moveNamePostfix) {
        this.moveNamePostfix = moveNamePostfix;
    }
    public String getMoveNamePrefix() {
        return moveNamePrefix;
    }
    /**
     * Sets the name prefix appended to moved files. For example to move
     * processed files into a hidden directory called <tt>.camel</tt> set this value to
     * <tt>.camel/</tt>
     */
    public void setMoveNamePrefix(String moveNamePrefix) {
        this.moveNamePrefix = moveNamePrefix;
    }
    public String[] getExcludedNamePrefixes() {
        return excludedNamePrefixes;
    }
    /**
     * Sets the excluded file name prefixes, such as <tt>"".""</tt> for hidden files which
     * are excluded by default
     */
    public void setExcludedNamePrefixes(String[] excludedNamePrefixes) {
        this.excludedNamePrefixes = excludedNamePrefixes;
    }
    public String[] getExcludedNamePostfixes() {
        return excludedNamePostfixes;
    }
    /**
     * Sets the excluded file name postfixes, such as {@link FileProcessStrategySupport#DEFAULT_LOCK_FILE_POSTFIX}
     * to ignore lock files by default.
     */
    public void setExcludedNamePostfixes(String[] excludedNamePostfixes) {
        this.excludedNamePostfixes = excludedNamePostfixes;
    }
    public boolean isNoop() {
        return noop;
    }
    /**
     * If set to true then the default {@link FileProcessStrategy} will be to use the
     * {@link org.apache.camel.component.file.strategy.NoOpFileProcessStrategy NoOpFileProcessStrategy}
     * to not move or copy processed files
     */
    public void setNoop(boolean noop) {
        this.noop = noop;
    }
    public boolean isAppend() {
        return append;
    }
    /**
     * When writing do we append to the end of the file, or replace it?
     * The default is to append
     */
    public void setAppend(boolean append) {
        this.append = append;
    }
    public int getBufferSize() {
        return bufferSize;
    }
    /**
     * Sets the buffer size used to read/write files
     */
    public void setBufferSize(int bufferSize) {
        this.bufferSize = bufferSize;
    }
    public boolean isIgnoreFileNameHeader() {
        return ignoreFileNameHeader;
    }
    /**
     * If this flag is enabled then producers will ignore the {@link FileComponent#HEADER_FILE_NAME}
     * header and generate a new dynamic file
     */
    public void setIgnoreFileNameHeader(boolean ignoreFileNameHeader) {
        this.ignoreFileNameHeader = ignoreFileNameHeader;
    }
    /**
     * A strategy method to lazily create the file strategy
     */
    protected FileProcessStrategy createFileStrategy() {
        Class<?> factory = null;
        try {
            FactoryFinder finder = new FactoryFinder(""META-INF/services/org/apache/camel/component/"");
            factory = finder.findClass(""file"", ""strategy.factory."");
        } catch (ClassNotFoundException e) {
            LOG.debug(""'strategy.factory.class' not found"", e);
        } catch (IOException e) {
            LOG.debug(""No strategy factory defined in 'META-INF/services/org/apache/camel/component/file'"", e);
        }
        if (factory == null) {
            // use default
            factory = ObjectHelper.loadClass(DEFAULT_STRATEGYFACTORY_CLASS);
            if (factory == null) {
                throw new TypeNotPresentException(""FileProcessStrategyFactory class not found"", null);
            }
        }
        try {
            Method factoryMethod = factory.getMethod(""createFileProcessStrategy"", Properties.class);
            return (FileProcessStrategy) ObjectHelper.invokeMethod(factoryMethod, null, getParamsAsProperties());
        } catch (NoSuchMethodException e) {
            throw new TypeNotPresentException(factory.getSimpleName()
                + "".createFileProcessStrategy(Properties params) method not found"", e);
        }
    }
    protected Properties getParamsAsProperties() {
        Properties params = new Properties();
        if (isNoop()) {
            params.setProperty(""noop"", Boolean.toString(true));
        }
        if (isDelete()) {
            params.setProperty(""delete"", Boolean.toString(true));
        }
        if (isAppend()) {
            params.setProperty(""append"", Boolean.toString(true));
        }
        if (isLock()) {
            params.setProperty(""lock"", Boolean.toString(true));
        }
        if (moveNamePrefix != null) {
            params.setProperty(""moveNamePrefix"", moveNamePrefix);
        }
        if (moveNamePostfix != null) {
            params.setProperty(""moveNamePostfix"", moveNamePostfix);
        }
        return params;
    }
    @Override
    protected String createEndpointUri() {
        return ""file://"" + getFile().getAbsolutePath();
    }
    protected  String getFileFriendlyMessageId(String id) {
        return UuidGenerator.generateSanitizedId(id);
    }
}
"
org.apache.camel.component.file.FileExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * A {@link Exchange} for File
 *
 * @version $Revision: 647463 $
 */
public class FileExchange extends DefaultExchange {
    private File file;
    public FileExchange(CamelContext camelContext, ExchangePattern pattern, File file) {
        super(camelContext, pattern);
        setIn(new FileMessage(file));
        this.file = file;
    }
    public FileExchange(DefaultExchange parent, File file) {
        super(parent);
        this.file = file;
    }
    public File getFile() {
        return this.file;
    }
    public void setFile(File file) {
        this.file = file;
    }
    public Exchange newInstance() {
        return new FileExchange(this, getFile());
    }
}
"
org.apache.camel.component.file.FileExchangeTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.util.Collections;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.processor.Pipeline;
/**
 * @version $Revision: 640438 $
 */
public class FileExchangeTest extends ContextTestSupport {
    protected File file;
    protected ExchangePattern pattern = ExchangePattern.InOnly;
    public void testCopy() {
        FileExchange fileExchange = new FileExchange(context, pattern, file);
        Exchange exchange = fileExchange.copy();
        FileExchange copy = assertIsInstanceOf(FileExchange.class, exchange);
        assertEquals(""File"", file, copy.getFile());
        Object body = copy.getIn().getBody();
        assertNotNull(""Should have a body!"", body);
    }
    public void testCopyAfterBodyChanged() throws Exception {
        FileExchange original = new FileExchange(context, pattern, file);
        Object expectedBody = 1234;
        original.getIn().setBody(expectedBody);
        Exchange exchange = original.copy();
        FileExchange copy = assertIsInstanceOf(FileExchange.class, exchange);
        assertEquals(""File"", file, copy.getFile());
        Object body = copy.getIn().getBody();
        assertNotNull(""Should have a body!"", body);
        assertEquals(""Copied exchange in body"", expectedBody, body);
    }
    public void testPipelineCopy() throws Exception {
        Processor myProcessor = new Processor() {
            public void process(Exchange exchange) throws Exception {
                Object body = exchange.getIn().getBody();
                assertNotNull(""Should have a body!"", body);
            }
        };
        Pipeline pipeline = new Pipeline(Collections.singletonList(myProcessor));
        FileExchange exchange = new FileExchange(context, pattern, file);
        pipeline.process(exchange.copy());
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        file = new File(FileExchangeTest.class.getResource(""FileExchangeTest.class"").getFile());
    }
}
"
org.apache.camel.component.file.FileFilterOnNameRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.builder.RouteBuilder;
/**
 * verify file name header is visible
 */
public class FileFilterOnNameRouteTest extends FileRouteTest {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // more natural
                from(uri).filter(header(FileComponent.HEADER_FILE_NAME).contains(""-"")).to(""mock:result"");
                // than
                //from(uri).filter(header(FileComponent.HEADER_FILE_NAME).matchesRegex("".*-.*"")).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileHeaderFileNameProducedTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test that tests that the header contains the absolute path to the filename it used.
 */
public class FileHeaderFileNameProducedTest extends ContextTestSupport {
    public void testHeaderFileNameProduced() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(1);
        // the absolute path to the file written should contain the target folder
        mock.message(0).header(FileComponent.HEADER_FILE_NAME_PRODUCED).contains(""target"");
        template.requestBodyAndHeader(""direct:in"", ""Hello World"", FileComponent.HEADER_FILE_NAME,
            ""FileHeaderFileNameProducedTest.txt"");
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:in"")
                    .to(""file://target/?append=false"")
                    .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileMEPInOutTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.converter.IOConverter;
/**
 * Unit test that we can produce files even for InOut MEP.
 */
public class FileMEPInOutTest extends ContextTestSupport {
    public void testMEPInOutTest() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(1);
        mock.expectedBodiesReceived(""Hello World"");
        // request is InOut
        template.requestBodyAndHeader(""direct:in"", ""Hello World"", FileComponent.HEADER_FILE_NAME,
            ""FileMEPInOutTest.txt"");
        // give Camel time to create the file
        Thread.sleep(1000);
        File file = new File(""target/FileMEPInOutTest.txt"");
        file = file.getAbsoluteFile();
        assertEquals(""Hello World"", IOConverter.toString(file));
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:in"")
                    .to(""file://target/?append=false"")
                    .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.impl.DefaultMessage;
/**
 * A {@link org.apache.camel.Message Message} for File
 *
 * @version $Revision: 659782 $
 */
public class FileMessage extends DefaultMessage {
    private File file;
    public FileMessage() {
        this(new File("".""));
    }
    public FileMessage(File file) {
        this.file = file;
    }
    @Override
    public String toString() {
        return ""FileMessage: "" + file;
    }
    @Override
    public FileExchange getExchange() {
        return (FileExchange)super.getExchange();
    }
    public File getFile() {
        return file;
    }
    public void setFile(File file) {
        this.file = file;
    }
    @Override
    public FileMessage newInstance() {
        return new FileMessage();
    }
    @Override
    protected Object createBody() {
        return file;
    }
}
"
org.apache.camel.component.file.FileNoOpLockFileTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.file.strategy.FileProcessStrategySupport;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test to verify that the noop file strategy usage of lock files.
 */
public class FileNoOpLockFileTest extends ContextTestSupport {
    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        deleteDirectory(""target/reports"");
    }
    public void testLocked() throws Exception {
        deleteDirectory(""target/reports"");
        MockEndpoint mock = getMockEndpoint(""mock:report"");
        mock.expectedBodiesReceived(""Hello Locked"");
        template.sendBodyAndHeader(""file:target/reports/locked"", ""Hello Locked"",
            FileComponent.HEADER_FILE_NAME, ""report.txt"");
        mock.assertIsSatisfied();
        // sleep to let file consumer do its unlocking
        Thread.sleep(200);
        // should be deleted after processing
        checkLockFile(false);
    }
    public void testNotLocked() throws Exception {
        deleteDirectory(""target/reports"");
        MockEndpoint mock = getMockEndpoint(""mock:report"");
        mock.expectedBodiesReceived(""Hello Not Locked"");
        template.sendBodyAndHeader(""file:target/reports/notlocked"", ""Hello Not Locked"",
            FileComponent.HEADER_FILE_NAME, ""report.txt"");
        mock.assertIsSatisfied();
        // sleep to let file consumer do its unlocking
        Thread.sleep(200);
        // no lock files should exists after processing
        checkLockFile(false);
    }
    private static void checkLockFile(boolean expected) {
        String filename = ""target/reports/"";
        filename += expected ? ""locked/"" : ""notlocked/"";
        filename += ""report.txt"" + FileProcessStrategySupport.DEFAULT_LOCK_FILE_POSTFIX;
        File file = new File(filename);
        assertEquals(""Lock file should "" + (expected ? ""exists"" : ""not exists""), expected, file.exists());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // for locks
                from(""file://target/reports/locked/?noop=true"").process(new MyNoopProcessor()).
                    to(""mock:report"");
                // for no locks
                from(""file://target/reports/notlocked/?noop=true&lock=false"").process(new MyNoopProcessor()).
                    to(""mock:report"");
            }
        };
    }
    private class MyNoopProcessor implements Processor {
        public void process(Exchange exchange) throws Exception {
            String body = exchange.getIn().getBody(String.class);
            boolean locked = ""Hello Locked"".equals(body);
            checkLockFile(locked);
        }
    }
}
"
org.apache.camel.component.file.FileNoOpRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
/**
 * @version $Revision: 630591 $
 */
public class FileNoOpRouteTest extends FileRouteTest {
    @Override
    protected void setUp() throws Exception {
        uri = ""file:target/test-noop-inbox?noop=true"";
        deleteDirectory(""target/test-noop-inbox"");
        super.setUp();
    }
}
"
org.apache.camel.component.file.FileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
/**
 * Represents a strategy for marking that a file is processed.
 *
 * @version $Revision: 647463 $
 */
public interface FileProcessStrategy {
    /**
     * Called when work is about to begin on this file. This method may attempt to acquire some file lock before
     * returning true; returning false if the file lock could not be obtained so that the file should be ignored.
     *
     * @param endpoint  the endpoint
     * @param exchange  the exchange
     * @param file      the file
     * @return true if the file can be processed (such as if a file lock could be obtained)
     * @throws Exception can be thrown in case of errors
     */
    boolean begin(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception;
    /**
     * Releases any file locks and possibly deletes or moves the file
     *
     * @param endpoint  the endpoint
     * @param exchange  the exchange
     * @param file      the file
     * @throws Exception can be thrown in case of errors
     */
    void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception;
}
"
org.apache.camel.component.file.FileProduceGeneratedFileNameTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
/**
 * Unit test that FileProducer can use message id as the filename.
 */
public class FileProduceGeneratedFileNameTest extends ContextTestSupport {
    public void testGeneratedFileName() throws Exception {
        Endpoint endpoint = context.getEndpoint(""direct:a"");
        FileEndpoint fileEndpoint = resolveMandatoryEndpoint(""file://target"", FileEndpoint.class);
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setBody(""Hello World"");
        String id = fileEndpoint.getGeneratedFileName(exchange.getIn());
        template.send(endpoint, exchange);
        File file = new File(""target/"" + id);
        // use absolute file to let unittest pass on all platforms
        file = file.getAbsoluteFile();
        assertEquals(""The generated file should exists: "" + file, true, file.exists());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:a"").to(""file://target"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.UuidGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * For producing files.
 *
 * @version $Revision: 676309 $
 */
public class FileProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(FileProducer.class);
    private FileEndpoint endpoint;
    public FileProducer(FileEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public FileEndpoint getEndpoint() {
        return (FileEndpoint) super.getEndpoint();
    }
    public void process(Exchange exchange) throws Exception {
        FileExchange fileExchange = endpoint.createExchange(exchange);
        process(fileExchange);
        ExchangeHelper.copyResults(exchange, fileExchange);
    }
    public void process(FileExchange exchange) throws Exception {
        InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        File file = createFileName(exchange.getIn());
        buildDirectory(file);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""About to write to: "" + file + "" from exchange: "" + exchange);
        }
        FileChannel fc = null;
        try {
            if (getEndpoint().isAppend()) {
                fc = new RandomAccessFile(file, ""rw"").getChannel();
                fc.position(fc.size());
            } else {
                fc = new FileOutputStream(file).getChannel();
            }
            int size = getEndpoint().getBufferSize();
            byte[] buffer = new byte[size];
            ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);
            while (true) {
                int count = in.read(buffer);
                if (count <= 0) {
                    break;
                } else if (count < size) {
                    byteBuffer = ByteBuffer.wrap(buffer, 0, count);
                    fc.write(byteBuffer);
                    break;
                } else {
                    fc.write(byteBuffer);
                    byteBuffer.clear();
                }
            }
        } finally {
            ObjectHelper.close(in, file.getName(), LOG);
            ObjectHelper.close(fc, file.getName(), LOG);
        }
    }
    protected File createFileName(Message message) {
        File answer;
        String name = null;
        if (!endpoint.isIgnoreFileNameHeader()) {
            name = message.getHeader(FileComponent.HEADER_FILE_NAME, String.class);
        }
        File endpointFile = endpoint.getFile();
        if (endpointFile.isDirectory()) {
            if (name != null) {
                answer = new File(endpointFile, name);
                if (answer.isDirectory()) {
                    answer = new File(answer, endpoint.getGeneratedFileName(message));
                }
            } else {
                answer = new File(endpointFile, endpoint.getGeneratedFileName(message));
            }
        } else {
            if (name == null) {
                answer = endpointFile;
            } else {
                answer = new File(endpointFile, name);
            }
        }
        // lets store the name we really used in the header, so end-users can retrieve it
        message.setHeader(FileComponent.HEADER_FILE_NAME_PRODUCED, answer.getAbsolutePath());
        return answer;
    }
    private void buildDirectory(File file) {
        String dirName = file.getAbsolutePath();
        int index = dirName.lastIndexOf(File.separatorChar);
        if (index > 0) {
            dirName = dirName.substring(0, index);
            File dir = new File(dirName);
            dir.mkdirs();
        }
    }
}
"
org.apache.camel.component.file.FileProducerRenameStrategyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.io.FileWriter;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.converter.IOConverter;
/**
 * Unit test for the FileRenameStrategy
 */
public class FileProducerRenameStrategyTest extends ContextTestSupport {
    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        deleteDirectory(""target/done"");
        deleteDirectory(""target/reports"");
    }
    public void testRenameSuccess() throws Exception {
        deleteDirectory(""target/done"");
        deleteDirectory(""target/reports"");
        MockEndpoint mock = getMockEndpoint(""mock:report"");
        mock.expectedBodiesReceived(""Hello Paris"");
        template.sendBodyAndHeader(""file:target/reports"", ""Hello Paris"", FileComponent.HEADER_FILE_NAME, ""paris.txt"");
        mock.assertIsSatisfied();
        // sleep to let the file consumer do its renaming
        Thread.sleep(500);
        // content of file should be Hello Paris
        String content = IOConverter.toString(new File(""./target/done/paris.txt""));
        assertEquals(""The file should have been renamed"", ""Hello Paris"", content);
    }
    public void testRenameFileExists() throws Exception {
        deleteDirectory(""target/done"");
        deleteDirectory(""target/reports"");
        // create a file in done to let there be a duplicate file
        File file = new File(""target/done"");
        file.mkdirs();
        FileWriter fw = new FileWriter(""./target/done/london.txt"");
        fw.write(""I was there once in London"");
        fw.flush();
        fw.close();
        MockEndpoint mock = getMockEndpoint(""mock:report"");
        mock.expectedBodiesReceived(""Hello London"");
        template.sendBodyAndHeader(""file:target/reports"", ""Hello London"", FileComponent.HEADER_FILE_NAME, ""london.txt"");
        mock.assertIsSatisfied();
        // sleep to let the file consumer do its renaming
        Thread.sleep(500);
        // content of file should be Hello London
        String content = IOConverter.toString(new File(""./target/done/london.txt""));
        assertEquals(""The file should have been renamed replacing any existing files"", ""Hello London"", content);
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""file://target/reports?moveNamePrefix=../done/&consumer.delay=5000"").to(""mock:report"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileRenameRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
/**
 * @version $Revision: 630591 $
 */
public class FileRenameRouteTest extends FileRouteTest {
    @Override
    protected void setUp() throws Exception {
        deleteDirectory(""target/test-rename-inbox"");
        uri = ""file:target/test-rename-inbox?moveNamePrefix=foo/"";
        super.setUp();
    }
}
"
org.apache.camel.component.file.FileRouteGenerateEmptyExchangeWhenIdleTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 643934 $
 */
public class FileRouteGenerateEmptyExchangeWhenIdleTest extends ContextTestSupport {
    protected Object expectedBody = ""Hello there!"";
    protected String uri = ""file:target/test-inbox2?consumer.generateEmptyExchangeWhenIdle=true"";
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedMinimumMessageCount(2);
        result.setResultWaitTime(5000);
        template.sendBodyAndHeader(uri, expectedBody, ""cheese"", 123);
        result.assertIsSatisfied();
        int fileCount = 0;
        int nullCount = 0;
        for (Exchange exchange : result.getReceivedExchanges()) {
            assertTrue(exchange instanceof FileExchange);
            FileExchange fx = (FileExchange)exchange;
            if (fx.getFile() == null) {
                nullCount++;
            } else {
                fileCount++;
            }
        }
        assertEquals(1, fileCount);
        assertTrue(nullCount > 0);
    }
    @Override
    protected void setUp() throws Exception {
        deleteDirectory(""target/test-inbox2"");
        super.setUp();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(uri).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 654441 $
 */
public class FileRouteTest extends ContextTestSupport {
    protected Object expectedBody = ""Hello there!"";
    protected String uri = ""file:target/test-default-inbox"";
    public void testFileRoute() throws Exception {
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedBodiesReceived(expectedBody);
        result.setResultWaitTime(5000);
        template.sendBodyAndHeader(uri, expectedBody, ""cheese"", 123);
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        deleteDirectory(""target/test-default-inbox"");
        super.setUp();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(uri).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FilerProducerFileNamesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
/**
 * Unit test for the how FileProducer behaves a bit strantegly when generating filenames
 */
public class FilerProducerFileNamesTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testProducerWithMessageIdAsFileName() throws Exception {
        Endpoint endpoint = context.getEndpoint(""direct:report"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setBody(""This is a good report"");
        FileEndpoint fileEndpoint = resolveMandatoryEndpoint(""file:target/reports/report.txt"", FileEndpoint.class);
        String id = fileEndpoint.getGeneratedFileName(exchange.getIn());
        template.send(""direct:report"", exchange);
        File file = new File(""target/reports/report.txt/"" + id);
        assertEquals(""File should exists"", true, file.exists());
    }
    public void testProducerWithConfiguedFileNameInEndpointURI() throws Exception {
        template.sendBody(""direct:report2"", ""This is another good report"");
        File file = new File(""target/report2.txt"");
        assertEquals(""File should exists"", true, file.exists());
    }
    public void testProducerWithHeaderFileName() throws Exception {
        template.sendBody(""direct:report3"", ""This is super good report"");
        File file = new File(""target/report-super.txt"");
        assertEquals(""File should exists"", true, file.exists());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:report"").to(""file:target/reports/report.txt"");
                from(""direct:report2"").to(""file:target/report2.txt?autoCreate=false"");
                from(""direct:report3"").setHeader(FileComponent.HEADER_FILE_NAME, ""report-super.txt"").to(""file:target/"");
            }
        };
    }
    // END SNIPPET: e1
}
"
org.apache.camel.component.file.MoveFilesToDirectoryTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 655296 $
 */
public class MoveFilesToDirectoryTest extends ContextTestSupport {
    protected String testDirectory = ""target/test/MoveFilesToDirectoryTest"";
    protected String inputDirectory = testDirectory + ""/input"";
    protected String outputDirectory = testDirectory + ""/output"";
    protected String fileName = ""foo.txt"";
    protected Object expectedBody = ""Hello there!"";
    protected boolean noop;
    public void testFileRoute() throws Exception {
        template.sendBodyAndHeader(""file:"" + inputDirectory, expectedBody, FileComponent.HEADER_FILE_NAME, fileName);
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedBodiesReceived(expectedBody);
        result.setResultWaitTime(5000);
        // now lets wait a bit and move that file
        Thread.sleep(5000);
        // lets delete the output directory
        deleteDirectory(outputDirectory);
        // now lets wait a bit for it to be polled
        Thread.sleep(5000);
        File file = new File(inputDirectory + ""/"" + fileName);
        File outDir = new File(outputDirectory);
        outDir.mkdirs();
        File newFile = new File(outDir, fileName);
        assertFileExists(file);
        assertFileNotExists(newFile);
        boolean answer = file.renameTo(newFile);
        assertTrue(""Move of file: "" + file + "" to "" + newFile + "" should have worked!"", answer);
        assertFileNotExists(file);
        assertFileExists(newFile);
        // now lets wait for multiple polls to check we only process it once
        Thread.sleep(5000);
        assertMockEndpointsSatisifed();
    }
    protected void assertFileNotExists(File file) {
        assertFalse(""File should not exist: "" + file, file.exists());
    }
    protected void assertFileExists(File file) {
        assertTrue(""File should exist: "" + file, file.exists());
    }
    @Override
    protected void setUp() throws Exception {
        deleteDirectory(testDirectory);
        super.setUp();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(getOutputEndpointUri()).to(""mock:result"");
            }
        };
    }
    protected String getOutputEndpointUri() {
        return ""file:"" + outputDirectory;
    }
}
"
org.apache.camel.component.file.MoveFilesToDirectoryWithNoopTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
/**
 * @version $Revision: 655401 $
 */
public class MoveFilesToDirectoryWithNoopTest extends MoveFilesToDirectoryTest {
    @Override
    protected String getOutputEndpointUri() {
        return super.getOutputEndpointUri() + ""?noop=true"";
    }
}
"
org.apache.camel.component.file.ToFileRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.JndiRegistry;
/**
 * For documentation how to write files using the FileProducer.
 */
public class ToFileRouteTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testToFile() throws Exception {
        template.sendBody(""seda:reports"", ""This is a great report"");
        // give time for the file to be written before assertions
        Thread.sleep(1000);
        // assert the file exists
        File file = new File(""target/test-reports/report.txt"");
        file = file.getAbsoluteFile();
        assertTrue(""The file should have been written"", file.exists());
    }
    protected JndiRegistry createRegistry() throws Exception {
        // bind our processor in the registry with the given id
        JndiRegistry reg = super.createRegistry();
        reg.bind(""processReport"", new ProcessReport());
        return reg;
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // the reports from the seda queue is processed by our processor
                // before they are written to files in the target/reports directory
                from(""seda:reports"").processRef(""processReport"").to(""file://target/test-reports"");
            }
        };
    }
    private class ProcessReport implements Processor {
        public void process(Exchange exchange) throws Exception {
            String body = exchange.getIn().getBody(String.class);
            // do some business logic here
            // set the output to the file
            exchange.getOut().setBody(body);
            // set the output filename using java code logic, notice that this is done by setting
            // a special header property of the out exchange
            exchange.getOut().setHeader(FileComponent.HEADER_FILE_NAME, ""report.txt"");
        }
    }
    // END SNIPPET: e1
}
"
org.apache.camel.component.file.strategy.DefaultFileRenamer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
/**
 * Camel default file renamer.
 *
 * @version $Revision: 647463 $
 */
public class DefaultFileRenamer implements FileRenamer {
    private static final boolean ON_WINDOWS = System.getProperty(""os.name"").startsWith(""Windows"");
    private String namePrefix;
    private String namePostfix;
    public DefaultFileRenamer() {
    }
    public DefaultFileRenamer(String namePrefix, String namePostfix) {
        this.namePrefix = namePrefix;
        this.namePostfix = namePostfix;
    }
    public File renameFile(File file) {
        File parent = file.getParentFile();
        String name = renameFileName(file);
        if (ON_WINDOWS && (name.indexOf("":"") >= 0 || name.startsWith(""//""))) {
            return new File(name);
        }
        return new File(parent, name);
    }
    public String getNamePostfix() {
        return namePostfix;
    }
    /**
     * Sets the name postfix appended to moved files. For example
     * to rename all the files from * to *.done set this value to "".done""
     */
    public void setNamePostfix(String namePostfix) {
        this.namePostfix = namePostfix;
    }
    public String getNamePrefix() {
        return namePrefix;
    }
    /**
     * Sets the name prefix appended to moved files. For example
     * to move processed files into a hidden directory called "".camel""
     * set this value to "".camel/""
     */
    public void setNamePrefix(String namePrefix) {
        this.namePrefix = namePrefix;
    }
    protected String renameFileName(File file) {
        StringBuffer buffer = new StringBuffer();
        if (namePrefix != null) {
            buffer.append(namePrefix);
        }
        buffer.append(file.getName());
        if (namePostfix != null) {
            buffer.append(namePostfix);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.component.file.strategy.DeleteFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A strategy which will delete the file when its processed
 *
 * @version $Revision: 660099 $
 */
public class DeleteFileProcessStrategy extends FileProcessStrategySupport {
    private static final transient Log LOG = LogFactory.getLog(DeleteFileProcessStrategy.class);
    public DeleteFileProcessStrategy() {
    }
    public DeleteFileProcessStrategy(boolean lockFile) {
        super(lockFile);
    }
    @Override
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Deleting file: "" + file);
        }
        boolean deleted = file.delete();
        if (!deleted) {
            LOG.warn(""Could not delete file: "" + file);
        }
        // must commit to release the lock
        super.commit(endpoint, exchange, file);
    }
}
"
org.apache.camel.component.file.strategy.FileProcessStrategyFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.util.Properties;
import org.apache.camel.component.file.FileProcessStrategy;
/**
 * Factory to provide the {@link org.apache.camel.component.file.FileProcessStrategy} to use.
 */
public final class FileProcessStrategyFactory {
    private FileProcessStrategyFactory() {
        // Factory class
    }
    /**
     * A strategy method to lazily create the file strategy to use.
     */
    public static FileProcessStrategy createFileProcessStrategy(Properties params) {
        // We assume a value is present only if its value not null for String and 'true' for boolean
        boolean isDelete = params.getProperty(""delete"") != null;
        boolean isLock = params.getProperty(""lock"") != null;
        String moveNamePrefix = params.getProperty(""moveNamePrefix"");
        String moveNamePostfix = params.getProperty(""moveNamePostfix"");
        if (params.getProperty(""noop"") != null) {
            return new NoOpFileProcessStrategy(isLock);
        } else if (moveNamePostfix != null || moveNamePrefix != null) {
            if (isDelete) {
                throw new IllegalArgumentException(""You cannot set the deleteFiles property ""
                    + ""and a moveFilenamePostfix or moveFilenamePrefix"");
            }
            return new RenameFileProcessStrategy(isLock, moveNamePrefix, moveNamePostfix);
        } else if (isDelete) {
            return new DeleteFileProcessStrategy(isLock);
        } else {
            return new RenameFileProcessStrategy(isLock);
        }
    }
}
"
org.apache.camel.component.file.strategy.FileProcessStrategySupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import java.io.RandomAccessFile;
import java.nio.channels.Channel;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.camel.component.file.FileProcessStrategy;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Base class for {@link org.apache.camel.component.file.FileProcessStrategy} implementation to extend.
 *
 * @version $Revision: 647463 $
 */
public abstract class FileProcessStrategySupport implements FileProcessStrategy {
    public static final String DEFAULT_LOCK_FILE_POSTFIX = "".cameLock"";
    private static final transient Log LOG = LogFactory.getLog(FileProcessStrategySupport.class);
    private boolean lockFile;
    private FileRenamer lockFileRenamer;
    protected FileProcessStrategySupport() {
        this(true);
    }
    protected FileProcessStrategySupport(boolean lockFile) {
        this(lockFile, new DefaultFileRenamer(null, DEFAULT_LOCK_FILE_POSTFIX));
    }
    protected FileProcessStrategySupport(boolean lockFile, FileRenamer lockFileRenamer) {
        this.lockFile = lockFile;
        this.lockFileRenamer = lockFileRenamer;
    }
    public boolean begin(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (isLockFile()) {
            File newFile = lockFileRenamer.renameFile(file);
            String lockFileName = newFile.getAbsolutePath();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Locking the file: "" + file + "" using the lock file name: "" + lockFileName);
            }
            FileChannel channel = new RandomAccessFile(lockFileName, ""rw"").getChannel();
            FileLock lock = channel.lock();
            if (lock != null) {
                exchange.setProperty(""org.apache.camel.fileChannel"", channel);
                exchange.setProperty(""org.apache.camel.file.lock"", lock);
                exchange.setProperty(""org.apache.camel.file.lock.name"", lockFileName);
                return true;
            }
            return false;
        }
        return true;
    }
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (isLockFile()) {
            Channel channel = ExchangeHelper.getMandatoryProperty(exchange, ""org.apache.camel.fileChannel"", Channel.class);
            String lockfile = ExchangeHelper.getMandatoryProperty(exchange, ""org.apache.camel.file.lock.name"", String.class);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Unlocking file: "" + file);
            }
            channel.close();
            File lock = new File(lockfile);
            lock.delete();
        }
    }
    public boolean isLockFile() {
        return lockFile;
    }
    public void setLockFile(boolean lockFile) {
        this.lockFile = lockFile;
    }
    public FileRenamer getLockFileRenamer() {
        return lockFileRenamer;
    }
    public void setLockFileRenamer(FileRenamer lockFileRenamer) {
        this.lockFileRenamer = lockFileRenamer;
    }
}
"
org.apache.camel.component.file.strategy.FileRenamer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
/**
 * Used for renaming files.
 *
 * @version $Revision: 647463 $
 */
public interface FileRenamer {
    /**
     * Renames the given file
     *
     * @param file  the original file.
     * @return  the renamed file.
     */
    File renameFile(File file);
}
"
org.apache.camel.component.file.strategy.NoOpFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
/**
 * A simple strategy which does not move or delete the processed files in any way.
 *
 * @version $Revision: 660102 $
 */
public class NoOpFileProcessStrategy extends FileProcessStrategySupport {
    public NoOpFileProcessStrategy() {
        super(true);
    }
    public NoOpFileProcessStrategy(boolean isLock) {
        super(isLock);
    }
}
"
org.apache.camel.component.file.strategy.RenameFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A strategy to rename a file
 * 
 * @version $Revision: 660099 $
 */
public class RenameFileProcessStrategy extends FileProcessStrategySupport {
    private static final transient Log LOG = LogFactory.getLog(RenameFileProcessStrategy.class);
    private FileRenamer renamer;
    public RenameFileProcessStrategy() {
        this(true);
    }
    public RenameFileProcessStrategy(boolean lock) {
        this(lock, "".camel/"", """");
    }
    public RenameFileProcessStrategy(boolean lock, String namePrefix, String namePostfix) {
        this(lock, new DefaultFileRenamer(namePrefix, namePostfix));
    }
    public RenameFileProcessStrategy(boolean lock, FileRenamer renamer) {
        super(lock);
        this.renamer = renamer;
    }
    @Override
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        File newName = renamer.renameFile(file);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Renaming file: "" + file + "" to: "" + newName);
        }
        // deleting any existing files before renaming
        if (newName.exists()) {
            newName.delete();
        }
        // make parent folder if missing
        newName.getParentFile().mkdirs();
        boolean renamed = file.renameTo(newName);
        if (!renamed) {
            LOG.warn(""Could not rename file from: "" + file + "" to "" + newName);
        }
        // must commit to release the lock
        super.commit(endpoint, exchange, file);
    }
    public FileRenamer getRenamer() {
        return renamer;
    }
    public void setRenamer(FileRenamer renamer) {
        this.renamer = renamer;
    }
}
"
org.apache.camel.component.jmx.JMXComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import java.util.Map;
import javax.management.MBeanServer;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * The <a href=""http://activemq.apache.org/camel/jmx.html"">JMX Component</a>
 * for monitoring JMX attributes
 *
 * @version $Revision: 659782 $
 */
public class JMXComponent extends DefaultComponent<JMXExchange> {
    private MBeanServer mbeanServer;
    public JMXComponent() {
    }
    public JMXComponent(CamelContext context) {
        super(context);
    }
    protected Endpoint<JMXExchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        JMXEndpoint result = new JMXEndpoint(remaining, this);
        setProperties(result, parameters);
        result.setMbeanServer(getMbeanServer());
        return result;
    }
    public MBeanServer getMbeanServer() {
        return mbeanServer;
    }
    public void setMbeanServer(MBeanServer mbeanServer) {
        this.mbeanServer = mbeanServer;
    }
}
"
org.apache.camel.component.jmx.JMXConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import javax.management.NotificationListener;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * Creates an JMXExchange after getting a JMX Notification
 * 
 * @version $Revision: 660275 $
 */
public class JMXConsumer extends DefaultConsumer implements NotificationListener {
    private JMXEndpoint jmxEndpoint;
    public JMXConsumer(JMXEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.jmxEndpoint = endpoint;
    }
    public void handleNotification(Notification notification, Object handback) {
        try {
            getProcessor().process(jmxEndpoint.createExchange(notification));
        } catch (Throwable e) {
            handleException(e);
        }
    }
}
"
org.apache.camel.component.jmx.JMXEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.MBeanServer;
import javax.management.Notification;
import javax.management.ObjectName;
import javax.management.monitor.CounterMonitor;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * JMXEndpoint for monitoring JMX attributs using {@link CounterMonitor}.
 *
 * @version $Revision: 660275 $
 */
public class JMXEndpoint extends DefaultEndpoint<JMXExchange> {
    private static final transient Log LOG = LogFactory.getLog(JMXEndpoint.class);
    private String name;
    private ObjectName ourName;
    private String observedObjectName;
    private String attributeName;
    private long granularityPeriod = 5000;
    private Number threshold;
    private Number offset;
    private MBeanServer mbeanServer;
    private CounterMonitor counterMonitor = new CounterMonitor();
    protected JMXEndpoint(String endpointUri, JMXComponent component) {
        super(endpointUri, component);
        observedObjectName = endpointUri;
    }
    public JMXEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<JMXExchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""Producer not supported"");
    }
    public Consumer<JMXExchange> createConsumer(Processor proc) throws Exception {
        ObjectName observedName = new ObjectName(observedObjectName);
        if (name == null) {
            String type = observedName.getKeyProperty(""type"");
            type = type != null ? type : ""UNKNOWN"";
            name = mbeanServer.getDefaultDomain() + "":type=CounterMonitor_"" + type;
        }
        JMXConsumer result = new JMXConsumer(this, proc);
        ourName = new ObjectName(name);
        counterMonitor.setNotify(true);
        counterMonitor.addObservedObject(observedName);
        counterMonitor.setObservedAttribute(attributeName);
        counterMonitor.setGranularityPeriod(granularityPeriod);
        counterMonitor.setDifferenceMode(false);
        counterMonitor.setInitThreshold(threshold);
        counterMonitor.setOffset(offset);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Registering and adding notification listener for ["" + counterMonitor + ""] with name ["" + ourName + ""]"");
        }
        mbeanServer.registerMBean(counterMonitor, ourName);
        // TODO: How do we remove the listener?
        mbeanServer.addNotificationListener(ourName, result, null, new Object());
        return result;
    }
    public boolean isSingleton() {
        return true;
    }
    public JMXExchange createExchange(Notification notification) {
        return new JMXExchange(getCamelContext(), getExchangePattern(), notification);
    }
    public JMXExchange createExchange() {
        return new JMXExchange(getCamelContext(), getExchangePattern(), null);
    }
    public JMXExchange createExchange(ExchangePattern pattern) {
        return new JMXExchange(getCamelContext(), pattern, null);
    }
    public String getAttributeName() {
        return attributeName;
    }
    public void setAttributeName(String attributeName) {
        this.attributeName = attributeName;
    }
    public long getGranularityPeriod() {
        return granularityPeriod;
    }
    public void setGranularityPeriod(long granularityPeriod) {
        this.granularityPeriod = granularityPeriod;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Number getOffset() {
        return offset;
    }
    public void setOffset(Number offset) {
        this.offset = offset;
    }
    public Number getThreshold() {
        return threshold;
    }
    public void setThreshold(Number threshold) {
        this.threshold = threshold;
    }
    public MBeanServer getMbeanServer() {
        return mbeanServer;
    }
    public void setMbeanServer(MBeanServer mbeanServer) {
        this.mbeanServer = mbeanServer;
    }
}
"
org.apache.camel.component.jmx.JMXExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * A {@link Exchange} for JMX notification
 *
 * @version $Revision: 659782 $
 */
public class JMXExchange extends DefaultExchange {
    public JMXExchange(CamelContext camelContext, ExchangePattern pattern, Notification notification) {
        super(camelContext, pattern);
        setIn(new JMXMessage(notification));
    }
}
"
org.apache.camel.component.jmx.JMXMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import org.apache.camel.impl.DefaultMessage;
/**
 * A {@link org.apache.camel.Message Message} for a JMX Notification
 * 
 * @version $Revision: 642753 $
 */
public class JMXMessage extends DefaultMessage {
    private Notification notification;
    public JMXMessage() {
        this(null);
    }
    public JMXMessage(Notification notification) {
        this.notification = notification;
    }
    @Override
    public String toString() {
        return ""JMXMessage: "" + notification;
    }
    @Override
    public JMXExchange getExchange() {
        return (JMXExchange)super.getExchange();
    }
    @Override
    public JMXMessage newInstance() {
        return new JMXMessage();
    }
    public Notification getNotification() {
        return notification;
    }
}
"
org.apache.camel.component.list.ListComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.list;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * The <a href=""http://activemq.apache.org/camel/list.html"">List</a> component.
 *
 * @version $Revision: 659782 $
 */
public class ListComponent extends DefaultComponent {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new ListEndpoint(uri, this);
    }
}
"
org.apache.camel.component.list.ListEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.list;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.processor.loadbalancer.LoadBalancerConsumer;
import org.apache.camel.processor.loadbalancer.TopicLoadBalancer;
import org.apache.camel.spi.BrowsableEndpoint;
/**
 * An endpoint which maintains a {@link List} of {@link Exchange} instances
 * which can be useful for tooling, debugging and visualising routes.
 *
 * @version $Revision: 659782 $
 */
public class ListEndpoint extends DefaultEndpoint<Exchange> implements BrowsableEndpoint<Exchange> {
    private List<Exchange> exchanges;
    private TopicLoadBalancer loadBalancer = new TopicLoadBalancer();
    private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
    public ListEndpoint(String uri, CamelContext camelContext) {
        super(uri, camelContext);
        reset();
    }
    public ListEndpoint(String uri, Component component) {
        super(uri, component);
        reset();
    }
    public ListEndpoint(String endpointUri) {
        super(endpointUri);
        reset();
    }
    public boolean isSingleton() {
        return true;
    }
    public List<Exchange> getExchanges() {
        return exchanges;
    }
    public TopicLoadBalancer getLoadBalancer() {
        return loadBalancer;
    }
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.addPropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.removePropertyChangeListener(listener);
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new LoadBalancerConsumer(this, processor, loadBalancer);
    }
    public void reset() {
        exchanges = createExchangeList();
    }
    protected List<Exchange> createExchangeList() {
        return new CopyOnWriteArrayList<Exchange>();
    }
    /**
     * Invoked on a message exchange being sent by a producer
     */
    protected void onExchange(Exchange exchange) throws Exception {
        exchanges.add(exchange);
        // lets fire any consumers
        loadBalancer.process(exchange);
    }
}
"
org.apache.camel.component.list.ListTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.list;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.camel.util.CamelContextHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class ListTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(ListTest.class);
    protected Object body1 = ""one"";
    protected Object body2 = ""two"";
    public void testListEndpoints() throws Exception {
        template.sendBody(""list:foo"", body1);
        template.sendBody(""list:foo"", body2);
        List<BrowsableEndpoint> list = CamelContextHelper.getSingletonEndpoints(context, BrowsableEndpoint.class);
        assertEquals(""number of endpoints"", 2, list.size());
        Thread.sleep(2000);
        for (BrowsableEndpoint endpoint : list) {
            List<Exchange> exchanges = endpoint.getExchanges();
            LOG.debug("">>>> "" + endpoint + "" has: "" + exchanges);
            assertEquals(""Exchanges received on "" + endpoint, 2, exchanges.size());
            assertInMessageBodyEquals(exchanges.get(0), body1);
            assertInMessageBodyEquals(exchanges.get(1), body2);
        }
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""list:foo"").to(""list:bar"");
            }
        };
    }
}
"
org.apache.camel.component.log.LogComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.processor.ThroughputLogger;
/**
 * The <a href=""http://activemq.apache.org/camel/log.html"">Log Component</a>
 * to log message exchanges to the underlying logging mechanism.
 * 
 * @version $Revision: 676850 $
 */
public class LogComponent extends DefaultComponent<Exchange> {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        LoggingLevel level = getLoggingLevel(parameters);
        Integer groupSize = getAndRemoveParameter(parameters, ""groupSize"", Integer.class);
        Logger logger;
        if (groupSize != null) {
            logger = new ThroughputLogger(remaining, level, ObjectConverter.toInteger(groupSize));
        } else {
            LogFormatter formatter = new LogFormatter();
            IntrospectionSupport.setProperties(formatter, parameters);
            logger = new Logger(remaining);
            logger.setLevel(level);
            logger.setFormatter(formatter);
        }
        return new ProcessorEndpoint(uri, this, logger);
    }
    /**
     * Gets the logging level, will default to use INFO if no level parameter provided.
     */
    protected LoggingLevel getLoggingLevel(Map parameters) {
        String levelText = getAndRemoveParameter(parameters, ""level"", String.class, ""INFO"");
        return LoggingLevel.valueOf(levelText.toUpperCase());
    }
}
"
org.apache.camel.component.log.LogFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import org.apache.camel.processor.interceptor.ExchangeFormatter;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.util.ObjectHelper;
/**
 * Log formatter to format the logging output.
 */
public class LogFormatter implements ExchangeFormatter {
    private boolean showExchangeId;
    private boolean showProperties;
    private boolean showHeaders;
    private boolean showBodyType = true;
    private boolean showBody = true;
    private boolean showOut;
    private boolean showAll;
    private boolean multiline;
    public Object format(Exchange exchange) {
        Message in = exchange.getIn();
        StringBuilder sb = new StringBuilder("""");
        if (showAll || showExchangeId) {
            if (multiline) sb.append('\n');
            sb.append("", Id:"").append(exchange.getExchangeId());
        }
        if (showAll || showProperties) {
            if (multiline) sb.append('\n');
            sb.append("", Properties:"").append(exchange.getProperties());
        }
        if (showAll || showHeaders) {
            if (multiline) sb.append('\n');
            sb.append("", Headers:"").append(in.getHeaders());
        }
        if (showAll || showBodyType) {
            if (multiline) sb.append('\n');
            sb.append("", BodyType:"").append(getBodyTypeAsString(in));
        }
        if (showAll || showBody) {
            if (multiline) sb.append('\n');
            sb.append("", Body:"").append(getBodyAsString(in));
        }
        Message out = exchange.getOut(false);
        if (showAll || showOut) {
            if (out != null) {
                if (showAll || showHeaders) {
                    if (multiline) sb.append('\n');
                    sb.append("", OutHeaders:"").append(out.getHeaders());
                }
                if (showAll || showBodyType) {
                    if (multiline) sb.append('\n');
                    sb.append("", OutBodyType:"").append(getBodyTypeAsString(out));
                }
                if (showAll || showBody) {
                    if (multiline) sb.append('\n');
                    sb.append("", OutBody:"").append(getBodyAsString(out));
                }
            } else {
                if (multiline) sb.append('\n');
                sb.append("", Out: null"");
            }
        }
        // get rid of the leading space comma if needed
        return ""Exchange["" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + ""]"");
    }
    public boolean isShowExchangeId() {
        return showExchangeId;
    }
    public void setShowExchangeId(boolean showExchangeId) {
        this.showExchangeId = showExchangeId;
    }
    public boolean isShowProperties() {
        return showProperties;
    }
    public void setShowProperties(boolean showProperties) {
        this.showProperties = showProperties;
    }
    public boolean isShowHeaders() {
        return showHeaders;
    }
    public void setShowHeaders(boolean showHeaders) {
        this.showHeaders = showHeaders;
    }
    public boolean isShowBodyType() {
        return showBodyType;
    }
    public void setShowBodyType(boolean showBodyType) {
        this.showBodyType = showBodyType;
    }
    public boolean isShowBody() {
        return showBody;
    }
    public void setShowBody(boolean showBody) {
        this.showBody = showBody;
    }
    public boolean isShowOut() {
        return showOut;
    }
    public void setShowOut(boolean showOut) {
        this.showOut = showOut;
    }
    public boolean isShowAll() {
        return showAll;
    }
    public void setShowAll(boolean showAll) {
        this.showAll = showAll;
    }
    public boolean isMultiline() {
        return multiline;
    }
    /**
     * If enabled then each information is outputted on a newline.
     */
    public void setMultiline(boolean multiline) {
        this.multiline = multiline;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected Object getBodyAsString(Message message) {
        Object answer = message.getBody(String.class);
        if (answer == null) {
            answer = message.getBody();
        }
        return answer;
    }
    protected Object getBodyTypeAsString(Message message) {
        String answer = ObjectHelper.className(message.getBody());
        if (answer.startsWith(""java.lang."")) {
            return answer.substring(10);
        }
        return answer;
    }
}
"
org.apache.camel.component.log.LogFormatterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
/**
 * Log formatter test.
 */
public class LogFormatterTest extends ContextTestSupport {
    public void testSendMessageToLogDefault() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST"", ""Hello World"");
    }
    public void testSendMessageToLogSingleOptions() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?showExchangeId=true"", ""Hello World"");
        template.sendBody(""log:org.apache.camel.TEST?showProperties=true"", ""Hello World"");
        template.sendBody(""log:org.apache.camel.TEST?showHeaders=true"", ""Hello World"");
        template.sendBody(""log:org.apache.camel.TEST?showBodyType=true"", ""Hello World"");
        template.sendBody(""log:org.apache.camel.TEST?showBody=true"", ""Hello World"");
        template.sendBody(""log:org.apache.camel.TEST?showOut=true"", ""Hello World"");
        template.sendBody(""log:org.apache.camel.TEST?showAll=true"", ""Hello World"");
    }
    public void testSendMessageToLogMultiOptions() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?showHeaders=true&showOut=true"", ""Hello World"");
        template.sendBody(""log:org.apache.camel.TEST?showProperties=true&showHeaders=true&showOut=true"", ""Hello World"");
    }
    public void testSendMessageToLogShowFalse() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?showBodyType=false"", ""Hello World"");
    }
    public void testSendMessageToLogMultiLine() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?multiline=true"", ""Hello World"");
    }
    public void testSendExchangeWithOut() throws Exception {
        Endpoint endpoint = resolveMandatoryEndpoint(""log:org.apache.camel.TEST?showAll=true&multiline=true"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setBody(""Hello World"");
        exchange.getOut().setBody(22);
        Producer producer = endpoint.createProducer();
        producer.start();
        producer.process(exchange);
        producer.stop();
    }
}
"
org.apache.camel.component.log.LogRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import org.apache.camel.ContextTestSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 630591 $
 */
public class LogRouteTest extends ContextTestSupport {
    private static final Log LOG = LogFactory.getLog(LogRouteTest.class);
    public void testSendMessageToLog() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST"", ""<level>default</level>"");
    }
    public void testSendMessageToInfoLog() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?level=INFO"", ""<level>INFO</level>"");
    }
    public void testSendMessageToWarnLog() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?level=warn"", ""<level>WARN</level>"");
    }
    public void testSendMessageToBadLevel() throws Exception {
        try {
            template.sendBody(""log:org.apache.camel.TEST?level=noSuchLevel"", ""<level>noSuchLevel</level>"");
            fail(""Shoudl have failed!"");
        } catch (Exception e) {
            LOG.debug(""Caught expected exception: "" + e, e);
        }
    }
}
"
org.apache.camel.component.mock.AssertionClause,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.builder.ValueBuilder;
import static org.apache.camel.builder.ExpressionBuilder.bodyExpression;
import static org.apache.camel.builder.ExpressionBuilder.headerExpression;
/**
 * A builder of assertions on message exchanges
 *
 * @version $Revision: 644162 $
 */
public abstract class AssertionClause implements Runnable {
    private List<Predicate<Exchange>> predicates = new ArrayList<Predicate<Exchange>>();
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Adds the given predicate to this assertion clause
     */
    public AssertionClause predicate(Predicate<Exchange> predicate) {
        addPredicate(predicate);
        return this;
    }
    public ExpressionClause<AssertionClause> predicate() {
        ExpressionClause<AssertionClause> clause = new ExpressionClause<AssertionClause>(this);
        addPredicate(clause);
        return clause;
    }
    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    public ValueBuilder<Exchange> header(String name) {
        Expression<Exchange> expression = headerExpression(name);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public PredicateValueBuilder body() {
        Expression<Exchange> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> PredicateValueBuilder bodyAs(Class<T> type) {
        Expression<Exchange> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public PredicateValueBuilder outBody() {
        Expression<Exchange> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> PredicateValueBuilder outBody(Class<T> type) {
        Expression<Exchange> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Performs any assertions on the given exchange
     */
    protected void applyAssertionOn(MockEndpoint endpoint, int index, Exchange exchange) {
        for (Predicate<Exchange> predicate : predicates) {
            predicate.assertMatches(endpoint.getEndpointUri() + "" "", exchange);
        }
    }
    protected void addPredicate(Predicate<Exchange> predicate) {
        predicates.add(predicate);
    }
    public class PredicateValueBuilder extends ValueBuilder<Exchange> {
        public PredicateValueBuilder(Expression<Exchange> expression) {
            super(expression);
        }
        protected Predicate<Exchange> onNewPredicate(Predicate<Exchange> predicate) {
            addPredicate(predicate);
            return predicate;
        }
    }
}
"
org.apache.camel.component.mock.MockComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.processor.ThroughputLogger;
/**
 * A factory of {@link MockEndpoint} instances
 *
 * @version $Revision: 655440 $
 */
public class MockComponent extends DefaultComponent<Exchange> {
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        MockEndpoint endpoint = new MockEndpoint(uri, this);
        Integer value = getAndRemoveParameter(parameters, ""reportGroup"", Integer.class);
        if (value != null) {
            Processor reporter = new ThroughputLogger(""org.apache.camel.mock:"" + remaining, value);
            endpoint.setReporter(reporter);
        }
        return endpoint;
    }
}
"
org.apache.camel.component.mock.MockEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ExpressionComparator;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A Mock endpoint which provides a literate, fluent API for testing routes
 * using a <a href=""http://jmock.org/"">JMock style</a> API.
 *
 * @version $Revision: 674383 $
 */
public class MockEndpoint extends DefaultEndpoint<Exchange> implements BrowsableEndpoint<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(MockEndpoint.class);
    private int expectedCount;
    private int counter;
    private Processor defaultProcessor;
    private Map<Integer, Processor> processors;
    private List<Exchange> receivedExchanges;
    private List<Throwable> failures;
    private List<Runnable> tests;
    private CountDownLatch latch;
    private long sleepForEmptyTest;
    private long resultWaitTime;
    private int expectedMinimumCount;
    private List expectedBodyValues;
    private List actualBodyValues;
    private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
    private String headerName;
    private String headerValue;
    private Object actualHeader;
    private Processor reporter;
    public MockEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
        init();
    }
    public MockEndpoint(String endpointUri) {
        super(endpointUri);
        init();
    }
    /**
     * A helper method to resolve the mock endpoint of the given URI on the given context
     *
     * @param context the camel context to try resolve the mock endpoint from
     * @param uri the uri of the endpoint to resolve
     * @return the endpoint
     */
    public static MockEndpoint resolve(CamelContext context, String uri) {
        return CamelContextHelper.getMandatoryEndpoint(context, uri, MockEndpoint.class);
    }
    public static void assertWait(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
        long start = System.currentTimeMillis();
        long left = unit.toMillis(timeout);
        long end = start + left;
        for (MockEndpoint endpoint : endpoints) {
            if (!endpoint.await(left, TimeUnit.MILLISECONDS)) {
                throw new AssertionError(""Timeout waiting for endpoints to receive enough messages. "" + endpoint.getEndpointUri() + "" timed out."");
            }
            left = end - System.currentTimeMillis();
            if (left <= 0) {
                left = 0;
            }
        }
    }
    public static void assertIsSatisfied(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
        assertWait(timeout, unit, endpoints);
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }
    public static void assertIsSatisfied(MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }
    /**
     * Asserts that all the expectations on any {@link MockEndpoint} instances registered
     * in the given context are valid
     *
     * @param context the camel context used to find all the available endpoints to be asserted
     */
    public static void assertIsSatisfied(CamelContext context) throws InterruptedException {
        ObjectHelper.notNull(context, ""camelContext"");
        Collection<Endpoint> endpoints = context.getSingletonEndpoints();
        for (Endpoint endpoint : endpoints) {
            if (endpoint instanceof MockEndpoint) {
                MockEndpoint mockEndpoint = (MockEndpoint) endpoint;
                mockEndpoint.assertIsSatisfied();
            }
        }
    }
    public static void expectsMessageCount(int count, MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            MockEndpoint.expectsMessageCount(count);
        }
    }
    public List<Exchange> getExchanges() {
        return getReceivedExchanges();
    }
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.addPropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.removePropertyChangeListener(listener);
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        throw new UnsupportedOperationException(""You cannot consume from this endpoint"");
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) {
                onExchange(exchange);
            }
        };
    }
    public void reset() {
        init();
    }
    // Testing API
    // -------------------------------------------------------------------------
    /**
     * Set the processor that will be invoked when the index
     * message is received.
     *
     * @param index
     * @param processor
     */
    public void whenExchangeReceived(int index, Processor processor) {
        this.processors.put(index, processor);
    }
    /**
     * Set the processor that will be invoked when the some message
     * is received.
     *
     * This processor could be overwritten by
     * {@link #whenExchangeReceived(int, Processor)} method.
     *
     * @param processor
     */
    public void whenAnyExchangeReceived(Processor processor) {
        this.defaultProcessor = processor;
    }
    /**
     * Validates that all the available expectations on this endpoint are
     * satisfied; or throw an exception
     */
    public void assertIsSatisfied() throws InterruptedException {
        assertIsSatisfied(sleepForEmptyTest);
    }
    /**
     * Validates that all the available expectations on this endpoint are
     * satisfied; or throw an exception
     *
     * @param timeoutForEmptyEndpoints the timeout in milliseconds that we
     *                should wait for the test to be true
     */
    public void assertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {
        LOG.info(""Asserting: "" + this + "" is satisfied"");
        if (expectedCount >= 0) {
            if (expectedCount != getReceivedCounter()) {
                if (expectedCount == 0) {
                    // lets wait a little bit just in case
                    if (timeoutForEmptyEndpoints > 0) {
                        LOG.debug(""Sleeping for: "" + timeoutForEmptyEndpoints + "" millis to check there really are no messages received"");
                        Thread.sleep(timeoutForEmptyEndpoints);
                    }
                } else {
                    waitForCompleteLatch();
                }
            }
            assertEquals(""Received message count"", expectedCount, getReceivedCounter());
        } else if (expectedMinimumCount > 0 && getReceivedCounter() < expectedMinimumCount) {
            waitForCompleteLatch();
        }
        if (expectedMinimumCount >= 0) {
            int receivedCounter = getReceivedCounter();
            assertTrue(""Received message count "" + receivedCounter + "", expected at least "" + expectedCount, expectedCount <= receivedCounter);
        }
        for (Runnable test : tests) {
            test.run();
        }
        for (Throwable failure : failures) {
            if (failure != null) {
                LOG.error(""Caught on "" + getEndpointUri() + "" Exception: "" + failure, failure);
                fail(""Failed due to caught exception: "" + failure);
            }
        }
    }
    /**
     * Validates that the assertions fail on this endpoint
     */
    public void assertIsNotSatisfied() throws InterruptedException {
        try {
            assertIsSatisfied();
            fail(""Expected assertion failure!"");
        } catch (AssertionError e) {
            LOG.info(""Caught expected failure: "" + e);
        }
    }
    /**
     * Specifies the expected number of message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void expectedMessageCount(int expectedCount) {
        setExpectedMessageCount(expectedCount);
    }
    /**
     * Specifies the minimum number of expected message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void expectedMinimumMessageCount(int expectedCount) {
        setMinimumExpectedMessageCount(expectedCount);
    }
    /**
     * Adds an expectation that the given header name & value are received by this
     * endpoint
     */
    public void expectedHeaderReceived(String name, String value) {
        this.headerName = name;
        this.headerValue = value;
        expects(new Runnable() {
            public void run() {
                assertTrue(""No header with name "" + headerName + "" found."", actualHeader != null);
                assertEquals(""Header of message"", headerValue, actualHeader);
            }
        });
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint
     */
    public void expectedBodiesReceived(final List bodies) {
        expectedMessageCount(bodies.size());
        this.expectedBodyValues = bodies;
        this.actualBodyValues = new ArrayList();
        expects(new Runnable() {
            public void run() {
                for (int i = 0; i < expectedBodyValues.size(); i++) {
                    Exchange exchange = getReceivedExchanges().get(i);
                    assertTrue(""No exchange received for counter: "" + i, exchange != null);
                    Object expectedBody = expectedBodyValues.get(i);
                    Object actualBody = actualBodyValues.get(i);
                    assertEquals(""Body of message: "" + i, expectedBody, actualBody);
                }
            }
        });
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint
     */
    public void expectedBodiesReceived(Object... bodies) {
        List bodyList = new ArrayList();
        bodyList.addAll(Arrays.asList(bodies));
        expectedBodiesReceived(bodyList);
    }
    /**
     * Adds an expectation that messages received should have ascending values
     * of the given expression such as a user generated counter value
     *
     * @param expression
     */
    public void expectsAscending(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertMessagesAscending(expression);
            }
        });
    }
    /**
     * Adds an expectation that messages received should have descending values
     * of the given expression such as a user generated counter value
     *
     * @param expression
     */
    public void expectsDescending(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertMessagesDescending(expression);
            }
        });
    }
    /**
     * Adds an expectation that no duplicate messages should be received using
     * the expression to determine the message ID
     *
     * @param expression the expression used to create a unique message ID for
     *                message comparison (which could just be the message
     *                payload if the payload can be tested for uniqueness using
     *                {@link Object#equals(Object)} and
     *                {@link Object#hashCode()}
     */
    public void expectsNoDuplicates(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertNoDuplicates(expression);
            }
        });
    }
    /**
     * Asserts that the messages have ascending values of the given expression
     */
    public void assertMessagesAscending(Expression<Exchange> expression) {
        assertMessagesSorted(expression, true);
    }
    /**
     * Asserts that the messages have descending values of the given expression
     */
    public void assertMessagesDescending(Expression<Exchange> expression) {
        assertMessagesSorted(expression, false);
    }
    protected void assertMessagesSorted(Expression<Exchange> expression, boolean ascending) {
        String type = ascending ? ""ascending"" : ""descending"";
        ExpressionComparator comparator = new ExpressionComparator(expression);
        List<Exchange> list = getReceivedExchanges();
        for (int i = 1; i < list.size(); i++) {
            int j = i - 1;
            Exchange e1 = list.get(j);
            Exchange e2 = list.get(i);
            int result = comparator.compare(e1, e2);
            if (result == 0) {
                fail(""Messages not "" + type + "". Messages"" + j + "" and "" + i + "" are equal with value: "" + expression.evaluate(e1) + "" for expression: "" + expression + "". Exchanges: "" + e1 + "" and ""
                     + e2);
            } else {
                if (!ascending) {
                    result = result * -1;
                }
                if (result > 0) {
                    fail(""Messages not "" + type + "". Message "" + j + "" has value: "" + expression.evaluate(e1) + "" and message "" + i + "" has value: "" + expression.evaluate(e2) + "" for expression: ""
                         + expression + "". Exchanges: "" + e1 + "" and "" + e2);
                }
            }
        }
    }
    public void assertNoDuplicates(Expression<Exchange> expression) {
        Map<Object, Exchange> map = new HashMap<Object, Exchange>();
        List<Exchange> list = getReceivedExchanges();
        for (int i = 0; i < list.size(); i++) {
            Exchange e2 = list.get(i);
            Object key = expression.evaluate(e2);
            Exchange e1 = map.get(key);
            if (e1 != null) {
                fail(""Duplicate message found on message "" + i + "" has value: "" + key + "" for expression: "" + expression + "". Exchanges: "" + e1 + "" and "" + e2);
            } else {
                map.put(key, e2);
            }
        }
    }
    /**
     * Adds the expection which will be invoked when enough messages are
     * received
     */
    public void expects(Runnable runnable) {
        tests.add(runnable);
    }
    /**
     * Adds an assertion to the given message index
     *
     * @param messageIndex the number of the message
     * @return the assertion clause
     */
    public AssertionClause message(final int messageIndex) {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                applyAssertionOn(MockEndpoint.this, messageIndex, assertExchangeReceived(messageIndex));
            }
        };
        expects(clause);
        return clause;
    }
    /**
     * Adds an assertion to all the received messages
     *
     * @return the assertion clause
     */
    public AssertionClause allMessages() {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                List<Exchange> list = getReceivedExchanges();
                int index = 0;
                for (Exchange exchange : list) {
                    applyAssertionOn(MockEndpoint.this, index++, exchange);
                }
            }
        };
        expects(clause);
        return clause;
    }
    /**
     * Asserts that the given index of message is received (starting at zero)
     */
    public Exchange assertExchangeReceived(int index) {
        int count = getReceivedCounter();
        assertTrue(""Not enough messages received. Was: "" + count, count > index);
        return getReceivedExchanges().get(index);
    }
    // Properties
    // -------------------------------------------------------------------------
    public List<Throwable> getFailures() {
        return failures;
    }
    public int getReceivedCounter() {
        return getReceivedExchanges().size();
    }
    public List<Exchange> getReceivedExchanges() {
        return receivedExchanges;
    }
    public int getExpectedCount() {
        return expectedCount;
    }
    public long getSleepForEmptyTest() {
        return sleepForEmptyTest;
    }
    /**
     * Allows a sleep to be specified to wait to check that this endpoint really
     * is empty when {@link #expectedMessageCount(int)} is called with zero
     *
     * @param sleepForEmptyTest the milliseconds to sleep for to determine that
     *                this endpoint really is empty
     */
    public void setSleepForEmptyTest(long sleepForEmptyTest) {
        this.sleepForEmptyTest = sleepForEmptyTest;
    }
    public long getResultWaitTime() {
        return resultWaitTime;
    }
    /**
     * Sets the maximum amount of time (in millis) the {@link #assertIsSatisfied()} will
     * wait on a latch until it is satisfied
     */
    public void setResultWaitTime(long resultWaitTime) {
        this.resultWaitTime = resultWaitTime;
    }
    /**
     * Specifies the expected number of message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void setExpectedMessageCount(int expectedCount) {
        this.expectedCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        } else {
            latch = new CountDownLatch(expectedCount);
        }
    }
    /**
     * Specifies the minimum number of expected message exchanges that should be
     * received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void setMinimumExpectedMessageCount(int expectedCount) {
        this.expectedMinimumCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        } else {
            latch = new CountDownLatch(expectedMinimumCount);
        }
    }
    public Processor getReporter() {
        return reporter;
    }
    /**
     * Allows a processor to added to the endpoint to report on progress of the test
     */
    public void setReporter(Processor reporter) {
        this.reporter = reporter;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    private void init() {
        expectedCount = -1;
        counter = 0;
        processors = new HashMap<Integer, Processor>();
        receivedExchanges = new CopyOnWriteArrayList<Exchange>();
        failures = new CopyOnWriteArrayList<Throwable>();
        tests = new CopyOnWriteArrayList<Runnable>();
        latch = null;
        sleepForEmptyTest = 1000L;
        resultWaitTime = 20000L;
        expectedMinimumCount = -1;
        expectedBodyValues = null;
        actualBodyValues = new ArrayList();
    }
    protected synchronized void onExchange(Exchange exchange) {
        try {
            if (reporter != null) {
                reporter.process(exchange);
            }
            performAssertions(exchange);
        } catch (Throwable e) {
            failures.add(e);
        }
        if (latch != null) {
            latch.countDown();
        }
    }
    protected void performAssertions(Exchange exchange) throws Exception {
        Message in = exchange.getIn();
        Object actualBody = in.getBody();
        if (headerName != null) {
            actualHeader = in.getHeader(headerName);
        }
        if (expectedBodyValues != null) {
            int index = actualBodyValues.size();
            if (expectedBodyValues.size() > index) {
                Object expectedBody = expectedBodyValues.get(index);
                if (expectedBody != null) {
                    actualBody = in.getBody(expectedBody.getClass());
                }
                actualBodyValues.add(actualBody);
            }
        }
        LOG.debug(getEndpointUri() + "" >>>> "" + (++counter) + "" : "" + exchange + "" with body: "" + actualBody);
        receivedExchanges.add(exchange);
        Processor processor = processors.get(getReceivedCounter()) != null
                ? processors.get(getReceivedCounter()) : defaultProcessor;
        if (processor != null) {
            processor.process(exchange);
        }
    }
    protected void waitForCompleteLatch() throws InterruptedException {
        if (latch == null) {
            fail(""Should have a latch!"");
        }
        // now lets wait for the results
        LOG.debug(""Waiting on the latch for: "" + resultWaitTime + "" millis"");
        latch.await(resultWaitTime, TimeUnit.MILLISECONDS);
    }
    protected void assertEquals(String message, Object expectedValue, Object actualValue) {
        if (!ObjectHelper.equal(expectedValue, actualValue)) {
            fail(message + "". Expected: <"" + expectedValue + ""> but was: <"" + actualValue + "">"");
        }
    }
    protected void assertTrue(String message, boolean predicate) {
        if (!predicate) {
            fail(message);
        }
    }
    protected void fail(Object message) {
        if (LOG.isDebugEnabled()) {
            List<Exchange> list = getReceivedExchanges();
            int index = 0;
            for (Exchange exchange : list) {
                LOG.debug(""Received["" + (++index) + ""]: "" + exchange);
            }
        }
        throw new AssertionError(getEndpointUri() + "" "" + message);
    }
    public int getExpectedMinimumCount() {
        return expectedMinimumCount;
    }
    public void await() throws InterruptedException {
        if (latch != null) {
            latch.await();
        }
    }
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
        if (latch != null) {
            return latch.await(timeout, unit);
        }
        return true;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.component.mock.MockEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 642773 $
 */
public class MockEndpointTest extends ContextTestSupport {
    public void testAscendingMessagesPass() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectsAscending(header(""counter"").convertTo(Number.class));
        sendMessages(11, 12, 13, 14, 15);
        resultEndpoint.assertIsSatisfied();
    }
    public void testAscendingMessagesFail() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result""); 
        resultEndpoint.expectsAscending(header(""counter"").convertTo(Number.class));
        sendMessages(11, 12, 13, 15, 14);
        resultEndpoint.assertIsNotSatisfied();
    }
    public void testDescendingMessagesPass() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result""); 
        resultEndpoint.expectsDescending(header(""counter"").convertTo(Number.class));
        sendMessages(15, 14, 13, 12, 11);
        resultEndpoint.assertIsSatisfied();
    }
    public void testDescendingMessagesFail() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result""); 
        resultEndpoint.expectsDescending(header(""counter"").convertTo(Number.class));
        sendMessages(15, 14, 13, 11, 12);
        resultEndpoint.assertIsNotSatisfied();
    }
    public void testNoDuplicateMessagesPass() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result""); 
        resultEndpoint.expectsNoDuplicates(header(""counter""));
        sendMessages(11, 12, 13, 14, 15);
        resultEndpoint.assertIsSatisfied();
    }
    public void testDuplicateMessagesFail() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result""); 
        resultEndpoint.expectsNoDuplicates(header(""counter""));
        sendMessages(11, 12, 13, 14, 12);
        resultEndpoint.assertIsNotSatisfied();
    }
    public void testExpectationsAfterMessagesArrivePass() throws Exception {
        sendMessages(11, 12, 13, 14, 12);
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result""); 
        resultEndpoint.expectedMessageCount(5);
        resultEndpoint.assertIsNotSatisfied();
    }
    public void testExpectationsAfterMessagesArriveFail() throws Exception {
        sendMessages(11, 12, 13, 14, 12);
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(6);
        resultEndpoint.assertIsNotSatisfied();
    }
    public void testReset() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result""); 
        resultEndpoint.expectedMessageCount(2);
        sendMessages(11, 12);
        resultEndpoint.assertIsSatisfied();
        resultEndpoint.reset();
        resultEndpoint.expectedMessageCount(3);
        sendMessages(11, 12, 13);
        resultEndpoint.assertIsSatisfied();
    }
    public void testExpectationOfHeader() throws InterruptedException {        
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.reset();
        // assert header & value are same
        resultEndpoint.expectedHeaderReceived(""header"", ""value"");
        sendHeader(""header"", ""value"");
        resultEndpoint.assertIsSatisfied();
        resultEndpoint.reset();
        // assert failure when value is different
        resultEndpoint.expectedHeaderReceived(""header"", ""value1"");
        sendHeader(""header"", ""value"");
        resultEndpoint.assertIsNotSatisfied();       
        resultEndpoint.reset();
        // assert failure when header name is different       
        resultEndpoint.expectedHeaderReceived(""header1"", ""value"");
        sendHeader(""header"", ""value"");
        resultEndpoint.assertIsNotSatisfied();               
        resultEndpoint.reset();
        // assert failure when both header name & value are different
        resultEndpoint.expectedHeaderReceived(""header1"", ""value1"");
        sendHeader(""header"", ""value"");
        resultEndpoint.assertIsNotSatisfied();                       
    }
    protected void sendMessages(int... counters) {
        for (int counter : counters) {
            template.sendBodyAndHeader(""direct:a"", ""<message>"" + counter + ""</message>"",
                    ""counter"", counter);
        }
    }
    protected void sendHeader(String name, String value) {
        template.sendBodyAndHeader(""direct:a"", ""body"", name, value);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.pojo.ISay,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;
public interface ISay {
    String say();
}
"
org.apache.camel.component.pojo.PojoRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;
import junit.framework.TestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.bean.ProxyHelper;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.util.jndi.JndiContext;
/**
 * @version $Revision: 630568 $
 */
public class PojoRouteTest extends TestCase {
    public void testPojoRoutes() throws Exception {
        // START SNIPPET: register
        // lets populate the context with the services we need
        // note that we could just use a spring.xml file to avoid this step
        JndiContext context = new JndiContext();
        context.bind(""bye"", new SayService(""Good Bye!""));
        CamelContext camelContext = new DefaultCamelContext(context);
        // END SNIPPET: register
        // START SNIPPET: route
        // lets add simple route
        camelContext.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:hello"").to(""pojo:bye"");
            }
        });
        // END SNIPPET: route
        camelContext.start();
        // START SNIPPET: invoke
        Endpoint endpoint = camelContext.getEndpoint(""direct:hello"");
        ISay proxy = ProxyHelper.createProxy(endpoint, ISay.class);
        String rc = proxy.say();
        assertEquals(""Good Bye!"", rc);
        // END SNIPPET: invoke
        camelContext.stop();
    }
}
"
org.apache.camel.component.pojo.SayService,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;
public class SayService implements ISay {
    String message = ""Hello"";
    public SayService() {
    }
    public SayService(String message) {
        this.message = message;
    }
    public String say() {
        return message;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
}
"
org.apache.camel.component.ref.RefComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ref;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Component for lookup of existing endpoints bound in the {@link org.apache.camel.spi.Registry}.
 * <p/>
 * This component uses the <tt>ref:</tt> notation instead of the mostly common <tt>uri:</tt> notation. 
 */
public class RefComponent extends DefaultComponent<Exchange> {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        String name = uri.substring(""ref:"".length());
        return getCamelContext().getRegistry().lookup(name, Endpoint.class);
    }
}
"
org.apache.camel.component.seda.CollectionProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.Collection;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
/**
 * A simple {@link Producer} which just appends to a {@link Collection} the {@link Exchange} object.
 *
 * @version $Revision: 640438 $
 */
public class CollectionProducer extends DefaultProducer implements AsyncProcessor {
    private final Collection<Exchange> queue;
    public CollectionProducer(Endpoint endpoint, Collection<Exchange> queue) {
        super(endpoint);
        this.queue = queue;
    }
    public void process(Exchange exchange) throws Exception {
        queue.add(exchange.copy());
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        queue.add(exchange.copy());
        callback.done(true);
        return true;
    }
}
"
org.apache.camel.component.seda.ListPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.PollingConsumerSupport;
/**
 * @deprecated not used. Will be removed in Camel 2.0.
 * @version $Revision: 663882 $
 */
@Deprecated
public class ListPollingConsumer extends PollingConsumerSupport {
    private final List<Exchange> exchanges;
    public ListPollingConsumer(Endpoint endpoint, List<Exchange> exchanges) {
        super(endpoint);
        this.exchanges = exchanges;
    }
    public Exchange receive() {
        return receiveNoWait();
    }
    public Exchange receiveNoWait() {
        if (exchanges.isEmpty()) {
            return null;
        } else {
            return exchanges.remove(0);
        }
    }
    public Exchange receive(long timeout) {
        return receiveNoWait();
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.seda.QueueComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.BlockingQueue;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/queue.html"">Queue components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @deprecated This component has been deprecated; please use the seda: URI format instead of queue: 
 * @version $Revision: 668065 $
 */
public class QueueComponent extends SedaComponent {
    private static final transient Log LOG = LogFactory.getLog(QueueComponent.class);
    public QueueComponent() {
        LOG.warn(""This component has been deprecated; please use the seda: URI format instead of queue:"");
    }
}
"
org.apache.camel.component.seda.SedaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/seda.html"">SEDA components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @version $Revision: 655440 $
 */
public class SedaComponent extends DefaultComponent<Exchange> {
    public BlockingQueue<Exchange> createQueue(String uri, Map parameters) {
        int size = getAndRemoveParameter(parameters, ""size"", Integer.class, 1000);
        return new LinkedBlockingQueue<Exchange>(size);
    }
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new SedaEndpoint(uri, this, parameters);
    }
}
"
org.apache.camel.component.seda.SedaConfigureTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
/**
 * @version $Revision: 640438 $
 */
public class SedaConfigureTest extends ContextTestSupport {
    public void testBlockingQueueConfigured() throws Exception {
        SedaEndpoint endpoint = resolveMandatoryEndpoint(""seda:foo?size=2000"", SedaEndpoint.class);
        BlockingQueue<Exchange> queue = endpoint.getQueue();
        LinkedBlockingQueue blockingQueue = assertIsInstanceOf(LinkedBlockingQueue.class, queue);
        assertEquals(""remainingCapacity"", 2000, blockingQueue.remainingCapacity());
    }
}
"
org.apache.camel.component.seda.SedaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A Consumer for the SEDA component.
 *
 * @version $Revision: 659782 $
 */
public class SedaConsumer extends ServiceSupport implements Consumer, Runnable {
    private static final transient Log LOG = LogFactory.getLog(SedaConsumer.class);
    private SedaEndpoint endpoint;
    private AsyncProcessor processor;
    private Thread thread;
    public SedaConsumer(SedaEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = AsyncProcessorTypeConverter.convert(processor);
    }
    @Override
    public String toString() {
        return ""SedaConsumer: "" + endpoint.getEndpointUri();
    }
    public void run() {
        while (isRunAllowed()) {
            final Exchange exchange;
            try {
                exchange = endpoint.getQueue().poll(1000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Interupted: "" + e, e);
                }
                continue;
            }
            if (exchange != null && isRunAllowed()) {
                try {
                    processor.process(exchange, new AsyncCallback() {
                        public void done(boolean sync) {
                        }
                    });
                } catch (Exception e) {
                    LOG.error(""Seda queue caught: "" + e, e);
                }
            }
        }
    }
    protected void doStart() throws Exception {
        thread = new Thread(this, getThreadName(endpoint.getEndpointUri()));
        thread.setDaemon(true);
        thread.start();
    }
    protected void doStop() throws Exception {
        thread.join();
    }
}
"
org.apache.camel.component.seda.SedaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.spi.BrowsableEndpoint;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/queue.html"">Queue components</a> for
 * asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @version $Revision: 655516 $
 */
public class SedaEndpoint extends DefaultEndpoint<Exchange> implements BrowsableEndpoint<Exchange> {
    private BlockingQueue<Exchange> queue;
    public SedaEndpoint(String endpointUri, Component component, BlockingQueue<Exchange> queue) {
        super(endpointUri, component);
        this.queue = queue;
    }
    public SedaEndpoint(String uri, SedaComponent component, Map parameters) {
        this(uri, component, component.createQueue(uri, parameters));
    }
    public SedaEndpoint(String endpointUri, BlockingQueue<Exchange> queue) {
        super(endpointUri);
        this.queue = queue;
    }
    public Producer createProducer() throws Exception {
        return new CollectionProducer(this, getQueue());
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        return new SedaConsumer(this, processor);
    }
    public BlockingQueue<Exchange> getQueue() {
        return queue;
    }
    public boolean isSingleton() {
        return true;
    }
    public List<Exchange> getExchanges() {
        return new ArrayList<Exchange>(getQueue());
    }
}
"
org.apache.camel.component.seda.SedaRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
/**
 * @version $Revision: 630568 $
 */
public class SedaRouteTest extends TestSupport {
    public void testSedaQueue() throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        CamelContext context = new DefaultCamelContext();
        // lets add some routes
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""seda:test.a"").to(""seda:test.b"");
                from(""seda:test.b"").process(new Processor() {
                    public void process(Exchange e) {
                        log.debug(""Received exchange: "" + e.getIn());
                        latch.countDown();
                    }
                });
            }
        });
        context.start();
        // now lets fire in a message
        Endpoint<Exchange> endpoint = context.getEndpoint(""seda:test.a"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setHeader(""cheese"", 123);
        Producer<Exchange> producer = endpoint.createProducer();
        producer.process(exchange);
        // now lets sleep for a while
        boolean received = latch.await(5, TimeUnit.SECONDS);
        assertTrue(""Did not receive the message!"", received);
        context.stop();
    }
    public void testThatShowsEndpointResolutionIsNotConsistent() throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        CamelContext context = new DefaultCamelContext();
        // lets add some routes
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""seda:test.a"").to(""seda:test.b"");
                from(""seda:test.b"").process(new Processor() {
                    public void process(Exchange e) {
                        log.debug(""Received exchange: "" + e.getIn());
                        latch.countDown();
                    }
                });
            }
        });
        context.start();
        // now lets fire in a message
        Endpoint<Exchange> endpoint = context.getEndpoint(""seda:test.a"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setHeader(""cheese"", 123);
        Producer<Exchange> producer = endpoint.createProducer();
        producer.process(exchange);
        // now lets sleep for a while
        boolean received = latch.await(5, TimeUnit.SECONDS);
        assertTrue(""Did not receive the message!"", received);
        context.stop();
    }
}
"
org.apache.camel.component.timer.TimerComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Represents the component that manages {@link TimerEndpoint}.  It holds the
 * list of {@link TimerConsumer} objects that are started.
 *
 * @version $Revision: 640438 $
 */
public class TimerComponent extends DefaultComponent<Exchange> {
    private Map<String, Timer> timers = new HashMap<String, Timer>();
    public Timer getTimer(TimerEndpoint endpoint) {
        String key = endpoint.getTimerName();
        if (!endpoint.isDaemon()) {
            key = ""nonDaemon:"" + key;
        }
        Timer answer = timers.get(key);
        if (answer == null) {
            answer = new Timer(endpoint.getTimerName(), endpoint.isDaemon());
            timers.put(key, answer);
        }
        return answer;
    }
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        TimerEndpoint answer = new TimerEndpoint(uri, this, remaining);
        setProperties(answer, parameters);
        return answer;
    }
    @Override
    protected void doStop() throws Exception {
        Collection<Timer> collection = timers.values();
        for (Timer timer : collection) {
            timer.cancel();
        }
        timers.clear();
    }
}
"
org.apache.camel.component.timer.TimerConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import java.util.Timer;
import java.util.TimerTask;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The timer consumer.
 *
 * @version $Revision: 659782 $
 */
public class TimerConsumer extends DefaultConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(TimerConsumer.class);
    private final TimerEndpoint endpoint;
    private TimerTask task;
    public TimerConsumer(TimerEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        task = new TimerTask() {
            @Override
            public void run() {
                sendTimerExchange();
            }
        };
        Timer timer = endpoint.getTimer();
        configureTask(task, timer);
    }
    @Override
    protected void doStop() throws Exception {
        task.cancel();
    }
    protected void configureTask(TimerTask task, Timer timer) {
        if (endpoint.isFixedRate()) {
            if (endpoint.getTime() != null) {
                timer.scheduleAtFixedRate(task, endpoint.getTime(), endpoint.getPeriod());
            } else {
                timer.scheduleAtFixedRate(task, endpoint.getDelay(), endpoint.getPeriod());
            }
        } else {
            if (endpoint.getTime() != null) {
                if (endpoint.getPeriod() >= 0) {
                    timer.schedule(task, endpoint.getTime(), endpoint.getPeriod());
                } else {
                    timer.schedule(task, endpoint.getTime());
                }
            } else {
                if (endpoint.getPeriod() >= 0) {
                    timer.schedule(task, endpoint.getDelay(), endpoint.getPeriod());
                } else {
                    timer.schedule(task, endpoint.getDelay());
                }
            }
        }
    }
    protected void sendTimerExchange() {
        Exchange exchange = endpoint.createExchange();
        exchange.setProperty(""org.apache.camel.timer.name"", endpoint.getTimerName());
        exchange.setProperty(""org.apache.camel.timer.time"", endpoint.getTime());
        exchange.setProperty(""org.apache.camel.timer.period"", endpoint.getPeriod());
        try {
            getProcessor().process(exchange);
        } catch (Exception e) {
            LOG.error(""Caught: "" + e, e);
        }
    }
}
"
org.apache.camel.component.timer.TimerEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import java.util.Date;
import java.util.Timer;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
/**
 * Represents a timer endpoint that can generate periodic inbound PojoExchanges.
 *
 * @version $Revision: 660275 $
 */
public class TimerEndpoint extends DefaultEndpoint<Exchange> {
    private String timerName;
    private Date time;
    private long period = 1000;
    private long delay;
    private boolean fixedRate;
    private boolean daemon = true;
    private Timer timer;
    public TimerEndpoint(String fullURI, TimerComponent component, String timerName) {
        super(fullURI, component);
        this.timer = component.getTimer(this);
        this.timerName = timerName;
    }
    public TimerEndpoint(String endpointUri, Timer timer) {
        this(endpointUri);
        this.timer = timer;
    }
    public TimerEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<Exchange> createProducer() throws Exception {
        throw new RuntimeCamelException(""Cannot produce to a TimerEndpoint: "" + getEndpointUri());
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new TimerConsumer(this, processor);
    }
    public String getTimerName() {
        if (timerName == null) {
            timerName = getEndpointUri();
        }
        return timerName;
    }
    public void setTimerName(String timerName) {
        this.timerName = timerName;
    }
    public boolean isDaemon() {
        return daemon;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public boolean isFixedRate() {
        return fixedRate;
    }
    public void setFixedRate(boolean fixedRate) {
        this.fixedRate = fixedRate;
    }
    public long getPeriod() {
        return period;
    }
    public void setPeriod(long period) {
        this.period = period;
    }
    public Date getTime() {
        return time;
    }
    public void setTime(Date time) {
        this.time = time;
    }
    public boolean isSingleton() {
        return true;
    }
    public Timer getTimer() {
        if (timer == null) {
            timer = new Timer();
        }
        return timer;
    }
    public void setTimer(Timer timer) {
        this.timer = timer;
    }
}
"
org.apache.camel.component.timer.TimerRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import java.util.concurrent.atomic.AtomicInteger;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class TimerRouteTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(TimerRouteTest.class);
    private MyBean bean = new MyBean();
    public void testTimerInvokesBeanMethod() throws Exception {
        // now lets wait for the timer to fire a few times.
        Thread.sleep(1000 * 2);
        assertTrue("""", bean.counter.get() >= 2);
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
                from(""timer://foo?fixedRate=true&delay=0&period=500"").to(""bean:myBean"");
            }
        };
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", bean);
        return answer;
    }
    public static class MyBean {
        public AtomicInteger counter = new AtomicInteger(0);
        public void someMethod() {
            LOG.debug(""Invoked someMethod()"");
            counter.incrementAndGet();
        }
    }
}
"
org.apache.camel.component.vm.VmComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.vm;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.seda.SedaComponent;
import org.apache.camel.component.seda.SedaEndpoint;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/vm.html"">VM components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within the classloader tree containing
 * the camel-core.jar. i.e. to handle communicating across CamelContext instances and possibly across
 * web application contexts, providing that camel-core.jar is on the system classpath.
 *
 * @version $Revision: 660275 $
 */
public class VmComponent extends SedaComponent {
    protected static final Map<String, BlockingQueue> QUEUES = new HashMap<String, BlockingQueue>();
    private static final AtomicInteger START_COUNTER = new AtomicInteger();
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        BlockingQueue<Exchange> blockingQueue = getBlockingQueue(uri, parameters);
        return new SedaEndpoint(uri, this, blockingQueue);
    }
    protected BlockingQueue<Exchange> getBlockingQueue(String uri, Map parameters) {
        synchronized (QUEUES) {
            BlockingQueue<Exchange> answer = QUEUES.get(uri);
            if (answer == null) {
                answer = createQueue(uri, parameters);
                QUEUES.put(uri, answer);
            }
            return answer;
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        START_COUNTER.incrementAndGet();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (START_COUNTER.decrementAndGet() == 0) {
            synchronized (QUEUES) {
                for (BlockingQueue q : QUEUES.values()) {
                    q.clear();
                }
                QUEUES.clear();
            }
        }
    }
}
"
org.apache.camel.component.vm.VmRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.vm;
import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.TestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.util.ServiceHelper;
/**
 * @version $Revision: 662986 $
 */
public class VmRouteTest extends TestSupport {
    private CamelContext context1 = new DefaultCamelContext();
    private CamelContext context2 = new DefaultCamelContext();
    private ProducerTemplate template = context1.createProducerTemplate();
    private Object expectedBody = ""<hello>world!</hello>"";
    public void testSedaQueue() throws Exception {
        MockEndpoint result = context2.getEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedBodiesReceived(expectedBody);
        template.sendBody(""vm:test.a"", expectedBody);
        result.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context1.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""vm:test.a"").to(""vm:test.b"");
            }
        });
        context2.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""vm:test.b"").to(""mock:result"");
            }
        });
        ServiceHelper.startServices(context1, context2);
    }
    @Override
    protected void tearDown() throws Exception {
        ServiceHelper.stopServices(context2, context1);
        super.tearDown();
    }
}
"
org.apache.camel.converter.CamelConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
/**
 * Some useful converters for Camel APIs such as to convert a {@link Predicate} or {@link Expression}
 * to a {@link Processor}
 *
 * @version $Revision: 662301 $
 */
@Converter
public class CamelConverter {
    @Converter
    public Processor toProcessor(final Predicate<Exchange> predicate) {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                boolean answer = predicate.matches(exchange);
                Message out = exchange.getOut();
                out.copyFrom(exchange.getIn());
                out.setBody(answer);
            }
        };
    }
    @Converter
    public Processor toProcessor(final Expression<Exchange> expresion) {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                Object answer = expresion.evaluate(exchange);
                Message out = exchange.getOut();
                out.copyFrom(exchange.getIn());
                out.setBody(answer);
            }
        };
    }
}
"
org.apache.camel.converter.CollectionConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.apache.camel.Converter;
/**
 * Some core java.util Collection based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 660275 $
 */
@Converter
public final class CollectionConverter {
    /**
     * Utility classes should not have a public constructor.
     */
    private CollectionConverter() {
    }
    /**
     * Converts a collection to an array
     */
    @Converter
    public static Object[] toArray(Collection value) {
        if (value == null) {
            return null;
        }
        return value.toArray();
    }
    /**
     * Converts an array to a collection
     */
    @Converter
    public static List toList(Object[] array) {
        return Arrays.asList(array);
    }
    /**
     * Converts a collection to a List if it is not already
     */
    @Converter
    public static List toList(Collection collection) {
        return new ArrayList(collection);
    }
    @Converter
    public static Set toSet(Object[] array) {
        Set answer = new HashSet();
        answer.addAll(Arrays.asList(array));
        return answer;
    }
    @Converter
    public static Set toSet(Collection collection) {
        return new HashSet(collection);
    }
    @Converter
    public static Set toSet(Map map) {
        return map.entrySet();
    }
    @Converter
    public static Properties toProperties(Map map) {
        Properties answer = new Properties();
        answer.putAll(map);
        return answer;
    }
    @Converter
    public static Hashtable toHashtable(Map map) {
        return new Hashtable(map);
    }
    @Converter
    public static HashMap toHashMap(Map map) {
        return new HashMap(map);
    }
}
"
org.apache.camel.converter.ConverterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.beans.PropertyEditorManager;
import java.beans.PropertyEditorSupport;
import java.io.File;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import junit.framework.TestCase;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ReflectionInjector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 659638 $
 */
public class ConverterTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(ConverterTest.class);
    protected TypeConverter converter = new DefaultTypeConverter(new ReflectionInjector());
    public static class IntegerPropertyEditor extends PropertyEditorSupport {
        public void setAsText(String text) throws IllegalArgumentException {
            setValue(new Integer(text));
        }
        public String getAsText() {
            Integer value = (Integer) getValue();
            return value != null ? value.toString() : """";
        }
    }
    public void testIntegerPropertyEditorConversion() throws Exception {
        Integer value = converter.convertTo(Integer.class, ""1000"");
        assertNotNull(value);
        assertEquals(""Converted to Integer"", new Integer(1000), value);
        String text = converter.convertTo(String.class, value);
        assertEquals(""Converted to String"", ""1000"", text);
    }
    public void testConvertStringToAndFromByteArray() throws Exception {
        byte[] array = converter.convertTo(byte[].class, ""foo"");
        assertNotNull(array);
        LOG.debug(""Found array of size: "" + array.length);
        String text = converter.convertTo(String.class, array);
        assertEquals(""Converted to String"", ""foo"", text);
    }
    public void testConvertStringToAndFromCharArray() throws Exception {
        char[] array = converter.convertTo(char[].class, ""foo"");
        assertNotNull(array);
        LOG.debug(""Found array of size: "" + array.length);
        String text = converter.convertTo(String.class, array);
        assertEquals(""Converted to String"", ""foo"", text);
    }
    public void testConvertStringAndStreams() throws Exception {
        InputStream inputStream = converter.convertTo(InputStream.class, ""bar"");
        assertNotNull(inputStream);
        String text = converter.convertTo(String.class, inputStream);
        assertEquals(""Converted to String"", ""bar"", text);
    }
    public void testArrayToListAndSetConversion() throws Exception {
        String[] array = new String[]{""one"", ""two""};
        List list = converter.convertTo(List.class, array);
        assertEquals(""List size: "" + list, 2, list.size());
        Collection collection = converter.convertTo(Collection.class, array);
        assertEquals(""Collection size: "" + collection, 2, collection.size());
        Set set = converter.convertTo(Set.class, array);
        assertEquals(""Set size: "" + set, 2, set.size());
        set = converter.convertTo(Set.class, list);
        assertEquals(""Set size: "" + set, 2, set.size());
    }
    public void testCollectionToArrayConversion() throws Exception {
        List list = new ArrayList();
        list.add(""one"");
        list.add(""two"");
        Object[] objectArray = converter.convertTo(Object[].class, list);
        assertEquals(""Object[] length"", 2, objectArray.length);
        String[] stringArray = converter.convertTo(String[].class, list);
        assertEquals(""String[] length"", 2, stringArray.length);
    }
    public void testCollectionToPrimitiveArrayConversion() throws Exception {
        List list = new ArrayList();
        list.add(5);
        list.add(6);
        Integer[] integerArray = converter.convertTo(Integer[].class, list);
        assertEquals(""Integer[] length"", 2, integerArray.length);
        int[] intArray = converter.convertTo(int[].class, list);
        assertEquals(""int[] length"", 2, intArray.length);
        // lets convert the typesafe array to a larger primitive type
        long[] longArray = converter.convertTo(long[].class, intArray);
        assertEquals(""long[] length"", 2, longArray.length);
        // now lets go back to a List again
        List resultList = converter.convertTo(List.class, intArray);
        assertEquals(""List size"", 2, resultList.size());
        LOG.debug(""From primitive type array we've created the list: "" + resultList);
    }
    public void testStringToFile() throws Exception {
        File file = converter.convertTo(File.class, ""foo.txt"");
        assertNotNull(""Should have converted to a file!"");
        assertEquals(""file name"", ""foo.txt"", file.getName());
    }
    public void testFileToString() throws Exception {
        URL resource = getClass().getResource(""dummy.txt"");
        assertNotNull(""Cannot find resource!"");
        File file = new File(resource.getFile());
        String text = converter.convertTo(String.class, file);
        assertNotNull(""Should have returned a String!"", text);
        text = text.trim();
        assertTrue(""Text not read correctly: "" + text, text.endsWith(""Hello World!""));
    }
    public void testPrimitiveBooleanConversion() throws Exception {
        boolean value = converter.convertTo(boolean.class, null);
        assertFalse(value);
    }
    public void testPrimitiveIntConversion() throws Exception {
        int value = converter.convertTo(int.class, 4);
        assertEquals(""value"", 4, value);
    }
    public void testPrimitiveIntPropertySetter() throws Exception {
        MyBean bean = new MyBean();
        IntrospectionSupport.setProperty(converter, bean, ""foo"", ""4"");
        assertEquals(""bean.foo"", 4, bean.getFoo());
    }
    public void testStringToBoolean() throws Exception {
        Boolean value = converter.convertTo(Boolean.class, ""true"");
        assertEquals(""converted boolean value"", Boolean.TRUE, value);
        value = converter.convertTo(Boolean.class, ""false"");
        assertEquals(""converted boolean value"", Boolean.FALSE, value);
        value = converter.convertTo(Boolean.class, null);
        assertEquals(""converted boolean value"", null, value);
    }
    public static class MyBean {
        private int foo;
        public int getFoo() {
            return foo;
        }
        public void setFoo(int foo) {
            this.foo = foo;
        }
    }
    @Override
    protected void setUp() throws Exception {
        PropertyEditorManager.registerEditor(Integer.class, IntegerPropertyEditor.class);
    }
}
"
org.apache.camel.converter.HasAnnotation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to indicate that the actual type of a parameter on a converter method must have the given annotation class
 * to be applicable. e.g. this annotation could be used on a JAXB converter which only applies to objects with a
 * JAXB annotation on them
 *
 * @version $Revision: 630591 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface HasAnnotation {
    Class value();
}
"
org.apache.camel.converter.IOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;
import java.net.URL;
import java.util.Properties;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.apache.camel.Converter;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some core java.io based <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 642102 $
 */
@Converter
public final class IOConverter {
    private static final transient Log LOG = LogFactory.getLog(IOConverter.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private IOConverter() {
    }
    @Converter
    public static InputStream toInputStream(URL url) throws IOException {
        return url.openStream();
    }
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
    @Converter
    public static BufferedReader toReader(File file) throws FileNotFoundException {
        return new BufferedReader(new FileReader(file));
    }
    @Converter
    public static File toFile(String name) throws FileNotFoundException {
        return new File(name);
    }
    @Converter
    public static OutputStream toOutputStream(File file) throws FileNotFoundException {
        return new BufferedOutputStream(new FileOutputStream(file));
    }
    @Converter
    public static BufferedWriter toWriter(File file) throws IOException {
        return new BufferedWriter(new FileWriter(file));
    }
    @Converter
    public static Reader toReader(InputStream in) throws FileNotFoundException {
        return new InputStreamReader(in);
    }
    @Converter
    public static Writer toWriter(OutputStream out) throws FileNotFoundException {
        return new OutputStreamWriter(out);
    }
    @Converter
    public static StringReader toReader(String text) {
        // TODO could we automatically find this?
        return new StringReader(text);
    }
    @Converter
    public static InputStream toInputStream(String text) {
        return toInputStream(text.getBytes());
    }
    @Converter
    public static InputStream toInputStream(BufferedReader buffer) throws IOException {
        return toInputStream(toString(buffer));
    }
    @Converter
    public static InputStream toInputStrean(DOMSource source) throws TransformerException, IOException {
        ByteArrayInputStream bais = new ByteArrayInputStream(toString(source).getBytes());
        return bais;
    }
    @Converter
    public static String toString(byte[] data) {
        return new String(data);
    }
    @Converter
    public static String toString(File file) throws IOException {
        return toString(toReader(file));
    }
    @Converter
    public static String toString(URL url) throws IOException {
        return toString(toInputStream(url));
    }
    @Converter
    public static String toString(Reader reader) throws IOException {
        if (reader instanceof BufferedReader) {
            return toString((BufferedReader)reader);
        } else {
            return toString(new BufferedReader(reader));
        }
    }
    @Converter
    public static String toString(BufferedReader reader) throws IOException {
        if (reader == null) {
            return null;
        }
        try {
            CollectionStringBuffer builder = new CollectionStringBuffer(""\n"");
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    return builder.toString();
                }
                builder.append(line);
            }
        } finally {
            try {
                reader.close();
            } catch (IOException e) {
                LOG.warn(""Failed to close stream: "" + e, e);
            }
        }
    }
    @Converter
    public static String toString(InputStream in) throws IOException {
        return toString(toReader(in));
    }
    public static String toString(Source source) throws TransformerException, IOException {
        return toString(source, null);
    }
    public static String toString(Source source, Properties props) throws TransformerException, IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        StreamResult sr = new StreamResult(bos);
        Transformer trans = TransformerFactory.newInstance().newTransformer();
        if (props == null) {
            props = new Properties();
            props.put(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
        }
        trans.setOutputProperties(props);
        trans.transform(source, sr);
        bos.close();
        return bos.toString();
    }
    @Converter
    public static InputStream toInputStream(byte[] data) {
        return new ByteArrayInputStream(data);
    }
    @Converter
    public static ObjectOutput toObjectOutput(OutputStream stream) throws IOException {
        if (stream instanceof ObjectOutput) {
            return (ObjectOutput) stream;
        } else {
            return new ObjectOutputStream(stream);
        }
    }
    @Converter
    public static ObjectInput toObjectInput(InputStream stream) throws IOException {
        if (stream instanceof ObjectInput) {
            return (ObjectInput) stream;
        } else {
            return new ObjectInputStream(stream);
        }
    }
    @Converter
    public static byte[] toBytes(InputStream stream) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        copy(stream, bos);
        return bos.toByteArray();
    }
    protected static void copy(InputStream stream, ByteArrayOutputStream bos) throws IOException {
        byte[] data = new byte[4096];
        int read = stream.read(data);
        while (read != -1) {
            bos.write(data, 0, read);
            read = stream.read(data);
        }
        bos.flush();
    }
}
"
org.apache.camel.converter.IOConverterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import junit.framework.TestCase;
/**
 * Test case for {@link IOConverter}
 */
public class IOConverterTest extends TestCase {
    private static final byte[] TESTDATA = ""My test data"".getBytes();
    public void testToBytes() throws FileNotFoundException, IOException {
        File file = new File(""src/test/resources/org/apache/camel/converter/dummy.txt"");
        byte[] data = IOConverter.toBytes(new FileInputStream(file));
        assertEquals(""get the wrong byte size"", file.length(), data.length);
        assertEquals('#', (char) data[0]);
        assertEquals('!', (char) data[data.length - 1]);
    }
    public void testCopy() throws IOException {
        ByteArrayInputStream bis = new ByteArrayInputStream(TESTDATA);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        IOConverter.copy(bis, bos);
        assertEquals(TESTDATA, bos.toByteArray());
    }
    private void assertEquals(byte[] data1, byte[] data2) {
        assertEquals(data1.length, data2.length);
        for (int i = 0; i < data1.length; i++) {
            assertEquals(data1[i], data2[i]);
        }
    }
}
"
org.apache.camel.converter.JaxpTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.io.InputStream;
import java.io.StringReader;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import junit.framework.TestCase;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.util.ReflectionInjector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 659638 $
 */
public class JaxpTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(JaxpTest.class);
    protected TypeConverter converter = new DefaultTypeConverter(new ReflectionInjector());
    public void testConvertToDocument() throws Exception {
        Document document = converter
                .convertTo(Document.class, ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><hello>world!</hello>"");
        assertNotNull(document);
        LOG.debug(""Found document: "" + document);
        // lets now convert back again
        String text = converter.convertTo(String.class, document);
        // The preamble changes a little under Java 1.6 it adds a
        // standalone=""no"" attribute.
        assertTrue(""Converted to String: "" + text, text.endsWith(""<hello>world!</hello>""));
    }
    public void testConvertToSource() throws Exception {
        Source source = converter
                .convertTo(Source.class, ""<hello>world!</hello>"");
        assertNotNull(source);
        LOG.debug(""Found document: "" + source);
    }
    public void testStreamSourceToDomSource() throws Exception {
        StreamSource streamSource = new StreamSource(new StringReader(""<hello>world!</hello>""));
        DOMSource domSource = converter.convertTo(DOMSource.class, streamSource);
        assertNotNull(""Could not convert to a DOMSource!"", domSource);
        LOG.debug(""Found document: "" + domSource);
    }
    public void testNodeToSourceThenToInputStream() throws Exception {
        Document document = converter.convertTo(Document.class, ""<?xml version=\""1.0\""?><hello>world!</hello>"");
        Element element = document.getDocumentElement();
        Source source = converter.convertTo(Source.class, element);
        assertNotNull(""Could not convert from Node to Source!"", source);
        LOG.debug(""Found source: "" + source);
        InputStream in = converter.convertTo(InputStream.class, source);
        assertNotNull(""Could not convert from Source to InputStream!"", in);
        String actualText = IOConverter.toString(in);
        assertEquals(""Text"", ""<hello>world!</hello>"", actualText);
    }
}
"
org.apache.camel.converter.NIOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import org.apache.camel.Converter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some core java.nio based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 668062 $
 */
@Converter
public final class NIOConverter {
    private static final transient Log LOG = LogFactory.getLog(NIOConverter.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private NIOConverter() {
    }
    @Converter
    public static byte[] toByteArray(ByteBuffer buffer) {
        return buffer.array();
    }
    @Converter
    public static String toString(ByteBuffer buffer) {
        return IOConverter.toString(buffer.array());
    }
    @Converter
    public static ByteBuffer toByteBuffer(byte[] data) {
        return ByteBuffer.wrap(data);
    }
    @Converter
    public static ByteBuffer toByteBuffer(File file) throws IOException {
        InputStream in = null;
        try {
            byte[] buf = new byte[(int)file.length()];
            in = new BufferedInputStream(new FileInputStream(file));
            int sizeLeft = (int)file.length();
            int offset = 0;
            while (sizeLeft > 0) {
                int readSize = in.read(buf, offset, sizeLeft);
                sizeLeft -= readSize;
                offset += readSize;
            }
            return ByteBuffer.wrap(buf);
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
            } catch (IOException e) {
                LOG.warn(""Failed to close file stream: "" + file.getPath(), e);
            }
        }
    }
    @Converter
    public static ByteBuffer toByteBuffer(String value) {
        ByteBuffer buf = ByteBuffer.allocate(value.length());
        byte[] bytes = value.getBytes();
        buf.put(bytes);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Short value) {
        ByteBuffer buf = ByteBuffer.allocate(2);
        buf.putShort(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Integer value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putInt(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Long value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putLong(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Float value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putFloat(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Double value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putDouble(value);
        return buf;
    }
    @Converter
    public static InputStream toInputStream(ByteBuffer bufferbuffer) {
        return IOConverter.toInputStream(toByteArray(bufferbuffer));
    }
}
"
org.apache.camel.converter.ObjectConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.util.Collection;
import java.util.Iterator;
import org.apache.camel.Converter;
import org.apache.camel.util.ObjectHelper;
/**
 * Some core java.lang based <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 664624 $
 */
@Converter
public final class ObjectConverter {
    /**
     * Utility classes should not have a public constructor.
     */
    private ObjectConverter() {
    }
    public static boolean isCollection(Object value) {
        // TODO we should handle primitive array types?
        return value instanceof Collection || (value != null && value.getClass().isArray());
    }
    /**
     * Creates an iterator over the value
     *
     * @deprecated use {@link org.apache.camel.util.ObjectHelper#createIterator(Object)}. Will be removed in Camel 2.0.
     */
    @SuppressWarnings(""unchecked"")
    @Converter
    @Deprecated
    public static Iterator iterator(Object value) {
        return ObjectHelper.createIterator(value);
    }
    /**
     * Converts the given value to a boolean, handling strings or Boolean
     * objects; otherwise returning false if the value could not be converted to
     * a boolean
     */
    @Converter
    public static boolean toBool(Object value) {
        Boolean answer = toBoolean(value);
        if (answer != null) {
            return answer.booleanValue();
        }
        return false;
    }
    /**
     * Converts the given value to a Boolean, handling strings or Boolean
     * objects; otherwise returning null if the value cannot be converted to a
     * boolean
     */
    @Converter
    public static Boolean toBoolean(Object value) {
        return ObjectHelper.toBoolean(value);
    }
    /**
     * Returns the boolean value, or null if the value is null
     */
    @Converter
    public static Boolean toBoolean(Boolean value) {
        if (value != null) {
            return value;
        }
        return Boolean.FALSE;
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Byte toByte(Object value) {
        if (value instanceof Byte) {
            return (Byte) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Byte.valueOf(number.byteValue());
        } else if (value instanceof String) {
            return Byte.valueOf((String) value);
        } else {
            return null;
        }
    }
    @Converter
    public static byte[] toByteArray(String value) {
        return value.getBytes();
    }
    @Converter
    public static char[] toCharArray(String value) {
        return value.toCharArray();
    }
    @Converter
    public static String fromCharArray(char[] value) {
        return new String(value);
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Short toShort(Object value) {
        if (value instanceof Short) {
            return (Short) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Short.valueOf(number.shortValue());
        } else if (value instanceof String) {
            return Short.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Integer toInteger(Object value) {
        if (value instanceof Integer) {
            return (Integer) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Integer.valueOf(number.intValue());
        } else if (value instanceof String) {
            return Integer.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Long toLong(Object value) {
        if (value instanceof Long) {
            return (Long) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Long.valueOf(number.longValue());
        } else if (value instanceof String) {
            return Long.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Float toFloat(Object value) {
        if (value instanceof Float) {
            return (Float) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Float.valueOf(number.floatValue());
        } else if (value instanceof String) {
            return Float.valueOf((String) value);
        } else {
            return null;
        }
    }
    /**
     * Returns the converted value, or null if the value is null
     */
    @Converter
    public static Double toDouble(Object value) {
        if (value instanceof Double) {
            return (Double) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return Double.valueOf(number.doubleValue());
        } else if (value instanceof String) {
            return Double.valueOf((String) value);
        } else {
            return null;
        }
    }
}
"
org.apache.camel.converter.ObjectConverterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.util.Iterator;
import junit.framework.TestCase;
/**
 * @version $Revision: 640438 $
 */
public class ObjectConverterTest extends TestCase {
    public void testArrayAsIterator() throws Exception {
        String[] data = {""a"", ""b""};
        Iterator iter = ObjectConverter.iterator(data);
        assertTrue(""should have next"", iter.hasNext());
        Object a = iter.next();
        assertEquals(""a"", ""a"", a);
        assertTrue(""should have next"", iter.hasNext());
        Object b = iter.next();
        assertEquals(""b"", ""b"", b);
        assertFalse(""should not have a next"", iter.hasNext());
    }
}
"
org.apache.camel.converter.StringSourceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import junit.framework.TestCase;
import org.apache.camel.TypeConverter;
import org.apache.camel.converter.jaxp.StringSource;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.util.ReflectionInjector;
/**
 * @version $Revision: 673954 $
 */
public class StringSourceTest extends TestCase {
    protected TypeConverter converter = new DefaultTypeConverter(new ReflectionInjector());
    protected String expectedBody = ""<hello>world!</hello>"";
    public void testSerialization() throws Exception {
        StringSource expected = new StringSource(expectedBody, ""mySystemID"", ""utf-8"");
        expected.setPublicId(""myPublicId"");
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        ObjectOutputStream output = new ObjectOutputStream(buffer);
        output.writeObject(expected);
        output.close();
        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));
        Object object = in.readObject();
        assertTrue(""is a StringSource"", object instanceof StringSource);
        StringSource actual = (StringSource) object;
        assertEquals(""source.text"", expected.getPublicId(), actual.getPublicId());
        assertEquals(""source.text"", expected.getSystemId(), actual.getSystemId());
        assertEquals(""source.text"", expected.getEncoding(), actual.getEncoding());
        assertEquals(""source.text"", expected.getText(), actual.getText());
        String value = converter.convertTo(String.class, actual);
        assertEquals(""text value of StringSource"", expectedBody, value);
    }
}
"
org.apache.camel.converter.jaxp.BytesSource,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import javax.xml.transform.stream.StreamSource;
/**
 * A helper class which provides a JAXP {@link javax.xml.transform.Source Source} from a byte[]
 * which can be read as many times as required.
 *
 * @version $Revision: 642753 $
 */
public class BytesSource extends StreamSource {
    private byte[] data;
    public BytesSource(byte[] data) {
        this.data = data;
    }
    public BytesSource(byte[] data, String systemId) {
        this.data = data;
        setSystemId(systemId);
    }
    public InputStream getInputStream() {
        return new ByteArrayInputStream(data);
    }
    public Reader getReader() {
        return new InputStreamReader(getInputStream());
    }
    public byte[] getData() {
        return data;
    }
    public String toString() {
        return ""BytesSource["" + new String(data) + ""]"";
    }
}
"
org.apache.camel.converter.jaxp.DomConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.apache.camel.Converter;
/**
 * Converts from some DOM types to Java types
 *
 * @version $Revision: 660275 $
 */
@Converter
public final class DomConverter {
    private DomConverter() {
        // Utility Class
    }
    @Converter
    public static String toString(NodeList nodeList) {
        StringBuffer buffer = new StringBuffer();
        append(buffer, nodeList);
        return buffer.toString();
    }
/*
    @Converter
    public static String toString(Node node) {
        StringBuffer buffer = new StringBuffer();
        append(buffer, node);
        return buffer.toString();
    }
*/
    protected static void append(StringBuffer buffer, NodeList nodeList) {
        int size = nodeList.getLength();
        for (int i = 0; i < size; i++) {
            append(buffer, nodeList.item(i));
        }
    }
    protected static void append(StringBuffer buffer, Node node) {
        if (node instanceof Text) {
            Text text = (Text) node;
            buffer.append(text.getTextContent());
        } else if (node instanceof Attr) {
            Attr attribute = (Attr) node;
            buffer.append(attribute.getTextContent());
        } else if (node instanceof Element) {
            Element element = (Element) node;
            append(buffer, element.getChildNodes());
        } else if (node instanceof Document) {
            Document doc = (Document) node;
            append(buffer, doc.getChildNodes());
        }
    }
}
"
org.apache.camel.converter.jaxp.StaxConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import org.apache.camel.Converter;
/**
 * A converter of StAX objects
 *
 * @version $Revision: 640438 $
 */
@Converter
public class StaxConverter {
    private XMLInputFactory inputFactory;
    private XMLOutputFactory outputFactory;
    @Converter
    public XMLEventWriter createXMLEventWriter(OutputStream out) throws XMLStreamException {
        return getOutputFactory().createXMLEventWriter(out);
    }
    @Converter
    public XMLEventWriter createXMLEventWriter(Writer writer) throws XMLStreamException {
        return getOutputFactory().createXMLEventWriter(writer);
    }
    @Converter
    public XMLEventWriter createXMLEventWriter(Result result) throws XMLStreamException {
        return getOutputFactory().createXMLEventWriter(result);
    }
    @Converter
    public XMLStreamWriter createXMLStreamWriter(OutputStream outputStream) throws XMLStreamException {
        return getOutputFactory().createXMLStreamWriter(outputStream);
    }
    @Converter
    public XMLStreamWriter createXMLStreamWriter(Writer writer) throws XMLStreamException {
        return getOutputFactory().createXMLStreamWriter(writer);
    }
    @Converter
    public XMLStreamWriter createXMLStreamWriter(Result result) throws XMLStreamException {
        return getOutputFactory().createXMLStreamWriter(result);
    }
    @Converter
    public XMLStreamReader createXMLStreamReader(InputStream in) throws XMLStreamException {
        return getInputFactory().createXMLStreamReader(in);
    }
    @Converter
    public XMLStreamReader createXMLStreamReader(Reader in) throws XMLStreamException {
        return getInputFactory().createXMLStreamReader(in);
    }
    @Converter
    public XMLStreamReader createXMLStreamReader(Source in) throws XMLStreamException {
        return getInputFactory().createXMLStreamReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(InputStream in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(Reader in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(XMLStreamReader in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    @Converter
    public XMLEventReader createXMLEventReader(Source in) throws XMLStreamException {
        return getInputFactory().createXMLEventReader(in);
    }
    // Properties
    //-------------------------------------------------------------------------
    public XMLInputFactory getInputFactory() {
        if (inputFactory == null) {
            inputFactory = XMLInputFactory.newInstance();
        }
        return inputFactory;
    }
    public void setInputFactory(XMLInputFactory inputFactory) {
        this.inputFactory = inputFactory;
    }
    public XMLOutputFactory getOutputFactory() {
        if (outputFactory == null) {
            outputFactory = XMLOutputFactory.newInstance();
        }
        return outputFactory;
    }
    public void setOutputFactory(XMLOutputFactory outputFactory) {
        this.outputFactory = outputFactory;
    }
}
"
org.apache.camel.converter.jaxp.StreamSourceConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.Converter;
/**
 * A converter from {@link StreamSource} objects
 *
 * @version $Revision: 669864 $
 */
@Converter
public class StreamSourceConverter {
    @Converter
    public InputStream toInputStream(StreamSource source) {
        return source.getInputStream();
    }
    @Converter
    public Reader toReader(StreamSource source) {
        return source.getReader();
    }
}
"
org.apache.camel.converter.jaxp.StringSource,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.Externalizable;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import javax.xml.transform.stream.StreamSource;
/**
 * A helper class which provides a JAXP {@link javax.xml.transform.Source Source} from a String which can
 * be read as many times as required.
 *
 * @version $Revision: 668062 $
 */
public class StringSource extends StreamSource implements Externalizable {
    private String text;
    private String encoding = ""UTF-8"";
    public StringSource() {
    }
    public StringSource(String text) {
        if (text == null) {
            throw new NullPointerException(""text can not be null"");
        }
        this.text = text;
    }
    public StringSource(String text, String systemId) {
        this(text);
        setSystemId(systemId);
    }
    public StringSource(String text, String systemId, String encoding) {
        this.text = text;
        this.encoding = encoding;
        setSystemId(systemId);
    }
    public InputStream getInputStream() {
        try {
            return new ByteArrayInputStream(text.getBytes(encoding));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
    public Reader getReader() {
        return new StringReader(text);
    }
    public String toString() {
        return ""StringSource["" + text + ""]"";
    }
    public String getText() {
        return text;
    }
    public String getEncoding() {
        return encoding;
    }
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    public void setText(String text) {
        this.text = text;
    }
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(text);
        out.writeUTF(encoding);
        out.writeUTF(getPublicId());
        out.writeUTF(getSystemId());
    }
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        text = in.readUTF();
        encoding = in.readUTF();
        setPublicId(in.readUTF());
        setSystemId(in.readUTF());
    }
}
"
org.apache.camel.converter.jaxp.XmlConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.lang.reflect.Constructor;
import java.nio.ByteBuffer;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.NIOConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A helper class to transform to and from various JAXB types such as {@link Source} and {@link Document}
 *
 * @version $Revision: 660275 $
 */
@Converter
public class XmlConverter {
    public static final String DEFAULT_CHARSET_PROPERTY = ""org.apache.camel.default.charset"";
    public static String defaultCharset = ObjectHelper.getSystemProperty(DEFAULT_CHARSET_PROPERTY, ""UTF-8"");
    /*
     * When converting a DOM tree to a SAXSource, we try to use Xalan internal DOM parser if
     * available. Else, transform the DOM tree to a String and build a SAXSource on top of it.
     */
    private static final Class DOM_TO_SAX_CLASS;
    private DocumentBuilderFactory documentBuilderFactory;
    private TransformerFactory transformerFactory;
    static {
        // TODO: Use ObjectHelper.loadClass instead
        Class cl = null;
        try {
            cl = Class.forName(""org.apache.xalan.xsltc.trax.DOM2SAX"");
        } catch (Throwable t) {
            // do nothing here
        }
        DOM_TO_SAX_CLASS = cl;
    }
    public XmlConverter() {
    }
    public XmlConverter(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }
    /**
     * Converts the given input Source into the required result
     */
    public void toResult(Source source, Result result) throws TransformerException {
        if (source == null) {
            return;
        }
        Transformer transformer = createTransfomer();
        if (transformer == null) {
            throw new TransformerException(""Could not create a transformer - JAXP is misconfigured!"");
        }
        transformer.setOutputProperty(OutputKeys.ENCODING, defaultCharset);
        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
        transformer.transform(source, result);
    }
    /**
     * Converts the given byte[] to a Source
     */
    @Converter
    public BytesSource toSource(byte[] data) {
        return new BytesSource(data);
    }
    /**
     * Converts the given String to a Source
     */
    @Converter
    public StringSource toSource(String data) {
        return new StringSource(data);
    }
    /**
     * Converts the given Document to a Source
     */
    @Converter
    public DOMSource toSource(Document document) {
        return new DOMSource(document);
    }
    /**
     * Converts the given Node to a Source
     */
    @Converter
    public Source toSource(Node node) {
        return new DOMSource(node);
    }
    /**
     * Converts the given input Source into text
     */
    @Converter
    public String toString(Source source) throws TransformerException {
        if (source == null) {
            return null;
        } else if (source instanceof StringSource) {
            return ((StringSource) source).getText();
        } else if (source instanceof BytesSource) {
            return new String(((BytesSource) source).getData());
        } else {
            StringWriter buffer = new StringWriter();
            toResult(source, new StreamResult(buffer));
            return buffer.toString();
        }
    }
    /**
     * Converts the given input Node into text
     */
/*
    @Converter
    public String toString(NodeList nodeList) throws TransformerException {
        StringWriter buffer = new StringWriter();
        for (int i = 0, size = nodeList.getLength(); i < size; i++) {
            Node node = nodeList.item(i);
            Source source = new DOMSource(node);
            toResult(source, new StreamResult(buffer));
        }
        return buffer.toString();
    }
*/
    /**
     * Converts the given input Node into text
     */
    @Converter
    public String toString(Node node) throws TransformerException {
        return toString(new DOMSource(node));
    }
    /**
     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        if (source instanceof DOMSource) {
            return (DOMSource) source;
        } else if (source instanceof SAXSource) {
            return toDOMSourceFromSAX((SAXSource) source);
        } else if (source instanceof StreamSource) {
            return toDOMSourceFromStream((StreamSource) source);
        } else {
            return null;
        }
    }
    /**
     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public DOMSource toDOMSource(String text) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        Source source = toSource(text);
        if (source != null) {
            return toDOMSourceFromStream((StreamSource) source);
        } else {
            return null;
        }
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(String source) throws IOException, SAXException, TransformerException {
        return toSAXSource(toSource(source));
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(InputStream source) throws IOException, SAXException, TransformerException {
        return toSAXSource(toStreamSource(source));
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {
        if (source instanceof SAXSource) {
            return (SAXSource) source;
        } else if (source instanceof DOMSource) {
            return toSAXSourceFromDOM((DOMSource) source);
        } else if (source instanceof StreamSource) {
            return toSAXSourceFromStream((StreamSource) source);
        } else {
            return null;
        }
    }
    @Converter
    public StreamSource toStreamSource(Source source) throws TransformerException {
        if (source instanceof StreamSource) {
            return (StreamSource) source;
        } else if (source instanceof DOMSource) {
            return toStreamSourceFromDOM((DOMSource) source);
        } else if (source instanceof SAXSource) {
            return toStreamSourceFromSAX((SAXSource) source);
        } else {
            return null;
        }
    }
    @Converter
    public StreamSource toStreamSource(InputStream in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(Reader in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(File in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(byte[] in) throws TransformerException {
        if (in != null) {
            return new StreamSource(IOConverter.toInputStream(in));
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(ByteBuffer in) throws TransformerException {
        if (in != null) {
            return new StreamSource(NIOConverter.toInputStream(in));
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {
        InputSource inputSource = source.getInputSource();
        if (inputSource != null) {
            if (inputSource.getCharacterStream() != null) {
                return new StreamSource(inputSource.getCharacterStream());
            }
            if (inputSource.getByteStream() != null) {
                return new StreamSource(inputSource.getByteStream());
            }
        }
        String result = toString(source);
        return new StringSource(result);
    }
    @Converter
    public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {
        String result = toString(source);
        return new StringSource(result);
    }
    @Converter
    public SAXSource toSAXSourceFromStream(StreamSource source) {
        InputSource inputSource;
        if (source.getReader() != null) {
            inputSource = new InputSource(source.getReader());
        } else {
            inputSource = new InputSource(source.getInputStream());
        }
        inputSource.setSystemId(source.getSystemId());
        inputSource.setPublicId(source.getPublicId());
        return new SAXSource(inputSource);
    }
    @Converter
    public Reader toReaderFromSource(Source src) throws TransformerException {
        StreamSource stSrc = toStreamSource(src);
        Reader r = stSrc.getReader();
        if (r == null) {
            r = new InputStreamReader(stSrc.getInputStream());
        }
        return r;
    }
    @Converter
    public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {
        DocumentBuilder builder = createDocumentBuilder();
        String systemId = source.getSystemId();
        Document document = null;
        Reader reader = source.getReader();
        if (reader != null) {
            document = builder.parse(new InputSource(reader));
        } else {
            InputStream inputStream = source.getInputStream();
            if (inputStream != null) {
                InputSource inputsource = new InputSource(inputStream);
                inputsource.setSystemId(systemId);
                document = builder.parse(inputsource);
            } else {
                throw new IOException(""No input stream or reader available"");
            }
        }
        return new DOMSource(document, systemId);
    }
    @Converter
    public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {
        if (DOM_TO_SAX_CLASS != null) {
            try {
                Constructor cns = DOM_TO_SAX_CLASS.getConstructor(Node.class);
                XMLReader converter = (XMLReader) cns.newInstance(source.getNode());
                return new SAXSource(converter, new InputSource());
            } catch (Exception e) {
                throw new TransformerException(e);
            }
        } else {
            String str = toString(source);
            StringReader reader = new StringReader(str);
            return new SAXSource(new InputSource(reader));
        }
    }
    @Converter
    public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {
        return new DOMSource(toDOMNodeFromSAX(source));
    }
    @Converter
    public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        DOMResult result = new DOMResult();
        toResult(source, result);
        return result.getNode();
    }
    /**
     * Converts the given TRaX Source into a W3C DOM node
     * @throws SAXException
     * @throws IOException
     * @throws ParserConfigurationException
     */
    @Converter
    public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        DOMSource domSrc = toDOMSource(source);
        return domSrc != null ? domSrc.getNode() :  null;
    }
    /**
     * Create a DOM element from the given source.
     */
    @Converter
    public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMElement(node);
    }
    /**
     * Create a DOM element from the DOM node.
     * Simply cast if the node is an Element, or
     * return the root element if it is a Document.
     */
    @Converter
    public Element toDOMElement(Node node) throws TransformerException {
        // If the node is an document, return the root element
        if (node instanceof Document) {
            return ((Document) node).getDocumentElement();
        // If the node is an element, just cast it
        } else if (node instanceof Element) {
            return (Element) node;
        // Other node types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to an Element"");
        }
    }
    /**
     * Converts the given data to a DOM document
     *
     * @param data is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(new ByteArrayInputStream(data));
    }
    /**
     * Converts the given {@link InputStream} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }
    /**
     * Converts the given {@link InputStream} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(Reader in) throws IOException, SAXException, ParserConfigurationException {
        return toDOMDocument(new InputSource(in));
    }
    /**
     * Converts the given {@link InputSource} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }
    /**
     * Converts the given {@link String} to a DOM document
     *
     * @param text is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException {
        return toDOMDocument(new StringReader(text));
    }
    /**
     * Converts the given {@link File} to a DOM document
     *
     * @param file is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(file);
    }
    /**
     * Create a DOM document from the given source.
     */
    @Converter
    public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMDocument(node);
    }
    /**
     * Create a DOM document from the given Node.
     * If the node is an document, just cast it,
     * if the node is an root element, retrieve its
     * owner element or create a new document and import
     * the node.
     */
    @Converter
    public Document toDOMDocument(Node node) throws ParserConfigurationException, TransformerException {
        // If the node is the document, just cast it
        if (node instanceof Document) {
            return (Document) node;
        // If the node is an element
        } else if (node instanceof Element) {
            Element elem = (Element) node;
            // If this is the root element, return its owner document
            if (elem.getOwnerDocument().getDocumentElement() == elem) {
                return elem.getOwnerDocument();
            // else, create a new doc and copy the element inside it
            } else {
                Document doc = createDocument();
                doc.appendChild(doc.importNode(node, true));
                return doc;
            }
        // other element types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to a Document"");
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory getDocumentBuilderFactory() {
        if (documentBuilderFactory == null) {
            documentBuilderFactory = createDocumentBuilderFactory();
        }
        return documentBuilderFactory;
    }
    public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }
    // Helper methods
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory createDocumentBuilderFactory() {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setIgnoringElementContentWhitespace(true);
        factory.setIgnoringComments(true);
        return factory;
    }
    public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = getDocumentBuilderFactory();
        return factory.newDocumentBuilder();
    }
    public Document createDocument() throws ParserConfigurationException {
        DocumentBuilder builder = createDocumentBuilder();
        return builder.newDocument();
    }
    public TransformerFactory getTransformerFactory() {
        if (transformerFactory == null) {
            transformerFactory = createTransformerFactory();
        }
        return transformerFactory;
    }
    public void setTransformerFactory(TransformerFactory transformerFactory) {
        this.transformerFactory = transformerFactory;
    }
    public Transformer createTransfomer() throws TransformerConfigurationException {
        TransformerFactory factory = getTransformerFactory();
        return factory.newTransformer();
    }
    public TransformerFactory createTransformerFactory() {
        TransformerFactory answer = TransformerFactory.newInstance();
        return answer;
    }
}
"
org.apache.camel.converter.stream.StreamCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.stream;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
/**
 * Tagging interface to indicate that a type is capable of caching the underlying data stream.
 * <p/>
 * This is a useful feature for avoid message re-readability issues.
 * This interface is mainly used by the {@link StreamCachingInterceptor} for determining if/how to wrap a
 * stream-based message.
 */
public interface StreamCache {
}
"
org.apache.camel.converter.stream.StreamCacheConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.stream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import javax.xml.transform.TransformerException;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.jaxp.StringSource;
import org.apache.camel.converter.jaxp.XmlConverter;
/**
 * A set of {@link Converter} methods for wrapping stream-based messages in a {@link StreamCache}
 * implementation to ensure message re-readability (eg multicasting, retrying)
 */
@Converter
public class StreamCacheConverter {
    private XmlConverter converter = new XmlConverter();
    @Converter
    public StreamCache convertToStreamCache(StreamSource source) throws TransformerException {
        //TODO: we can probably build a more generic converter method to support other kinds of Sources as well (e.g. SAXSource, StAXSource, ...)
        return new StreamSourceCache(converter.toString(source));
    }
    @Converter
    public StreamCache convertToStreamCache(InputStream stream) throws IOException {
        return new InputStreamCache(IOConverter.toBytes(stream));
    }
    private class StreamSourceCache extends StringSource implements StreamCache {
        private static final long serialVersionUID = 4147248494104812945L;
        public StreamSourceCache(String text) {
            super(text);
        }
    }
    private class InputStreamCache extends ByteArrayInputStream implements StreamCache {
        public InputStreamCache(byte[] data) {
            super(data);
        }
    }
}
"
org.apache.camel.converter.stream.StreamCacheConverterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.stream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import javax.xml.transform.TransformerException;
import javax.xml.transform.stream.StreamSource;
import junit.framework.TestCase;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.jaxp.XmlConverter;
/**
 * Test cases for {@link StreamCacheConverter}
 */
public class StreamCacheConverterTest extends TestCase {
    private static final String TEST_FILE = ""org/apache/camel/converter/stream/test.xml"";
    private StreamCacheConverter converter;
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        this.converter = new StreamCacheConverter();
    }
    public void testConvertToStreamCacheStreamSource() throws TransformerException, FileNotFoundException {
        StreamSource source = new StreamSource(getTestFileStream());
        StreamSource cache = (StreamSource) converter.convertToStreamCache(source);
        //assert re-readability of the cached StreamSource
        XmlConverter converter = new XmlConverter();
        assertNotNull(converter.toString(cache));
        assertNotNull(converter.toString(cache));
    }
    public void testConvertToStreamCacheInputStream() throws IOException {
        InputStream is = getTestFileStream();
        InputStream cache = (InputStream)converter.convertToStreamCache(is);
        //assert re-readability of the cached InputStream
        assertNotNull(IOConverter.toString(cache));
        assertNotNull(IOConverter.toString(cache));
    }
    protected InputStream getTestFileStream() {
        InputStream answer = getClass().getClassLoader().getResourceAsStream(TEST_FILE);
        assertNotNull(""Should have found the file: "" + TEST_FILE + "" on the classpath"", answer);
        return answer;
    }
}
"
org.apache.camel.impl.BinaryPredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A useful base class for {@link Predicate} implementations
 * 
 * @version $Revision: 630591 $
 */
public abstract class BinaryPredicateSupport<E extends Exchange> implements Predicate<E> {
    private final Expression<E> left;
    private final Expression<E> right;
    protected BinaryPredicateSupport(Expression<E> left, Expression<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        this.left = left;
        this.right = right;
    }
    @Override
    public String toString() {
        return left + "" "" + getOperationText() + "" "" + right;
    }
    public boolean matches(E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        return matches(exchange, leftValue, rightValue);
    }
    public void assertMatches(String text, E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        if (!matches(exchange, leftValue, rightValue)) {
            throw new AssertionError(text + assertionFailureMessage(exchange, leftValue, rightValue));
        }
    }
    protected abstract boolean matches(E exchange, Object leftValue, Object rightValue);
    protected abstract String getOperationText();
    protected String assertionFailureMessage(E exchange, Object leftValue, Object rightValue) {
        return this + "" failed on "" + exchange + "" with left value <"" + leftValue + ""> right value <""
               + rightValue + "">"";
    }
}
"
org.apache.camel.impl.CustomExchangePatternTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class CustomExchangePatternTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testInOut() throws Exception {
        final ExchangePattern expectedPattern = ExchangePattern.InOut;
        template.send(""direct:start"", expectedPattern, new Processor() {
            public void process(Exchange exchange) throws Exception {
                assertEquals(""MEP"", expectedPattern, exchange.getPattern());
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertReceivedExpectedPattern(expectedPattern);
    }
    public void testInOnly() throws Exception {
        ExchangePattern expectedPattern = ExchangePattern.InOnly;
        template.send(""direct:start"", expectedPattern, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertReceivedExpectedPattern(expectedPattern);
    }
    public void testInOutViaUri() throws Exception {
        final ExchangePattern expectedPattern = ExchangePattern.InOut;
        template.send(""direct:start?exchangePattern=InOut"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                assertEquals(""MEP"", expectedPattern, exchange.getPattern());
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertReceivedExpectedPattern(expectedPattern);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
    }
    protected void assertReceivedExpectedPattern(ExchangePattern expectedPattern) {
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        Exchange exchange = list.get(0);
        assertEquals(""MEP"", expectedPattern, exchange.getPattern());
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""mock:result"");
                from(""direct:start?exchangePattern=InOut"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.impl.DefaultCamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import javax.naming.Context;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.Route;
import org.apache.camel.Routes;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Service;
import org.apache.camel.TypeConverter;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.management.InstrumentationLifecycleStrategy;
import org.apache.camel.management.JmxSystemPropertyKeys;
import org.apache.camel.model.RouteType;
import org.apache.camel.processor.interceptor.Tracer;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ReflectionInjector;
import org.apache.camel.util.SystemHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;
/**
 * Represents the context used to configure routes and the policies to use.
 *
 * @version $Revision: 677554 $
 */
public class DefaultCamelContext extends ServiceSupport implements CamelContext, Service {
    private static final transient Log LOG = LogFactory.getLog(DefaultCamelContext.class);
    private static final String NAME_PREFIX = ""camel-"";
    private static int nameSuffix;
    private String name;
    private final Map<String, Endpoint> endpoints = new HashMap<String, Endpoint>();
    private final Map<String, Component> components = new HashMap<String, Component>();
    private List<Route> routes;
    private List<Service> servicesToClose = new ArrayList<Service>();
    private TypeConverter typeConverter;
    private ExchangeConverter exchangeConverter;
    private Injector injector;
    private ComponentResolver componentResolver;
    private boolean autoCreateComponents = true;
    private LanguageResolver languageResolver = new DefaultLanguageResolver();
    private Registry registry;
    private LifecycleStrategy lifecycleStrategy;
    private List<RouteType> routeDefinitions = new ArrayList<RouteType>();
    private List<InterceptStrategy> interceptStrategies = new ArrayList<InterceptStrategy>();
    private Boolean trace;
    private ErrorHandlerBuilder errorHandlerBuilder;
    public DefaultCamelContext() {
        name = NAME_PREFIX + ++nameSuffix;
        if (Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
            LOG.info(""JMX is disabled. Using DefaultLifecycleStrategy."");
            lifecycleStrategy = new DefaultLifecycleStrategy();
        } else {
            try {
                LOG.info(""JMX enabled. Using InstrumentationLifecycleStrategy."");
                lifecycleStrategy = new InstrumentationLifecycleStrategy();
            } catch (NoClassDefFoundError e) {
                // if we can't instantiate the JMX enabled strategy then fallback to default
                // could be because of missing .jars on the classpath
                LOG.warn(""Could not find needed classes for JMX lifecycle strategy.""
                    + "" Are you missing spring-context.jar by any chance? NoClassDefFoundError: "" + e.getMessage());
            } catch (Exception e) {
                LOG.warn(""Could not create JMX lifecycle strategy, caused by: "" + e.getMessage());
            }
            // if not created then fallback to default
            if (lifecycleStrategy == null) {
                LOG.warn(""Not possible to use JMX lifecycle strategy. Using DefaultLifecycleStrategy instead."");
                lifecycleStrategy = new DefaultLifecycleStrategy();
            }
        }
    }
    /**
     * Creates the {@link CamelContext} using the given JNDI context as the
     * registry
     *
     * @param jndiContext
     */
    public DefaultCamelContext(Context jndiContext) {
        this(new JndiRegistry(jndiContext));
    }
    /**
     * Creates the {@link CamelContext} using the given registry
     */
    public DefaultCamelContext(Registry registry) {
        this();
        this.registry = registry;
    }
    public String getName() {
        return name;
    }
    /**
     * Sets the name of the this context.
     */
    public void setName(String name) {
        this.name = name;
    }
    public void addComponent(String componentName, final Component component) {
        if (component == null) {
            throw new IllegalArgumentException(""Component cannot be null"");
        }
        synchronized (components) {
            if (components.containsKey(componentName)) {
                throw new IllegalArgumentException(""Component previously added: "" + componentName);
            }
            component.setCamelContext(this);
            components.put(componentName, component);
        }
    }
    public Component getComponent(String name) {
        // synchronize the look up and auto create so that 2 threads can't
        // concurrently auto create the same component.
        synchronized (components) {
            Component component = components.get(name);
            if (component == null && autoCreateComponents) {
                try {
                    component = getComponentResolver().resolveComponent(name, this);
                    if (component != null) {
                        addComponent(name, component);
                        if (isStarted()) {
                            // If the component is looked up after the context
                            // is started,
                            // lets start it up.
                            startServices(component);
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeCamelException(""Could not auto create component: "" + name, e);
                }
            }
            return component;
        }
    }
    public <T extends Component> T getComponent(String name, Class<T> componentType) {
        Component component = getComponent(name);
        if (componentType.isInstance(component)) {
            return componentType.cast(component);
        } else {
            throw new IllegalArgumentException(""The component is not of type: "" + componentType + "" but is: ""
                    + component);
        }
    }
    public Component removeComponent(String componentName) {
        synchronized (components) {
            return components.remove(componentName);
        }
    }
    public Component getOrCreateComponent(String componentName, Callable<Component> factory) {
        synchronized (components) {
            Component component = components.get(componentName);
            if (component == null) {
                try {
                    component = factory.call();
                    if (component == null) {
                        throw new RuntimeCamelException(""Factory failed to create the "" + componentName
                                + "" component, it returned null."");
                    }
                    components.put(componentName, component);
                    component.setCamelContext(this);
                } catch (Exception e) {
                    throw new RuntimeCamelException(""Factory failed to create the "" + componentName
                            + "" component"", e);
                }
            }
            return component;
        }
    }
    // Endpoint Management Methods
    // -----------------------------------------------------------------------
    public Collection<Endpoint> getSingletonEndpoints() {
        synchronized (endpoints) {
            return new ArrayList<Endpoint>(endpoints.values());
        }
    }
    public Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception {
        Endpoint oldEndpoint;
        synchronized (endpoints) {
            startServices(endpoint);
            oldEndpoint = endpoints.remove(uri);
            endpoints.put(uri, endpoint);
            stopServices(oldEndpoint);
        }
        return oldEndpoint;
    }
    public Endpoint removeSingletonEndpoint(String uri) throws Exception {
        Endpoint oldEndpoint;
        synchronized (endpoints) {
            oldEndpoint = endpoints.remove(uri);
            stopServices(oldEndpoint);
        }
        return oldEndpoint;
    }
    public Endpoint getEndpoint(String uri) {
        Endpoint answer;
        synchronized (endpoints) {
            answer = endpoints.get(uri);
            if (answer == null) {
                try {
                    // Use the URI prefix to find the component.
                    String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                    if (splitURI[1] != null) {
                        String scheme = splitURI[0];
                        Component component = getComponent(scheme);
                        // Ask the component to resolve the endpoint.
                        if (component != null) {
                            // Have the component create the endpoint if it can.
                            answer = component.createEndpoint(uri);
                            if (answer != null && LOG.isDebugEnabled()) {
                                LOG.debug(uri + "" converted to endpoint: "" + answer + "" by component: "" + component);
                            }
                        }
                    }
                    if (answer == null) {
                        answer = createEndpoint(uri);
                    }
                    // If it's a singleton then auto register it.
                    if (answer != null) {
                        addService(answer);
                        if (answer.isSingleton()) {
                            endpoints.put(uri, answer);
                            // TODO we should support non-singletons in the lifecycle
                            lifecycleStrategy.onEndpointAdd(answer);
                        }
                    }
                } catch (Exception e) {
                    LOG.debug(""Failed to resolve endpoint "" + uri + "". Reason: "" + e, e);
                    throw new ResolveEndpointFailedException(uri, e);
                }
            }
        }
        return answer;
    }
    public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {
        Endpoint endpoint = getEndpoint(name);
        if (endpointType.isInstance(endpoint)) {
            return endpointType.cast(endpoint);
        } else {
            throw new IllegalArgumentException(""The endpoint is not of type: "" + endpointType + "" but is: ""
                    + endpoint);
        }
    }
    // Route Management Methods
    // -----------------------------------------------------------------------
    public List<Route> getRoutes() {
        if (routes == null) {
            routes = new ArrayList<Route>();
        }
        return routes;
    }
    public void setRoutes(List<Route> routes) {
        this.routes = routes;
    }
    public void addRoutes(Collection<Route> routes) throws Exception {
        if (this.routes == null) {
            this.routes = new ArrayList<Route>(routes);
        } else {
            this.routes.addAll(routes);
        }
        lifecycleStrategy.onRoutesAdd(routes);
        if (shouldStartRoutes()) {
            startRoutes(routes);
        }
    }
    public void addRoutes(Routes builder) throws Exception {
        // lets now add the routes from the builder
        builder.setContext(this);
        List<Route> routeList = builder.getRouteList();
        LOG.debug(""Adding routes from: "" + builder + "" routes: "" + routeList);
        addRoutes(routeList);
    }
    public void addRouteDefinitions(Collection<RouteType> routeDefinitions) throws Exception {
        this.routeDefinitions.addAll(routeDefinitions);
        if (shouldStartRoutes()) {
            startRouteDefinitions(routeDefinitions);
        }
    }
    /**
     * Adds a service, starting it so that it will be stopped with this context
     */
    public void addService(Object object) throws Exception {
        if (object instanceof Service) {
            Service service = (Service) object;
            service.start();
            servicesToClose.add(service);
        }
    }
    // Helper methods
    // -----------------------------------------------------------------------
    public Language resolveLanguage(String language) {
        return getLanguageResolver().resolveLanguage(language, this);
    }
    // Properties
    // -----------------------------------------------------------------------
    public ExchangeConverter getExchangeConverter() {
        if (exchangeConverter == null) {
            exchangeConverter = createExchangeConverter();
        }
        return exchangeConverter;
    }
    public void setExchangeConverter(ExchangeConverter exchangeConverter) {
        this.exchangeConverter = exchangeConverter;
    }
    public TypeConverter getTypeConverter() {
        if (typeConverter == null) {
            typeConverter = createTypeConverter();
        }
        return typeConverter;
    }
    public void setTypeConverter(TypeConverter typeConverter) {
        this.typeConverter = typeConverter;
    }
    public Injector getInjector() {
        if (injector == null) {
            injector = createInjector();
        }
        return injector;
    }
    public void setInjector(Injector injector) {
        this.injector = injector;
    }
    public ComponentResolver getComponentResolver() {
        if (componentResolver == null) {
            componentResolver = createComponentResolver();
        }
        return componentResolver;
    }
    public void setComponentResolver(ComponentResolver componentResolver) {
        this.componentResolver = componentResolver;
    }
    public LanguageResolver getLanguageResolver() {
        return languageResolver;
    }
    public void setLanguageResolver(LanguageResolver languageResolver) {
        this.languageResolver = languageResolver;
    }
    public boolean isAutoCreateComponents() {
        return autoCreateComponents;
    }
    public void setAutoCreateComponents(boolean autoCreateComponents) {
        this.autoCreateComponents = autoCreateComponents;
    }
    public Registry getRegistry() {
        if (registry == null) {
            registry = createRegistry();
        }
        return registry;
    }
    public void setRegistry(Registry registry) {
        this.registry = registry;
    }
    public LifecycleStrategy getLifecycleStrategy() {
        return lifecycleStrategy;
    }
    public void setLifecycleStrategy(LifecycleStrategy lifecycleStrategy) {
        this.lifecycleStrategy = lifecycleStrategy;
    }
    public List<RouteType> getRouteDefinitions() {
        return routeDefinitions;
    }
    public List<InterceptStrategy> getInterceptStrategies() {
        return interceptStrategies;
    }
    public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {
        this.interceptStrategies = interceptStrategies;
    }
    public void addInterceptStrategy(InterceptStrategy interceptStrategy) {
        getInterceptStrategies().add(interceptStrategy);
    }
    /**
     * Returns true if tracing has been enabled or disabled via the {@link #setTrace(Boolean)} method
     * or it has not been specified then default to the <b>camel.trace</b> system property
     */
    public boolean getTrace() {
        final Boolean value = getTracing();
        if (value != null) {
            return value;
        } else {
            return SystemHelper.isSystemProperty(""canel.trace"");
        }
    }
    public Boolean getTracing() {
        return trace;
    }
    public void setTrace(Boolean trace) {
        this.trace = trace;
    }
    public <E extends Exchange> ProducerTemplate<E> createProducerTemplate() {
        return new DefaultProducerTemplate<E>(this);
    }
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        return errorHandlerBuilder;
    }
    /**
     * Sets the default error handler builder which is inherited by the routes
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void doStart() throws Exception {
        if (getTrace()) {
            // lets check if we already have already been configured and if not add the default
            boolean found = false;
            final List<InterceptStrategy> list = getInterceptStrategies();
            for (InterceptStrategy strategy : list) {
                if (strategy instanceof Tracer) {
                    found = true;
                }
            }
            if (!found) {
                addInterceptStrategy(new Tracer());
            }
        }
        lifecycleStrategy.onContextStart(this);
        forceLazyInitialization();
        if (components != null) {
            for (Component component : components.values()) {
                startServices(component);
            }
        }
        startRouteDefinitions(routeDefinitions);
        startRoutes(routes);
    }
    protected void startRouteDefinitions(Collection<RouteType> list) throws Exception {
        if (list != null) {
            Collection<Route> routes = new ArrayList<Route>();
            for (RouteType route : list) {
                route.addRoutes(this, routes);
            }
            addRoutes(routes);
        }
    }
    protected void doStop() throws Exception {
        stopServices(servicesToClose);
        if (components != null) {
            for (Component component : components.values()) {
                stopServices(component);
            }
        }
    }
    protected void startRoutes(Collection<Route> routeList) throws Exception {
        if (routeList != null) {
            for (Route<Exchange> route : routeList) {
                List<Service> services = route.getServicesForRoute();
                for (Service service : services) {
                    addService(service);
                }
            }
        }
    }
    /**
     * Lets force some lazy initialization to occur upfront before we start any
     * components and create routes
     */
    protected void forceLazyInitialization() {
        getExchangeConverter();
        getInjector();
        getLanguageResolver();
        getTypeConverter();
    }
    /**
     * Lazily create a default implementation
     */
    protected ExchangeConverter createExchangeConverter() {
        return new DefaultExchangeConverter();
    }
    /**
     * Lazily create a default implementation
     */
    protected TypeConverter createTypeConverter() {
        return new DefaultTypeConverter(getInjector());
    }
    /**
     * Lazily create a default implementation
     */
    protected Injector createInjector() {
        FactoryFinder finder = new FactoryFinder();
        try {
            return (Injector) finder.newInstance(""Injector"");
        } catch (NoFactoryAvailableException e) {
            // lets use the default
            return new ReflectionInjector();
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e);
        } catch (IOException e) {
            throw new RuntimeCamelException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Lazily create a default implementation
     */
    protected ComponentResolver createComponentResolver() {
        return new DefaultComponentResolver();
    }
    /**
     * Lazily create a default implementation
     */
    protected Registry createRegistry() {
        return new JndiRegistry();
    }
    /**
     * A pluggable strategy to allow an endpoint to be created without requiring
     * a component to be its factory, such as for looking up the URI inside some
     * {@link Registry}
     *
     * @param uri the uri for the endpoint to be created
     * @return the newly created endpoint or null if it could not be resolved
     */
    protected Endpoint createEndpoint(String uri) {
        Object value = getRegistry().lookup(uri);
        if (value instanceof Endpoint) {
            return (Endpoint) value;
        } else if (value instanceof Processor) {
            return new ProcessorEndpoint(uri, this, (Processor) value);
        } else if (value != null) {
            return convertBeanToEndpoint(uri, value);
        }
        return null;
    }
    /**
     * Attempt to convert the bean from a {@link Registry} to an endpoint using
     * some kind of transformation or wrapper
     *
     * @param uri  the uri for the endpoint (and name in the registry)
     * @param bean the bean to be converted to an endpoint, which will be not null
     * @return a new endpoint
     */
    protected Endpoint convertBeanToEndpoint(String uri, Object bean) {
        throw new IllegalArgumentException(""uri: "" + uri + "" bean: "" + bean
                + "" could not be converted to an Endpoint"");
    }
    /**
     * Should we start newly added routes?
     */
    protected boolean shouldStartRoutes() {
        return isStarted() && !isStarting();
    }
}
"
org.apache.camel.impl.DefaultCamelContextTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import junit.framework.TestCase;
import org.apache.camel.Component;
import org.apache.camel.component.bean.BeanComponent;
/**
 * @version $Revision: 630568 $
 */
public class DefaultCamelContextTest extends TestCase {
    public void testAutoCreateComponentsOn() {
        DefaultCamelContext ctx = new DefaultCamelContext();
        Component component = ctx.getComponent(""bean"");
        assertNotNull(component);
        assertEquals(component.getClass(), BeanComponent.class);
    }
    public void testAutoCreateComponentsOff() {
        DefaultCamelContext ctx = new DefaultCamelContext();
        ctx.setAutoCreateComponents(false);
        Component component = ctx.getComponent(""bean"");
        assertNull(component);
    }
}
"
org.apache.camel.impl.DefaultComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.net.URI;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.URISupport;
import org.apache.camel.util.UnsafeUriCharactersEncoder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Default component to use for base for components implementations.
 *
 * @version $Revision: 676850 $
 */
public abstract class DefaultComponent<E extends Exchange> extends ServiceSupport implements Component<E> {
    private static final transient Log LOG = LogFactory.getLog(DefaultComponent.class);
    private int defaultThreadPoolSize = 5;
    private CamelContext camelContext;
    private ScheduledExecutorService executorService;
    public DefaultComponent() {
    }
    public DefaultComponent(CamelContext context) {
        this.camelContext = context;
    }
    public Endpoint<E> createEndpoint(String uri) throws Exception {
        ObjectHelper.notNull(getCamelContext(), ""camelContext"");
        //encode URI string to the unsafe URI characters
        URI u = new URI(UnsafeUriCharactersEncoder.encode(uri));
        String path = u.getSchemeSpecificPart();
        // lets trim off any query arguments
        if (path.startsWith(""//"")) {
            path = path.substring(2);
        }
        int idx = path.indexOf('?');
        if (idx > 0) {
            path = path.substring(0, idx);
        }
        Map parameters = URISupport.parseParameters(u);
        validateURI(uri, path, parameters);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating endpoint uri=["" + uri + ""], path=["" + path + ""], parameters=["" + parameters + ""]"");
        }
        Endpoint<E> endpoint = createEndpoint(uri, path, parameters);
        if (endpoint == null) {
            return null;
        }
        if (parameters != null) {
            endpoint.configureProperties(parameters);
            if (useIntrospectionOnEndpoint()) {
                setProperties(endpoint, parameters);
            }
            // fail if there are parameters that could not be set, then they are probably miss spelt or not supported at all
            if (parameters.size() > 0) {
                throw new ResolveEndpointFailedException(uri, ""There are "" + parameters.size()
                    + "" parameters that couldn't be set on the endpoint.""
                    + "" Check the uri if the parameters are spelt correctly and that they are properties of the endpoint.""
                    + "" Unknown parameters=["" + parameters + ""]"");
            }
        }
        return endpoint;
    }
    /**
     * Strategy for validation of the uri when creating the endpoint.
     *
     * @param uri        the uri - the uri the end user provided untouched
     * @param path       the path - part after the scheme
     * @param parameters the parameters, an empty map if no parameters given
     * @throws ResolveEndpointFailedException should be thrown if the URI validation failed
     */
    protected void validateURI(String uri, String path, Map parameters) throws ResolveEndpointFailedException {
        // check for uri containing & but no ? marker
        if (uri.contains(""&"") && !uri.contains(""?"")) {
            throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: no ? marker however the uri ""
                + ""has & parameter separators. Check the uri if its missing a ? marker."");
        }
        // check for uri containing double && markers
        if (uri.contains(""&&"")) {
            throw new ResolveEndpointFailedException(uri, ""Invalid uri syntax: Double && marker found. ""
                + ""Check the uri and remove the duplicate & marker."");
        }
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext context) {
        this.camelContext = context;
    }
    public ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            executorService = createExecutorService();
        }
        return executorService;
    }
    public void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }
    /**
     * A factory method to create a default thread pool and executor
     */
    protected ScheduledExecutorService createExecutorService() {
        return new ScheduledThreadPoolExecutor(defaultThreadPoolSize, new ThreadFactory() {
            int counter;
            public synchronized Thread newThread(Runnable runnable) {
                Thread thread = new Thread(runnable);
                thread.setName(""Thread: "" + (++counter) + "" "" + DefaultComponent.this.toString());
                return thread;
            }
        });
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
        if (executorService != null) {
            executorService.shutdown();
        }
    }
    /**
     * A factory method allowing derived components to create a new endpoint
     * from the given URI, remaining path and optional parameters
     *
     * @param uri the full URI of the endpoint
     * @param remaining the remaining part of the URI without the query
     *                parameters or component prefix
     * @param parameters the optional parameters passed in
     * @return a newly created endpoint or null if the endpoint cannot be
     *         created based on the inputs
     */
    protected abstract Endpoint<E> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception;
    /**
     * Sets the bean properties on the given bean
     */
    protected void setProperties(Object bean, Map parameters) throws Exception {
        IntrospectionSupport.setProperties(getCamelContext().getTypeConverter(), bean, parameters);
    }
    /**
     * Derived classes may wish to overload this to prevent the default introspection of URI parameters
     * on the created Endpoint instance
     */
    protected boolean useIntrospectionOnEndpoint() {
        return true;
    }
    // Some helper methods
    //-------------------------------------------------------------------------
    /**
     * Converts the given value to the requested type
     */
    public <T> T convertTo(Class<T> type, Object value) {
        return CamelContextHelper.convertTo(getCamelContext(), type, value);
    }
    /**
     * Converts the given value to the specified type throwing an {@link IllegalArgumentException}
     * if the value could not be converted to a non null value
     */
    public  <T> T mandatoryConvertTo(Class<T> type, Object value) {
        return CamelContextHelper.mandatoryConvertTo(getCamelContext(), type, value);
    }
    /**
     * Creates a new instance of the given type using the {@link Injector} on the given
     * {@link CamelContext}
     */
    public  <T> T newInstance(Class<T> beanType) {
        return getCamelContext().getInjector().newInstance(beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext}
     */
    public Object lookup(String name) {
        return getCamelContext().getRegistry().lookup(name);
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public <T> T lookup(String name, Class<T> beanType) {
        return getCamelContext().getRegistry().lookup(name, beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext} or throws
     */
    public Object mandatoryLookup(String name) {
        return CamelContextHelper.mandatoryLookup(getCamelContext(), name);
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public <T> T mandatoryLookup(String name, Class<T> beanType) {
        return CamelContextHelper.mandatoryLookup(getCamelContext(), name, beanType);
    }
    /**
     * Gets the parameter and remove it from the parameter map.
     * 
     * @param parameters  the parameters
     * @param key        the key
     * @param type       the requested type to convert the value from the parameter
     * @return  the converted value parameter, <tt>null</tt> if parameter does not exists.
     */
    public <T> T getAndRemoveParameter(Map parameters, String key, Class<T> type) {
        return getAndRemoveParameter(parameters, key, type, null);
    }
    /**
     * Gets the parameter and remove it from the parameter map.
     *
     * @param parameters     the parameters
     * @param key           the key
     * @param type          the requested type to convert the value from the parameter
     * @param defaultValue  use this default value if the parameter does not contain the key
     * @return  the converted value parameter
     */
    public <T> T getAndRemoveParameter(Map parameters, String key, Class<T> type, T defaultValue) {
        Object value = parameters.remove(key);
        if (value == null) {
            value = defaultValue;
        }
        if (value == null) {
            return null;
        }
        return convertTo(type, value);
    }
}
"
org.apache.camel.impl.DefaultComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The default implementation of {@link ComponentResolver} which tries to find
 * components by using the URI scheme prefix and searching for a file of the URI
 * scheme name in the <b>META-INF/services/org/apache/camel/component/</b>
 * directory on the classpath.
 *
 * @version $Revision: 640438 $
 */
public class DefaultComponentResolver<E extends Exchange> implements ComponentResolver<E> {
    protected static final FactoryFinder COMPONENT_FACTORY =
            new FactoryFinder(""META-INF/services/org/apache/camel/component/"");
    private static final transient Log LOG = LogFactory.getLog(DefaultComponentResolver.class);
    public Component<E> resolveComponent(String name, CamelContext context) {
        Object bean = null;
        try {
            bean = context.getRegistry().lookup(name);
            if (bean != null && LOG.isDebugEnabled()) {
                LOG.debug(""Found component: "" + name + "" in registry: "" + bean);
            }
        } catch (Exception e) {
            LOG.debug(""Ignored error looking up bean: "" + name + "". Error: "" + e);
        }
        if (bean != null) {
            if (bean instanceof Component) {
                return (Component) bean;
            }
            // we do not throw the exception here and try to auto create a component
        }
        Class type;
        try {
            type = COMPONENT_FACTORY.findClass(name);
        } catch (NoFactoryAvailableException e) {
            return null;
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Component registered for scheme : ""
                    + name, e);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found component: "" + name + "" via type: "" + type.getName() + "" via "" + COMPONENT_FACTORY.getPath() + name);
        }
        if (type == null) {
            return null;
        }
        if (Component.class.isAssignableFrom(type)) {
            return (Component<E>) context.getInjector().newInstance(type);
        } else {
            throw new IllegalArgumentException(""Type is not a Component implementation. Found: ""
                    + type.getName());
        }
    }
}
"
org.apache.camel.impl.DefaultComponentTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
/**
 * Unit test for helper methods on the DefaultComponent.
 */
public class DefaultComponentTest extends ContextTestSupport {
    private final class MyComponent extends DefaultComponent<DefaultExchange> {
        private MyComponent(CamelContext context) {
            super(context);
        }
        protected Endpoint<DefaultExchange> createEndpoint(String uri, String remaining, Map parameters)
            throws Exception {
            return null;
        }
    }
    public void testGetAndRemoveParameterEmptyMap() {
        Map parameters = new HashMap();
        MyComponent my = new MyComponent(this.context);
        Integer value = my.getAndRemoveParameter(parameters, ""size"", Integer.class);
        assertNull(value);
    }
    public void testGetAndRemoveParameterEmptyMapDefault() {
        Map parameters = new HashMap();
        MyComponent my = new MyComponent(this.context);
        Integer value = my.getAndRemoveParameter(parameters, ""size"", Integer.class, 5);
        assertEquals(value.intValue(), 5);
    }
    public void testGetAndRemoveParameterEmptyMapDefaultIsNull() {
        Map parameters = new HashMap();
        MyComponent my = new MyComponent(this.context);
        Integer value = my.getAndRemoveParameter(parameters, ""size"", Integer.class, null);
        assertNull(value);
    }
    public void testGetAndRemoveParameterToInteger() {
        Map parameters = new HashMap();
        parameters.put(""size"", 200);
        MyComponent my = new MyComponent(this.context);
        Integer value = my.getAndRemoveParameter(parameters, ""size"", Integer.class);
        assertEquals(value.intValue(), 200);
    }
    public void testGetAndRemoveParameterToIntegerDefault() {
        Map parameters = new HashMap();
        parameters.put(""size"", 200);
        MyComponent my = new MyComponent(this.context);
        Integer value = my.getAndRemoveParameter(parameters, ""level"", Integer.class, 4);
        assertEquals(value.intValue(), 4);
    }
}
"
org.apache.camel.impl.DefaultComponentValidateURITest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.ResolveEndpointFailedException;
/**
 * Unit test for URI validation when creating an endpoint
 */
public class DefaultComponentValidateURITest extends ContextTestSupport {
    public void testNoParameters() throws Exception {
        Endpoint endpoint = context.getEndpoint(""timer://foo"");
        assertNotNull(""Should have created an endpoint"", endpoint);
    }
    public void testNoQuestionMarker() throws Exception {
        try {
            context.getEndpoint(""timer://foo&fixedRate=true&delay=0&period=500"");
            fail(""Should have thrown ResolveEndpointFailedException"");
        } catch (ResolveEndpointFailedException e) {
            // ok
        }
    }
    public void testUnknownParameter() throws Exception {
        try {
            context.getEndpoint(""timer://foo?delay=250&unknown=1&period=500"");
            fail(""Should have thrown ResolveEndpointFailedException"");
        } catch (ResolveEndpointFailedException e) {
            // ok
        }
    }
    public void testDoubleAmpersand() throws Exception {
        try {
            context.getEndpoint(""timer://foo?delay=250&&period=500"");
            fail(""Should have thrown ResolveEndpointFailedException"");
        } catch (ResolveEndpointFailedException e) {
            // ok
        }
    }
}
"
org.apache.camel.impl.DefaultConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;
/**
 * A default consumer useful for implementation inheritance.
 *
 * @version $Revision: 659842 $
 */
public class DefaultConsumer<E extends Exchange> extends ServiceSupport implements Consumer<E> {
    private Endpoint<E> endpoint;
    private Processor processor;
    private AsyncProcessor asyncProcessor;
    private ExceptionHandler exceptionHandler;
    public DefaultConsumer(Endpoint<E> endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""Consumer on "" + endpoint;
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public Processor getProcessor() {
        return processor;
    }
    /**
     * Provides an {@link AsyncProcessor} interface to the configured
     * processor on the consumer.  If the processor does not implement
     * the interface, it will be adapted so that it does.  
     */
    public AsyncProcessor getAsyncProcessor() {
        if (asyncProcessor == null) {
            asyncProcessor = AsyncProcessorTypeConverter.convert(processor);
        }
        return asyncProcessor;
    }
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     * 
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        getExceptionHandler().handleException(t);
    }
}
"
org.apache.camel.impl.DefaultEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.util.ObjectHelper;
/**
 * A default endpoint useful for implementation inheritance
 *
 * @version $Revision: 670567 $
 */
public abstract class DefaultEndpoint<E extends Exchange> implements Endpoint<E>, CamelContextAware {
    private String endpointUri;
    private CamelContext camelContext;
    private Component component;
    private ScheduledExecutorService executorService;
    private ExchangePattern exchangePattern = ExchangePattern.InOnly;
    protected DefaultEndpoint(String endpointUri, Component component) {
        this(endpointUri, component.getCamelContext());
        this.component = component;
    }
    protected DefaultEndpoint(String endpointUri, CamelContext camelContext) {
        this(endpointUri);
        this.camelContext = camelContext;
    }
    protected DefaultEndpoint(String endpointUri) {
        this.setEndpointUri(endpointUri);
    }
    protected DefaultEndpoint() {
    }
    public int hashCode() {
        return getEndpointUri().hashCode() * 37 + 1;
    }
    @Override
    public boolean equals(Object object) {
        if (object instanceof DefaultEndpoint) {
            DefaultEndpoint that = (DefaultEndpoint) object;
            return ObjectHelper.equal(this.getEndpointUri(), that.getEndpointUri());
        }
        return false;
    }
    @Override
    public String toString() {
        return ""Endpoint["" + getEndpointUri() + ""]"";
    }
    public String getEndpointUri() {
        if (endpointUri == null) {
            endpointUri = createEndpointUri();
            if (endpointUri == null) {
                throw new IllegalArgumentException(""endpointUri is not specified and "" + getClass().getName()
                        + "" does not implement createEndpointUri() to create a default value"");
            }
        }
        return endpointUri;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public Component getComponent() {
        return component;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public synchronized ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            Component c = getComponent();
            if (c != null && c instanceof DefaultComponent) {
                DefaultComponent dc = (DefaultComponent) c;
                executorService = dc.getExecutorService();
            }
            if (executorService == null) {
                executorService = createExecutorService();
            }
        }
        return executorService;
    }
    public synchronized void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }
    public PollingConsumer<E> createPollingConsumer() throws Exception {
        return new EventDrivenPollingConsumer<E>(this);
    }
    /**
     * Converts the given exchange to the specified exchange type
     */
    public E convertTo(Class<E> type, Exchange exchange) {
        // TODO we could infer type parameter
        if (type.isInstance(exchange)) {
            return type.cast(exchange);
        }
        return getCamelContext().getExchangeConverter().convertTo(type, exchange);
    }
    public E createExchange(Exchange exchange) {
        Class<E> exchangeType = getExchangeType();
        if (exchangeType != null) {
            if (exchangeType.isInstance(exchange)) {
                return exchangeType.cast(exchange);
            }
        }
        E answer = createExchange();
        answer.copyFrom(exchange);
        return answer;
    }
    /**
     * Returns the type of the exchange which is generated by this component
     */
    public Class<E> getExchangeType() {
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    return (Class<E>) argumentType;
                }
            }
        }
        return null;
    }
    public E createExchange() {
        return createExchange(getExchangePattern());
    }
    public E createExchange(ExchangePattern pattern) {
        return (E) new DefaultExchange(getCamelContext(), pattern);
    }
    public ExchangePattern getExchangePattern() {
        return exchangePattern;
    }
    public void setExchangePattern(ExchangePattern exchangePattern) {
        this.exchangePattern = exchangePattern;
    }
    protected ScheduledThreadPoolExecutor createExecutorService() {
        return new ScheduledThreadPoolExecutor(10);
    }
    public void configureProperties(Map options) {
    }
    /**
     * A factory method to lazily create the endpointUri if none is specified 
     */
    protected String createEndpointUri() {
        return null;
    }
    protected void setEndpointUri(String endpointUri) {
        this.endpointUri = endpointUri;
    }
    @Deprecated
    public CamelContext getContext() {
        return getCamelContext();
    }
    @Deprecated
    public void setContext(CamelContext context) {
        setCamelContext(context);
    }
}
"
org.apache.camel.impl.DefaultExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.ExchangeProperty;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.UnitOfWork;
import org.apache.camel.util.UuidGenerator;
/**
 * A default implementation of {@link Exchange}
 *
 * @version $Revision: 673008 $
 */
public class DefaultExchange implements Exchange {
    private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator();
    protected final CamelContext context;
    private Map<String, Object> properties;
    private Message in;
    private Message out;
    private Message fault;
    private Throwable exception;
    private String exchangeId;
    private UnitOfWork unitOfWork;
    private ExchangePattern pattern;
    public DefaultExchange(CamelContext context) {
        this(context, ExchangePattern.InOnly);
    }
    public DefaultExchange(CamelContext context, ExchangePattern pattern) {
        this.context = context;
        this.pattern = pattern;
    }
    public DefaultExchange(DefaultExchange parent) {
        this(parent.getContext(), parent.getPattern());
        this.unitOfWork = parent.getUnitOfWork();
    }
    @Override
    public String toString() {
        return ""Exchange["" + in + ""]"";
    }
    public Exchange copy() {
        Exchange exchange = newInstance();
        exchange.copyFrom(this);
        return exchange;
    }
    public void copyFrom(Exchange exchange) {
        if (exchange == this) {
            return;
        }
        setProperties(safeCopy(exchange.getProperties()));
        // this can cause strangeness if we copy, say, a FileMessage onto an FtpExchange with overloaded getExchange() methods etc.
        safeCopy(getIn(), exchange, exchange.getIn());
        Message copyOut = exchange.getOut(false);
        if (copyOut != null) {
            safeCopy(getOut(true), exchange, copyOut);
        }
        Message copyFault = exchange.getFault(false);
        if (copyFault != null) {
            safeCopy(getFault(true), exchange, copyFault);
        }
        setException(exchange.getException());
        unitOfWork = exchange.getUnitOfWork();
        pattern = exchange.getPattern();
    }
    private static void safeCopy(Message message, Exchange exchange, Message that) {
        if (message != null) {
            message.copyFrom(that);
        }
    }
    private static Map<String, Object> safeCopy(Map<String, Object> properties) {
        if (properties == null) {
            return null;
        }
        return new HashMap<String, Object>(properties);
    }
    private static Message safeCopy(Exchange exchange, Message message) {
        if (message == null) {
            return null;
        }
        Message answer = message.copy();
        if (answer instanceof MessageSupport) {
            MessageSupport messageSupport = (MessageSupport) answer;
            messageSupport.setExchange(exchange);
        }
        return answer;
    }
    public Exchange newInstance() {
        return new DefaultExchange(this);
    }
    public CamelContext getContext() {
        return context;
    }
    public Object getProperty(String name) {
        if (properties != null) {
            return properties.get(name);
        }
        return null;
    }
    public <T> T getProperty(String name, Class<T> type) {
        Object value = getProperty(name);
        // if the property is also a well known property in ExchangeProperty then validate that the
        // value is of the same type
        ExchangeProperty<?> property = ExchangeProperty.getByName(name);
        if (property != null) {
            validateExchangePropertyIsExpectedType(property, type, value);
        }
        return getContext().getTypeConverter().convertTo(type, value);
    }
    public void setProperty(String name, Object value) {
        ExchangeProperty<?> property = ExchangeProperty.getByName(name);
        // if the property is also a well known property in ExchangeProperty then validate that the
        // value is of the same type
        if (property != null) {
            Class type = value.getClass();
            validateExchangePropertyIsExpectedType(property, type, value);
        }
        getProperties().put(name, value);
    }
    private <T> void validateExchangePropertyIsExpectedType(ExchangeProperty<?> property, Class<T> type, Object value) {
        if (value != null && property != null && !property.type().isAssignableFrom(type)) {
            throw new RuntimeCamelException(""Type cast exception while getting an ""
                    + ""Exchange Property value '"" + value.toString()
                    + ""' on Exchange "" + this
                    + "" for a well known Exchange Property with these traits: "" + property);
        }
    }
    public Object removeProperty(String name) {
        return getProperties().remove(name);
    }
    public Map<String, Object> getProperties() {
        if (properties == null) {
            properties = new HashMap<String, Object>();
        }
        return properties;
    }
    public void setProperties(Map<String, Object> properties) {
        this.properties = properties;
    }
    public Message getIn() {
        if (in == null) {
            in = createInMessage();
            configureMessage(in);
        }
        return in;
    }
    public void setIn(Message in) {
        this.in = in;
        configureMessage(in);
    }
    public Message getOut() {
        return getOut(true);
    }
    public Message getOut(boolean lazyCreate) {
        if (out == null && lazyCreate) {
            out = createOutMessage();
            configureMessage(out);
        }
        return out;
    }
    public void setOut(Message out) {
        this.out = out;
        configureMessage(out);
    }
    public Throwable getException() {
        return exception;
    }
    public void setException(Throwable exception) {
        this.exception = exception;
    }
    public ExchangePattern getPattern() {
        return pattern;
    }
    public void setPattern(ExchangePattern pattern) {
        this.pattern = pattern;
    }
    public void throwException() throws Exception {
        if (exception == null) {
            return;
        }
        if (exception instanceof RuntimeException) {
            throw (RuntimeException)exception;
        }
        if (exception instanceof Exception) {
            throw (Exception)exception;
        }
        throw new RuntimeCamelException(exception);
    }
    public Message getFault() {
        return getFault(true);
    }
    public Message getFault(boolean lazyCreate) {
        if (fault == null && lazyCreate) {
            fault = createFaultMessage();
            configureMessage(fault);
        }
        return fault;
    }
    public void setFault(Message fault) {
        this.fault = fault;
        configureMessage(fault);
    }
    public String getExchangeId() {
        if (exchangeId == null) {
            exchangeId = DefaultExchange.DEFAULT_ID_GENERATOR.generateId();
        }
        return exchangeId;
    }
    public void setExchangeId(String id) {
        this.exchangeId = id;
    }
    public boolean isFailed() {
        Message faultMessage = getFault(false);
        if (faultMessage != null) {
            Object faultBody = faultMessage.getBody();
            if (faultBody != null) {
                return true;
            }
        }
        return getException() != null;
    }
    public boolean isTransacted() {
        ExchangeProperty<?> property = ExchangeProperty.get(""transacted"");
        return property != null && property.get(this) == Boolean.TRUE;
    }
    public UnitOfWork getUnitOfWork() {
        return unitOfWork;
    }
    public void setUnitOfWork(UnitOfWork unitOfWork) {
        this.unitOfWork = unitOfWork;
    }
    /**
     * Factory method used to lazily create the IN message
     */
    protected Message createInMessage() {
        return new DefaultMessage();
    }
    /**
     * Factory method to lazily create the OUT message
     */
    protected Message createOutMessage() {
        return new DefaultMessage();
    }
    /**
     * Factory method to lazily create the FAULT message
     */
    protected Message createFaultMessage() {
        return new DefaultMessage();
    }
    /**
     * Configures the message after it has been set on the exchange
     */
    protected void configureMessage(Message message) {
        if (message instanceof MessageSupport) {
            MessageSupport messageSupport = (MessageSupport)message;
            messageSupport.setExchange(this);
        }
    }
}
"
org.apache.camel.impl.DefaultExchangeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.spi.ExchangeConverter;
/**
 * Default implementation of {@link org.apache.camel.spi.ExchangeConverter}.
 *
 * @version $Revision: 659798 $
 */
public class DefaultExchangeConverter implements ExchangeConverter {
    public <T> T convertTo(Class<T> type, Exchange exchange) {
        // TODO use some kinda introspection to find available exchange conversions
        throw new UnsupportedOperationException(""Not implemented yet"");
    }
}
"
org.apache.camel.impl.DefaultExchangeFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.processor.interceptor.ExchangeFormatter;
/**
 * A default {@link ExchangeFormatter} which just uses the {@link org.apache.camel.Exchange#toString()} method
 *
 * @version $Revision: 673954 $
 */
public class DefaultExchangeFormatter implements ExchangeFormatter {
    protected static final DefaultExchangeFormatter INSTANCE = new DefaultExchangeFormatter();
    public static DefaultExchangeFormatter getInstance() {
        return INSTANCE;
    }
    public Object format(Exchange exchange) {
        return exchange;
    }
}
"
org.apache.camel.impl.DefaultLanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.NoSuchLanguageException;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
/**
 * Default language resolver that looks for language factories in <b>META-INF/services/org/apache/camel/language/</b> and
 * language resolvers in <b>META-INF/services/org/apache/camel/language/resolver/</b>.
 *
 * @version $Revision: 659798 $
 */
public class DefaultLanguageResolver implements LanguageResolver {
    protected static final FactoryFinder LANGUAGE_FACTORY = new FactoryFinder(""META-INF/services/org/apache/camel/language/"");
    protected static final FactoryFinder LANGUAGE_RESOLVER = new FactoryFinder(""META-INF/services/org/apache/camel/language/resolver/"");
    public Language resolveLanguage(String name, CamelContext context) {
        Class type = null;
        try {
            type = LANGUAGE_FACTORY.findClass(name);
        } catch (NoFactoryAvailableException e) {
            // ignore
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Language registered for scheme : "" + name, e);
        }
        if (type != null) {
            if (Language.class.isAssignableFrom(type)) {
                return (Language)context.getInjector().newInstance(type);
            } else {
                throw new IllegalArgumentException(""Type is not a Language implementation. Found: "" + type.getName());
            }
        }
        return noSpecificLanguageFound(name, context);
    }
    protected Language noSpecificLanguageFound(String name, CamelContext context) {
        Class type = null;
        try {
            type = LANGUAGE_RESOLVER.findClass(""default"");
        } catch (NoFactoryAvailableException e) {
            // ignore
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Language registered for scheme : "" + name, e);
        }
        if (type != null) {
            if (LanguageResolver.class.isAssignableFrom(type)) {
                LanguageResolver resolver = (LanguageResolver)context.getInjector().newInstance(type);
                return resolver.resolveLanguage(name, context);
            } else {
                throw new IllegalArgumentException(""Type is not a LanguageResolver implementation. Found: "" + type.getName());
            }
        }
        throw new NoSuchLanguageException(name);
    }
}
"
org.apache.camel.impl.DefaultLifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * Default implementation of the lifecycle strategy.
 */
public class DefaultLifecycleStrategy implements LifecycleStrategy {
    public void onContextStart(CamelContext context) {
        // do nothing
    }
    public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
        // do nothing
    }
    public void onServiceAdd(CamelContext context, Service service) {
        // do nothing
    }
    public void onRoutesAdd(Collection<Route> routes) {
        // do nothing
    }
    public void onRouteContextCreate(RouteContext routeContext) {
        // do nothing
    }
}
"
org.apache.camel.impl.DefaultMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.activation.DataHandler;
import org.apache.camel.Message;
/**
 * The default implementation of {@link Message}
 *
 * @version $Revision: 653092 $
 */
public class DefaultMessage extends MessageSupport {
    private Map<String, Object> headers;
    private Map<String, DataHandler> attachments;
    @Override
    public String toString() {
        return ""Message: "" + getBody();
    }
    public Object getHeader(String name) {
        return getHeaders().get(name);
    }
    public <T> T getHeader(String name, Class<T> type) {
        Object value = getHeader(name);
        return getExchange().getContext().getTypeConverter().convertTo(type, value);
    }
    public void setHeader(String name, Object value) {
        if (headers == null) {
            headers = createHeaders();
        }
        headers.put(name, value);
    }
    public Object removeHeader(String name) {
        if (headers != null) {
            return headers.remove(name);
        } else {
            return null;
        }
    }
    public Map<String, Object> getHeaders() {
        if (headers == null) {
            headers = createHeaders();
        }
        return headers;
    }
    public void setHeaders(Map<String, Object> headers) {
        this.headers = headers;
    }
    public DefaultMessage newInstance() {
        return new DefaultMessage();
    }
    /**
     * A factory method to lazily create the headers to make it easy to create
     * efficient Message implementations which only construct and populate the
     * Map on demand
     *
     * @return return a newly constructed Map possibly containing headers from
     *         the underlying inbound transport
     */
    protected Map<String, Object> createHeaders() {
        HashMap<String, Object> map = new HashMap<String, Object>();
        populateInitialHeaders(map);
        return map;
    }
    /**
     * A strategy method populate the initial set of headers on an inbound
     * message from an underlying binding
     *
     * @param map is the empty header map to populate
     */
    protected void populateInitialHeaders(Map<String, Object> map) {
    }
    /**
     * A factory method to lazily create the attachments to make it easy to
     * create efficient Message implementations which only construct and
     * populate the Map on demand
     *
     * @return return a newly constructed Map
     */
    protected Map<String, DataHandler> createAttachments() {
        HashMap<String, DataHandler> map = new HashMap<String, DataHandler>();
        populateInitialAttachments(map);
        return map;
    }
    /**
     * A strategy method populate the initial set of attachments on an inbound
     * message from an underlying binding
     *
     * @param map is the empty attachment map to populate
     */
    protected void populateInitialAttachments(Map<String, DataHandler> map) {
    }
    public void addAttachment(String id, DataHandler content) {
        if (attachments == null) {
            attachments = createAttachments();
        }
        attachments.put(id, content);
    }
    public DataHandler getAttachment(String id) {
        return getAttachments().get(id);
    }
    public Set<String> getAttachmentNames() {
        if (attachments == null) {
            attachments = createAttachments();
        }
        return attachments.keySet();
    }
    public void removeAttachment(String id) {
        if (attachments != null && attachments.containsKey(id)) {
            attachments.remove(id);
        }
    }
    public Map<String, DataHandler> getAttachments() {
        if (attachments == null) {
            attachments = createAttachments();
        }
        return attachments;
    }
    public void setAttachments(Map<String, DataHandler> attachments) {
        this.attachments = attachments;
    }
    public boolean hasAttachments() {
        return this.attachments != null && this.attachments.size() > 0;
    }
    /**
     * Returns true if the headers have been mutated in some way
     */
    protected boolean hasPopulatedHeaders() {
        return headers != null;
    }
}
"
org.apache.camel.impl.DefaultPollingEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
/**
 * A base class for an endpoint which the default consumer mode is to use a {@link PollingConsumer}
 *
 * @version $Revision: 656397 $
 */
public abstract class DefaultPollingEndpoint<E extends Exchange> extends ScheduledPollEndpoint<E>  {
    protected DefaultPollingEndpoint() {
    }
    protected DefaultPollingEndpoint(String endpointUri) {
        super(endpointUri);
    }
    protected DefaultPollingEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    protected DefaultPollingEndpoint(String endpointUri, CamelContext context) {
        super(endpointUri, context);
    }
    public Consumer<E> createConsumer(Processor processor) throws Exception {
        DefaultScheduledPollConsumer result = new DefaultScheduledPollConsumer(this, processor);
        configureConsumer(result);
        return result;
    }
}
"
org.apache.camel.impl.DefaultProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Producer;
/**
 * A default implementation of @{link Producer} for implementation inheritence
 *
 * @version $Revision: 640438 $
 */
public abstract class DefaultProducer<E extends Exchange> extends ServiceSupport implements Producer<E> {
    private Endpoint<E> endpoint;
    public DefaultProducer(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""Producer["" + endpoint.getEndpointUri() + ""]"";
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public E createExchange() {
        return endpoint.createExchange();
    }
    public E createExchange(ExchangePattern pattern) {
        return endpoint.createExchange(pattern);
    }
    public E createExchange(E exchange) {
        return endpoint.createExchange(exchange);
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.impl.DefaultProducerTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.AsyncCallback;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.util.ObjectHelper;
/**
 * A client helper object (named like Spring's TransactionTemplate & JmsTemplate
 * et al) for working with Camel and sending {@link org.apache.camel.Message} instances in an
 * {@link org.apache.camel.Exchange} to an {@link org.apache.camel.Endpoint}.
 *
 * @version $Revision: 675919 $
 */
public class DefaultProducerTemplate<E extends Exchange> extends ServiceSupport implements ProducerTemplate<E> {
    private CamelContext context;
    private final ProducerCache<E> producerCache = new ProducerCache<E>();
    private boolean useEndpointCache = true;
    private final Map<String, Endpoint<E>> endpointCache = new HashMap<String, Endpoint<E>>();
    private Endpoint<E> defaultEndpoint;
    public DefaultProducerTemplate(CamelContext context) {
        this.context = context;
    }
    public DefaultProducerTemplate(CamelContext context, Endpoint defaultEndpoint) {
        this(context);
        this.defaultEndpoint = defaultEndpoint;
    }
    public E send(String endpointUri, E exchange) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, exchange);
    }
    public E send(String endpointUri, Processor processor) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, processor);
    }
    public E send(String endpointUri, Processor processor, AsyncCallback callback) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, processor, callback);
    }
    public E send(String endpointUri, ExchangePattern pattern, Processor processor) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, pattern, processor);
    }
    public E send(Endpoint<E> endpoint, E exchange) {
        E convertedExchange = exchange;
        producerCache.send(endpoint, convertedExchange);
        return convertedExchange;
    }
    public E send(Endpoint<E> endpoint, Processor processor) {
        return producerCache.send(endpoint, processor);
    }
    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {
        return producerCache.send(endpoint, processor, callback);
    }
    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {
        return producerCache.send(endpoint, pattern, processor);
    }
    public Object sendBody(Endpoint<E> endpoint, ExchangePattern pattern, Object body) {
        E result = send(endpoint, pattern, createSetBodyProcessor(body));
        return extractResultBody(result, pattern);
    }
    public Object sendBody(Endpoint<E> endpoint, Object body) {
        E result = send(endpoint, createSetBodyProcessor(body));
        return extractResultBody(result);
    }
    public Object sendBody(String endpointUri, Object body) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return sendBody(endpoint, body);
    }
    public Object sendBody(String endpointUri, ExchangePattern pattern, Object body) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return sendBody(endpoint, pattern, body);
    }
    public Object sendBodyAndHeader(String endpointUri, final Object body, final String header,
            final Object headerValue) {
        return sendBodyAndHeader(resolveMandatoryEndpoint(endpointUri), body, header, headerValue);
    }
    public Object sendBodyAndHeader(Endpoint endpoint, final Object body, final String header,
            final Object headerValue) {
        E result = send(endpoint, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result);
    }
    public Object sendBodyAndHeader(Endpoint endpoint, ExchangePattern pattern, final Object body, final String header,
            final Object headerValue) {
        E result = send(endpoint, pattern, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result, pattern);
    }
    public Object sendBodyAndHeader(String endpoint, ExchangePattern pattern, final Object body, final String header,
            final Object headerValue) {
        E result = send(endpoint, pattern, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result, pattern);
    }
    public Object sendBodyAndHeaders(String endpointUri, final Object body, final Map<String, Object> headers) {
        return sendBodyAndHeaders(resolveMandatoryEndpoint(endpointUri), body, headers);
    }
    public Object sendBodyAndHeaders(Endpoint endpoint, final Object body, final Map<String, Object> headers) {
        E result = send(endpoint, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                for (Map.Entry<String, Object> header : headers.entrySet()) {
                    in.setHeader(header.getKey(), header.getValue());
                }
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }
    // Methods using an InOut ExchangePattern
    // -----------------------------------------------------------------------
    public E request(Endpoint<E> endpoint, Processor processor) {
        return send(endpoint, ExchangePattern.InOut, processor);
    }
    public Object requestBody(Endpoint<E> endpoint, Object body) {
        return sendBody(endpoint, ExchangePattern.InOut, body);
    }
    public Object requestBodyAndHeader(Endpoint<E> endpoint, Object body, String header, Object headerValue) {
        return sendBodyAndHeader(endpoint, ExchangePattern.InOut, body, header, headerValue);
    }
    public E request(String endpoint, Processor processor) {
        return send(endpoint, ExchangePattern.InOut, processor);
    }
    public Object requestBody(String endpoint, Object body) {
        return sendBody(endpoint, ExchangePattern.InOut, body);
    }
    public Object requestBodyAndHeader(String endpoint, Object body, String header, Object headerValue) {
        return sendBodyAndHeader(endpoint, ExchangePattern.InOut, body, header, headerValue);
    }
    // Methods using the default endpoint
    // -----------------------------------------------------------------------
    public Object sendBody(Object body) {
        return sendBody(getMandatoryDefaultEndpoint(), body);
    }
    public E send(E exchange) {
        return send(getMandatoryDefaultEndpoint(), exchange);
    }
    public E send(Processor processor) {
        return send(getMandatoryDefaultEndpoint(), processor);
    }
    public Object sendBodyAndHeader(Object body, String header, Object headerValue) {
        return sendBodyAndHeader(getMandatoryDefaultEndpoint(), body, header, headerValue);
    }
    public Object sendBodyAndHeaders(Object body, Map<String, Object> headers) {
        return sendBodyAndHeaders(getMandatoryDefaultEndpoint(), body, headers);
    }
    // Properties
    // -----------------------------------------------------------------------
    public Producer<E> getProducer(Endpoint<E> endpoint) {
        return producerCache.getProducer(endpoint);
    }
    public CamelContext getContext() {
        return context;
    }
    public Endpoint<E> getDefaultEndpoint() {
        return defaultEndpoint;
    }
    public void setDefaultEndpoint(Endpoint<E> defaultEndpoint) {
        this.defaultEndpoint = defaultEndpoint;
    }
    /**
     * Sets the default endpoint to use if none is specified
     */
    public void setDefaultEndpointUri(String endpointUri) {
        setDefaultEndpoint(getContext().getEndpoint(endpointUri));
    }
    public boolean isUseEndpointCache() {
        return useEndpointCache;
    }
    public void setUseEndpointCache(boolean useEndpointCache) {
        this.useEndpointCache = useEndpointCache;
    }
    public <T extends Endpoint<?>> T getResolvedEndpoint(String endpointUri, Class<T> expectedClass) {
        Endpoint<?> e = null;
        synchronized (endpointCache) {
            e = endpointCache.get(endpointUri);
        }
        if (e != null && expectedClass.isAssignableFrom(e.getClass())) {
            return expectedClass.asSubclass(expectedClass).cast(e);
        }
        return null;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected Processor createBodyAndHeaderProcessor(final Object body, final String header, final Object headerValue) {
        return new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setHeader(header, headerValue);
                in.setBody(body);
            }
        };
    }
    protected Processor createSetBodyProcessor(final Object body) {
        return new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
            }
        };
    }
    protected Endpoint resolveMandatoryEndpoint(String endpointUri) {
        Endpoint endpoint = null;
        if (isUseEndpointCache()) {
            synchronized (endpointCache) {
                endpoint = endpointCache.get(endpointUri);
                if (endpoint == null) {
                    endpoint = context.getEndpoint(endpointUri);
                    if (endpoint != null) {
                        endpointCache.put(endpointUri, endpoint);
                    }
                }
            }
        } else {
            endpoint = context.getEndpoint(endpointUri);
        }
        if (endpoint == null) {
            throw new NoSuchEndpointException(endpointUri);
        }
        return endpoint;
    }
    protected Endpoint<E> getMandatoryDefaultEndpoint() {
        Endpoint<E> answer = getDefaultEndpoint();
        ObjectHelper.notNull(answer, ""defaultEndpoint"");
        return answer;
    }
    protected void doStart() throws Exception {
        producerCache.start();
    }
    protected void doStop() throws Exception {
        producerCache.stop();
        endpointCache.clear();
    }
    /**
     * Extracts the body from the given result.
     *
     * @param result   the result
     * @return  the result, can be <tt>null</tt>.
     */
    protected Object extractResultBody(E result) {
        return extractResultBody(result, null);
    }
    /**
     * Extracts the body from the given result.
     * <p/>
     * If the exchange pattern is provided it will try to honor it and retrive the body
     * from either IN or OUT according to the pattern.
     *
     * @param result   the result
     * @param pattern  exchange pattern if given, can be <tt>null</tt>
     * @return  the result, can be <tt>null</tt>.
     */
    protected Object extractResultBody(E result, ExchangePattern pattern) {
        Object answer = null;
        if (result != null) {
            // try to honor pattern if provided
            boolean notOut = pattern != null && !pattern.isOutCapable();
            boolean hasOut = result.getOut(false) != null;
            if (hasOut && !notOut) {
                answer = result.getOut().getBody();
            } else {
                answer = result.getIn().getBody();
            }
        }
        return answer;
    }
}
"
org.apache.camel.impl.DefaultRouteContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Intercept;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.model.FromType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.processor.Interceptor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.ProceedProcessor;
import org.apache.camel.processor.UnitOfWorkProcessor;
import org.apache.camel.spi.ErrorHandlerWrappingStrategy;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * The context used to activate new routing rules
 *
 * @version $Revision: 673335 $
 */
public class DefaultRouteContext implements RouteContext {
    private RouteType route;
    private FromType from;
    private Collection<Route> routes;
    private Endpoint<? extends Exchange> endpoint;
    private List<Processor> eventDrivenProcessors = new ArrayList<Processor>();
    private Interceptor lastInterceptor;
    private CamelContext camelContext;
    private List<InterceptStrategy> interceptStrategies = new ArrayList<InterceptStrategy>();
    private ErrorHandlerWrappingStrategy errorHandlerWrappingStrategy;
    private boolean routeAdded;
    public DefaultRouteContext(RouteType route, FromType from, Collection<Route> routes) {
        this.route = route;
        this.from = from;
        this.routes = routes;
    }
    /**
     * Only used for lazy construction from inside ExpressionType
     */
    public DefaultRouteContext(CamelContext camelContext) {
        this.camelContext = camelContext;
        routes = new ArrayList<Route>();
        route = new RouteType(""temporary"");
    }
    public Endpoint<? extends Exchange> getEndpoint() {
        if (endpoint == null) {
            endpoint = from.resolveEndpoint(this);
        }
        return endpoint;
    }
    public FromType getFrom() {
        return from;
    }
    public RouteType getRoute() {
        return route;
    }
    public CamelContext getCamelContext() {
        if (camelContext == null) {
            camelContext = getRoute().getCamelContext();
        }
        return camelContext;
    }
    public Processor createProcessor(ProcessorType node) throws Exception {
        return node.createOutputsProcessor(this);
    }
    public Endpoint<? extends Exchange> resolveEndpoint(String uri) {
        return route.resolveEndpoint(uri);
    }
    public Endpoint<? extends Exchange> resolveEndpoint(String uri, String ref) {
        Endpoint<? extends Exchange> endpoint = null;
        if (uri != null) {
            endpoint = resolveEndpoint(uri);
            if (endpoint == null) {
                throw new NoSuchEndpointException(uri);
            }
        }
        if (ref != null) {
            endpoint = lookup(ref, Endpoint.class);
            if (endpoint == null) {
                throw new NoSuchEndpointException(""ref:"" + ref);
            }
        }
        if (endpoint == null) {
            throw new IllegalArgumentException(""Either 'uri' or 'ref' must be specified on: "" + this);
        } else {
            return endpoint;
        }
    }
    public <T> T lookup(String name, Class<T> type) {
        return getCamelContext().getRegistry().lookup(name, type);
    }
    public void commit() {
        // now lets turn all of the event driven consumer processors into a
        // single route
        if (!eventDrivenProcessors.isEmpty()) {
            Processor processor = Pipeline.newInstance(eventDrivenProcessors);
            // lets create the async processor
            final AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(processor);
            Processor unitOfWorkProcessor = new UnitOfWorkProcessor(asyncProcessor);
            // TODO: hz: move all this into the lifecycle strategy! (used by jmx naming strategy)
            Route edcr = new EventDrivenConsumerRoute(getEndpoint(), unitOfWorkProcessor);
            edcr.getProperties().put(Route.PARENT_PROPERTY, Integer.toHexString(route.hashCode()));
            if (route.getGroup() != null) {
                edcr.getProperties().put(Route.GROUP_PROPERTY, route.getGroup());
            }
            routes.add(edcr);
        }
    }
    public void addEventDrivenProcessor(Processor processor) {
        eventDrivenProcessors.add(processor);
    }
    public void intercept(Intercept interceptor) {
/*
        InterceptorRef block = new InterceptorRef(interceptor);
        RouteType route = getRoute();
        List<ProcessorType<?>> list = route.getOutputs();
        for (ProcessorType<?> processorType : list) {
            block.addOutput(processorType);
        }
        route.clearOutput();
        route.intercept(block);
*/
        //getRoute().getInterceptors().add(new InterceptorRef(interceptor));
        lastInterceptor = (Interceptor)interceptor;
    }
    public Processor createProceedProcessor() {
        if (lastInterceptor == null) {
            throw new IllegalArgumentException(""Cannot proceed() from outside of an interceptor!"");
        } else {
            return new ProceedProcessor(lastInterceptor);
        }
    }
    public List<InterceptStrategy> getInterceptStrategies() {
        return interceptStrategies;
    }
    public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {
        this.interceptStrategies = interceptStrategies;
    }
    public void addInterceptStrategy(InterceptStrategy interceptStrategy) {
        getInterceptStrategies().add(interceptStrategy);
    }
    public ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy() {
        return errorHandlerWrappingStrategy;
    }
    public void setErrorHandlerWrappingStrategy(ErrorHandlerWrappingStrategy strategy) {
        errorHandlerWrappingStrategy = strategy;
    }
    public boolean isRouteAdded() {
        return routeAdded;
    }
    public void setIsRouteAdded(boolean b) {
        routeAdded = b;
    }
}
"
org.apache.camel.impl.DefaultScheduledPollConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
/**
 * A default implementation of an event driven {@link Consumer} which uses the {@link PollingConsumer}
 *
 * @version $Revision: 640438 $
 */
public class DefaultScheduledPollConsumer<E extends Exchange> extends ScheduledPollConsumer<E> {
    private PollingConsumer<E> pollingConsumer;
    public DefaultScheduledPollConsumer(DefaultEndpoint<E> defaultEndpoint, Processor processor) {
        super(defaultEndpoint, processor);
    }
    public DefaultScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
    }
    protected void poll() throws Exception {
        while (true) {
            E exchange = pollingConsumer.receiveNoWait();
            if (exchange == null) {
                break;
            }
            // if the result of the polled exchange has output we should create a new exchange and
            // use the output as input to the next processor
            Message out = exchange.getOut(false);
            if (out != null) {
                // lets create a new exchange
                E newExchange = getEndpoint().createExchange();
                newExchange.getIn().copyFrom(out);
                exchange = newExchange;
            }
            getProcessor().process(exchange);
        }
    }
    @Override
    protected void doStart() throws Exception {
        pollingConsumer = getEndpoint().createPollingConsumer();
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (pollingConsumer != null) {
            pollingConsumer.stop();
        }
    }
}
"
org.apache.camel.impl.DefaultUnitOfWork,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.spi.Synchronization;
import org.apache.camel.spi.UnitOfWork;
import org.apache.camel.util.UuidGenerator;
/**
 * The default implementation of {@link UnitOfWork}
 *
 * @version $Revision: 670436 $
 */
public class DefaultUnitOfWork implements UnitOfWork {
    private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator();
    private String id;
    private List<Synchronization> synchronizations;
    private List<AsyncCallback> asyncCallbacks;
    private CountDownLatch latch;
    public DefaultUnitOfWork() {
    }
    public synchronized void addSynchronization(Synchronization synchronization) {
        if (synchronizations == null) {
            synchronizations = new ArrayList<Synchronization>();
        }
        synchronizations.add(synchronization);
    }
    public synchronized void removeSynchronization(Synchronization synchronization) {
        if (synchronizations != null) {
            synchronizations.remove(synchronization);
        }
    }
    public void reset() {
    }
    public void done(Exchange exchange) {
        if (synchronizations != null) {
            boolean failed = exchange.isFailed();
            for (Synchronization synchronization : synchronizations) {
                if (failed) {
                    synchronization.onFailure(exchange);
                } else {
                    synchronization.onComplete(exchange);
                }
            }
        }
    }
    public boolean isSynchronous() {
        return asyncCallbacks == null || asyncCallbacks.isEmpty();
    }
    /**
     * Returns the unique ID of this unit of work, lazily creating one if it does not yet have one
     *
     * @return
     */
    public String getId() {
        if (id == null) {
            id = DEFAULT_ID_GENERATOR.generateId();
        }
        return id;
    }
    /**
     * Register some asynchronous processing step
     */
    /*
    public synchronized AsyncCallback addAsyncStep() {
        AsyncCallback answer = new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                latch.countDown();
            }
        };
        if (latch == null) {
            latch = new CountDownLatch(1);
        }
        else {
            // TODO increment latch!
        }
        if (asyncCallbacks == null) {
            asyncCallbacks = new ArrayList<AsyncCallback>();
        }
        asyncCallbacks.add(answer);
        return answer;
    }
    */
}
"
org.apache.camel.impl.DelegateLifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * A helper class for folks writing delegate listener strategies
 *
 * @version $Revision: 669756 $
 */
public class DelegateLifecycleStrategy implements LifecycleStrategy {
    private final LifecycleStrategy delegate;
    public DelegateLifecycleStrategy(LifecycleStrategy delegate) {
        this.delegate = delegate;
    }
    public void onContextStart(CamelContext context) {
        delegate.onContextStart(context);
    }
    public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
        delegate.onEndpointAdd(endpoint);
    }
    public void onRouteContextCreate(RouteContext routeContext) {
        delegate.onRouteContextCreate(routeContext);
    }
    public void onRoutesAdd(Collection<Route> routes) {
        delegate.onRoutesAdd(routes);
    }
    public void onServiceAdd(CamelContext context, Service service) {
        delegate.onServiceAdd(context, service);
    }
}
"
org.apache.camel.impl.EventDrivenConsumerRoute,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.List;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.Service;
/**
 * A {@link Route} which starts with an
 * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event Driven Consumer</a>
 *
 * @version $Revision: 630591 $
 */
public class EventDrivenConsumerRoute<E extends Exchange> extends Route<E> {
    private Processor processor;
    public EventDrivenConsumerRoute(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""EventDrivenConsumerRoute["" + getEndpoint() + "" -> "" + processor + ""]"";
    }
    public Processor getProcessor() {
        return processor;
    }
    public void setProcessor(Processor processor) {
        this.processor = processor;
    }
    /**
     * Factory method to lazily create the complete list of services required for this route
     * such as adding the processor or consumer
     */
    @Override
    protected void addServices(List<Service> services) throws Exception {
        Endpoint<E> endpoint = getEndpoint();
        Consumer<E> consumer = endpoint.createConsumer(processor);
        if (consumer != null) {
            services.add(consumer);
        }
        Processor processor = getProcessor();
        if (processor instanceof Service) {
            Service service = (Service) processor;
            services.add(service);
        }
    }
}
"
org.apache.camel.impl.EventDrivenPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.processor.Logger;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A default implementation of the {@link PollingConsumer} which uses the normal
 * asynchronous consumer mechanism along with a {@link BlockingQueue} to allow
 * the caller to pull messages on demand.
 *
 * @version $Revision: 640438 $
 */
public class EventDrivenPollingConsumer<E extends Exchange> extends PollingConsumerSupport<E> implements
    Processor {
    private static final transient Log LOG = LogFactory.getLog(EventDrivenPollingConsumer.class);
    private BlockingQueue<E> queue;
    private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler(new Logger(LOG));
    private Consumer<E> consumer;
    public EventDrivenPollingConsumer(Endpoint<E> endpoint) {
        this(endpoint, new ArrayBlockingQueue<E>(1000));
    }
    public EventDrivenPollingConsumer(Endpoint<E> endpoint, BlockingQueue<E> queue) {
        super(endpoint);
        this.queue = queue;
    }
    public E receiveNoWait() {
        return receive(0);
    }
    public E receive() {
        while (isRunAllowed()) {
            try {
                return queue.take();
            } catch (InterruptedException e) {
                handleInteruptedException(e);
            }
        }
        return null;
    }
    public E receive(long timeout) {
        try {
            return queue.poll(timeout, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            handleInteruptedException(e);
            return null;
        }
    }
    public void process(Exchange exchange) throws Exception {
        queue.offer((E)exchange);
    }
    public ExceptionHandler getInteruptedExceptionHandler() {
        return interuptedExceptionHandler;
    }
    public void setInteruptedExceptionHandler(ExceptionHandler interuptedExceptionHandler) {
        this.interuptedExceptionHandler = interuptedExceptionHandler;
    }
    protected void handleInteruptedException(InterruptedException e) {
        getInteruptedExceptionHandler().handleException(e);
    }
    protected void doStart() throws Exception {
        // lets add ourselves as a consumer
        consumer = getEndpoint().createConsumer(this);
        consumer.start();
    }
    protected void doStop() throws Exception {
        if (consumer != null) {
            try {
                consumer.stop();
            } finally {
                consumer = null;
            }
        }
    }
}
"
org.apache.camel.impl.ExpressionSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.util.ObjectHelper;
/**
 * A useful base class for {@link Predicate} and {@link Expression} implementations
 *
 * @version $Revision: 663018 $
 */
public abstract class ExpressionSupport<E extends Exchange> implements Expression<E> , Predicate<E> {
    public boolean matches(E exchange) {
        Object value = evaluate(exchange);
        return ObjectHelper.evaluateValuePredicate(value);
    }
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(text + "" "" + assertionFailureMessage(exchange) + "" for exchange: "" + exchange);
        }
    }
    protected abstract String assertionFailureMessage(E exchange);
}
"
org.apache.camel.impl.JndiRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Hashtable;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Registry;
/**
 * A {@link Registry} implementation which looks up the objects in JNDI
 * 
 * @version $Revision: 630591 $
 */
public class JndiRegistry implements Registry {
    private Context context;
    public JndiRegistry() {
    }
    public JndiRegistry(Context context) {
        this.context = context;
    }
    public <T> T lookup(String name, Class<T> type) {
        Object value = lookup(name);
        return type.cast(value);
    }
    public Object lookup(String name) {
        try {
            return getContext().lookup(name);
        } catch (NameNotFoundException e) {
            return null;
        } catch (NamingException e) {
            return null;
        }
    }
    public void bind(String s, Object o) {
        try {
            getContext().bind(s, o);
        } catch (NamingException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public void close() throws NamingException {
        getContext().close();
    }
    public Context getContext() throws NamingException {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(Context context) {
        this.context = context;
    }
    protected Context createContext() throws NamingException {
        Hashtable properties = new Hashtable(System.getProperties());
        return new InitialContext(properties);
    }
}
"
org.apache.camel.impl.LoggingExceptionHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.commons.logging.LogFactory;
/**
 * A default implementation of {@link ExceptionHandler} which uses a {@link Logger} to
 * log to an arbitrary {@link org.apache.commons.logging.Log Log} with some {@link LoggingLevel}
 *
 * @version $Revision: 642753 $
 */
public class LoggingExceptionHandler implements ExceptionHandler {
    private final Logger logger;
    public LoggingExceptionHandler(Class ownerType) {
        this(new Logger(LogFactory.getLog(ownerType), LoggingLevel.ERROR));
    }
    public LoggingExceptionHandler(Logger logger) {
        this.logger = logger;
    }
    public void handleException(Throwable exception) {
        logger.log(exception.getMessage(), exception);
    }
}
"
org.apache.camel.impl.MessageSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.UuidGenerator;
/**
 * A base class for implementation inheritence providing the core
 * {@link Message} body handling features but letting the derived class deal
 * with headers.
 *
 * Unless a specific provider wishes to do something particularly clever with
 * headers you probably want to just derive from {@link DefaultMessage}
 *
 * @version $Revision: 676826 $
 */
public abstract class MessageSupport implements Message {
    private static final UuidGenerator DEFALT_ID_GENERATOR = new UuidGenerator();
    private Exchange exchange;
    private Object body;
    private String messageId;
    public Object getBody() {
        if (body == null) {
            body = createBody();
        }
        return body;
    }
    @SuppressWarnings({""unchecked"" })
    public <T> T getBody(Class<T> type) {
        return getBody(type, getBody());
    }
    protected <T> T getBody(Class<T> type, Object body) {
        Exchange e = getExchange();
        if (e != null) {
            CamelContext camelContext = e.getContext();
            if (camelContext != null) {
                TypeConverter converter = camelContext.getTypeConverter();
                T answer = converter.convertTo(type, body);
                if (answer == null) {
                    // lets first try converting the message itself first
                    // as for some types like InputStream v Reader its more efficient to do the transformation
                    // from the Message itself as its got efficient implementations of them, before trying the
                    // payload
                    answer = converter.convertTo(type, this);
                }
                return answer;
            }
        }
        return (T)getBody();
    }
    public void setBody(Object body) {
        this.body = body;
    }
    public <T> void setBody(Object value, Class<T> type) {
        Exchange e = getExchange();
        if (e != null) {
            T v = e.getContext().getTypeConverter().convertTo(type, value);
            if (v != null) {
                value = v;
            }
        }
        setBody(value);
    }
    public Message copy() {
        Message answer = newInstance();
        answer.copyFrom(this);
        return answer;
    }
    public void copyFrom(Message that) {
        setMessageId(that.getMessageId());
        setBody(that.getBody());
        getHeaders().putAll(that.getHeaders());
        getAttachments().putAll(that.getAttachments());
    }
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    /**
     * Returns a new instance
     */
    public abstract Message newInstance();
    /**
     * A factory method to allow a provider to lazily create the message body
     * for inbound messages from other sources
     *
     * @return the value of the message body or null if there is no value
     *         available
     */
    protected Object createBody() {
        return null;
    }
    public String getMessageId() {
        if (messageId == null) {
            messageId = createMessageId();
        }
        return this.messageId;
    }
    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }
    /**
     * Lets allow implementations to auto-create a messageId
     */
    protected String createMessageId() {
        return DEFALT_ID_GENERATOR.generateId();
    }
}
"
org.apache.camel.impl.MyExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
/**
 * @version $Revision: 630568 $
 */
public class MyExchange extends DefaultExchange {
    public MyExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
}
"
org.apache.camel.impl.NoPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
/**
 * Represents an {@link Policy} which adds no interceptors.
 *
 * @version $Revision: 630591 $
 */
public class NoPolicy<E> implements Policy<E> {
    public Processor wrap(Processor processor) {
        return processor;
    }
}
"
org.apache.camel.impl.PollingConsumerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.spi.ExceptionHandler;
/**
 * A useful base class for implementations of {@link PollingConsumer}
 * 
 * @version $Revision: 630591 $
 */
public abstract class PollingConsumerSupport<E extends Exchange> extends ServiceSupport implements
    PollingConsumer<E> {
    private final Endpoint<E> endpoint;
    private ExceptionHandler exceptionHandler;
    public PollingConsumerSupport(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""PullConsumer on "" + endpoint;
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     * 
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        getExceptionHandler().handleException(t);
    }
}
"
org.apache.camel.impl.PredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A useful base class for {@link Predicate} implementations
 *
 * @version $Revision: 630591 $
 */
public abstract class PredicateSupport<E extends Exchange> implements Predicate<E> {
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(assertionFailureMessage(exchange)  + "" on "" + exchange);
        }
    }
    protected String assertionFailureMessage(E exchange) {
        return toString();
    }
}
"
org.apache.camel.impl.ProcessorEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
/**
 * An endpoint which allows exchanges to be sent into it which just invokes a
 * given {@link Processor}. This component does not support the use of
 * consumers.
 *
 * @version $Revision: 656397 $
 */
public class ProcessorEndpoint extends DefaultPollingEndpoint<Exchange> {
    private Processor processor;
    protected ProcessorEndpoint() {
    }
    protected ProcessorEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public ProcessorEndpoint(String endpointUri, CamelContext context, Processor processor) {
        super(endpointUri, context);
        this.processor = processor;
    }
    public ProcessorEndpoint(String endpointUri, Component component, Processor processor) {
        super(endpointUri, component);
        this.processor = processor;
    }
    public ProcessorEndpoint(String endpointUri, Processor processor) {
        super(endpointUri);
        this.processor = processor;
    }
    protected ProcessorEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }
    @Override
    public PollingConsumer<Exchange> createPollingConsumer() throws Exception {
        return new ProcessorPollingConsumer(this, getProcessor());
    }
    public Processor getProcessor() throws Exception {
        if (processor == null) {
            processor = createProcessor();
        }
        return processor;
    }
    protected Processor createProcessor() throws Exception {
        return new Processor() {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }
    protected void onExchange(Exchange exchange) throws Exception {
        getProcessor().process(exchange);
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.impl.ProcessorPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeExchangeException;
import org.apache.camel.util.ServiceHelper;
/**
 * A simple implementation of {@link PollingConsumer} which just uses
 * a {@link Processor}. This implementation does not support timeout based
 * receive methods such as {@link #receive(long)}
 *
 * @version $Revision: 640438 $
 */
public class ProcessorPollingConsumer extends PollingConsumerSupport {
    private Processor processor;
    public ProcessorPollingConsumer(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startService(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopService(processor);
    }
    public Exchange receive() {
        Exchange exchange = getEndpoint().createExchange();
        try {
            processor.process(exchange);
        } catch (Exception e) {
            throw new RuntimeExchangeException(e, exchange);
        }
        return exchange;
    }
    public Exchange receiveNoWait() {
        return receive();
    }
    public Exchange receive(long timeout) {
        return receive();
    }
}
"
org.apache.camel.impl.ProducerCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.FailedToCreateProducerException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Cache containing created {@link Producer}.
 *
 * @version $Revision: 660275 $
 */
public class ProducerCache<E extends Exchange> extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(ProducerCache.class);
    private Map<String, Producer<E>> producers = new HashMap<String, Producer<E>>();
    public synchronized Producer<E> getProducer(Endpoint<E> endpoint) {
        String key = endpoint.getEndpointUri();
        Producer<E> answer = producers.get(key);
        if (answer == null) {
            try {
                answer = endpoint.createProducer();
                answer.start();
            } catch (Exception e) {
                throw new FailedToCreateProducerException(endpoint, e);
            }
            producers.put(key, answer);
        }
        return answer;
    }
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    public void send(Endpoint<E> endpoint, E exchange) {
        try {
            Producer<E> producer = getProducer(endpoint);
            producer.process(exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * {@link Processor} to populate the exchange
     *
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange();
            return sendExchange(endpoint, producer, processor, exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * {@link Processor} to populate the exchange.  The callback
     * will be called when the exchange is completed.
     *
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange();
            boolean sync = sendExchange(endpoint, producer, processor, exchange, callback);
            setProcessedSync(exchange, sync);
            return exchange;
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    public static boolean isProcessedSync(Exchange exchange) {
        Boolean rc = exchange.getProperty(ProducerCache.class.getName() + "".SYNC"", Boolean.class);
        return rc == null ? false : rc;
    }
    public static void setProcessedSync(Exchange exchange, boolean b) {
        exchange.setProperty(ProducerCache.class.getName() + "".SYNC"", b ? Boolean.TRUE : Boolean.FALSE);
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * {@link Processor} to populate the exchange
     *
     * @param endpoint the endpoint to send the exchange to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange(pattern);
            return sendExchange(endpoint, producer, processor, exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    protected E sendExchange(Endpoint<E> endpoint, Producer<E> producer, Processor processor, E exchange) throws Exception {
        // lets populate using the processor callback
        processor.process(exchange);
        // now lets dispatch
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> "" + endpoint + "" "" + exchange);
        }
        producer.process(exchange);
        return exchange;
    }
    protected boolean sendExchange(Endpoint<E> endpoint, Producer<E> producer, Processor processor, E exchange, AsyncCallback callback) throws Exception {
        // lets populate using the processor callback
        processor.process(exchange);
        // now lets dispatch
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> "" + endpoint + "" "" + exchange);
        }
        return AsyncProcessorTypeConverter.convert(producer).process(exchange, callback);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(producers.values());
        producers.clear();
    }
    protected void doStart() throws Exception {
    }
}
"
org.apache.camel.impl.ProducerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
/**
 * @version $Revision: 655516 $
 */
public class ProducerTest extends TestSupport {
    protected CamelContext context = new DefaultCamelContext();
    protected ExchangePattern pattern = ExchangePattern.InOnly;
    public void testUsingADerivedExchange() throws Exception {
        DefaultEndpoint<MyExchange> endpoint = new DefaultEndpoint<MyExchange>(""foo"", new DefaultComponent() {
            @Override
            protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
                return null;
            }
        }) {
            public Consumer<MyExchange> createConsumer(Processor processor) throws Exception {
                return null;
            }
            public MyExchange createExchange(ExchangePattern pattern) {
                return new MyExchange(getCamelContext(), pattern);
            }
            public Producer<MyExchange> createProducer() throws Exception {
                return null;
            }
            public boolean isSingleton() {
                return false;
            }
        };
        DefaultProducer producer = new DefaultProducer(endpoint) {
            public void process(Exchange exchange) throws Exception {
                log.debug(""Received: "" + exchange);
            }
        };
        // now lets try send in a normal exchange
        Exchange exchange = new DefaultExchange(context);
        producer.process(exchange);
        Class type = endpoint.getExchangeType();
        assertEquals(""exchange type"", MyExchange.class, type);
        MyExchange actual = endpoint.createExchange(exchange);
        assertNotNull(actual);
        assertTrue(""Not same exchange"", actual != exchange);
        MyExchange expected = new MyExchange(context, pattern);
        actual = endpoint.createExchange(expected);
        assertSame(""Should not copy an exchange when of the correct type"", expected, actual);
    }
}
"
org.apache.camel.impl.RegistryTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Arrays;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.util.jndi.JndiTest;
/**
 * @version $Revision: 630568 $
 */
public class RegistryTest extends TestCase {
    protected JndiRegistry registry;
    public void testBind() throws Exception {
        List foo = Arrays.asList(""a"", ""b"", ""c"");
        registry.bind(""foo"", foo);
        List list = registry.lookup(""foo"", List.class);
        assertEquals(""Should be same!"", foo, list);
    }
    public void testDefaultProviderAllowsValuesToBeCreatedInThePropertiesFile() throws Exception {
        Object value = registry.lookup(""foo"");
        assertEquals(""lookup of foo"", ""bar"", value);
    }
    public void testLookupOfUnknownName() throws Exception {
        Object value = registry.lookup(""No such entry!"");
        assertNull(""Should not find anything!"", value);
    }
    protected void setUp() throws Exception {
        super.setUp();
        registry = new JndiRegistry(JndiTest.createInitialContext());
    }
}
"
org.apache.camel.impl.ReportingTypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.AnnotationTypeConverterLoader;
import org.apache.camel.impl.converter.TypeConverterRegistry;
import org.apache.camel.util.ObjectHelper;
/**
 * Type converter loader that is capable of reporting the loaded type converters.
 * <p/>
 * Used by the camel-maven-plugin.
 */
public class ReportingTypeConverterLoader extends AnnotationTypeConverterLoader {
    private static final Comparator<TypeMapping> COMPARE_LAST_LOADED_FIRST = new Comparator<TypeMapping>() {
        public int compare(TypeMapping t1, TypeMapping t2) {
            if (ObjectHelper.equal(t1.fromType, t2.fromType)) {
                return ObjectHelper.equal(t1.toType, t2.toType) ? t1.index - t2.index : ObjectHelper
                    .compare(getTypeName(t1.toType), getTypeName(t2.toType));
            }
            return ObjectHelper.compare(getTypeName(t1.fromType), getTypeName(t2.fromType));
        }
    };
    private List<TypeMapping> typeMappings = new ArrayList<TypeMapping>();
    public TypeMapping[] getTypeConversions() {
        Collections.sort(typeMappings, COMPARE_LAST_LOADED_FIRST);
        return typeMappings.toArray(new TypeMapping[typeMappings.size()]);
    }
    protected void registerTypeConverter(TypeConverterRegistry registry, Method method, Class toType,
                                         Class fromType, TypeConverter typeConverter) {
        TypeMapping mapping = new TypeMapping(toType, fromType, typeConverter.getClass(), method);
        typeMappings.add(mapping);
    }
    private static String getTypeName(Class type) {
        return type != null ? type.getName() : null;
    }
    /**
     * Represents a mapping from one type (which can be null) to another
     *
     * Used by the camel-maven-plugin.
     */
    public static class TypeMapping {
        private static int counter;
        private Class toType;
        private Class fromType;
        private Class converterType;
        private Method method;
        private int index;
        public TypeMapping(Class toType, Class fromType, Class converterType, Method method) {
            this.toType = toType;
            this.fromType = fromType;
            this.converterType = converterType;
            this.method = method;
            this.index = counter++;
        }
        public Class getFromType() {
            return fromType;
        }
        public Class getToType() {
            return toType;
        }
        public Class getConverterType() {
            return converterType;
        }
        public Method getMethod() {
            return method;
        }
        public int getIndex() {
            return index;
        }
        @Override
        public boolean equals(Object object) {
            if (object instanceof TypeMapping) {
                TypeMapping that = (TypeMapping)object;
                return this.index == that.index;
            }
            return false;
        }
        @Override
        public int hashCode() {
            int answer = toType.hashCode();
            if (fromType != null) {
                answer *= 37 + fromType.hashCode();
            }
            return answer;
        }
        @Override
        public String toString() {
            return ""["" + fromType.getSimpleName() + ""=>"" + toType.getSimpleName() + ""]"";
        }
    }
}
"
org.apache.camel.impl.ReportingTypeConverterRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.TypeConverterRegistry;
import org.apache.camel.spi.Injector;
/**
 * Registry for reporting type converters.
 * <p/>
 * Used by the camel-maven-plugin.
 */
public class ReportingTypeConverterRegistry implements TypeConverterRegistry {
    private List<String> errors = new ArrayList<String>();
    public String[] getErrors() {
        return errors.toArray(new String[errors.size()]);
    }
    public void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter) {
        if (errors.size() == 0) {
            errors.add(""Method should not be invoked."");
        }
    }
    public Injector getInjector() {
        return null;
    }
}
"
org.apache.camel.impl.RouteWithMistypedComponentNameTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.TestSupport;
import org.apache.camel.builder.RouteBuilder;
/**
 * Testing for mistyped component name
 */
public class RouteWithMistypedComponentNameTest extends TestSupport {
    public void testNoSuchComponent() throws Exception {
        CamelContext context = new DefaultCamelContext();
        context.addRoutes(createRouteBuilder());
        try {
            context.start();
            fail(""Should have thrown a NoSuchEndpointException"");
        } catch (NoSuchEndpointException e) {
            // expected
        }
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""mistyped://hello"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.impl.ScheduledPollConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for any consumer which is polling based
 * 
 * @version $Revision: 656947 $
 */
public abstract class ScheduledPollConsumer<E extends Exchange> extends DefaultConsumer<E> implements
    Runnable {
    private static final transient Log LOG = LogFactory.getLog(ScheduledPollConsumer.class);
    private final ScheduledExecutorService executor;
    private long initialDelay = 1000;
    private long delay = 500;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    private boolean useFixedDelay;
    private ScheduledFuture<?> future;
    public ScheduledPollConsumer(DefaultEndpoint<E> endpoint, Processor processor) {
        this(endpoint, processor, endpoint.getExecutorService());
    }
    public ScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor);
        this.executor = executor;
        if (executor == null) {
            throw new IllegalArgumentException(""A non null ScheduledExecutorService must be provided."");
        }
    }
    /**
     * Invoked whenever we should be polled
     */
    public void run() {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Starting to poll: "" + this.getEndpoint());
        }
        try {
            poll();
        } catch (Exception e) {
            // TODO: We should not swallow this but handle it better. See CAMEL-501
            LOG.warn(""An exception occured while polling: "" + this.getEndpoint() + "": "" + e.getMessage(), e);
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getInitialDelay() {
        return initialDelay;
    }
    public void setInitialDelay(long initialDelay) {
        this.initialDelay = initialDelay;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    public void setTimeUnit(TimeUnit timeUnit) {
        this.timeUnit = timeUnit;
    }
    public boolean isUseFixedDelay() {
        return useFixedDelay;
    }
    public void setUseFixedDelay(boolean useFixedDelay) {
        this.useFixedDelay = useFixedDelay;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * The polling method which is invoked periodically to poll this consumer
     * 
     * @throws Exception can be thrown if an exception occured during polling
     */
    protected abstract void poll() throws Exception;
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (isUseFixedDelay()) {
            future = executor.scheduleWithFixedDelay(this, getInitialDelay(), getDelay(), getTimeUnit());
        } else {
            future = executor.scheduleAtFixedRate(this, getInitialDelay(), getDelay(), getTimeUnit());
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (future != null) {
            future.cancel(false);
        }
        super.doStop();
    }
}
"
org.apache.camel.impl.ScheduledPollEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.util.IntrospectionSupport;
/**
 * A base class for {@link Endpoint} which creates a {@link ScheduledPollConsumer}
 *
 * @version $Revision: 655868 $
 */
public abstract class ScheduledPollEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private Map consumerProperties;
    protected ScheduledPollEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    protected ScheduledPollEndpoint(String endpointUri, CamelContext context) {
        super(endpointUri, context);
    }
    protected ScheduledPollEndpoint(String endpointUri) {
        super(endpointUri);
    }
    protected ScheduledPollEndpoint() {
    }
    public Map getConsumerProperties() {
        return consumerProperties;
    }
    public void setConsumerProperties(Map consumerProperties) {
        this.consumerProperties = consumerProperties;
    }
    protected void configureConsumer(Consumer<E> consumer) throws Exception {
        if (consumerProperties != null) {
            // TODO pass in type converter
            IntrospectionSupport.setProperties(getCamelContext().getTypeConverter(), consumer, consumerProperties);
        }
    }
    public void configureProperties(Map options) {
        Map consumerProperties = IntrospectionSupport.extractProperties(options, ""consumer."");
        if (consumerProperties != null) {
            setConsumerProperties(consumerProperties);
        }
    }
}
"
org.apache.camel.impl.SerializationDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.OutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.spi.DataFormat;
/**
 * The <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * using Java Serialiation.
 *
 * @version $Revision: 660275 $
 */
public class SerializationDataFormat implements DataFormat {
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        ObjectOutput out = IOConverter.toObjectOutput(stream);
        out.writeObject(graph);
        out.flush();
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        ObjectInput in = IOConverter.toObjectInput(stream);
        return in.readObject();
    }
}
"
org.apache.camel.impl.ServiceSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.Service;
import org.apache.camel.util.ServiceHelper;
/**
 * A useful base class which ensures that a service is only initialized once and
 * provides some helper methods for enquiring of its status
 *
 * @version $Revision: 659422 $
 */
public abstract class ServiceSupport implements Service {
    private static int threadCounter;
    private AtomicBoolean started = new AtomicBoolean(false);
    private AtomicBoolean starting = new AtomicBoolean(false);
    private AtomicBoolean stopping = new AtomicBoolean(false);
    private AtomicBoolean stopped = new AtomicBoolean(false);
    private Collection childServices;
    public void start() throws Exception {
        if (started.compareAndSet(false, true)) {
            starting.set(true);
            try {
                if (childServices != null) {
                    ServiceHelper.startServices(childServices);
                }
                doStart();
            } finally {
                starting.set(false);
            }
        }
    }
    public void stop() throws Exception {
        if (started.get() && stopping.compareAndSet(false, true)) {
            try {
                doStop();
            } finally {
                if (childServices != null) {
                    ServiceHelper.stopServices(childServices);
                }
                stopped.set(true);
                started.set(false);
                stopping.set(false);
            }
        }
    }
    /**
     * @return true if this service has been started
     */
    public boolean isStarted() {
        return started.get();
    }
    /**
     * @return true if this service is
     */
    public boolean isStarting() {
        return starting.get();
    }
    /**
     * @return true if this service is in the process of closing
     */
    public boolean isStopping() {
        return stopping.get();
    }
    /**
     * Helper methods so the service knows if it should keep running.
     * Returns false if the service is being stopped or is stopped.
     *
     * @return true if the service should continue to run.
     */
    protected boolean isRunAllowed() {
        return !(stopping.get() || stopped.get());
    }
    /**
     * @return true if this service is closed
     */
    public boolean isStopped() {
        return stopped.get();
    }
    protected abstract void doStart() throws Exception;
    protected abstract void doStop() throws Exception;
    /**
     * Creates a new thread name with the given prefix
     */
    protected String getThreadName(String prefix) {
        return prefix + "" thread:"" + nextThreadCounter();
    }
    protected static synchronized int nextThreadCounter() {
        return ++threadCounter;
    }
    protected void addChildService(Object childService) {
        if (childServices == null) {
            childServices = new ArrayList();
        }
        childServices.add(childService);
    }
    protected boolean removeChildService(Object childService) {
        if (childServices != null) {
            return childServices.remove(childService);
        } else {
            return false;
        }
    }
}
"
org.apache.camel.impl.StringDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
/**
 * The text based <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a> supporting
 * charset encoding.
 *
 * @version $Revision: 647575 $
 */
public class StringDataFormat implements DataFormat {
    private String charset;
    public StringDataFormat(String charset) {
        this.charset = charset;
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        String text = ExchangeHelper.convertToType(exchange, String.class, graph);
        byte[] bytes;
        if (charset != null) {
            bytes = text.getBytes(charset);
        } else {
            bytes = text.getBytes();
        }
        stream.write(bytes);
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        byte[] bytes = IOConverter.toBytes(stream);
        String answer;
        if (charset != null) {
            answer = new String(bytes, charset);
        } else {
            answer = new String(bytes);
        }
        return answer;
    }
}
"
org.apache.camel.impl.StringDataFormatTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.TestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test of the string data format.
 */
public class StringDataFormatTest extends TestSupport {
    private CamelContext context;
    private ProducerTemplate template;
    protected void setUp() throws Exception {
        context = new DefaultCamelContext();
        template = context.createProducerTemplate();
        template.start();
    }
    protected void tearDown() throws Exception {
        template.stop();
        context.stop();
    }
    public void testMarshalUTF8() throws Exception {
        // NOTE: We are using a processor to do the assertions as the mock endpoint (Camel) does not yet support
        // type conversion using byte and strings where you can set a charset encoding
        // include a UTF-8 char in the text \u0E08 is a Thai elephant
        final String title = ""Hello Thai Elephant \u0E08"";
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:start"").marshal().string(""UTF-8"").process(new MyBookProcessor(""UTF-8"", title));
            }
        });
        context.start();
        MyBook book = new MyBook();
        book.setTitle(title);
        template.sendBody(""direct:start"", book);
    }
    public void testMarshalNoEncoding() throws Exception {
        // NOTE: We are using a processor to do the assertions as the mock endpoint (Camel) does not yet support
        // type conversion using byte and strings where you can set a charset encoding
        final String title = ""Hello World"";
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:start"").marshal().string().process(new MyBookProcessor(null, title));
            }
        });
        context.start();
        MyBook book = new MyBook();
        book.setTitle(title);
        template.sendBody(""direct:start"", book);
    }
    public void testUnmarshalUTF8() throws Exception {
        // NOTE: Here we can use a MockEndpoint as we unmarshal the inputstream to String
        // include a UTF-8 char in the text \u0E08 is a Thai elephant
        final String title = ""Hello Thai Elephant \u0E08"";
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:start"").unmarshal().string(""UTF-8"").to(""mock:unmarshal"");
            }
        });
        context.start();
        byte[] bytes = title.getBytes(""UTF-8"");
        InputStream in = new ByteArrayInputStream(bytes);
        template.sendBody(""direct:start"", in);
        MockEndpoint mock = context.getEndpoint(""mock:unmarshal"", MockEndpoint.class);
        mock.setExpectedMessageCount(1);
        mock.expectedBodiesReceived(title);
    }
    public void testUnmarshalNoEncoding() throws Exception {
        // NOTE: Here we can use a MockEndpoint as we unmarshal the inputstream to String
        final String title = ""Hello World"";
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:start"").unmarshal().string().to(""mock:unmarshal"");
            }
        });
        context.start();
        byte[] bytes = title.getBytes();
        InputStream in = new ByteArrayInputStream(bytes);
        template.sendBody(""direct:start"", in);
        MockEndpoint mock = context.getEndpoint(""mock:unmarshal"", MockEndpoint.class);
        mock.setExpectedMessageCount(1);
        mock.expectedBodiesReceived(title);
    }
    private class MyBookProcessor implements Processor {
        private String encoding;
        private String title;
        public MyBookProcessor(String encoding, String title) {
            this.encoding = encoding;
            this.title = title;
        }
        public void process(Exchange exchange) throws Exception {
            byte[] body = exchange.getIn().getBody(byte[].class);
            String text;
            if (encoding != null) {
                text = new String(body, encoding);
            } else {
                text = new String(body);
            }
            // does the testing
            assertEquals(text, title);
        }
    }
    private class MyBook {
        private String title;
        public String getTitle() {
            return title;
        }
        public void setTitle(String title) {
            this.title = title;
        }
        public String toString() {
            // Camel will fallback to object toString converter and thus we get this text
            return title;
        }
    }
}
"
org.apache.camel.impl.converter.AnnotationTypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;
import static java.lang.reflect.Modifier.isAbstract;
import static java.lang.reflect.Modifier.isPublic;
import static java.lang.reflect.Modifier.isStatic;
import org.apache.camel.Converter;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ResolverUtil;
import org.apache.camel.util.WebSphereResolverUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A class which will auto-discover converter objects and methods to pre-load
 * the registry of converters on startup
 *
 * @version $Revision: 675471 $
 */
public class AnnotationTypeConverterLoader implements TypeConverterLoader {
    public static final String META_INF_SERVICES = ""META-INF/services/org/apache/camel/TypeConverter"";
    private static final transient Log LOG = LogFactory.getLog(AnnotationTypeConverterLoader.class);
    private ResolverUtil resolver = new ResolverUtil();
    private Set<Class> visitedClasses = new HashSet<Class>();
    public AnnotationTypeConverterLoader() {
        // use WebSphere specific resolver if running on WebSphere
        if (WebSphereResolverUtil.isWebSphereClassLoader(this.getClass().getClassLoader())) {
            LOG.info(""Using WebSphere specific ResolverUtil"");
            resolver = new WebSphereResolverUtil(META_INF_SERVICES);
        }
    }
    public void load(TypeConverterRegistry registry) throws Exception {
        String[] packageNames = findPackageNames();
        resolver.findAnnotated(Converter.class, packageNames);
        Set<Class> classes = resolver.getClasses();
        for (Class type : classes) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Loading converter class: "" + ObjectHelper.name(type));
            }
            loadConverterMethods(registry, type);
        }
    }
    /**
     * Finds the names of the packages to search for on the classpath looking
     * for text files on the classpath at the {@link #META_INF_SERVICES} location.
     *
     * @return a collection of packages to search for
     * @throws IOException is thrown for IO related errors
     */
    protected String[] findPackageNames() throws IOException {
        Set<String> packages = new HashSet<String>();
        findPackages(packages, Thread.currentThread().getContextClassLoader());
        findPackages(packages, getClass().getClassLoader());
        return packages.toArray(new String[packages.size()]);
    }
    protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {
        Enumeration<URL> resources = classLoader.getResources(META_INF_SERVICES);
        while (resources.hasMoreElements()) {
            URL url = resources.nextElement();
            if (url != null) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                try {
                    while (true) {
                        String line = reader.readLine();
                        if (line == null) {
                            break;
                        }
                        line = line.trim();
                        if (line.startsWith(""#"") || line.length() == 0) {
                            continue;
                        }
                        tokenize(packages, line);
                    }
                } finally {
                    ObjectHelper.close(reader, null, LOG);
                }
            }
        }
    }
    /**
     * Tokenizes the line from the META-IN/services file using commas and
     * ignoring whitespace between packages
     */
    protected void tokenize(Set<String> packages, String line) {
        StringTokenizer iter = new StringTokenizer(line, "","");
        while (iter.hasMoreTokens()) {
            String name = iter.nextToken().trim();
            if (name.length() > 0) {
                packages.add(name);
            }
        }
    }
    /**
     * Loads all of the converter methods for the given type
     */
    protected void loadConverterMethods(TypeConverterRegistry registry, Class type) {
        if (visitedClasses.contains(type)) {
            return;
        }
        visitedClasses.add(type);
        try {
            Method[] methods = type.getDeclaredMethods();
            CachingInjector injector = null;
            for (Method method : methods) {
                Converter annotation = method.getAnnotation(Converter.class);
                if (annotation != null) {
                    Class<?>[] parameterTypes = method.getParameterTypes();
                    if (parameterTypes == null || parameterTypes.length != 1) {
                        LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method
                                + "" as a converter method should have one parameter"");
                    } else {
                        int modifiers = method.getModifiers();
                        if (isAbstract(modifiers) || !isPublic(modifiers)) {
                            LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method
                                    + "" as a converter method is not a public and concrete method"");
                        } else {
                            Class toType = method.getReturnType();
                            if (toType.equals(Void.class)) {
                                LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: ""
                                        + method + "" as a converter method returns a void method"");
                            } else {
                                Class fromType = parameterTypes[0];
                                if (isStatic(modifiers)) {
                                    registerTypeConverter(registry, method, toType, fromType,
                                                          new StaticMethodTypeConverter(method));
                                } else {
                                    if (injector == null) {
                                        injector = new CachingInjector(registry, type);
                                    }
                                    registerTypeConverter(registry, method, toType, fromType,
                                            new InstanceMethodTypeConverter(injector, method));
                                }
                            }
                        }
                    }
                }
            }
            Class superclass = type.getSuperclass();
            if (superclass != null && !superclass.equals(Object.class)) {
                loadConverterMethods(registry, superclass);
            }
        } catch (NoClassDefFoundError e) {
            LOG.debug(""Ignoring converter type: "" + type.getName() + "" as a dependent class could not be found: "" + e, e);
        }
    }
    protected void registerTypeConverter(TypeConverterRegistry registry, Method method,
                                         Class toType, Class fromType, TypeConverter typeConverter) {
        registry.addTypeConverter(toType, fromType, typeConverter);
    }
}
"
org.apache.camel.impl.converter.ArrayTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.apache.camel.TypeConverter;
/**
 * A type converter which is used to convert to and from array types
 * particularly for derived types of array component types and dealing with
 * primitive array types.
 * 
 * @version $Revision: 660275 $
 */
public class ArrayTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> type, Object value) {
        if (type.isArray()) {
            if (value instanceof Collection) {
                Collection collection = (Collection)value;
                Object array = Array.newInstance(type.getComponentType(), collection.size());
                if (array instanceof Object[]) {
                    collection.toArray((Object[])array);
                } else {
                    int index = 0;
                    for (Object element : collection) {
                        Array.set(array, index++, element);
                    }
                }
                return (T)array;
            } else if (value != null && value.getClass().isArray()) {
                int size = Array.getLength(value);
                Object answer = Array.newInstance(type.getComponentType(), size);
                for (int i = 0; i < size; i++) {
                    Array.set(answer, i, Array.get(value, i));
                }
                return (T)answer;
            }
        } else if (Collection.class.isAssignableFrom(type)) {
            if (value != null) {
                if (value instanceof Object[]) {
                    return (T)Arrays.asList((Object[])value);
                } else if (value.getClass().isArray()) {
                    int size = Array.getLength(value);
                    List answer = new ArrayList(size);
                    for (int i = 0; i < size; i++) {
                        answer.add(Array.get(value, i));
                    }
                    return (T)answer;
                }
            }
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.AsyncProcessorTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.TypeConverter;
import org.apache.camel.processor.DelegateProcessor;
/**
 * A simple converter that can convert any {@link Processor} to an {@link AsyncProcessor}.
 * Processing will still occur synchronously but it will provide the required
 * notifications that the caller expects.
 * 
 * @version $Revision: 659849 $
 */
public class AsyncProcessorTypeConverter implements TypeConverter {
    private static final class ProcessorToAsyncProcessorBridge extends DelegateProcessor implements AsyncProcessor {
        private ProcessorToAsyncProcessorBridge(Processor processor) {
            super(processor);
        }
        public boolean process(Exchange exchange, AsyncCallback callback) {
            try {
                processor.process(exchange);
            } catch (Throwable e) {
                exchange.setException(e);
            }
            // false means processing of the exchange asynchronously,
            callback.done(true);
            return true;
        }
    }
    public <T> T convertTo(Class<T> toType, Object value) {
        if (value != null) {
            if (toType.equals(AsyncProcessor.class)) {
                if (value instanceof AsyncProcessor) {
                    return toType.cast(value);
                } else if (value instanceof Processor) {
                    // Provide an async bridge to the regular processor.
                    final Processor processor = (Processor)value;
                    return toType.cast(new ProcessorToAsyncProcessorBridge(processor));
                }
            }
        }
        return null;
    }
    public static AsyncProcessor convert(Processor value) {
        if (value instanceof AsyncProcessor) {
            return (AsyncProcessor)value;
        }
        return new ProcessorToAsyncProcessorBridge(value);
    }
}
"
org.apache.camel.impl.converter.CachingInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
/**
 * A caching proxy
 *
 * @version $Revision: 648954 $
 */
public class CachingInjector<T> {
    private final TypeConverterRegistry repository;
    private final Class<T> type;
    private T instance;
    public CachingInjector(TypeConverterRegistry repository, Class<T> type) {
        this.repository = repository;
        this.type = type;
    }
    public synchronized T newInstance() {
        if (instance == null) {
            instance = createInstance(type);
        }
        return instance;
    }
    protected T createInstance(Class<T> t) {
        return repository.getInjector().newInstance(t);
    }
}
"
org.apache.camel.impl.converter.DefaultTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.TypeConverterAware;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Default implementation of a type converter registry used for
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">type converters</a> in Camel.
 *
 * @version $Revision: 659849 $
 */
public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistry {
    private static final transient Log LOG = LogFactory.getLog(DefaultTypeConverter.class);
    private final Map<TypeMapping, TypeConverter> typeMappings = new HashMap<TypeMapping, TypeConverter>();
    private Injector injector;
    private List<TypeConverterLoader> typeConverterLoaders = new ArrayList<TypeConverterLoader>();
    private List<TypeConverter> fallbackConverters = new ArrayList<TypeConverter>();
    private boolean loaded;
    public DefaultTypeConverter(Injector injector) {
        typeConverterLoaders.add(new AnnotationTypeConverterLoader());
        this.injector = injector;
        addFallbackConverter(new AsyncProcessorTypeConverter());
        addFallbackConverter(new PropertyEditorTypeConverter());
        addFallbackConverter(new ToStringTypeConverter());
        addFallbackConverter(new ArrayTypeConverter());
        addFallbackConverter(new EnumTypeConverter());
    }
    public <T> T convertTo(Class<T> toType, Object value) {
        if (toType.isInstance(value)) {
            return toType.cast(value);
        }
        checkLoaded();
        TypeConverter converter = getOrFindTypeConverter(toType, value);
        if (converter != null) {
            return converter.convertTo(toType, value);
        }
        for (TypeConverter fallback : fallbackConverters) {
            T rc = fallback.convertTo(toType, value);
            if (rc != null) {
                return rc;
            }
        }
        // lets avoid NullPointerException when converting to boolean for null values
        if (boolean.class.isAssignableFrom(toType)) {
            return (T) Boolean.FALSE;
        }
        if (toType.isPrimitive()) {
            Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(toType);
            if (primitiveType != toType) {
                return (T) convertTo(primitiveType, value);
            }
        }
        return null;
    }
    public void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter) {
        TypeMapping key = new TypeMapping(toType, fromType);
        synchronized (typeMappings) {
            TypeConverter converter = typeMappings.get(key);
            if (converter != null) {
                LOG.warn(""Overriding type converter from: "" + converter + "" to: "" + typeConverter);
            }
            typeMappings.put(key, typeConverter);
        }
    }
    public void addFallbackConverter(TypeConverter converter) {
        fallbackConverters.add(converter);
        if (converter instanceof TypeConverterAware) {
            TypeConverterAware typeConverterAware = (TypeConverterAware)converter;
            typeConverterAware.setTypeConverter(this);
        }
    }
    public TypeConverter getTypeConverter(Class toType, Class fromType) {
        TypeMapping key = new TypeMapping(toType, fromType);
        synchronized (typeMappings) {
            return typeMappings.get(key);
        }
    }
    public Injector getInjector() {
        return injector;
    }
    public void setInjector(Injector injector) {
        this.injector = injector;
    }
    protected <T> TypeConverter getOrFindTypeConverter(Class toType, Object value) {
        Class fromType = null;
        if (value != null) {
            fromType = value.getClass();
        }
        TypeMapping key = new TypeMapping(toType, fromType);
        TypeConverter converter;
        synchronized (typeMappings) {
            converter = typeMappings.get(key);
            if (converter == null) {
                converter = findTypeConverter(toType, fromType, value);
                if (converter != null) {
                    typeMappings.put(key, converter);
                }
            }
        }
        return converter;
    }
    /**
     * Tries to auto-discover any available type converters
     */
    protected TypeConverter findTypeConverter(Class toType, Class fromType, Object value) {
        // lets try the super classes of the from type
        if (fromType != null) {
            Class fromSuperClass = fromType.getSuperclass();
            if (fromSuperClass != null && !fromSuperClass.equals(Object.class)) {
                TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                if (converter == null) {
                    converter = findTypeConverter(toType, fromSuperClass, value);
                }
                if (converter != null) {
                    return converter;
                }
            }
            for (Class type : fromType.getInterfaces()) {
                TypeConverter converter = getTypeConverter(toType, type);
                if (converter != null) {
                    return converter;
                }
            }
            // lets test for arrays
            if (fromType.isArray() && !fromType.getComponentType().isPrimitive()) {
                // TODO can we try walking the inheritance-tree for the element types?
                if (!fromType.equals(Object[].class)) {
                    fromSuperClass = Object[].class;
                    TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                    if (converter == null) {
                        converter = findTypeConverter(toType, fromSuperClass, value);
                    }
                    if (converter != null) {
                        return converter;
                    }
                }
            }
            // lets test for Object based converters
            if (!fromType.equals(Object.class)) {
                TypeConverter converter = getTypeConverter(toType, Object.class);
                if (converter != null) {
                    return converter;
                }
            }
        }
        // lets try classes derived from this toType
        if (fromType != null) {
            Set<Map.Entry<TypeMapping, TypeConverter>> entries = typeMappings.entrySet();
            for (Map.Entry<TypeMapping, TypeConverter> entry : entries) {
                TypeMapping key = entry.getKey();
                Class aToType = key.getToType();
                if (toType.isAssignableFrom(aToType)) {
                    if (key.getFromType().isAssignableFrom(fromType)) {
                        return entry.getValue();
                    }
                }
            }
        }
        // TODO look at constructors of toType?
        return null;
    }
    /**
     * Checks if the registry is loaded and if not lazily load it
     */
    protected synchronized void checkLoaded() {
        if (!loaded) {
            loaded = true;
            try {
                for (TypeConverterLoader typeConverterLoader : typeConverterLoaders) {
                    typeConverterLoader.load(this);
                }
                // lets try load any other fallback converters
                try {
                    loadFallbackTypeConverters();
                } catch (NoFactoryAvailableException e) {
                    // ignore its fine to have none
                }
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
        }
    }
    protected void loadFallbackTypeConverters() throws IOException, ClassNotFoundException {
        FactoryFinder finder = new FactoryFinder();
        List<TypeConverter> converters = finder.newInstances(""FallbackTypeConverter"", getInjector(),
                                                             TypeConverter.class);
        for (TypeConverter converter : converters) {
            addFallbackConverter(converter);
        }
    }
    /**
     * Represents a mapping from one type (which can be null) to another
     */
    protected static class TypeMapping {
        Class toType;
        Class fromType;
        public TypeMapping(Class toType, Class fromType) {
            this.toType = toType;
            this.fromType = fromType;
        }
        public Class getFromType() {
            return fromType;
        }
        public Class getToType() {
            return toType;
        }
        @Override
        public boolean equals(Object object) {
            if (object instanceof TypeMapping) {
                TypeMapping that = (TypeMapping)object;
                return ObjectHelper.equal(this.fromType, that.fromType)
                       && ObjectHelper.equal(this.toType, that.toType);
            }
            return false;
        }
        @Override
        public int hashCode() {
            int answer = toType.hashCode();
            if (fromType != null) {
                answer *= 37 + fromType.hashCode();
            }
            return answer;
        }
        @Override
        public String toString() {
            return ""["" + fromType + ""=>"" + toType + ""]"";
        }
    }
}
"
org.apache.camel.impl.converter.EnumTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A type converter which is used to convert to and from array types
 * particularly for derived types of array component types and dealing with
 * primitive array types.
 *
 * @version $Revision: 660275 $
 */
public class EnumTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> type, Object value) {
        if (type.isEnum() && value != null) {
            String text = value.toString();
            Method method = null;
            try {
                method = type.getMethod(""valueOf"", String.class);
            } catch (NoSuchMethodException e) {
                throw new RuntimeCamelException(""Could not find valueOf method on enum type: "" + type.getName());
            }
            return (T) ObjectHelper.invokeMethod(method, null, text);
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.InstanceMethodTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link TypeConverter} implementation which instantiates an object
 * so that an instance method can be used as a type converter
 *
 * @version $Revision: 661565 $
 */
public class InstanceMethodTypeConverter implements TypeConverter {
    private final CachingInjector injector;
    private final Method method;
    public InstanceMethodTypeConverter(CachingInjector injector, Method method) {
        this.injector = injector;
        this.method = method;
    }
    @Override
    public String toString() {
        return ""InstanceMethodTypeConverter: "" + method;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        Object instance = injector.newInstance();
        if (instance == null) {
            throw new RuntimeCamelException(""Could not instantiate an instance of: "" + type.getName());
        }
        return (T) ObjectHelper.invokeMethod(method, instance, value);
    }
}
"
org.apache.camel.impl.converter.PropertyEditorTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * Uses the {@link java.beans.PropertyEditor} conversion system to convert Objects to
 * and from String values.
 *
 * @version $Revision: 659798 $
 */
public class PropertyEditorTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> toType, Object value) {
        // We can't convert null values since we can't figure out a property
        // editor for it.
        if (value == null) {
            return null;
        }
        if (value.getClass() == String.class) {
            // No conversion needed.
            if (toType == String.class) {
                return ObjectHelper.cast(toType, value);
            }
            PropertyEditor editor = PropertyEditorManager.findEditor(toType);
            if (editor != null) {
                editor.setAsText(value.toString());
                return ObjectHelper.cast(toType, editor.getValue());
            }
        } else if (toType == String.class) {
            PropertyEditor editor = PropertyEditorManager.findEditor(value.getClass());
            if (editor != null) {
                editor.setValue(value);
                return ObjectHelper.cast(toType, editor.getAsText());
            }
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.StaticMethodTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link TypeConverter} implementation which invokes a static method to convert from a type to another type
 *
 * @version $Revision: 630591 $
 */
public class StaticMethodTypeConverter implements TypeConverter {
    private final Method method;
    public StaticMethodTypeConverter(Method method) {
        this.method = method;
    }
    @Override
    public String toString() {
        return ""StaticMethodTypeConverter: "" + method;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        return (T) ObjectHelper.invokeMethod(method, null, value);
    }
}
"
org.apache.camel.impl.converter.ToStringTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.TypeConverter;
/**
 * A simple converter that can convert any object to a String type by using the
 * toString() method of the object.
 * 
 * @version $Revision: 630591 $
 */
public class ToStringTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> toType, Object value) {
        if (value != null) {
            if (toType.equals(String.class)) {
                return (T)value.toString();
            }
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.TypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
/**
 * A pluggable strategy to load type converters into a registry from some kind of mechanism
 *
 * @version $Revision: 659798 $
 */
public interface TypeConverterLoader {
    /**
     * A pluggable strategy to load type converters into a registry from some kind of mechanism
     *
     * @param registry the registry to load the type converters into
     * @throws Exception if the type converters could not be loaded
     */
    void load(TypeConverterRegistry registry) throws Exception;
}
"
org.apache.camel.impl.converter.TypeConverterRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;
/**
 * Registry for type converters.
 *
 * @version $Revision: 659798 $
 */
public interface TypeConverterRegistry {
    /**
     * Allows a new type converter to be registered
     *
     * @param toType        the type to convert to
     * @param fromType      the type to convert from
     * @param typeConverter the type converter to use
     */
    void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter);
    Injector getInjector();
}
"
org.apache.camel.issues.AmahDeadLetterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class AmahDeadLetterTest extends ContextTestSupport {
    public void testException() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:err"");
        mock.expectedMessageCount(1);
        template.sendBody(""seda:a"", ""Test message"");
        mock.assertIsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                errorHandler(deadLetterChannel(""mock:err""));
                from(""seda:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        throw new Exception(""Test exception"");
                    }
                });
            }
        };
    }
}
"
org.apache.camel.issues.DavidSiefertTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 652240 $
 */
public class DavidSiefertTest extends ContextTestSupport {
    protected static Object expectedBody = ""Some Output"";
    public void testWorks() throws Exception {
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedMessageCount(1);
        result.expectedBodiesReceived(expectedBody);
        result.message(0).header(""sample.name"").equals(""myValue"");
        template.sendBody(""direct:start"", ""<sample><name>value</name></sample>"");
        result.assertIsSatisfied();
    }
    public void testHeaderPredicateFails() throws Exception {
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.message(0).header(""sample.name"").isEqualTo(""shouldNotMatch"");
        template.sendBody(""direct:start"", ""<sample><name>value</name></sample>"");
        try {
            result.assertIsSatisfied();
            fail(""Should have failed this test!"");
        } catch (AssertionError e) {
            log.info(""Caught expected assertion failure: "" + e, e);
        }
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").process(new MyProcessor()).to(""mock:result"");
            }
        };
    }
    public static class MyProcessor implements Processor {
        public void process(Exchange exchange) throws Exception {
            String input = exchange.getIn().getBody(String.class);
            Message output = exchange.getOut();
            output.setHeader(""sample.name"", ""myValue"");
            output.setBody(expectedBody);
        }
    }
}
"
org.apache.camel.issues.ExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class ExceptionTest extends ContextTestSupport {
    public void testExceptionWithoutHandler() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""<body/>"");
        assertMockEndpointsSatisifed();
    }
    public void testExceptionWithHandler() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        MockEndpoint exceptionEndpoint = getMockEndpoint(""mock:exception"");
        exceptionEndpoint.expectedMessageCount(1);
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""<body/>"");
        assertMockEndpointsSatisifed();
    }
    public void testExceptionWithLongHandler() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        MockEndpoint exceptionEndpoint = getMockEndpoint(""mock:exception"");
        exceptionEndpoint.expectedBodiesReceived(""<handled/>"");
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""<body/>"");
        assertMockEndpointsSatisifed();
    }
    public void testLongRouteWithHandler() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        MockEndpoint exceptionEndpoint = getMockEndpoint(""mock:exception"");
        exceptionEndpoint.expectedMessageCount(1);
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start2"", ""<body/>"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        final Processor exceptionThrower = new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""<exception/>"");
                throw new IllegalArgumentException(""Exception thrown intentionally."");
            }
        };
        return new RouteBuilder() {
            public void configure() {
                if (getName().endsWith(""WithLongHandler"")) {
                    log.debug(""Using long exception handler"");
                    exception(IllegalArgumentException.class).setBody(constant(""<handled/>"")).
                        to(""mock:exception"");
                } else if (getName().endsWith(""WithHandler"")) {
                    log.debug(""Using exception handler"");
                    exception(IllegalArgumentException.class).to(""mock:exception"");
                }
                from(""direct:start"").process(exceptionThrower).to(""mock:result"");
                from(""direct:start2"").to(""direct:intermediate"").to(""mock:result"");
                from(""direct:intermediate"").setBody(constant(""<some-value/>"")).process(exceptionThrower).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.issues.InterceptorLogTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Testing http://activemq.apache.org/camel/dsl.html
 */
public class InterceptorLogTest extends ContextTestSupport {
    public void testInterceptor() throws Exception {
        MockEndpoint intercept = getMockEndpoint(""mock:intercept"");
        intercept.expectedMessageCount(2);
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(1);
        mock.expectedBodiesReceived(""Hello World"");
        template.sendBody(""seda:foo"", ""Hello World"");
        intercept.assertIsSatisfied();
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // lets log all steps in all routes (must use proceed to let the exchange continue its
                // normal route path instead of swallowing it here by our intercepter.
                intercept().to(""log:foo"").proceed().to(""mock:intercept"");
                intercept().to(""log:bar"").proceed();
                from(""seda:foo"").to(""seda:bar"");
                from(""seda:bar"").intercept().to(""log:cheese"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.issues.InterceptorPredicateProceedAndStopTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Testing http://activemq.apache.org/camel/dsl.html
 */
public class InterceptorPredicateProceedAndStopTest extends ContextTestSupport {
    public void testInterceptorNoPredicate() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                intercept().to(""mock:test"");
                from(""seda:order"").to(""mock:ok"");
            }
        });
        MockEndpoint mockTest = getMockEndpoint(""mock:test"");
        mockTest.expectedBodiesReceived(""Camel in Action"");
        MockEndpoint mockOk = getMockEndpoint(""mock:ok"");
        mockOk.expectedBodiesReceived(""Camel in Action"");
        template.sendBodyAndHeader(""seda:order"", ""Camel in Action"", ""user"", ""test"");
        mockTest.assertIsSatisfied();
        mockOk.assertIsSatisfied();
    }
    public void testInterceptorNoPredicateAndProceed() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                intercept().to(""mock:test"").proceed();
                from(""seda:order"").to(""mock:ok"");
            }
        });
        MockEndpoint mockTest = getMockEndpoint(""mock:test"");
        mockTest.expectedBodiesReceived(""Camel in Action"");
        MockEndpoint mockOk = getMockEndpoint(""mock:ok"");
        mockOk.expectedBodiesReceived(""Camel in Action"");
        template.sendBodyAndHeader(""seda:order"", ""Camel in Action"", ""user"", ""test"");
        mockTest.assertIsSatisfied();
        mockOk.assertIsSatisfied();
    }
    public void testInterceptorNoPredicateAndStop() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                intercept().to(""mock:test"").stop();
                from(""seda:order"").to(""mock:ok"");
            }
        });
        MockEndpoint mockTest = getMockEndpoint(""mock:test"");
        mockTest.expectedBodiesReceived(""Camel in Action"");
        MockEndpoint mockOk = getMockEndpoint(""mock:ok"");
        mockOk.expectedMessageCount(0);
        template.sendBodyAndHeader(""seda:order"", ""Camel in Action"", ""user"", ""test"");
        mockTest.assertIsSatisfied();
        mockOk.assertIsSatisfied();
    }
    public void testInterceptorWithPredicate() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                intercept(header(""user"").isEqualTo(""test"")).to(""mock:test"");
                from(""seda:order"").to(""mock:ok"");
            }
        });
        MockEndpoint mockTest = getMockEndpoint(""mock:test"");
        mockTest.expectedBodiesReceived(""Camel in Action"");
        MockEndpoint mockOk = getMockEndpoint(""mock:ok"");
        mockOk.expectedBodiesReceived(""Camel in Action"");
        template.sendBodyAndHeader(""seda:order"", ""Camel in Action"", ""user"", ""test"");
        mockTest.assertIsSatisfied();
        mockOk.assertIsSatisfied();
    }
    public void testInterceptorWithPredicateAndProceed() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                intercept(header(""user"").isEqualTo(""test"")).to(""mock:test"").proceed();
                from(""seda:order"").to(""mock:ok"");
            }
        });
        MockEndpoint mockTest = getMockEndpoint(""mock:test"");
        mockTest.expectedBodiesReceived(""Camel in Action"");
        MockEndpoint mockOk = getMockEndpoint(""mock:ok"");
        mockOk.expectedBodiesReceived(""Camel in Action"");
        template.sendBodyAndHeader(""seda:order"", ""Camel in Action"", ""user"", ""test"");
        mockTest.assertIsSatisfied();
        mockOk.assertIsSatisfied();
    }
    public void testInterceptorWithPredicateAndStop() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                intercept(header(""user"").isEqualTo(""test"")).to(""mock:test"").stop();
                from(""seda:order"").to(""mock:ok"");
            }
        });
        MockEndpoint mockTest = getMockEndpoint(""mock:test"");
        mockTest.expectedBodiesReceived(""Camel in Action"");
        MockEndpoint mockOk = getMockEndpoint(""mock:ok"");
        mockOk.expectedMessageCount(0);
        template.sendBodyAndHeader(""seda:order"", ""Camel in Action"", ""user"", ""test"");
        mockTest.assertIsSatisfied();
        mockOk.assertIsSatisfied();
    }
}
"
org.apache.camel.issues.Issue170Test,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class Issue170Test extends ContextTestSupport {
    protected String qOne = ""seda:Q1"";
    protected String qTwo = ""mock:Q2"";
    protected String qThree = ""mock:Q3"";
    public void testSendMessagesGetCorrectCounts() throws Exception {
        MockEndpoint q2 = getMockEndpoint(qTwo);
        MockEndpoint q3 = getMockEndpoint(qThree);
        String body1 = ""<message id='1'/>"";
        String body2 = ""<message id='2'/>"";
        q2.expectedBodiesReceived(body1, body2);
        q3.expectedBodiesReceived(body1, body2);
        template.sendBodyAndHeader(""direct:start"", body1, ""counter"", 1);
        template.sendBodyAndHeader(""direct:start"", body2, ""counter"", 2);
        assertMockEndpointsSatisifed();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(qOne);
                from(qOne).to(qTwo, qThree); // write to Q3 but not to Q2
            }
        };
    }
}
"
org.apache.camel.issues.Issue3Test,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630591 $
 */
public class Issue3Test extends ContextTestSupport {
    protected String fromQueue = ""direct:A"";
    public void testIssue() throws Exception {
        sendBody(fromQueue, ""ha!"");
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(fromQueue).process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        final Message in = exchange.getIn();
                        assertNotNull(""Message is Null"", in);
                        String isDebugString = in.getHeader(""someproperty"", String.class);
                        assertNull(""Header should be null but is: "" + isDebugString, isDebugString);
                        assertNotNull(""Message is Null"", in);
                        // the following line throws an NPE due to null being converted to a boolean
                        //boolean isDebug = in.getHeader(""someproperty"", Boolean.class);
                        //assertFalse(isDebug);
                        Boolean isDebug = in.getHeader(""someproperty"", Boolean.class);
                        assertNull(isDebug);
                        boolean isDebug2 = in.getHeader(""someproperty"", boolean.class);
                        assertFalse(isDebug2);
                    }
                });
            }
        };
    }
}
"
org.apache.camel.issues.NeilSplitterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 640438 $
 */
public class NeilSplitterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    class CatFight {
        String name;
        String[] cats;
        public String[] getCats() {
            return cats;
        }
        public void setCats(String[] cats) {
            this.cats = cats;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
    public void testCustomExpression() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Ginger"", ""Mr Boots"");
        template.send(""direct:custom"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                CatFight catFight = new CatFight();
                catFight.setName(""blueydart"");
                catFight.setCats(new String[]{""Ginger"", ""Mr Boots""});
                in.setBody(catFight);
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
    }
    public void testXPathExpression() throws Exception {
        resultEndpoint.expectedBodiesReceived(
                ""<b>Ginger</b>"",
                ""<b>Mr Boots</b>"");
        template.send(""direct:xpath"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""<a><b>Ginger</b><b>Mr Boots</b></a> "");
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                Expression catFightCats = new Expression() {
                    public Object evaluate(Exchange exchange) {
                        CatFight catFight = (CatFight)
                                exchange.getIn().getBody();
                        String[] cats = catFight.getCats();
                        return cats;
                    }
                };
                from(""direct:custom"").splitter(catFightCats).to(""mock:result"");
                from(""direct:xpath"").splitter(xpath(""/a/b"")).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.issues.RomeksExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class RomeksExceptionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(RomeksExceptionTest.class);
    public void testRouteA() throws Exception {
        assertErrorHandlingWorks(""a"");
    }
    public void testRouteB() throws Exception {
        assertErrorHandlingWorks(""b"");
    }
    protected void assertErrorHandlingWorks(String route) throws InterruptedException {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        MockEndpoint exceptionEndpoint = getMockEndpoint(""mock:exception"");
        resultEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedBodiesReceived(""<exception/>"");
        template.sendBodyAndHeader(""direct:start"", ""<body/>"", ""route"", route);
        assertMockEndpointsSatisifed();
        List<Exchange> list = exceptionEndpoint.getReceivedExchanges();
        Exchange exchange = list.get(0);
        LOG.debug(""Received: "" + exchange.getIn());
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        final Processor exceptionThrower = new Processor() {
            public void process(Exchange exchange) throws Exception {
                LOG.debug(""About to throw exception on "" + exchange);
                exchange.getIn().setBody(""<exception/>"");
                throw new IllegalArgumentException(""Exception thrown intentionally."");
            }
        };
        return new RouteBuilder() {
            public void configure() {
                exception(IllegalArgumentException.class).to(""mock:exception"");
                from(""direct:start"").
                        recipientList().simple(""direct:${header.route}"").
                        to(""mock:result"");
                from(""direct:a"").
                        setBody(constant(""<some-value/>"")).
                        process(exceptionThrower).
                        to(""mock:result"");
                from(""direct:b"").
                        process(exceptionThrower).
                        setBody(constant(""<some-value/>"")).
                        to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.issues.SetHeaderIssueTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class SetHeaderIssueTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    protected String matchingBody = ""<person xmlns='urn:cheese' name='James' city='London'/>"";
    protected String notMatchingBody = ""<person xmlns='urn:cheese' name='Hiram' city='Tampa'/>"";
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        sendBody(""direct:start"", matchingBody);
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", notMatchingBody);
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                Namespaces ns = new Namespaces(""foo"", ""urn:cheese"");
                from(""direct:start"").
                        unmarshal().string().
                        setHeader(""foo"", ns.xpath(""/foo:person[@name='James']"")).
                        filter(ns.xpath(""/foo:person[@name='James']"")).
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.language.Bean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to inject a bean expression into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision: 640438 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""bean"")
public @interface Bean {
    String value();
}
"
org.apache.camel.language.BeanTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import javax.naming.Context;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Header;
import org.apache.camel.LanguageTestSupport;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision: 675468 $
 */
public class BeanTest extends LanguageTestSupport {
    public void testSimpleExpressions() throws Exception {
        assertExpression(""foo.cheese"", ""abc"");
    }
    public void testPredicates() throws Exception {
        assertPredicate(""foo.isFooHeaderAbc"");
    }
    protected String getLanguageName() {
        return ""bean"";
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""foo"", new MyBean());
        return context;
    }
    public static class MyBean {
        public Object cheese(Exchange exchange) {
            Message in = exchange.getIn();
            return in.getHeader(""foo"");
        }
        public boolean isFooHeaderAbc(@Header(name = ""foo"")String foo) {
            return ""abc"".equals(foo);
        }
    }
}
"
org.apache.camel.language.ExpressionEvaluationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if evaluation of the expression failed.
 *
 * @version $Revision: 659760 $
 */
public class ExpressionEvaluationException extends RuntimeCamelException {
    private final Expression<Exchange> expression;
    private final Exchange exchange;
    public ExpressionEvaluationException(Expression<Exchange> expression, Exchange exchange, Throwable cause) {
        super(cause);
        this.expression = expression;
        this.exchange = exchange;
    }
    public Expression<Exchange> getExpression() {
        return expression;
    }
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.language.IllegalSyntaxException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Language;
/**
 * An exception thrown if some illegal syntax is rejected by a specific language
 *
 * @version $Revision: 630568 $
 */
public class IllegalSyntaxException extends RuntimeCamelException {
    private final Language language;
    private final String expression;
    public IllegalSyntaxException(Language language, String expression) {
        super(""Illegal syntax for language: "" + language + "". Expression: "" + expression);
        this.language = language;
        this.expression = expression;
    }
    public String getExpression() {
        return expression;
    }
    public Language getLanguage() {
        return language;
    }
}
"
org.apache.camel.language.LanguageAnnotation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.component.bean.DefaultAnnotationExpressionFactory;
/**
 * Base annotation for languages.
 *
 * @version $Revision: 659760 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE })
public @interface LanguageAnnotation {
    String language();
    Class<?> factory() default DefaultAnnotationExpressionFactory.class;
}
"
org.apache.camel.language.LanguageExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Base annotation for language expressions.
 *
 * @version $Revision: 659760 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface LanguageExpression {
    String language();
    String expression();
}
"
org.apache.camel.language.NamespacePrefix,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Creates a namespace prefix for an XPath
 *
 * @version $Revision: 640438 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE })
public @interface NamespacePrefix {
    String prefix();
    String uri();
}
"
org.apache.camel.language.Simple,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to inject a simple expression into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision: 640438 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""simple"")
public @interface Simple {
    String value();
}
"
org.apache.camel.language.SimpleTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.LanguageTestSupport;
/**
 * @version $Revision: 640438 $
 */
public class SimpleTest extends LanguageTestSupport {
    public void testSimpleExpressions() throws Exception {
        assertExpression(""body"", ""<hello id='m123'>world!</hello>"");
        assertExpression(""in.body"", ""<hello id='m123'>world!</hello>"");
        assertExpression(""in.header.foo"", ""abc"");
        assertExpression(""header.foo"", ""abc"");
    }
    public void testComplexExpressions() throws Exception {
        assertExpression(""hey ${in.header.foo}"", ""hey abc"");
        assertExpression(""hey ${in.header.foo}!"", ""hey abc!"");
        assertExpression(""hey ${in.header.foo}-${in.header.foo}!"", ""hey abc-abc!"");
        assertExpression(""hey ${in.header.foo}${in.header.foo}"", ""hey abcabc"");
        assertExpression(""${in.header.foo}${in.header.foo}"", ""abcabc"");
        assertExpression(""${in.header.foo}"", ""abc"");
        assertExpression(""${in.header.foo}!"", ""abc!"");
    }
    public void testInvalidComplexExpression() throws Exception {
        try {
            assertExpression(""hey ${foo"", ""bad expression!"");
            fail(""Should have thrown an exception!"");
        } catch (IllegalArgumentException e) {
            log.debug(""Caught expected exception: "" + e, e);
        }
    }
    public void testPredicates() throws Exception {
        assertPredicate(""body"");
        assertPredicate(""header.foo"");
        assertPredicate(""header.madeUpHeader"", false);
    }
    protected String getLanguageName() {
        return ""simple"";
    }
}
"
org.apache.camel.language.XPath,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.component.bean.XPathAnnotationExpressionFactory;
/**
 * Used to inject an XPath expression into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision: 640438 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""xpath"", factory = XPathAnnotationExpressionFactory.class)
public @interface XPath {
    String value();
    NamespacePrefix[] namespaces() default {
    @NamespacePrefix(prefix = ""soap"", uri = ""http://www.w3.org/2003/05/soap-envelope""),
    @NamespacePrefix(prefix = ""xsd"", uri = ""http://www.w3.org/2001/XMLSchema"")};
}
"
org.apache.camel.language.XPathTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import javax.xml.xpath.XPathConstants;
import org.apache.camel.LanguageTestSupport;
import org.apache.camel.builder.xml.XPathLanguage;
import org.apache.camel.spi.Language;
/**
 * @version $Revision: 640438 $
 */
public class XPathTest extends LanguageTestSupport {
    public void testExpressions() throws Exception {
        assertExpression(""in:body()"", ""<hello id='m123'>world!</hello>"");
        assertExpression(""in:header('foo')"", ""abc"");
        assertExpression(""$foo"", ""abc"");
    }
    public void testPredicates() throws Exception {
        assertPredicate(""in:header('foo') = 'abc'"");
        assertPredicate(""$foo = 'abc'"");
        assertPredicate(""$foo = 'bar'"", false);
    }
    protected String getLanguageName() {
        return ""xpath"";
    }
    @Override
    protected Language assertResolveLanguage(String languageName) {
        XPathLanguage answer = new XPathLanguage();
        answer.setResultType(XPathConstants.STRING);
        return answer;
    }
}
"
org.apache.camel.language.bean.BeanExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.bean;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.bean.RegistryBean;
import org.apache.camel.impl.ExpressionSupport;
/**
 * Evaluates an expression using a bean method invocation
 *
 * @version $Revision: 675833 $
 */
public class BeanExpression<E extends Exchange> extends ExpressionSupport<E> {
    private String beanName;
    private String method;
    public BeanExpression(String beanName, String method) {
        this.beanName = beanName;
        this.method = method;
    }
    @Override
    public String toString() {
        return ""BeanExpression[bean: "" + beanName + "" method: "" + method + ""]"";
    }
    protected String assertionFailureMessage(E exchange) {
        return ""bean: "" + beanName + "" method: "" + method;
    }
    public Object evaluate(E exchange) {
        BeanProcessor processor = new BeanProcessor(new RegistryBean(exchange.getContext(), beanName));
        if (method != null) {
            processor.setMethod(method);
        }
        try {
            Exchange newExchange = exchange.copy();
            // The BeanExperession always has a result regardless of the ExchangePattern,
            // so I add a checker here to make sure we can get the result.
            if (!newExchange.getPattern().isOutCapable()) {
                newExchange.setPattern(ExchangePattern.InOut);
            }
            processor.process(newExchange);
            return newExchange.getOut(true).getBody();
        } catch (Exception e) {
            throw new RuntimeBeanExpressionException(exchange, beanName, method, e);
        }
    }
}
"
org.apache.camel.language.bean.BeanLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.bean;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/bean-language.html>bean language</a>
 * which uses a simple text notation to invoke methods on beans to evaluate predicates or expressions<p/>
 * <p/>
 * The notation is essentially <code>beanName.methodName</code> which is then invoked using the
 * beanName to lookup in the <a href=""http://activemq.apache.org/camel/registry.html>registry</a>
 * then the method is invoked to evaluate the expression using the
 * <a href=""http://activemq.apache.org/camel/bean-integration.html>bean integration</a> to bind the
 * {@link Exchange} to the method arguments.
 *
 * @version $Revision: 630591 $
 */
public class BeanLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return PredicateBuilder.toPredicate(createExpression(expression));
    }
    public Expression<Exchange> createExpression(String expression) {
        ObjectHelper.notNull(expression, ""expression"");
        int idx = expression.lastIndexOf('.');
        String beanName = expression;
        String method = null;
        if (idx > 0) {
            beanName = expression.substring(0, idx);
            method = expression.substring(idx + 1);
        }
        return new BeanExpression(beanName, method);
    }
}
"
org.apache.camel.language.bean.RuntimeBeanExpressionException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.bean;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeExpressionException;
/**
 * Exception thrown if invocation of bean failed.
 *
 * @version $Revision: 659760 $
 */
public class RuntimeBeanExpressionException extends RuntimeExpressionException {
    private final Exchange exchange;
    private final String bean;
    private final String method;
    public RuntimeBeanExpressionException(Exchange exchange, String bean, String method, Throwable e) {
        super(""Failed to invoke method: "" + method + "" on "" + bean + "" due to: "" + e, e);
        this.exchange = exchange;
        this.bean = bean;
        this.method = method;
    }
    public String getBean() {
        return bean;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public String getMethod() {
        return method;
    }
}
"
org.apache.camel.language.simple.SimpleLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.simple;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.language.IllegalSyntaxException;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/simple.html"">simple language</a>
 * which maps simple property style notations to access headers and bodies.
 * Examples of supported expressions are <p/>
 * <ul>
 * <li>in.header.foo or header.foo to access an inbound header called 'foo'</li>
 * <li>in.body or body to access the inbound body</li>
 * <li>out.header.foo to access an outbound header called 'foo'</li>
 * <li>out.body to access the inbound body</li>
 * <li>property.foo to access the exchange property called 'foo'</li>
 * <li>sys.foo to access the system property called 'foo'</li>
 * </ul>
 *
 * @version $Revision: 659197 $
 */
public class SimpleLanguage implements Language {
    public static Expression simple(String expression) {
        SimpleLanguage language = new SimpleLanguage();
        return language.createExpression(expression);
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return PredicateBuilder.toPredicate(createExpression(expression));
    }
    public Expression<Exchange> createExpression(String expression) {
        if (expression.indexOf(""${"") >= 0) {
            return createComplexExpression(expression);
        }
        return createSimpleExpression(expression);
    }
    protected Expression<Exchange> createComplexExpression(String expression) {
        List<Expression> results = new ArrayList<Expression>();
        int pivot = 0;
        int size = expression.length();
        while (pivot < size) {
            int idx = expression.indexOf(""${"", pivot);
            if (idx < 0) {
                results.add(createConstantExpression(expression, pivot, size));
                break;
            } else {
                if (pivot < idx) {
                    results.add(createConstantExpression(expression, pivot, idx));
                }
                pivot = idx + 2;
                int endIdx = expression.indexOf(""}"", pivot);
                if (endIdx < 0) {
                    throw new IllegalArgumentException(""Expecting } but found end of string for simple expression: "" + expression);
                }
                String simpleText = expression.substring(pivot, endIdx);
                Expression simpleExpression = createSimpleExpression(simpleText);
                results.add(simpleExpression);
                pivot = endIdx + 1;
            }
        }
        return ExpressionBuilder.concatExpression(results, expression);
    }
    protected Expression createConstantExpression(String expression, int start, int end) {
        return ExpressionBuilder.constantExpression(expression.substring(start, end));
    }
    protected Expression<Exchange> createSimpleExpression(String expression) {
        if (ObjectHelper.isEqualToAny(expression, ""body"", ""in.body"")) {
            return ExpressionBuilder.bodyExpression();
        } else if (ObjectHelper.equal(expression, ""out.body"")) {
            return ExpressionBuilder.outBodyExpression();
        }
        // in header expression
        String remainder = ifStartsWithReturnRemainder(""in.header."", expression);
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""header."", expression);
        }
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""headers."", expression);
        }
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""in.headers."", expression);
        }
        if (remainder != null) {
            return ExpressionBuilder.headerExpression(remainder);
        }
        // out header expression
        remainder = ifStartsWithReturnRemainder(""out.header."", expression);
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""out.headers."", expression);
        }
        if (remainder != null) {
            return ExpressionBuilder.outHeaderExpression(remainder);
        }
        // property
        remainder = ifStartsWithReturnRemainder(""property."", expression);
        if (remainder != null) {
            return ExpressionBuilder.propertyExpression(remainder);
        }
        // system property
        remainder = ifStartsWithReturnRemainder(""sys."", expression);
        if (remainder != null) {
            return ExpressionBuilder.propertyExpression(remainder);
        }
        throw new IllegalSyntaxException(this, expression);
    }
    protected String ifStartsWithReturnRemainder(String prefix, String text) {
        if (text.startsWith(prefix)) {
            String remainder = text.substring(prefix.length());
            if (remainder.length() > 0) {
                return remainder;
            }
        }
        return null;
    }
}
"
org.apache.camel.management.CamelChoiceWithManagementTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
/**
 * @version $Revision: 670436 $
 */
public class CamelChoiceWithManagementTest extends ContextTestSupport {
    private MockEndpoint a;
    private MockEndpoint b;
    private MockEndpoint c;
    private MockEndpoint d;
    private MockEndpoint e;
    protected void setUp() throws Exception {
        context = createCamelContext();
        assertValidContext(context);
        template = context.createProducerTemplate();
        RouteBuilder[] builders = createRouteBuilders();
        for (RouteBuilder builder : builders) {
            context.addRoutes(builder);
        }
        startCamelContext();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
        c = getMockEndpoint(""mock:c"");
        d = getMockEndpoint(""mock:d"");
        e = getMockEndpoint(""mock:e"");
    }
    protected void tearDown() throws Exception {
        super.tearDown();
    }
    public void testFirstChoiceRoute() throws Exception {
        final String body = ""<one/>"";
        a.expectedBodiesReceived(body);
        a.expectedHeaderReceived(""CBR1"", ""Yes"");
        c.expectedBodiesReceived(body);
        c.expectedHeaderReceived(""CBR1"", ""Yes"");
        c.expectedHeaderReceived(""Validation"", ""Yes"");
        expectsMessageCount(0, b, d, e);
        template.send(""direct:start"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(body);
                exchange.getIn().setHeader(""CBR1"", ""Yes"");
            }
        });
        assertMockEndpointsSatisifed();
    }
    public void testOtherwise() throws Exception {
        final String body = ""<None/>"";
        e.expectedBodiesReceived(body);
        expectsMessageCount(0, a, b, c, d);
        template.send(""direct:start"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(body);
            }
        });
        assertMockEndpointsSatisifed();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .choice()
                        .when(header(""CBR1"").isEqualTo(""Yes"")).to(""mock:a"").setHeader(""Validation"", ""Yes"")
                        .when(header(""CBR1"").isEqualTo(""No"")).to(""mock:b"").end()
                    .choice().when(header(""Validation"").isEqualTo(""Yes"")).to(""mock:c"")
                        .when(header(""Validation"").isEqualTo(""No"")).to(""mock:d"").otherwise().to(""mock:e"").end();
            }
        };
    }
}
"
org.apache.camel.management.CamelNamingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.net.InetAddress;
import java.net.UnknownHostException;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.RouteContext;
/**
 * Naming strategy used when registering MBeans.
 */
public class CamelNamingStrategy {
    public static final String VALUE_UNKNOWN = ""unknown"";
    public static final String KEY_NAME = ""name"";
    public static final String KEY_TYPE = ""type"";
    public static final String KEY_CONTEXT = ""context"";
    public static final String KEY_GROUP = ""group"";
    public static final String KEY_COMPONENT = ""component"";
    public static final String KEY_ROUTE = ""route"";
    public static final String TYPE_CONTEXT = ""context"";
    public static final String TYPE_ENDPOINT = ""endpoint"";
    public static final String TYPE_PROCESSOR = ""processor"";
    public static final String TYPE_ROUTE = ""route"";
    public static final String TYPE_SERVICE = ""service"";
    public static final String KEY_NODE_ID = ""nodeid"";
    protected String domainName;
    protected String hostName = ""locahost"";
    public CamelNamingStrategy() {
        this(""org.apache.camel"");
    }
    public CamelNamingStrategy(String domainName) {
        if (domainName != null) {
            this.domainName = domainName;
        }
        try {
            hostName = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException ex) {
            // ignore, use the default ""locahost""
        }
    }
    /**
     * Implements the naming strategy for a {@link CamelContext}.
     * The convention used for a {@link CamelContext} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,type=context,name=&lt;context-name&gt;</tt>
     *
     * @param context the camel context
     * @return generated ObjectName
     * @throws MalformedObjectNameException
     */
    public ObjectName getObjectName(CamelContext context) throws MalformedObjectNameException {
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(context)).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_CONTEXT + "","");
        buffer.append(KEY_NAME + ""="").append(getContextId(context));
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link ManagedEndpoint}.
     * The convention used for a {@link ManagedEndpoint} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,type=endpoint,component=&lt;component-name&gt;name=&lt;endpoint-name&gt;</tt>
     */
    public ObjectName getObjectName(ManagedEndpoint mbean) throws MalformedObjectNameException {
        Endpoint<? extends Exchange> ep = mbean.getEndpoint();
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(ep.getCamelContext())).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_ENDPOINT + "","");
        buffer.append(KEY_COMPONENT + ""="").append(getComponentId(ep)).append("","");
        buffer.append(KEY_NAME + ""="").append(getEndpointId(ep));
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link org.apache.camel.impl.ServiceSupport Service}.
     * The convention used for a {@link org.apache.camel.Service Service} ObjectName is
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,type=service,name=&lt;service-name&gt;</tt>
     */
    public ObjectName getObjectName(CamelContext context, ManagedService mbean) throws MalformedObjectNameException {
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(context)).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_SERVICE + "","");
        buffer.append(KEY_NAME + ""="").append(Integer.toHexString(mbean.getService().hashCode()));
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link ManagedRoute}.
     * The convention used for a {@link ManagedRoute} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,route=&lt;route-name&gt;,type=route,name=&lt;route-name&gt;</tt>
     */
    public ObjectName getObjectName(ManagedRoute mbean) throws MalformedObjectNameException {
        Route<? extends Exchange> route = mbean.getRoute();
        Endpoint<? extends Exchange> ep = route.getEndpoint();
        String ctxid = ep != null ? getContextId(ep.getCamelContext()) : VALUE_UNKNOWN;
        String cid = getComponentId(ep);
        String id = VALUE_UNKNOWN.equals(cid) ? getEndpointId(ep)
            : ""["" + cid + ""]"" + getEndpointId(ep);
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(ctxid).append("","");
        buffer.append(KEY_ROUTE + ""="").append(id).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_ROUTE + "","");
        buffer.append(KEY_NAME + ""="").append(id);
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@link ProcessorType}.
     * The convention used for a {@link ProcessorType} ObjectName is:
     * <tt>&lt;domain&gt;:context=&lt;context-name&gt;,route=&lt;route-name&gt;,type=processor,name=&lt;processor-name&gt;,nodeid=&lt;node-id&gt;</tt>
     */
    public ObjectName getObjectName(RouteContext routeContext, ProcessorType processor)
        throws MalformedObjectNameException {
        Endpoint<? extends Exchange> ep = routeContext.getEndpoint();
        String ctxid = ep != null ? getContextId(ep.getCamelContext()) : VALUE_UNKNOWN;
        String cid = getComponentId(ep);
        String id = VALUE_UNKNOWN.equals(cid) ? getEndpointId(ep) : ""["" + cid + ""]"" + getEndpointId(ep);
        String nodeId = processor.idOrCreate();
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(ctxid).append("","");
        buffer.append(KEY_ROUTE + ""="").append(id).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_PROCESSOR + "","");
        buffer.append(KEY_NODE_ID + ""="").append(nodeId).append("","");
        buffer.append(KEY_NAME + ""="").append(ObjectName.quote(processor.toString()));
        return createObjectName(buffer);
    }
    public String getDomainName() {
        return domainName;
    }
    public void setDomainName(String domainName) {
        this.domainName = domainName;
    }
    public String getHostName() {
        return hostName;
    }
    public void setHostName(String hostName) {
        this.hostName = hostName;
    }
    protected String getContextId(CamelContext context) {
        String id = context != null ? context.getName() : VALUE_UNKNOWN;
        return hostName + ""/"" + id;
    }
    protected String getComponentId(Endpoint<? extends Exchange> ep) {
        String uri = ep.getEndpointUri();
        int pos = uri.indexOf(':');
        return (pos == -1) ? VALUE_UNKNOWN : uri.substring(0, pos);
    }
    protected String getEndpointId(Endpoint<? extends Exchange> ep) {
        String uri = ep.getEndpointUri();
        int pos = uri.indexOf(':');
        String id = (pos == -1) ? uri : uri.substring(pos + 1);
        if (!ep.isSingleton()) {
            id += ""@"" + Integer.toString(ep.hashCode());
        }
        return ObjectNameEncoder.encode(id);
    }
    /**
     * Factory method to create an ObjectName escaping any required characters
     */
    protected ObjectName createObjectName(StringBuffer buffer) throws MalformedObjectNameException {
        String text = buffer.toString();
        try {
            return new ObjectName(text);
        } catch (MalformedObjectNameException e) {
            throw new MalformedObjectNameException(""Could not create ObjectName from: "" + text + "". Reason: "" + e);
        }
    }
}
"
org.apache.camel.management.Counter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.concurrent.atomic.AtomicLong;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Counter"", currencyTimeLimit = 15)
public class Counter {
    protected AtomicLong numExchanges = new AtomicLong(0L);
    @ManagedOperation(description = ""Reset counters"")
    public void reset() {
        numExchanges.set(0L);
    }
    @ManagedAttribute(description = ""Total number of exchanges"")
    public long getNumExchanges() throws Exception {
        return numExchanges.get();
    }
    public long increment() {
        return numExchanges.incrementAndGet();
    }
}
"
org.apache.camel.management.DefaultInstrumentationAgent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.management.InstanceAlreadyExistsException;
import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectInstance;
import javax.management.ObjectName;
import javax.management.modelmbean.InvalidTargetObjectTypeException;
import javax.management.modelmbean.ModelMBeanInfo;
import javax.management.modelmbean.RequiredModelMBean;
import javax.management.remote.JMXConnectorServer;
import javax.management.remote.JMXConnectorServerFactory;
import javax.management.remote.JMXServiceURL;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.InstrumentationAgent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource;
import org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler;
/**
 * Default implementation of the Camel JMX service agent
 */
public class DefaultInstrumentationAgent extends ServiceSupport implements InstrumentationAgent {
    public static final String DEFAULT_DOMAIN = ""org.apache.camel"";
    public static final String DEFAULT_HOST = ""localhost"";
    public static final int DEFAULT_REGISTRY_PORT = 1099;
    public static final int DEFAULT_CONNECTION_PORT = -1;
    public static final String DEFAULT_SERVICE_URL_PATH = ""/jmxrmi/camel"";
    private static final transient Log LOG = LogFactory.getLog(DefaultInstrumentationAgent.class);
    private MBeanServer server;
    private Set<ObjectName> mbeans = new HashSet<ObjectName>();
    private MetadataMBeanInfoAssembler assembler;
    private JMXConnectorServer cs;
    private Integer registryPort;
    private Integer connectorPort;
    private String mBeanServerDefaultDomain;
    private String mBeanObjectDomainName;
    private String serviceUrlPath;
    private Boolean usePlatformMBeanServer;
    private Boolean createConnector;
    protected void finalizeSettings() {
        if (registryPort == null) {
            registryPort = Integer.getInteger(JmxSystemPropertyKeys.REGISTRY_PORT,
                    DEFAULT_REGISTRY_PORT);
        }
        if (connectorPort == null) {
            connectorPort = Integer.getInteger(JmxSystemPropertyKeys.CONNECTOR_PORT,
                    DEFAULT_CONNECTION_PORT);
        }
        if (mBeanServerDefaultDomain == null) {
            mBeanServerDefaultDomain =
                System.getProperty(JmxSystemPropertyKeys.DOMAIN, DEFAULT_DOMAIN);
        }
        if (mBeanObjectDomainName == null) {
            mBeanObjectDomainName =
                System.getProperty(JmxSystemPropertyKeys.MBEAN_DOMAIN, DEFAULT_DOMAIN);
        }
        if (serviceUrlPath == null) {
            serviceUrlPath =
                System.getProperty(JmxSystemPropertyKeys.SERVICE_URL_PATH,
                        DEFAULT_SERVICE_URL_PATH);
        }
        if (createConnector == null) {
            createConnector = Boolean.getBoolean(JmxSystemPropertyKeys.CREATE_CONNECTOR);
        }
        if (usePlatformMBeanServer == null) {
            usePlatformMBeanServer =
                Boolean.getBoolean(JmxSystemPropertyKeys.USE_PLATFORM_MBS);
        }
    }
    public void setRegistryPort(Integer value) {
        registryPort = value;
    }
    public void setConnectorPort(Integer value) {
        connectorPort = value;
    }
    public void setMBeanServerDefaultDomain(String value) {
        mBeanServerDefaultDomain = value;
    }
    public void setMBeanObjectDomainName(String value) {
        mBeanObjectDomainName = value;
    }
    public void setServiceUrlPath(String value) {
        serviceUrlPath = value;
    }
    public void setCreateConnector(Boolean flag) {
        createConnector = flag;
    }
    public void setUsePlatformMBeanServer(Boolean flag) {
        usePlatformMBeanServer = flag;
    }
    public MBeanServer getMBeanServer() {
        return server;
    }
    public void register(Object obj, ObjectName name) throws JMException {
        register(obj, name, false);
    }
    public void register(Object obj, ObjectName name, boolean forceRegistration) throws JMException {
        try {
            registerMBeanWithServer(obj, name, forceRegistration);
        } catch (NotCompliantMBeanException e) {
            // If this is not a ""normal"" MBean, then try to deploy it using JMX
            // annotations
            ModelMBeanInfo mbi = null;
            mbi = assembler.getMBeanInfo(obj, name.toString());
            RequiredModelMBean mbean = (RequiredModelMBean)server.instantiate(RequiredModelMBean.class
                .getName());
            mbean.setModelMBeanInfo(mbi);
            try {
                mbean.setManagedResource(obj, ""ObjectReference"");
            } catch (InvalidTargetObjectTypeException itotex) {
                throw new JMException(itotex.getMessage());
            }
            registerMBeanWithServer(mbean, name, forceRegistration);
        }
    }
    public void unregister(ObjectName name) throws JMException {
        server.unregisterMBean(name);
    }
    protected void doStart() throws Exception {
        assembler = new MetadataMBeanInfoAssembler();
        assembler.setAttributeSource(new AnnotationJmxAttributeSource());
        // create mbean server if is has not be injected.
        if (server == null) {
            finalizeSettings();
            createMBeanServer();
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Starting JMX agent on server: "" + getMBeanServer());
        }
    }
    protected void doStop() throws Exception {
        // close JMX Connector
        if (cs != null) {
            try {
                cs.stop();
            } catch (IOException e) {
                // ignore
            }
            cs = null;
        }
        // Using the array to hold the busMBeans to avoid the
        // CurrentModificationException
        Object[] mBeans = mbeans.toArray();
        int caught = 0;
        for (Object name : mBeans) {
            mbeans.remove((ObjectName)name);
            try {
                unregister((ObjectName)name);
            } catch (JMException jmex) {
                LOG.info(""Exception unregistering MBean"", jmex);
                caught++;
            }
        }
        if (caught > 0) {
            LOG.warn(""A number of "" + caught
                     + "" exceptions caught while unregistering MBeans during stop operation.""
                     + "" See INFO log for details."");
        }
    }
    private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration)
        throws JMException {
        // have we already registered the bean, there can be shared instances in the camel routes
        boolean exists = server.isRegistered(name);
        if (exists) {
            if (forceRegistration) {
                LOG.info(""ForceRegistration enabled, unregistering existing MBean"");
                server.unregisterMBean(name);
            } else {
                // okay ignore we do not want to force it and it could be a shared instance
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""MBean already registered with objectname: "" + name);
                }
            }
        }
        // register bean if by force or not exsists
        ObjectInstance instance = null;
        if (forceRegistration || !exists) {
            if (LOG.isTraceEnabled()) {
                LOG.trace(""Registering MBean with objectname: "" + name);
            }
            instance = server.registerMBean(obj, name);
        }
        if (instance != null) {
            ObjectName registeredName = instance.getObjectName();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Registered MBean with objectname: "" + registeredName);
            }
            mbeans.add(registeredName);
        }
    }
    protected void createMBeanServer() {
        String hostName = DEFAULT_HOST;
        boolean canAccessSystemProps = true;
        try {
            // we'll do it this way mostly to determine if we should lookup the
            // hostName
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPropertiesAccess();
            }
        } catch (SecurityException se) {
            canAccessSystemProps = false;
        }
        if (canAccessSystemProps) {
            try {
                hostName = InetAddress.getLocalHost().getHostName();
            } catch (UnknownHostException uhe) {
                LOG.info(""Cannot determine localhost name. Using default: ""
                         + DEFAULT_REGISTRY_PORT, uhe);
                hostName = DEFAULT_HOST;
            }
        } else {
            hostName = DEFAULT_HOST;
        }
        server = findOrCreateMBeanServer();
        try {
            // Create the connector if we need
            if (createConnector) {
                createJmxConnector(hostName);
            }
        } catch (IOException ioe) {
            LOG.warn(""Could not create and start JMX connector."", ioe);
        }
    }
    @SuppressWarnings(""unchecked"")
    protected MBeanServer findOrCreateMBeanServer() {
        // return platform mbean server if the option is specified.
        if (Boolean.getBoolean(JmxSystemPropertyKeys.USE_PLATFORM_MBS) || usePlatformMBeanServer) {
            return ManagementFactory.getPlatformMBeanServer();
        }
        // look for the first mbean server that has match default domain name
        List<MBeanServer> servers =
            (List<MBeanServer>)MBeanServerFactory.findMBeanServer(null);
        for (MBeanServer server : servers) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Found MBeanServer with default domain "" + server.getDefaultDomain());
            }
            if (mBeanServerDefaultDomain.equals(server.getDefaultDomain())) {
                return server;
            }
        }
        // create a mbean server with the given default domain name
        return MBeanServerFactory.createMBeanServer(mBeanServerDefaultDomain);
    }
    protected void createJmxConnector(String host) throws IOException {
        try {
            LocateRegistry.createRegistry(registryPort);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Created JMXConnector RMI regisry on port "" + registryPort);
            }
        } catch (RemoteException ex) {
            // The registry may had been created, we could get the registry instead
        }
        // Create an RMI connector and start it
        JMXServiceURL url;
        if (connectorPort > 0) {
            url = new JMXServiceURL(""service:jmx:rmi://"" + host + "":"" + connectorPort + ""/jndi/rmi://"" + host
                                    + "":"" + registryPort + serviceUrlPath);
        } else {
            url = new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://"" + host + "":"" + registryPort
                                    + serviceUrlPath);
        }
        cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);
        // Start the connector server asynchronously (in a separate thread).
        Thread connectorThread = new Thread() {
            public void run() {
                try {
                    cs.start();
                } catch (IOException ioe) {
                    LOG.warn(""Could not start JMXConnector thread."", ioe);
                }
            }
        };
        connectorThread.setName(""Camel JMX Connector Thread ["" + url + ""]"");
        connectorThread.start();
        LOG.info(""JMX Connector thread started and listening at: "" + url);
    }
    public String getMBeanObjectDomainName() {
        return mBeanObjectDomainName;
    }
    public void setServer(MBeanServer value) {
        server = value;
    }
}
"
org.apache.camel.management.InstrumentationErrorHandlerWrappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Map;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.ErrorHandlerWrappingStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * @version $Revision: 673837 $
 */
public class InstrumentationErrorHandlerWrappingStrategy implements
        ErrorHandlerWrappingStrategy {
    private Map<ProcessorType, PerformanceCounter> counterMap;
    public InstrumentationErrorHandlerWrappingStrategy(
            Map<ProcessorType, PerformanceCounter> counterMap) {
        this.counterMap = counterMap;
    }
    public Processor wrapProcessorInErrorHandler(RouteContext routeContext, ProcessorType processorType,
                                                 Processor target) throws Exception {
        // don't wrap our instrumentation interceptors
        if (counterMap.containsKey(processorType)) {
            return processorType.getErrorHandlerBuilder().createErrorHandler(routeContext, target);
        }
        return target;
    }
}
"
org.apache.camel.management.InstrumentationInterceptStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Map;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
/**
 * This strategy class wraps targeted processors with a
 * {@link InstrumentationProcessor}. Each InstrumentationProcessor has an
 * embedded {@link PerformanceCounter} for monitoring performance metrics.
 * <p/>
 * This class looks up a map to determine which PerformanceCounter should go into the
 * InstrumentationProcessor for any particular target processor.
 *
 * @version $Revision: 671035 $
 */
public class InstrumentationInterceptStrategy implements InterceptStrategy {
    private Map<ProcessorType, PerformanceCounter> counterMap;
    public InstrumentationInterceptStrategy(Map<ProcessorType, PerformanceCounter> counterMap) {
        this.counterMap = counterMap;
    }
    public Processor wrapProcessorInInterceptors(ProcessorType processorType,
            Processor target) throws Exception {
        Processor retval = target;
        PerformanceCounter counter = counterMap.get(processorType);
        if (counter != null) {
            InstrumentationProcessor wrapper = new InstrumentationProcessor(counter);
            wrapper.setProcessor(target);
            retval = wrapper;
        }
        return retval;
    }
}
"
org.apache.camel.management.InstrumentationLifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.management.JMException;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.InstrumentationAgent;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * JMX agent that registeres Camel lifecycle events in JMX.
 *
 * @version $Revision: 676133 $
 *
 */
public class InstrumentationLifecycleStrategy implements LifecycleStrategy {
    private static final transient Log LOG = LogFactory.getLog(InstrumentationProcessor.class);
    private InstrumentationAgent agent;
    private CamelNamingStrategy namingStrategy;
    private boolean initialized;
    // A map (Endpoint -> InstrumentationProcessor) to facilitate
    // adding per-route interceptor and registering ManagedRoute MBean
    private Map<Endpoint, InstrumentationProcessor> interceptorMap =
        new HashMap<Endpoint, InstrumentationProcessor>();
    public InstrumentationLifecycleStrategy() {
        this(new DefaultInstrumentationAgent());
    }
    public InstrumentationLifecycleStrategy(InstrumentationAgent agent) {
        this.agent = agent;
    }
    /**
     * Constructor for camel context that has been started.
     *
     * @param agent
     * @param context
     */
    public InstrumentationLifecycleStrategy(InstrumentationAgent agent,
            CamelContext context) {
        this.agent = agent;
        onContextStart(context);
    }
    public void onContextStart(CamelContext context) {
        if (context instanceof DefaultCamelContext) {
            try {
                initialized = true;
                DefaultCamelContext dc = (DefaultCamelContext)context;
                // call addService so that context will start and stop the agent
                dc.addService(agent);
                namingStrategy = new CamelNamingStrategy(agent.getMBeanObjectDomainName());
                ManagedService ms = new ManagedService(dc);
                agent.register(ms, getNamingStrategy().getObjectName(dc));
            } catch (Exception e) {
                LOG.warn(""Could not register CamelContext MBean"", e);
            }
        }
    }
    public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        try {
            ManagedEndpoint me = new ManagedEndpoint(endpoint);
            agent.register(me, getNamingStrategy().getObjectName(me));
        } catch (JMException e) {
            LOG.warn(""Could not register Endpoint MBean"", e);
        }
    }
    public void onRoutesAdd(Collection<Route> routes) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        for (Route route : routes) {
            try {
                ManagedRoute mr = new ManagedRoute(route);
                // retrieve the per-route intercept for this route
                InstrumentationProcessor interceptor = interceptorMap.get(route.getEndpoint());
                if (interceptor == null) {
                    LOG.warn(""Instrumentation processor not found for route endpoint ""
                             + route.getEndpoint());
                } else {
                    interceptor.setCounter(mr);
                }
                agent.register(mr, getNamingStrategy().getObjectName(mr));
            } catch (JMException e) {
                LOG.warn(""Could not register Route MBean"", e);
            }
        }
    }
    public void onServiceAdd(CamelContext context, Service service) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        if (service instanceof ServiceSupport) {
            try {
                ManagedService ms = new ManagedService((ServiceSupport)service);
                agent.register(ms, getNamingStrategy().getObjectName(context, ms));
            } catch (JMException e) {
                LOG.warn(""Could not register Service MBean"", e);
            }
        }
    }
    public void onRouteContextCreate(RouteContext routeContext) {
        // the agent hasn't been started
        if (!initialized) {
            return;
        }
        // Create a map (ProcessorType -> PerformanceCounter)
        // to be passed to InstrumentationInterceptStrategy.
        Map<ProcessorType, PerformanceCounter> counterMap =
            new HashMap<ProcessorType, PerformanceCounter>();
        // Each processor in a route will have its own performance counter
        // The performance counter are MBeans that we register with MBeanServer.
        // These performance counter will be embedded
        // to InstrumentationProcessor and wrap the appropriate processor
        // by InstrumentationInterceptStrategy.
        RouteType route = routeContext.getRoute();
        for (ProcessorType processor : route.getOutputs()) {
            ObjectName name = null;
            try {
                // get the mbean name
                name = getNamingStrategy().getObjectName(routeContext, processor);
                // register mbean wrapped in the performance counter mbean
                PerformanceCounter pc = new PerformanceCounter();
                agent.register(pc, name);
                // add to map now that it has ben registered
                counterMap.put(processor, pc);
            } catch (MalformedObjectNameException e) {
                LOG.warn(""Could not create MBean name: "" + name, e);
            } catch (JMException e) {
                LOG.warn(""Could not register PerformanceCounter MBean: "" + name, e);
            }
        }
        routeContext.addInterceptStrategy(new InstrumentationInterceptStrategy(counterMap));
        routeContext.setErrorHandlerWrappingStrategy(
                new InstrumentationErrorHandlerWrappingStrategy(counterMap));
        // Add an InstrumentationProcessor at the beginning of each route and
        // set up the interceptorMap for onRoutesAdd() method to register the
        // ManagedRoute MBeans.
        RouteType routeType = routeContext.getRoute();
        if (routeType.getInputs() != null && !routeType.getInputs().isEmpty()) {
            if (routeType.getInputs().size() > 1) {
                LOG.warn(""Add InstrumentationProcessor to first input only."");
            }
            Endpoint endpoint  = routeType.getInputs().get(0).getEndpoint();
            List<ProcessorType<?>> exceptionHandlers = new ArrayList<ProcessorType<?>>();
            List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
            // separate out the exception handers in the outputs
            for (ProcessorType output : routeType.getOutputs()) {
                if (output instanceof ExceptionType) {
                    exceptionHandlers.add(output);
                } else {
                    outputs.add(output);
                }
            }
            // clearing the outputs
            routeType.clearOutput();
            // add exception handlers as top children
            routeType.getOutputs().addAll(exceptionHandlers);
            // add an interceptor
            InstrumentationProcessor processor = new InstrumentationProcessor();
            routeType.intercept(processor);
            // add the output
            for (ProcessorType<?> processorType : outputs) {
                routeType.addOutput(processorType);
            }
            interceptorMap.put(endpoint, processor);
        }
    }
    public CamelNamingStrategy getNamingStrategy() {
        return namingStrategy;
    }
    public void setNamingStrategy(CamelNamingStrategy strategy) {
        this.namingStrategy = strategy;
    }
    public void setAgent(InstrumentationAgent agent) {
        this.agent = agent;
    }
}
"
org.apache.camel.management.InstrumentationProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * JMX enabled processor that uses the {@link Counter} for instrumenting
 * processing of exchanges.
 *
 * @version $Revision: 671751 $
 */
public class InstrumentationProcessor extends DelegateProcessor implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(InstrumentationProcessor.class);
    private PerformanceCounter counter;
    public InstrumentationProcessor(PerformanceCounter counter) {
        this.counter = counter;
    }
    public InstrumentationProcessor() {
    }
    public void setCounter(PerformanceCounter counter) {
        this.counter = counter;
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        final long startTime = System.nanoTime();
        if (processor instanceof AsyncProcessor) {
            return ((AsyncProcessor)processor).process(exchange, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    if (counter != null) {
                        // convert nanoseconds to milliseconds
                        recordTime(exchange, (System.nanoTime() - startTime) / 1000000.0);
                    }
                    callback.done(doneSynchronously);
                }
            });
        }
        try {
            processor.process(exchange);
        } catch (Exception e) {
            exchange.setException(e);
        }
        if (counter != null) {
            // convert nanoseconds to milliseconds
            recordTime(exchange, (System.nanoTime() - startTime) / 1000000.0);
        }
        callback.done(true);
        return true;
    }
    protected void recordTime(Exchange exchange, double duration) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Recording duration: "" + duration + "" millis for exchange: "" + exchange);
        }
        if (!exchange.isFailed() && exchange.getException() == null) {
            counter.completedExchange(duration);
        } else {
            counter.failedExchange();
        }
    }
}
"
org.apache.camel.management.JmxInstrumentationDisableTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
/**
 * A unit test which verifies disabling of JMX instrumentation.
 *
 * @version $Revision: 669756 $
 */
public class JmxInstrumentationDisableTest extends JmxInstrumentationUsingPropertiesTest {
    @Override
    protected void setUp() throws Exception {
        System.setProperty(JmxSystemPropertyKeys.DISABLED, ""True"");
        super.setUp();
    }
    @Override
    protected void tearDown() throws Exception {
        System.clearProperty(JmxSystemPropertyKeys.DISABLED);
        super.tearDown();
    }
    @Override
    public void testMBeansRegistered() throws Exception {
        assertNull(mbsc);
    }
    @Override
    public void testCounters() throws Exception {
        assertNull(mbsc);
    }
    @Override
    public void testMBeanServerType() throws Exception {
        assertNull(mbsc);
    }
}
"
org.apache.camel.management.JmxInstrumentationUsingDefaultsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.management.MBeanServer;
import javax.management.MBeanServerConnection;
import javax.management.MBeanServerFactory;
import javax.management.ObjectName;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * This test verifies JMX is enabled by default and it uses local mbean
 * server to conduct the test as connector server is not enabled by default.
 *
 * @version $Revision: 674800 $
 *
 */
public class JmxInstrumentationUsingDefaultsTest extends ContextTestSupport {
    protected String domainName = DefaultInstrumentationAgent.DEFAULT_DOMAIN;
    protected MBeanServerConnection mbsc;
    protected long sleepForConnection;
    public void testMBeansRegistered() throws Exception {
        if (!Boolean.getBoolean(JmxSystemPropertyKeys.USE_PLATFORM_MBS)) {
            assertEquals(domainName, mbsc.getDefaultDomain());
        }
        resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        Set s = mbsc.queryNames(
                new ObjectName(domainName + "":type=endpoint,*""), null);
        assertEquals(""Could not find 2 endpoints: "" + s, 2, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=context,*""), null);
        assertEquals(""Could not find 1 context: "" + s, 1, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=processor,*""), null);
        assertEquals(""Could not find 1 processor: "" + s, 1, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=route,*""), null);
        assertEquals(""Could not find 1 route: "" + s, 1, s.size());
    }
    public void testCounters() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(""<hello>world!</hello>"");
        sendBody(""direct:start"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
        verifyCounter(mbsc, new ObjectName(domainName + "":type=route,*""));
        verifyCounter(mbsc, new ObjectName(domainName + "":type=processor,*""));
    }
    protected void verifyCounter(MBeanServerConnection beanServer, ObjectName name) throws Exception {
        Set s = beanServer.queryNames(name, null);
        assertEquals(""Found mbeans: "" + s, 1, s.size());
        Iterator iter = s.iterator();
        ObjectName pcob = (ObjectName)iter.next();
        Long valueofNumExchanges = (Long)beanServer.getAttribute(pcob, ""NumExchanges"");
        assertNotNull(""Expected attribute found. MBean registered under a ""
                      + ""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"",
                      valueofNumExchanges);
        assertTrue(valueofNumExchanges == 1);
        Long valueofNumCompleted = (Long)beanServer.getAttribute(pcob, ""NumCompleted"");
        assertNotNull(""Expected attribute found. MBean registered under a ""
                      + ""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"",
                      valueofNumCompleted);
        assertTrue(valueofNumCompleted == 1);
        Long valueofNumFailed = (Long)beanServer.getAttribute(pcob, ""NumFailed"");
        assertNotNull(""Expected attribute found. MBean registered under a ""
                      + ""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"",
                      valueofNumFailed);
        assertTrue(valueofNumFailed == 0);
        Double valueofMinProcessingTime = (Double)beanServer.getAttribute(pcob, ""MinProcessingTimeMillis"");
        assertNotNull(""Expected attribute found. MBean registered under a ""
                      + ""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"",
                      valueofMinProcessingTime);
        assertTrue(valueofMinProcessingTime > 0);
        Double valueofMaxProcessingTime = (Double)beanServer.getAttribute(pcob, ""MaxProcessingTimeMillis"");
        assertNotNull(""Expected attribute found. MBean registered under a ""
                      + ""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"",
                      valueofMaxProcessingTime);
        assertTrue(valueofMaxProcessingTime > 0);
        Double valueofMeanProcessingTime = (Double)beanServer.getAttribute(pcob, ""MeanProcessingTimeMillis"");
        assertNotNull(""Expected attribute found. MBean registered under a ""
                      + ""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"",
                      valueofMeanProcessingTime);
        assertTrue(valueofMeanProcessingTime >= valueofMinProcessingTime
                   && valueofMeanProcessingTime <= valueofMaxProcessingTime);
        Double totalProcessingTime = (Double)beanServer.getAttribute(pcob, ""TotalProcessingTimeMillis"");
        assertNotNull(""Expected attribute found. MBean registered under a ""
                      + ""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"",
                      totalProcessingTime);
        assertTrue(totalProcessingTime > 0);
        assertNotNull(""Expected first completion time to be available"",
                beanServer.getAttribute(pcob, ""FirstExchangeCompletionTime""));
        assertNotNull(""Expected last completion time to be available"",
                beanServer.getAttribute(pcob, ""LastExchangeCompletionTime""));
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""mock:end"");
            }
        };
    }
    @Override
    protected void tearDown() throws Exception {
        releaseMBeanServers();
        mbsc = null;
        super.tearDown();
    }
    @SuppressWarnings(""unchecked"")
    protected void releaseMBeanServers() {
        List<MBeanServer> servers =
            (List<MBeanServer>)MBeanServerFactory.findMBeanServer(null);
        for (MBeanServer server : servers) {
            MBeanServerFactory.releaseMBeanServer(server);
        }
    }
    @Override
    protected void setUp() throws Exception {
        releaseMBeanServers();
        super.setUp();
        Thread.sleep(sleepForConnection);
        mbsc = getMBeanConnection();
    }
    @SuppressWarnings(""unchecked"")
    protected MBeanServerConnection getMBeanConnection() throws Exception {
        if (mbsc == null) {
            List<MBeanServer> servers =
                    (List<MBeanServer>)MBeanServerFactory.findMBeanServer(null);
            for (MBeanServer server : servers) {
                if (domainName.equals(server.getDefaultDomain())) {
                    mbsc = server;
                    break;
                }
            }
        }
        return mbsc;
    }
}
"
org.apache.camel.management.JmxInstrumentationUsingPlatformMBSTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.lang.management.ManagementFactory;
import javax.management.MBeanServerConnection;
import javax.management.ObjectName;
/**
 * This test verifies the system property to select platform mbean server.
 * 
 * @version $Revision: 669756 $
 */
public class JmxInstrumentationUsingPlatformMBSTest extends JmxInstrumentationUsingPropertiesTest {
    @Override
    protected void setUp() throws Exception {
        System.setProperty(JmxSystemPropertyKeys.USE_PLATFORM_MBS, ""True"");
        super.setUp();
    }
    @Override
    protected void tearDown() throws Exception {
        System.clearProperty(JmxSystemPropertyKeys.USE_PLATFORM_MBS);
        super.tearDown();
    }
    @Override
    public void testMBeanServerType() throws Exception {
        assertNotNull(mbsc.getMBeanInfo(
                new ObjectName(""java.lang:type=OperatingSystem"")));
    }
    @Override
    protected MBeanServerConnection getMBeanConnection() throws Exception {
        if (mbsc == null) {
            mbsc = ManagementFactory.getPlatformMBeanServer();
        }
        return mbsc;
    }
}
"
org.apache.camel.management.JmxInstrumentationUsingPropertiesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import javax.management.InstanceNotFoundException;
import javax.management.ObjectName;
/**
 * This module contains test cases that verifies jmx system property uses.
 *
 * @version $Revision: 669756 $
 */
public class JmxInstrumentationUsingPropertiesTest extends JmxInstrumentationUsingDefaultsTest {
    @Override
    protected void setUp() throws Exception {
        domainName = ""org.apache.camel-properties"";
        System.setProperty(JmxSystemPropertyKeys.DOMAIN, domainName);
        System.setProperty(JmxSystemPropertyKeys.MBEAN_DOMAIN, domainName);
        super.setUp();
    }
    @Override
    protected void tearDown() throws Exception {
        // restore environment to original state
        System.clearProperty(JmxSystemPropertyKeys.DOMAIN);
        System.clearProperty(JmxSystemPropertyKeys.MBEAN_DOMAIN);
        super.tearDown();
    }
    public void testMBeanServerType() throws Exception {
        try {
            mbsc.getMBeanInfo(new ObjectName(""java.lang:type=OperatingSystem""));
            assertTrue(false);  // should not get here
        } catch (InstanceNotFoundException e) {
            // expect exception since this is not a platform mbean server
        }
    }
}
"
org.apache.camel.management.JmxInstrumentationWithConnectorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import javax.management.MBeanServerConnection;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;
/**
 * Test that verifies JMX connector server can be connected by
 * a client.
 *
 * @version $Revision: 671113 $
 *
 */
public class JmxInstrumentationWithConnectorTest extends JmxInstrumentationUsingDefaultsTest {
    protected static final String JMXSERVICEURL =
        ""service:jmx:rmi:///jndi/rmi://localhost:2000/jmxrmi/camel"";
    protected JMXConnector clientConnector;
    @Override
    protected void setUp() throws Exception {
        sleepForConnection = 2000;
        System.setProperty(JmxSystemPropertyKeys.CREATE_CONNECTOR, ""True"");
        System.setProperty(JmxSystemPropertyKeys.REGISTRY_PORT, ""2000"");
        super.setUp();
    }
    @Override
    protected void tearDown() throws Exception {
        System.clearProperty(JmxSystemPropertyKeys.REGISTRY_PORT);
        System.clearProperty(JmxSystemPropertyKeys.CREATE_CONNECTOR);
        if (clientConnector != null) {
            try {
                clientConnector.close();
            } catch (Exception e) {
                // ignore
            }
            clientConnector = null;
        }
        super.tearDown();
    }
    @Override
    protected MBeanServerConnection getMBeanConnection() throws Exception {
        if (mbsc == null) {
            if (clientConnector == null) {
                clientConnector = JMXConnectorFactory.connect(
                        new JMXServiceURL(JMXSERVICEURL), null);
            }
            mbsc = clientConnector.getMBeanServerConnection();
        }
        return mbsc;
    }
}
"
org.apache.camel.management.JmxSystemPropertyKeys,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
/**
 * This module contains jmx related system property key constants.
 *
 * @version $Revision: 669756 $
 */
public final class JmxSystemPropertyKeys {
    // disable jmx
    public static final String DISABLED = ""org.apache.camel.jmx.disabled"";
    // jmx (rmi registry) port
    public static final String REGISTRY_PORT = ""org.apache.camel.jmx.rmiConnector.registryPort"";
    // jmx (rmi server connection) port
    public static final String CONNECTOR_PORT = ""org.apache.camel.jmx.rmiConnector.connectorPort"";
    // jmx domain name
    public static final String DOMAIN = ""org.apache.camel.jmx.mbeanServerDefaultDomain"";
    // the domain name for the camel mbeans
    public static final String MBEAN_DOMAIN = ""org.apache.camel.jmx.mbeanObjectDomainName"";
    // JMX service URL path 
    public static final String SERVICE_URL_PATH = ""org.apache.camel.jmx.serviceUrlPath"";
    // A flag that indicates whether the agent should be created
    public static final String CREATE_CONNECTOR = ""org.apache.camel.jmx.createRmiConnector"";
    // use jvm platform mbean server flag
    public static final String USE_PLATFORM_MBS = 
        ""org.apache.camel.jmx.usePlatformMBeanServer"";
    private JmxSystemPropertyKeys() {
        // not instantiated
    }
}
"
org.apache.camel.management.ManagedEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Managed Endpoint"", currencyTimeLimit = 15)
public class ManagedEndpoint {
    private Endpoint<? extends Exchange> endpoint;
    public ManagedEndpoint(Endpoint<? extends Exchange> endpoint) {
        this.endpoint = endpoint;
    }
    public Endpoint<? extends Exchange> getEndpoint() {
        return endpoint;
    }
    @ManagedAttribute(description = ""Endpoint Uri"")
    public String getUri() throws Exception {
        return endpoint.getEndpointUri();
    }
}
"
org.apache.camel.management.ManagedRoute,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Managed Route"", currencyTimeLimit = 15)
public class ManagedRoute extends PerformanceCounter {
    public static final String VALUE_UNKNOWN = ""Unknown"";
    private Route<? extends Exchange> route;
    private String description;
    ManagedRoute(Route<? extends Exchange> route) {
        this.route = route;
        this.description = route.toString();
    }
    public Route<? extends Exchange> getRoute() {
        return route;
    }
    @ManagedAttribute(description = ""Route Endpoint Uri"")
    public String getEndpointUri() {
        Endpoint<? extends Exchange> ep = route.getEndpoint();
        return ep != null ? ep.getEndpointUri() : VALUE_UNKNOWN;
    }
    @ManagedAttribute(description = ""Route description"")
    public String getDescription() {
        return description;
    }
    @ManagedOperation(description = ""Start Route"")
    public void start() throws IOException {
        throw new IOException(""Not supported"");
    }
    @ManagedOperation(description = ""Stop Route"")
    public void stop() throws IOException {
        throw new IOException(""Not supported"");
    }
}
"
org.apache.camel.management.ManagedService,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""Managed Service"", currencyTimeLimit = 15)
public class ManagedService {
    private ServiceSupport service;
    public ManagedService(ServiceSupport service) {
        this.service = service;
    }
    public Service getService() {
        return service;
    }
    @ManagedAttribute(description = ""Service running state"")
    public boolean isStarted() throws IOException {
        return service.isStarted();
    }
    @ManagedOperation(description = ""Start Service"")
    public void start() throws IOException {
        try {
            service.start();
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }
    @ManagedOperation(description = ""Stop Service"")
    public void stop() throws IOException {
        try {
            service.stop();
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }
}
"
org.apache.camel.management.MultiInstanceProcessorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Set;
import javax.management.ObjectName;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * A unit test to verify mbean registration of multi-instances of a processor 
 *
 * @version $Revision: 676133 $
 */
public class MultiInstanceProcessorTest extends JmxInstrumentationUsingDefaultsTest {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""mock:end"").to(""mock:end"");
            }
        };
    }
    /**
     * It retrieves a mbean for each ""to"" processor instance in the query "":type=processor""
     */
    @Override
    public void testMBeansRegistered() throws Exception {
        if (!Boolean.getBoolean(JmxSystemPropertyKeys.USE_PLATFORM_MBS)) {
            assertEquals(domainName, mbsc.getDefaultDomain());
        }
        resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        Set s = mbsc.queryNames(
                new ObjectName(domainName + "":type=endpoint,*""), null);
        assertEquals(""Could not find 2 endpoints: "" + s, 2, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=context,*""), null);
        assertEquals(""Could not find 1 context: "" + s, 1, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=processor,*""), null);
        assertEquals(""Could not find 2 processor: "" + s, 2, s.size());
        s = mbsc.queryNames(
                new ObjectName(domainName + "":type=route,*""), null);
        assertEquals(""Could not find 1 route: "" + s, 1, s.size());
    }
    @Override
    public void testCounters() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(
                new Object[] {""<hello>world!</hello>"", ""<hello>world!</hello>""});
        sendBody(""direct:start"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
        verifyCounter(mbsc, new ObjectName(domainName + "":type=route,*""));
        verifyCounter(mbsc, new ObjectName(domainName + "":type=processor,nodeid=to3,*""));
        verifyCounter(mbsc, new ObjectName(domainName + "":type=processor,nodeid=to4,*""));
    }
}
"
org.apache.camel.management.ObjectNameEncoder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
/**
 * Utility class providing RFC 1738 style encoding for ObjectName values.
 * (see section 2.2).
 *
 * Key Property Values in ObjectName(s) may not contain one of :"",=*?
 * (see jmx_1.2_spec, Chapter 6)
 *
 * @author hzbarcea
 *
 */
public final class ObjectNameEncoder {
    private ObjectNameEncoder() {
        // Complete (utility class should not have instances)
    }
    public static String encode(String on) {
        return encode(on, false);
    }
    public static String encode(String on, boolean ignoreWildcards) {
        on = on.replace(""%"", ""%25"");    // must be first
        on = on.replace("":"", ""%3a"");
        on = on.replace(""\"""", ""%22"");
        on = on.replace("","", ""%2c"");
        on = on.replace(""="", ""%3d"");
        if (!ignoreWildcards) {
            on = on.replace(""*"", ""%2a"");
            on = on.replace(""?"", ""%3f"");
        }
        return on;
    }
    public static String decode(String on) {
        on = on.replace(""%25"", ""%"");
        on = on.replace(""%3a"", "":"");
        on = on.replace(""%22"", ""\"""");
        on = on.replace(""%2c"", "","");
        on = on.replace(""%3d"", ""="");
        on = on.replace(""%2a"", ""*"");
        on = on.replace(""%3f"", ""?"");
        return on;
    }
}
"
org.apache.camel.management.ObjectNameEncoderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import javax.management.ObjectName;
import junit.framework.TestCase;
public class ObjectNameEncoderTest extends TestCase {
    private static final String BEFOR_ENCODING = ""test:test:hello*adsfad*"";
    private static final String AFTER_ENCODING_1 = ""test%3atest%3ahello%2aadsfad%2a"";
    private static final String AFTER_ENCODING_2 = ""test%3atest%3ahello*adsfad*"";
    public void testEncoding() {
        assertEquals(""Get the wrong endcoding result"", ObjectNameEncoder.encode(BEFOR_ENCODING), AFTER_ENCODING_1);
        assertEquals(""Get the wrong endcoding result with ignore Wildcards"", ObjectNameEncoder.encode(BEFOR_ENCODING, true), AFTER_ENCODING_2);
    }
    public void testDecoding() {
        assertEquals(""Get the wrong decoding result"", ObjectNameEncoder.decode(AFTER_ENCODING_1), BEFOR_ENCODING);
        assertEquals(""Get the wrong decoding result with ignore Wildcards"", ObjectNameEncoder.decode(AFTER_ENCODING_2), BEFOR_ENCODING);
    }
}
"
org.apache.camel.management.PerformanceCounter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Date;
import java.util.concurrent.atomic.AtomicLong;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(description = ""PerformanceCounter"", currencyTimeLimit = 15)
public class PerformanceCounter extends Counter {
    private AtomicLong numCompleted = new AtomicLong(0L);
    private double minProcessingTime = -1.0;
    private double maxProcessingTime;
    private double totalProcessingTime;
    private Date lastExchangeCompletionTime;
    private Date lastExchangeFailureTime;
    private Date firstExchangeCompletionTime;
    private Date firstExchangeFailureTime;
    @Override
    @ManagedOperation(description = ""Reset counters"")
    public synchronized void reset() {
        super.reset();
        numCompleted.set(0L);
        minProcessingTime = -1.0;
        maxProcessingTime = 0.0;
        totalProcessingTime = 0.0;
        lastExchangeCompletionTime = null;
        lastExchangeFailureTime = null;
        firstExchangeCompletionTime = null;
        firstExchangeFailureTime = null;
    }
    @ManagedAttribute(description = ""Number of successful exchanges"")
    public long getNumCompleted() throws Exception {
        return numCompleted.get();
    }
    @ManagedAttribute(description = ""Number of failed exchanges"")
    public long getNumFailed() throws Exception {
        return numExchanges.get() - numCompleted.get();
    }
    @ManagedAttribute(description = ""Min Processing Time [milliseconds]"")
    public synchronized double getMinProcessingTimeMillis() throws Exception {
        return minProcessingTime;
    }
    @ManagedAttribute(description = ""Mean Processing Time [milliseconds]"")
    public synchronized double getMeanProcessingTimeMillis() throws Exception {
        long count = numCompleted.get();
        return count > 0 ? totalProcessingTime / count : 0.0;
    }
    @ManagedAttribute(description = ""Max Processing Time [milliseconds]"")
    public synchronized double getMaxProcessingTimeMillis() throws Exception {
        return maxProcessingTime;
    }
    @ManagedAttribute(description = ""Total Processing Time [milliseconds]"")
    public synchronized double getTotalProcessingTimeMillis() throws Exception {
        return totalProcessingTime;
    }
    @ManagedAttribute(description = ""Last Exchange Completed Timestamp"")
    public synchronized Date getLastExchangeCompletionTime() {
        return lastExchangeCompletionTime;
    }
    @ManagedAttribute(description = ""First Exchange Completed Timestamp"")
    public synchronized Date getFirstExchangeCompletionTime() {
        return firstExchangeCompletionTime;
    }
    @ManagedAttribute(description = ""Last Exchange Failed Timestamp"")
    public synchronized Date getLastExchangeFailureTime() {
        return lastExchangeFailureTime;
    }
    @ManagedAttribute(description = ""First Exchange Failed Timestamp"")
    public synchronized Date getFirstExchangeFailureTime() {
        return firstExchangeFailureTime;
    }
    /**
     * This method is called when an exchange has been processed successfully.
     * 
     * @param time in milliseconds it spent on processing the exchange
     */
    public synchronized void completedExchange(double time) {
        increment();
        numCompleted.incrementAndGet();
        totalProcessingTime += time;
        if (minProcessingTime < 0 || time < minProcessingTime) {
            minProcessingTime = time;
        }
        if (time > maxProcessingTime) {
            maxProcessingTime = time;
        }
        Date timestamp = new Date();
        if (firstExchangeCompletionTime == null) {
            firstExchangeCompletionTime = timestamp;
        }
        lastExchangeCompletionTime = timestamp;
    }
    /**
     * This method is called when an exchange has been processed and failed.
     */
    public synchronized void failedExchange() {
        increment();
        Date timestamp = new Date();
        if (firstExchangeFailureTime == null) {
            firstExchangeFailureTime = timestamp;
        }
        lastExchangeFailureTime = timestamp;
    }
}
"
org.apache.camel.model.AggregatorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collection;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Aggregator;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;aggregator/&gt; element
 *
 * @version $Revision: 673335 $
 */
@XmlRootElement(name = ""aggregator"")
@XmlAccessorType(XmlAccessType.FIELD)
public class AggregatorType extends ExpressionNode {
    @XmlTransient
    private AggregationStrategy aggregationStrategy;
    @XmlTransient
    private AggregationCollection aggregationCollection;
    @XmlAttribute(required = false)
    private Integer batchSize;
    @XmlAttribute(required = false)
    private Long batchTimeout;
    @XmlAttribute(required = false)
    private String strategyRef;
    @XmlElement(name = ""completedPredicate"", required = false)
    private CompletedPredicate completedPredicate;
    public AggregatorType() {
    }
    public AggregatorType(Expression correlationExpression) {
        super(correlationExpression);
    }
    public AggregatorType(ExpressionType correlationExpression) {
        super(correlationExpression);
    }
    public AggregatorType(Expression correlationExpression, AggregationStrategy aggregationStrategy) {
        super(correlationExpression);
        this.aggregationStrategy = aggregationStrategy;
    }
    @Override
    public String toString() {
        return ""Aggregator[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""aggregator"";
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        final Aggregator aggregator = createAggregator(routeContext);
        doAddRoute(routeContext, routes, aggregator);
    }
    private void doAddRoute(RouteContext routeContext, Collection<Route> routes, final Aggregator aggregator)
        throws Exception {
        Route route = new Route<Exchange>(aggregator.getEndpoint(), aggregator) {
            @Override
            public String toString() {
                return ""AggregatorRoute["" + getEndpoint() + "" -> "" + aggregator.getProcessor() + ""]"";
            }
        };
        routes.add(route);
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        final Aggregator aggregator = createAggregator(routeContext);
        doAddRoute(routeContext, routeContext.getCamelContext().getRoutes(), aggregator);
        routeContext.setIsRouteAdded(true);
        return aggregator;
    }
    protected Aggregator createAggregator(RouteContext routeContext) throws Exception {
        Endpoint from = routeContext.getEndpoint();
        final Processor processor = routeContext.createProcessor(this);
        final Aggregator aggregator;
        if (aggregationCollection != null) {
            aggregator = new Aggregator(from, processor, aggregationCollection);
        } else {
            AggregationStrategy strategy = getAggregationStrategy();
            if (strategy == null && strategyRef != null) {
                strategy = routeContext.lookup(strategyRef, AggregationStrategy.class);
            }
            if (strategy == null) {
                strategy = new UseLatestAggregationStrategy();
            }
            Expression aggregateExpression = getExpression().createExpression(routeContext);
            Predicate predicate = null;
            if (completedPredicate != null) {
                predicate = completedPredicate.createPredicate(routeContext);
            }
            if (predicate != null) {
                aggregator = new Aggregator(from, processor, aggregateExpression, strategy, predicate);
            } else {
                aggregator = new Aggregator(from, processor, aggregateExpression, strategy);
            }
        }
        if (batchSize != null) {
            aggregator.setBatchSize(batchSize);
        }
        if (batchTimeout != null) {
            aggregator.setBatchTimeout(batchTimeout);
        }
        return aggregator;
    }
    public AggregationCollection getAggregationCollection() {
        return aggregationCollection;
    }
    public void setAggregationCollection(AggregationCollection aggregationCollection) {
        this.aggregationCollection = aggregationCollection;
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;
    }
    public Integer getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(Integer batchSize) {
        this.batchSize = batchSize;
    }
    public Long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(Long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
    public String getStrategyRef() {
        return strategyRef;
    }
    public void setStrategyRef(String strategyRef) {
        this.strategyRef = strategyRef;
    }
    public CompletedPredicate getCompletePredicate() {
        return completedPredicate;
    }
    public void setCompletePredicate(CompletedPredicate completedPredicate) {
        this.completedPredicate = completedPredicate;
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public AggregatorType batchSize(int batchSize) {
        setBatchSize(batchSize);
        return this;
    }
    public AggregatorType batchTimeout(long batchTimeout) {
        setBatchTimeout(batchTimeout);
        return this;
    }
    /**
     * Sets the predicate used to determine if the aggregation is completed
     *
     * @return the clause used to create the predicate
     */
    public ExpressionClause<AggregatorType> completedPredicate() {
        checkNoCompletedPredicate();
        ExpressionClause<AggregatorType> clause = new ExpressionClause<AggregatorType>(this);
        completedPredicate = new CompletedPredicate(clause);
        return clause;
    }
    /**
     * Sets the predicate used to determine if the aggregation is completed
     */
    public AggregatorType completedPredicate(Predicate predicate) {
        checkNoCompletedPredicate();
        completedPredicate = new CompletedPredicate(predicate);
        return this;
    }
    protected void checkNoCompletedPredicate() {
        if (completedPredicate != null) {
            throw new IllegalArgumentException(""There already is a completedPredicate defined for this aggregator: "" + this);
        }
    }
}
"
org.apache.camel.model.BeanRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.bean.RegistryBean;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;bean/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""bean"")
@XmlAccessorType(XmlAccessType.FIELD)
public class BeanRef extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private String ref;
    @XmlAttribute(required = false)
    private String method;
    @XmlAttribute(required = false)
    private Class beanType;
    @XmlTransient
    private Object bean;
    public BeanRef() {
    }
    public BeanRef(String ref) {
        this.ref = ref;
    }
    public BeanRef(String ref, String method) {
        this.ref = ref;
        this.method = method;
    }
    @Override
    public String toString() {
        return ""Bean["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""bean"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    public void setBean(Object bean) {
        this.bean = bean;
    }
    public Class getBeanType() {
        return beanType;
    }
    public void setBeanType(Class beanType) {
        this.beanType = beanType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        BeanProcessor answer;
        if (ref != null) {
            answer = new BeanProcessor(new RegistryBean(routeContext.getCamelContext(), ref));
        } else {
            if (bean == null) {
                ObjectHelper.notNull(beanType, ""bean, ref or beanType"");
                bean = CamelContextHelper.newInstance(routeContext.getCamelContext(), beanType);
            }
            answer = new BeanProcessor(bean, routeContext.getCamelContext());
        }
        if (method != null) {
            answer.setMethod(method);
        }
        return answer;
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            String methodText = """";
            if (method != null) {
                methodText = "" method: "" + method;
            }
            return ""ref: "" + ref + methodText;
        } else if (bean != null) {
            return bean.toString();
        } else if (beanType != null) {
            return beanType.getName();
        } else {
            return """";
        }
    }
}
"
org.apache.camel.model.Block,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
/**
 * Interface to add block featuring to the XML element type.
 *
 * @version $Revision: 660266 $
 */
public interface Block {
    void addOutput(ProcessorType processorType);
}
"
org.apache.camel.model.CatchType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;catch/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""catch"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CatchType extends ProcessorType<ProcessorType> {
    @XmlElement(name = ""exception"")
    private List<String> exceptions = new ArrayList<String>();
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private List<Class> exceptionClasses;
    public CatchType() {
    }
    public CatchType(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public CatchType(Class exceptionType) {
        exceptionClasses = new ArrayList<Class>();
        exceptionClasses.add(exceptionType);
    }
    @Override
    public String toString() {
        return ""Catch[ "" + getExceptionClasses() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""catch"";
    }
    @Override
    public String getLabel() {
        return getExceptionClasses().toString();
    }
    @Override
    public CatchProcessor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new CatchProcessor(getExceptionClasses(), childProcessor);
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public List<Class> getExceptionClasses() {
        if (exceptionClasses == null) {
            exceptionClasses = createExceptionClasses();
        }
        return exceptionClasses;
    }
    public void setExceptionClasses(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public List<String> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<String> exceptions) {
        this.exceptions = exceptions;
    }
    protected List<Class> createExceptionClasses() {
        List<String> list = getExceptions();
        List<Class> answer = new ArrayList<Class>(list.size());
        for (String name : list) {
            Class type = ObjectHelper.loadClass(name, getClass().getClassLoader());
            answer.add(type);
        }
        return answer;
    }
}
"
org.apache.camel.model.ChoiceType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.processor.ChoiceProcessor;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents an XML &lt;choice/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""choice"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ChoiceType extends ProcessorType<ChoiceType> {
    private static final transient Log LOG = LogFactory.getLog(ChoiceType.class);
    @XmlElementRef
    private List<WhenType> whenClauses = new ArrayList<WhenType>();
    @XmlElement(required = false)
    private OtherwiseType otherwise;
    @Override
    public String toString() {
        if (getOtherwise() != null) {
            return ""Choice[ "" + getWhenClauses() + "" "" + getOtherwise() + ""]"";
        } else {
            return ""Choice[ "" + getWhenClauses() + ""]"";
        }
    }
    @Override
    public String getShortName() {
        return ""choice"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
        for (WhenType whenClaus : whenClauses) {
            filters.add(whenClaus.createProcessor(routeContext));
        }
        Processor otherwiseProcessor = null;
        if (otherwise != null) {
            otherwiseProcessor = otherwise.createProcessor(routeContext);
        } else {
            LOG.warn(""No otherwise clause was specified for a choice block -- any unmatched exchanges will be dropped"");
        }
        return new ChoiceProcessor(filters, otherwiseProcessor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public ChoiceType when(Predicate predicate) {
        getWhenClauses().add(new WhenType(predicate));
        return this;
    }
    public ExpressionClause<ChoiceType> when() {
        WhenType when = new WhenType();
        getWhenClauses().add(when);
        ExpressionClause<ChoiceType> clause = new ExpressionClause<ChoiceType>(this);
        when.setExpression(clause);
        return clause;
    }
    public ChoiceType otherwise() {
        OtherwiseType answer = new OtherwiseType();
        setOtherwise(answer);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    @Override
    public String getLabel() {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        List<WhenType> list = getWhenClauses();
        for (WhenType whenType : list) {
            buffer.append(whenType.getLabel());
        }
        return buffer.toString();
    }
    public List<WhenType> getWhenClauses() {
        return whenClauses;
    }
    public void setWhenClauses(List<WhenType> whenClauses) {
        this.whenClauses = whenClauses;
    }
    public List<ProcessorType<?>> getOutputs() {
        if (otherwise != null) {
            return otherwise.getOutputs();
        } else if (whenClauses.isEmpty()) {
            return Collections.EMPTY_LIST;
        } else {
            WhenType when = whenClauses.get(whenClauses.size() - 1);
            return when.getOutputs();
        }
    }
    public OtherwiseType getOtherwise() {
        return otherwise;
    }
    public void setOtherwise(OtherwiseType otherwise) {
        this.otherwise = otherwise;
    }
}
"
org.apache.camel.model.CompletedPredicate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Predicate;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;completedPredicate/&gt; element
 *
 * @version $Revision: 660266 $
 */
@XmlRootElement(name = ""completedPredicate"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CompletedPredicate {
    @XmlElementRef
    private ExpressionType completePredicate;
    @XmlTransient
    private Predicate predicate;
    public CompletedPredicate() {
    }
    public CompletedPredicate(Predicate predicate) {
        this.predicate = predicate;
    }
    public ExpressionType getCompletePredicate() {
        return completePredicate;
    }
    public void setCompletePredicate(ExpressionType completePredicate) {
        this.completePredicate = completePredicate;
    }
    public Predicate getPredicate() {
        return predicate;
    }
    public void setPredicate(Predicate predicate) {
        this.predicate = predicate;
    }
    public Predicate createPredicate(RouteContext routeContext) {
        ExpressionType predicateType = getCompletePredicate();
        if (predicateType != null && predicate == null) {
            predicate = predicateType.createPredicate(routeContext);
        }
        return predicate;
    }
}
"
org.apache.camel.model.ConvertBodyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.ConvertBodyProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;convertBodyTo/&gt; element
 */
@XmlRootElement(name = ""convertBodyTo"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ConvertBodyType extends ProcessorType<ProcessorType> {
    @XmlAttribute
    private String type;
    @XmlTransient
    private Class typeClass;
    public ConvertBodyType() {
    }
    public ConvertBodyType(String type) {
        setType(type);
    }
    public ConvertBodyType(Class typeClass) {
        setTypeClass(typeClass);
    }
    @Override
    public String toString() {
        return ""convertBodyTo[ "" + getType() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""convertBodyTo"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return new ConvertBodyProcessor(getTypeClass());
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }    
    protected Class createTypeClass() {
        return ObjectHelper.loadClass(getType(), getClass().getClassLoader());
    }
    public void setType(String type) {
        this.type = type;
    }
    public String getType() {
        return type;
    }
    public void setTypeClass(Class typeClass) {
        this.typeClass = typeClass;
    }
    public Class getTypeClass() {
        if (typeClass == null) {
            setTypeClass(createTypeClass());
        }
        return typeClass;
    }
}
"
org.apache.camel.model.DelayerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Delayer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;delayer/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""delayer"")
@XmlAccessorType(XmlAccessType.FIELD)
public class DelayerType extends ExpressionNode {
    private Long delay = 0L;
    public DelayerType() {
    }
    public DelayerType(Expression processAtExpression) {
        super(processAtExpression);
    }
    public DelayerType(ExpressionType processAtExpression) {
        super(processAtExpression);
    }
    public DelayerType(Expression processAtExpression, long delay) {
        super(processAtExpression);
        this.delay = delay;
    }
    @Override
    public String toString() {
        return ""Delayer[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""delayer"";
    }
    public Long getDelay() {
        return delay;
    }
    public void setDelay(Long delay) {
        this.delay = delay;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        Expression processAtExpression = getExpression() != null ? getExpression().createExpression(routeContext) : null;
        return new Delayer(childProcessor, processAtExpression, delay);
    }
}
"
org.apache.camel.model.Description,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlValue;
/**
 * Represents a description element which can be used on any element in the EIP route
 *
 * @version $Revision: 662301 $
 */
@XmlRootElement(name = ""description"")
@XmlAccessorType(XmlAccessType.FIELD)
public class Description {
    @XmlAttribute(required = false)
    private String lang;
    @XmlValue
    private String text;
    public String getLang() {
        return lang;
    }
    public void setLang(String lang) {
        this.lang = lang;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
}
"
org.apache.camel.model.ExceptionType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;onException/&gt; element
 *
 * @version $Revision: 660266 $
 */
@XmlRootElement(name = ""onException"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ExceptionType extends ProcessorType<ProcessorType> {
/*
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
*/
    @XmlElement(name = ""exception"")
    private List<String> exceptions = new ArrayList<String>();
    @XmlElement(name = ""redeliveryPolicy"", required = false)
    private RedeliveryPolicyType redeliveryPolicy;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private List<Class> exceptionClasses;
    @XmlTransient
    private Processor errorHandler;
    public ExceptionType() {
    }
    public ExceptionType(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public ExceptionType(Class exceptionType) {
        exceptionClasses = new ArrayList<Class>();
        exceptionClasses.add(exceptionType);
    }
    @Override
    public String toString() {
        return ""Exception[ "" + getExceptionClasses() + "" -> "" + getOutputs() + ""]"";
    }
    /**
     * Allows an exception handler to create a new redelivery policy for this exception type
     * @param parentPolicy the current redelivery policy
     * @return a newly created redelivery policy, or return the original policy if no customization is required
     * for this exception handler.
     */
    public RedeliveryPolicy createRedeliveryPolicy(RedeliveryPolicy parentPolicy) {
        if (redeliveryPolicy != null) {
            return redeliveryPolicy.createRedeliveryPolicy(parentPolicy);
        } else if (errorHandler != null) {
            // lets create a new error handler that has no retries
            RedeliveryPolicy answer = parentPolicy.copy();
            answer.setMaximumRedeliveries(0);
            return answer;
        }
        return parentPolicy;
    }
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        // lets attach a processor to an error handler
        errorHandler = routeContext.createProcessor(this);
        ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();
        builder.addErrorHandlers(this);
    }
    @Override
    public CatchProcessor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new CatchProcessor(getExceptionClasses(), childProcessor);
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public ExceptionType backOffMultiplier(double backOffMultiplier) {
        getOrCreateRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    public ExceptionType collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        getOrCreateRedeliveryPolicy().collisionAvoidanceFactor(collisionAvoidanceFactor);
        return this;
    }
    public ExceptionType collisionAvoidancePercent(short collisionAvoidancePercent) {
        getOrCreateRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    public ExceptionType initialRedeliveryDelay(long initialRedeliveryDelay) {
        getOrCreateRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public ExceptionType maximumRedeliveries(int maximumRedeliveries) {
        getOrCreateRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public ExceptionType useCollisionAvoidance() {
        getOrCreateRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    public ExceptionType useExponentialBackOff() {
        getOrCreateRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
    // Properties
    //-------------------------------------------------------------------------
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public List<Class> getExceptionClasses() {
        if (exceptionClasses == null) {
            exceptionClasses = createExceptionClasses();
        }
        return exceptionClasses;
    }
    public void setExceptionClasses(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public List<String> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<String> exceptions) {
        this.exceptions = exceptions;
    }
    public Processor getErrorHandler() {
        return errorHandler;
    }
    public RedeliveryPolicyType getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    public void setRedeliveryPolicy(RedeliveryPolicyType redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected RedeliveryPolicyType getOrCreateRedeliveryPolicy() {
        if (redeliveryPolicy == null) {
            redeliveryPolicy = new RedeliveryPolicyType();
        }
        return redeliveryPolicy;
    }
    protected List<Class> createExceptionClasses() {
        List<String> list = getExceptions();
        List<Class> answer = new ArrayList<Class>(list.size());
        for (String name : list) {
            Class type = ObjectHelper.loadClass(name, getClass().getClassLoader());
            answer.add(type);
        }
        return answer;
    }
}
"
org.apache.camel.model.ExpressionNode,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * A base class for nodes which contain an expression and a number of outputs
 *
 * @version $Revision: 671918 $
 */
@XmlAccessorType(XmlAccessType.FIELD)
public class ExpressionNode extends ProcessorType<ProcessorType> {
    @XmlElementRef
    private ExpressionType expression;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public ExpressionNode() {
    }
    public ExpressionNode(ExpressionType expression) {
        this.expression = expression;
    }
    public ExpressionNode(Expression expression) {
        if (expression != null) {
            setExpression(new ExpressionType(expression));
        }
    }
    public ExpressionNode(Predicate predicate) {
        if (predicate != null) {
            setExpression(new ExpressionType(predicate));
        }
    }
    @Override
    public String getShortName() {
        return ""exp"";
    }
    public ExpressionType getExpression() {
        return expression;
    }
    public void setExpression(ExpressionType expression) {
        this.expression = expression;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    @Override
    public String getLabel() {
        if (getExpression() == null) {
            return """";
        }
        return getExpression().getLabel();
    }
    protected FilterProcessor createFilterProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new FilterProcessor(getExpression().createPredicate(routeContext), childProcessor);
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
    }
}
"
org.apache.camel.model.FilterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;filter/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""filter"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FilterType extends ExpressionNode implements Block {
    public FilterType() {
    }
    public FilterType(ExpressionType expression) {
        super(expression);
    }
    public FilterType(Predicate predicate) {
        super(predicate);
    }
    @Override
    public String toString() {
        return ""Filter[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""filter"";
    }
    @Override
    public FilterProcessor createProcessor(RouteContext routeContext) throws Exception {
        return createFilterProcessor(routeContext);
    }
}
"
org.apache.camel.model.FinallyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;finally/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""finally"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FinallyType extends OutputType<ProcessorType> implements Block {
    @Override
    public String toString() {
        return ""Finally["" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""finally"";
    }
    @Override
    public String getLabel() {
        return """";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return routeContext.createProcessor(this);
    }
}
"
org.apache.camel.model.FromType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;from/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""from"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FromType extends OptionalIdentifiedType<FromType> {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String ref;
    @XmlTransient
    private Endpoint<? extends Exchange> endpoint;
    public FromType() {
    }
    public FromType(String uri) {
        setUri(uri);
    }
    public FromType(Endpoint<? extends Exchange> endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""From["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""from"";
    }
    public String getLabel() {
        return description(getUri(), getRef(), getEndpoint());
    }
    public Endpoint<? extends Exchange> resolveEndpoint(RouteContext context) {
        if (endpoint == null) {
            endpoint = context.resolveEndpoint(getUri(), getRef());
        }
        return endpoint;
    }
    // Properties
    // -----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI of the endpoint to use
     *
     * @param uri the endpoint URI to use
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    public String getRef() {
        return ref;
    }
    /**
     * Sets the name of the endpoint within the registry (such as the Spring
     * ApplicationContext or JNDI) to use
     *
     * @param ref the reference name to use
     */
    public void setRef(String ref) {
        this.ref = ref;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    /**
     * Returns the endpoint URI or the name of the reference to it
     */
    public Object getUriOrRef() {
        if (ObjectHelper.isNullOrBlank(uri)) {
            return uri;
        } else if (endpoint != null) {
            return endpoint.getEndpointUri();
        }
        return ref;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected static String description(String uri, String ref, Endpoint endpoint) {
        if (ref != null) {
            return ""ref:"" + ref;
        } else if (endpoint != null) {
            return endpoint.getEndpointUri();
        } else if (uri != null) {
            return uri;
        } else {
            return ""no uri or ref supplied!"";
        }
    }
}
"
org.apache.camel.model.GenerateXmlTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.io.StringWriter;
import java.util.List;
import javax.xml.bind.Marshaller;
import org.apache.camel.model.language.GroovyExpression;
import org.apache.camel.model.language.XQueryExpression;
/**
 * @version $Revision: 668035 $
 */
public class GenerateXmlTest extends XmlTestSupport {
    public void testCreateSimpleXml() throws Exception {
        RoutesType context = new RoutesType();
        RouteType route = context.route();
        route.from(""seda:a"");
        route.filter(new XQueryExpression(""in.header.foo == 'bar'"")).
                to(""seda:b"");
        route.description(""This is a description of the route"");
        dump(context);
    }
    public void testGroovyFilterXml() throws Exception {
        RoutesType context = new RoutesType();
        RouteType route = context.route();
        route.from(""seda:a"");
        route.interceptors(""interceptor1"", ""interceptor2"");
        route.filter(new GroovyExpression(""in.headers.any { h -> h.startsWith('foo') }"")).
                to(""seda:b"");
        route.description(""This is a description of the route"");
        List<ProcessorType<?>> list = route.getOutputs();
        assertEquals(""Size of list: "" + list, 1, list.size());
        dump(context);
    }
    protected void dump(RouteContainer context) throws Exception {
        Marshaller marshaller = jaxbContext.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        StringWriter buffer = new StringWriter();
        marshaller.marshal(context, buffer);
        log.info(""Created: "" + buffer);
        assertNotNull(buffer);
        String out = buffer.toString();
        assertTrue(""Should contain the description"", out.indexOf(""This is a description of the route"") > 0);
    }
}
"
org.apache.camel.model.HandleFaultType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.HandleFaultProcessor;
/**
 * Represents an XML &lt;handleFault/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""handleFault"")
@XmlAccessorType(XmlAccessType.FIELD)
public class HandleFaultType extends InterceptorRef {
    public HandleFaultType() {
        super(new HandleFaultProcessor());
    }
    @Override
    public String getShortName() {
        return ""handleFault"";
    }
    @Override
    public String toString() {
        return ""HandleFault["" + getLabel() + ""]"";
    }
}
"
org.apache.camel.model.IdempotentConsumerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;idempotentConsumer/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""idempotentConsumer"")
@XmlAccessorType(XmlAccessType.FIELD)
public class IdempotentConsumerType extends ExpressionNode {
    @XmlAttribute
    private String messageIdRepositoryRef;
    @XmlTransient
    private MessageIdRepository messageIdRepository;
    public IdempotentConsumerType() {
    }
    public IdempotentConsumerType(Expression messageIdExpression, MessageIdRepository messageIdRepository) {
        super(messageIdExpression);
        this.messageIdRepository = messageIdRepository;
    }
    @Override
    public String toString() {
        return ""IdempotentConsumer[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""idempotentConsumer"";
    }
    public String getMessageIdRepositoryRef() {
        return messageIdRepositoryRef;
    }
    public void setMessageIdRepositoryRef(String messageIdRepositoryRef) {
        this.messageIdRepositoryRef = messageIdRepositoryRef;
    }
    public MessageIdRepository getMessageIdRepository() {
        return messageIdRepository;
    }
    public void setMessageIdRepository(MessageIdRepository messageIdRepository) {
        this.messageIdRepository = messageIdRepository;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        MessageIdRepository messageIdRepository = resolveMessageIdRepository(routeContext);
        return new IdempotentConsumer(getExpression().createExpression(routeContext), messageIdRepository,
                                      childProcessor);
    }
    public MessageIdRepository resolveMessageIdRepository(RouteContext routeContext) {
        if (messageIdRepository == null) {
            messageIdRepository = routeContext.lookup(messageIdRepositoryRef, MessageIdRepository.class);
        }
        return messageIdRepository;
    }
}
"
org.apache.camel.model.IdentifiedType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
/**
 * The unique identifier for a bean. The scope of the identifier is the enclosing bean factory.
 * <p>
 * The following schema fragment specifies the expected content contained within this class.
 * <pre>
 * &lt;complexType name=""identifiedType"">
 *   &lt;complexContent>
 *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
 *       &lt;attribute name=""id"" type=""{http://www.w3.org/2001/XMLSchema}ID"" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 * @version $Revision: 660266 $
 */
@XmlType(name = ""identifiedType"")
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class IdentifiedType {
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    /**
     * Gets the value of the id property.
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     */
    public void setId(String value) {
        this.id = value;
    }
}
"
org.apache.camel.model.InterceptorRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Base class for interceptor types.
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""interceptor"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InterceptorRef extends InterceptorType {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private DelegateProcessor interceptor;
    public InterceptorRef() {
    }
    public InterceptorRef(String ref) {
        setRef(ref);
    }
    public InterceptorRef(DelegateProcessor interceptor) {
        this.interceptor = interceptor;
    }
    @Override
    public String toString() {
        return ""Interceptor["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""interceptor"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        DelegateProcessor processor = createInterceptor(routeContext);
        Processor child = createOutputsProcessor(routeContext);
        processor.setProcessor(child);
        return processor;
    }
    public DelegateProcessor createInterceptor(RouteContext routeContext) {
        if (interceptor == null) {
            interceptor = routeContext.lookup(getRef(), DelegateProcessor.class);
        }
        if (interceptor == null) {
            throw new IllegalArgumentException(""No DelegateProcessor bean available for reference: "" + getRef());
        }
        return interceptor;
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        } else if (interceptor != null) {
            return interceptor.toString();
        } else {
            return """";
        }
    }
    /**
     * Get the underlying {@link DelegateProcessor} implementation
     * 
     * @return the {@link DelegateProcessor}
     */
    @XmlTransient
    public DelegateProcessor getInterceptor() {
        return interceptor;
    }
}
"
org.apache.camel.model.InterceptorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Base class for interceptor types.
 * 
 * @version $Revision: 660266 $
 */
@XmlType(name = ""interceptorType"")
public abstract class InterceptorType extends OutputType implements Block {
    public abstract DelegateProcessor createInterceptor(RouteContext routeContext) throws Exception;
}
"
org.apache.camel.model.InterceptType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Intercept;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.processor.Interceptor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;intercept/&gt; element
 *
 * @version $Revision: 674289 $
 */
@XmlRootElement(name = ""intercept"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InterceptType extends OutputType<ProcessorType> {
    @XmlTransient
    private ProceedType proceed = new ProceedType();
    @XmlTransient
    private Boolean stop = Boolean.FALSE;
    @XmlTransient
    private Boolean usePredicate = Boolean.FALSE;
    @Override
    public String toString() {
        return ""Intercept["" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""intercept"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Interceptor interceptor = new Interceptor();
        routeContext.intercept(interceptor);
        final Processor interceptRoute = createOutputsProcessor(routeContext);
        interceptor.setInterceptorLogic(interceptRoute);
        return interceptor;
    }
    /**
     * Applies this interceptor only if the given predicate is true
     */
    public ChoiceType when(Predicate predicate) {
        usePredicate = Boolean.TRUE;
        ChoiceType choice = choice().when(PredicateBuilder.not(predicate));
        choice.addOutput(proceed);
        return choice.otherwise();
    }
    public ProceedType getProceed() {
        return proceed;
    }
    public void stopIntercept() {
        stop = Boolean.TRUE;
    }
    public InterceptType createProxy() {
        InterceptType answer = new InterceptType();
        answer.getOutputs().addAll(this.getOutputs());
        // hack: now we need to replace the proceed of the proxy with its own
        // a bit ugly, operating based on the assumption that the proceed is
        // in its outputs (if proceed() was called) and/or in the
        // outputs of the otherwise or last when clause for the predicated version.
        if (answer.getOutputs().size() > 0) {
            // this is for the predicate version or if a choice() is present
            ChoiceType choice = null;
            for (ProcessorType processor : answer.getOutputs()) {
                if (processor instanceof ChoiceType) {
                    // special cases for predicates (choices)
                    choice = (ChoiceType) processor;
                    // for the predicated version we add the proceed() to otherwise()
                    // before knowing if stop() will follow, so let's make a small adjustment
                    if (usePredicate.booleanValue() && stop.booleanValue()) {
                        WhenType when = choice.getWhenClauses().get(0);
                        when.getOutputs().remove(this.getProceed());
                    }
                    // add proceed to the when clause
                    addProceedProxy(this.getProceed(), answer.getProceed(),
                        choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate.booleanValue() && !stop.booleanValue());
                    // force adding a proceed at the end (otherwise) if its not a stop type
                    addProceedProxy(this.getProceed(), answer.getProceed(), choice.getOtherwise(), !stop.booleanValue());
                    if (stop.booleanValue()) {
                        // must add proceed to when clause if stop is explictiy declared, otherwise when the
                        // predicate test fails then there is no proceed
                        // See example: InterceptorSimpleRouteTest (City Paris is never proceeded)  
                        addProceedProxy(this.getProceed(), answer.getProceed(),
                            choice.getWhenClauses().get(choice.getWhenClauses().size() - 1), usePredicate.booleanValue());
                    }
                    break;
                }
            }
            if (choice == null) {
                // force adding a proceed at the end if its not a stop type
                addProceedProxy(this.getProceed(), answer.getProceed(), answer, !stop.booleanValue());
            }
        }
        return answer;
    }
    private void addProceedProxy(ProceedType orig, ProceedType proxy, ProcessorType<?> processor, boolean force) {
        int index = processor.getOutputs().indexOf(orig);
        if (index >= 0) {
            processor.addOutput(proxy);
            // replace original proceed with proxy
            List<ProcessorType<?>> outs = processor.getOutputs();
            outs.remove(proxy);
            outs.set(index, proxy);
        } else if (force) {
            processor.addOutput(proxy);
        }
    }
}
"
org.apache.camel.model.LoadBalanceType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.loadbalancer.LoadBalancerType;
import org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.RandomLoadBalancer;
import org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer;
import org.apache.camel.processor.loadbalancer.StickyLoadBalancer;
import org.apache.camel.processor.loadbalancer.TopicLoadBalancer;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CollectionStringBuffer;
/**
 * Represents an XML &lt;loadBalance/&gt; element
 */
@XmlRootElement(name = ""loadBalance"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LoadBalanceType extends OutputType<LoadBalanceType> {
    @XmlAttribute(required = false)
    private String ref;
    @XmlElements({
        @XmlElement(required = false, name = ""roundRobin"", type = RoundRobinLoadBalanceStrategy.class),
        @XmlElement(required = false, name = ""random"", type = RandomLoadBalanceStrategy.class),
        @XmlElement(required = false, name = ""sticky"", type = StickyLoadBalanceStrategy.class),
        @XmlElement(required = false, name = ""topic"", type = TopicLoadBalanceStrategy.class)}
        )
    private LoadBalancerType loadBalancerType;
    public LoadBalanceType() {
    }
    @Override
    public String getShortName() {
        return ""loadbalance"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public LoadBalancerType getLoadBalancerType() {
        return loadBalancerType;
    }
    public void setLoadBalancerType(LoadBalancerType loadbalancer) {
        loadBalancerType = loadbalancer;
    }
    protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorType<?>> outputs)
        throws Exception {
        LoadBalancer loadBalancer = LoadBalancerType.getLoadBalancer(routeContext, loadBalancerType, ref);
        for (ProcessorType processorType : outputs) {
            // The outputs should be the SendProcessor
            SendProcessor processor = (SendProcessor) processorType.createProcessor(routeContext);
            loadBalancer.addProcessor(processor);
        }
        return loadBalancer;
    }
    // when this method will be called
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        LoadBalancer loadBalancer = LoadBalancerType.getLoadBalancer(routeContext, loadBalancerType, ref);
        for (ProcessorType processorType : getOutputs()) {
            // The outputs should be the SendProcessor
            SendProcessor processor = (SendProcessor) processorType.createProcessor(routeContext);
            loadBalancer.addProcessor(processor);
        }
        return loadBalancer;
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public LoadBalanceType setLoadBalancer(LoadBalancer loadBalancer) {
        loadBalancerType = new LoadBalancerType(loadBalancer);
        return this;
    }
    public LoadBalanceType roundRobin() {
        loadBalancerType = new LoadBalancerType(new RoundRobinLoadBalancer());
        return this;
    }
    public LoadBalanceType random() {
        loadBalancerType = new LoadBalancerType(new RandomLoadBalancer());
        return this;
    }
    public LoadBalanceType sticky(Expression<Exchange> correlationExpression) {
        loadBalancerType = new LoadBalancerType(new StickyLoadBalancer(correlationExpression));
        return this;
    }
    public LoadBalanceType topic() {
        loadBalancerType = new LoadBalancerType(new TopicLoadBalancer());
        return this;
    }
    @Override
    public String getLabel() {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        List<ProcessorType<?>> list = getOutputs();
        for (ProcessorType<?> processorType : list) {
            buffer.append(processorType.getLabel());
        }
        return buffer.toString();
    }
    @Override
    public String toString() {
        String result;
        if (loadBalancerType != null) {
            result = ""LoadBalanceType["" + loadBalancerType + "", "";
        } else {
            result =  ""LoadBalanceType["" + ref + "", "";
        }
        result = result + getOutputs() + ""]"";
        return result;
    }
}
"
org.apache.camel.model.MarshalType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.CsvDataFormat;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.StringDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.processor.MarshalProcessor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Marshals to a binary payload using the given {@link DataFormatType}
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""marshal"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MarshalType extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private String ref;
    // TODO cannot use @XmlElementRef as it doesn't allow optional properties
    // @XmlElementRef
    @XmlElements({
    @XmlElement(required = false, name = ""artixDS"", type = ArtixDSDataFormat.class),
    @XmlElement(required = false, name = ""csv"", type = CsvDataFormat.class),
    @XmlElement(required = false, name = ""jaxb"", type = JaxbDataFormat.class),
    @XmlElement(required = false, name = ""serialization"", type = SerializationDataFormat.class),
    @XmlElement(required = false, name = ""string"", type = StringDataFormat.class),
    @XmlElement(required = false, name = ""xmlBeans"", type = XMLBeansDataFormat.class)}
    )
    private DataFormatType dataFormatType;
    public MarshalType() {
    }
    public MarshalType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    public MarshalType(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        if (dataFormatType != null) {
            return ""Marshal["" + dataFormatType + ""]"";
        } else {
            return ""Marshal[ref:  "" + ref + ""]"";
        }
    }
    @Override
    public String getShortName() {
        return ""marshal"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public DataFormatType getDataFormatType() {
        return dataFormatType;
    }
    public void setDataFormatType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        DataFormat dataFormat = DataFormatType.getDataFormat(routeContext, getDataFormatType(), ref);
        return new MarshalProcessor(dataFormat);
    }
}
"
org.apache.camel.model.MulticastType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.MulticastProcessor;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;multicast/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""multicast"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MulticastType extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private Boolean parallelProcessing;
    @XmlTransient
    private AggregationStrategy aggregationStrategy;
    @XmlTransient
    private ThreadPoolExecutor threadPoolExecutor;
    @Override
    public String toString() {
        return ""Multicast["" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""multicast"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return createOutputsProcessor(routeContext);
    }
    protected Processor createCompositeProcessor(List<Processor> list) {
        if (aggregationStrategy == null) {
            aggregationStrategy = new UseLatestAggregationStrategy();
        }
        return new MulticastProcessor(list, aggregationStrategy, isParallelProcessing(), threadPoolExecutor);
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public MulticastType setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;
        return this;
    }
    public boolean isParallelProcessing() {
        return parallelProcessing != null ? parallelProcessing : false;
    }
    public MulticastType setParallelProcessing(boolean parallelProcessing) {
        this.parallelProcessing = parallelProcessing;
        return this;
    }
    public ThreadPoolExecutor getThreadPoolExecutor() {
        return threadPoolExecutor;
    }
    public MulticastType setThreadPoolExecutor(ThreadPoolExecutor executor) {
        this.threadPoolExecutor = executor;
        return this;
    }
    @Override
    protected Processor wrapProcessorInInterceptors(RouteContext routeContext, Processor target) throws Exception {
        // No need to wrap me in interceptors as they are all applied directly to my children
        return new StreamCachingInterceptor(target);
    }
}
"
org.apache.camel.model.NodeFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
/**
 * A simple factory used to create new child nodes which allows pluggable extension points
 * such as to add extra DSL helper methods such as for the Groovy or Ruby DSLs
 *
 * @version $Revision: 640438 $
 */
public class NodeFactory {
    public FilterType createFilter() {
        return new FilterType();
    }
    public RouteType createRoute() {
        return new RouteType();
    }
}
"
org.apache.camel.model.OptionalIdentifiedType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
/**
 * Allows an element to have an optional ID specified
 *
 * @version $Revision: 672271 $
 */
@XmlType(name = ""optionalIdentifiedType"")
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class OptionalIdentifiedType<T extends OptionalIdentifiedType> {
    @XmlTransient
    protected static Map<String, AtomicInteger> nodeCounters = new HashMap<String, AtomicInteger>();
    @XmlAttribute(required = false)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    @XmlElement(required = false)
    private Description description;
    /**
     * Gets the value of the id property.
     *
     * @return possible object is
     *         {@link String }
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setId(String value) {
        this.id = value;
    }
    public Description getDescription() {
        return description;
    }
    public void setDescription(Description description) {
        this.description = description;
    }
    /**
     * Returns a short name for this node which can be useful for ID generation or referring to related resources like images
     *
     * @return defaults to ""node"" but derived nodes should overload this to provide a unique name
     */
    public String getShortName() {
        return ""node"";
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public T description(String text) {
        if (description == null) {
            description = new Description();
        }
        description.setText(text);
        return (T) this;
    }
    public T description(String text, String lang) {
        description(text);
        description.setLang(lang);
        return (T) this;
    }
    public T id(String id) {
        setId(id);
        return (T) this;
    }
    public String idOrCreate() {
        if (id == null) {
            setId(createId());
        }
        return getId();
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A helper method to create a new ID for this node
     */
    protected String createId() {
        String key = getShortName();
        return key + getNodeCounter(key).incrementAndGet();
    }
    /**
     * Returns the counter for the given node key, lazily creating one if necessary
     */
    protected static synchronized AtomicInteger getNodeCounter(String key) {
        AtomicInteger answer = nodeCounters.get(key);
        if (answer == null) {
            answer = new AtomicInteger(0);
            nodeCounters.put(key, answer);
        }
        return answer;
    }
}
"
org.apache.camel.model.OtherwiseType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;otherwise/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""otherwise"")
@XmlAccessorType(XmlAccessType.FIELD)
public class OtherwiseType extends OutputType<ProcessorType> implements Block {
    @Override
    public String toString() {
        return ""Otherwise["" + getOutputs() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return routeContext.createProcessor(this);
    }
    @Override
    public String getShortName() {
        return ""otherwise"";
    }
    @Override
    public String getLabel() {
        return ""otherwise"";
    }
}
"
org.apache.camel.model.OutputType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for output types
 *
 * @version $Revision: 640438 $
 */
@XmlType(name = ""outputType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class OutputType<Type extends ProcessorType> extends ProcessorType<Type> {
    private static final transient Log LOG = LogFactory.getLog(OutputType.class);
    @XmlElementRef
    protected List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                configureChild(output);
            }
        }
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
        // don't inherit interceptors by default
/*
        List<InterceptorType> list = output.getInterceptors();
        if (list == null) {
            log.warn(""No interceptor collection: "" + output);
        }
        else {
            list.addAll(getInterceptors());
        }
*/
    }
}
"
org.apache.camel.model.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JAXB POJOs for the
 * <a href=""http://activemq.apache.org/camel/xml-configuration.html"">XML Configuration</a>
 * of the routing rules.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model;
"
org.apache.camel.model.PipelineType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;pipeline/&gt; element which can be used to define an explicit pipeline; or to define
 * a specific pipeline within a &lt;multicast&gt; block
 *
 * @version $Revision: 673835 $
 */
@XmlRootElement(name = ""pipeline"")
@XmlAccessorType(XmlAccessType.FIELD)
public class PipelineType extends OutputType<ProcessorType> {
    @Override
    public String getShortName() {
        return ""pipeline"";
    }
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return createOutputsProcessor(routeContext);
    }
}
"
org.apache.camel.model.PolicyRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;policy/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""policy"")
@XmlAccessorType(XmlAccessType.FIELD)
public class PolicyRef extends OutputType<ProcessorType> {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private Policy policy;
    public PolicyRef() {
    }
    public PolicyRef(Policy policy) {
        this.policy = policy;
    }
    @Override
    public String toString() {
        return ""Policy["" + description() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""policy"";
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        } else if (policy != null) {
            return policy.toString();
        } else {
            return """";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = createOutputsProcessor(routeContext);
        Policy policy = resolvePolicy(routeContext);
        if (policy == null) {
            throw new IllegalArgumentException(""No policy configured: "" + this);
        }
        return policy.wrap(childProcessor);
    }
    protected Policy resolvePolicy(RouteContext routeContext) {
        if (policy == null) {
            policy = routeContext.lookup(getRef(), Policy.class);
        }
        return policy;
    }
    protected String description() {
        if (policy != null) {
            return policy.toString();
        } else {
            return ""ref:  "" + ref;
        }
    }
}
"
org.apache.camel.model.ProceedType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;proceed/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""proceed"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ProceedType extends OutputType<ProcessorType> {
    @Override
    public String getShortName() {
        return ""proceed"";
    }
    // TODO we should be just returning the outputs!
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        //return routeContext.createProceedProcessor();
        return createOutputsProcessor(routeContext);
    }
}
"
org.apache.camel.model.ProcessorRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;process/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""process"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ProcessorRef extends OutputType<ProcessorType> {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private Processor processor;
    public ProcessorRef() {
    }
    public ProcessorRef(Processor processor) {
        this.processor = processor;
    }
    @Override
    public String getShortName() {
        return ""processor"";
    }
    @Override
    public String toString() {
        return ""Processor[""
                + ((ref != null) ? ""ref:  "" + ref : processor)
                + ""]"";
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        } else if (processor != null) {
            return processor.toString();
        } else {
            return """";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        if (processor == null) {
            processor = routeContext.lookup(getRef(), Processor.class);
        }
        return processor;
    }
}
"
org.apache.camel.model.ProcessorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelException;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.DataFormatClause;
import org.apache.camel.builder.DeadLetterChannelBuilder;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.ErrorHandlerBuilderRef;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.builder.NoErrorHandlerBuilder;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.model.language.LanguageExpression;
import org.apache.camel.processor.ConvertBodyProcessor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.ErrorHandlerWrappingStrategy;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.camel.spi.Policy;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Base class for processor types that most XML types extend.
 *
 * @version $Revision: 673837 $
 */
@XmlAccessorType(XmlAccessType.PROPERTY)
public abstract class ProcessorType<Type extends ProcessorType> extends OptionalIdentifiedType<Type> implements Block {
    public static final String DEFAULT_TRACE_CATEGORY = ""org.apache.camel.TRACE"";
    private static final transient Log LOG = LogFactory.getLog(ProcessorType.class);
    private ErrorHandlerBuilder errorHandlerBuilder;
    private Boolean inheritErrorHandlerFlag;
    private NodeFactory nodeFactory;
    private LinkedList<Block> blocks = new LinkedList<Block>();
    private ProcessorType<? extends ProcessorType> parent;
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    private String errorHandlerRef;
    // else to use an optional attribute in JAXB2
    public abstract List<ProcessorType<?>> getOutputs();
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        throw new UnsupportedOperationException(""Not implemented yet for class: "" + getClass().getName());
    }
    public Processor createOutputsProcessor(RouteContext routeContext) throws Exception {
        Collection<ProcessorType<?>> outputs = getOutputs();
        return createOutputsProcessor(routeContext, outputs);
    }
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        Processor processor = makeProcessor(routeContext);
        if (!routeContext.isRouteAdded()) {
            routeContext.addEventDrivenProcessor(processor);
        }
    }
    /**
     * Wraps the child processor in whatever necessary interceptors and error
     * handlers
     */
    public Processor wrapProcessor(RouteContext routeContext, Processor processor) throws Exception {
        processor = wrapProcessorInInterceptors(routeContext, processor);
        return wrapInErrorHandler(routeContext, processor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Sends the exchange to the given endpoint URI
     */
    public Type to(String uri) {
        addOutput(new ToType(uri));
        return (Type) this;
    }
    /**
     * Sends the exchange to the given endpoint
     */
    public Type to(Endpoint endpoint) {
        addOutput(new ToType(endpoint));
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints using the
     * {@link MulticastProcessor} pattern
     */
    public Type to(String... uris) {
        for (String uri : uris) {
            addOutput(new ToType(uri));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints using the
     * {@link MulticastProcessor} pattern
     */
    public Type to(Endpoint... endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoint using the
     * {@link MulticastProcessor} pattern
     */
    public Type to(Collection<Endpoint> endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint));
        }
        return (Type) this;
    }
    /**
     * Multicasts messages to all its child outputs; so that each processor and
     * destination gets a copy of the original message to avoid the processors
     * interfering with each other.
     */
    public MulticastType multicast() {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        return answer;
    }
    /**
     * Multicasts messages to all its child outputs; so that each processor and
     * destination gets a copy of the original message to avoid the processors
     * interfering with each other.
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the multicast type
     */
    public MulticastType multicast(AggregationStrategy aggregationStrategy, boolean parallelProcessing) {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        return answer;
    }
    /**
     * Multicasts messages to all its child outputs; so that each processor and
     * destination gets a copy of the original message to avoid the processors
     * interfering with each other.
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @return the multicast type
     */
    public MulticastType multicast(AggregationStrategy aggregationStrategy) {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        return answer;
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(String... uris) {
        // TODO pipeline v mulicast
        return to(uris);
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(Endpoint... endpoints) {
        // TODO pipeline v mulicast
        return to(endpoints);
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(Collection<Endpoint> endpoints) {
        // TODO pipeline v mulicast
        return to(endpoints);
    }
    /**
     * Ends the current block
     */
    public ProcessorType<? extends ProcessorType> end() {
        if (blocks.isEmpty()) {
            if (parent == null) {
                throw new IllegalArgumentException(""Root node with no active block"");
            }
            return parent;
        }
        popBlock();
        return this;
    }
    /**
     * Causes subsequent processors to be called asynchronously
     *
     * @param coreSize the number of threads that will be used to process
     *                 messages in subsequent processors.
     * @return a ThreadType builder that can be used to further configure the
     *         the thread pool.
     */
    public ThreadType thread(int coreSize) {
        ThreadType answer = new ThreadType(coreSize);
        addOutput(answer);
        return answer;
    }
    /**
     * Causes subsequent processors to be called asynchronously
     *
     * @param executor the executor that will be used to process
     *                 messages in subsequent processors.
     * @return a ThreadType builder that can be used to further configure the
     *         the thread pool.
     */
    public ProcessorType<Type> thread(ThreadPoolExecutor executor) {
        ThreadType answer = new ThreadType(executor);
        addOutput(answer);
        return this;
    }
    /**
     * Creates an {@link IdempotentConsumer} to avoid duplicate messages
     */
    public IdempotentConsumerType idempotentConsumer(Expression messageIdExpression,
            MessageIdRepository messageIdRepository) {
        IdempotentConsumerType answer = new IdempotentConsumerType(messageIdExpression, messageIdRepository);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates an {@link IdempotentConsumer} to avoid duplicate messages
     *
     * @return the builder used to create the expression
     */
    public ExpressionClause<IdempotentConsumerType> idempotentConsumer(MessageIdRepository messageIdRepository) {
        IdempotentConsumerType answer = new IdempotentConsumerType();
        answer.setMessageIdRepository(messageIdRepository);
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates a predicate expression which only if it is true then the
     * exchange is forwarded to the destination
     *
     * @return the clause used to create the filter expression
     */
    public ExpressionClause<FilterType> filter() {
        FilterType filter = new FilterType();
        addOutput(filter);
        return ExpressionClause.createAndSetExpression(filter);
    }
    /**
     * Creates a predicate which is applied and only if it is true then the
     * exchange is forwarded to the destination
     *
     * @return the builder for a predicate
     */
    public FilterType filter(Predicate predicate) {
        FilterType filter = new FilterType(predicate);
        addOutput(filter);
        return filter;
    }
    public FilterType filter(ExpressionType expression) {
        FilterType filter = getNodeFactory().createFilter();
        filter.setExpression(expression);
        addOutput(filter);
        return filter;
    }
    public FilterType filter(String language, String expression) {
        return filter(new LanguageExpression(language, expression));
    }
    public LoadBalanceType loadBalance() {
        LoadBalanceType answer = new LoadBalanceType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a choice of one or more predicates with an otherwise clause
     *
     * @return the builder for a choice expression
     */
    public ChoiceType choice() {
        ChoiceType answer = new ChoiceType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a try/catch block
     *
     * @return the builder for a tryBlock expression
     */
    public TryType tryBlock() {
        TryType answer = new TryType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a dynamic <a
     * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient
     * List</a> pattern.
     *
     * @param receipients is the builder of the expression used in the
     *                    {@link RecipientList} to decide the destinations
     */
    public Type recipientList(Expression receipients) {
        RecipientListType answer = new RecipientListType(receipients);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates a dynamic <a
     * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient
     * List</a> pattern.
     *
     * @return the expression clause for the expression used in the
     *                    {@link RecipientList} to decide the destinations
     */
    public ExpressionClause<ProcessorType<Type>> recipientList() {
        RecipientListType answer = new RecipientListType();
        addOutput(answer);
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        answer.setExpression(clause);
        return clause;
    }
    /**
     * Creates a <a
     * href=""http://activemq.apache.org/camel/routing-slip.html"">Routing
     * Slip</a> pattern.
     *
     * @param header is the header that the {@link org.apache.camel.processor.RoutingSlip RoutingSlip}
     * class will look in for the list of URIs to route the message to.
     * @param uriDelimiter is the delimiter that will be used to split up
     * the list of URIs in the routing slip.
     */
    public Type routingSlip(String header, String uriDelimiter) {
        RoutingSlipType answer = new RoutingSlipType(header, uriDelimiter);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates a <a
     * href=""http://activemq.apache.org/camel/routing-slip.html"">Routing
     * Slip</a> pattern.
     *
     * @param header is the header that the {@link org.apache.camel.processor.RoutingSlip RoutingSlip}
     * class will look in for the list of URIs to route the message to. The list of URIs
     * will be split based on the default delimiter
     * {@link RoutingSlipType#DEFAULT_DELIMITER}.
     */
    public Type routingSlip(String header) {
        RoutingSlipType answer = new RoutingSlipType(header);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates a <a
     * href=""http://activemq.apache.org/camel/routing-slip.html"">Routing
     * Slip</a> pattern with the default header {@link RoutingSlipType#ROUTING_SLIP_HEADER}.
     * The list of URIs in the header will be split based on the default delimiter
     * {@link RoutingSlipType#DEFAULT_DELIMITER}.
     */
    public Type routingSlip() {
        RoutingSlipType answer = new RoutingSlipType();
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param receipients the expression on which to split
     * @return the builder
     */
    public SplitterType splitter(Expression receipients) {
        SplitterType answer = new SplitterType(receipients);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter() {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param partsExpression the expression on which to split
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @return the builder
     */
    public SplitterType splitter(Expression partsExpression, AggregationStrategy aggregationStrategy) {
        SplitterType answer = new SplitterType(partsExpression);
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(AggregationStrategy aggregationStrategy) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param receipients the expression on which to split
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the builder
     */
    public SplitterType splitter(Expression receipients, boolean parallelProcessing) {
        SplitterType answer = new SplitterType(receipients);
        addOutput(answer);
        answer.setParallelProcessing(parallelProcessing);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * This splitter responds with the latest message returned from destination
     * endpoint.
     *
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(boolean parallelProcessing) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setParallelProcessing(parallelProcessing);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param partsExpression the expression on which to split
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the builder
     */
    public SplitterType splitter(Expression partsExpression,
            AggregationStrategy aggregationStrategy, boolean parallelProcessing) {
        SplitterType answer = new SplitterType(partsExpression);
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * Answer from the splitter is produced using given {@link AggregationStrategy}
     * @param aggregationStrategy the strategy used to aggregate responses for
     *          every part
     * @param parallelProcessing if is <tt>true</tt> camel will fork thread to call the endpoint producer
     * @return the expression clause for the expression on which to split
     */
    public ExpressionClause<SplitterType> splitter(AggregationStrategy aggregationStrategy, boolean parallelProcessing) {
        SplitterType answer = new SplitterType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(parallelProcessing);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     *
     * @return the expression clause for the expressions on which to compare messages in order
     */
    public ExpressionClause<ResequencerType> resequencer() {
        ResequencerType answer = new ResequencerType();
        addOutput(answer);
        ExpressionClause<ResequencerType> clause = new ExpressionClause<ResequencerType>(answer);
        answer.expression(clause);
        return clause;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where an expression is evaluated to be able to compare the
     * message exchanges to reorder them. e.g. you may wish to sort by some
     * header
     *
     * @param expression the expression on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(Expression<Exchange> expression) {
        return resequencer(Collections.<Expression>singletonList(expression));
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     *
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(List<Expression> expressions) {
        ResequencerType answer = new ResequencerType(expressions);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     *
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(Expression... expressions) {
        List<Expression> list = new ArrayList<Expression>();
        list.addAll(Arrays.asList(expressions));
        return resequencer(list);
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     */
    public ExpressionClause<AggregatorType> aggregator() {
        AggregatorType answer = new AggregatorType();
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     *
     * @param aggregationStrategy the strategy used for the aggregation
     */
    public ExpressionClause<AggregatorType> aggregator(AggregationStrategy aggregationStrategy) {
        AggregatorType answer = new AggregatorType();
        answer.setAggregationStrategy(aggregationStrategy);
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern using a custom aggregation collection implementation.
     *
     * @param aggregationCollection the collection used to perform the aggregation
     */
    public ExpressionClause<AggregatorType> aggregator(AggregationCollection aggregationCollection) {
        AggregatorType answer = new AggregatorType();
        answer.setAggregationCollection(aggregationCollection);
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     *
     * @param correlationExpression the expression used to calculate the
     *                              correlation key. For a JMS message this could be the
     *                              expression <code>header(""JMSDestination"")</code> or
     *                              <code>header(""JMSCorrelationID"")</code>
     */
    public AggregatorType aggregator(Expression correlationExpression) {
        AggregatorType answer = new AggregatorType(correlationExpression);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates an <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of {@link AggregationStrategy}
     * (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges.
     * <p/>
     * A good example of this is stock market data; you may be receiving 30,000
     * messages/second and you may want to throttle it right down so that multiple
     * messages for the same stock are combined (or just the latest message is used
     * and older prices are discarded). Another idea is to combine line item messages
     * together into a single invoice message.
     *
     * @param correlationExpression the expression used to calculate the
     *                              correlation key. For a JMS message this could be the
     *                              expression <code>header(""JMSDestination"")</code> or
     *                              <code>header(""JMSCorrelationID"")</code>
     */
    public AggregatorType aggregator(Expression correlationExpression, AggregationStrategy aggregationStrategy) {
        AggregatorType answer = new AggregatorType(correlationExpression, aggregationStrategy);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     *
     * @param processAtExpression an expression to calculate the time at which
     *                            the messages should be processed
     * @return the builder
     */
    public DelayerType delayer(Expression<Exchange> processAtExpression) {
        return delayer(processAtExpression, 0L);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     *
     * @param processAtExpression an expression to calculate the time at which
     *                            the messages should be processed
     * @param delay               the delay in milliseconds which is added to the
     *                            processAtExpression to determine the time the message
     *                            should be processed
     * @return the builder
     */
    public DelayerType delayer(Expression<Exchange> processAtExpression, long delay) {
        DelayerType answer = new DelayerType(processAtExpression, delay);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     * @return the expression clause to create the expression
     */
    public ExpressionClause<DelayerType> delayer() {
        DelayerType answer = new DelayerType();
        addOutput(answer);
        return ExpressionClause.createAndSetExpression(answer);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where a fixed amount of milliseconds are used to delay processing of a
     * message exchange
     *
     * @param delay the default delay in milliseconds
     * @return the builder
     */
    public DelayerType delayer(long delay) {
        return delayer(null, delay);
    }
    /**
     * Creates the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     *
     * @return the builder
     */
    public ThrottlerType throttler(long maximumRequestCount) {
        ThrottlerType answer = new ThrottlerType(maximumRequestCount);
        addOutput(answer);
        return answer;
    }
    public Type throwFault(Throwable fault) {
        ThrowFaultType answer = new ThrowFaultType();
        answer.setFault(fault);
        addOutput(answer);
        return (Type) this;
    }
    public Type throwFault(String message) {
        return throwFault(new CamelException(message));
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public Type interceptor(String ref) {
        InterceptorRef interceptor = new InterceptorRef(ref);
        intercept(interceptor);
        return (Type) this;
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public Type intercept(DelegateProcessor interceptor) {
        intercept(new InterceptorRef(interceptor));
        //lastInterceptor = interceptor;
        return (Type) this;
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public InterceptType intercept() {
        InterceptType answer = new InterceptType();
        addOutput(answer);
        return answer;
    }
    /**
     * Intercepts outputs added to this node in the future (i.e. intercepts outputs added after this statement)
     */
    public void intercept(InterceptorType interceptor) {
        addOutput(interceptor);
        pushBlock(interceptor);
    }
    /**
     * Adds an interceptor around the whole of this nodes processing
     *
     * @param interceptor
     */
    public void addInterceptor(InterceptorType interceptor) {
        interceptors.add(interceptor);
    }
    /**
     * Adds an interceptor around the whole of this nodes processing
     *
     * @param interceptor
     */
    public void addInterceptor(DelegateProcessor interceptor) {
        addInterceptor(new InterceptorRef(interceptor));
    }
    protected void pushBlock(Block block) {
        blocks.add(block);
    }
    protected Block popBlock() {
        return blocks.isEmpty() ? null : blocks.removeLast();
    }
    public Type proceed() {
        ProceedType proceed = null;
        ProcessorType currentProcessor = this;
        if (currentProcessor instanceof InterceptType) {
            proceed = ((InterceptType) currentProcessor).getProceed();
            LOG.info(""proceed() is the implied and hence not needed for an intercept()"");
        }
        if (proceed == null) {
            for (ProcessorType node = parent; node != null; node = node.getParent()) {
                if (node instanceof InterceptType) {
                    InterceptType intercept = (InterceptType)node;
                    proceed = intercept.getProceed();
                    break;
                }
            }
            if (proceed == null) {
                throw new IllegalArgumentException(""Cannot use proceed() without being within an intercept() block"");
            }
        }
        addOutput(proceed);
        return (Type) this;
    }
    public Type stop() {
        ProcessorType currentProcessor = this;
        if (currentProcessor instanceof InterceptType) {
            ((InterceptType) currentProcessor).stopIntercept();
        } else {
            ProcessorType node;
            for (node = parent; node != null; node = node.getParent()) {
                if (node instanceof InterceptType) {
                    ((InterceptType) node).stopIntercept();
                    break;
                }
            }
            if (node == null) {
                throw new IllegalArgumentException(""Cannot use stop() without being within an intercept() block"");
            }
        }
        return (Type) this;
    }
    public ExceptionType exception(Class exceptionType) {
        ExceptionType answer = new ExceptionType(exceptionType);
        addOutput(answer);
        return answer;
    }
    /**
     * Apply an interceptor route if the predicate is true
     */
    public ChoiceType intercept(Predicate predicate) {
        InterceptType answer = new InterceptType();
        addOutput(answer);
        return answer.when(predicate);
    }
    public Type interceptors(String... refs) {
        for (String ref : refs) {
            interceptor(ref);
        }
        return (Type) this;
    }
    /**
     * Trace logs the exchange before it goes to the next processing step using
     * the {@link #DEFAULT_TRACE_CATEGORY} logging category.
     */
    public Type trace() {
        return trace(DEFAULT_TRACE_CATEGORY);
    }
    /**
     * Trace logs the exchange before it goes to the next processing step using
     * the specified logging category.
     *
     * @param category the logging category trace messages will sent to.
     */
    public Type trace(String category) {
        final Log log = LogFactory.getLog(category);
        return intercept(new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                log.trace(exchange);
                processNext(exchange);
            }
        });
    }
    public PolicyRef policies() {
        PolicyRef answer = new PolicyRef();
        addOutput(answer);
        return answer;
    }
    public PolicyRef policy(Policy policy) {
        PolicyRef answer = new PolicyRef(policy);
        addOutput(answer);
        return answer;
    }
    /**
     * Forces handling of faults as exceptions
     *
     * @return the current builder with the fault handler configured
     */
    public Type handleFault() {
        intercept(new HandleFaultType());
        return (Type) this;
    }
    /**
     * Installs the given error handler builder
     *
     * @param errorHandlerBuilder the error handler to be used by default for
     *                            all child routes
     * @return the current builder with the error handler configured
     */
    public Type errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return (Type) this;
    }
    /**
     * Configures whether or not the error handler is inherited by every
     * processing node (or just the top most one)
     *
     * @param condition the flag as to whether error handlers should be
     *                  inherited or not
     * @return the current builder
     */
    public Type inheritErrorHandler(boolean condition) {
        setInheritErrorHandlerFlag(condition);
        return (Type) this;
    }
    // Transformers
    // -------------------------------------------------------------------------
    /**
     * Adds the custom processor to this destination which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type process(Processor processor) {
        ProcessorRef answer = new ProcessorRef(processor);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds the custom processor reference to this destination which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type processRef(String ref) {
        ProcessorRef answer = new ProcessorRef();
        answer.setRef(ref);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type bean(Object bean) {
        BeanRef answer = new BeanRef();
        answer.setBean(bean);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type bean(Object bean, String method) {
        BeanRef answer = new BeanRef();
        answer.setBean(bean);
        answer.setMethod(method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean by type which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type bean(Class beanType) {
        BeanRef answer = new BeanRef();
        answer.setBeanType(beanType);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean type and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type bean(Class beanType, String method) {
        BeanRef answer = new BeanRef();
        answer.setBeanType(beanType);
        answer.setMethod(method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type beanRef(String ref) {
        BeanRef answer = new BeanRef(ref);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type beanRef(String ref, String method) {
        BeanRef answer = new BeanRef(ref, method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the body on the IN message
     */
    public ExpressionClause<ProcessorType<Type>> setBody() {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        SetBodyType answer = new SetBodyType(clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which sets the body on the IN message
     */
    public Type setBody(Expression expression) {
        SetBodyType answer = new SetBodyType(expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the body on the OUT message
     *
     * @deprecated Please use {@link #transform(Expression)} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public Type setOutBody(Expression expression) {
        return transform(expression);
    }
    /**
     * Adds a processor which sets the body on the OUT message
     *
     * @deprecated Please use {@link #transform()} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public ExpressionClause<ProcessorType<Type>> setOutBody() {
        return transform();
    }
    /**
     * Adds a processor which sets the body on the OUT message
     */
    public Type transform(Expression expression) {
        TransformType answer = new TransformType(expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the body on the OUT message
     */
    public ExpressionClause<ProcessorType<Type>> transform() {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        TransformType answer = new TransformType(clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which sets the body on the FAULT message
     */
    public Type setFaultBody(Expression expression) {
        return process(ProcessorBuilder.setFaultBody(expression));
    }
    /**
     * Adds a processor which sets the header on the IN message
     */
    public ExpressionClause<ProcessorType<Type>> setHeader(String name) {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        SetHeaderType answer = new SetHeaderType(name, clause);
        addOutput(answer);
        return clause;
    }
    /**
     * Adds a processor which sets the header on the IN message
     */
    public Type setHeader(String name, Expression expression) {
        SetHeaderType answer = new SetHeaderType(name, expression);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the header on the IN message to the given value
     */
    public Type setHeader(String name, String value) {
        SetHeaderType answer = new SetHeaderType(name, value);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the header on the OUT message
     */
    public ExpressionClause<ProcessorType<Type>> setOutHeader(String name) {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        process(ProcessorBuilder.setOutHeader(name, clause));
        return clause;
    }
    /**
     * Adds a processor which sets the header on the OUT message
     */
    public Type setOutHeader(String name, Expression expression) {
        return process(ProcessorBuilder.setOutHeader(name, expression));
    }
    /**
     * Adds a processor which sets the header on the OUT message
     */
    public Type setOutHeader(String name, String value) {
        return (Type) setOutHeader(name).constant(value);
    }
    /**
     * Adds a processor which sets the header on the FAULT message
     */
    public Type setFaultHeader(String name, Expression expression) {
        return process(ProcessorBuilder.setFaultHeader(name, expression));
    }
    /**
     * Adds a processor which sets the exchange property
     */
    public Type setProperty(String name, Expression expression) {
        return process(ProcessorBuilder.setProperty(name, expression));
    }
    /**
     * Adds a processor which sets the exchange property
     */
    public ExpressionClause<ProcessorType<Type>> setProperty(String name) {
        ExpressionClause<ProcessorType<Type>> clause = new ExpressionClause<ProcessorType<Type>>((Type) this);
        process(ProcessorBuilder.setProperty(name, clause));
        return clause;
    }
    /**
     * Adds a processor which removes the header on the IN message
     */
    public Type removeHeader(String name) {
        return process(ProcessorBuilder.removeHeader(name));
    }
    /**
     * Adds a processor which removes the header on the OUT message
     */
    public Type removeOutHeader(String name) {
        return process(ProcessorBuilder.removeOutHeader(name));
    }
    /**
     * Adds a processor which removes the header on the FAULT message
     */
    public Type removeFaultHeader(String name) {
        return process(ProcessorBuilder.removeFaultHeader(name));
    }
    /**
     * Adds a processor which removes the exchange property
     */
    public Type removeProperty(String name) {
        return process(ProcessorBuilder.removeProperty(name));
    }
    /**
     * Converts the IN message body to the specified type
     */
    public Type convertBodyTo(Class type) {
        addOutput(new ConvertBodyType(type));
        return (Type) this;
    }
    /**
     * Converts the OUT message body to the specified type
     *
     * @deprecated Please use {@link #convertBodyTo(Class)} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public Type convertOutBodyTo(Class type) {
        return process(new ConvertBodyProcessor(type));
    }
    /**
     * Converts the FAULT message body to the specified type
     *
     * @deprecated Please use {@link #convertBodyTo(Class)} instead. Will be removed in Camel 2.0.
     */
    @Deprecated
    public Type convertFaultBodyTo(Class type) {
        return process(new ConvertBodyProcessor(type));
    }
    // DataFormat support
    // -------------------------------------------------------------------------
    /**
     * Unmarshals the in body using a {@link DataFormat} expression to define
     * the format of the input message and the output will be set on the out message body.
     *
     * @return the expression to create the {@link DataFormat}
     */
    public DataFormatClause<ProcessorType<Type>> unmarshal() {
        return new DataFormatClause<ProcessorType<Type>>(this, DataFormatClause.Operation.Unmarshal);
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(DataFormatType dataFormatType) {
        addOutput(new UnmarshalType(dataFormatType));
        return (Type) this;
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(DataFormat dataFormat) {
        return unmarshal(new DataFormatType(dataFormat));
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * reference in the {@link Registry} and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(String dataTypeRef) {
        addOutput(new UnmarshalType(dataTypeRef));
        return (Type) this;
    }
    /**
     * Marshals the in body using a {@link DataFormat} expression to define
     * the format of the output which will be added to the out body.
     *
     * @return the expression to create the {@link DataFormat}
     */
    public DataFormatClause<ProcessorType<Type>> marshal() {
        return new DataFormatClause<ProcessorType<Type>>(this, DataFormatClause.Operation.Marshal);
    }
    /**
     * Marshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(DataFormatType dataFormatType) {
        addOutput(new MarshalType(dataFormatType));
        return (Type) this;
    }
    /**
     * Marshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(DataFormat dataFormat) {
        return marshal(new DataFormatType(dataFormat));
    }
    /**
     * Marshals the in body the specified {@link DataFormat}
     * reference in the {@link Registry} and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(String dataTypeRef) {
        addOutput(new MarshalType(dataTypeRef));
        return (Type) this;
    }
    // Properties
    // -------------------------------------------------------------------------
    @XmlTransient
    public ProcessorType<? extends ProcessorType> getParent() {
        return parent;
    }
    public void setParent(ProcessorType<? extends ProcessorType> parent) {
        this.parent = parent;
    }
    @XmlTransient
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        if (errorHandlerBuilder == null) {
            errorHandlerBuilder = createErrorHandlerBuilder();
        }
        return errorHandlerBuilder;
    }
    /**
     * Sets the error handler to use with processors created by this builder
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    /**
     * Sets the error handler if one is not already set
     */
    protected void setErrorHandlerBuilderIfNull(ErrorHandlerBuilder errorHandlerBuilder) {
        if (this.errorHandlerBuilder == null) {
            setErrorHandlerBuilder(errorHandlerBuilder);
        }
    }
    public String getErrorHandlerRef() {
        return errorHandlerRef;
    }
    /**
     * Sets the bean ref name of the error handler builder to use on this route
     */
    @XmlAttribute(required = false)
    public void setErrorHandlerRef(String errorHandlerRef) {
        this.errorHandlerRef = errorHandlerRef;
        setErrorHandlerBuilder(new ErrorHandlerBuilderRef(errorHandlerRef));
    }
    @XmlTransient
    public boolean isInheritErrorHandler() {
        return isInheritErrorHandler(getInheritErrorHandlerFlag());
    }
    /**
     * Lets default the inherit value to be true if there is none specified
     */
    public static boolean isInheritErrorHandler(Boolean value) {
        return value == null || value.booleanValue();
    }
    @XmlAttribute(name = ""inheritErrorHandler"", required = false)
    public Boolean getInheritErrorHandlerFlag() {
        return inheritErrorHandlerFlag;
    }
    public void setInheritErrorHandlerFlag(Boolean inheritErrorHandlerFlag) {
        this.inheritErrorHandlerFlag = inheritErrorHandlerFlag;
    }
    @XmlTransient
    public NodeFactory getNodeFactory() {
        if (nodeFactory == null) {
            nodeFactory = new NodeFactory();
        }
        return nodeFactory;
    }
    public void setNodeFactory(NodeFactory nodeFactory) {
        this.nodeFactory = nodeFactory;
    }
    /**
     * Returns a label to describe this node such as the expression if some kind of expression node
     */
    public String getLabel() {
        return """";
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Creates the processor and wraps it in any necessary interceptors and
     * error handlers
     */
    protected Processor makeProcessor(RouteContext routeContext) throws Exception {
        Processor processor = createProcessor(routeContext);
        return wrapProcessor(routeContext, processor);
    }
    /**
     * A strategy method which allows derived classes to wrap the child
     * processor in some kind of interceptor
     *
     * @param routeContext
     * @param target       the processor which can be wrapped
     * @return the original processor or a new wrapped interceptor
     */
    protected Processor wrapProcessorInInterceptors(RouteContext routeContext, Processor target) throws Exception {
        // The target is required.
        if (target == null) {
            throw new RuntimeCamelException(""target not provided."");
        }
        List<InterceptStrategy> strategies = new ArrayList<InterceptStrategy>();
        CamelContext camelContext = routeContext.getCamelContext();
        if (camelContext instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) camelContext;
            strategies.addAll(defaultCamelContext.getInterceptStrategies());
        }
        strategies.addAll(routeContext.getInterceptStrategies());
        for (InterceptStrategy strategy : strategies) {
            if (strategy != null) {
                target = strategy.wrapProcessorInInterceptors(this, target);
            }
        }
        List<InterceptorType> list = routeContext.getRoute().getInterceptors();
        if (interceptors != null) {
            list.addAll(interceptors);
        }
        // lets reverse the list so we apply the inner interceptors first
        Collections.reverse(list);
        Set<Processor> interceptors = new HashSet<Processor>();
        interceptors.add(target);
        for (InterceptorType interceptorType : list) {
            DelegateProcessor interceptor = interceptorType.createInterceptor(routeContext);
            if (!interceptors.contains(interceptor)) {
                interceptors.add(interceptor);
                if (interceptor.getProcessor() != null) {
                    LOG.warn(""Interceptor "" + interceptor + "" currently wraps target ""
                            + interceptor.getProcessor()
                            + "" is attempting to change target "" + target
                            + "" new wrapping has been denied."");
                } else {
                    interceptor.setProcessor(target);
                    target = interceptor;
                }
            }
        }
        return target;
    }
    /**
     * A strategy method to allow newly created processors to be wrapped in an
     * error handler.
     */
    protected Processor wrapInErrorHandler(RouteContext routeContext, Processor target) throws Exception {
        // The target is required.
        if (target == null) {
            throw new RuntimeCamelException(""target not provided."");
        }
        ErrorHandlerWrappingStrategy strategy = routeContext.getErrorHandlerWrappingStrategy();
        if (strategy != null) {
            return strategy.wrapProcessorInErrorHandler(routeContext, this, target);
        }
        return getErrorHandlerBuilder().createErrorHandler(routeContext, target);
    }
    protected ErrorHandlerBuilder createErrorHandlerBuilder() {
        if (errorHandlerRef != null) {
            return new ErrorHandlerBuilderRef(errorHandlerRef);
        }
        if (isInheritErrorHandler()) {
            return new DeadLetterChannelBuilder();
        } else {
            return new NoErrorHandlerBuilder();
        }
    }
    protected void configureChild(ProcessorType output) {
        output.setNodeFactory(getNodeFactory());
    }
    public void addOutput(ProcessorType processorType) {
        processorType.setParent(this);
        configureChild(processorType);
        if (blocks.isEmpty()) {
            getOutputs().add(processorType);
        } else {
            Block block = blocks.getLast();
            block.addOutput(processorType);
        }
    }
    /**
     * Creates a new instance of some kind of composite processor which defaults
     * to using a {@link Pipeline} but derived classes could change the
     * behaviour
     */
    protected Processor createCompositeProcessor(List<Processor> list) {
        // return new MulticastProcessor(list);
        return new Pipeline(list);
    }
    protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorType<?>> outputs)
        throws Exception {
        List<Processor> list = new ArrayList<Processor>();
        for (ProcessorType output : outputs) {
            Processor processor = output.createProcessor(routeContext);
            processor = output.wrapProcessorInInterceptors(routeContext, processor);
            ProcessorType currentProcessor = this;
            if (!(currentProcessor instanceof ExceptionType || currentProcessor instanceof TryType)) {
                processor = output.wrapInErrorHandler(routeContext, processor);
            }
            list.add(processor);
        }
        Processor processor = null;
        if (!list.isEmpty()) {
            if (list.size() == 1) {
                processor = list.get(0);
            } else {
                processor = createCompositeProcessor(list);
            }
        }
        return processor;
    }
    public void clearOutput() {
        getOutputs().clear();
        blocks.clear();
    }
}
"
org.apache.camel.model.RecipientListType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;recipientList/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""recipientList"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RecipientListType extends ExpressionNode {
    public RecipientListType() {
    }
    public RecipientListType(ExpressionType expression) {
        super(expression);
    }
    public RecipientListType(Expression expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""RecipientList[ "" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""recipientList"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return new RecipientList(getExpression().createExpression(routeContext));
    }
}
"
org.apache.camel.model.RedeliveryPolicyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.RedeliveryPolicy;
/**
 * Represents an XML &lt;redeliveryPolicy/&gt; element
 *
 * @version $Revision: 664624 $
 */
@XmlRootElement(name = ""redeliveryPolicy"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RedeliveryPolicyType {
    private Integer maximumRedeliveries;
    private Long initialRedeliveryDelay;
    private Double backOffMultiplier;
    private Boolean useExponentialBackOff;
    private Double collisionAvoidanceFactor;
    private Boolean useCollisionAvoidance;
    public RedeliveryPolicy createRedeliveryPolicy(RedeliveryPolicy parentPolicy) {
        RedeliveryPolicy answer =  parentPolicy.copy();
        // copy across the properties - if they are set
        if (maximumRedeliveries != null) {
            answer.setMaximumRedeliveries(maximumRedeliveries);
        }
        if (initialRedeliveryDelay != null) {
            answer.setInitialRedeliveryDelay(initialRedeliveryDelay);
        }
        if (backOffMultiplier != null) {
            answer.setBackOffMultiplier(backOffMultiplier);
        }
        if (useExponentialBackOff != null) {
            answer.setUseExponentialBackOff(useExponentialBackOff);
        }
        if (collisionAvoidanceFactor != null) {
            answer.setCollisionAvoidanceFactor(collisionAvoidanceFactor);
        }
        if (useCollisionAvoidance != null) {
            answer.setUseCollisionAvoidance(useCollisionAvoidance);
        }
        return answer;
    }
    public String toString() {
        return ""RedeliveryPolicy[maxRedeliveries: "" + maximumRedeliveries + ""]"";
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public RedeliveryPolicyType backOffMultiplier(double backOffMultiplier) {
        setBackOffMultiplier(backOffMultiplier);
        return this;
    }
    public RedeliveryPolicyType collisionAvoidancePercent(double collisionAvoidancePercent) {
        setCollisionAvoidanceFactor(collisionAvoidancePercent * 0.01d);
        return this;
    }
    public RedeliveryPolicyType collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        setCollisionAvoidanceFactor(collisionAvoidanceFactor);
        return this;
    }
    public RedeliveryPolicyType initialRedeliveryDelay(long initialRedeliveryDelay) {
        setInitialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public RedeliveryPolicyType maximumRedeliveries(int maximumRedeliveries) {
        setMaximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public RedeliveryPolicyType useCollisionAvoidance() {
        setUseCollisionAvoidance(Boolean.TRUE);
        return this;
    }
    public RedeliveryPolicyType useExponentialBackOff() {
        setUseExponentialBackOff(Boolean.TRUE);
        return this;
    }
    // Properties
    //-------------------------------------------------------------------------
    public Double getBackOffMultiplier() {
        return backOffMultiplier;
    }
    public void setBackOffMultiplier(Double backOffMultiplier) {
        this.backOffMultiplier = backOffMultiplier;
    }
    public Double getCollisionAvoidanceFactor() {
        return collisionAvoidanceFactor;
    }
    public void setCollisionAvoidanceFactor(Double collisionAvoidanceFactor) {
        this.collisionAvoidanceFactor = collisionAvoidanceFactor;
    }
    public Long getInitialRedeliveryDelay() {
        return initialRedeliveryDelay;
    }
    public void setInitialRedeliveryDelay(Long initialRedeliveryDelay) {
        this.initialRedeliveryDelay = initialRedeliveryDelay;
    }
    public Integer getMaximumRedeliveries() {
        return maximumRedeliveries;
    }
    public void setMaximumRedeliveries(Integer maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }
    public Boolean getUseCollisionAvoidance() {
        return useCollisionAvoidance;
    }
    public void setUseCollisionAvoidance(Boolean useCollisionAvoidance) {
        this.useCollisionAvoidance = useCollisionAvoidance;
    }
    public Boolean getUseExponentialBackOff() {
        return useExponentialBackOff;
    }
    public void setUseExponentialBackOff(Boolean useExponentialBackOff) {
        this.useExponentialBackOff = useExponentialBackOff;
    }
}
"
org.apache.camel.model.ResequencerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.model.config.BatchResequencerConfig;
import org.apache.camel.model.config.StreamResequencerConfig;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Resequencer;
import org.apache.camel.processor.StreamResequencer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;resequencer/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""resequencer"")
public class ResequencerType extends ProcessorType<ProcessorType> {
    @XmlElementRef
    private List<ExpressionType> expressions = new ArrayList<ExpressionType>();
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    // Binding annotation at setter
    private BatchResequencerConfig batchConfig;
    // Binding annotation at setter
    private StreamResequencerConfig streamConfig;
    @XmlTransient
    private List<Expression> expressionList;
    public ResequencerType() {
        this(null);
    }
    public ResequencerType(List<Expression> expressions) {
        this.expressionList = expressions;
        this.batch();
    }
    @Override
    public String getShortName() {
        return ""resequencer"";
    }
    /**
     * Configures the stream-based resequencing algorithm using the default
     * configuration.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType stream() {
        return stream(StreamResequencerConfig.getDefault());
    }
    /**
     * Configures the batch-based resequencing algorithm using the default
     * configuration.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType batch() {
        return batch(BatchResequencerConfig.getDefault());
    }
    /**
     * Configures the stream-based resequencing algorithm using the given
     * {@link StreamResequencerConfig}.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType stream(StreamResequencerConfig config) {
        this.streamConfig = config;
        this.batchConfig = null;
        return this;
    }
    /**
     * Configures the batch-based resequencing algorithm using the given
     * {@link BatchResequencerConfig}.
     *
     * @return <code>this</code> instance.
     */
    public ResequencerType batch(BatchResequencerConfig config) {
        this.batchConfig = config;
        this.streamConfig = null;
        return this;
    }
    public ResequencerType expression(ExpressionType expression) {
        expressions.add(expression);
        return this;
    }
    @Override
    public String toString() {
        return ""Resequencer[ "" + getExpressions() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getLabel() {
        return ExpressionType.getLabel(getExpressions());
    }
    public List<ExpressionType> getExpressions() {
        return expressions;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public BatchResequencerConfig getBatchConfig() {
        return batchConfig;
    }
    public BatchResequencerConfig getBatchConfig(BatchResequencerConfig defaultConfig) {
        return batchConfig;
    }
    public StreamResequencerConfig getStreamConfig() {
        return streamConfig;
    }
    @XmlElement(name = ""batch-config"", required = false)
    public void setBatchConfig(BatchResequencerConfig batchConfig) {
        // TODO: find out how to have these two within an <xsd:choice>
        batch(batchConfig);
    }
    @XmlElement(name = ""stream-config"", required = false)
    public void setStreamConfig(StreamResequencerConfig streamConfig) {
        // TODO: find out how to have these two within an <xsd:choice>
        stream(streamConfig);
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        if (batchConfig != null) {
            return createBatchResequencer(routeContext, batchConfig);
        } else {
            // streamConfig should be non-null if batchConfig is null
            return createStreamResequencer(routeContext, streamConfig);
        }
    }
    @Override
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        if (batchConfig != null) {
            routes.add(createBatchResequencerRoute(routeContext));
        } else {
            // StreamResequencer created via createProcessor method
            super.addRoutes(routeContext, routes);
        }
    }
    private Route<? extends Exchange> createBatchResequencerRoute(RouteContext routeContext) throws Exception {
        final Resequencer resequencer = createBatchResequencer(routeContext, batchConfig);
        return new Route(routeContext.getEndpoint(), resequencer) {
            @Override
            public String toString() {
                return ""BatchResequencerRoute["" + getEndpoint() + "" -> "" + resequencer.getProcessor() + ""]"";
            }
        };
    }
    protected Resequencer createBatchResequencer(RouteContext routeContext,
            BatchResequencerConfig config) throws Exception {
        Processor processor = routeContext.createProcessor(this);
        Resequencer resequencer = new Resequencer(routeContext.getEndpoint(),
                processor, resolveExpressionList(routeContext));
        resequencer.setBatchSize(config.getBatchSize());
        resequencer.setBatchTimeout(config.getBatchTimeout());
        return resequencer;
    }
    protected StreamResequencer createStreamResequencer(RouteContext routeContext,
            StreamResequencerConfig config) throws Exception {
        config.getComparator().setExpressions(resolveExpressionList(routeContext));
        Processor processor = routeContext.createProcessor(this);
        StreamResequencer resequencer = new StreamResequencer(processor,
                config.getComparator(), config.getCapacity());
        resequencer.setTimeout(config.getTimeout());
        return resequencer;
    }
    private List<Expression> resolveExpressionList(RouteContext routeContext) {
        if (expressionList == null) {
            expressionList = new ArrayList<Expression>();
            for (ExpressionType expression : expressions) {
                expressionList.add(expression.createExpression(routeContext));
            }
        }
        if (expressionList.isEmpty()) {
            throw new IllegalArgumentException(""No expressions configured for: "" + this);
        }
        return expressionList;
    }
}
"
org.apache.camel.model.RouteBuilderRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;routeBuilderRef/&gt; element
 *
 * @version $Revision: 660266 $
 */
@XmlRootElement(name = ""routeBuilderRef"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RouteBuilderRef extends IdentifiedType {
    @XmlAttribute(required = true)
    private String ref;
    public RouteBuilderRef() {
    }
    public RouteBuilderRef(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        return ""RouteBuilderRef["" + getRef() + ""]"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public RouteBuilder createRouteBuilder(CamelContext camelContext) {
        ObjectHelper.notNull(camelContext, ""camelContext"");
        ObjectHelper.notNull(ref, ""ref"");
        RouteBuilder builder = CamelContextHelper.lookup(camelContext, ref, RouteBuilder.class);
        return builder != null ? builder : CamelContextHelper.newInstance(camelContext, RouteBuilder.class);
    }
}
"
org.apache.camel.model.RouteContainer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import javax.xml.bind.annotation.XmlElementRef;
/**
 * Container to hold {@link org.apache.camel.model.RouteType Route}.
 *
 * @version $Revision: 660266 $
 */
public interface RouteContainer {
    /**
     * Returns the routes
     */
    @XmlElementRef
    List<RouteType> getRoutes();
    /**
     * Sets the routes to use
     */
    void setRoutes(List<RouteType> routes);
}
"
org.apache.camel.model.RoutesType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.processor.DelegateProcessor;
/**
 * Represents a collection of routes
 *
 * @version $Revision: 673837 $
 */
@XmlRootElement(name = ""routes"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RoutesType extends OptionalIdentifiedType<RoutesType> implements RouteContainer {
    // TODO: not sure how else to use an optional attribute in JAXB2
    @XmlAttribute
    private Boolean inheritErrorHandlerFlag;
    @XmlElementRef
    private List<RouteType> routes = new ArrayList<RouteType>();
    @XmlElementRef
    private List<ServiceActivationType> activations = new ArrayList<ServiceActivationType>();
    @XmlTransient
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlTransient
    private List<InterceptType> intercepts = new ArrayList<InterceptType>();
    @XmlTransient
    private List<ExceptionType> exceptions = new ArrayList<ExceptionType>();
    @XmlTransient
    private CamelContext camelContext;
    @XmlTransient
    private ErrorHandlerBuilder errorHandlerBuilder;
    @Override
    public String toString() {
        return ""Routes: "" + routes;
    }
    // Properties
    //-----------------------------------------------------------------------
    public List<RouteType> getRoutes() {
        return routes;
    }
    public void setRoutes(List<RouteType> routes) {
        this.routes = routes;
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<InterceptType> getIntercepts() {
        return intercepts;
    }
    public void setIntercepts(List<InterceptType> intercepts) {
        this.intercepts = intercepts;
    }
    public List<ExceptionType> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<ExceptionType> exceptions) {
        this.exceptions = exceptions;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public boolean isInheritErrorHandler() {
        return ProcessorType.isInheritErrorHandler(getInheritErrorHandlerFlag());
    }
    public Boolean getInheritErrorHandlerFlag() {
        return inheritErrorHandlerFlag;
    }
    public void setInheritErrorHandlerFlag(Boolean inheritErrorHandlerFlag) {
        this.inheritErrorHandlerFlag = inheritErrorHandlerFlag;
    }
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        return errorHandlerBuilder;
    }
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    // Fluent API
    //-------------------------------------------------------------------------
    /**
     * Creates a new route
     */
    public RouteType route() {
        RouteType route = createRoute();
        return route(route);
    }
    /**
     * Creates a new route from the given URI input
     */
    public RouteType from(String uri) {
        RouteType route = createRoute();
        route.from(uri);
        return route(route);
    }
    /**
     * Creates a new route from the given endpoint
     */
    public RouteType from(Endpoint endpoint) {
        RouteType route = createRoute();
        route.from(endpoint);
        return route(route);
    }
    public RouteType route(RouteType route) {
        // lets configure the route
        route.setCamelContext(getCamelContext());
        route.setInheritErrorHandlerFlag(getInheritErrorHandlerFlag());
        List<InterceptorType> list = getInterceptors();
        for (InterceptorType interceptorType : list) {
            route.addInterceptor(interceptorType);
        }
        List<InterceptType> intercepts = getIntercepts();
        for (InterceptType intercept : intercepts) {
            // need to create a proxy for this one and use the
            // proceed of the proxy which will be local to this route
            InterceptType proxy = intercept.createProxy();
            route.addOutput(proxy);
            route.pushBlock(proxy.getProceed());
        }
        route.getOutputs().addAll(getExceptions());
        getRoutes().add(route);
        return route;
    }
    public RoutesType intercept(DelegateProcessor interceptor) {
        getInterceptors().add(new InterceptorRef(interceptor));
        return this;
    }
    public InterceptType intercept() {
        InterceptType answer = new InterceptType();
        getIntercepts().add(answer);
        return answer;
    }
    public ChoiceType intercept(Predicate predicate) {
        InterceptType answer = new InterceptType();
        getIntercepts().add(answer);
        return answer.when(predicate);
    }
    public ExceptionType exception(Class exceptionType) {
        ExceptionType answer = new ExceptionType(exceptionType);
        getExceptions().add(answer);
        return answer;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected RouteType createRoute() {
        RouteType route = new RouteType();
        ErrorHandlerBuilder handler = getErrorHandlerBuilder();
        if (isInheritErrorHandler() && handler != null) {
            route.setErrorHandlerBuilderIfNull(handler);
        }
        return route;
    }
}
"
org.apache.camel.model.RouteType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Route;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultRouteContext;
import org.apache.camel.processor.interceptor.StreamCachingInterceptor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CamelContextHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents an XML &lt;route/&gt; element
 *
 * @version $Revision: 674383 $
 */
@XmlRootElement(name = ""route"")
@XmlType(propOrder = {""inputs"", ""outputs"" })
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RouteType extends ProcessorType<ProcessorType> implements CamelContextAware {
    private static final transient Log LOG = LogFactory.getLog(RouteType.class);
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    private List<FromType> inputs = new ArrayList<FromType>();
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    private String group;
    private CamelContext camelContext;
    private Boolean streamCaching;
    public RouteType() {
    }
    public RouteType(String uri) {
        from(uri);
    }
    public RouteType(Endpoint endpoint) {
        from(endpoint);
    }
    @Override
    public String toString() {
        return ""Route[ "" + inputs + "" -> "" + outputs + ""]"";
    }
    public void addRoutes(CamelContext context, Collection<Route> routes) throws Exception {
        setCamelContext(context);
        if (context instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
            ErrorHandlerBuilder handler = defaultCamelContext.getErrorHandlerBuilder();
            if (handler != null) {
                setErrorHandlerBuilderIfNull(handler);
            }
        }
        for (FromType fromType : inputs) {
            addRoutes(routes, fromType);
        }
    }
    public Endpoint resolveEndpoint(String uri) throws NoSuchEndpointException {
        CamelContext context = getCamelContext();
        if (context == null) {
            throw new IllegalArgumentException(""No CamelContext has been injected!"");
        }
        return CamelContextHelper.getMandatoryEndpoint(context, uri);
    }
    // Fluent API
    // -----------------------------------------------------------------------
    /**
     * Creates an input to the route
     */
    public RouteType from(String uri) {
        getInputs().add(new FromType(uri));
        return this;
    }
    /**
     * Creates an input to the route
     */
    public RouteType from(Endpoint endpoint) {
        getInputs().add(new FromType(endpoint));
        return this;
    }
    /**
     * Set the group name for this route
     */
    public RouteType group(String name) {
        setGroup(name);
        return this;
    }
    // Properties
    // -----------------------------------------------------------------------
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    @XmlTransient
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<FromType> getInputs() {
        return inputs;
    }
    @XmlElementRef
    public void setInputs(List<FromType> inputs) {
        this.inputs = inputs;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    @XmlElementRef
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
        // TODO I don't think this is called when using JAXB!
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                configureChild(output);
            }
        }
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    @XmlTransient
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    /**
     * The group that this route belongs to; could be the name of the RouteBuilder class
     * or be explicitly configured in the XML.
     *
     * May be null.
     */
    public String getGroup() {
        return group;
    }
    @XmlAttribute
    public void setGroup(String group) {
        this.group = group;
    }
    public Boolean getStreamCaching() {
        return streamCaching;
    }
    /**
     * Enable stream caching on this route
     * @param streamCaching <code>true</code> for enabling stream caching
     */
    @XmlAttribute(required = false)
    public void setStreamCaching(Boolean streamCaching) {
        this.streamCaching = streamCaching;
        if (streamCaching != null && streamCaching) {
            streamCaching();
        } else {
            noStreamCaching();
        }
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void addRoutes(Collection<Route> routes, FromType fromType) throws Exception {
        RouteContext routeContext = new DefaultRouteContext(this, fromType, routes);
        routeContext.getEndpoint(); // force endpoint resolution
        if (camelContext != null) {
            camelContext.getLifecycleStrategy().onRouteContextCreate(routeContext);
        }
        List<ProcessorType<?>> list = new ArrayList<ProcessorType<?>>(outputs);
        for (ProcessorType output : list) {
            output.addRoutes(routeContext, routes);
        }
        routeContext.commit();
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
        List<InterceptorType> interceptors = getInterceptors();
        for (InterceptorType interceptor : interceptors) {
            output.addInterceptor(interceptor);
        }
/*
        List<InterceptorType> list = output.getInterceptors();
        if (list == null) {
            LOG.warn(""No interceptor collection: "" + output);
        } else {
            list.addAll(getInterceptors());
        }
*/
    }
    /**
     * Disable stream caching for this Route.
     */
    public RouteType noStreamCaching() {
        StreamCachingInterceptor.noStreamCaching(interceptors);
        return this;
    }
    /**
     * Enable stream caching for this Route.
     */
    public RouteType streamCaching() {
        addInterceptor(new StreamCachingInterceptor());
        return this;
    }
    @Override
    public void addInterceptor(InterceptorType interceptor) {
        getInterceptors().add(interceptor);
    }
}
"
org.apache.camel.model.RoutingSlipType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.processor.RoutingSlip;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;routingSlip/&gt; element
 */
@XmlRootElement(name = ""routingSlip"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RoutingSlipType extends ProcessorType<ProcessorType> {
    public static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    public static final String DEFAULT_DELIMITER = "","";
    @XmlAttribute
    private String headerName;
    @XmlAttribute
    private String uriDelimiter;
    public RoutingSlipType() {
        this(ROUTING_SLIP_HEADER, DEFAULT_DELIMITER);
    }
    public RoutingSlipType(String headerName) {
        this(headerName, DEFAULT_DELIMITER);
    }
    public RoutingSlipType(String headerName, String uriDelimiter) {
        setHeaderName(headerName);
        setUriDelimiter(uriDelimiter);
    }
    @Override
    public String toString() {
        return ""RoutingSlip[ headerName="" + getHeaderName() + "" uriDelimiter="" + getUriDelimiter() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""routingSlip"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return new RoutingSlip(getHeaderName(), getUriDelimiter());
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }
    public void setHeaderName(String headerName) {
        this.headerName = headerName;
    }
    public String getHeaderName() {
        return this.headerName;
    }
    public void setUriDelimiter(String uriDelimiter) {
        this.uriDelimiter = uriDelimiter;
    }
    public String getUriDelimiter() {
        return uriDelimiter;
    }
}
"
org.apache.camel.model.ServiceActivationType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.language.ExpressionType;
/**
 * Represents an XML &lt;serviceActivation/&gt; element
 * 
 * @version $Revision: 660266 $
 */
@XmlRootElement(name = ""serviceActivation"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ServiceActivationType {
    @XmlAttribute
    private String group = ""default"";
    @XmlElementRef
    private List<ExpressionType> uris = new ArrayList<ExpressionType>();
    public String getGroup() {
        return group;
    }
    public void setGroup(String group) {
        this.group = group;
    }
    public List<ExpressionType> getUris() {
        return uris;
    }
    public void setUris(List<ExpressionType> uris) {
        this.uris = uris;
    }
}
"
org.apache.camel.model.SetBodyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;setBody/&gt; element.
 */
@XmlRootElement(name = ""setBody"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SetBodyType extends ExpressionNode {
    public SetBodyType() {
    }
    public SetBodyType(Expression expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""SetBody[ "" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""setBody"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Expression expr = getExpression().createExpression(routeContext);
        return ProcessorBuilder.setBody(expr);
    }
}
"
org.apache.camel.model.SetHeaderType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.SetHeaderProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;setHeader/&gt; element
 */
@XmlRootElement(name = ""setHeader"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SetHeaderType extends ExpressionNode {
    @XmlAttribute
    private String headerName;
    @XmlAttribute(required = false)
    private String value;
    public SetHeaderType() {
    }
    public SetHeaderType(String headerName, ExpressionType expression) {
        super(expression);
        setHeaderName(headerName);
    }
    public SetHeaderType(String headerName, Expression expression) {
        super(expression);
        setHeaderName(headerName);        
    }
    public SetHeaderType(String headerName, String value) {
        super(ExpressionBuilder.constantExpression(value));
        setHeaderName(headerName);        
    }   
    @Override
    public String toString() {
        return ""SetHeader[ "" + getHeaderName() + "", "" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""setHeader"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Expression expr;
        if (getValue() == null) {
            expr = getExpression().createExpression(routeContext);
        } else {
            expr = ExpressionBuilder.constantExpression(getValue());
        }
        Processor childProcessor = routeContext.createProcessor(this);
        return new SetHeaderProcessor(getHeaderName(), expr, childProcessor);
    }
    public void setHeaderName(String headerName) {
        this.headerName = headerName;
    }
    public String getHeaderName() {
        return headerName;
    }
    public void setValue(String value) {
        this.value = value;
    }
    public String getValue() {
        return value;
    }
}
"
org.apache.camel.model.SplitterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Splitter;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;splitter/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""splitter"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SplitterType extends ExpressionNode {
    @XmlTransient
    private AggregationStrategy aggregationStrategy;
    @XmlAttribute(required = false)
    private Boolean parallelProcessing;
    @XmlTransient
    private ThreadPoolExecutor threadPoolExecutor;
    public SplitterType() {
    }
    public SplitterType(Expression expression) {
        super(expression);
    }
    public SplitterType(ExpressionType expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""Splitter[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""splitter"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        if (aggregationStrategy == null) {
            aggregationStrategy = new UseLatestAggregationStrategy();
        }
        if (threadPoolExecutor == null) {
            threadPoolExecutor = new ThreadPoolExecutor(4, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
        }
        return new Splitter(getExpression().createExpression(routeContext), childProcessor, aggregationStrategy,
                isParallelProcessing(), threadPoolExecutor);
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;
    }
    public boolean isParallelProcessing() {
        return parallelProcessing != null ? parallelProcessing : false;
    }
    public void setParallelProcessing(boolean parallelProcessing) {
        this.parallelProcessing = parallelProcessing;
    }
    public ThreadPoolExecutor getThreadPoolExecutor() {
        return threadPoolExecutor;
    }
    public void setThreadPoolExecutor(ThreadPoolExecutor threadPoolExecutor) {
        this.threadPoolExecutor = threadPoolExecutor;
    }
}
"
org.apache.camel.model.ThreadType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.ThreadProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;thread/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""thread"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThreadType extends ProcessorType<ProcessorType> {
    @XmlAttribute(required = false)
    private Integer coreSize = 1;
    @XmlAttribute(required = false)
    private Boolean daemon = Boolean.TRUE;
    @XmlAttribute(required = false)
    private Long keepAliveTime;
    @XmlAttribute(required = false)
    private Integer maxSize = 1;
    @XmlAttribute(required = false)
    private String name = ""Thread Processor"";
    @XmlAttribute(required = false)
    private Integer priority = Thread.NORM_PRIORITY;
    @XmlAttribute(required = false)
    private Long stackSize;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private BlockingQueue<Runnable> taskQueue;
    @XmlTransient
    private ThreadGroup threadGroup;
    @XmlTransient
    private ThreadPoolExecutor executor;
    public ThreadType() {
    }
    public ThreadType(int coreSize) {
        this.coreSize = coreSize;
        this.maxSize = coreSize;
    }
    public ThreadType(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    @Override
    public String toString() {
        return ""Thread["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""thread"";
    }
    @Override
    public String getLabel() {
        return ""coreSize="" + coreSize;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        ThreadProcessor thread = new ThreadProcessor();
        thread.setExecutor(executor);
        if (coreSize != null) {
            thread.setCoreSize(coreSize);
        }
        if (daemon != null) {
            thread.setDaemon(daemon);
        }
        if (keepAliveTime != null) {
            thread.setKeepAliveTime(keepAliveTime);
        }
        if (maxSize != null) {
            thread.setMaxSize(maxSize);
        }
        thread.setName(name);
        thread.setPriority(priority);
        if (stackSize != null) {
            thread.setStackSize(stackSize);
        }
        thread.setTaskQueue(taskQueue);
        thread.setThreadGroup(threadGroup);
        // TODO: see if we can avoid creating so many nested pipelines
        ArrayList<Processor> pipe = new ArrayList<Processor>(2);
        pipe.add(thread);
        pipe.add(createOutputsProcessor(routeContext, outputs));
        return new Pipeline(pipe);
    }
    ///////////////////////////////////////////////////////////////////
    //
    // Fluent Methods
    //
    ///////////////////////////////////////////////////////////////////
    public ThreadType coreSize(int coreSize) {
        setCoreSize(coreSize);
        return this;
    }
    public ThreadType daemon(boolean daemon) {
        setDaemon(daemon);
        return this;
    }
    public ThreadType keepAliveTime(long keepAliveTime) {
        setKeepAliveTime(keepAliveTime);
        return this;
    }
    public ThreadType maxSize(int maxSize) {
        setMaxSize(maxSize);
        return this;
    }
    public ThreadType name(String name) {
        setName(name);
        return this;
    }
    public ThreadType priority(int priority) {
        setPriority(priority);
        return this;
    }
    public ThreadType stackSize(long stackSize) {
        setStackSize(stackSize);
        return this;
    }
    public ThreadType taskQueue(BlockingQueue<Runnable> taskQueue) {
        setTaskQueue(taskQueue);
        return this;
    }
    public ThreadType threadGroup(ThreadGroup threadGroup) {
        setThreadGroup(threadGroup);
        return this;
    }
    public ThreadType executor(ThreadPoolExecutor executor) {
        setExecutor(executor);
        return this;
    }
    ///////////////////////////////////////////////////////////////////
    //
    // Property Accessors
    //
    ///////////////////////////////////////////////////////////////////
    public void setCoreSize(int coreSize) {
        this.coreSize = coreSize;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public void setKeepAliveTime(long keepAliveTime) {
        this.keepAliveTime = keepAliveTime;
    }
    public void setMaxSize(int maxSize) {
        this.maxSize = maxSize;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public void setStackSize(long stackSize) {
        this.stackSize = stackSize;
    }
    public void setTaskQueue(BlockingQueue<Runnable> taskQueue) {
        this.taskQueue = taskQueue;
    }
    public void setThreadGroup(ThreadGroup threadGroup) {
        this.threadGroup = threadGroup;
    }
    public ThreadPoolExecutor getExecutor() {
        return executor;
    }
    public void setExecutor(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
}
"
org.apache.camel.model.ThrottlerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.processor.Throttler;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;throttler/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""throttler"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThrottlerType extends ProcessorType<ProcessorType> {
    @XmlAttribute
    private Long maximumRequestsPerPeriod;
    @XmlAttribute
    private long timePeriodMillis = 1000;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public ThrottlerType() {
    }
    public ThrottlerType(long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    @Override
    public String toString() {
        return ""Throttler["" + getMaximumRequestsPerPeriod() + "" request per "" + getTimePeriodMillis()
               + "" millis -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""throttler"";
    }
    @Override
    public String getLabel() {
        return """" + getMaximumRequestsPerPeriod() + "" per "" + getTimePeriodMillis() + "" (ms)"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new Throttler(childProcessor, maximumRequestsPerPeriod, timePeriodMillis);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Sets the time period during which the maximum request count is valid for
     */
    public ThrottlerType timePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public Long getMaximumRequestsPerPeriod() {
        return maximumRequestsPerPeriod;
    }
    public void setMaximumRequestsPerPeriod(Long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    public long getTimePeriodMillis() {
        return timePeriodMillis;
    }
    public void setTimePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
}
"
org.apache.camel.model.ThrowFaultType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelException;
import org.apache.camel.Processor;
import org.apache.camel.processor.ThrowFaultProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;throwFault/&gt; element
 */
@XmlRootElement(name = ""throwFault"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThrowFaultType extends ProcessorType<ThrowFaultType> {
    @XmlTransient
    private Throwable fault;
    @XmlTransient
    private Processor processor;
    @XmlAttribute (required = true)
    private String faultRef;
    public ThrowFaultType() {
    }
    @Override
    public String getShortName() {
        return ""throwFault"";
    }
    public void setFault(Throwable fault) {
        this.fault = fault;
    }
    public Throwable getFault() {
        return fault;
    }
    public void setFaultRef(String ref) {
        this.faultRef = ref;
    }
    public String getFaultRef() {
        return faultRef;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        if (processor == null) {
            if (fault == null) {
                fault = routeContext.lookup(faultRef, Throwable.class);
                if (fault == null) {
                    // can't find the fault instance, create a new one
                    fault = new CamelException(faultRef);
                }
            }
            processor = new ThrowFaultProcessor(fault);
        }
        return processor;
    }
    @Override
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }
}
"
org.apache.camel.model.ToType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents an XML &lt;to/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""to"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ToType extends ProcessorType<ProcessorType> {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String ref;
    @XmlTransient
    private Endpoint endpoint;
    public ToType() {
    }
    public ToType(String uri) {
        setUri(uri);
    }
    public ToType(Endpoint endpoint) {
        setEndpoint(endpoint);
    }
    @Override
    public String toString() {
        return ""To["" + getLabel() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""to"";
    }
    @Override
    public String getLabel() {
        return FromType.description(getUri(), getRef(), getEndpoint());
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Endpoint endpoint = resolveEndpoint(routeContext);
        return new SendProcessor(endpoint);
    }
    public Endpoint resolveEndpoint(RouteContext context) {
        if (endpoint == null) {
            endpoint = context.resolveEndpoint(getUri(), getRef());
        }
        return endpoint;
    }
    // Properties
    // -----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI of the endpoint to use
     *
     * @param uri the endpoint URI to use
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    public String getRef() {
        return ref;
    }
    /**
     * Sets the name of the endpoint within the registry (such as the Spring
     * ApplicationContext or JNDI) to use
     *
     * @param ref the reference name to use
     */
    public void setRef(String ref) {
        this.ref = ref;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public List<ProcessorType<?>> getOutputs() {
        return Collections.EMPTY_LIST;
    }
    /**
     * Returns the endpoint URI or the name of the reference to it
     */
    public Object getUriOrRef() {
        if (ObjectHelper.isNullOrBlank(uri)) {
            return uri;
        } else if (endpoint != null) {
            return endpoint.getEndpointUri();
        }
        return ref;
    }
}
"
org.apache.camel.model.TransformType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.TransformProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;transform/&gt; element
 */
@XmlRootElement(name = ""transform"")
@XmlAccessorType(XmlAccessType.FIELD)
public class TransformType extends ExpressionNode {
    public TransformType() {
    }
    public TransformType(Expression expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""Transform[ "" + getExpression() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""transform"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Expression expr = getExpression().createExpression(routeContext);
        Processor childProcessor = routeContext.createProcessor(this);
        return new TransformProcessor(expr, childProcessor);
    }
}
"
org.apache.camel.model.TryType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.processor.TryProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;try/&gt; element
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""try"")
@XmlAccessorType(XmlAccessType.FIELD)
public class TryType extends OutputType<TryType> {
    @XmlTransient
    private List<CatchType> catchClauses;
    @XmlTransient
    private FinallyType finallyClause;
    @XmlTransient
    private boolean initialized;
    @XmlTransient
    private List<ProcessorType<?>> outputsWithoutCatches;
    @Override
    public String toString() {
        return ""Try[ "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""try"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor tryProcessor = createOutputsProcessor(routeContext, getOutputsWithoutCatches());
        Processor finallyProcessor = null;
        if (finallyClause != null) {
            finallyProcessor = finallyClause.createProcessor(routeContext);
        }
        List<CatchProcessor> catchProcessors = new ArrayList<CatchProcessor>();
        if (catchClauses != null) {
            for (CatchType catchClause : catchClauses) {
                catchProcessors.add(catchClause.createProcessor(routeContext));
            }
        }
        return new TryProcessor(tryProcessor, catchProcessors, finallyProcessor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public TryType handle(Class<?> exceptionType) {
        popBlock();
        CatchType answer = new CatchType(exceptionType);
        addOutput(answer);
        pushBlock(answer);
        return this;
    }
    /**
     * @deprecated Use {@link #finallyBlock()} instead, as the name
     * is better. Current name sugests that it handles exception,
     * while it mimics java finally keyword. Will be removed in Camel 2.0.
     */
    @Deprecated
    public TryType handleAll() {
        return finallyBlock();
    }
    public TryType finallyBlock() {
        popBlock();
        FinallyType answer = new FinallyType();
        addOutput(answer);
        pushBlock(answer);
        return this;
    }
    @Override
    public ProcessorType<? extends ProcessorType> end() {
        popBlock();
        return super.end();
    }
    // Properties
    // -------------------------------------------------------------------------
    public List<CatchType> getCatchClauses() {
        if (catchClauses == null) {
            checkInitialized();
        }
        return catchClauses;
    }
    public FinallyType getFinallyClause() {
        if (finallyClause == null) {
            checkInitialized();
        }
        return finallyClause;
    }
    public List<ProcessorType<?>> getOutputsWithoutCatches() {
        if (outputsWithoutCatches == null) {
            checkInitialized();
        }
        return outputsWithoutCatches;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        initialized = false;
        super.setOutputs(outputs);
    }
    @Override
    public void addOutput(ProcessorType output) {
        initialized = false;
        super.addOutput(output);
    }
    /**
     * Checks whether or not this object has been initialized
     */
    protected void checkInitialized() {
        if (!initialized) {
            initialized = true;
            outputsWithoutCatches = new ArrayList<ProcessorType<?>>();
            catchClauses = new ArrayList<CatchType>();
            finallyClause = null;
            for (ProcessorType output : outputs) {
                if (output instanceof CatchType) {
                    catchClauses.add((CatchType)output);
                } else if (output instanceof FinallyType) {
                    if (finallyClause != null) {
                        throw new IllegalArgumentException(""Multiple finally clauses added: "" + finallyClause
                                                           + "" and "" + output);
                    } else {
                        finallyClause = (FinallyType)output;
                    }
                } else {
                    outputsWithoutCatches.add(output);
                }
            }
        }
    }
}
"
org.apache.camel.model.UnmarshalType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.CsvDataFormat;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.StringDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.processor.UnmarshalProcessor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Unmarshals the binary payload using the given {@link DataFormatType}
 *
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""unmarshal"")
@XmlAccessorType(XmlAccessType.FIELD)
public class UnmarshalType extends OutputType<ProcessorType> {
    @XmlAttribute(required = false)
    private String ref;
    // TODO cannot use @XmlElementRef as it doesn't allow optional properties
    // @XmlElementRef
    @XmlElements({
    @XmlElement(required = false, name = ""artixDS"", type = ArtixDSDataFormat.class),
    @XmlElement(required = false, name = ""csv"", type = CsvDataFormat.class),
    @XmlElement(required = false, name = ""jaxb"", type = JaxbDataFormat.class),
    @XmlElement(required = false, name = ""serialization"", type = SerializationDataFormat.class),
    @XmlElement(required = false, name = ""string"", type = StringDataFormat.class),
    @XmlElement(required = false, name = ""xmlBeans"", type = XMLBeansDataFormat.class)}
    )
    private DataFormatType dataFormatType;
    public UnmarshalType() {
    }
    public UnmarshalType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    public UnmarshalType(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        if (dataFormatType != null) {
            return ""Marshal["" + dataFormatType + ""]"";
        } else {
            return ""Marshal[ref:  "" + ref + ""]"";
        }
    }
    @Override
    public String getShortName() {
        return ""unmarshal"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public DataFormatType getDataFormatType() {
        return dataFormatType;
    }
    public void setDataFormatType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        DataFormat dataFormat = DataFormatType.getDataFormat(routeContext, getDataFormatType(), ref);
        return new UnmarshalProcessor(dataFormat);
    }
}
"
org.apache.camel.model.WhenType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;when/&gt; element
 * 
 * @version $Revision: 671918 $
 */
@XmlRootElement(name = ""when"")
public class WhenType<Type extends ProcessorType> extends ExpressionNode {
    public WhenType() {
    }
    public WhenType(Predicate predicate) {
        super(predicate);
    }
    public WhenType(ExpressionType expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""When[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getShortName() {
        return ""when"";
    }
    @Override
    public FilterProcessor createProcessor(RouteContext routeContext) throws Exception {
        return createFilterProcessor(routeContext);
    }
}
"
org.apache.camel.model.XmlParseTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import javax.xml.bind.JAXBException;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy;
/**
 * @version $Revision: 664441 $
 */
public class XmlParseTest extends XmlTestSupport {
    public void testParseSimpleRouteXml() throws Exception {
        RouteType route = assertOneRoute(""simpleRoute.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(""to"", route, ""seda:b"");
    }
    public void testParseProcessorXml() throws Exception {
        RouteType route = assertOneRoute(""processor.xml"");
        assertFrom(route, ""seda:a"");
        assertProcessor(route, ""myProcessor"");
    }
    public void testParseProcessorWithFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""juel"", ""in.header.foo == 'bar'"");
    }
    public void testParseProcessorWithHeaderFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithHeaderFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""header"", ""foo"");
    }
    public void testParseProcessorWithElFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithElFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""el"", ""$in.header.foo == 'bar'"");
    }
    public void testParseProcessorWithGroovyFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithGroovyFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""groovy"", ""in.headers.any { h -> h.startsWith('foo')}"");
    }
    public void testParseRecipientListXml() throws Exception {
        RouteType route = assertOneRoute(""dynamicRecipientList.xml"");
        assertFrom(route, ""seda:a"");
        RecipientListType node = assertRecipientList(route);
        assertExpression(node.getExpression(), ""header"", ""foo"");
    }
    public void testParseStaticRecipientListXml() throws Exception {
        RouteType route = assertOneRoute(""staticRecipientList.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(route, ""seda:b"", ""seda:c"", ""seda:d"");
    }
    public void testParseTransformXml() throws Exception {
        RouteType route = assertOneRoute(""transform.xml"");
        assertFrom(route, ""direct:start"");
        TransformType node = assertTransform(route);
        assertExpression(node.getExpression(), ""simple"", ""${in.body} extra data!"");
        assertChildTo(route, ""mock:end"", 1);
    }    
    public void testParseSetBodyXml() throws Exception {
        RouteType route = assertOneRoute(""setBody.xml"");
        assertFrom(route, ""direct:start"");
        SetBodyType node = assertSetBody(route);
        assertExpression(node.getExpression(), ""simple"", ""${in.body} extra data!"");
        assertChildTo(route, ""mock:end"", 1);
    }        
    public void testParseSetHeaderXml() throws Exception {
        RouteType route = assertOneRoute(""setHeader.xml"");
        assertFrom(route, ""seda:a"");
        SetHeaderType node = assertSetHeader(route);
        assertEquals(""oldBodyValue"", node.getHeaderName());
        assertExpression(node.getExpression(), ""simple"", ""body"");
        assertChildTo(route, ""mock:b"", 1);
    }   
    public void testParseSetHeaderWithChildProcessorXml() throws Exception {
        RouteType route = assertOneRoute(""setHeaderWithChildProcessor.xml"");
        assertFrom(route, ""seda:a"");
        SetHeaderType node = assertSetHeader(route);
        assertEquals(""oldBodyValue"", node.getHeaderName());
        assertExpression(node.getExpression(), ""simple"", ""body"");
        assertChildTo(node, ""mock:b"");
    }
    public void testParseSetHeaderToConstantXml() throws Exception {
        RouteType route = assertOneRoute(""setHeaderToConstant.xml"");
        assertFrom(route, ""seda:a"");
        SetHeaderType node = assertSetHeader(route);
        assertEquals(""theHeader"", node.getHeaderName());
        assertEquals(""a value"", node.getValue());
        assertEquals("""", node.getExpression().getExpression());
        assertChildTo(route, ""mock:b"", 1);
    }       
    public void testParseConvertBodyXml() throws Exception {
        RouteType route = assertOneRoute(""convertBody.xml"");
        assertFrom(route, ""seda:a"");
        ConvertBodyType node = assertConvertBody(route);
        assertEquals(""java.lang.Integer"", node.getType());
        assertEquals(Integer.class, node.getTypeClass());
    } 
    public void testParseRoutingSlipXml() throws Exception {
        RouteType route = assertOneRoute(""routingSlip.xml"");
        assertFrom(route, ""seda:a"");
        RoutingSlipType node = assertRoutingSlip(route);
        assertEquals(RoutingSlipType.ROUTING_SLIP_HEADER, node.getHeaderName());
        assertEquals(RoutingSlipType.DEFAULT_DELIMITER, node.getUriDelimiter());
    }
    public void testParseRoutingSlipWithHeaderSetXml() throws Exception {
        RouteType route = assertOneRoute(""routingSlipHeaderSet.xml"");
        assertFrom(route, ""seda:a"");
        RoutingSlipType node = assertRoutingSlip(route);
        assertEquals(""theRoutingSlipHeader"", node.getHeaderName());
        assertEquals(RoutingSlipType.DEFAULT_DELIMITER, node.getUriDelimiter());       
    }       
    public void testParseRoutingSlipWithHeaderAndDelimiterSetXml() throws Exception {
        RouteType route = assertOneRoute(""routingSlipHeaderAndDelimiterSet.xml"");
        assertFrom(route, ""seda:a"");
        RoutingSlipType node = assertRoutingSlip(route);
        assertEquals(""theRoutingSlipHeader"", node.getHeaderName());
        assertEquals(""#"", node.getUriDelimiter());       
    }   
    //TODO get the test fixed
    public void xtestParseRouteWithInterceptorXml() throws Exception {
        RouteType route = assertOneRoute(""routeWithInterceptor.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(""to"", route, ""seda:d"");
        assertInterceptorRefs(route, ""interceptor1"", ""interceptor2"");
    }
    public void testParseRouteWithChoiceXml() throws Exception {
        RouteType route = assertOneRoute(""routeWithChoice.xml"");
        assertFrom(route, ""seda:a"");
        ChoiceType choice = assertChoice(route);
        List<WhenType> whens = assertListSize(choice.getWhenClauses(), 2);
        assertChildTo(""when(0)"", whens.get(0), ""seda:b"");
        assertChildTo(""when(1)"", whens.get(1), ""seda:c"");
        OtherwiseType otherwise = choice.getOtherwise();
        assertNotNull(""Otherwise is null"", otherwise);
        assertChildTo(""otherwise"", otherwise, ""seda:d"");
    }
    public void testParseSplitterXml() throws Exception {
        RouteType route = assertOneRoute(""splitter.xml"");
        assertFrom(route, ""seda:a"");
        SplitterType splitter = assertSplitter(route);
        assertExpression(splitter.getExpression(), ""xpath"", ""/foo/bar"");
        assertChildTo(""to"", splitter, ""seda:b"");
    }
    public void testParseLoadBalance() throws Exception {
        RouteType route = assertOneRoute(""routeWithLoadBalance.xml"");
        assertFrom(route, ""seda:a"");
        LoadBalanceType loadBalance = assertLoadBalancer(route);
        assertEquals(""Here should have 3 output here"", 3, loadBalance.getOutputs().size());
        assertTrue(""The loadBalancer shoud be RoundRobinLoadBalanceStrategy"", loadBalance.getLoadBalancerType() instanceof RoundRobinLoadBalanceStrategy);
    }
    public void testParseStickyLoadBalance() throws Exception {
        RouteType route = assertOneRoute(""routeWithStickyLoadBalance.xml"");
        assertFrom(route, ""seda:a"");
        LoadBalanceType loadBalance = assertLoadBalancer(route);
        assertEquals(""Here should have 3 output here"", 3, loadBalance.getOutputs().size());
        assertTrue(""The loadBalancer shoud be StickyLoadBalanceStrategy"", loadBalance.getLoadBalancerType() instanceof StickyLoadBalanceStrategy);
        StickyLoadBalanceStrategy strategy = (StickyLoadBalanceStrategy)loadBalance.getLoadBalancerType();
        assertNotNull(""the expression should not be null "", strategy.getExpressionType());
    }
    public void testParseBatchResequencerXml() throws Exception {
        RouteType route = assertOneRoute(""resequencerBatch.xml"");
        ResequencerType resequencer = assertResequencer(route);
        assertNull(resequencer.getStreamConfig());
        assertNotNull(resequencer.getBatchConfig());
        assertEquals(500, resequencer.getBatchConfig().getBatchSize());
        assertEquals(2000L, resequencer.getBatchConfig().getBatchTimeout());
    }
    public void testParseStreamResequencerXml() throws Exception {
        RouteType route = assertOneRoute(""resequencerStream.xml"");
        ResequencerType resequencer = assertResequencer(route);
        assertNotNull(resequencer.getStreamConfig());
        assertNull(resequencer.getBatchConfig());
        assertEquals(100, resequencer.getStreamConfig().getCapacity());
        assertEquals(2000L, resequencer.getStreamConfig().getTimeout());
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected RouteType assertOneRoute(String uri) throws JAXBException {
        RouteContainer context = assertParseAsJaxb(uri);
        RouteType route = assertOneElement(context.getRoutes());
        return route;
    }
    protected void assertFrom(RouteType route, String uri) {
        FromType from = assertOneElement(route.getInputs());
        assertEquals(""From URI"", uri, from.getUri());
    }
    protected void assertChildTo(String message, ProcessorType<?> route, String uri) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        ToType value = assertIsInstanceOf(ToType.class, processor);
        String text = message + ""To URI"";
        log.info(""Testing: "" + text + "" is equal to: "" + uri + "" for processor: "" + processor);
        assertEquals(text, uri, value.getUri());
    }
    protected void assertTo(String message, ProcessorType processor, String uri) {
        ToType value = assertIsInstanceOf(ToType.class, processor);
        String text = message + ""To URI"";
        log.info(""Testing: "" + text + "" is equal to: "" + uri + "" for processor: "" + processor);
        assertEquals(text, uri, value.getUri());
    }
    protected void assertChildTo(ProcessorType route, String... uris) {
        List<ProcessorType<?>> list = assertListSize(route.getOutputs(), uris.length);
        int idx = 0;
        for (String uri : uris) {
            assertTo(""output["" + idx + ""] "", list.get(idx++), uri);
        }
    }
    protected void assertChildTo(ProcessorType route, String uri, int toIdx) {
        List<ProcessorType<?>> list = route.getOutputs();
        assertTo(""to and idx="" + toIdx, list.get(toIdx), uri);
    }
    protected void assertProcessor(ProcessorType<?> route, String processorRef) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        ProcessorRef to = assertIsInstanceOf(ProcessorRef.class, processor);
        assertEquals(""Processor ref"", processorRef, to.getRef());
    }
    protected FilterType assertFilter(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(FilterType.class, processor);
    }
    protected RecipientListType assertRecipientList(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(RecipientListType.class, processor);
    }
    protected ConvertBodyType assertConvertBody(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(ConvertBodyType.class, processor);
    }   
    protected RoutingSlipType assertRoutingSlip(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(RoutingSlipType.class, processor);
    }   
    protected SetHeaderType assertSetHeader(ProcessorType<?> route) {
        ProcessorType<?> processor = route.getOutputs().get(0);
        return assertIsInstanceOf(SetHeaderType.class, processor);
    }    
    protected TransformType assertTransform(ProcessorType<?> route) {
        ProcessorType<?> processor = route.getOutputs().get(0);
        return assertIsInstanceOf(TransformType.class, processor);
    } 
    protected SetBodyType assertSetBody(ProcessorType<?> route) {
        ProcessorType<?> processor = route.getOutputs().get(0);
        return assertIsInstanceOf(SetBodyType.class, processor);
    }        
    protected ChoiceType assertChoice(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(ChoiceType.class, processor);
    }
    protected SplitterType assertSplitter(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(SplitterType.class, processor);
    }
    protected LoadBalanceType assertLoadBalancer(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(LoadBalanceType.class, processor);
    }
    protected ResequencerType assertResequencer(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(ResequencerType.class, processor);
    }
    protected void assertExpression(ExpressionType expression, String language, String languageExpression) {
        assertNotNull(""Expression should not be null!"", expression);
        assertEquals(""Expression language"", language, expression.getLanguage());
        assertEquals(""Expression"", languageExpression, expression.getExpression());
    }
    protected void assertInterceptorRefs(ProcessorType route, String... names) {
/*
        TODO
        int idx = 0;
        List<InterceptorType> interceptors = route.getInterceptors();
        for (String name : names) {
            int nextIdx = idx + 1;
            assertTrue(""Not enough interceptors! Expected: "" + nextIdx + "" but have: "" + interceptors,
                    nextIdx <= interceptors.size());
            InterceptorRef interceptor = assertIsInstanceOf(InterceptorRef.class, interceptors.get(idx++));
            assertEquals(""Interceptor: "" + idx, name, interceptor.getRef());
        }
*/
    }
}
"
org.apache.camel.model.XmlTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.net.URL;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import org.apache.camel.TestSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public abstract class XmlTestSupport extends TestSupport {
    protected final transient Log log = LogFactory.getLog(getClass());
    protected JAXBContext jaxbContext;
    protected RouteContainer assertParseAsJaxb(String uri) throws JAXBException {
        Object value = parseUri(uri);
        RouteContainer context = assertIsInstanceOf(RouteContainer.class, value);
        log.info(""Found: "" + context);
        return context;
    }
    protected Object parseUri(String uri) throws JAXBException {
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
        URL resource = getClass().getResource(uri);
        assertNotNull(""Cannot find resource on the classpath: "" + uri, resource);
        Object value = unmarshaller.unmarshal(resource);
        return value;
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        jaxbContext = JAXBContext
            .newInstance(""org.apache.camel.model:org.apache.camel.model.config:org.apache.camel.model.dataformat:org.apache.camel.model.language:org.apache.camel.model.loadbalancer"");
    }
}
"
org.apache.camel.model.config.BatchResequencerConfig,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.config;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.Resequencer;
/**
 * Defines the configuration parameters for the batch-processing
 * {@link Resequencer}. Usage example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch(
 *         BatchResequencerConfig.getDefault()).to(&quot;mock:result&quot;)
 * </pre>
 * is equivalent to
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch().to(&quot;mock:result&quot;)
 * </pre>
 * 
 * or
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * Custom values for <code>batchSize</code> and <code>batchTimeout</code>
 * can be set like in this example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch(
 *         new BatchResequencerConfig(300, 400L)).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 630568 $
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class BatchResequencerConfig {
    @XmlAttribute
    private Integer batchSize; // optional XML attribute requires wrapper object 
    @XmlAttribute
    private Long batchTimeout; // optional XML attribute requires wrapper object
    /**
     * Creates a new {@link BatchResequencerConfig} instance using default
     * values for <code>batchSize</code> (100) and <code>batchTimeout</code>
     * (1000L).
     */
    public BatchResequencerConfig() {
        this(100, 1000L);
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>batchSize</code> and <code>batchTimeout</code>.
     * 
     * @param batchSize
     *            size of the batch to be re-ordered.
     * @param batchTimeout
     *            timeout for collecting elements to be re-ordered.
     */
    public BatchResequencerConfig(int batchSize, long batchTimeout) {
        this.batchSize = batchSize;
        this.batchTimeout = batchTimeout;
    }
    /**
     * Returns a new {@link BatchResequencerConfig} instance using default
     * values for <code>batchSize</code> (100) and <code>batchTimeout</code>
     * (1000L).
     * 
     * @return a default {@link BatchResequencerConfig}.
     */
    public static BatchResequencerConfig getDefault() {
        return new BatchResequencerConfig();
    }
    public int getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }
    public long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
}
"
org.apache.camel.model.config.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The Resequencer Configuration classes
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.config;
"
org.apache.camel.model.config.StreamResequencerConfig,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.config;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Exchange;
import org.apache.camel.processor.StreamResequencer;
import org.apache.camel.processor.resequencer.DefaultExchangeComparator;
import org.apache.camel.processor.resequencer.ExpressionResultComparator;
/**
 * Defines the configuration parameters for the {@link StreamResequencer}.
 * Usage example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream(
 *         StreamResequencerConfig.getDefault()).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * is equivalent to
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream().to(&quot;mock:result&quot;)
 * </pre>
 * 
 * Custom values for <code>capacity</code> and <code>timeout</code> can be
 * set like in this example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream(
 *         new StreamResequencerConfig(300, 400L)).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 642753 $
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class StreamResequencerConfig {
    @XmlAttribute
    private Integer capacity; // optional XML attribute requires wrapper object
    @XmlAttribute
    private Long timeout; // optional XML attribute requires wrapper object
    @XmlTransient
    private ExpressionResultComparator<Exchange> comparator;
    /**
     * Creates a new {@link StreamResequencerConfig} instance using default
     * values for <code>capacity</code> (100) and <code>timeout</code>
     * (1000L). Elements of the sequence are compared using the
     * {@link DefaultExchangeComparator}.
     */
    public StreamResequencerConfig() {
        this(100, 1000L);
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>capacity</code> and <code>timeout</code>. Elements
     * of the sequence are compared using the {@link DefaultExchangeComparator}.
     * 
     * @param capacity   capacity of the resequencer's inbound queue.
     * @param timeout    minimum time to wait for missing elements (messages).
     */
    public StreamResequencerConfig(int capacity, long timeout) {
        this(capacity, timeout, new DefaultExchangeComparator());
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>capacity</code> and <code>timeout</code>. Elements
     * of the sequence are compared with the given
     * {@link ExpressionResultComparator}.
     * 
     * @param capacity   capacity of the resequencer's inbound queue.
     * @param timeout    minimum time to wait for missing elements (messages).
     */
    public StreamResequencerConfig(int capacity, long timeout, ExpressionResultComparator<Exchange> comparator) {
        this.capacity = capacity;
        this.timeout = timeout;
        this.comparator = comparator;
    }
    /**
     * Returns a new {@link StreamResequencerConfig} instance using default
     * values for <code>capacity</code> (100) and <code>timeout</code>
     * (1000L). Elements of the sequence are compared using the
     * {@link DefaultExchangeComparator}.
     * 
     * @return a default {@link StreamResequencerConfig}.
     */
    public static StreamResequencerConfig getDefault() {
        return new StreamResequencerConfig();
    }
    public int getCapacity() {
        return capacity;
    }
    public void setCapacity(int capacity) {
        this.capacity = capacity;
    }
    public long getTimeout() {
        return timeout;
    }
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    public ExpressionResultComparator<Exchange> getComparator() {
        return comparator;
    }
    public void setComparator(ExpressionResultComparator<Exchange> comparator) {
        this.comparator = comparator;
    }
}
"
org.apache.camel.model.dataformat.ArtixDSContentType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlEnum;
/**
 * @version $Revision: 640438 $
 */
@XmlEnum(String.class)
public enum ArtixDSContentType {
    Default, Auto, Binary, Text, Java, Xml, Sax, TagValuePair
}
"
org.apache.camel.model.dataformat.ArtixDSDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents the <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
 * {@link DataFormat}
 *
 * @version $Revision: 640438 $
 */
@XmlRootElement(name = ""artixDS"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ArtixDSDataFormat extends DataFormatType {
    private static final transient Log LOG = LogFactory.getLog(ArtixDSDataFormat.class);
    @XmlAttribute(required = false)
    private String elementTypeName;
    @XmlAttribute(required = false)
    private String format;
    @XmlAttribute(required = false)
    private Class<?> elementType;
    @XmlAttribute(required = false)
    private ArtixDSContentType contentType;
    public ArtixDSDataFormat() {
        super(""org.apache.camel.artix.ds.ArtixDSFormat"");
    }
    public ArtixDSDataFormat(Class<?> elementType) {
        this();
        this.elementType = elementType;
    }
    public ArtixDSDataFormat(Class<?> elementType, ArtixDSContentType contentType) {
        this();
        this.elementType = elementType;
        this.contentType = contentType;
    }
    public ArtixDSDataFormat(ArtixDSContentType contentType) {
        this();
        this.contentType = contentType;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getElementTypeName() {
        return elementTypeName;
    }
    public void setElementTypeName(String elementTypeName) {
        this.elementTypeName = elementTypeName;
    }
    public ArtixDSContentType getContentType() {
        return contentType;
    }
    public void setContentType(ArtixDSContentType contentType) {
        this.contentType = contentType;
    }
    public Class<?> getElementType() {
        if (elementType == null) {
            if (elementTypeName != null) {
                elementType = ObjectHelper.loadClass(elementTypeName, getClass().getClassLoader());
                if (elementType == null) {
                    throw new IllegalArgumentException(""The ArtixDS Element class "" + elementTypeName + "" is not on the classpath! Cannot use the dataFormat "" + this);
                }
            }
        }
        return elementType;
    }
    public void setElementType(Class<?> elementType) {
        this.elementType = elementType;
    }
    public String getFormat() {
        return format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void configureDataFormat(DataFormat dataFormat) {
        Class<?> type = getElementType();
        if (type != null) {
            setProperty(dataFormat, ""elementType"", type);
        }
        ArtixDSContentType content = getContentType();
        if (content != null) {
            setProperty(dataFormat, ""contentType"", content);
        }
    }
}
"
org.apache.camel.model.dataformat.CsvDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents a CSV (Comma Separated Values) {@link DataFormat}
 *
 * @version $Revision: 659842 $
 */
@XmlRootElement(name = ""csv"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CsvDataFormat extends DataFormatType {
    public CsvDataFormat() {
        super(""org.apache.camel.dataformat.csv.CsvDataFormat"");
    }
}
"
org.apache.camel.model.dataformat.DataFormatType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.Exchange;
import org.apache.camel.model.IdentifiedType;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Represents the base XML type for DataFormat.
 *
 * @version $Revision: 660266 $
 */
@XmlType(name = ""dataFormatType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class DataFormatType extends IdentifiedType implements DataFormat {
    @XmlTransient
    private DataFormat dataFormat;
    @XmlTransient
    private String dataFormatTypeName;
    public DataFormatType() {
    }
    public DataFormatType(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    protected DataFormatType(String dataFormatTypeName) {
        this.dataFormatTypeName = dataFormatTypeName;
    }
    public static DataFormat getDataFormat(RouteContext routeContext, DataFormatType type, String ref) {
        if (type == null) {
            notNull(ref, ""ref or dataFormatType"");
            DataFormat dataFormat = routeContext.lookup(ref, DataFormat.class);
            if (dataFormat instanceof DataFormatType) {
                type = (DataFormatType)dataFormat;
            } else {
                return dataFormat;
            }
        }
        return type.getDataFormat(routeContext);
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
        ObjectHelper.notNull(dataFormat, ""dataFormat"");
        dataFormat.marshal(exchange, graph, stream);
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
        ObjectHelper.notNull(dataFormat, ""dataFormat"");
        return dataFormat.unmarshal(exchange, stream);
    }
    public DataFormat getDataFormat(RouteContext routeContext) {
        if (dataFormat == null) {
            dataFormat = createDataFormat(routeContext);
            ObjectHelper.notNull(dataFormat, ""dataFormat"");
            configureDataFormat(dataFormat);
        }
        return dataFormat;
    }
    /**
     * Factory method to create the data format instance
     */
    protected DataFormat createDataFormat(RouteContext routeContext) {
        if (dataFormatTypeName != null) {
            Class type = ObjectHelper.loadClass(dataFormatTypeName, getClass().getClassLoader());
            if (type == null) {
                throw new IllegalArgumentException(""The class "" + dataFormatTypeName + "" is not on the classpath! Cannot use the dataFormat "" + this);
            }
            return (DataFormat) ObjectHelper.newInstance(type);
        }
        return null;
    }
    /**
     * Allows derived classes to customize the data format
     */
    protected void configureDataFormat(DataFormat dataFormat) {
    }
    /**
     * Sets a named property on the data format instance using introspection
     */
    protected void setProperty(Object bean, String name, Object value) {
        try {
            IntrospectionSupport.setProperty(bean, name, value);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Failed to set property "" + name + "" on "" + bean
                                               + "". Reason: "" + e, e);
        }
    }
}
"
org.apache.camel.model.dataformat.JaxbDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents the JAXB2 XML {@link DataFormat}
 *
 * @version $Revision: 662969 $
 */
@XmlRootElement(name = ""jaxb"")
@XmlAccessorType(XmlAccessType.FIELD)
public class JaxbDataFormat extends DataFormatType {
    @XmlAttribute(required = true)
    private String contextPath;
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public JaxbDataFormat() {
        super(""org.apache.camel.converter.jaxb.JaxbDataFormat"");
    }
    public JaxbDataFormat(boolean prettyPrint) {
        this();
        setPrettyPrint(prettyPrint);
    }
    public String getContextPath() {
        return contextPath;
    }
    public void setContextPath(String contextPath) {
        this.contextPath = contextPath;
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    @Override
    protected void configureDataFormat(DataFormat dataFormat) {
        Boolean answer = ObjectHelper.toBoolean(getPrettyPrint());
        if (answer != null && answer.booleanValue()) {
            setProperty(dataFormat, ""prettyPrint"", Boolean.TRUE);
        }
        setProperty(dataFormat, ""contextPath"", contextPath);
    }
}
"
org.apache.camel.model.dataformat.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JAXB POJOs for the
 * <a href=""http://activemq.apache.org/camel/data-format.html"">Data Formats</a> used to marshal and unmarshal objects to
 * and from streams inside <a href=""http://activemq.apache.org/camel/components.html"">components</a>
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.dataformat;
"
org.apache.camel.model.dataformat.SerializationDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Represents the Java Serialization {@link DataFormat}
 *
 * @version $Revision: 659007 $
 */
@XmlRootElement(name = ""serialization"")
public class SerializationDataFormat extends DataFormatType {
    @Override
    protected DataFormat createDataFormat(RouteContext routeContext) {
        return new org.apache.camel.impl.SerializationDataFormat();
    }
}
"
org.apache.camel.model.dataformat.StringDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.RouteContext;
/**
 * Represents the String (text based) {@link DataFormat}
 *
 * @version $Revision: 659007 $
 */
@XmlRootElement(name = ""string"")
@XmlAccessorType(XmlAccessType.FIELD)
public class StringDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private String charset;
    @Override
    protected DataFormat createDataFormat(RouteContext routeContext) {
        return new org.apache.camel.impl.StringDataFormat(charset);
    }
    public String getCharset() {
        return charset;
    }
    public void setCharset(String charset) {
        this.charset = charset;
    }
}
"
org.apache.camel.model.dataformat.XMLBeansDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents the XMLBeans XML {@link DataFormat}
 *
 * @version $Revision: 640438 $
 */
@XmlRootElement(name = ""xmlBeans"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XMLBeansDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public XMLBeansDataFormat() {
        super(""org.apache.camel.converter.xmlbeans.XmlBeansDataFormat"");
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
}
"
org.apache.camel.model.dataformat.XStreamDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents the XStream XML {@link DataFormat}
 *
 * @version $Revision: 640438 $
 */
@XmlRootElement(name = ""xstream"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XStreamDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public XStreamDataFormat() {
        super(""org.apache.camel.dataformat.xstream.XStreamDataFormat"");
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
}
"
org.apache.camel.model.language.ELExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For EL expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""el"")
public class ELExpression extends ExpressionType {
    public ELExpression() {
    }
    public ELExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""el"";
    }
}
"
org.apache.camel.model.language.ExpressionType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionClause;
import org.apache.camel.impl.DefaultRouteContext;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
/**
 * A useful base class for an expression
 *
 * @version $Revision: 659007 $
 */
@XmlType(name = ""expressionType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ExpressionType implements Expression<Exchange>, Predicate<Exchange> {
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    @XmlValue
    private String expression;
    @XmlTransient
    private Predicate predicate;
    @XmlTransient
    private Expression expressionValue;
    @XmlTransient
    private ExpressionType expressionType;
    public ExpressionType() {
    }
    public ExpressionType(String expression) {
        this.expression = expression;
    }
    public ExpressionType(Predicate predicate) {
        this.predicate = predicate;
    }
    public ExpressionType(Expression expression) {
        this.expressionValue = expression;
    }
    public static String getLabel(List<ExpressionType> expressions) {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        for (ExpressionType expression : expressions) {
            buffer.append(expression.getLabel());
        }
        return buffer.toString();
    }
    @Override
    public String toString() {
        return getLanguage() + ""Expression["" + getExpression() + ""]"";
    }
    public Object evaluate(Exchange exchange) {
        if (expressionValue == null) {
            RouteContext routeContext = new DefaultRouteContext(exchange.getContext());
            expressionValue = createExpression(routeContext);
        }
        ObjectHelper.notNull(expressionValue, ""expressionValue"");
        return expressionValue.evaluate(exchange);
    }
    public void assertMatches(String text, Exchange exchange) throws AssertionError {
        if (!matches(exchange)) {
            throw new AssertionError(text + getExpression() + "" for exchange: "" + exchange);
        }
    }
    public boolean matches(Exchange exchange) {
        if (predicate == null) {
            RouteContext routeContext = new DefaultRouteContext(exchange.getContext());
            predicate = createPredicate(routeContext);
        }
        ObjectHelper.notNull(predicate, ""predicate"");
        return predicate.matches(exchange);
    }
    public String getLanguage() {
        return """";
    }
    public Predicate<Exchange> createPredicate(RouteContext routeContext) {
        if (predicate == null) {
            if (expressionType != null) {
                predicate = expressionType.createPredicate(routeContext);
            } else {
                CamelContext camelContext = routeContext.getCamelContext();
                Language language = camelContext.resolveLanguage(getLanguage());
                predicate = language.createPredicate(getExpression());
                configurePredicate(routeContext, predicate);
            }
        }
        return predicate;
    }
    public Expression createExpression(RouteContext routeContext) {
        if (expressionValue == null) {
            if (expressionType != null) {
                expressionValue = expressionType.createExpression(routeContext);
            } else {
                CamelContext camelContext = routeContext.getCamelContext();
                Language language = camelContext.resolveLanguage(getLanguage());
                expressionValue = language.createExpression(getExpression());
                configureExpression(routeContext, expressionValue);
            }
        }
        return expressionValue;
    }
    public String getExpression() {
        return expression;
    }
    public void setExpression(String expression) {
        this.expression = expression;
    }
    /**
     * Gets the value of the id property.
     *
     * @return possible object is
     *         {@link String }
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setId(String value) {
        this.id = value;
    }
    public Predicate getPredicate() {
        return predicate;
    }
    public Expression getExpressionValue() {
        return expressionValue;
    }
    protected void setExpressionValue(Expression expressionValue) {
        this.expressionValue = expressionValue;
    }
    /**
     * Returns some descriptive text to describe this node
     */
    public String getLabel() {
        String language = getExpression();
        if (ObjectHelper.isNullOrBlank(language)) {
            Predicate predicate = getPredicate();
            if (predicate != null) {
                return predicate.toString();
            }
            Expression expressionValue = getExpressionValue();
            if (expressionValue != null) {
                return expressionValue.toString();
            }
        } else {
            return language;
        }
        return """";
    }
    /**
     * Allows derived classes to set a lazily created expressionType instance
     * such as if using the {@link ExpressionClause}
     */
    protected void setExpressionType(ExpressionType expressionType) {
        this.expressionType = expressionType;
    }
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
    }
    protected void configureExpression(RouteContext routeContext, Expression expression) {
    }
    /**
     * Sets a named property on the object instance using introspection
     */
    protected void setProperty(Object bean, String name, Object value) {
        try {
            IntrospectionSupport.setProperty(bean, name, value);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Failed to set property "" + name + "" on "" + bean
                                               + "". Reason: "" + e, e);
        }
    }
}
"
org.apache.camel.model.language.GroovyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Groovy expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""groovy"")
public class GroovyExpression extends ExpressionType {
    public GroovyExpression() {
    }
    public GroovyExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""groovy"";
    }
}
"
org.apache.camel.model.language.HeaderExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * An expression which extracts the named header
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""header"")
public class HeaderExpression extends ExpressionType {
    public HeaderExpression() {
    }
    public HeaderExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""header"";
    }
}
"
org.apache.camel.model.language.JavaScriptExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For JavaScript expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""javaScript"")
public class JavaScriptExpression extends ExpressionType {
    public JavaScriptExpression() {
    }
    public JavaScriptExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""js"";
    }
}
"
org.apache.camel.model.language.JXPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For <a href=""http://commons.apache.org/jxpath/"">JXPath</a> expresions and predicates
 *
 * @version $Revision: 638977 $
 */
@XmlRootElement(name = ""jxpath"")
public class JXPathExpression extends ExpressionType {
    public JXPathExpression() {
    }
    public JXPathExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""jxpath"";
    }
}
"
org.apache.camel.model.language.LanguageExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * Represents a parameterised language expression which can support any language
 * at runtime using the language attribute.
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""expression"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LanguageExpression extends ExpressionType {
    @XmlAttribute
    private String language;
    public LanguageExpression() {
    }
    public LanguageExpression(String language, String expression) {
        setLanguage(language);
        setExpression(expression);
    }
    public String getLanguage() {
        return language;
    }
    public void setLanguage(String language) {
        this.language = language;
    }
}
"
org.apache.camel.model.language.MethodCallExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.language.bean.BeanExpression;
import org.apache.camel.spi.RouteContext;
/**
 * For expresions and predicates using the
 * <a href=""http://activemq.apache.org/camel/bean-language.html"">bean language</a>
 *
 * @version $Revision: 659197 $
 */
@XmlRootElement(name = ""methodCall"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MethodCallExpression extends ExpressionType {
    @XmlAttribute(required = false)
    private String bean;
    @XmlAttribute(required = false)
    private String method;
    public MethodCallExpression() {
    }
    public MethodCallExpression(String beanName) {
        super(beanName);
    }
    public MethodCallExpression(String beanName, String method) {
        super(beanName);
        this.method = method;
    }
    public String getLanguage() {
        return ""bean"";
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    @Override
    public Expression createExpression(RouteContext routeContext) {
        return new BeanExpression(beanName(), getMethod());
    }
    @Override
    public Predicate<Exchange> createPredicate(RouteContext routeContext) {
        return new BeanExpression<Exchange>(beanName(), getMethod());
    }
    protected String beanName() {
        if (bean != null) {
            return bean;
        }
        return getExpression();
    }
}
"
org.apache.camel.model.language.NamespaceAwareExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.spi.RouteContext;
/**
 * A useful base class for any expression which may be namespace or XML content aware
 * such as {@link XPathExpression} or {@link XQueryExpression}
 *
 * @version $Revision: 659007 $
 */
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class NamespaceAwareExpression extends ExpressionType implements NamespaceAware {
    @XmlTransient
    private Map<String, String> namespaces;
    public NamespaceAwareExpression() {
    }
    public NamespaceAwareExpression(String expression) {
        super(expression);
    }
    public Map<String, String> getNamespaces() {
        return namespaces;
    }
    /**
     * Injects the XML Namespaces of prefix -> uri mappings
     *
     * @param namespaces the XML namespaces with the key of prefixes and the value the URIs
     */
    public void setNamespaces(Map<String, String> namespaces) {
        this.namespaces = namespaces;
    }
    @Override
    protected void configureExpression(RouteContext routeContext, Expression expression) {
        configureNamespaceAware(expression);
    }
    @Override
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
        configureNamespaceAware(predicate);
    }
    protected void configureNamespaceAware(Object builder) {
        if (namespaces != null && builder instanceof NamespaceAware) {
            NamespaceAware namespaceAware = (NamespaceAware) builder;
            namespaceAware.setNamespaces(namespaces);
        }
    }
}
"
org.apache.camel.model.language.OgnlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For OGNL expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""ognl"")
public class OgnlExpression extends ExpressionType {
    public OgnlExpression() {
    }
    public OgnlExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""ognl"";
    }
}
"
org.apache.camel.model.language.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JAXB POJOs for the
 * <a href=""http://activemq.apache.org/camel/expression.html"">Expression</a> and
 * <a href=""http://activemq.apache.org/camel/predicate.html"">Predicate</a> plugins for the
 * <a href=""http://activemq.apache.org/camel/xml-configuration.html"">XML Configuration</a>.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.language;
"
org.apache.camel.model.language.PhpExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For PHP expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""php"")
public class PhpExpression extends ExpressionType {
    public PhpExpression() {
    }
    public PhpExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""php"";
    }
}
"
org.apache.camel.model.language.PythonExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Python expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""python"")
public class PythonExpression extends ExpressionType {
    public PythonExpression() {
    }
    public PythonExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""python"";
    }
}
"
org.apache.camel.model.language.RubyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Ruby expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""ruby"")
public class RubyExpression extends ExpressionType {
    public RubyExpression() {
    }
    public RubyExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""ruby"";
    }
}
"
org.apache.camel.model.language.SimpleExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For expresions and predicates using the
 * <a href=""http://activemq.apache.org/camel/simple.html>simple language</a>
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""simple"")
public class SimpleExpression extends ExpressionType {
    public SimpleExpression() {
    }
    public SimpleExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""simple"";
    }
}
"
org.apache.camel.model.language.SqlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For SQL expresions and predicates
 *
 * @version $Revision: 630591 $
 */
@XmlRootElement(name = ""sql"")
public class SqlExpression extends ExpressionType {
    public SqlExpression() {
    }
    public SqlExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""sql"";
    }
}
"
org.apache.camel.model.language.XPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.RouteContext;
/**
 * For XPath expresions and predicates
 *
 * @version $Revision: 659007 $
 */
@XmlRootElement(name = ""xpath"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XPathExpression extends NamespaceAwareExpression {
    @XmlAttribute(required = false)
    private Class resultType;
    public XPathExpression() {
    }
    public XPathExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""xpath"";
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
    }
    @Override
    protected void configureExpression(RouteContext routeContext, Expression expression) {
        super.configureExpression(routeContext, expression);
        if (resultType != null) {
            setProperty(expression, ""resultType"", resultType);
        }
    }
    @Override
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
        super.configurePredicate(routeContext, predicate);
        if (resultType != null) {
            setProperty(predicate, ""resultType"", resultType);
        }
    }
}
"
org.apache.camel.model.language.XQueryExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.RouteContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * For XQuery expresions and predicates
 *
 * @version $Revision: 659007 $
 */
@XmlRootElement(name = ""xquery"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XQueryExpression extends NamespaceAwareExpression {
    private static final transient Log LOG = LogFactory.getLog(XQueryExpression.class);
    @XmlAttribute(required = false)
    private String type;
    @XmlTransient
    private Class resultType;
    public XQueryExpression() {
    }
    public XQueryExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""xquery"";
    }
    public String getType() {
        return type;
    }
    public void setType(String type) {
        this.type = type;
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
    }
    @Override
    protected void configureExpression(RouteContext routeContext, Expression expression) {
        super.configureExpression(routeContext, expression);
        updateResultType();
        if (resultType != null) {
            setProperty(expression, ""resultType"", resultType);
        }
    }
    @Override
    protected void configurePredicate(RouteContext routeContext, Predicate predicate) {
        super.configurePredicate(routeContext, predicate);
        updateResultType();
        if (resultType != null) {
            setProperty(predicate, ""resultType"", resultType);
        }
    }
    private void updateResultType() {
        if (resultType == null && type != null) {
            try {
                resultType = Class.forName(type);
            } catch (ClassNotFoundException e) {
                LOG.error(""ClassNotFoundException creating class: "" + type);
            }
        }
    }
}
"
org.apache.camel.model.loadbalancer.LoadBalancerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.model.IdentifiedType;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Represents an XML &lt;loadBalance/&gt; element
 */
@XmlType(name = ""loadBalancerType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LoadBalancerType extends IdentifiedType implements LoadBalancer {
    @XmlTransient
    private LoadBalancer loadBalancer;
    @XmlTransient
    private String loadBalancerTypeName;
    public LoadBalancerType() {
    }
    public LoadBalancerType(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    protected LoadBalancerType(String loadBalancerTypeName) {
        this.loadBalancerTypeName = loadBalancerTypeName;
    }
    public static LoadBalancer getLoadBalancer(RouteContext routeContext, LoadBalancerType type, String ref) {
        if (type == null) {
            notNull(ref, ""ref or LoadBalancerType"");
            LoadBalancer loadBalancer = routeContext.lookup(ref, LoadBalancer.class);
            if (loadBalancer instanceof LoadBalancerType) {
                type = (LoadBalancerType) loadBalancer;
            } else {
                return loadBalancer;
            }
        }
        return type.getLoadBalancer(routeContext);
    }
    /**
     * Sets a named property on the data format instance using introspection
     */
    protected void setProperty(Object bean, String name, Object value) {
        try {
            IntrospectionSupport.setProperty(bean, name, value);
        } catch (Exception e) {
            throw new IllegalArgumentException(""Failed to set property "" + name + "" on "" + bean
                                               + "". Reason: "" + e, e);
        }
    }
    /**
     * Allows derived classes to customize the load balancer
     */
    protected void configureLoadBalancer(LoadBalancer loadBalancer) {
    }
    public LoadBalancer getLoadBalancer(RouteContext routeContext) {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer(routeContext);
            ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
            configureLoadBalancer(loadBalancer);
        }
        return loadBalancer;
    }
    /**
     * Factory method to create the load balancer instance
     */
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        if (loadBalancerTypeName != null) {
            Class type = ObjectHelper.loadClass(loadBalancerTypeName, getClass().getClassLoader());
            if (type == null) {
                throw new IllegalArgumentException(""The class "" + loadBalancerTypeName + "" is not on the classpath! Cannot use the loadBalancer "" + this);
            }
            return (LoadBalancer) ObjectHelper.newInstance(type);
        }
        return null;
    }
    public void addProcessor(Processor processor) {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        loadBalancer.addProcessor(processor);
    }
    public List<Processor> getProcessors() {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        return loadBalancer.getProcessors();
    }
    public void removeProcessor(Processor processor) {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        loadBalancer.removeProcessor(processor);
    }
    public void process(Exchange exchange) throws Exception {
        ObjectHelper.notNull(loadBalancer, ""loadBalancer"");
        loadBalancer.process(exchange);
    }
}
"
org.apache.camel.model.loadbalancer.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The LoadBalancer and the LoadBalancerStrategy JAXB Objects
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.loadbalancer;
"
org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;random/&gt; element
 */
@XmlRootElement(name = ""random"")
public class RandomLoadBalanceStrategy extends LoadBalancerType {
    @Override
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        return new org.apache.camel.processor.loadbalancer.RandomLoadBalancer();
    }
}
"
org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;roundRobin/&gt; element
 */
@XmlRootElement(name = ""roundRobin"")
public class RoundRobinLoadBalanceStrategy extends LoadBalancerType {
    @Override
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        return new org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer();
    }
}
"
org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
/**
 * Represents an XML &lt;sticky/&gt; element
 */
@XmlRootElement(name = ""sticky"")
@XmlAccessorType(XmlAccessType.FIELD)
public class StickyLoadBalanceStrategy extends LoadBalancerType {
    @XmlElement(required = true, name = ""expression"", type = ExpressionType.class)
    private ExpressionType expressionType;
    @XmlElement(required = false, name = ""loadBalancer"", type = ExpressionType.class)
    private LoadBalancerType loadBalancerType;
    public StickyLoadBalanceStrategy() {
        super(""org.apache.camel.processor.loadbalancer.StickyLoadBalancer"");
    }
    public StickyLoadBalanceStrategy(ExpressionType expressionType) {
        this();
        this.expressionType = expressionType;
    }
    public StickyLoadBalanceStrategy(ExpressionType expressionType, LoadBalancerType loadBalancerType) {
        this();
        this.expressionType = expressionType;
        this.loadBalancerType = loadBalancerType;
    }
    public void setExpressionType(ExpressionType expressionType) {
        this.expressionType = expressionType;
    }
    public ExpressionType getExpressionType() {
        return expressionType;
    }
    public void setLoadBalancerType(LoadBalancerType loadBalancerType) {
        this.loadBalancerType = loadBalancerType;
    }
    public LoadBalancerType getLoadBalancerType() {
        return loadBalancerType;
    }
    @Override
    protected void configureLoadBalancer(LoadBalancer loadBalancer) {
        ExpressionType expression = getExpressionType();
        if (expression != null) {
            setProperty(loadBalancer, ""correlationExpression"", expression);
        }
        LoadBalancerType type = getLoadBalancerType();
        if (type != null) {
            setProperty(loadBalancer, ""loadBalancer"", type);
        }
    }
    @Override
    public String toString() {
        return ""StickyLoadBalanceStrategy["" + expressionType + "", "" + loadBalancerType + ""]"";
    }
}
"
org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.loadbalancer;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.spi.RouteContext;
/**
 * Represents an XML &lt;topic/&gt; element
 */
@XmlRootElement(name = ""topic"")
public class TopicLoadBalanceStrategy extends LoadBalancerType {
    @Override
    protected LoadBalancer createLoadBalancer(RouteContext routeContext) {
        return new org.apache.camel.processor.loadbalancer.TopicLoadBalancer();
    }
}
"
org.apache.camel.processor.Aggregator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Endpoint;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.PredicateAggregationCollection;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
 * pattern where a batch of messages are processed (up to a maximum amount or
 * until some timeout is reached) and messages for the same correlation key are
 * combined together using some kind of {@link AggregationStrategy}
 * (by default the latest message is used) to compress many message exchanges
 * into a smaller number of exchanges.
 * <p/>
 * A good example of this is stock market data; you may be receiving 30,000
 * messages/second and you may want to throttle it right down so that multiple
 * messages for the same stock are combined (or just the latest message is used
 * and older prices are discarded). Another idea is to combine line item messages
 * together into a single invoice message.
 *
 * @version $Revision: 642753 $
 */
public class Aggregator extends BatchProcessor {
    private Predicate aggregationCompletedPredicate;
    public Aggregator(Endpoint endpoint, Processor processor, Expression correlationExpression,
                      AggregationStrategy aggregationStrategy) {
        this(endpoint, processor, new AggregationCollection(correlationExpression, aggregationStrategy));
    }
    public Aggregator(Endpoint endpoint, Processor processor, Expression correlationExpression,
                      AggregationStrategy aggregationStrategy, Predicate aggregationCompletedPredicate) {
        this(endpoint, processor, new PredicateAggregationCollection(correlationExpression, aggregationStrategy, aggregationCompletedPredicate));
        this.aggregationCompletedPredicate = aggregationCompletedPredicate;
    }
    public Aggregator(Endpoint endpoint, Processor processor, AggregationCollection collection) {
        super(endpoint, processor, collection);
    }
    @Override
    public String toString() {
        return ""Aggregator[to: "" + getProcessor() + ""]"";
    }
    @Override
    protected boolean isBatchCompleted(int index) {
        if (aggregationCompletedPredicate != null) {
            if (getCollection().size() > 0) {
                return true;
            }
        }
        return super.isBatchCompleted(index);
    }
}
"
org.apache.camel.processor.AggregatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class AggregatorTest extends ContextTestSupport {
    protected int messageCount = 100;
    public void testSendingLotsOfMessagesGetAggregatedToTheLatestMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(""message:"" + messageCount);
        // lets send a large batch of messages
        for (int i = 1; i <= messageCount; i++) {
            String body = ""message:"" + i;
            template.sendBodyAndHeader(""direct:start"", body, ""cheese"", 123);
        }
        resultEndpoint.assertIsSatisfied();
    }
    public void testPredicate() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(messageCount / 5);
        // lets send a large batch of messages
        for (int i = 1; i <= messageCount; i++) {
            String body = ""message:"" + i;
            template.sendBodyAndHeader(""direct:predicate"", body, ""cheese"", 123);
        }
        resultEndpoint.assertIsSatisfied();
    }
    public void testOneMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:predicate"", ""test"", ""aggregated"", 5);
        resultEndpoint.assertIsSatisfied();
    }
    public void testBatchTimeoutExpiry() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.setSleepForEmptyTest(2 * BatchProcessor.DEFAULT_BATCH_TIMEOUT);
        template.sendBodyAndHeader(""direct:start"", ""message:1"", ""cheese"", 123);
        resultEndpoint.assertIsSatisfied();
    }
    //TODO fix this test
    public void xtestAggregatorNotAtStart() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.message(0).header(""visited"").isNotNull();
        resultEndpoint.setSleepForEmptyTest(2 * BatchProcessor.DEFAULT_BATCH_TIMEOUT);
        template.sendBodyAndHeader(""seda:header"", ""message:1"", ""cheese"", 123);
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""direct:start"").aggregator(header(""cheese"")).to(""mock:result"");
                from(""seda:header"").setHeader(""visited"", constant(true)).aggregator(header(""cheese"")).to(""mock:result"");
                from(""direct:predicate"").aggregator(header(""cheese""), new MyAggregationStrategy()).
                        completedPredicate(header(""aggregated"").isEqualTo(5)).to(""mock:result"");
                // END SNIPPET: ex
            }
        };
    }
}
"
org.apache.camel.processor.BatchProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import java.util.Iterator;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.LoggingExceptionHandler;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A base class for any kind of {@link Processor} which implements some kind of
 * batch processing.
 * 
 * @version $Revision: 669756 $
 */
public class BatchProcessor extends ServiceSupport implements Runnable, Processor {
    public static final long DEFAULT_BATCH_TIMEOUT = 1000L;
    public static final int DEFAULT_BATCH_SIZE = 100;
    private static final transient Log LOG = LogFactory.getLog(BatchProcessor.class);
    private Endpoint endpoint;
    private Processor processor;
    private Collection<Exchange> collection;
    private long batchTimeout = DEFAULT_BATCH_TIMEOUT;
    private int batchSize = DEFAULT_BATCH_SIZE;
    private PollingConsumer consumer;
    private ExceptionHandler exceptionHandler;
    public BatchProcessor(Endpoint endpoint, Processor processor, Collection<Exchange> collection) {
        this.endpoint = endpoint;
        this.processor = processor;
        this.collection = collection;
    }
    @Override
    public String toString() {
        return ""BatchProcessor[to: "" + processor + ""]"";
    }
    public void run() {
        LOG.debug(""Starting thread for "" + this);
        while (isRunAllowed()) {
            try {
                processBatch();
            } catch (Exception e) {
                getExceptionHandler().handleException(e);
            }
        }
        collection.clear();
    }
    // Properties
    // -------------------------------------------------------------------------
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    public int getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }
    public long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public Processor getProcessor() {
        return processor;
    }
    /**
     * A transactional method to process a batch of messages up to a timeout
     * period or number of messages reached.
     */
    protected synchronized void processBatch() throws Exception {
        long start = System.currentTimeMillis();
        long end = start + batchTimeout;
        for (int i = 0; !isBatchCompleted(i); i++) {
            long timeout = end - System.currentTimeMillis();
            if (timeout < 0L) {                
                LOG.debug(""batch timeout expired at batch index:""  + i);
                break;
            }
            Exchange exchange = consumer.receive(timeout);
            if (exchange == null) {
                LOG.debug(""receive with timeout: "" + timeout + "" expired at batch index:""  + i);
                break;
            }
            collection.add(exchange);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Finished batch size: "" + batchSize + "" timeout: "" + batchTimeout + "" so sending set: ""
                      + collection);
        }
        // lets send the batch
        Iterator<Exchange> iter = collection.iterator();
        while (iter.hasNext()) {
            Exchange exchange = iter.next();
            iter.remove();
            processExchange(exchange);
        }
    }
    /**
     * A strategy method to decide if the batch is completed the resulting exchanges should be sent
     */
    protected boolean isBatchCompleted(int index) {
        return index >= batchSize;
    }
    /**
     * Strategy Method to process an exchange in the batch. This method allows
     * derived classes to perform custom processing before or after an
     * individual exchange is processed
     */
    protected void processExchange(Exchange exchange) throws Exception {
        processor.process(exchange);
    }
    protected void doStart() throws Exception {
        consumer = endpoint.createPollingConsumer();
        ServiceHelper.startServices(processor, consumer);
        Thread thread = new Thread(this, this + "" Polling Thread"");
        thread.start();
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(consumer, processor);
        collection.clear();
    }
    protected Collection<Exchange> getCollection() {
        return collection;
    }
    public void process(Exchange exchange) throws Exception {
        // empty since exchanges come from endpoint's polling consumer
    }
}
"
org.apache.camel.processor.BeanInvocationThrowsExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.builder.RouteBuilder;
/**
 * Unit test for bean invocation that throws an exception
 */
public class BeanInvocationThrowsExceptionTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testBeanInvocation() {
        int result = (Integer) template.sendBody(""direct:input"", ExchangePattern.InOut, ""Hello London"");
        assertEquals(1, result);
    }
    public void testBeanInvocationFailure() {
        // must create an exchange to get the result as an exchange where we can get the caused exception
        Exchange exchange = getMandatoryEndpoint(""direct:input"").createExchange(ExchangePattern.InOut);
        exchange.getIn().setBody(""Hello Paris"");
        Exchange result = template.send(""direct:input"", exchange);
        assertTrue(""Should be failed"", result.isFailed());
        assertTrue(""Should be IllegalArgumentException"", result.getException() instanceof IllegalArgumentException);
        assertEquals(""Forced exception"", result.getException().getMessage());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:input"").bean(new ExceptionBean());
            }
        };
    }
    public static class ExceptionBean {
        public int doSomething(String request) throws Exception {
            if (request.equals(""Hello London"")) {
                return 1;
            } else {
                throw new IllegalArgumentException(""Forced exception"");
            }
        }
    }
    // END SNIPPET: e1
}
"
org.apache.camel.processor.BeanMethodHeartbeatTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * This test shows we can poll a bean for a method and send the POJO over some transport
 *
 * @version $Revision: 630568 $
 */
public class BeanMethodHeartbeatTest extends ContextTestSupport {
    protected MyService bean = new MyService(""Beer"");
    public void testHeartbeatsArrive() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMinimumMessageCount(1);
        resultEndpoint.assertIsSatisfied();
        List<Exchange> list = new ArrayList<Exchange>(resultEndpoint.getReceivedExchanges());
        log.debug(""Received: "" + list);
        Exchange exchange = list.get(0);
        log.debug(""In: "" + exchange.getIn());
        log.debug(""Out: "" + exchange.getOut());
        Map map = assertIsInstanceOf(Map.class, exchange.getIn().getBody());
        log.debug(""Received: "" + map);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""myService"", bean);
        return context;
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""bean:myService?method=status"").to(""mock:result"");
            }
        };
    }
    public static class MyService {
        private String name;
        public MyService(String name) {
            this.name = name;
        }
        public Map status() {
            Map answer = new HashMap();
            answer.put(""name"", name);
            answer.put(""time"", new Date());
            return answer;
        }
    }
}
"
org.apache.camel.processor.BeanRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.atomic.AtomicInteger;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanRouteTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendingMessageWithMethodNameHeader() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, BeanProcessor.METHOD_NAME, ""read"");
        assertEquals(""bean received correct value for: "" + myBean, expectedBody, myBean.body);
    }
    public void testSendingMessageWithMethodNameHeaderWithMoreVerboseCoe() throws Exception {
        final String expectedBody = ""Wibble"";
        template.send(""direct:in"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(expectedBody);
                in.setHeader(BeanProcessor.METHOD_NAME, ""read"");
            }
        });
        assertEquals(""bean received correct value"", expectedBody, myBean.body);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        private static AtomicInteger counter = new AtomicInteger(0);
        public String body;
        private int id;
        public MyBean() {
            id = counter.incrementAndGet();
        }
        @Override
        public String toString() {
            return ""MyBean:"" + id;
        }
        public void read(String body) {
            this.body = body;
            LOG.info(""read() method on "" + this + "" with body: "" + body);
        }
        public void wrongMethod(String body) {
            fail(""wrongMethod() called with: "" + body);
        }
    }
}
"
org.apache.camel.processor.BeanWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Header;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanWithExceptionTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", new ValidationBean());
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").beanRef(""myBean"").to(""mock:valid"");
            }
        };
    }
    public static class ValidationBean {
        private static final transient Log LOG = LogFactory.getLog(ValidationBean.class);
        public void someMethod(String body, @Header(name = ""foo"")
                               String header) throws ValidationException {
            if (""bar"".equals(header)) {
                LOG.info(""someMethod() called with valid header and body: "" + body);
            } else {
                throw new ValidationException(null, ""Invalid header foo: "" + header);
            }
        }
    }
}
"
org.apache.camel.processor.BeanWithXPathInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.language.XPath;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public class BeanWithXPathInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        String expectedBody = ""<env:Envelope xmlns:env='http://www.w3.org/2003/05/soap-envelope'><env:Body>""
                              + ""<foo>bar</foo></env:Body></env:Envelope>"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, expectedBody, myBean.body);
        assertEquals(""bean foo: "" + myBean, ""bar"", myBean.foo);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        public String foo;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" body: "" + body + ""]"";
        }
        public void read(String body, @XPath(""/soap:Envelope/soap:Body/foo/text()"") String foo) {
            this.foo = foo;
            this.body = body;
            LOG.info(""read() method called on "" + this);
        }
    }
}
"
org.apache.camel.processor.CatchProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.Processor;
/**
 * A processor which catches exceptions.
 *
 * @version $Revision: 659760 $
 */
public class CatchProcessor extends DelegateProcessor {
    private List<Class> exceptions;
    public CatchProcessor(List<Class> exceptions, Processor processor) {
        super(processor);
        this.exceptions = exceptions;
    }
    @Override
    public String toString() {
        return ""Catch["" + exceptions + "" -> "" + getProcessor() + ""]"";
    }
    public boolean catches(Throwable e) {
        for (Class type : exceptions) {
            if (type.isInstance(e)) {
                return true;
            }
        }
        return false;
    }
    public List<Class> getExceptions() {
        return exceptions;
    }
}
"
org.apache.camel.processor.ChoiceProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * Implements a Choice structure where one or more predicates are used which if
 * they are true their processors are used, with a default otherwise clause used
 * if none match.
 * 
 * @version $Revision: 674278 $
 */
public class ChoiceProcessor extends ServiceSupport implements Processor {
    private List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
    private Processor otherwise;
    public ChoiceProcessor(List<FilterProcessor> filters, Processor otherwise) {
        this.filters = filters;
        this.otherwise = otherwise;
    }
    public void process(Exchange exchange) throws Exception {
        for (FilterProcessor filterProcessor : filters) {
            Predicate<Exchange> predicate = filterProcessor.getPredicate();
            if (predicate != null && predicate.matches(exchange)) {
                // process next will also take care (has not null test) if next was a stop().
                // stop() has no processor to execute, and thus we will end in a NPE 
                filterProcessor.processNext(exchange);
                return;
            }
        }
        if (otherwise != null) {
            otherwise.process(exchange);
        }
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""choice{"");
        boolean first = true;
        for (FilterProcessor processor : filters) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(""when "");
            builder.append(processor.getPredicate().toString());
            builder.append("": "");
            builder.append(processor.getProcessor());
        }
        if (otherwise != null) {
            builder.append("", otherwise: "");
            builder.append(otherwise);
        }
        builder.append(""}"");
        return builder.toString();
    }
    public List<FilterProcessor> getFilters() {
        return filters;
    }
    public Processor getOtherwise() {
        return otherwise;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(filters);
        ServiceHelper.startServices(otherwise);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(otherwise);
        ServiceHelper.stopServices(filters);
    }
}
"
org.apache.camel.processor.ChoiceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
/**
 * @version $Revision: 660348 $
 */
public class ChoiceTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendToFirstWhen() throws Exception {
        String body = ""<one/>"";
        x.expectedBodiesReceived(body);
        // The SpringChoiceTest.java can't setup the header by Spring configure file
        // x.expectedHeaderReceived(""name"", ""a"");
        expectsMessageCount(0, y, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisifed();
    }
    public void testSendToSecondWhen() throws Exception {
        String body = ""<two/>"";
        y.expectedBodiesReceived(body);
        expectsMessageCount(0, x, z);
        sendMessage(""cheese"", body);
        assertMockEndpointsSatisifed();
    }
    public void testSendToOtherwiseClause() throws Exception {
        String body = ""<three/>"";
        z.expectedBodiesReceived(body);
        expectsMessageCount(0, x, y);
        sendMessage(""somethingUndefined"", body);
        assertMockEndpointsSatisifed();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.sendBodyAndHeader(""direct:start"", body, ""foo"", headerValue);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").choice()
                        .when(header(""foo"").isEqualTo(""bar"")).setHeader(""name"", constant(""a"")).to(""mock:x"")
                        .when(header(""foo"").isEqualTo(""cheese"")).to(""mock:y"")
                        .otherwise().to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.CompositeProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * Represents a composite pattern, aggregating a collection of processors
 * together as a single processor
 * 
 * @version $Revision: 630591 $
 */
public class CompositeProcessor extends ServiceSupport implements Processor {
    private final Collection<Processor> processors;
    public CompositeProcessor(Collection<Processor> processors) {
        this.processors = processors;
    }
    public void process(Exchange exchange) throws Exception {
        for (Processor processor : processors) {
            processor.process(exchange);
        }
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""[ "");
        boolean first = true;
        for (Processor processor : processors) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(processor.toString());
        }
        builder.append("" ]"");
        return builder.toString();
    }
    public Collection<Processor> getProcessors() {
        return processors;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processors);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors);
    }
}
"
org.apache.camel.processor.ConvertBodyProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A processor which converts the payload of the input message to be of the given type
 *
 * @version $Revision: 674383 $
 */
public class ConvertBodyProcessor implements Processor {
    private static final transient Log LOG = LogFactory.getLog(ConvertBodyProcessor.class);
    private final Class type;
    public ConvertBodyProcessor(Class type) {
        this.type = type;
    }
    public void process(Exchange exchange) throws Exception {
        Message in = exchange.getIn();
        Object value = in.getBody(type);
        if (value == null) {
            LOG.warn(""Could not convert body of IN message: "" + in + "" to type: "" + type.getName());
        }
        if (exchange.getPattern().isOutCapable()) {
            Message out = exchange.getOut();
            out.copyFrom(in);
            out.setBody(value);
        } else {
            in.setBody(value);
        }
    }
}
"
org.apache.camel.processor.ConvertBodyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class ConvertBodyTest extends ContextTestSupport {
    public void testConvertToInteger() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"",
                MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(11);
        template.sendBody(""direct:start"", ""11"");
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").convertBodyTo(Integer.class).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.CreateRouteWithNonExistingEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630568 $
 */
public class CreateRouteWithNonExistingEndpointTest extends ContextTestSupport {
    public void testCreateRouteWithBadEndpoint() throws Exception {
    }
    @Override
    protected void setUp() throws Exception {
        try {
            super.setUp();
            fail(""Should have failed to create this route!"");
        } catch (NoSuchEndpointException e) {
            log.debug(""Caught expected exception: "" + e, e);
            assertEquals(""uri"", ""thisUriDoesNotExist"", e.getUri());
        }
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""thisUriDoesNotExist"");
            }
        };
    }
}
"
org.apache.camel.processor.DataFormatTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.Serializable;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.util.ObjectHelper.equal;
/**
 * @version $Revision: 659842 $
 */
public class DataFormatTest extends ContextTestSupport {
    public void testMarshalThenUnmarshalBean() throws Exception {
        MyBean bean = new MyBean();
        bean.name = ""James"";
        bean.counter = 5;
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(bean);
        template.sendBody(""direct:start"", bean);
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").marshal().serialization().to(""direct:marshalled"");
                from(""direct:marshalled"").unmarshal().serialization().to(""mock:result"");
            }
        };
    }
    protected static class MyBean implements Serializable {
        public String name;
        public int counter;
        @Override
        public boolean equals(Object o) {
            if (o instanceof MyBean) {
                MyBean that = (MyBean) o;
                return equal(this.name, that.name) && equal(this.counter,  that.counter);
            }
            return false;
        }
        @Override
        public int hashCode() {
            return name.hashCode() + counter;
        }
    }
}
"
org.apache.camel.processor.DeadLetterChannel,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.RejectedExecutionException;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangeProperty;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Implements a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a> after attempting to redeliver the message using the
 * {@link RedeliveryPolicy}
 *
 * @version $Revision: 674036 $
 */
public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor {
    public static final String REDELIVERY_COUNTER = ""org.apache.camel.RedeliveryCounter"";
    public static final String REDELIVERED = ""org.apache.camel.Redelivered"";
    public static final String EXCEPTION_CAUSE_PROPERTY = ""CamelCauseException"";
    private class RedeliveryData {
        int redeliveryCounter;
        long redeliveryDelay;
        boolean sync = true;
        // default behaviour which can be overloaded on a per exception basis
        RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy;
        Processor failureProcessor = deadLetter;
    }
    private static final transient Log LOG = LogFactory.getLog(DeadLetterChannel.class);
    private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel.class.getName() + "".FAILURE_HANDLED"";
    private Processor output;
    private Processor deadLetter;
    private AsyncProcessor outputAsync;
    private RedeliveryPolicy redeliveryPolicy;
    private Logger logger;
    public DeadLetterChannel(Processor output, Processor deadLetter) {
        this(output, deadLetter, new RedeliveryPolicy(), DeadLetterChannel.createDefaultLogger(),
            ErrorHandlerSupport.createDefaultExceptionPolicyStrategy());
    }
    public DeadLetterChannel(Processor output, Processor deadLetter, RedeliveryPolicy redeliveryPolicy, Logger logger, ExceptionPolicyStrategy exceptionPolicyStrategy) {
        this.deadLetter = deadLetter;
        this.output = output;
        this.outputAsync = AsyncProcessorTypeConverter.convert(output);
        this.redeliveryPolicy = redeliveryPolicy;
        this.logger = logger;
        setExceptionPolicy(exceptionPolicyStrategy);
    }
    public static <E extends Exchange> Logger createDefaultLogger() {
        return new Logger(LOG, LoggingLevel.ERROR);
    }
    @Override
    public String toString() {
        return ""DeadLetterChannel["" + output + "", "" + deadLetter + "", "" + redeliveryPolicy + ""]"";
    }
    public boolean process(Exchange exchange, final AsyncCallback callback) {
        return process(exchange, callback, new RedeliveryData());
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) {
        while (true) {
            // We can't keep retrying if the route is being shutdown.
            if (!isRunAllowed()) {
                if (exchange.getException() == null) {
                    exchange.setException(new RejectedExecutionException());
                }
                callback.done(data.sync);
                return data.sync;
            }
            // if the exchange is transacted then let the underlysing system handle the redelivery etc.
            // this DeadLetterChannel is only for non transacted exchanges
            if (exchange.isTransacted() && exchange.getException() != null) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Transacted Exchange, this DeadLetterChannel is bypassed: "" + exchange);
                }
                return data.sync;
            }
            if (exchange.getException() != null) {
                Throwable e = exchange.getException();
                exchange.setException(null); // Reset it since we are handling it.
                logger.log(""Failed delivery for exchangeId: "" + exchange.getExchangeId() + "". On delivery attempt: "" + data.redeliveryCounter + "" caught: "" + e, e);
                data.redeliveryCounter = incrementRedeliveryCounter(exchange, e);
                ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e);
                if (exceptionPolicy != null) {
                    data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy);
                    Processor processor = exceptionPolicy.getErrorHandler();
                    if (processor != null) {
                        data.failureProcessor = processor;
                    }
                }
            }
            if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) {
                setFailureHandled(exchange, true);
                AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor);
                boolean sync = afp.process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        restoreExceptionOnExchange(exchange);
                        callback.done(data.sync);
                    }
                });
                restoreExceptionOnExchange(exchange);
                logger.log(""Failed delivery for exchangeId: "" + exchange.getExchangeId() + "". Handled by the failure processor: "" + data.failureProcessor);
                return sync;
            }
            if (data.redeliveryCounter > 0) {
                // Figure out how long we should wait to resend this message.
                data.redeliveryDelay = data.currentRedeliveryPolicy.sleep(data.redeliveryDelay);
            }
            exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, exchange.getException());
            exchange.setException(null);
            boolean sync = outputAsync.process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    // Only handle the async case...
                    if (sync) {
                        return;
                    }
                    data.sync = false;
                    if (exchange.getException() != null) {
                        process(exchange, callback, data);
                    } else {
                        callback.done(sync);
                    }
                }
            });
            if (!sync) {
                // It is going to be processed async..
                return false;
            }
            if (exchange.getException() == null || isFailureHandled(exchange)) {
                // If everything went well.. then we exit here..
                callback.done(true);
                return true;
            }
            // error occurred so loop back around.....
        }
    }
    public static boolean isFailureHandled(Exchange exchange) {
        return exchange.getProperty(FAILURE_HANDLED_PROPERTY) != null;
    }
    public static void setFailureHandled(Exchange exchange, boolean isHandled) {
        if (isHandled) {
            exchange.setProperty(FAILURE_HANDLED_PROPERTY, exchange.getException());
            exchange.setException(null);
        } else {
            exchange.setException(exchange.getProperty(FAILURE_HANDLED_PROPERTY, Throwable.class));
            exchange.removeProperty(FAILURE_HANDLED_PROPERTY);
        }
    }
    public static void restoreExceptionOnExchange(Exchange exchange) {
        exchange.setException(exchange.getProperty(FAILURE_HANDLED_PROPERTY, Throwable.class));
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    // Properties
    // -------------------------------------------------------------------------
    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }
    /**
     * Returns the dead letter that message exchanges will be sent to if the
     * redelivery attempts fail
     */
    public Processor getDeadLetter() {
        return deadLetter;
    }
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public Logger getLogger() {
        return logger;
    }
    /**
     * Sets the logger strategy; which {@link Log} to use and which
     * {@link LoggingLevel} to use
     */
    public void setLogger(Logger logger) {
        this.logger = logger;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Increments the redelivery counter and adds the redelivered flag if the
     * message has been redelivered
     */
    protected int incrementRedeliveryCounter(Exchange exchange, Throwable e) {
        Message in = exchange.getIn();
        Integer counter = in.getHeader(REDELIVERY_COUNTER, Integer.class);
        int next = 1;
        if (counter != null) {
            next = counter + 1;
        }
        in.setHeader(REDELIVERY_COUNTER, next);
        in.setHeader(REDELIVERED, Boolean.TRUE);
        exchange.setException(e);
        return next;
    }
    @Override
    protected void doStart() throws Exception {
        ServiceHelper.startServices(output, deadLetter);
    }
    @Override
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(deadLetter, output);
    }
}
"
org.apache.camel.processor.DeadLetterChannelTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 645063 $
 */
public class DeadLetterChannelTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint deadEndpoint;
    protected MockEndpoint successEndpoint;
    protected int failUntilAttempt = 2;
    protected String body = ""<hello>world!</hello>"";
    public void testFirstFewAttemptsFail() throws Exception {
        successEndpoint.expectedBodiesReceived(body);
        successEndpoint.message(0).header(DeadLetterChannel.REDELIVERED).isEqualTo(true);
        // TODO convert to AND
        successEndpoint.message(0).header(DeadLetterChannel.REDELIVERY_COUNTER).isEqualTo(1);
        deadEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", body);
        assertMockEndpointsSatisifed();
    }
    public void testLotsOfAttemptsFail() throws Exception {
        failUntilAttempt = 5;
        deadEndpoint.expectedBodiesReceived(body);
        deadEndpoint.message(0).header(DeadLetterChannel.REDELIVERED).isEqualTo(true);
        // TODO convert to AND
        deadEndpoint.message(0).header(DeadLetterChannel.REDELIVERY_COUNTER).isEqualTo(2);
        successEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", body);
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        deadEndpoint = getMockEndpoint(""mock:failed"");
        successEndpoint = getMockEndpoint(""mock:success"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                Integer counter = exchange.getIn().getHeader(DeadLetterChannel.REDELIVERY_COUNTER,
                                                             Integer.class);
                int attempt = (counter == null) ? 1 : counter + 1;
                if (attempt < failUntilAttempt) {
                    throw new RuntimeException(""Failed to process due to attempt: "" + attempt
                                               + "" being less than: "" + failUntilAttempt);
                } else {
                    template.send(""mock:success"", exchange);
                }
            }
        };
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").errorHandler(
                    deadLetterChannel(""mock:failed"").maximumRedeliveries(2)
                        .initialRedeliveryDelay(1)
                        .loggingLevel(LoggingLevel.DEBUG)
                ).process(processor);
                // TODO - currently process().to() results in two separate operations which have their own error handler
                // to(""mock:success"");
            }
        };
    }
}
"
org.apache.camel.processor.DebugInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.interceptor.Debugger;
/**
 * @version $Revision: 673954 $
 */
public class DebugInterceptorTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testSendingSomeMessages() throws Exception {
        template.sendBodyAndHeader(""direct:start"", ""Hello London"", ""to"", ""James"");
        template.sendBodyAndHeader(""direct:start"", ""This is Copenhagen calling"", ""from"", ""Claus"");
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // add debugger as an interceptor. The debugger is an enhanced tracer that also
                // logs the exchanges at runtime. It is also a framework where we programatically
                // can access the internal states of Camel etc.
                getContext().addInterceptStrategy(new Debugger());
                from(""direct:start"").
                        process(new Processor() {
                            public void process(Exchange exchange) throws Exception {
                                // do nothing
                            }
                            @Override
                            public String toString() {
                                return ""MyProcessor"";
                            }
                        }).
                        to(""mock:a"").
                        to(""mock:b"");
            }
        };
    }
    // END SNIPPET: e1
}
"
org.apache.camel.processor.Delayer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.util.ExpressionHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> which
 * delays processing the exchange until the correct amount of time has elapsed
 * using an expression to determine the delivery time. <p/> For example if you
 * wish to delay JMS messages by 25 seconds from their publish time you could
 * create an instance of this class with the expression
 * <code>header(""JMSTimestamp"")</code> and a delay value of 25000L.
 * 
 * @version $Revision: 630591 $
 */
public class Delayer extends DelayProcessorSupport {
    private Expression<Exchange> timeExpression;
    private long delay;
    public Delayer(Processor processor, Expression<Exchange> timeExpression, long delay) {
        super(processor);
        this.timeExpression = timeExpression;
        this.delay = delay;
    }
    @Override
    public String toString() {
        return ""Delayer[on: "" + timeExpression + "" delay: "" + delay + "" to: "" + getProcessor() + ""]"";
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getDelay() {
        return delay;
    }
    /**
     * Sets the delay from the publish time; which is typically the time from
     * the expression or the current system time if none is available
     */
    public void setDelay(long delay) {
        this.delay = delay;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Waits for an optional time period before continuing to process the
     * exchange
     */
    protected void delay(Exchange exchange) throws Exception {
        long time = 0;
        if (timeExpression != null) {
            Long longValue = ExpressionHelper.evaluateAsType(timeExpression, exchange, Long.class);
            if (longValue != null) {
                time = longValue.longValue();
            }
        }
        if (time <= 0) {
            time = defaultProcessTime(exchange);
        }
        time += delay;
        waitUntil(time, exchange);
    }
    /**
     * A Strategy Method to allow derived implementations to decide the current
     * system time or some other default exchange property
     * 
     * @param exchange
     */
    protected long defaultProcessTime(Exchange exchange) {
        return currentSystemTime();
    }
}
"
org.apache.camel.processor.DelayerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class DelayerTest extends ContextTestSupport {
    public void testSendingMessageGetsDelayed() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""seda:a"", ""<hello>world!</hello>"", ""JMSTimestamp"", System
            .currentTimeMillis());
        resultEndpoint.assertIsSatisfied();
        // now if we wait a bit longer we should receive the message!
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
        template.sendBody(""seda:b"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
        // now if we wait a bit longer we should receive the message!
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""seda:a"").delayer(header(""JMSTimestamp""), 3000).to(""mock:result"");
                // END SNIPPET: ex
                // START SNIPPET: ex2
                from(""seda:b"").delayer(3000).to(""mock:result"");
                // END SNIPPET: ex2
            }
        };
    }
}
"
org.apache.camel.processor.DelayProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AlreadyStoppedException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for any processor which provides some kind of throttling
 * or delayed processing
 * 
 * @version $Revision: 676542 $
 */
public abstract class DelayProcessorSupport extends DelegateProcessor {
    private static final transient Log LOG = LogFactory.getLog(Delayer.class);
    private CountDownLatch stoppedLatch = new CountDownLatch(1);
    private boolean fastStop = true;
    public DelayProcessorSupport(Processor processor) {
        super(processor);
    }
    public void process(Exchange exchange) throws Exception {
        delay(exchange);
        super.process(exchange);
    }
    public boolean isFastStop() {
        return fastStop;
    }
    /**
     * Enables & disables a fast stop; basically to avoid waiting a possibly
     * long time for delays to complete before the context shuts down; instead
     * the current processing method throws
     * {@link org.apache.camel.AlreadyStoppedException} to terminate processing.
     */
    public void setFastStop(boolean fastStop) {
        this.fastStop = fastStop;
    }
    protected void doStop() throws Exception {
        stoppedLatch.countDown();
        super.doStop();
    }
    protected abstract void delay(Exchange exchange) throws Exception;
    /**
     * Wait until the given system time before continuing
     * 
     * @param time the system time to wait for
     * @param exchange the exchange being processed
     */
    protected void waitUntil(long time, Exchange exchange) throws Exception {
        while (true) {
            long delay = time - currentSystemTime();
            if (delay < 0) {
                return;
            } else {
                if (isFastStop() && !isRunAllowed()) {
                    throw new AlreadyStoppedException();
                }
                try {
                    sleep(delay);
                } catch (InterruptedException e) {
                    handleSleepInteruptedException(e);
                }
            }
        }
    }
    protected void sleep(long delay) throws InterruptedException {
        if (delay <= 0) {
            return;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Sleeping for: "" + delay + "" millis"");
        }
        if (isFastStop()) {
            stoppedLatch.await(delay, TimeUnit.MILLISECONDS);
        } else {
            Thread.sleep(delay);
        }
    }
    /**
     * Called when a sleep is interupted; allows derived classes to handle this
     * case differently
     */
    protected void handleSleepInteruptedException(InterruptedException e) {
        LOG.debug(""Sleep interupted: "" + e, e);
    }
    protected long currentSystemTime() {
        return System.currentTimeMillis();
    }
}
"
org.apache.camel.processor.DelegateAsyncProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.Policy;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ServiceHelper;
/**
 * A Delegate pattern which delegates processing to a nested AsyncProcessor which can
 * be useful for implementation inheritance when writing an {@link Policy}
 */
public class DelegateAsyncProcessor extends ServiceSupport implements AsyncProcessor {
    protected AsyncProcessor processor;
    public DelegateAsyncProcessor() {
    }
    public DelegateAsyncProcessor(AsyncProcessor processor) {
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""Delegate("" + processor + "")"";
    }
    public AsyncProcessor getProcessor() {
        return processor;
    }
    public void setProcessor(AsyncProcessor processor) {
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        return processor.process(exchange, callback);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
}
"
org.apache.camel.processor.DelegateProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.Policy;
import org.apache.camel.util.ServiceHelper;
/**
 * A Delegate pattern which delegates processing to a nested processor which can
 * be useful for implementation inheritance when writing an {@link Policy}
 * 
 * @version $Revision: 658240 $
 */
public class DelegateProcessor extends ServiceSupport implements Processor {
    protected Processor processor;
    public DelegateProcessor() {
    }
    public DelegateProcessor(Processor processor) {
        if (processor == this) {
            throw new IllegalArgumentException(""Recursive DelegateProcessor!"");
        }
        this.processor = processor;
    }
    public void process(Exchange exchange) throws Exception {
        processNext(exchange);
    }
    protected void processNext(Exchange exchange) throws Exception {
        if (processor != null) {
            processor.process(exchange);
        }
    }
    @Override
    public String toString() {
        return ""Delegate("" + processor + "")"";
    }
    public Processor getProcessor() {
        return processor;
    }
    public void setProcessor(Processor processor) {
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    /**
     * Proceed with the underlying delegated processor
     */
    public void proceed(Exchange exchange) throws Exception {
        processNext(exchange);
    }
}
"
org.apache.camel.processor.ErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Processor;
/**
 * An interface used to represent an error handler
 *
 * @version $Revision: 630591 $
 */
public interface ErrorHandler extends Processor {
}
"
org.apache.camel.processor.ErrorHandlerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy;
import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
/**
 * Support class for {@link ErrorHandler} implementations.
 *
 * @version $Revision: 645359 $
 */
public abstract class ErrorHandlerSupport extends ServiceSupport implements ErrorHandler {
    private Map<Class, ExceptionType> exceptionPolicies = new LinkedHashMap<Class, ExceptionType>();
    private ExceptionPolicyStrategy exceptionPolicy = createDefaultExceptionPolicyStrategy();
    public void addExceptionPolicy(ExceptionType exception) {
        Processor processor = exception.getErrorHandler();
        addChildService(processor);
        List<Class> list = exception.getExceptionClasses();
        for (Class exceptionType : list) {
            exceptionPolicies.put(exceptionType, exception);
        }
    }
    /**
     * Attempts to invoke the handler for this particular exception if one is available
     */
    protected boolean customProcessorForException(Exchange exchange, Throwable exception) throws Exception {
        ExceptionType policy = getExceptionPolicy(exchange, exception);
        if (policy != null) {
            Processor processor = policy.getErrorHandler();
            if (processor != null) {
                processor.process(exchange);
                return true;
            }
        }
        return false;
    }
    /**
     * Attempts to find the best suited {@link ExceptionType} to be used for handling the given thrown exception.
     *
     * @param exchange  the exchange
     * @param exception the exception that was thrown
     * @return the best exception type to handle this exception, <tt>null</tt> if none found.
     */
    protected ExceptionType getExceptionPolicy(Exchange exchange, Throwable exception) {
        if (exceptionPolicy == null) {
            throw new IllegalStateException(""The exception policy has not been set"");
        }
        return exceptionPolicy.getExceptionPolicy(exceptionPolicies, exchange, exception);
    }
    /**
     * Sets the strategy to use for resolving the {@link ExceptionType} to use
     * for handling thrown exceptions.
     */
    public void setExceptionPolicy(ExceptionPolicyStrategy exceptionPolicy) {
        this.exceptionPolicy = exceptionPolicy;
    }
    /**
     * Creates the default exception policy strategy to use.
     */
    public static ExceptionPolicyStrategy createDefaultExceptionPolicyStrategy() {
        return new DefaultExceptionPolicyStrategy();
    }
}
"
org.apache.camel.processor.ErrorHandlerSupportTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.Exchange;
import org.apache.camel.model.ExceptionType;
public class ErrorHandlerSupportTest extends TestCase {
    public void testOnePolicyChildFirst() {
        List<Class> exceptions = new ArrayList<Class>();
        exceptions.add(ChildException.class);
        exceptions.add(ParentException.class);
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(exceptions));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 0));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 1));
    }
    public void testOnePolicyChildLast() {
        List<Class> exceptions = new ArrayList<Class>();
        exceptions.add(ParentException.class);
        exceptions.add(ChildException.class);
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(exceptions));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 1));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 0));
    }
    public void testTwoPolicyChildFirst() {
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(ChildException.class));
        support.addExceptionPolicy(new ExceptionType(ParentException.class));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 0));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 0));
    }
    public void testTwoPolicyChildLast() {
        ErrorHandlerSupport support = new ShuntErrorHandlerSupport();
        support.addExceptionPolicy(new ExceptionType(ParentException.class));
        support.addExceptionPolicy(new ExceptionType(ChildException.class));
        assertEquals(ChildException.class, getExceptionPolicyFor(support, new ChildException(), 0));
        assertEquals(ParentException.class, getExceptionPolicyFor(support, new ParentException(), 0));
    }
    private static Class getExceptionPolicyFor(ErrorHandlerSupport support, Throwable childException,
                                               int index) {
        return support.getExceptionPolicy(null, childException).getExceptionClasses().get(index);
    }
    private static class ParentException extends Exception {
    }
    private static class ChildException extends ParentException {
    }
    private static class ShuntErrorHandlerSupport extends ErrorHandlerSupport {
        protected void doStart() throws Exception {
        }
        protected void doStop() throws Exception {
        }
        public void process(Exchange exchange) throws Exception {
        }
    }
}
"
org.apache.camel.processor.ExpressionAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.impl.ExpressionSupport;
/**
 * A helper class for developers wishing to implement an {@link Expression} using Java code with a minimum amount
 * of code to write so that the developer only needs to implement the {@link #evaluate(Exchange)} method.
 *
 * @version $Revision: 647890 $
 */
public abstract class ExpressionAdapter extends ExpressionSupport<Exchange> {
    public abstract Object evaluate(Exchange exchange);
    protected String assertionFailureMessage(Exchange exchange) {
        return toString();
    }
}
"
org.apache.camel.processor.FaultRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.CamelException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 659491 $
 */
public class FaultRouteTest extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    protected MockEndpoint c;
    protected MockEndpoint err;
    protected boolean shouldWork = true;
    public void testWithOut() throws Exception {
        a.whenExchangeReceived(1, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getOut().setBody(""out"");
            }
        });
        a.expectedMessageCount(1);
        b.expectedBodiesReceived(""out"");
        c.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""in"");
        MockEndpoint.assertIsSatisfied(a, b, c);
    }
    public void testWithFault() throws Exception {
        shouldWork = false;
        a.whenExchangeReceived(1, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getFault().setBody(""fault"");
            }
        });
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
        c.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""in"");
        MockEndpoint.assertIsSatisfied(a, b, c);
        // TODO wrap up as an exception on the mock endpoint
        List<Exchange> list = a.getReceivedExchanges();
        Exchange exchange = list.get(0);
        Message fault = exchange.getFault();
        assertNotNull(""Should have a fault on A"", fault);
        assertEquals(""Fault body"", ""fault"", fault.getBody());
    }
    public void testWithThrowFaultMessage() throws Exception {
        throwFaultTest(""direct:string"");
    }
    public void testWithThrowFaultException() throws Exception {
        throwFaultTest(""direct:exception"");
    }
    public void testWithThrowFaultMessageUnhandled() throws Exception {
        throwFaultTest(""direct:fault"");
    }
    public void testWithHandleFaultMessage() throws Exception {
        throwFaultTest(""direct:error"", 1);
    }
    private void throwFaultTest(String startPoint) throws InterruptedException {
        throwFaultTest(startPoint, 0);
    }
    private void throwFaultTest(String startPoint, int errors) throws InterruptedException {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
        c.expectedMessageCount(0);
        err.expectedMessageCount(errors);
        template.sendBody(startPoint, ""in"");
        MockEndpoint.assertIsSatisfied(a, b, c, err);
        List<Exchange> list = a.getReceivedExchanges();
        Exchange exchange = list.get(0);
        Message fault = exchange.getFault();
        assertNotNull(""Should have a fault on A"", fault);
        if (startPoint.equals(""direct:exception"")) {
            assertTrue(""It should be the IllegalStateException"",
                       fault.getBody() instanceof IllegalStateException);
            assertEquals(""Fault message"", ""It makes no sense of business logic"",
                         ((IllegalStateException)(fault.getBody())).getMessage());
        } else { // test for the throwFault with String
            assertTrue(""It should be the CamelException"", fault.getBody() instanceof CamelException);
            assertEquals(""Fault message"", ""ExceptionMessage"", ((CamelException)(fault.getBody()))
                .getMessage());
        }
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = resolveMandatoryEndpoint(""mock:a"", MockEndpoint.class);
        b = resolveMandatoryEndpoint(""mock:b"", MockEndpoint.class);
        c = resolveMandatoryEndpoint(""mock:c"", MockEndpoint.class);
        err = resolveMandatoryEndpoint(""mock:error"", MockEndpoint.class);
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:start"").to(""mock:a"").to(""mock:b"");
                from(""direct:string"").to(""mock:a"").throwFault(""ExceptionMessage"").to(""mock:b"");
                from(""direct:exception"").to(""mock:a"")
                    .throwFault(new IllegalStateException(""It makes no sense of business logic""))
                    .to(""mock:b"");
                from(""direct:fault"").errorHandler(
                    deadLetterChannel(""mock:error"")
                            .maximumRedeliveries(2)
                        .loggingLevel(LoggingLevel.DEBUG))
                    .to(""mock:a"").throwFault(""ExceptionMessage"").to(""mock:b"");
                from(""direct:error"").errorHandler(
                    deadLetterChannel(""mock:error"")
                            .maximumRedeliveries(2)
                        .loggingLevel(LoggingLevel.DEBUG))
                    .to(""mock:a"").handleFault().throwFault(""ExceptionMessage"").to(""mock:b"");
            }
        };
    }
}
"
org.apache.camel.processor.FilterProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
/**
 * The processor which implements the
 * <a href=""http://activemq.apache.org/camel/message-filter.html"">Message Filter</a> EIP pattern.
 *
 * @version $Revision: 659760 $
 */
public class FilterProcessor extends DelegateProcessor {
    private Predicate<Exchange> predicate;
    public FilterProcessor(Predicate<Exchange> predicate, Processor processor) {
        super(processor);
        this.predicate = predicate;
    }
    public void process(Exchange exchange) throws Exception {
        if (predicate.matches(exchange)) {
            super.process(exchange);
        }
    }
    @Override
    public String toString() {
        return ""Filter[if: "" + predicate + "" do: "" + getProcessor() + ""]"";
    }
    public Predicate<Exchange> getPredicate() {
        return predicate;
    }
}
"
org.apache.camel.processor.FilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class FilterTest extends ContextTestSupport {
    public void testSendMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").filter(header(""foo"").isEqualTo(""bar"")).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.HandleFaultProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
public class HandleFaultProcessor extends DelegateProcessor {
    @Override
    public void process(Exchange exchange) throws Exception {
        super.process(exchange);
        final Message faultMessage = exchange.getFault(false);
        if (faultMessage != null) {
            final Object faultBody = faultMessage.getBody();
            if (faultBody != null) {
                if (faultBody instanceof Throwable) {
                    exchange.setException((Throwable)faultBody);
                } else {
                    exchange.setException(new CamelException(""Message contains fault of type ""
                                                             + faultBody.getClass().getName() + "":\n""
                                                             + faultBody));
                }
            }
        }
    }
}
"
org.apache.camel.processor.IdempotentConsumerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.processor.idempotent.MemoryMessageIdRepository.memoryMessageIdRepository;
/**
 * @version $Revision: 630568 $
 */
public class IdempotentConsumerTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testDuplicateMessagesAreFilteredOut() throws Exception {
        resultEndpoint.expectedBodiesReceived(""one"", ""two"", ""three"");
        sendMessage(""1"", ""one"");
        sendMessage(""2"", ""two"");
        sendMessage(""1"", ""one"");
        sendMessage(""2"", ""two"");
        sendMessage(""1"", ""one"");
        sendMessage(""3"", ""three"");
        resultEndpoint.assertIsSatisfied();
    }
    protected void sendMessage(final Object messageId, final Object body) {
        template.send(startEndpoint, new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""messageId"", messageId);
            }
        });
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").idempotentConsumer(
                        header(""messageId""), memoryMessageIdRepository(200)
                ).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.Interceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Intercept;
import org.apache.camel.Processor;
import org.apache.camel.util.ServiceHelper;
/**
 * An interceptor which provides the processing logic as a pluggable processor
 * which allows the {@link #proceed(Exchange)} method to be called at some point
 *
 * @version $Revision: 662664 $
 */
public class Interceptor extends DelegateProcessor implements Intercept {
    private Processor interceptorLogic;
    public Interceptor() {
    }
    public Interceptor(Processor interceptorLogic) {
        this.interceptorLogic = interceptorLogic;
    }
    public void process(Exchange exchange) throws Exception {
        interceptorLogic.process(exchange);
    }
    public Processor getInterceptorLogic() {
        return interceptorLogic;
    }
    public void setInterceptorLogic(Processor interceptorLogic) {
        this.interceptorLogic = interceptorLogic;
    }
    @Override
    protected void doStart() throws Exception {
        ServiceHelper.startService(interceptorLogic);
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        ServiceHelper.stopService(interceptorLogic);
        super.doStop();
    }
}
"
org.apache.camel.processor.InterceptorSimpleRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * A simple interceptor routing test
 */
public class InterceptorSimpleRouteTest extends ContextTestSupport {
    public void testIntercept() throws Exception {
        MockEndpoint intercepted = getMockEndpoint(""mock:intercepted"");
        intercepted.expectedBodiesReceived(""Hello London"");
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedBodiesReceived(""Hello Paris"");
        template.sendBodyAndHeader(""seda:a"", ""Hello London"", ""city"", ""London"");
        template.sendBodyAndHeader(""seda:a"", ""Hello Paris"", ""city"", ""Paris"");
        intercepted.assertIsSatisfied();
        result.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // In Camel 1.4 proceed is default so we must use stop to not route it to the result mock
                intercept(header(""city"").isEqualTo(""London"")).to(""mock:intercepted"").stop();
                from(""seda:a"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.InterceptRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 672271 $
 */
public class InterceptRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept().choice().
                        when(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").
                        otherwise().proceed();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptRouteTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 673954 $
 */
public abstract class InterceptRouteTestSupport extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    public void testSendMatchingMessage() throws Exception {
        prepareMatchingTest();
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisifed();
    }
    public void testSendNonMatchingMessage() throws Exception {
        prepareNonMatchingTest();
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected abstract void prepareMatchingTest();
    protected abstract void prepareNonMatchingTest();
}
"
org.apache.camel.processor.InterceptWithoutProceedRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 672271 $
 */
public class InterceptWithoutProceedRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept().filter(header(""foo"").isEqualTo(""bar"")).to(""mock:b"");
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithPredicateAndProceedRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 672271 $
 */
public class InterceptWithPredicateAndProceedRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").proceed();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithPredicateAndStopRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 674289 $
 */
public class InterceptWithPredicateAndStopRouteTest extends
        InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").stop();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithPredicateRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 674289 $
 */
public class InterceptWithPredicateRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // no stop so the message will proceed in its normal route also
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"");
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.InterceptWithStopRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 673954 $
 */
public class InterceptWithStopRouteTest extends InterceptRouteTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept().filter(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").stop();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
    @Override
    protected void prepareMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(1);
    }
    @Override
    protected void prepareNonMatchingTest() {
        a.expectedMessageCount(0);
        b.expectedMessageCount(0);
    }
}
"
org.apache.camel.processor.JoinRoutesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class JoinRoutesTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testMessagesThroughDifferentRoutes() throws Exception {
        resultEndpoint.expectedBodiesReceived(""one"", ""two"", ""three"");
        sendMessage(""bar"", ""one"");
        sendMessage(""cheese"", ""two"");
        sendMessage(""somethingUndefined"", ""three"");
        resultEndpoint.assertIsSatisfied();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.send(startEndpoint, new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""foo"", headerValue);
            }
        });
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:a"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").choice()
                        .when(header(""foo"").isEqualTo(""bar"")).to(""direct:b"")
                        .when(header(""foo"").isEqualTo(""cheese"")).to(""direct:c"")
                        .otherwise().to(""direct:d"");
                from(""direct:b"").to(""mock:result"");
                from(""direct:c"").to(""mock:result"");
                from(""direct:d"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.LoadBalanceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
public class LoadBalanceTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").loadBalance().
                roundRobin().to(""mock:x"", ""mock:y"", ""mock:z"");
                // END SNIPPET: example
            }
        };
    }
    public void testRoundRobin() throws Exception {
        String body = ""<one/>"";
        x.expectedBodiesReceived(body);
        expectsMessageCount(0, y, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisifed();
        body = ""<two/>"";
        y.expectedBodiesReceived(body);
        expectsMessageCount(0, x, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisifed();
        body = ""<three/>"";
        z.expectedBodiesReceived(body);
        expectsMessageCount(0, x, y);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisifed();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.sendBodyAndHeader(""direct:start"", body, ""foo"", headerValue);
    }
}
"
org.apache.camel.processor.Logger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultExchangeFormatter;
import org.apache.camel.processor.interceptor.ExchangeFormatter;
import org.apache.camel.processor.interceptor.TraceInterceptor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Processor} which just logs to a {@link Log} object which can be used
 * as an exception handler instead of using a dead letter queue.
 *
 * @version $Revision: 676850 $
 */
public class Logger implements Processor {
    private Log log;
    private LoggingLevel level;
    private ExchangeFormatter formatter = DefaultExchangeFormatter.getInstance();
    public Logger() {
        this(LogFactory.getLog(Logger.class));
    }
    public Logger(Log log) {
        this(log, LoggingLevel.INFO);
    }
    public Logger(Log log, LoggingLevel level) {
        this.log = log;
        this.level = level;
    }
    public Logger(String logName) {
        this(LogFactory.getLog(logName));
    }
    public Logger(String logName, LoggingLevel level) {
        this(LogFactory.getLog(logName), level);
    }
    public Logger(Log log, ExchangeFormatter formatter) {
        this(log);
        this.formatter = formatter;
    }
    @Override
    public String toString() {
        return ""Logger["" + log + ""]"";
    }
    public void process(Exchange exchange) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange));
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange));
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange));
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.info(logMessage(exchange));
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange));
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange));
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange));
        }
    }
    public void process(Exchange exchange, Throwable exception) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange), exception);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange), exception);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange), exception);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.info(logMessage(exchange), exception);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange), exception);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange), exception);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange));
        }
    }
    public void log(String message) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(message);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(message);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(message);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(message);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(message);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(message);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message);
        }
    }
    public void log(String message, Throwable exception) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(message, exception);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(message, exception);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(message, exception);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(message, exception);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(message, exception);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(message, exception);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message, exception);
        }
    }
    protected Object logMessage(Exchange exchange) {
        return formatter.format(exchange);
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
    public void setFormatter(ExchangeFormatter formatter) {
        this.formatter = formatter;
    }
}
"
org.apache.camel.processor.LoggingErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An {@link ErrorHandler} which uses commons-logging to dump the error
 * 
 * @version $Revision: 659842 $
 */
public class LoggingErrorHandler extends ErrorHandlerSupport {
    private Processor output;
    private Log log;
    private LoggingLevel level;
    public LoggingErrorHandler(Processor output) {
        this(output, LogFactory.getLog(LoggingErrorHandler.class), LoggingLevel.INFO);
    }
    public LoggingErrorHandler(Processor output, Log log, LoggingLevel level) {
        this.output = output;
        this.log = log;
        this.level = level;
    }
    @Override
    public String toString() {
        return ""LoggingErrorHandler["" + output + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        try {
            output.process(exchange);
        } catch (Throwable e) {
            if (!customProcessorForException(exchange, e)) {
                logError(exchange, e);
            }
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void logError(Exchange exchange, Throwable e) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange, e), e);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange, e), e);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange, e), e);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(logMessage(exchange, e), e);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange, e), e);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange, e), e);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange, e),
                      e);
        }
    }
    protected Object logMessage(Exchange exchange, Throwable e) {
        return e + "" while processing exchange: "" + exchange;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(output);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(output);
    }
}
"
org.apache.camel.processor.LoggingLevel,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
/**
 * Used to configure the logging levels
 *
 * @version $Revision: 655440 $
 */
public enum LoggingLevel {
    DEBUG, ERROR, FATAL, INFO, TRACE, WARN
}
"
org.apache.camel.processor.MarshalProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.ByteArrayOutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.spi.DataFormat;
/**
 * Marshals the body of the incoming message using the given
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 *
 * @version $Revision: 640438 $
 */
public class MarshalProcessor implements Processor {
    private final DataFormat dataFormat;
    public MarshalProcessor(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    public void process(Exchange exchange) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        Message in = exchange.getIn();
        Object body = in.getBody();
        // lets setup the out message before we invoke the dataFormat
        // so that it can mutate it if necessary
        Message out = exchange.getOut(true);
        out.copyFrom(in);
        dataFormat.marshal(exchange, body, buffer);
        byte[] data = buffer.toByteArray();
        out.setBody(data);
    }
}
"
org.apache.camel.processor.MethodFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Header;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 675468 $
 */
public class MethodFilterTest extends ContextTestSupport {
    public void testSendMatchingMessage() throws Exception {
        String body = ""<person name='James' city='London'/>"";
        getMockEndpoint(""mock:result"").expectedBodiesReceived(body);
        template.sendBodyAndHeader(""direct:start"", ExchangePattern.InOut, body, ""foo"", ""London"");
        assertMockEndpointsSatisifed();
    }
    public void testSendNotMatchingMessage() throws Exception {
        String body = ""<person name='Hiram' city='Tampa'/>"";
        getMockEndpoint(""mock:result"").expectedMessageCount(0);
        template.sendBodyAndHeader(""direct:start"", ExchangePattern.InOut, body, ""foo"", ""Tampa"");
        assertMockEndpointsSatisifed();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").
                        filter().method(""myBean"", ""matches"").
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
    @Override
    protected Context createJndiContext() throws Exception {
        Context context = super.createJndiContext();
        context.bind(""myBean"", new MyBean());
        return context;
    }
    // START SNIPPET: filter
    public static class MyBean {
        public boolean matches(@Header(name = ""foo"")String location) {
            return ""London"".equals(location);
        }
    }
    // END SNIPPET: filter
}
"
org.apache.camel.processor.MultiCastAggregatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.AggregationStrategy;
public class MultiCastAggregatorTest extends ContextTestSupport {
    public void testMulticastReceivesItsOwnExchangeParallelly() throws Exception {
        sendingAMessageUsingMulticastReceivesItsOwnExchange(true);
    }
    public void testMulticastReceivesItsOwnExchangeSequentially() throws Exception {
        sendingAMessageUsingMulticastReceivesItsOwnExchange(false);
    }
    private void sendingAMessageUsingMulticastReceivesItsOwnExchange(boolean isParallel) throws Exception {
        MockEndpoint result = getMockEndpoint(""mock:result"");
        result.expectedBodiesReceived(""inputx+inputy+inputz"");
        String url;
        if (isParallel) {
            url = ""direct:parallel"";
        } else {
            url = ""direct:sequential"";
        }
        Exchange exchange = template.send(url, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""input"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertNotNull(""We should get result here"", exchange);
        assertEquals(""Can't get the right result"", ""inputx+inputy+inputz"", exchange.getOut().getBody(String.class));
        assertMockEndpointsSatisifed();
    }
    private class AppendingProcessor implements Processor {
        private String appendingString;
        public AppendingProcessor(String string) {
            appendingString = string;
        }
        public void process(Exchange exchange) {
            // lets transform the IN message
            Message in = exchange.getIn();
            String body = in.getBody(String.class);
            in.setBody(body + appendingString);
        }
    }
    private class BodyOutAggregatingStrategy implements AggregationStrategy {
        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
            Message newOut = newExchange.getOut();
            String oldBody = oldExchange.getOut().getBody(String.class);
            String newBody = newOut.getBody(String.class);
            newOut.setBody(oldBody + ""+"" + newBody);
            return newExchange;
        }
    }
    private class BodyInAggregatingStrategy implements AggregationStrategy {
        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
            Exchange copy = newExchange.copy();
            Message newIn = copy.getIn();
            String oldBody = oldExchange.getIn().getBody(String.class);
            String newBody = newIn.getBody(String.class);
            newIn.setBody(oldBody + ""+"" + newBody);
            Integer old = (Integer) oldExchange.getProperty(""aggregated"");
            if (old == null) {
                old = 1;
            }
            copy.setProperty(""aggregated"", old + 1);
            return copy;
        }
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                ThreadPoolExecutor tpExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));
                // START SNIPPET: example
                // The message will be sent parallelly to the endpoints
                from(""direct:parallel"")
                    .multicast(new BodyOutAggregatingStrategy(), true).setThreadPoolExecutor(tpExecutor)
                        .to(""direct:x"", ""direct:y"", ""direct:z"");
                // Multicast the message in a sequential way
                from(""direct:sequential"").multicast(new BodyOutAggregatingStrategy()).to(""direct:x"", ""direct:y"", ""direct:z"");
                from(""direct:x"").process(new AppendingProcessor(""x"")).to(""direct:aggregater"");
                from(""direct:y"").process(new AppendingProcessor(""y"")).to(""direct:aggregater"");
                from(""direct:z"").process(new AppendingProcessor(""z"")).to(""direct:aggregater"");
                from(""direct:aggregater"").aggregator(header(""cheese""), new BodyInAggregatingStrategy()).
                completedPredicate(header(""aggregated"").isEqualTo(3)).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.MulticastProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ServiceHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements the Multicast pattern to send a message exchange to a number of
 * endpoints, each endpoint receiving a copy of the message exchange.
 *
 * @see Pipeline
 * @version $Revision: 662940 $
 */
public class MulticastProcessor extends ServiceSupport implements Processor {
    static class ProcessorExchangePair {
        private final Processor processor;
        private final Exchange exchange;
        public ProcessorExchangePair(Processor processor, Exchange exchange) {
            this.processor = processor;
            this.exchange = exchange;
        }
        public Processor getProcessor() {
            return processor;
        }
        public Exchange getExchange() {
            return exchange;
        }
    }
    private Collection<Processor> processors;
    private AggregationStrategy aggregationStrategy;
    private boolean isParallelProcessing;
    private ThreadPoolExecutor executor;
    private final AtomicBoolean shutdown = new AtomicBoolean(true);
    public MulticastProcessor(Collection<Processor> processors) {
        this(processors, null);
    }
    public MulticastProcessor(Collection<Processor> processors, AggregationStrategy aggregationStrategy) {
        this(processors, aggregationStrategy, false, null);
    }
    public MulticastProcessor(Collection<Processor> processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor executor) {
        notNull(processors, ""processors"");
        this.processors = processors;
        this.aggregationStrategy = aggregationStrategy;
        this.isParallelProcessing = parallelProcessing;
        if (isParallelProcessing) {
            if (executor != null) {
                this.executor = executor;
            } else { // setup default Executor
                this.executor = new ThreadPoolExecutor(processors.size(), processors.size(), 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(processors.size()));
            }
        }
    }
    /**
     * A helper method to convert a list of endpoints into a list of processors
     */
    public static <E extends Exchange> Collection<Processor> toProducers(Collection<Endpoint> endpoints)
        throws Exception {
        Collection<Processor> answer = new ArrayList<Processor>();
        for (Endpoint endpoint : endpoints) {
            answer.add(endpoint.createProducer());
        }
        return answer;
    }
    @Override
    public String toString() {
        return ""Multicast"" + getProcessors();
    }
    class ProcessCall implements Runnable {
        private final Exchange exchange;
        private final AsyncCallback callback;
        private final Processor processor;
        public ProcessCall(Exchange exchange, Processor processor, AsyncCallback callback) {
            this.exchange = exchange;
            this.callback = callback;
            this.processor = processor;
        }
        public void run() {
            if (shutdown.get()) {
                exchange.setException(new RejectedExecutionException());
                callback.done(false);
            } else {
                try {
                    processor.process(exchange);
                } catch (Exception ex) {
                    exchange.setException(ex);
                }
                callback.done(false);
            }
        }
    }
    public void process(Exchange exchange) throws Exception {
        Exchange result = null;
        List<ProcessorExchangePair> pairs = createProcessorExchangePairs(exchange);
        // Parallel Processing the producer
        if (isParallelProcessing) {
            Exchange[] exchanges = new Exchange[pairs.size()];
            final CountDownLatch completedExchanges = new CountDownLatch(pairs.size());
            int i = 0;
            for (ProcessorExchangePair pair : pairs) {
                Processor producer = pair.getProcessor();
                exchanges[i] = pair.getExchange();
                updateNewExchange(exchanges[i], i, pairs);
                ProcessCall call = new ProcessCall(exchanges[i], producer, new AsyncCallback() {
                    public void done(boolean doneSynchronously) {
                        completedExchanges.countDown();
                    }
                });
                executor.execute(call);
                i++;
            }
            completedExchanges.await();
            if (aggregationStrategy != null) {
                for (Exchange resultExchange : exchanges) {
                    if (result == null) {
                        result = resultExchange;
                    } else {
                        result = aggregationStrategy.aggregate(result, resultExchange);
                    }
                }
            }
        } else {
            // we call the producer one by one sequentially
            int i = 0;
            for (ProcessorExchangePair pair : pairs) {
                Processor producer = pair.getProcessor();
                Exchange subExchange = pair.getExchange();
                updateNewExchange(subExchange, i, pairs);
                producer.process(subExchange);
                if (aggregationStrategy != null) {
                    if (result == null) {
                        result = subExchange;
                    } else {
                        result = aggregationStrategy.aggregate(result, subExchange);
                    }
                }
                i++;
            }
        }
        if (result != null) {
            ExchangeHelper.copyResults(exchange, result);
        }
    }
    protected void updateNewExchange(Exchange exchange, int i, List<ProcessorExchangePair> allPairs) {
        // No updates needed
    }
    protected List<ProcessorExchangePair> createProcessorExchangePairs(
        Exchange exchange) {
        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());
        Processor[] processorsArray = processors.toArray(new Processor[processors.size()]);
        for (int i = 0; i < processorsArray.length; i++) {
            result.add(new ProcessorExchangePair(processorsArray[i], exchange.copy()));
        }
        return result;
    }
    protected void doStop() throws Exception {
        shutdown.set(true);
        if (executor != null) {
            executor.shutdown();
            executor.awaitTermination(0, TimeUnit.SECONDS);
        }
        ServiceHelper.stopServices(processors);
    }
    protected void doStart() throws Exception {
        shutdown.set(false);
        if (executor != null) {
            executor.setRejectedExecutionHandler(new RejectedExecutionHandler() {
                public void rejectedExecution(Runnable runnable, ThreadPoolExecutor executor) {
                    ProcessCall call = (ProcessCall)runnable;
                    call.exchange.setException(new RejectedExecutionException());
                    call.callback.done(false);
                }
            });
        }
        ServiceHelper.startServices(processors);
    }
    /**
     * Returns the producers to multicast to
     */
    public Collection<Processor> getProcessors() {
        return processors;
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
}
"
org.apache.camel.processor.MulticastStreamCachingTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.StringReader;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 658260 $
 */
public class MulticastStreamCachingTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendingAMessageUsingMulticastConvertsToReReadable() throws Exception {
        x.expectedBodiesReceived(""<input/>+output"");
        y.expectedBodiesReceived(""<input/>+output"");
        z.expectedBodiesReceived(""<input/>+output"");
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(new StreamSource(new StringReader(""<input/>"")));
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                // lets transform the IN message
                Message in = exchange.getIn();
                String body = in.getBody(String.class);
                in.setBody(body + ""+output"");
            }
        };
        return new RouteBuilder() {
            public void configure() {
                //stream caching should fix re-readability issues when multicasting messags
                from(""direct:a"").multicast().to(""direct:x"", ""direct:y"", ""direct:z"");
                from(""direct:x"").process(processor).to(""mock:x"");
                from(""direct:y"").process(processor).to(""mock:y"");
                from(""direct:z"").process(processor).to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.MulticastTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 659842 $
 */
public class MulticastTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        x.expectedBodiesReceived(""input+output"");
        y.expectedBodiesReceived(""input+output"");
        z.expectedBodiesReceived(""input+output"");
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""input"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                // lets transform the IN message
                Message in = exchange.getIn();
                String body = in.getBody(String.class);
                in.setBody(body + ""+output"");
            }
        };
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").multicast().to(""direct:x"", ""direct:y"", ""direct:z"");
                // END SNIPPET: example
                from(""direct:x"").process(processor).to(""mock:x"");
                from(""direct:y"").process(processor).to(""mock:y"");
                from(""direct:z"").process(processor).to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.MyAggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Header;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
/**
 * @version $Revision: 664441 $
*/
public class MyAggregationStrategy extends UseLatestAggregationStrategy {
    @Override
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        Exchange result = super.aggregate(oldExchange, newExchange);
        Integer old = (Integer) oldExchange.getProperty(""aggregated"");
        if (old == null) {
            old = 1;
        }
        result.setProperty(""aggregated"", old + 1);
        return result;
    }
    /**
     * An expression used to determine if the aggregation is complete
     */
    public boolean isCompleted(@Header(name = ""aggregated"")
                               Integer aggregated) {
        if (aggregated == null) {
            return false;
        }
        return aggregated == 5;
    }
}
"
org.apache.camel.processor.MyValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
/**
 * @version $Revision: 630568 $
 */
public class MyValidator implements Processor {
    public void process(Exchange exchange) throws Exception {
        Object value = exchange.getIn().getHeader(""foo"");
        if (value == null || !value.equals(""bar"")) {
            throw new ValidationException(exchange, ""The foo header does not equal bar! Was: "" + value);
        }
    }
}
"
org.apache.camel.processor.Pipeline,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Creates a Pipeline pattern where the output of the previous step is sent as
 * input to the next step, reusing the same message exchanges
 *
 * @version $Revision: 676606 $
 */
public class Pipeline extends MulticastProcessor implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(Pipeline.class);
    public Pipeline(Collection<Processor> processors) {
        super(processors);
    }
    public static Processor newInstance(List<Processor> processors) {
        if (processors.isEmpty()) {
            return null;
        } else if (processors.size() == 1) {
            return processors.get(0);
        }
        return new Pipeline(processors);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange original, AsyncCallback callback) {
        Iterator<Processor> processors = getProcessors().iterator();
        Exchange nextExchange = original;
        boolean first = true;
        while (true) {
            if (nextExchange.isFailed()) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Message exchange has failed so breaking out of pipeline: "" + nextExchange
                              + "" exception: "" + nextExchange.getException() + "" fault: ""
                              + nextExchange.getFault(false));
                }
                break;
            }
            if (!processors.hasNext()) {
                break;
            }
            AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());
            if (first) {
                first = false;
            } else {
                nextExchange = createNextExchange(processor, nextExchange);
            }
            boolean sync = process(original, nextExchange, callback, processors, processor);
            // Continue processing the pipeline synchronously ...
            if (!sync) {
                // The pipeline will be completed async...
                return false;
            }
        }
        // If we get here then the pipeline was processed entirely
        // synchronously.
        ExchangeHelper.copyResults(original, nextExchange);
        callback.done(true);
        return true;
    }
    private boolean process(final Exchange original, final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, AsyncProcessor processor) {
        return processor.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                // We only have to handle async completion of
                // the pipeline..
                if (sync) {
                    return;
                }
                // Continue processing the pipeline...
                Exchange nextExchange = exchange;
                while (processors.hasNext()) {
                    AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());
                    if (nextExchange.isFailed()) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Message exchange has failed so breaking out of pipeline: "" + nextExchange + "" exception: "" + nextExchange.getException() + "" fault: ""
                                    + nextExchange.getFault(false));
                        }
                        break;
                    }
                    nextExchange = createNextExchange(processor, nextExchange);
                    sync = process(original, nextExchange, callback, processors, processor);
                    if (!sync) {
                        return;
                    }
                }
                ExchangeHelper.copyResults(original, nextExchange);
                callback.done(false);
            }
        });
    }
    /**
     * Strategy method to create the next exchange from the previous exchange.
     *
     * @param producer         the producer used to send to the endpoint
     * @param previousExchange the previous exchange
     * @return a new exchange
     */
    protected Exchange createNextExchange(Processor producer, Exchange previousExchange) {
        Exchange answer = previousExchange.newInstance();
        answer.getProperties().putAll(previousExchange.getProperties());
        // now lets set the input of the next exchange to the output of the
        // previous message if it is not null
        Message previousOut = previousExchange.getOut(false);
        Message in = answer.getIn();
        if (previousOut != null) {
            in.copyFrom(previousOut);
        } else {
            in.copyFrom(previousExchange.getIn());
        }
        return answer;
    }
    @Override
    public String toString() {
        return ""Pipeline"" + getProcessors();
    }
}
"
org.apache.camel.processor.PipelineConcurrentTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Random;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
/**
 * Unit test the pipeline in concurrent conditions.
 */
public class PipelineConcurrentTest extends ContextTestSupport {
    public void testConcurrentPipeline() throws Exception {
        int total = 10000;
        final int group = total / 20;
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(total);
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.afterPropertiesSet();
        for (int i = 0; i < 20; i++) {
            final int threadCount = i;
            executor.execute(new Runnable() {
                public void run() {
                    int start = threadCount * group;
                    for (int i = 0; i < group; i++) {
                        try {
                            // do some random sleep to simulate spread in user activity
                            Thread.sleep(new Random().nextInt(10));
                        } catch (InterruptedException e) {
                            // ignore
                        }
                        template.sendBody(""seda:in"", """" + (start + i));
                    }
                }
            });
        }
        mock.assertIsSatisfied();
        mock.expectsNoDuplicates(body());
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // to force any exceptions coming forward imeddiately
                errorHandler(noErrorHandler());
                from(""seda:in"")
                    .thread(10)
                    .pipeline(""direct:do"", ""mock:result"");
                from(""direct:do"")
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            String body = exchange.getIn().getBody(String.class);
                            exchange.getOut().setBody(""Bye "" + body);
                        }
                    });
            }
        };
    }
}
"
org.apache.camel.processor.PipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class PipelineTest extends ContextTestSupport {
    /**
     * Simple processor the copies the in to the out and increments a counter.
     * Used to verify that the pipeline actually takes the output of one stage of 
     * the pipe and feeds it in as input into the next stage.
     */
    private final class InToOut implements Processor {
        public void process(Exchange exchange) throws Exception {            
            exchange.getOut(true).copyFrom(exchange.getIn());
            Integer counter = exchange.getIn().getHeader(""copy-counter"", Integer.class);
            if (counter == null) {
                counter = 0;
            }
            exchange.getOut().setHeader(""copy-counter"", counter + 1);
        }
    }
    /**
     * Simple processor the copies the in to the fault and increments a counter.
     */
    private final class InToFault implements Processor {
        public void process(Exchange exchange) throws Exception {
            exchange.getFault(true).setBody(exchange.getIn().getBody());
            Integer counter = exchange.getIn().getHeader(""copy-counter"", Integer.class);
            if (counter == null) {
                counter = 0;
            }
            exchange.getFault().setHeader(""copy-counter"", counter + 1);
        }
    }
    protected MockEndpoint resultEndpoint;
    public void testSendMessageThroughAPipeline() throws Exception {
        resultEndpoint.expectedBodiesReceived(4);
        Exchange results = template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertEquals(""Result body"", 4, results.getOut().getBody());
    }
    public void testResultsReturned() throws Exception {
        Exchange exchange = template.send(""direct:b"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setBody(""Hello World"");
            }
        });
        assertEquals(""Hello World"", exchange.getOut().getBody());
        assertEquals(3, exchange.getOut().getHeader(""copy-counter""));        
    }
    /**
     * Disabled for now until we figure out fault processing in the pipeline.
     * 
     * @throws Exception
     */
    public void testFaultStopsPipeline() throws Exception {
        Exchange exchange = template.send(""direct:c"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setBody(""Fault Message"");
            }
        });
        // Check the fault..
        assertEquals(""Fault Message"", exchange.getFault().getBody());
        assertEquals(2, exchange.getFault().getHeader(""copy-counter""));        
        // Check the out Message.. It should have only been processed once.
        // since the fault should stop it from going to the next process.
        assertEquals(1, exchange.getOut().getHeader(""copy-counter""));                
    }
    public void testOnlyProperties() {
        Exchange exchange = template.send(""direct:b"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setHeader(""header"", ""headerValue"");
            }
        });
        assertEquals(""headerValue"", exchange.getOut().getHeader(""header""));
        assertEquals(3, exchange.getOut().getHeader(""copy-counter""));  
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                Integer number = exchange.getIn().getBody(Integer.class);
                if (number == null) {
                    number = 0;
                }
                // todo set the endpoint name we were received from
                //exchange.setProperty(exchange.get);
                number = number + 1;
                exchange.getOut().setBody(number);
            }
        };
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").pipeline(""direct:x"", ""direct:y"", ""direct:z"", ""mock:result"");
                // END SNIPPET: example
                from(""direct:x"").process(processor);
                from(""direct:y"").process(processor);
                from(""direct:z"").process(processor);
                // Create a route that uses the  InToOut processor 3 times. the copy-counter header should be == 3
                from(""direct:b"").process(new InToOut()).process(new InToOut()).process(new InToOut());
                // Create a route that uses the  InToFault processor.. the last InToOut will not be called since the Fault occurs before.
                from(""direct:c"").process(new InToOut()).process(new InToFault()).process(new InToOut());
            }
        };
    }
}
"
org.apache.camel.processor.ProceedProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A {@link Processor} which proceeds on an {@link Interceptor}
 *
 * @version $Revision: 640438 $
 */
public class ProceedProcessor implements Processor {
    private final Interceptor interceptor;
    public ProceedProcessor(Interceptor interceptor) {
        this.interceptor = interceptor;
    }
    public String toString() {
        return ""Proceed["" + interceptor + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        interceptor.proceed(exchange);
    }
}
"
org.apache.camel.processor.RecipientList,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.ProducerCache;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
import org.apache.camel.util.ExchangeHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements a dynamic <a
 * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient List</a>
 * pattern where the list of actual endpoints to send a message exchange to are
 * dependent on some dynamic expression.
 *
 * @version $Revision: 659638 $
 */
public class RecipientList extends ServiceSupport implements Processor {
    private final Expression<Exchange> expression;
    private ProducerCache<Exchange> producerCache = new ProducerCache<Exchange>();
    public RecipientList(Expression<Exchange> expression) {
        notNull(expression, ""expression"");
        this.expression = expression;
    }
    @Override
    public String toString() {
        return ""RecipientList["" + expression + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Object receipientList = expression.evaluate(exchange);
        Iterator iter = ObjectConverter.iterator(receipientList);
        List<Processor> processors = new ArrayList<Processor>();
        while (iter.hasNext()) {
            Object recipient = iter.next();
            Endpoint<Exchange> endpoint = resolveEndpoint(exchange, recipient);
            Producer<Exchange> producer = producerCache.getProducer(endpoint);
            processors.add(producer);
        }
        MulticastProcessor mp = new MulticastProcessor(processors, new UseLatestAggregationStrategy());
        mp.process(exchange);
    }
    protected Endpoint<Exchange> resolveEndpoint(Exchange exchange, Object recipient) {
        return ExchangeHelper.resolveEndpoint(exchange, recipient);
    }
    protected void doStop() throws Exception {
        producerCache.stop();
    }
    protected void doStart() throws Exception {
    }
}
"
org.apache.camel.processor.RecipientListTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 659842 $
 */
public class RecipientListTest extends ContextTestSupport {
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        x.expectedBodiesReceived(""answer"");
        y.expectedBodiesReceived(""answer"");
        z.expectedBodiesReceived(""answer"");
        sendBody();
        assertMockEndpointsSatisifed();
    }
    protected void sendBody() {
        template.sendBodyAndHeader(""direct:a"", ""answer"", ""recipientListHeader"",
                ""mock:x,mock:y,mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").recipientList(
                        header(""recipientListHeader"").tokenize("",""));
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.RedeliveryPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.Serializable;
import java.util.Random;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
// Code taken from the ActiveMQ codebase
/**
 * The policy used to decide how many times to redeliver and the time between
 * the redeliveries before being sent to a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a>
 * <p>
 * The default values is:
 * <ul>
 *   <li>maximumRedeliveries = 6</li>
 *   <li>initialRedeliveryDelay = 1000L</li>
 *   <li>maximumRedeliveryDelay = 60 * 1000L</li>
 *   <li>backOffMultiplier = 2</li>
 *   <li>useExponentialBackOff = false</li>
 *   <li>collisionAvoidanceFactor = 0.15d</li>
 *   <li>useCollisionAvoidance = false</li>
 * </ul>
 *
 * @version $Revision: 674383 $
 */
public class RedeliveryPolicy implements Cloneable, Serializable {
    protected static transient Random randomNumberGenerator;
    private static final transient Log LOG = LogFactory.getLog(RedeliveryPolicy.class);
    protected int maximumRedeliveries = 6;
    protected long initialRedeliveryDelay = 1000L;
    protected long maximumRedeliveryDelay = 60 * 1000L;
    protected double backOffMultiplier = 2;
    protected boolean useExponentialBackOff;
    // +/-15% for a 30% spread -cgs
    protected double collisionAvoidanceFactor = 0.15d;
    protected boolean useCollisionAvoidance;
    public RedeliveryPolicy() {
    }
    @Override
    public String toString() {
        return ""RedeliveryPolicy[maximumRedeliveries="" + maximumRedeliveries + ""]"";
    }
    public RedeliveryPolicy copy() {
        try {
            return (RedeliveryPolicy)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(""Could not clone: "" + e, e);
        }
    }
    /**
     * Returns true if the policy decides that the message exchange should be
     * redelivered
     */
    public boolean shouldRedeliver(int redeliveryCounter) {
        if (getMaximumRedeliveries() < 0) {
            return true;
        }
        return redeliveryCounter < getMaximumRedeliveries();
    }
    /**
     * Calculates the new redelivery delay based on the last one then sleeps for the necessary amount of time
     */
    public long sleep(long redeliveryDelay) {
        redeliveryDelay = getRedeliveryDelay(redeliveryDelay);
        if (redeliveryDelay > 0) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Sleeping for: "" + redeliveryDelay + "" millis until attempting redelivery"");
            }
            try {
                Thread.sleep(redeliveryDelay);
            } catch (InterruptedException e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Thread interrupted: "" + e, e);
                }
            }
        }
        return redeliveryDelay;
    }
    public long getRedeliveryDelay(long previousDelay) {
        long redeliveryDelay;
        if (previousDelay == 0) {
            redeliveryDelay = initialRedeliveryDelay;
        } else if (useExponentialBackOff && backOffMultiplier > 1) {
            redeliveryDelay = Math.round(backOffMultiplier * previousDelay);
        } else {
            redeliveryDelay = previousDelay;
        }
        if (useCollisionAvoidance) {
            /*
             * First random determines +/-, second random determines how far to
             * go in that direction. -cgs
             */
            Random random = getRandomNumberGenerator();
            double variance = (random.nextBoolean() ? collisionAvoidanceFactor : -collisionAvoidanceFactor)
                              * random.nextDouble();
            redeliveryDelay += redeliveryDelay * variance;
        }
        if (maximumRedeliveryDelay > 0 && redeliveryDelay > maximumRedeliveryDelay) {
            redeliveryDelay = maximumRedeliveryDelay;
        }
        return redeliveryDelay;
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Sets the maximum number of times a message exchange will be redelivered
     */
    public RedeliveryPolicy maximumRedeliveries(int maximumRedeliveries) {
        setMaximumRedeliveries(maximumRedeliveries);
        return this;
    }
    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     */
    public RedeliveryPolicy initialRedeliveryDelay(long initialRedeliveryDelay) {
        setInitialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    /**
     * Enables collision avoidence which adds some randomization to the backoff
     * timings to reduce contention probability
     */
    public RedeliveryPolicy useCollisionAvoidance() {
        setUseCollisionAvoidance(true);
        return this;
    }
    /**
     * Enables exponential backof using the {@link #getBackOffMultiplier()} to
     * increase the time between retries
     */
    public RedeliveryPolicy useExponentialBackOff() {
        setUseExponentialBackOff(true);
        return this;
    }
    /**
     * Enables exponential backoff and sets the multiplier used to increase the
     * delay between redeliveries
     */
    public RedeliveryPolicy backOffMultiplier(double multiplier) {
        useExponentialBackOff();
        setBackOffMultiplier(multiplier);
        return this;
    }
    /**
     * Enables collision avoidence and sets the percentage used
     */
    public RedeliveryPolicy collisionAvoidancePercent(double collisionAvoidancePercent) {
        useCollisionAvoidance();
        setCollisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    /**
     * Sets the maximum redelivery delay if using exponential back off.
     * Use -1 if you wish to have no maximum
     */
    public RedeliveryPolicy maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        setMaximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public double getBackOffMultiplier() {
        return backOffMultiplier;
    }
    /**
     * Sets the multiplier used to increase the delay between redeliveries if
     * {@link #setUseExponentialBackOff(boolean)} is enabled
     */
    public void setBackOffMultiplier(double backOffMultiplier) {
        this.backOffMultiplier = backOffMultiplier;
    }
    public short getCollisionAvoidancePercent() {
        return (short)Math.round(collisionAvoidanceFactor * 100);
    }
    /**
     * Sets the percentage used for collision avoidence if enabled via
     * {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidancePercent(double collisionAvoidancePercent) {
        this.collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d;
    }
    public double getCollisionAvoidanceFactor() {
        return collisionAvoidanceFactor;
    }
    /**
     * Sets the factor used for collision avoidence if enabled via
     * {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidanceFactor(double collisionAvoidanceFactor) {
        this.collisionAvoidanceFactor = collisionAvoidanceFactor;
    }
    public long getInitialRedeliveryDelay() {
        return initialRedeliveryDelay;
    }
    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     */
    public void setInitialRedeliveryDelay(long initialRedeliveryDelay) {
        this.initialRedeliveryDelay = initialRedeliveryDelay;
    }
    public int getMaximumRedeliveries() {
        return maximumRedeliveries;
    }
    /**
     * Sets the maximum number of times a message exchange will be redelivered.
     * Setting a negative value will retry forever.
     */
    public void setMaximumRedeliveries(int maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }
    public long getMaximumRedeliveryDelay() {
        return maximumRedeliveryDelay;
    }
    /**
     * Sets the maximum redelivery delay if using exponential back off.
     * Use -1 if you wish to have no maximum
     */
    public void setMaximumRedeliveryDelay(long maximumRedeliveryDelay) {
        this.maximumRedeliveryDelay = maximumRedeliveryDelay;
    }
    public boolean isUseCollisionAvoidance() {
        return useCollisionAvoidance;
    }
    /**
     * Enables/disables collision avoidence which adds some randomization to the
     * backoff timings to reduce contention probability
     */
    public void setUseCollisionAvoidance(boolean useCollisionAvoidance) {
        this.useCollisionAvoidance = useCollisionAvoidance;
    }
    public boolean isUseExponentialBackOff() {
        return useExponentialBackOff;
    }
    /**
     * Enables/disables exponential backof using the
     * {@link #getBackOffMultiplier()} to increase the time between retries
     */
    public void setUseExponentialBackOff(boolean useExponentialBackOff) {
        this.useExponentialBackOff = useExponentialBackOff;
    }
    protected static synchronized Random getRandomNumberGenerator() {
        if (randomNumberGenerator == null) {
            randomNumberGenerator = new Random();
        }
        return randomNumberGenerator;
    }
}
"
org.apache.camel.processor.RedeliveryPolicyPerExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class RedeliveryPolicyPerExceptionTest extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    public void testUsingCustomExceptionHandlerAndOneRedelivery() throws Exception {
        a.expectedMessageCount(1);
        sendBody(""direct:start"", ""a"");
        MockEndpoint.assertIsSatisfied(a, b);
        List<Exchange> list = a.getReceivedExchanges();
        assertTrue(""List should not be empty!"", !list.isEmpty());
        Exchange exchange = list.get(0);
        Message in = exchange.getIn();
        log.info(""Found message with headers: "" + in.getHeaders());
        assertMessageHeader(in, DeadLetterChannel.REDELIVERY_COUNTER, 2);
        assertMessageHeader(in, DeadLetterChannel.REDELIVERED, true);
    }
    public void testUsingCustomExceptionHandlerWithNoRedeliveries() throws Exception {
        b.expectedMessageCount(1);
        sendBody(""direct:start"", ""b"");
        MockEndpoint.assertIsSatisfied(a, b);
        List<Exchange> list = b.getReceivedExchanges();
        assertTrue(""List should not be empty!"", !list.isEmpty());
        Exchange exchange = list.get(0);
        Message in = exchange.getIn();
        log.info(""Found message with headers: "" + in.getHeaders());
        assertMessageHeader(in, DeadLetterChannel.REDELIVERY_COUNTER, 1);
        assertMessageHeader(in, DeadLetterChannel.REDELIVERED, true);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = resolveMandatoryEndpoint(""mock:a"", MockEndpoint.class);
        b = resolveMandatoryEndpoint(""mock:b"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                if (""b"".equals(exchange.getIn().getBody())) {
                    throw new NullPointerException(""MyCustomException"");
                } else {
                    throw new IllegalArgumentException(""MyCustomException"");
                }
            }
        };
        return new RouteBuilder() {
            public void configure() {
                exception(IllegalArgumentException.class).maximumRedeliveries(2).to(""mock:a"");
                exception(NullPointerException.class).to(""mock:b"");
                from(""direct:start"").process(processor);
            }
        };
    }
}
"
org.apache.camel.processor.Resequencer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.util.ExpressionComparator;
import org.apache.camel.util.ExpressionListComparator;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
 * which can reorder messages within a batch.
 *
 * @version $Revision: 630591 $
 */
public class Resequencer extends BatchProcessor {
    public Resequencer(Endpoint endpoint, Processor processor, Expression<Exchange> expression) {
        this(endpoint, processor, createSet(expression));
    }
    public Resequencer(Endpoint endpoint, Processor processor, List<Expression> expressions) {
        this(endpoint, processor, createSet(expressions));
    }
    public Resequencer(Endpoint endpoint, Processor processor, Set<Exchange> collection) {
        super(endpoint, processor, collection);
    }
    @Override
    public String toString() {
        return ""Resequencer[to: "" + getProcessor() + ""]"";
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected static Set<Exchange> createSet(Expression<Exchange> expression) {
        return createSet(new ExpressionComparator<Exchange>(expression));
    }
    protected static Set<Exchange> createSet(List<Expression> expressions) {
        if (expressions.size() == 1) {
            return createSet(expressions.get(0));
        }
        return createSet(new ExpressionListComparator(expressions));
    }
    protected static Set<Exchange> createSet(Comparator<? super Exchange> comparator) {
        return new TreeSet<Exchange>(comparator);
    }
}
"
org.apache.camel.processor.ResequencerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.management.InstrumentationProcessor;
import org.apache.camel.management.JmxSystemPropertyKeys;
/**
 * @version $Revision: 671020 $
 */
public class ResequencerTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Guillaume"", ""Hiram"", ""James"", ""Rob"");
        sendBodies(""direct:start"", ""Rob"", ""Hiram"", ""Guillaume"", ""James"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    @Override 
    protected void tearDown() throws Exception {
        super.tearDown();
        System.clearProperty(JmxSystemPropertyKeys.DISABLED);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").resequencer(body()).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
    public void testBatchResequencerTypeWithJmx() throws Exception {
        System.setProperty(JmxSystemPropertyKeys.DISABLED, ""true"");
        List<Route> list = getRouteList(createRouteBuilder());
        assertEquals(""Number of routes created: "" + list, 1, list.size());
        Route route = list.get(0);
        assertTrue(route.toString().startsWith(""BatchResequencerRoute""));
    }
    public void testBatchResequencerTypeWithoutJmx() throws Exception {
        List<Route> list = getRouteList(createRouteBuilder());
        assertEquals(""Number of routes created: "" + list, 1, list.size());
        Route route = list.get(0);
        EventDrivenConsumerRoute consumerRoute =
            assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
        Processor processor = unwrap(consumerRoute.getProcessor());
        DeadLetterChannel deadLetterChannel =
            assertIsInstanceOf(DeadLetterChannel.class, processor);
        Processor outputProcessor = deadLetterChannel.getOutput();
        InstrumentationProcessor interceptor =
                assertIsInstanceOf(InstrumentationProcessor.class, outputProcessor);
        outputProcessor = interceptor.getProcessor();
        assertIsInstanceOf(Resequencer.class, outputProcessor);
    }
}
"
org.apache.camel.processor.RoutingSlip,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ProducerCache;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.RoutingSlipType;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements a <a
 * href=""http://activemq.apache.org/camel/routing-slip.html"">Routing Slip</a>
 * pattern where the list of actual endpoints to send a message exchange to are
 * dependent on the value of a message header.
 */
public class RoutingSlip extends ServiceSupport implements Processor {
    private static final transient Log LOG = LogFactory.getLog(RoutingSlip.class);
    private final String header;
    private final String uriDelimiter;
    private ProducerCache<Exchange> producerCache = new ProducerCache<Exchange>();
    public RoutingSlip(String header) {
        this(header, RoutingSlipType.DEFAULT_DELIMITER);
    }
    public RoutingSlip(String header, String uriDelimiter) {
        notNull(header, ""header"");
        notNull(uriDelimiter, ""uriDelimiter"");
        this.header = header;
        this.uriDelimiter = uriDelimiter;
    }
    @Override
    public String toString() {
        return ""RoutingSlip[header="" + header + "" uriDelimiter="" + uriDelimiter + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Message message = exchange.getIn();
        String[] recipients = recipients(message);
        Exchange current = exchange;
        for (String nextRecipient : recipients) {
            Endpoint<Exchange> endpoint = resolveEndpoint(exchange, nextRecipient);
            Producer<Exchange> producer = producerCache.getProducer(endpoint);
            Exchange ex = endpoint.createExchange(ExchangePattern.InOut);
            updateRoutingSlip(current);
            copyOutToIn(ex, current);
            producer.process(ex);
            current = ex;
        }
        ExchangeHelper.copyResults(exchange, current);
    }
    protected Endpoint<Exchange> resolveEndpoint(Exchange exchange, Object recipient) {
        return ExchangeHelper.resolveEndpoint(exchange, recipient);
    }
    protected void doStop() throws Exception {
        producerCache.stop();
    }
    protected void doStart() throws Exception {
    }
    private void updateRoutingSlip(Exchange current) {
        Message message = getResultMessage(current);
        message.setHeader(header, removeFirstElement(recipients(message)));
    }
    /**
     * Returns the outbound message if available. Otherwise return the inbound
     * message.
     */
    private Message getResultMessage(Exchange exchange) {
        Message message = exchange.getOut(false);
        // if this endpoint had no out (like a mock endpoint)
        // just take the in
        if (message == null) {
            message = exchange.getIn();
        }
        return message;
    }
    /**
     * Return the list of recipients defined in the routing slip in the
     * specified message.
     */
    private String[] recipients(Message message) {
        Object headerValue = message.getHeader(header);
        if (headerValue != null && !headerValue.equals("""")) {
            return headerValue.toString().split(uriDelimiter);
        }
        return new String[] {};
    }
    /**
     * Return a string representation of the element list with the first element
     * removed.
     */
    private String removeFirstElement(String[] elements) {
        CollectionStringBuffer updatedElements = new CollectionStringBuffer(uriDelimiter);
        for (int i = 1; i < elements.length; i++) {
            updatedElements.append(elements[i]);
        }
        return updatedElements.toString();
    }
    /**
     * Copy the outbound data in 'source' to the inbound data in 'result'.
     */
    private void copyOutToIn(Exchange result, Exchange source) {
        result.setException(source.getException());
        Message fault = source.getFault(false);
        if (fault != null) {
            result.getFault(true).copyFrom(fault);
        }
        result.setIn(getResultMessage(source));
        result.getProperties().clear();
        result.getProperties().putAll(source.getProperties());
    }
}
"
org.apache.camel.processor.SendProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Processor for forwarding exchanges to an endpoint destination.
 *
 * @version $Revision: 659760 $
 */
public class SendProcessor extends ServiceSupport implements AsyncProcessor, Service {
    private static final transient Log LOG = LogFactory.getLog(SendProcessor.class);
    private Endpoint destination;
    private Producer producer;
    private AsyncProcessor processor;
    public SendProcessor(Endpoint destination) {
        if (destination == null) {
            throw new IllegalArgumentException(""Endpoint cannot be null!"");
        }
        this.destination = destination;
    }
    @Override
    public String toString() {
        return ""sendTo("" + destination + "")"";
    }
    public void process(Exchange exchange) throws Exception {
        if (producer == null) {
            if (isStopped()) {
                LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            } else {
                throw new IllegalStateException(""No producer, this processor has not been started!"");
            }
        } else {
            producer.process(exchange);
        }
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        if (producer == null) {
            if (isStopped()) {
                LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            } else {
                exchange.setException(new IllegalStateException(""No producer, this processor has not been started!""));
            }
            callback.done(true);
            return true;
        } else {
            return processor.process(exchange, callback);
        }
    }
    public Endpoint getDestination() {
        return destination;
    }
    protected void doStart() throws Exception {
        this.producer = destination.createProducer();
        this.producer.start();
        this.processor = AsyncProcessorTypeConverter.convert(producer);
    }
    protected void doStop() throws Exception {
        if (producer != null) {
            try {
                producer.stop();
            } finally {
                producer = null;
                processor = null;
            }
        }
    }
}
"
org.apache.camel.processor.SendToNonExistingEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.NoSuchEndpointException;
/**
 * @version $Revision: 630568 $
 */
public class SendToNonExistingEndpointTest extends ContextTestSupport {
    public void testSendToNonExistingEndpoint() throws Exception {
        try {
            template.sendBody(""thisUriDoesNotExist"", ""<hello>world!</hello>"");
            fail(""Should have failed to send this message!"");
        } catch (NoSuchEndpointException e) {
            log.debug(""Caught expected exception: "" + e, e);
            assertEquals(""uri"", ""thisUriDoesNotExist"", e.getUri());
        }
    }
}
"
org.apache.camel.processor.SetHeaderProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A processor which sets the header on the IN message
 */
public class SetHeaderProcessor extends DelegateProcessor implements Processor {
    private static final transient Log LOG = LogFactory.getLog(SetHeaderProcessor.class);
    private String name;
    private Expression expression;
    public SetHeaderProcessor(String name, Expression expression) {
        this.name = name;
        this.expression = expression;
    }
    public SetHeaderProcessor(String name, Expression expression,
            Processor childProcessor) {
        super(childProcessor);
        this.name = name;
        this.expression = expression;
    }
    public void process(Exchange exchange) throws Exception {
        Object value = expression.evaluate(exchange);
        if (value == null) {
            LOG.warn(""Expression: "" + expression
                    + "" on exchange: "" + exchange + "" evaluated to null."");
        }
        exchange.getIn().setHeader(name, value);
        super.process(exchange);
    }
    @Override
    public String toString() {
        return ""setHeader("" + name + "", "" + expression + "")"";
    }
}
"
org.apache.camel.processor.SetHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 640438 $
 */
public class SetHeaderTest extends ContextTestSupport {
    protected String matchingBody = ""<person name='James' city='London'/>"";
    public void testSendMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(1);
        sendBody(""direct:start"", matchingBody);
        assertMockEndpointsSatisifed();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        Exchange exchange = list.get(0);
        Object value = exchange.getIn().getHeader(""foo"");
        assertEquals(""foo header"", ""London"", value);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                Namespaces ns = new Namespaces(""foo"", ""urn:cheese"");
                from(""direct:start"").
                        unmarshal().string().
                        setHeader(""foo"").xpath(""/person[@name='James']/@city"", String.class).
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.SetHeaderUsingDslExpressionsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 647433 $
 */
public class SetHeaderUsingDslExpressionsTest extends ContextTestSupport {
    protected String body = ""<person name='James' city='London'/>"";
    protected MockEndpoint expected;
    public void testUseConstant() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").constant(""ABC"").
                        to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisifed();
    }
    public void testUseConstantParameter() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"", ""ABC"").
                        to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisifed();
    }
    public void testUseExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").setHeader(""foo"").expression(new ExpressionAdapter() {
                    public Object evaluate(Exchange exchange) {
                        return ""ABC"";
                    }
                }).to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisifed();
    }
    public void testUseHeaderExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").header(""bar"").
                        to(""mock:result"");
            }
        });
        template.sendBodyAndHeader(""direct:start"", body, ""bar"", ""ABC"");
        assertMockEndpointsSatisifed();
    }
    public void testUseBodyExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").body().
                        to(""mock:result"");
            }
        });
        template.sendBody(""direct:start"", ""ABC"");
        assertMockEndpointsSatisifed();
    }
    public void testUseBodyAsTypeExpression() throws Exception {
        context.addRoutes(new RouteBuilder() {
            public void configure() throws Exception {
                from(""direct:start"").
                        setHeader(""foo"").body(String.class).
                        to(""mock:result"");
            }
        });
        template.sendBody(""direct:start"", ""ABC"".getBytes());
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        expected = getMockEndpoint(""mock:result"");
        expected.message(0).header(""foo"").isEqualTo(""ABC"");
    }
}
"
org.apache.camel.processor.SetOutBodyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
/*
 * This tests whether the deprecated setOutBody method in ProcessorType behaves the
 * same as the new transform method.  
 */
public class SetOutBodyTest extends TransformProcessorTest {
    @SuppressWarnings(""deprecation"")
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").setOutBody(body().append("" World!"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.SimulatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.InvalidPayloadException;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.jndi.JndiContext;
import static org.apache.camel.language.simple.SimpleLanguage.simple;
/**
 * @version $Revision: 676826 $
 */
public class SimulatorTest extends ContextTestSupport {
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""foo"", new MyBean(""foo""));
        answer.bind(""bar"", new MyBean(""bar""));
        return answer;
    }
    public void testReceivesFooResponse() throws Exception {
        assertRespondsWith(""foo"", ""Bye said foo"");
    }
    public void testReceivesBarResponse() throws Exception {
        assertRespondsWith(""bar"", ""Bye said bar"");
    }
    protected void assertRespondsWith(final String value, String containedText)
        throws InvalidPayloadException {
        Exchange response = template.request(""direct:a"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                Message in = exchange.getIn();
                in.setBody(""answer"");
                in.setHeader(""cheese"", value);
            }
        });
        assertNotNull(""Should receive a response!"", response);
        String text = ExchangeHelper.getMandatoryOutBody(response, String.class);
        assertStringContains(text, containedText);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").
                    recipientList(simple(""bean:${in.header.cheese}""));
                // END SNIPPET: example
            }
        };
    }
    public static class MyBean {
        private String value;
        public MyBean(String value) {
            this.value = value;
        }
        public String doSomething(String in) {
            return ""Bye said "" + value;
        }
    }
}
"
org.apache.camel.processor.Splitter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ThreadPoolExecutor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.util.CollectionHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements a dynamic <a
 * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a> pattern
 * where an expression is evaluated to iterate through each of the parts of a
 * message and then each part is then send to some endpoint.
 *
 * @version $Revision: 645359 $
 */
public class Splitter extends MulticastProcessor implements Processor {
    public static final String SPLIT_SIZE = ""org.apache.camel.splitSize"";
    public static final String SPLIT_COUNTER = ""org.apache.camel.splitCounter"";
    private final Expression expression;
    public Splitter(Expression expression, Processor destination, AggregationStrategy aggregationStrategy) {
        this(expression, destination, aggregationStrategy, false, null);
    }
    public Splitter(Expression expression, Processor destination,
            AggregationStrategy aggregationStrategy,
            boolean parallelProcessing, ThreadPoolExecutor threadPoolExecutor) {
        super(Collections.singleton(destination), aggregationStrategy, parallelProcessing, threadPoolExecutor);
        this.expression = expression;
        notNull(expression, ""expression"");
        notNull(destination, ""destination"");
    }
    @Override
    public String toString() {
        return ""Splitter[on: "" + expression + "" to: "" + getProcessors().iterator().next() + "" aggregate: "" + getAggregationStrategy() + ""]"";
    }
    @Override
    protected List<ProcessorExchangePair> createProcessorExchangePairs(
        Exchange exchange) {
        Object value = expression.evaluate(exchange);
        Integer collectionSize = CollectionHelper.size(value);
        List<ProcessorExchangePair> result;
        if (collectionSize != null) {
            result = new ArrayList<ProcessorExchangePair>(collectionSize);
        } else {
            result = new ArrayList<ProcessorExchangePair>();
        }
        Iterator<Object> iter = ObjectConverter.iterator(value);
        while (iter.hasNext()) {
            Object part = iter.next();
            Exchange newExchange = exchange.copy();
            Message in = newExchange.getIn();
            in.setBody(part);
            result.add(new ProcessorExchangePair(getProcessors().iterator().next(), newExchange));
        }
        return result;
    }
    @Override
    protected void updateNewExchange(Exchange exchange, int i, List<ProcessorExchangePair> allPairs) {
        exchange.getIn().setHeader(SPLIT_COUNTER, i);
        exchange.getIn().setHeader(SPLIT_SIZE, allPairs.size());
    }
}
"
org.apache.camel.processor.SplitterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
/**
 * @version $Revision: 645359 $
 */
public class SplitterTest extends ContextTestSupport {
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedBodiesReceived(""James"", ""Guillaume"", ""Hiram"", ""Rob"");
        template.send(""direct:seqential"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisifed();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        for (int i = 0; i < 4; i++) {
            Exchange exchange = list.get(i);
            Message in = exchange.getIn();
            assertMessageHeader(in, Splitter.SPLIT_COUNTER, i);
            assertMessageHeader(in, Splitter.SPLIT_SIZE, 4);
        }
    }
    public void testSpliterWithAggregationStrategy() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedBodiesReceived(""James"", ""Guillaume"", ""Hiram"", ""Rob"", ""Roman"");
        Exchange result = template.send(""direct:seqential"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob,Roman"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisifed();
        Message out = result.getOut();
        assertEquals(""Roman"", out.getBody());
        assertMessageHeader(out, ""foo"", ""bar"");
        assertMessageHeader(out, Splitter.SPLIT_COUNTER, 4);
    }
    public void testEmptyBody() {
        Exchange result = template.send(""direct:seqential"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setHeader(""foo"", ""bar"");
            }
        });
        assertNull(result.getOut(false));
    }
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchangeParallel() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectsNoDuplicates(body());
        resultEndpoint.expectedMessageCount(4);
        template.send(""direct:parallel"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisifed();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        Set<Integer> numbersFound = new TreeSet<Integer>();
        final String[] names = {""James"", ""Guillaume"", ""Hiram"", ""Rob""};
        for (int i = 0; i < 4; i++) {
            Exchange exchange = list.get(i);
            Message in = exchange.getIn();
            Integer splitCounter = in.getHeader(Splitter.SPLIT_COUNTER, Integer.class);
            numbersFound.add(splitCounter);
            assertEquals(names[splitCounter], in.getBody());
            assertMessageHeader(in, Splitter.SPLIT_SIZE, 4);
        }
        assertEquals(4, numbersFound.size());
    }
    public void testSpliterWithAggregationStrategyParallel() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(5);
        Exchange result = template.send(""direct:parallel"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob,Roman"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisifed();
        Message out = result.getOut();
        assertMessageHeader(out, ""foo"", ""bar"");
        assertEquals((Integer)5, result.getProperty(""aggregated"", Integer.class));
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:seqential"").splitter(body().tokenize("",""), new UseLatestAggregationStrategy()).to(""mock:result"");
                from(""direct:parallel"").splitter(body().tokenize("",""), new MyAggregationStrategy(), true).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.StaticRecipientListTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
public class StaticRecipientListTest extends RecipientListTest {
    @Override
    protected void sendBody() {
        template.sendBody(""direct:a"", ""answer"");
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").to(""mock:x"", ""mock:y"", ""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.StreamResequencer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.resequencer.ResequencerEngine;
import org.apache.camel.processor.resequencer.SequenceElementComparator;
import org.apache.camel.processor.resequencer.SequenceSender;
/**
 * A resequencer that re-orders a (continuous) stream of {@link Exchange}s. The
 * algorithm implemented by {@link ResequencerEngine} is based on the detection
 * of gaps in a message stream rather than on a fixed batch size. Gap detection
 * in combination with timeouts removes the constraint of having to know the
 * number of messages of a sequence (i.e. the batch size) in advance.
 * <p>
 * Messages must contain a unique sequence number for which a predecessor and a
 * successor is known. For example a message with the sequence number 3 has a
 * predecessor message with the sequence number 2 and a successor message with
 * the sequence number 4. The message sequence 2,3,5 has a gap because the
 * sucessor of 3 is missing. The resequencer therefore has to retain message 5
 * until message 4 arrives (or a timeout occurs).
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 630591 $
 */
public class StreamResequencer extends DelegateProcessor implements Processor {
    private ResequencerEngine<Exchange> reseq;
    private BlockingQueue<Exchange> queue;
    private SequenceSender sender;
    /**
     * Creates a new {@link StreamResequencer} instance.
     * 
     * @param processor
     *            the next processor that processes the re-ordered exchanges.
     * @param comparator
     *            a {@link SequenceElementComparator} for comparing sequence
     *            number contained in {@link Exchange}s.
     * @param capacity
     *            the capacity of the inbound queue.
     */
    public StreamResequencer(Processor processor, SequenceElementComparator<Exchange> comparator, int capacity) {
        super(processor);
        queue = new LinkedBlockingQueue<Exchange>();
        reseq = new ResequencerEngine<Exchange>(comparator, capacity);
        reseq.setOutQueue(queue);
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        sender = new SequenceSender(getProcessor());
        sender.setQueue(queue);
        sender.start();
    }
    @Override
    protected void doStop() throws Exception {
        reseq.stop();
        sender.cancel();
        super.doStop();
    }
    @Override
    public void process(Exchange exchange) throws Exception {
        reseq.put(exchange);
    }
    public long getTimeout() {
        return reseq.getTimeout();
    }
    public void setTimeout(long timeout) {
        reseq.setTimeout(timeout);
    }
    @Override
    public String toString() {
        return ""StreamResequencer[to: "" + getProcessor() + ""]"";
    }
}
"
org.apache.camel.processor.StreamResequencerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.management.InstrumentationProcessor;
import org.apache.camel.management.JmxSystemPropertyKeys;
public class StreamResequencerTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    protected void sendBodyAndHeader(String endpointUri, final Object body,
                                   final String headerName, final Object headerValue) {
        template.send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(headerName, headerValue);
                in.setHeader(""testCase"", getName());
            }
        });
    }
    public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {
        resultEndpoint.expectedBodiesReceived(""msg1"", ""msg2"", ""msg3"", ""msg4"");
        sendBodyAndHeader(""direct:start"", ""msg4"", ""seqnum"", 4L);
        sendBodyAndHeader(""direct:start"", ""msg1"", ""seqnum"", 1L);
        sendBodyAndHeader(""direct:start"", ""msg3"", ""seqnum"", 3L);
        sendBodyAndHeader(""direct:start"", ""msg2"", ""seqnum"", 2L);
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        System.clearProperty(JmxSystemPropertyKeys.DISABLED);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").resequencer(header(""seqnum"")).stream().to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
    public void testStreamResequencerTypeWithJmx() throws Exception {
        doTestStreamResequencerType();
    }
    public void testStreamResequencerTypeWithoutJmx() throws Exception {
        System.setProperty(JmxSystemPropertyKeys.DISABLED, ""true"");
        doTestStreamResequencerType();
    }
    protected void doTestStreamResequencerType() throws Exception {
        List<Route> list = getRouteList(createRouteBuilder());
        assertEquals(""Number of routes created: "" + list, 1, list.size());
        Route route = list.get(0);
        EventDrivenConsumerRoute consumerRoute =
            assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
        Processor processor = unwrap(consumerRoute.getProcessor());
        DeadLetterChannel deadLetterChannel = assertIsInstanceOf(DeadLetterChannel.class, processor);
        Processor outputProcessor = deadLetterChannel.getOutput();
        if (!Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {
            InstrumentationProcessor interceptor =
                assertIsInstanceOf(InstrumentationProcessor.class, outputProcessor);
            outputProcessor = interceptor.getProcessor();
        }
        assertIsInstanceOf(StreamResequencer.class, outputProcessor);
    }
}
"
org.apache.camel.processor.ThreadProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Service;
import org.apache.camel.util.AsyncProcessorHelper;
/**
 * A processor that forces async processing of the exchange using a thread pool.
 *
 * @version $Revision: 659491 $
 */
public class ThreadProcessor implements AsyncProcessor, Service {
    private ThreadPoolExecutor executor;
    private long stackSize;
    private ThreadGroup threadGroup;
    private int priority = Thread.NORM_PRIORITY;
    private boolean daemon = true;
    private String name = ""Thread Processor"";
    private BlockingQueue<Runnable> taskQueue;
    private long keepAliveTime;
    private int maxSize = 1;
    private int coreSize = 1;
    private final AtomicBoolean shutdown = new AtomicBoolean(true);
    private boolean callerRunsWhenRejected = true;
    class ProcessCall implements Runnable {
        private final Exchange exchange;
        private final AsyncCallback callback;
        public ProcessCall(Exchange exchange, AsyncCallback callback) {
            this.exchange = exchange;
            this.callback = callback;
        }
        public void run() {
            if (shutdown.get()) {
                exchange.setException(new RejectedExecutionException());
            }
            callback.done(false);
        }
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if (shutdown.get()) {
            throw new IllegalStateException(""ThreadProcessor is not running."");
        }
        ProcessCall call = new ProcessCall(exchange, callback);
        try {
            executor.execute(call);
            return false;
        } catch (RejectedExecutionException e) {
            if (callerRunsWhenRejected) {
                if (shutdown.get()) {
                    exchange.setException(new RejectedExecutionException());
                } else {
                    callback.done(true);
                }
            } else {
                exchange.setException(e);
            }
            return true;
        }
    }
    public void start() throws Exception {
        shutdown.set(false);
        getExecutor();
    }
    public void stop() throws Exception {
        shutdown.set(true);
        executor.shutdown();
        executor.awaitTermination(0, TimeUnit.SECONDS);
    }
    public long getStackSize() {
        return stackSize;
    }
    public void setStackSize(long stackSize) {
        this.stackSize = stackSize;
    }
    public ThreadGroup getThreadGroup() {
        return threadGroup;
    }
    public void setThreadGroup(ThreadGroup threadGroup) {
        this.threadGroup = threadGroup;
    }
    public int getPriority() {
        return priority;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public boolean isDaemon() {
        return daemon;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public long getKeepAliveTime() {
        return keepAliveTime;
    }
    public void setKeepAliveTime(long keepAliveTime) {
        this.keepAliveTime = keepAliveTime;
    }
    public int getMaxSize() {
        return maxSize;
    }
    public void setMaxSize(int maxSize) {
        this.maxSize = maxSize;
    }
    public int getCoreSize() {
        return coreSize;
    }
    public void setCoreSize(int coreSize) {
        this.coreSize = coreSize;
    }
    public BlockingQueue<Runnable> getTaskQueue() {
        if (taskQueue == null) {
            taskQueue = new ArrayBlockingQueue<Runnable>(1000);
        }
        return taskQueue;
    }
    public void setTaskQueue(BlockingQueue<Runnable> taskQueue) {
        this.taskQueue = taskQueue;
    }
    public ThreadPoolExecutor getExecutor() {
        if (executor == null) {
            executor = new ThreadPoolExecutor(getCoreSize(), getMaxSize(), getKeepAliveTime(), TimeUnit.MILLISECONDS, getTaskQueue(), new ThreadFactory() {
                public Thread newThread(Runnable runnable) {
                    Thread thread;
                    if (getStackSize() > 0) {
                        thread = new Thread(getThreadGroup(), runnable, getName(), getStackSize());
                    } else {
                        thread = new Thread(getThreadGroup(), runnable, getName());
                    }
                    thread.setDaemon(isDaemon());
                    thread.setPriority(getPriority());
                    return thread;
                }
            });
        }
        return executor;
    }
    public void setExecutor(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
    public boolean isCallerRunsWhenRejected() {
        return callerRunsWhenRejected;
    }
    public void setCallerRunsWhenRejected(boolean callerRunsWhenRejected) {
        this.callerRunsWhenRejected = callerRunsWhenRejected;
    }
}
"
org.apache.camel.processor.ThreadTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AsyncCallback;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 659842 $
 */
public class ThreadTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    private CountDownLatch continueProcessing = new CountDownLatch(1);
    public void testSimpleAsyncThreadCase() throws Exception {
        // Send the exchange using the async completion interface.
        // This call returns before the exchange is completed.
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
            }
        }, new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                log.info(""Exchange completed."");
            }
        });
        // Should not received anything since processing should not be complete.
        resultEndpoint.expectedMessageCount(0);
        resultEndpoint.assertIsSatisfied();
        // Release the processing latch..
        continueProcessing.countDown();
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    public void testSimpleSyncThreadCase() throws Exception {
        // Release the processing latch in an async thread.
        releaseProcessingLatchIn(1000);
        // This call will block until the continueProcessing is released.
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
            }
        });
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    public void testQueuedUpExchangesCompleteOnShutdown() throws Exception {
        int exchangeCount = 10;
        final CountDownLatch completedExchanges = new CountDownLatch(exchangeCount);
        final Exchange exchanges[] = new Exchange[exchangeCount];
        for (int i = 0; i < exchangeCount; i++) {
            final int index = i;
            // Send the exchange using the async completion interface.
            // This call returns before the exchange is completed.
            exchanges[i] = template.send(""direct:a"", new Processor() {
                public void process(Exchange exchange) {
                    // now lets fire in a message
                    Message in = exchange.getIn();
                    in.setBody(1);
                }
            }, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    log.debug(""Completed: "" + index + "", exception: "" + exchanges[index].getException());
                    completedExchanges.countDown();
                }
            });
        }
        // Should not received anything since processing should not be complete.
        resultEndpoint.expectedMessageCount(0);
        resultEndpoint.assertIsSatisfied();
        // Release it in a sec
        releaseProcessingLatchIn(1000);
        // Make sure we can shut down the context while there are
        // concurrent requests outstanding.
        stopCamelContext();
        // All exchanges should get completed..
        assertTrue(completedExchanges.await(5, TimeUnit.SECONDS));
    }
    protected void releaseProcessingLatchIn(final long delay) {
        new Thread() {
            @Override
            public void run() {
                try {
                    Thread.sleep(delay);
                    continueProcessing.countDown();
                } catch (InterruptedException e) {
                }
            }
        }.start();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                inheritErrorHandler(false);
                // START SNIPPET: example
                from(""direct:a"").thread(1).process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        continueProcessing.await();
                    }
                }).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.Throttler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A <a href=""http://activemq.apache.org/camel/throttler.html"">Throttler</a>
 * will set a limit on the maximum number of message exchanges which can be sent
 * to a processor within a specific time period. <p/> This pattern can be
 * extremely useful if you have some external system which meters access; such
 * as only allowing 100 requests per second; or if huge load can cause a
 * particular systme to malfunction or to reduce its throughput you might want
 * to introduce some throttling.
 * 
 * @version $Revision: 630591 $
 */
public class Throttler extends DelayProcessorSupport {
    private long maximumRequestsPerPeriod;
    private long timePeriodMillis;
    private long startTimeMillis;
    private long requestCount;
    public Throttler(Processor processor, long maximumRequestsPerPeriod) {
        this(processor, maximumRequestsPerPeriod, 1000);
    }
    public Throttler(Processor processor, long maximumRequestsPerPeriod, long timePeriodMillis) {
        super(processor);
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
        this.timePeriodMillis = timePeriodMillis;
    }
    @Override
    public String toString() {
        return ""Throttler[requests: "" + maximumRequestsPerPeriod + "" per: "" + timePeriodMillis + "" (ms) to: ""
               + getProcessor() + ""]"";
    }
    // Properties
    // -----------------------------------------------------------------------
    public long getMaximumRequestsPerPeriod() {
        return maximumRequestsPerPeriod;
    }
    /**
     * Sets the maximum number of requests per time period
     */
    public void setMaximumRequestsPerPeriod(long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    public long getTimePeriodMillis() {
        return timePeriodMillis;
    }
    /**
     * Sets the time period during which the maximum number of requests apply
     */
    public void setTimePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
    }
    /**
     * The number of requests which have taken place so far within this time
     * period
     */
    public long getRequestCount() {
        return requestCount;
    }
    /**
     * The start time when this current period began
     */
    public long getStartTimeMillis() {
        return startTimeMillis;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void delay(Exchange exchange) throws Exception {
        long now = currentSystemTime();
        if (startTimeMillis == 0) {
            startTimeMillis = now;
        }
        if (now - startTimeMillis > timePeriodMillis) {
            // we're at the start of a new time period
            // so lets reset things
            requestCount = 1;
            startTimeMillis = now;
        } else {
            if (++requestCount > maximumRequestsPerPeriod) {
                // lets sleep until the start of the next time period
                long time = startTimeMillis + timePeriodMillis;
                waitUntil(time, exchange);
            }
        }
    }
}
"
org.apache.camel.processor.ThrottlerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 643934 $
 */
public class ThrottlerTest extends ContextTestSupport {
    protected int messageCount = 6;
    public void testSendLotsOfMessagesButOnly3GetThrough() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(3);
        resultEndpoint.setResultWaitTime(1000);
        for (int i = 0; i < messageCount; i++) {
            template.sendBody(""seda:a"", ""<message>"" + i + ""</message>"");
        }
        // lets pause to give the requests time to be processed
        // to check that the throttle really does kick in
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""seda:a"").throttler(3).timePeriodMillis(30000).to(""mock:result"");
                // END SNIPPET: ex
            }
        };
    }
}
"
org.apache.camel.processor.ThroughputLogger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.text.NumberFormat;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.camel.Exchange;
import org.apache.commons.logging.Log;
/**
 * A logger for logging message throughput.
 *  
 * @version $Revision: 659760 $
 */
public class ThroughputLogger extends Logger {
    private int groupSize = 100;
    private long startTime;
    private long groupStartTime;
    private AtomicInteger receivedCounter = new AtomicInteger();
    private NumberFormat numberFormat = NumberFormat.getNumberInstance();
    private String action = ""Received"";
    private String logMessage;
    public ThroughputLogger() {
    }
    public ThroughputLogger(Log log) {
        super(log);
    }
    public ThroughputLogger(Log log, LoggingLevel level) {
        super(log, level);
    }
    public ThroughputLogger(String logName) {
        super(logName);
    }
    public ThroughputLogger(String logName, LoggingLevel level) {
        super(logName, level);
    }
    public ThroughputLogger(String logName, LoggingLevel level, int groupSize) {
        super(logName, level);
        setGroupSize(groupSize);
    }
    public ThroughputLogger(String logName, int groupSize) {
        super(logName);
        setGroupSize(groupSize);
    }
    public ThroughputLogger(int groupSize) {
        setGroupSize(groupSize);
    }
    @Override
    public void process(Exchange exchange) {
        if (startTime == 0) {
            startTime = System.currentTimeMillis();
        }
        int receivedCount = receivedCounter.incrementAndGet();
        if (receivedCount % groupSize == 0) {
            logMessage = createLogMessage(exchange, receivedCount);
            super.process(exchange);
        }
    }
    public int getGroupSize() {
        return groupSize;
    }
    public void setGroupSize(int groupSize) {
        if (groupSize == 0) {
            throw new IllegalArgumentException(""groupSize cannot be zero!"");
        }
        this.groupSize = groupSize;
    }
    public NumberFormat getNumberFormat() {
        return numberFormat;
    }
    public void setNumberFormat(NumberFormat numberFormat) {
        this.numberFormat = numberFormat;
    }
    public String getAction() {
        return action;
    }
    public void setAction(String action) {
        this.action = action;
    }
    @Override
    protected Object logMessage(Exchange exchange) {
        return logMessage;
    }
    protected String createLogMessage(Exchange exchange, int receivedCount) {
        long time = System.currentTimeMillis();
        if (groupStartTime == 0) {
            groupStartTime = startTime;
        }
        double rate = messagesPerSecond(groupSize, groupStartTime, time);
        double average = messagesPerSecond(receivedCount, startTime, time);
        groupStartTime = time;
        return getAction() + "": "" + receivedCount + "" messages so far. Last group took: "" + (time - groupStartTime)
                + "" millis which is: "" + numberFormat.format(rate)
                + "" messages per second. average: "" + numberFormat.format(average);
    }
    // timeOneMessage = elapsed / messageCount
    // messagePerSend = 1000 / timeOneMessage
    protected double messagesPerSecond(long messageCount, long startTime, long endTime) {
        double rate = messageCount * 1000.0;
        rate /= endTime - startTime;
        return rate;
    }
}
"
org.apache.camel.processor.ThrowFaultProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
/**
 * The processor which implements the ThrowFault DSL
 */
public class ThrowFaultProcessor implements Processor {
    private Throwable fault;
    public ThrowFaultProcessor(Throwable fault) {
        this.fault = fault;
    }
    /**
     * Set the fault message in the exchange
     * @see org.apache.camel.Processor#process(org.apache.camel.Exchange)
     */
    public void process(Exchange exchange) throws Exception {
        Message message = exchange.getFault();
        message.setBody(fault);
    }
}
"
org.apache.camel.processor.TraceInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.interceptor.Debugger;
import org.apache.camel.processor.interceptor.Tracer;
/**
 * @version $Revision: 673954 $
 */
public class TraceInterceptorTest extends ContextTestSupport {
    // START SNIPPET: e1
    public void testSendingSomeMessages() throws Exception {
        template.sendBodyAndHeader(""direct:start"", ""Hello London"", ""to"", ""James"");
        template.sendBodyAndHeader(""direct:start"", ""This is Copenhagen calling"", ""from"", ""Claus"");
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                // add tracer as an interceptor so it will log the exchange executions at runtime
                // this can aid us to understand/see how the exchanges is routed etc.
                getContext().addInterceptStrategy(new Tracer());
                from(""direct:start"").
                        process(new Processor() {
                            public void process(Exchange exchange) throws Exception {
                                // do nothing
                            }
                            @Override
                            public String toString() {
                                return ""MyProcessor"";
                            }
                        }).
                        to(""mock:a"").
                        to(""mock:b"");
            }
        };
    }
    // END SNIPPET: e1
}
"
org.apache.camel.processor.TransformProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A processor which sets the body on the OUT message with an expression
 */
public class TransformProcessor extends DelegateProcessor implements Processor {
    private static final transient Log LOG = LogFactory.getLog(TransformProcessor.class);
    private Expression expression;
    public TransformProcessor(Expression expression) {
        this.expression = expression;
    }
    public TransformProcessor(Expression expression, Processor childProcessor) {
        super(childProcessor);
        this.expression = expression;
    }
    public void process(Exchange exchange) throws Exception {
        Object newBody = expression.evaluate(exchange);
        exchange.getOut().setBody(newBody);
        // propogate headers
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
        super.process(exchange);
    }
    @Override
    public String toString() {
        return ""transform("" + expression + "")"";
    }
}
"
org.apache.camel.processor.TransformProcessorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.builder.RouteBuilder;
public class TransformProcessorTest extends TransformViaDSLTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").transform(body().append("" World!"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TransformProcessorWithHeaderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test to verify that headers can be propogated with the transform DSL.
 */
public class TransformProcessorWithHeaderTest extends ContextTestSupport {
    public void testTransformPropogateHeaders() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        mock.expectedMessageCount(1);
        mock.expectedBodiesReceived(""London"");
        mock.expectedHeaderReceived(""foo"", ""bar"");
        template.sendBodyAndHeader(""direct:in"",
            ""<person name='James' city='London'/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisifed();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"")
                    .transform().constant(""London"")
                    .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.TransformTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class TransformTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Hello World!"");
        sendBody(""direct:start"", ""Hello"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) {
                        Message in = exchange.getIn();
                        in.setBody(in.getBody(String.class) + "" World!"");
                    }
                }).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TransformViaDSLTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class TransformViaDSLTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Hello World!"");
        sendBody(""direct:start"", ""Hello"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").setBody(body().append("" World!"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TryProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Implements try/catch/finally type processing
 *
 * @version $Revision: 660275 $
 */
public class TryProcessor extends ServiceSupport implements Processor {
    private static final transient Log LOG = LogFactory.getLog(TryProcessor.class);
    private final Processor tryProcessor;
    private final List<CatchProcessor> catchClauses;
    private final Processor finallyProcessor;
    public TryProcessor(Processor tryProcessor, List<CatchProcessor> catchClauses, Processor finallyProcessor) {
        this.tryProcessor = tryProcessor;
        this.catchClauses = catchClauses;
        this.finallyProcessor = finallyProcessor;
    }
    public String toString() {
        String finallyText = (finallyProcessor == null) ? """" : "" Finally {"" + finallyProcessor + ""}"";
        return ""Try {"" + tryProcessor + ""} "" + catchClauses + finallyText;
    }
    public void process(Exchange exchange) throws Exception {
        Throwable e = null;
        try {
            tryProcessor.process(exchange);
            e = exchange.getException();
            // Ignore it if it was handled by the dead letter channel.
            if (e != null && DeadLetterChannel.isFailureHandled(exchange)) {
                e = null;
            }
        } catch (Throwable ex) {
            e = ex;
            exchange.setException(e);
        }
        Exception unexpected = null;
        try {
            if (e != null) {
                LOG.info(""Caught exception while processing exchange."", e);
                handleException(exchange, e);
            }
        } catch (Exception ex) {
            unexpected = ex;
        } catch (Throwable ex) {
            unexpected = new RuntimeCamelException(ex);
        } finally {
            try {
                processFinally(exchange);
            } catch (Exception ex) {
                unexpected = ex;
            } catch (Throwable ex) {
                unexpected = new RuntimeCamelException(ex);
            }
            if (unexpected != null) {
                LOG.warn(""Caught exception inside processFinally clause."", unexpected);
                throw unexpected;
            }
        }
        if (unexpected != null) {
            LOG.warn(""Caught exception inside handle clause."", unexpected);
            throw unexpected;
        }
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(tryProcessor, catchClauses, finallyProcessor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(tryProcessor, catchClauses, finallyProcessor);
    }
    protected void handleException(Exchange exchange, Throwable e) throws Throwable {
        for (CatchProcessor catchClause : catchClauses) {
            if (catchClause.catches(e)) {
                // lets attach the exception to the exchange
                Exchange localExchange = exchange.copy();
                localExchange.getIn().setHeader(""caught.exception"", e);
                // give the rest of the pipeline another chance
                localExchange.setException(null);
                // do not catch any exception here, let it propagate up
                catchClause.process(localExchange);
                localExchange.getIn().removeHeader(""caught.exception"");
                ExchangeHelper.copyResults(exchange, localExchange);
                return;
            }
        }
    }
    protected void processFinally(Exchange exchange) throws Throwable {
        if (finallyProcessor != null) {
            Throwable lastException = exchange.getException();
            exchange.setException(null);
            // do not catch any exception here, let it propagate up
            finallyProcessor.process(exchange);
            if (exchange.getException() == null) {
                exchange.setException(lastException);
            }
        }
    }
}
"
org.apache.camel.processor.TryProcessorHandleTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * Unit test for try .. handle routing (CAMEL-564).
 */
public class TryProcessorHandleTest extends ContextTestSupport {
    private boolean handled;
    public void test() throws Exception {
        MockEndpoint mock = getMockEndpoint(""mock:result"");
        sendBody(""direct:start"", ""<test>Hello World!</test>"");
        assertTrue(""Should have been handled"", handled);
        mock.expectedMessageCount(0);
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(new ProcessorFail())
                        .to(""mock:result"")
                    .handle(Exception.class)
                      .process(new ProcessorHandle())
                    .end();
            }
        };
    }
    private class ProcessorFail implements Processor {
        public void process(Exchange exchange) throws Exception {
            throw new IllegalStateException(""Force to fail"");
        }
    }
    private class ProcessorHandle implements Processor {
        public void process(Exchange exchange) throws Exception {
            handled = true;
            assertEquals(""Should not be marked as failed"", false, exchange.isFailed());
            Exception e = (Exception)exchange.getIn().getHeader(""caught.exception"");
            assertNotNull(""There should be an exception"", e);
            assertTrue(e instanceof IllegalStateException);
            assertEquals(""Force to fail"", e.getMessage());
        }
    }
}
"
org.apache.camel.processor.UnitOfWorkProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultUnitOfWork;
/** 
 * Handles calling the UnitOfWork.done() method when processing of an exchange
 * is complete.
 */
public final class UnitOfWorkProcessor extends DelegateAsyncProcessor {
    public UnitOfWorkProcessor(AsyncProcessor processor) {
        super(processor);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if (exchange.getUnitOfWork() == null) {
            // If there is no existing UoW, then we should start one and
            // terminate it once processing is completed for the exchange.
            exchange.setUnitOfWork(new DefaultUnitOfWork());
            return processor.process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    // Order here matters. We need to complete the callbacks
                    // since they will likely update the exchange with 
                    // some final results.
                    callback.done(sync);
                    exchange.getUnitOfWork().done(exchange);
                    exchange.setUnitOfWork(null);
                }
            });
        } else {
            // There was an existing UoW, so we should just pass through..
            // so that the guy the initiated the UoW can terminate it.
            return processor.process(exchange, callback);
        }
    }
}
"
org.apache.camel.processor.UnitOfWorkTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spi.Synchronization;
/**
 * @version $Revision: 583549 $
 */
public class UnitOfWorkTest extends ContextTestSupport {
    protected Synchronization synchronization;
    protected Exchange completed;
    protected Exchange failed;
    protected String uri = ""direct:foo"";
    protected CountDownLatch doneLatch = new CountDownLatch(1);
    public void testSuccess() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have failed"", failed);
        assertNotNull(""Should have received completed notification"", completed);
        log.info(""Received completed: "" + completed);
    }
    public void testFail() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have completed"", completed);
        assertNotNull(""Should have received failed notification"", failed);
        log.info(""Received fail: "" + failed);
    }
    public void testException() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have completed"", completed);
        assertNotNull(""Should have received failed notification"", failed);
        log.info(""Received fail: "" + failed);
    }
    @Override
    protected void setUp() throws Exception {
        synchronization = new Synchronization() {
            public void onComplete(Exchange exchange) {
                completed = exchange;
                doneLatch.countDown();
            }
            public void onFailure(Exchange exchange) {
                failed = exchange;
                doneLatch.countDown();
            }
        };
        super.setUp();
    }
    protected void sendMessage() throws InterruptedException {
        template.send(uri, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:async"").thread(1).to(""direct:foo"");
                from(""direct:foo"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        log.info(""Received: "" + exchange);
                        exchange.getUnitOfWork().addSynchronization(synchronization);
                        String name = getName();
                        if (name.equals(""testFail"")) {
                            log.info(""Failing test!"");
                            exchange.getFault(true).setBody(""testFail() should always fail with a fault!"");
                        } else if (name.equals(""testException"")) {
                            log.info(""Throwing exception!"");
                            throw new Exception(""Failing test!"");
                        }
                    }
                });
            }
        };
    }
}
"
org.apache.camel.processor.UnitOfWorkWithAsyncFlowTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
/**
 * @version $Revision: 640438 $
 */
public class UnitOfWorkWithAsyncFlowTest extends UnitOfWorkTest {
    @Override
    protected void setUp() throws Exception {
        uri = ""direct:async"";
        super.setUp();
    }
}
"
org.apache.camel.processor.UnmarshalProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.InputStream;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
/**
 * Unmarshals the body of the incoming message using the given
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 *
 * @version $Revision: 640438 $
 */
public class UnmarshalProcessor implements Processor {
    private final DataFormat dataFormat;
    public UnmarshalProcessor(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    public void process(Exchange exchange) throws Exception {
        InputStream stream = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        try {
            // lets setup the out message before we invoke the dataFormat
            // so that it can mutate it if necessary
            Message out = exchange.getOut(true);
            out.copyFrom(exchange.getIn());
            Object result = dataFormat.unmarshal(exchange, stream);
            out.setBody(result);
        } finally {
            if (null != stream) {
                stream.close();
            }
        }
    }
}
"
org.apache.camel.processor.ValidationFinallyBlockNoCatchTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.TryType;
/**
 * No catch blocks but handle all should work
 *
 * @author <a href=""mailto:nsandhu@raleys.com"">nsandhu</a>
 */
public class ValidationFinallyBlockNoCatchTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint allEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, allEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        validEndpoint.expectedMessageCount(0);
        // allEndpoint receives 6 messages, as redelivery is involved
        allEndpoint.expectedMessageCount(6);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, allEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        allEndpoint = resolveMandatoryEndpoint(""mock:all"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                TryType tryType = from(""direct:start"").tryBlock().
                        process(validator).
                        to(""mock:valid"");
                tryType.finallyBlock().to(""mock:all"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationFinallyBlockTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.TryType;
/**
 * Test finallyBlock
 *
 * @author <a href=""mailto:nsandhu@raleys.com"">nsandhu</a>
 */
public class ValidationFinallyBlockTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    protected MockEndpoint allEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        invalidEndpoint.expectedMessageCount(0);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        validEndpoint.expectedMessageCount(0);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
        allEndpoint = resolveMandatoryEndpoint(""mock:all"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                TryType tryType = from(""direct:start"").tryBlock().
                        process(validator).
                        to(""mock:valid"");
                tryType.handle(ValidationException.class).to(""mock:invalid"");
                tryType.finallyBlock().to(""mock:all"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.Builder;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 659842 $
 */
public class ValidationTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        invalidEndpoint.expectedMessageCount(0);
        Object result = template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
        assertEquals(""validResult"", result);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        validEndpoint.expectedMessageCount(0);
        Object result = template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
        assertEquals(""invalidResult"", result);
    }
    public void testinvalidThenValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(2);
        invalidEndpoint.expectedMessageCount(1);
        Object result;
        result = template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"",  ""notMatchedHeaderValue"");
        assertEquals(""invalidResult"", result);
        result = template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"",   ""bar"");
        assertEquals(""validResult"", result);
        result = template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"",   ""bar"");
        assertEquals(""validResult"", result);
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
        validEndpoint.whenAnyExchangeReceived(ProcessorBuilder.setOutBody(Builder.constant(""validResult"")));
        invalidEndpoint.whenAnyExchangeReceived(ProcessorBuilder.setOutBody(Builder.constant(""invalidResult"")));
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                        tryBlock().
                        process(validator).
                        to(""mock:valid"").
                        handle(ValidationException.class).to(""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithErrorInHandleAndFinallyBlockTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
public class ValidationWithErrorInHandleAndFinallyBlockTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .errorHandler(noErrorHandler())
                    .tryBlock()
                        .process(validator)
                    .handle(ValidationException.class)
                        .process(validator)
                    .finallyBlock()
                        .choice()
                        .when(header(""foo"").isEqualTo(""bar""))
                        .to(""mock:valid"")
                        .otherwise()
                        .to(""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630568 $
 */
public class ValidationWithExceptionTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").
                        process(validator).
                        to(""mock:valid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithFinallyBlockPipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithFinallyBlockPipelineTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(validator)
                        .setHeader(""valid"", constant(true))
                    .handle(ValidationException.class)
                        .setHeader(""valid"", constant(false))
                    .finallyBlock()
                        .setBody(body())
                        .choice()
                        .when(header(""valid"").isEqualTo(true))
                        .to(""mock:valid"")
                        .otherwise()
                        .to(""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithHandlePipelineAndExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithHandlePipelineAndExceptionTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").tryBlock().process(validator).to(""mock:valid"").handle(
                        ValidationException.class).process(validator);
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithHandlePipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithHandlePipelineTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(validator).to(""mock:valid"")
                    .handle(ValidationException.class)
                        .tryBlock()
                            .process(validator).to(""mock:valid"")
                        .handle(ValidationException.class)
                            .pipeline(""direct:a"", ""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithInFlowExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 647890 $
 */
public class ValidationWithInFlowExceptionTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").
                        exception(ValidationException.class).to(""mock:invalid"").
                        end().
                        process(validator).
                        to(""mock:valid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithMultipleHandlesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithMultipleHandlesTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .process(validator)
                    .handle(ValidationException.class)
                        .setHeader(""xxx"", constant(""yyy""))
                    .end()
                    .tryBlock()
                        .process(validator).to(""mock:valid"")
                    .handle(ValidationException.class)
                        .pipeline(""direct:a"", ""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithNestedFinallyBlockPipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * The handle catch clause has a pipeline processing the exception.
 *
 * @author <a href=""mailto:nsandhu"">nsandhu</a>
 *
 */
public class ValidationWithNestedFinallyBlockPipelineTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"")
                    .tryBlock()
                        .to(""direct:embedded"")
                    .handle(ValidationException.class)
                        .to(""mock:invalid"");
                from(""direct:embedded"")
                    .errorHandler(noErrorHandler())
                    .tryBlock()
                        .process(validator)
                        .to(""mock:valid"")
                    .finallyBlock()
                        .setHeader(""valid"", constant(false))
                    .end();
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithTryCatchTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630568 $
 */
public class ValidationWithTryCatchTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        try {
                            validator.process(exchange);
                            template.send(""mock:valid"", exchange);
                        } catch (ValidationException e) {
                            template.send(""mock:invalid"", exchange);
                        }
                    }
                });
            }
        };
    }
}
"
org.apache.camel.processor.XPathChoiceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
/**
 * @version $Revision: 659842 $
 */
public class XPathChoiceTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendToFirstWhen() throws Exception {
        String body = ""<body id='a'/>"";
        x.expectedBodiesReceived(body);
        expectsMessageCount(0, y, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisifed();
    }
    public void testSendToSecondWhen() throws Exception {
        String body = ""<body id='b'/>"";
        y.expectedBodiesReceived(body);
        expectsMessageCount(0, x, z);
        sendMessage(""cheese"", body);
        assertMockEndpointsSatisifed();
    }
    public void testSendToOtherwiseClause() throws Exception {
        String body = ""<body id='c'/>"";
        z.expectedBodiesReceived(body);
        expectsMessageCount(0, x, y);
        sendMessage(""somethingUndefined"", body);
        assertMockEndpointsSatisifed();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.sendBodyAndHeader(""direct:start"", body, ""foo"", headerValue);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").choice()
                        .when().xpath(""/body[@id='a']"").setHeader(""name"", constant(""a"")).to(""mock:x"")
                        .when().xpath(""/body[@id='b']"").to(""mock:y"")
                        .otherwise().to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.XPathFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 630568 $
 */
public class XPathFilterTest extends ContextTestSupport {
    protected String matchingBody = ""<person name='James' city='London'/>"";
    protected String notMatchingBody = ""<person name='Hiram' city='Tampa'/>"";
    public void testSendMatchingMessage() throws Exception {
        getMockEndpoint(""mock:result"").expectedBodiesReceived(matchingBody);
        sendBody(""direct:start"", matchingBody);
        assertMockEndpointsSatisifed();
    }
    public void testSendNotMatchingMessage() throws Exception {
        getMockEndpoint(""mock:result"").expectedMessageCount(0);
        sendBody(""direct:start"", notMatchingBody);
        assertMockEndpointsSatisifed();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").
                        filter().xpath(""/person[@name='James']"").
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.XPathWithNamespaceBuilderFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class XPathWithNamespaceBuilderFilterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese' name='James' city='London'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese'  name='Hiram' city='Tampa'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                // lets define the namespaces we'll need in our filters
                Namespaces ns = new Namespaces(""c"", ""http://acme.com/cheese"")
                        .add(""xsd"", ""http://www.w3.org/2001/XMLSchema"");
                // now lets create an xpath based Message Filter
                from(""direct:start"").
                        filter(ns.xpath(""/c:person[@name='James']"")).
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.XPathWithNamespacesFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 630568 $
 */
public class XPathWithNamespacesFilterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese' name='James' city='London'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"",
                ""<person xmlns='http://acme.com/cheese'  name='Hiram' city='Tampa'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                Namespaces ns = new Namespaces(""c"", ""http://acme.com/cheese"");
                from(""direct:start"").filter().
                        xpath(""/c:person[@name='James']"", ns).
                        to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.aggregate.AggregationCollection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import java.util.AbstractCollection;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Collection} which aggregates exchanges together using a correlation
 * expression so that there is only a single message exchange sent for a single
 * correlation key.
 *
 * @version $Revision: 640438 $
 */
public class AggregationCollection extends AbstractCollection<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(AggregationCollection.class);
    private final Expression<Exchange> correlationExpression;
    private final AggregationStrategy aggregationStrategy;
    private Map<Object, Exchange> map = new LinkedHashMap<Object, Exchange>();
    public AggregationCollection(Expression<Exchange> correlationExpression,
                                 AggregationStrategy aggregationStrategy) {
        this.correlationExpression = correlationExpression;
        this.aggregationStrategy = aggregationStrategy;
    }
    protected Map<Object, Exchange> getMap() {
        return map;
    }
    @Override
    public boolean add(Exchange exchange) {
        Object correlationKey = correlationExpression.evaluate(exchange);
        Exchange oldExchange = map.get(correlationKey);
        Exchange newExchange = exchange;
        if (oldExchange != null) {
            newExchange = aggregationStrategy.aggregate(oldExchange, newExchange);
        }
        // the strategy may just update the old exchange and return it
        if (newExchange != oldExchange) {
            LOG.debug(""put exchange:"" + newExchange + "" for key:""  + correlationKey);
            map.put(correlationKey, newExchange);
        }
        onAggregation(correlationKey, newExchange);
        return true;
    }
    public Iterator<Exchange> iterator() {
        return map.values().iterator();
    }
    public int size() {
        return map.size();
    }
    @Override
    public void clear() {
        map.clear();
    }
    /**
     * A strategy method allowing derived classes such as {@link PredicateAggregationCollection}
     * to check to see if the aggregation has completed
     */
    protected void onAggregation(Object correlationKey, Exchange newExchange) {
    }
}
"
org.apache.camel.processor.aggregate.AggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import org.apache.camel.Exchange;
/**
 * A strategy for aggregating two exchanges together into a single exchange.
 * Possible implementations include performing some kind of combining or delta
 * processing, such as adding line items together into an invoice or just using
 * the newest exchange and removing old exchanges such as for state tracking or
 * market data prices; where old values are of little use.
 * 
 * @version $Revision: 630568 $
 */
public interface AggregationStrategy {
    /**
     * Aggregates an old and new exchange together to create a single combined
     * exchange
     *
     * @param oldExchange the oldest exchange
     * @param newExchange the newest exchange
     * @return a combined composite of the two exchanges
     */
    Exchange aggregate(Exchange oldExchange, Exchange newExchange);
}
"
org.apache.camel.processor.aggregate.PredicateAggregationCollection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * An aggregator collection which uses a predicate to decide when an aggregation is completed for
 * a particular correlation key
 *
 * @version $Revision: 640438 $
 */
public class PredicateAggregationCollection extends AggregationCollection {
    private Predicate aggregationCompletedPredicate;
    private List<Exchange> collection = new ArrayList<Exchange>();
    public PredicateAggregationCollection(Expression<Exchange> correlationExpression, AggregationStrategy aggregationStrategy, Predicate aggregationCompletedPredicate) {
        super(correlationExpression, aggregationStrategy);
        this.aggregationCompletedPredicate = aggregationCompletedPredicate;
    }
    @Override
    protected void onAggregation(Object correlationKey, Exchange newExchange) {
        if (aggregationCompletedPredicate.matches(newExchange)) {
            // this exchange has now aggregated so lets add it to the collection of things
            // to send
            super.getMap().remove(correlationKey);
            collection.add(newExchange);
        }
    }
    @Override
    public Iterator<Exchange> iterator() {
        return collection.iterator();
    }
    @Override
    public int size() {
        return collection.size();
    }
    @Override
    public void clear() {
        collection.clear();
        super.clear();
    }
}
"
org.apache.camel.processor.aggregate.UseLatestAggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import org.apache.camel.Exchange;
/**
 * An {@link AggregationStrategy} which just uses the latest exchange which is useful
 * for status messages where old status messages have no real value. Another example is things
 * like market data prices, where old stock prices are not that relevant, only the current price is.
 *
 * @version $Revision: 659760 $
 */
public class UseLatestAggregationStrategy implements AggregationStrategy {
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        return newExchange;
    }
}
"
org.apache.camel.processor.aggregator.AlbertoAggregatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.AggregatorType;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 662986 $
 */
public class AlbertoAggregatorTest extends ContextTestSupport {
    private static final String SURNAME_HEADER = ""surname"";
    private static final String TYPE_HEADER = ""type"";
    private static final String BROTHERS_TYPE = ""brothers"";
    private Log log = LogFactory.getLog(this.getClass());
    public void testAggregator() throws Exception {
        String allNames = ""Harpo Marx,Fiodor Karamazov,Chico Marx,Ivan Karamazov,Groucho Marx,Alexei Karamazov,Dimitri Karamazov"";
        List<String> marxBrothers = new ArrayList<String>();
        marxBrothers.add(""Harpo"");
        marxBrothers.add(""Chico"");
        marxBrothers.add(""Groucho"");
        List<String> karamazovBrothers = new ArrayList<String>();
        karamazovBrothers.add(""Fiodor"");
        karamazovBrothers.add(""Ivan"");
        karamazovBrothers.add(""Alexei"");
        karamazovBrothers.add(""Dimitri"");
        Map<String, List> allBrothers = new HashMap<String, List>();
        allBrothers.put(""Marx"", marxBrothers);
        allBrothers.put(""Karamazov"", karamazovBrothers);
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.expectedBodiesReceived(allBrothers);
        ProducerTemplate template = context.createProducerTemplate();
        template.sendBody(""direct:start"", allNames);
        assertMockEndpointsSatisifed();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            AggregationStrategy surnameAggregator = new AggregationStrategy() {
                public Exchange aggregate(Exchange oldExchange,
                        Exchange newExchange) {
                    debugIn(""Surname Aggregator"", oldExchange, newExchange);
                    Message oldIn = oldExchange.getIn();
                    Message newIn = newExchange.getIn();
                    List<String> brothers = null;
                    if (oldIn.getBody() instanceof List) {
                        brothers = oldIn.getBody(List.class);
                        brothers.add(newIn.getBody(String.class));
                    } else {
                        brothers = new ArrayList<String>();
                        brothers.add(oldIn.getBody(String.class));
                        brothers.add(newIn.getBody(String.class));
                        oldExchange.getIn().setBody(brothers);
                    } // else
                    debugOut(""Surname Aggregator"", oldExchange);
                    return oldExchange;
                }
            };
            AggregationStrategy brothersAggregator = new AggregationStrategy() {
                public Exchange aggregate(Exchange oldExchange,
                        Exchange newExchange) {
                    debugIn(""Brothers Aggregator"", oldExchange, newExchange);
                    Message oldIn = oldExchange.getIn();
                    Message newIn = newExchange.getIn();
                    Map<String, List> brothers = null;
                    if (oldIn.getBody() instanceof Map) {
                        brothers = oldIn.getBody(Map.class);
                        brothers.put(newIn.getHeader(SURNAME_HEADER,
                                String.class), newIn.getBody(List.class));
                    } else {
                        brothers = new HashMap<String, List>();
                        brothers.put(oldIn.getHeader(SURNAME_HEADER, String.class),
                                oldIn.getBody(List.class));
                        brothers.put(newIn.getHeader(SURNAME_HEADER,
                                String.class), newIn.getBody(List.class));
                        oldExchange.getIn().setBody(brothers);
                    } // else
                    debugOut(""Brothers Aggregator"", oldExchange);
                    return oldExchange;
                }
            };
            private void debugIn(String stringId, Exchange oldExchange,
                    Exchange newExchange) {
                log.debug(stringId + "" old headers in: ""
                        + oldExchange.getIn().getHeaders());
                log.debug(stringId + "" old body in: ""
                        + oldExchange.getIn().getBody());
                log.debug(stringId + "" new headers in: ""
                        + newExchange.getIn().getHeaders());
                log.debug(stringId + "" new body in: ""
                        + newExchange.getIn().getBody());
            }
            private void debugOut(String stringId, Exchange exchange) {
                log.debug(stringId + "" old headers out: ""
                        + exchange.getIn().getHeaders());
                log.debug(stringId + "" old body out: ""
                        + exchange.getIn().getBody());
            }
            @Override
            public void configure() throws Exception {
                from(""direct:start"")
                        // Separate people
                        .splitter(bodyAs(String.class).tokenize("","")).process(
                            // Split the name, erase the surname and put it in a
                            // header
                            new Processor() {
                                public void process(Exchange exchange) throws Exception {
                                    String[] parts = exchange.getIn()
                                            .getBody(String.class).split(
                                            "" "");
                                    exchange.getIn().setBody(parts[0]);
                                    exchange.getIn().setHeader(
                                            SURNAME_HEADER, parts[1]);
                                } // process
                            }) // Processor
                        .to(""direct:joinSurnames"");
                from(""direct:joinSurnames"")
                        .aggregator(header(SURNAME_HEADER),
                                surnameAggregator).setHeader(TYPE_HEADER,
                        constant(BROTHERS_TYPE)).to(""direct:joinBrothers"");
                // Join all brothers lists and remove surname and type headers
                AggregatorType agg =
                        from(""direct:joinBrothers"").aggregator(header(TYPE_HEADER),
                                brothersAggregator);
                agg.setBatchTimeout(5000L);
                agg.removeHeader(SURNAME_HEADER)
                        .removeHeader(TYPE_HEADER)
                        .to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.exceptionpolicy.CustomExceptionPolicyStrategyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.util.Map;
import org.apache.camel.CamelException;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.ExceptionType;
/**
 * Unit test with a user plugged in exception policy to use instead of default.
 */
public class CustomExceptionPolicyStrategyTest extends ContextTestSupport {
    private static final String MESSAGE_INFO = ""messageInfo"";
    private static final String ERROR_QUEUE = ""mock:error"";
    public static class MyPolicyException extends Exception {
    }
    // START SNIPPET e2
    public static class MyPolicy implements ExceptionPolicyStrategy {
        public ExceptionType getExceptionPolicy(Map<Class, ExceptionType> exceptionPolicices,
                                                Exchange exchange,
                                                Throwable exception) {
            // This is just an example that always forces the exception type configured
            // with MyPolicyException to win.
            return exceptionPolicices.get(MyPolicyException.class);
        }
    }
    // END SNIPPET e2
    public void testCustomPolicy() throws Exception {
        MockEndpoint mock = getMockEndpoint(ERROR_QUEUE);
        mock.expectedMessageCount(1);
        mock.expectedHeaderReceived(MESSAGE_INFO, ""Damm my policy exception"");
        template.sendBody(""direct:a"", ""Hello Camel"");
        mock.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            // START SNIPPET e1
            public void configure() throws Exception {
                // configure the error handler to use my policy instead of the default from Camel
                errorHandler(deadLetterChannel().exceptionPolicyStrategy(new MyPolicy()));
                exception(MyPolicyException.class)
                    .maximumRedeliveries(1)
                    .setHeader(MESSAGE_INFO, ""Damm my policy exception"")
                    .to(ERROR_QUEUE);
                exception(CamelException.class)
                    .maximumRedeliveries(3)
                    .setHeader(MESSAGE_INFO, ""Damm a Camel exception"")
                    .to(ERROR_QUEUE);
                // END SNIPPET e1
                from(""direct:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        String s = exchange.getIn().getBody(String.class);
                        if (""Hello Camel"".equals(s)) {
                            throw new CamelExchangeException(""Forced for testing"", exchange);
                        }
                        exchange.getOut().setBody(""Hello World"");
                    }
                }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.model.ExceptionType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The default strategy used in Camel to resolve the {@link org.apache.camel.model.ExceptionType} that should
 * handle the thrown exception.
 * <p/>
 * This strategy applies the following rules:
 * <ul>
 *   <li>The exception type must be configured with an Exception that is an instance of the thrown exception</li>
 *   <li>If the exception type has exactly the thrown exception then its selected</li>
 *   <li>Otherwise the type that has an exception that is super of the thrown exception is selected
 *       (recurring up the exception hierarchy)
 *  </ul>
 */
public class DefaultExceptionPolicyStrategy implements ExceptionPolicyStrategy {
    private static final transient Log LOG = LogFactory.getLog(DefaultExceptionPolicyStrategy.class);
    public ExceptionType getExceptionPolicy(Map<Class, ExceptionType> exceptionPolicices, Exchange exchange,
                                            Throwable exception) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Finding best suited exception policy for thrown exception "" + exception.getClass().getName());
        }
        // the goal is to find the exception with the same/closet inheritance level as the target exception being thrown
        int targetLevel = getInheritanceLevel(exception.getClass());
        // candidate is the best candidate found so far to return
        ExceptionType candidate = null;
        // difference in inheritance level between the current candidate and the thrown exception (target level)
        int candidateDiff = Integer.MAX_VALUE;
        // loop through all the entries and find the best candidates to use
        Set<Map.Entry<Class, ExceptionType>> entries = exceptionPolicices.entrySet();
        for (Map.Entry<Class, ExceptionType> entry : entries) {
            Class clazz = entry.getKey();
            ExceptionType type = entry.getValue();
            // must be instance of check to ensure that the clazz is one type of the thrown exception
            if (clazz.isInstance(exception)) {
                // exact match
                if (clazz.equals(exception.getClass())) {
                    candidate = type;
                    break;
                }
                // not an exact match so find the best candidate
                int level = getInheritanceLevel(clazz);
                int diff = targetLevel - level;
                if (diff < candidateDiff) {
                    // replace with a much better candidate
                    candidate = type;
                    candidateDiff = diff;
                }
            }
        }
        if (LOG.isDebugEnabled()) {
            if (candidate != null) {
                LOG.debug(""Using "" + candidate + "" as the exception policy"");
            } else {
                LOG.debug(""No candidate found to be used as exception policy"");
            }
        }
        return candidate;
    }
    private static int getInheritanceLevel(Class clazz) {
        if (clazz == null || ""java.lang.Object"".equals(clazz.getName())) {
            return 0;
        }
        return 1 + getInheritanceLevel(clazz.getSuperclass());
    }
}
"
org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategyTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.ConnectException;
import java.net.SocketException;
import java.util.HashMap;
import junit.framework.TestCase;
import org.apache.camel.AlreadyStoppedException;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.ExchangeTimedOutException;
import org.apache.camel.ValidationException;
import org.apache.camel.model.ExceptionType;
/**
 * Unit test for DefaultExceptionPolicy 
 */
public class DefaultExceptionPolicyStrategyTest extends TestCase {
    private DefaultExceptionPolicyStrategy strategy;
    private HashMap<Class, ExceptionType> policies;
    private ExceptionType type1;
    private ExceptionType type2;
    private ExceptionType type3;
    private void setupPolicies() {
        strategy = new DefaultExceptionPolicyStrategy();
        policies = new HashMap<Class, ExceptionType>();
        type1 = new ExceptionType(CamelExchangeException.class);
        type2 = new ExceptionType(Exception.class);
        type3 = new ExceptionType(IOException.class);
        policies.put(CamelExchangeException.class, type1);
        policies.put(Exception.class, type2);
        policies.put(IOException.class, type3);
    }
    private void setupPoliciesNoTopLevelException() {
        // without the top level exception that can be used as fallback
        strategy = new DefaultExceptionPolicyStrategy();
        policies = new HashMap<Class, ExceptionType>();
        type1 = new ExceptionType(CamelExchangeException.class);
        type3 = new ExceptionType(IOException.class);
        policies.put(CamelExchangeException.class, type1);
        policies.put(IOException.class, type3);
    }
    public void testDirectMatch1() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new CamelExchangeException("""", null));
        assertEquals(type1, result);
    }
    public void testDirectMatch2() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new Exception(""""));
        assertEquals(type2, result);
    }
    public void testDirectMatch3() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new IOException(""""));
        assertEquals(type3, result);
    }
    public void testClosetMatch3() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new ConnectException(""""));
        assertEquals(type3, result);
        result = strategy.getExceptionPolicy(policies, null, new SocketException(""""));
        assertEquals(type3, result);
        result = strategy.getExceptionPolicy(policies, null, new FileNotFoundException());
        assertEquals(type3, result);
    }
    public void testClosetMatch2() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new ClassCastException(""""));
        assertEquals(type2, result);
        result = strategy.getExceptionPolicy(policies, null, new NumberFormatException(""""));
        assertEquals(type2, result);
        result = strategy.getExceptionPolicy(policies, null, new NullPointerException());
        assertEquals(type2, result);
    }
    public void testClosetMatch1() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new ValidationException(null, """"));
        assertEquals(type1, result);
        result = strategy.getExceptionPolicy(policies, null, new ExchangeTimedOutException(null, 0));
        assertEquals(type1, result);
    }
    public void testNoMatch1ThenMatchingJustException() {
        setupPolicies();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new AlreadyStoppedException());
        assertEquals(type2, result);
    }
    public void testNoMatch1ThenNull() {
        setupPoliciesNoTopLevelException();
        ExceptionType result = strategy.getExceptionPolicy(policies, null, new AlreadyStoppedException());
        assertNull(""Should not find an exception policy to use"", result);
    }
}
"
org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.exceptionpolicy;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.model.ExceptionType;
/**
 * A strategy to determine which {@link org.apache.camel.model.ExceptionType} should handle the thrown
 * exception.
 *
 * @see org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy DefaultExceptionPolicy
 */
public interface ExceptionPolicyStrategy {
    /**
     * Resolves the {@link org.apache.camel.model.ExceptionType} that should handle the thrown exception.
     *
     * @param exceptionPolicices the configured exception policies to resolve from
     * @param exchange           the exchange
     * @param exception          the exception that was thrown
     * @return the resolved exception type to handle this exception, <tt>null</tt> if none found.
     */
    ExceptionType getExceptionPolicy(Map<Class, ExceptionType> exceptionPolicices, Exchange exchange,
                                            Throwable exception);
}
"
org.apache.camel.processor.idempotent.IdempotentConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExpressionHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent
 * Consumer</a> pattern.
 * 
 * @version $Revision: 630568 $
 */
public class IdempotentConsumer extends ServiceSupport implements Processor {
    private static final transient Log LOG = LogFactory.getLog(IdempotentConsumer.class);
    private Expression<Exchange> messageIdExpression;
    private Processor nextProcessor;
    private MessageIdRepository messageIdRepository;
    public IdempotentConsumer(Expression<Exchange> messageIdExpression,
                              MessageIdRepository messageIdRepository, Processor nextProcessor) {
        this.messageIdExpression = messageIdExpression;
        this.messageIdRepository = messageIdRepository;
        this.nextProcessor = nextProcessor;
    }
    @Override
    public String toString() {
        return ""IdempotentConsumer[expression="" + messageIdExpression + "", repository="" + messageIdRepository
               + "", processor="" + nextProcessor + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        String messageId = ExpressionHelper.evaluateAsString(messageIdExpression, exchange);
        if (messageId == null) {
            throw new NoMessageIdException(exchange, messageIdExpression);
        }
        if (!messageIdRepository.contains(messageId)) {
            nextProcessor.process(exchange);
        } else {
            onDuplicateMessage(exchange, messageId);
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public Expression<Exchange> getMessageIdExpression() {
        return messageIdExpression;
    }
    public MessageIdRepository getMessageIdRepository() {
        return messageIdRepository;
    }
    public Processor getNextProcessor() {
        return nextProcessor;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(nextProcessor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(nextProcessor);
    }
    /**
     * A strategy method to allow derived classes to overload the behaviour of
     * processing a duplicate message
     * 
     * @param exchange the exchange
     * @param messageId the message ID of this exchange
     */
    protected void onDuplicateMessage(Exchange exchange, String messageId) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Ignoring duplicate message with id: "" + messageId + "" for exchange: "" + exchange);
        }
    }
}
"
org.apache.camel.processor.idempotent.MemoryMessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.util.LRUCache;
/**
 * A memory based implementation of {@link MessageIdRepository}. Care should be
 * taken to use a suitable underlying {@link Map} to avoid this class being a
 * memory leak
 * 
 * @version $Revision: 664441 $
 */
public class MemoryMessageIdRepository implements MessageIdRepository {
    private final Map cache;
    public MemoryMessageIdRepository(Map set) {
        this.cache = set;
    }
    /**
     * Creates a new MemoryMessageIdRepository with a memory based repository.
     * <b>Warning</b> this method should only really be used for testing as it
     * will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository() {
        return memoryMessageIdRepository(new HashMap());
    }
    /**
     * Creates a new MemoryMessageIdRepository with a memory based repository.
     * <b>Warning</b> this method should only really be used for testing as it
     * will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository(int cacheSize) {
        return memoryMessageIdRepository(new LRUCache(cacheSize));
    }
    /**
     * Creates a new MemoryMessageIdRepository using the given {@link Map} to
     * use to store the processed Message ID objects. Warning be careful of the
     * implementation of Map you use as if you are not careful it could be a
     * memory leak.
     */
    public static MessageIdRepository memoryMessageIdRepository(Map cache) {
        return new MemoryMessageIdRepository(cache);
    }
    public boolean contains(String messageId) {
        synchronized (cache) {
            if (cache.containsKey(messageId)) {
                return true;
            } else {
                cache.put(messageId, messageId);
                return false;
            }
        }
    }
}
"
org.apache.camel.processor.idempotent.MessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
/**
 * Access to a repository of Message IDs to implement the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 630568 $
 */
public interface MessageIdRepository {
    /**
     * Returns true if this messageId has been processed before
     * otherwise this messageId is added to the repository and false is returned.
     *
     * @param messageId the String ID of the message
     * @return true if the message has been processed succesfully before otherwise false
     */
    boolean contains(String messageId);
}
"
org.apache.camel.processor.idempotent.NoMessageIdException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if no message ID could be found on a message which is to be used with the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 630568 $
 */
public class NoMessageIdException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Expression expression;
    public NoMessageIdException(Exchange exchange, Expression expression) {
        super(""No message ID could be found using expression: "" + expression + "" on message exchange: "" + exchange);
        this.exchange = exchange;
        this.expression = expression;
    }
    /**
     * The exchange which caused this failure
     */
    public Exchange getExchange() {
        return exchange;
    }
    /**
     * The expression which was used
     */
    public Expression getExpression() {
        return expression;
    }
}
"
org.apache.camel.processor.interceptor.Breakpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
/**
 * @version $Revision: 662301 $
 */
public class Breakpoint {
    public void waitForBreakpoint(Exchange exchange) {
        // TODO
    }
}
"
org.apache.camel.processor.interceptor.Debugger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An interceptor strategy for debugging and tracing routes
 *
 * @version $Revision: 671751 $
 */
public class Debugger implements InterceptStrategy {
    private static final transient Log LOG = LogFactory.getLog(Debugger.class);
    private int exchangeBufferSize = -1;
    private Map<String, DebugInterceptor> interceptors = new HashMap<String, DebugInterceptor>();
    private boolean logExchanges = true;
    private TraceFormatter formatter = new TraceFormatter();
    /**
     * A helper method to return the debugger instance for a given {@link CamelContext} if one is enabled
     *
     * @param context the camel context the debugger is connected to
     * @return the debugger or null if none can be found
     */
    public static Debugger getDebugger(CamelContext context) {
        if (context instanceof DefaultCamelContext) {
            DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
            List<InterceptStrategy> list = defaultCamelContext.getInterceptStrategies();
            for (InterceptStrategy interceptStrategy : list) {
                if (interceptStrategy instanceof Debugger) {
                    return (Debugger)interceptStrategy;
                }
            }
        }
        return null;
    }
    public DebugInterceptor getInterceptor(String id) {
        return interceptors.get(id);
    }
    /**
     * Returns the list of exchanges sent to the given node in the DSL
     */
    public List<Exchange> getExchanges(String id) {
        DebugInterceptor interceptor = getInterceptor(id);
        if (interceptor == null) {
            return null;
        } else {
            return interceptor.getExchanges();
        }
    }
    /**
     * Returns the breakpoint object for the given node in the DSL
     */
    public Breakpoint getBreakpoint(String id) {
        DebugInterceptor interceptor = getInterceptor(id);
        if (interceptor == null) {
            return null;
        } else {
            return interceptor.getBreakpoint();
        }
    }
    public Processor wrapProcessorInInterceptors(ProcessorType processorType, Processor target) throws Exception {
        String id = processorType.idOrCreate();
        if (logExchanges) {
            target = new TraceInterceptor(processorType, target, formatter);
        }
        DebugInterceptor interceptor = new DebugInterceptor(processorType, target, createExchangeList(), createExceptionsList());
        interceptors.put(id, interceptor);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Adding "" + id + "" interceptor: "" + interceptor);
        }
        return interceptor;
    }
    protected List<Exchange> createExchangeList() {
        if (exchangeBufferSize == 0) {
            return null;
        } else if (exchangeBufferSize > 0) {
            // TODO lets create a non blocking fixed size queue
            return new ArrayList<Exchange>();
        } else {
            return new ArrayList<Exchange>();
        }
    }
    protected List<ExceptionEvent> createExceptionsList() {
        // TODO allow some kinda LRU based fixed size list to be used?
        return new ArrayList<ExceptionEvent>();
    }
}
"
org.apache.camel.processor.interceptor.DebugInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.processor.DelegateProcessor;
/**
 * An interceptor for debugging and tracing routes
 *
 * @version $Revision: 664245 $
 */
public class DebugInterceptor extends DelegateProcessor {
    private final ProcessorType node;
    private final List<Exchange> exchanges;
    private final List<ExceptionEvent> exceptions;
    private Predicate traceFilter;
    private Breakpoint breakpoint = new Breakpoint();
    private boolean traceExceptions = true;
    public DebugInterceptor(ProcessorType node, Processor target, List<Exchange> exchanges, List<ExceptionEvent> exceptions) {
        super(target);
        this.node = node;
        this.exchanges = exchanges;
        this.exceptions = exceptions;
    }
    @Override
    public String toString() {
        return ""DebugInterceptor["" + node + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        checkForBreakpoint(exchange);
        addTraceExchange(exchange);
        try {
            super.proceed(exchange);
        } catch (Exception e) {
            onException(exchange, e);
            throw e;
        } catch (Error e) {
            onException(exchange, e);
            throw e;
        }
    }
    public ProcessorType getNode() {
        return node;
    }
    public List<Exchange> getExchanges() {
        return exchanges;
    }
    public List<ExceptionEvent> getExceptions() {
        return exceptions;
    }
    public Breakpoint getBreakpoint() {
        return breakpoint;
    }
    public Predicate getTraceFilter() {
        return traceFilter;
    }
    public void setTraceFilter(Predicate traceFilter) {
        this.traceFilter = traceFilter;
    }
    public boolean isTraceExceptions() {
        return traceExceptions;
    }
    public void setTraceExceptions(boolean traceExceptions) {
        this.traceExceptions = traceExceptions;
    }
    /**
     * Stategy method to wait for a breakpoint if one is set
     */
    protected void checkForBreakpoint(Exchange exchange) {
        breakpoint.waitForBreakpoint(exchange);
    }
    /**
     * Fired when an exception is thrown when processing the underlying processor
     */
    protected void onException(Exchange exchange, Throwable e) {
        if (shouldTraceExceptionEvents(exchange, e))  {
            exceptions.add(new ExceptionEvent(this, exchange, e));
        }
    }
    private boolean shouldTraceExceptionEvents(Exchange exchange, Throwable e) {
        return isTraceExceptions();
    }
    /**
     * Strategy method to store the exchange in a trace log if it is enabled
     */
    protected void addTraceExchange(Exchange exchange) {
        if (shouldTraceExchange(exchange)) {
            exchanges.add(copyExchange(exchange));
        }
    }
    protected Exchange copyExchange(Exchange previousExchange) {
        Exchange answer = previousExchange.newInstance();
        answer.getProperties().putAll(previousExchange.getProperties());
        answer.getIn().copyFrom(previousExchange.getIn());
        // only copy the out if its defined
        Message previousOut = previousExchange.getOut(false);
        if (previousOut != null) {
            answer.getOut().copyFrom(previousOut);
        }
        return answer;
    }
    /**
     * Returns true if the given exchange should be logged in the trace list
     */
    protected boolean shouldTraceExchange(Exchange exchange) {
        return traceFilter == null || traceFilter.matches(exchange);
    }
}
"
org.apache.camel.processor.interceptor.ExceptionEvent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
/**
 * Represents an exception that occurred when processing an exchange
 *
 * @version $Revision: 673954 $
 */
public class ExceptionEvent {
    private final DebugInterceptor interceptor;
    private final Exchange exchange;
    private final Throwable exception;
    public ExceptionEvent(DebugInterceptor interceptor, Exchange exchange, Throwable exception) {
        this.interceptor = interceptor;
        this.exchange = exchange;
        this.exception = exception;
    }
    public Throwable getException() {
        return exception;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public DebugInterceptor getInterceptor() {
        return interceptor;
    }
}
"
org.apache.camel.processor.interceptor.ExchangeFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
/**
 * A plugin used to turn an {@link Exchange} into a String
 * so it can be logged to a file
 *
 * @version $Revision: 673954 $
 */
public interface ExchangeFormatter {
    /**
     * Generates a string representation of the exchange
     */
    Object format(Exchange exchange);
}
"
org.apache.camel.processor.interceptor.StreamCachingInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.model.InterceptorRef;
import org.apache.camel.model.InterceptorType;
import org.apache.camel.processor.Interceptor;
/**
 * {@link Interceptor} that converts a message into a re-readable format
 */
public class StreamCachingInterceptor extends Interceptor {
    public StreamCachingInterceptor() {
        super();
        setInterceptorLogic(new Processor() {
            public void process(Exchange exchange) throws Exception {
                Object newBody = exchange.getIn().getBody(StreamCache.class);
                if (newBody != null) {
                    exchange.getIn().setBody(newBody);
                }
                proceed(exchange);
            }
        });
    }
    public StreamCachingInterceptor(Processor processor) {
        this();
        setProcessor(processor);
    }
    @Override
    public String toString() {
        return ""StreamCachingInterceptor"";
    }
    /**
     * Remove the {@link StreamCachingInterceptor} type of interceptor from the given list of interceptors
     *
     * @param interceptors the list of interceptors
     */
    public static void noStreamCaching(List<InterceptorType> interceptors) {
        for (int i = 0; i < interceptors.size(); i++) {
            InterceptorType interceptor = interceptors.get(i);
            if (interceptor instanceof InterceptorRef
                && ((InterceptorRef)interceptor).getInterceptor() instanceof StreamCachingInterceptor) {
                interceptors.remove(interceptor);
            }
        }
    }
}
"
org.apache.camel.processor.interceptor.StreamCachingInterceptorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import java.io.StringReader;
import java.util.LinkedList;
import java.util.List;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.converter.stream.StreamCache;
import org.apache.camel.model.InterceptorRef;
import org.apache.camel.model.InterceptorType;
import org.apache.camel.processor.DelegateProcessor;
public class StreamCachingInterceptorTest extends ContextTestSupport {
    private MockEndpoint a;
    private MockEndpoint b;
    public void testConvertStreamSourceWithRouteBuilderStreamCaching() throws Exception {
        a.expectedMessageCount(1);
        StreamSource message = new StreamSource(new StringReader(""<hello>world!</hello>""));
        template.sendBody(""direct:a"", message);
        assertMockEndpointsSatisifed();
        assertTrue(a.assertExchangeReceived(0).getIn().getBody() instanceof StreamCache);
    }
    public void testConvertStreamSourceWithRouteOnlyStreamCaching() throws Exception {
        b.expectedMessageCount(1);
        StreamSource message = new StreamSource(new StringReader(""<hello>world!</hello>""));
        template.sendBody(""direct:b"", message);
        assertMockEndpointsSatisifed();
        assertTrue(b.assertExchangeReceived(0).getIn().getBody() instanceof StreamCache);
    }
    public void testIgnoreAlreadyRereadable() throws Exception {
        a.expectedMessageCount(1);
        template.sendBody(""direct:a"", ""<hello>world!</hello>"");
        assertMockEndpointsSatisifed();
        assertTrue(a.assertExchangeReceived(0).getIn().getBody() instanceof String);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                //Stream caching for a single route...
                from(""direct:a"").streamCaching().to(""mock:a"");
                //... or for all the following routes in this builder
                streamCaching();
                from(""direct:b"").to(""mock:b"");
            }
        };
    }
    public void testNoStreamCaching() throws Exception {
        List<InterceptorType> interceptors = new LinkedList<InterceptorType>();
        InterceptorRef streamCache = new InterceptorRef(new StreamCachingInterceptor());
        interceptors.add(streamCache);
        interceptors.add(new InterceptorRef(new DelegateProcessor()));
        StreamCachingInterceptor.noStreamCaching(interceptors);
        assertEquals(1, interceptors.size());
        assertFalse(interceptors.contains(streamCache));
    }
}
"
org.apache.camel.processor.interceptor.TraceFormatter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.spi.UnitOfWork;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: 676850 $
 */
public class TraceFormatter {
    private boolean showBreadCrumb = true;
    private boolean showNode = true;
    private boolean showExchangeId;
    private boolean showProperties = true;
    private boolean showHeaders = true;
    private boolean showBody = true;
    private boolean showBodyType = true;
    public Object format(TraceInterceptor interceptor, Exchange exchange) {
        Message in = exchange.getIn();
        Throwable exception = exchange.getException();
        return (showBreadCrumb ? getBreadCrumbID(exchange) + "" "" : """")
                + ""-> "" + getNodeMessage(interceptor) + "" ""
                + (showNode ? interceptor.getNode() + "" "" : """")
                + exchange.getPattern()
                + (showExchangeId ? "" Id: "" + exchange.getExchangeId() : """")
                + (showProperties ? "" Properties:"" + exchange.getProperties() : """")
                + (showHeaders ? "" Headers:"" + in.getHeaders() : """")
                + (showBodyType ? "" BodyType:"" + getBodyTypeAsString(in) : """")
                + (showBody ? "" Body:"" + getBodyAsString(in) : """")
                + (exception != null ? "" Exception: "" + exception : """");
    }
    public boolean isShowBody() {
        return showBody;
    }
    public void setShowBody(boolean showBody) {
        this.showBody = showBody;
    }
    public boolean isShowBodyType() {
        return showBodyType;
    }
    public void setShowBodyType(boolean showBodyType) {
        this.showBodyType = showBodyType;
    }
    public boolean isShowBreadCrumb() {
        return showBreadCrumb;
    }
    public void setShowBreadCrumb(boolean showBreadCrumb) {
        this.showBreadCrumb = showBreadCrumb;
    }
    public boolean isShowExchangeId() {
        return showExchangeId;
    }
    public void setShowExchangeId(boolean showExchangeId) {
        this.showExchangeId = showExchangeId;
    }
    public boolean isShowHeaders() {
        return showHeaders;
    }
    public void setShowHeaders(boolean showHeaders) {
        this.showHeaders = showHeaders;
    }
    public boolean isShowProperties() {
        return showProperties;
    }
    public void setShowProperties(boolean showProperties) {
        this.showProperties = showProperties;
    }
    public boolean isShowNode() {
        return showNode;
    }
    public void setShowNode(boolean showNode) {
        this.showNode = showNode;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected Object getBreadCrumbID(Exchange exchange) {
        UnitOfWork unitOfWork = exchange.getUnitOfWork();
        return unitOfWork.getId();
    }
    protected Object getBodyAsString(Message in) {
        Object answer = in.getBody(String.class);
        if (answer == null) {
            answer = in.getBody();
        }
        return answer;
    }
    protected Object getBodyTypeAsString(Message message) {
        String answer = ObjectHelper.className(message.getBody());
        if (answer.startsWith(""java.lang."")) {
            return answer.substring(10);
        }
        return answer;
    }
    protected String getNodeMessage(TraceInterceptor interceptor) {
        return interceptor.getNode().idOrCreate();
    }
}
"
org.apache.camel.processor.interceptor.TraceInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An interceptor for debugging and tracing routes
 *
 * @version $Revision: 669650 $
 */
public class TraceInterceptor extends DelegateProcessor implements ExchangeFormatter {
    private final ProcessorType node;
    private Predicate traceFilter;
    private boolean traceExceptions = true;
    private Logger logger = new Logger(LogFactory.getLog(TraceInterceptor.class), this);
    private TraceFormatter formatter;
    public TraceInterceptor(ProcessorType node, Processor target, TraceFormatter formatter) {
        super(target);
        this.node = node;
        this.formatter = formatter;
    }
    @Override
    public String toString() {
        return ""TraceInterceptor["" + node + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        try {
            if (shouldLogExchange(exchange)) {
                logExchange(exchange);
            }
            super.proceed(exchange);
        } catch (Exception e) {
            logException(exchange, e);
            throw e;
        } catch (Error e) {
            logException(exchange, e);
            throw e;
        }
    }
    public Object format(Exchange exchange) {
        return formatter.format(this, exchange);
    }
    // Properties
    //-------------------------------------------------------------------------
    public ProcessorType getNode() {
        return node;
    }
    public Predicate getTraceFilter() {
        return traceFilter;
    }
    public void setTraceFilter(Predicate traceFilter) {
        this.traceFilter = traceFilter;
    }
    public boolean isTraceExceptions() {
        return traceExceptions;
    }
    public void setTraceExceptions(boolean traceExceptions) {
        this.traceExceptions = traceExceptions;
    }
    public Logger getLogger() {
        return logger;
    }
    public TraceFormatter getFormatter() {
        return formatter;
    }
    public void setFormatter(TraceFormatter formatter) {
        this.formatter = formatter;
    }
    public LoggingLevel getLevel() {
        return getLogger().getLevel();
    }
    public Log getLog() {
        return getLogger().getLog();
    }
    public void setLog(Log log) {
        getLogger().setLog(log);
    }
    public void setLevel(LoggingLevel level) {
        getLogger().setLevel(level);
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void logExchange(Exchange exchange) {
        logger.process(exchange);
    }
    protected void logException(Exchange exchange, Throwable throwable) {
        logger.process(exchange, throwable);
    }
    /**
     * Returns true if the given exchange should be logged in the trace list
     */
    protected boolean shouldLogExchange(Exchange exchange) {
        return traceFilter == null || traceFilter.matches(exchange);
    }
}
"
org.apache.camel.processor.interceptor.Tracer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.interceptor;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.InterceptStrategy;
/**
 * An interceptor strategy for tracing routes
 *
 * @version $Revision: 675876 $
 */
public class Tracer implements InterceptStrategy {
    private TraceFormatter formatter = new TraceFormatter();
    public Processor wrapProcessorInInterceptors(ProcessorType processorType, Processor target) throws Exception {
        // Force the creation of an id, otherwise the id is not available when the trace formatter is
        // outputting trace information
        String id = processorType.idOrCreate();
        return new TraceInterceptor(processorType, target, formatter);
    }
    public TraceFormatter getFormatter() {
        return formatter;
    }
    public void setFormatter(TraceFormatter formatter) {
        this.formatter = formatter;
    }
}
"
org.apache.camel.processor.loadbalancer.LoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Processor;
/**
 * A strategy for load balancing across a number of {@link Processor} instances
 *
 * @version $Revision: 630568 $
 */
public interface LoadBalancer extends Processor {
    /**
     * Adds a new processor to the load balancer
     *
     * @param processor the processor to be added to the load balancer
     */
    void addProcessor(Processor processor);
    /**
     * Removes the given processor from the load balancer
     *
     * @param processor the processor to be removed from the load balancer
     */
    void removeProcessor(Processor processor);
    /**
     * Returns the current processors available to this load balancer
     *
     * @return the processors available
     */
    List<Processor> getProcessors();
}
"
org.apache.camel.processor.loadbalancer.LoadBalancerConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * Represents a consumer which on starting registers itself with a {@link LoadBalancer} and on closing unregisters
 * itself with a load balancer
 *
 * @version $Revision: 640438 $
 */
public class LoadBalancerConsumer extends DefaultConsumer<Exchange> {
    private final LoadBalancer loadBalancer;
    public LoadBalancerConsumer(Endpoint endpoint, Processor processor, LoadBalancer loadBalancer) {
        super(endpoint, processor);
        this.loadBalancer = loadBalancer;
    }
    @Override
    protected void doStart() throws Exception {
        loadBalancer.addProcessor(getProcessor());
    }
    @Override
    protected void doStop() throws Exception {
        loadBalancer.removeProcessor(getProcessor());
    }
}
"
org.apache.camel.processor.loadbalancer.LoadBalancerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * A default base class for a {@link LoadBalancer} implementation
 *
 * @version $Revision: 630568 $
 */
public abstract class LoadBalancerSupport extends ServiceSupport implements LoadBalancer {
    private List<Processor> processors = new CopyOnWriteArrayList<Processor>();
    public void addProcessor(Processor processor) {
        processors.add(processor);
    }
    public void removeProcessor(Processor processor) {
        processors.remove(processor);
    }
    public List<Processor> getProcessors() {
        return processors;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processors);        
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors);       
    }
}
"
org.apache.camel.processor.loadbalancer.QueueLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A base class for {@link LoadBalancer} implementations which choose a single
 * destination for each exchange (rather like JMS Queues)
 * 
 * @version $Revision: 630568 $
 */
public abstract class QueueLoadBalancer extends LoadBalancerSupport {
    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        if (list.isEmpty()) {
            throw new IllegalStateException(""No processors available to process "" + exchange);
        }
        Processor processor = chooseProcessor(list, exchange);
        if (processor == null) {
            throw new IllegalStateException(""No processors could be chosen to process "" + exchange);
        } else {
            processor.process(exchange);
        }
    }
    protected abstract Processor chooseProcessor(List<Processor> processors, Exchange exchange);
}
"
org.apache.camel.processor.loadbalancer.RandomLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Implements the random load balancing policy
 *
 * @version $Revision: 630568 $
 */
public class RandomLoadBalancer extends QueueLoadBalancer {
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        while (true) {
            int index = (int) Math.round(Math.random() * size);
            if (index < size) {
                return processors.get(index);
            }
        }
    }
}
"
org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Implements the round robin load balancing policy
 *
 * @version $Revision: 630568 $
 */
public class RoundRobinLoadBalancer extends QueueLoadBalancer {
    private int counter = -1;
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        if (++counter >= size) {
            counter = 0;
        }
        return processors.get(counter);
    }
}
"
org.apache.camel.processor.loadbalancer.StickyLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
/**
 * Implements a sticky load balancer using an {@link Expression} to calculate
 * a correlation key to perform the sticky load balancing; rather like jsessionid in the web
 * or JMSXGroupID in JMS.
 *
 * @version $Revision: 659849 $
 */
public class StickyLoadBalancer extends QueueLoadBalancer {
    private Expression<Exchange> correlationExpression;
    private QueueLoadBalancer loadBalancer;
    private int numberOfHashGroups = 64 * 1024;
    private final Map<Object, Processor> stickyMap = new HashMap<Object, Processor>();
    public StickyLoadBalancer() {
        this.loadBalancer = new RoundRobinLoadBalancer();
    }
    public StickyLoadBalancer(Expression<Exchange> correlationExpression) {
        this(correlationExpression, new RoundRobinLoadBalancer());
    }
    public StickyLoadBalancer(Expression<Exchange> correlationExpression, QueueLoadBalancer loadBalancer) {
        this.correlationExpression = correlationExpression;
        this.loadBalancer = loadBalancer;
    }
    public void setCorrelationExpression(Expression<Exchange> correlationExpression) {
        this.correlationExpression = correlationExpression;
    }
    public void setLoadBalancer(QueueLoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        Object value = correlationExpression.evaluate(exchange);
        Object key = getStickyKey(value);
        Processor processor;
        synchronized (stickyMap) {
            processor = stickyMap.get(key);
            if (processor == null) {
                processor = loadBalancer.chooseProcessor(processors, exchange);
                stickyMap.put(key, processor);
            }
        }
        return processor;
    }
    @Override
    public void removeProcessor(Processor processor) {
        synchronized (stickyMap) {
            Iterator<Map.Entry<Object, Processor>> iter = stickyMap.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<Object, Processor> entry = iter.next();
                if (processor.equals(entry.getValue())) {
                    iter.remove();
                }
            }
        }
        super.removeProcessor(processor);
    }
    // Properties
    //-------------------------------------------------------------------------
    public int getNumberOfHashGroups() {
        return numberOfHashGroups;
    }
    public void setNumberOfHashGroups(int numberOfHashGroups) {
        this.numberOfHashGroups = numberOfHashGroups;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * A strategy to create the key for the sticky load balancing map.
     * The default implementation uses the hash code of the value
     * then modulos by the numberOfHashGroups to avoid the sticky map getting too big
     *
     * @param value the correlation value
     * @return the key to be used in the sticky map
     */
    protected Object getStickyKey(Object value) {
        int hashCode = 37;
        if (value != null) {
            hashCode = value.hashCode();
        }
        if (numberOfHashGroups > 0) {
            hashCode = hashCode % numberOfHashGroups;
        }
        return hashCode;
    }
}
"
org.apache.camel.processor.loadbalancer.TopicLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A {@link LoadBalancer} implementations which sends to all destinations
 * (rather like JMS Topics)
 * 
 * @version $Revision: 659782 $
 */
public class TopicLoadBalancer extends LoadBalancerSupport {
    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        for (Processor processor : list) {
            Exchange copy = copyExchangeStrategy(processor, exchange);
            processor.process(copy);
        }
    }
    /**
     * Strategy method to copy the exchange before sending to another endpoint.
     * Derived classes such as the {@link org.apache.camel.processor.Pipeline Pipeline}
     * will not clone the exchange
     * 
     * @param processor the processor that will send the exchange
     * @param exchange  the exchange
     * @return the current exchange if no copying is required such as for a
     *         pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Processor processor, Exchange exchange) {
        return exchange.copy();
    }
}
"
org.apache.camel.processor.resequencer.DefaultExchangeComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * Compares elements of an {@link Exchange} sequence by comparing
 * <code>long</code> values returned by this comaprator's
 * <code>expression</code>. The expression is set during route definition
 * e.g.
 * 
 * <pre>
 *    ...resequencer(header(&quot;seqnum&quot;)).stream()...
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 630591 $
 */
public class DefaultExchangeComparator implements ExpressionResultComparator<Exchange> {
    private Expression<Exchange> expression;
    public Expression<Exchange> getExpression() {
        return expression;
    }
    public void setExpression(Expression<Exchange> expression) {
        this.expression = expression;
    }
    @SuppressWarnings(""unchecked"")
    public void setExpressions(List<Expression> expressions) {
        if (expressions.isEmpty()) {
            throw new IllegalArgumentException(
                    ""Expression required to resolve sequence number"");
        } else if (expressions.size() > 1) {
            throw new IllegalArgumentException(
                    ""More than one expression currently not supported"");
        }
        expression = expressions.get(0);
    }
    public boolean predecessor(Exchange o1, Exchange o2) {
        long n1 = getSequenceNumber(o1);
        long n2 = getSequenceNumber(o2);
        return n1 == (n2 - 1L);
    }
    public boolean successor(Exchange o1, Exchange o2) {
        long n1 = getSequenceNumber(o1);
        long n2 = getSequenceNumber(o2);
        return n2 == (n1 - 1L);
    }
    public int compare(Exchange o1, Exchange o2) {
        Long n1 = getSequenceNumber(o1);
        Long n2 = getSequenceNumber(o2);
        return n1.compareTo(n2);
    }
    private long getSequenceNumber(Exchange exchange) {
        return (Long)expression.evaluate(exchange);
    }
}
"
org.apache.camel.processor.resequencer.Element,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * A container for objects to be resequenced. This container can be scheduled
 * for timing out. Non-scheduled objects or already timed-out objects are ready
 * for being released by the {@link ResequencerEngine}.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
class Element<E> implements TimeoutHandler {
    /**
     * The contained object.
     */
    private E object;
    /**
     * Not <code>null</code> if this element is currently beeing scheduled for
     * timing out.
     */
    private Timeout timeout;
    /**
     * Creates a new container instance.
     * 
     * @param object contained object.
     */
    public Element(E object) {
        this.object = object;
    }
    /**
     * Returns the contained object.
     * 
     * @return the contained object.
     */
    public E getObject() {
        return object;
    }
    /**
     * Returns <code>true</code> if this element is currently scheduled for
     * timing out.
     * 
     * @return <code>true</code> if scheduled or <code>false</code> if not
     *         scheduled or already timed-out.
     */
    public synchronized boolean scheduled() {
        return timeout != null;
    }
    /**
     * Schedules the given timeout task. Before this methods calls the
     * {@link Timeout#schedule()} method it adds this element as timeout
     * listener.
     * 
     * @param t a timeout task.
     */
    public synchronized void schedule(Timeout t) {
        this.timeout = t;
        this.timeout.addTimeoutHandlerFirst(this);
        this.timeout.schedule();
    }
    /**
     * Cancels the scheduled timeout for this element. If this element is not
     * scheduled or has already timed-out this method has no effect.
     */
    public synchronized void cancel() {
        if (timeout != null) {
            timeout.cancel();
        }
        timeout(null);
    }
    /**
     * Marks this element as timed-out.
     * 
     * @param t timeout task that caused the notification.
     */
    public synchronized void timeout(Timeout t) {
        this.timeout = null;
    }
}
"
org.apache.camel.processor.resequencer.ElementComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * A strategy for comparing {@link Element} instances. This strategy uses
 * another {@link SequenceElementComparator} instance for comparing elements
 * contained by {@link Element} instances.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
class ElementComparator<E> implements SequenceElementComparator<Element<E>> {
    /**
     * A sequence element comparator this comparator delegates to.
     */
    private SequenceElementComparator<E> comparator;
    /**
     * Creates a new element comparator instance.
     * 
     * @param comparator a sequence element comparator this comparator delegates
     *        to.
     */
    public ElementComparator(SequenceElementComparator<E> comparator) {
        this.comparator = comparator;
    }
    /**
     * @see SequenceElementComparator#predecessor(java.lang.Object, java.lang.Object)
     */
    public boolean predecessor(Element<E> o1, Element<E> o2) {
        return comparator.predecessor(o1.getObject(), o2.getObject());
    }
    /**
     * @see SequenceElementComparator#successor(java.lang.Object, java.lang.Object)
     */
    public boolean successor(Element<E> o1, Element<E> o2) {
        return comparator.successor(o1.getObject(), o2.getObject());
    }
    /**
     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
     */
    public int compare(Element<E> o1, Element<E> o2) {
        return comparator.compare(o1.getObject(), o2.getObject());
    }
}
"
org.apache.camel.processor.resequencer.ExpressionResultComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A {@link SequenceElementComparator} that compares {@link Exchange}s based on
 * the result of an expression evaluation.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 630591 $
 */
public interface ExpressionResultComparator<E extends Exchange> extends SequenceElementComparator<E> {
    /**
     * Sets the list expressions used for comparing {@link Exchange}s.
     * 
     * @param expressions a list of {@link Expression} objects.
     */
    void setExpressions(List<Expression> expressions);
}
"
org.apache.camel.processor.resequencer.ResequencerEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.Queue;
import java.util.Timer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Resequences elements based on a given {@link SequenceElementComparator}.
 * This resequencer is designed for resequencing element streams. Resequenced
 * elements are added to an output {@link Queue}. The resequencer is configured
 * via the <code>timeout</code> and <code>capacity</code> properties.
 * 
 * <ul>
 * <li><code>timeout</code>. Defines the timeout (in milliseconds) for a
 * given element managed by this resequencer. An out-of-sequence element can
 * only be marked as <i>ready-for-delivery</i> if it either times out or if it
 * has an immediate predecessor (in that case it is in-sequence). If an
 * immediate predecessor of a waiting element arrives the timeout task for the
 * waiting element will be cancelled (which marks it as <i>ready-for-delivery</i>).
 * <p>
 * If the maximum out-of-sequence time between elements within a stream is
 * known, the <code>timeout</code> value should be set to this value. In this
 * case it is guaranteed that all elements of a stream will be delivered in
 * sequence to the output queue. However, large <code>timeout</code> values
 * might require a very high resequencer <code>capacity</code> which might be
 * in conflict with available memory resources. The lower the
 * <code>timeout</code> value is compared to the out-of-sequence time between
 * elements within a stream the higher the probability is for out-of-sequence
 * elements delivered by this resequencer.</li>
 * <li><code>capacity</code>. The capacity of this resequencer.</li>
 * </ul>
 * 
 * Whenever a timeout for a certain element occurs or an element has been added
 * to this resequencer a delivery attempt is started. If a (sub)sequence of
 * elements is <i>ready-for-delivery</i> then they are added to output queue.
 * <p>
 * The resequencer remembers the last-delivered element. If an element arrives
 * which is the immediate successor of the last-delivered element it will be
 * delivered immediately and the last-delivered element is adjusted accordingly.
 * If the last-delivered element is <code>null</code> i.e. the resequencer was
 * newly created the first arriving element will wait <code>timeout</code>
 * milliseconds for being delivered to the output queue.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public class ResequencerEngine<E> implements TimeoutHandler {
    private static final transient Log LOG = LogFactory.getLog(ResequencerEngine.class);
    private long timeout;    
    private int capacity;    
    private Queue<E> outQueue;    
    private Element<E> lastDelivered;
    /**
     * A sequence of elements for sorting purposes.
     */
    private Sequence<Element<E>> sequence;
    /**
     * A timer for scheduling timeout notifications.
     */
    private Timer timer;
    /**
     * Creates a new resequencer instance with a default timeout of 2000
     * milliseconds. The capacity is set to {@link Integer#MAX_VALUE}.
     * 
     * @param comparator a sequence element comparator.
     */
    public ResequencerEngine(SequenceElementComparator<E> comparator) {
        this(comparator, Integer.MAX_VALUE);
    }
    /**
     * Creates a new resequencer instance with a default timeout of 2000
     * milliseconds.
     * 
     * @param comparator a sequence element comparator.
     * @param capacity the capacity of this resequencer.
     */
    public ResequencerEngine(SequenceElementComparator<E> comparator, int capacity) {
        this.timer = new Timer(""Resequencer Timer"");
        this.sequence = createSequence(comparator);
        this.capacity = capacity;
        this.timeout = 2000L;
        this.lastDelivered = null;
    }
    /**
     * Stops this resequencer (i.e. this resequencer's {@link Timer} instance).
     */
    public void stop() {
        this.timer.cancel();
    }
    /**
     * Returns the output queue.
     * 
     * @return the output queue.
     */
    public Queue<E> getOutQueue() {
        return outQueue;
    }
    /**
     * Sets the output queue.
     * 
     * @param outQueue output queue.
     */
    public void setOutQueue(Queue<E> outQueue) {
        this.outQueue = outQueue;
    }
    /**
     * Returns this resequencer's timeout value.
     * 
     * @return the timeout in milliseconds.
     */
    public long getTimeout() {
        return timeout;
    }
    /**
     * Sets this sequencer's timeout value.
     * 
     * @param timeout the timeout in milliseconds.
     */
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    /** 
     * Handles a timeout notification by starting a delivery attempt.
     * 
     * @param timout timeout task that caused the notification.
     */
    public synchronized void timeout(Timeout timout) {
        try {
            while (deliver()) {
                // work done in deliver()
            }
        } catch (RuntimeException e) {
            LOG.error(""error during delivery"", e);
        }
    }
    /**
     * Adds an element to this resequencer throwing an exception if the maximum
     * capacity is reached.
     * 
     * @param o element to be resequenced.
     * @throws IllegalStateException if the element cannot be added at this time
     *         due to capacity restrictions.
     */
    public synchronized void add(E o) {
        if (sequence.size() >= capacity) {
            throw new IllegalStateException(""maximum capacity is reached"");
        }
        insert(o);
    }
    /**
     * Adds an element to this resequencer waiting, if necessary, until capacity
     * becomes available.
     * 
     * @param o element to be resequenced.
     * @throws InterruptedException if interrupted while waiting.
     */
    public synchronized void put(E o) throws InterruptedException {
        if (sequence.size() >= capacity) {
            wait();
        }
        insert(o);
    }
    /**
     * Returns the last delivered element.
     * 
     * @return the last delivered element or <code>null</code> if no delivery
     *         has been made yet.
     */
    E getLastDelivered() {
        if (lastDelivered == null) {
            return null;
        }
        return lastDelivered.getObject();
    }
    /**
     * Sets the last delivered element. This is for testing purposes only.
     * 
     * @param o an element.
     */
    void setLastDelivered(E o) {
        lastDelivered = new Element<E>(o);
    }
    /**
     * Inserts the given element into this resequencing queue (sequence). If the
     * element is not ready for immediate delivery and has no immediate
     * presecessor then it is scheduled for timing out. After being timed out it
     * is ready for delivery.
     * 
     * @param o an element.
     */
    private void insert(E o) {
        // wrap object into internal element
        Element<E> element = new Element<E>(o);
        // add element to sequence in proper order
        sequence.add(element);
        Element<E> successor = sequence.successor(element);
        // check if there is an immediate successor and cancel
        // timer task (no need to wait any more for timeout)
        if (successor != null) {
            successor.cancel();
        }
        // start delivery if current element is successor of last delivered element
        if (successorOfLastDelivered(element)) {
            // nothing to schedule
        } else if (sequence.predecessor(element) != null) {
            // nothing to schedule
        } else {
            Timeout t = defineTimeout();
            element.schedule(t);
        }
        // start delivery
        while (deliver()) {
            // work done in deliver()
        }
    }
    /**
     * Attempts to deliver a single element from the head of the resequencer
     * queue (sequence). Only elements which have not been scheduled for timing
     * out or which already timed out can be delivered.
     * 
     * @return <code>true</code> if the element has been delivered
     *         <code>false</code> otherwise.
     */
    private boolean deliver() {
        if (sequence.size() == 0) {
            return false;
        }
        // inspect element with lowest sequence value
        Element<E> element = sequence.first();
        // if element is scheduled do not deliver and return
        if (element.scheduled()) {
            return false;
        }
        // remove deliverable element from sequence
        sequence.remove(element);
        // set the delivered element to last delivered element
        lastDelivered = element;
        // notify a waiting thread that capacity is available
        notify();
        // add element to output queue
        outQueue.add(element.getObject());
        // element has been delivered
        return true;
    }
    /**
     * Returns <code>true</code> if the given element is the immediate
     * successor of the last delivered element.
     * 
     * @param element an element.
     * @return <code>true</code> if the given element is the immediate
     *         successor of the last delivered element.
     */
    private boolean successorOfLastDelivered(Element<E> element) {
        if (lastDelivered == null) {
            return false;
        }
        if (sequence.comparator().successor(element, lastDelivered)) {
            return true;
        }
        return false;
    }
    /**
     * Creates a timeout task based on the timeout setting of this resequencer.
     * 
     * @return a new timeout task.
     */
    private Timeout defineTimeout() {
        Timeout result = new Timeout(timer, timeout);
        result.addTimeoutHandler(this);
        return result;
    }
    private static <E> Sequence<Element<E>> createSequence(SequenceElementComparator<E> comparator) {
        return new Sequence<Element<E>>(new ElementComparator<E>(comparator));
    }
}
"
org.apache.camel.processor.resequencer.Sequence,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.TreeSet;
/**
 * A sorted set of elements with additional methods for obtaining immediate
 * successors and immediate predecessors of a given element in the sequence.
 * Successors and predecessors are calculated by using a
 * {@link SequenceElementComparator}.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public class Sequence<E> extends TreeSet<E> {
    private static final long serialVersionUID = 5647393631147741711L;
    private SequenceElementComparator<E> comparator;
    /**
     * Creates a new {@link Sequence} instance.
     * 
     * @param comparator a strategy for comparing elements of this sequence.
     */
    public Sequence(SequenceElementComparator<E> comparator) {
        super(comparator);
        this.comparator = comparator;
    }
    /**
     * Returns the immediate predecessor of the given element in this sequence
     * or <code>null</code> if no predecessor exists.
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E predecessor(E e) {
        E elem = lower(e);
        if (elem == null) {
            return null;
        }
        if (comparator.predecessor(elem, e)) {
            return elem;
        }
        return null;
    }
    /**
     * Returns the immediate successor of the given element in this sequence
     * or <code>null</code> if no successor exists.
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E successor(E e) {
        E elem = higher(e);
        if (elem == null) {
            return null;
        }
        if (comparator.successor(elem, e)) {
            return elem;
        }
        return null;
    }
    /**
     * Returns this sequence's comparator.
     * 
     * @return this sequence's comparator.
     */
    public SequenceElementComparator<E> comparator() {
        return comparator;
    }
    /**
     * Returns the next higher element in the sequence to the given element. If
     * the given element doesn't exist or if it is the last element in the
     * sequence <code>null</code> is returned. <strong>Please note that this
     * method is provided for compatibility with Java 5 SE. On a Java 6 SE
     * platform the same method implemented by the {@link TreeSet}
     * class should be used for better performance.</strong>
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E higher(E e) {
        boolean found = false;
        for (E current : this) {
            if (found) {
                return current;
            }
            if (comparator.compare(e, current) == 0) {
                found = true;
            }
        }
        return null;
    }
    /**
     * Returns the next lower element in the sequence to the given element. If
     * the given element doesn't exist or if it is the first element in the
     * sequence <code>null</code> is returned. <strong>Please note that this
     * method is provided for compatibility with Java 5 SE. On a Java 6 SE
     * platform the same method implemented by the {@link TreeSet}
     * class should be used for better performance.</strong>
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E lower(E e) {
        E last = null;
        for (E current : this) {
            if (comparator.compare(e, current) == 0) {
                return last;
            }
            last = current;
        }
        return last;
    }
}
"
org.apache.camel.processor.resequencer.SequenceElementComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.Comparator;
/**
 * A strategy for comparing elements of a sequence.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public interface SequenceElementComparator<E> extends Comparator<E> {
    /**
     * Returns <code>true</code> if <code>o1</code> is an immediate predecessor
     * of <code>o2</code>.
     * 
     * @param o1 a sequence element.
     * @param o2 a sequence element.
     */
    boolean predecessor(E o1, E o2);
    /**
     * Returns <code>true</code> if <code>o1</code> is an immediate successor
     * of <code>o2</code>.
     * 
     * @param o1 a sequence element.
     * @param o2 a sequence element.
     */
    boolean successor(E o1, E o2);
}
"
org.apache.camel.processor.resequencer.SequenceSender,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.concurrent.BlockingQueue;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A thread that takes re-ordered {@link Exchange}s from a blocking queue and
 * send them to the linked processor.  
 * 
 * @author Martin Krasser
 * 
 * @version $Revision: 677549 $
 */
public class SequenceSender extends Thread {
    private static final transient Log LOG = LogFactory.getLog(SequenceSender.class);
    private static final Exchange STOP = createStopSignal();
    private BlockingQueue<Exchange> queue;
    private Processor processor;
    /**
     * Creates a new {@link SequenceSender} thread.
     * 
     * @param processor the processor to send re-ordered {@link Exchange}s.
     */
    public SequenceSender(Processor processor) {
        this.processor = processor;
    }
    /**
     * Sets the {@link BlockingQueue} to take messages from.
     * 
     * @param queue the {@link BlockingQueue} to take messages from.
     */
    public void setQueue(BlockingQueue<Exchange> queue) {
        this.queue = queue;
    }
    public void run() {
        while (true) {
            try {
                Exchange exchange = queue.take();
                if (exchange == STOP) {
                    LOG.info(""Exit processing loop after cancellation"");
                    return;
                }
                processor.process(exchange);
            } catch (InterruptedException e) {
                LOG.info(""Exit processing loop after interrupt"");
                return;
            } catch (Exception e) {
                LOG.warn(""Exception during exchange processing: "" + e.getMessage());
            }
        }
    }
    /**
     * Cancels this thread.
     */
    public void cancel() throws InterruptedException {
        queue.put(STOP);
    }
    private static Exchange createStopSignal() {
        return (Exchange)Proxy.newProxyInstance(SequenceSender.class.getClassLoader(), 
                new Class[] {Exchange.class}, createStopHandler());
    }
    private static InvocationHandler createStopHandler() {
        return new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                throw new RuntimeException(""Illegal method invocation on stop signal"");
            }
        };
    }
}
"
org.apache.camel.processor.resequencer.Timeout,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
/**
 * A timer task that notifies handlers about scheduled timeouts.
 * 
 * @see Timer
 * @see TimerTask
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public class Timeout extends TimerTask {
    private List<TimeoutHandler> timeoutHandlers;
    private Timer timer;
    private long timeout;
    /**
     * Creates a new timeout task using the given {@link Timer} instance a timeout value. The
     * task is not scheduled immediately. It will be scheduled by calling this
     * task's {@link #schedule()} method.
     * 
     * @param timer
     * @param timeout
     */
    public Timeout(Timer timer, long timeout) {
        this.timeoutHandlers = new LinkedList<TimeoutHandler>();
        this.timeout = timeout;
        this.timer = timer;
    }
    /**
     * Returns the list of timeout handlers that have been registered for
     * notification.
     * 
     * @return the list of timeout handlers
     */
    public List<TimeoutHandler> getTimeoutHandlers() {
        return timeoutHandlers;
    }
    /**
     * Appends a new timeout handler at the end of the timeout handler list.
     * 
     * @param handler a timeout handler.
     */
    public void addTimeoutHandler(TimeoutHandler handler) {
        timeoutHandlers.add(handler);
    }
    /**
     * inserts a new timeout handler at the beginning of the timeout handler
     * list.
     * 
     * @param handler a timeout handler.
     */
    public void addTimeoutHandlerFirst(TimeoutHandler handler) {
        timeoutHandlers.add(0, handler);
    }
    /**
     * Removes all timeout handlers from the timeout handler list. 
     */
    public void clearTimeoutHandlers() {
        this.timeoutHandlers.clear();
    }
    /**
     * Schedules this timeout task.
     */
    public void schedule() {
        timer.schedule(this, timeout);
    }
    /**
     * Notifies all timeout handlers about the scheduled timeout.
     */
    @Override
    public void run() {
        for (TimeoutHandler observer : timeoutHandlers) {
            observer.timeout(this);
        }
    }
}
"
org.apache.camel.processor.resequencer.TimeoutHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * Implemented by classes that handle timeout notifications.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public interface TimeoutHandler {
    /**
     * Handles a timeout notification.
     * 
     * @param timeout the timer task that caused this timeout notification.
     */
    void timeout(Timeout timeout);
}
"
org.apache.camel.processor.routingslip.RoutingSlipDataModificationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import java.util.Map;
import javax.naming.Context;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Headers;
import org.apache.camel.OutHeaders;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class RoutingSlipDataModificationTest extends ContextTestSupport {
    protected static final String ANSWER = ""answer"";
    protected static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    private static final transient Log LOG = LogFactory.getLog(RoutingSlipDataModificationTest.class);
    protected MyBean myBean = new MyBean(ROUTING_SLIP_HEADER);
    public void testModificationOfDataAlongRoute()
        throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        x.expectedBodiesReceived(ANSWER);
        y.expectedBodiesReceived(ANSWER + ANSWER);
        z.expectedBodiesReceived(ANSWER + ANSWER);
        sendBody();
        assertMockEndpointsSatisifed();
    }
    protected void sendBody() {
        template.sendBodyAndHeader(""direct:a"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:x,bean:myBean?method=modifyData,mock:y,mock:z"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").routingSlip(ROUTING_SLIP_HEADER);
                // END SNIPPET: example
            }
        };
    }
    public static class MyBean {
        private String routingSlipHeader;
        public MyBean() {
        }
        public MyBean(String routingSlipHeader) {
            this.routingSlipHeader = routingSlipHeader;
        }
        public String modifyData(
            @Body String body,
            @Headers Map<String, Object> headers,
            @OutHeaders Map<String, Object> outHeaders) {
            outHeaders.put(routingSlipHeader, headers.get(routingSlipHeader));
            return body + body;
        }
    }
}
"
org.apache.camel.processor.routingslip.RoutingSlipTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class RoutingSlipTest extends ContextTestSupport {
    protected static final String ANSWER = ""answer"";
    protected static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    public void testUpdatingOfRoutingSlipAllDefaults()
        throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        // at each destination, the routing slip should contain
        // the remaining destinations
        x.expectedHeaderReceived(ROUTING_SLIP_HEADER, ""mock:y,mock:z"");
        y.expectedHeaderReceived(ROUTING_SLIP_HEADER, ""mock:z"");
        z.expectedHeaderReceived(ROUTING_SLIP_HEADER, """");
        sendBody(""direct:a"", ROUTING_SLIP_HEADER, "","");
        assertMockEndpointsSatisifed();
    }
    public void testUpdatingOfRoutingSlipHeaderSet() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        // at each destination, the routing slip should contain
        // the remaining destinations
        x.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:y,mock:z"");
        y.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:z"");
        z.expectedHeaderReceived(""aRoutingSlipHeader"", """");
        sendBody(""direct:b"", ""aRoutingSlipHeader"", "","");
        assertMockEndpointsSatisifed();
    }
    public void testUpdatingOfRoutingSlipHeaderAndDelimiterSet() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        // at each destination, the routing slip should contain
        // the remaining destinations
        x.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:y#mock:z"");
        y.expectedHeaderReceived(""aRoutingSlipHeader"", ""mock:z"");
        z.expectedHeaderReceived(""aRoutingSlipHeader"", """");
        sendBody(""direct:c"", ""aRoutingSlipHeader"", ""#"");
        assertMockEndpointsSatisifed();
    }
    public void testMessagePassingThrough() throws Exception {
        MockEndpoint end = getMockEndpoint(""mock:end"");
        end.expectedMessageCount(1);
        sendBody(""direct:a"", ROUTING_SLIP_HEADER, "","");
        assertMockEndpointsSatisifed();
    }
    public void testEmptyRoutingSlip() throws Exception {
        MockEndpoint end = getMockEndpoint(""mock:end"");
        end.expectedMessageCount(1);
        sendBodyWithEmptyRoutingSlip();
        assertMockEndpointsSatisifed();
    }
    public void testNoRoutingSlip() throws Exception {
        MockEndpoint end = getMockEndpoint(""mock:end"");
        end.expectedMessageCount(1);
        sendBodyWithNoRoutingSlip();
        assertMockEndpointsSatisifed();
    }
    protected void sendBody(String endpoint, String header, String delimiter) {
        template.sendBodyAndHeader(endpoint, ANSWER, header,
               ""mock:x"" + delimiter + ""mock:y"" + delimiter + ""mock:z"");
    }
    protected void sendBodyWithEmptyRoutingSlip() {
        template.sendBodyAndHeader(""direct:a"", ANSWER, ROUTING_SLIP_HEADER, """");
    }
    protected void sendBodyWithNoRoutingSlip() {
        template.sendBody(""direct:a"", ANSWER);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: e1
                from(""direct:a"").routingSlip().to(""mock:end"");
                // END SNIPPET: e1
                // START SNIPPET: e2
                from(""direct:b"").routingSlip(""aRoutingSlipHeader"");
                // END SNIPPET: e2
                // START SNIPPET: e3
                from(""direct:c"").routingSlip(""aRoutingSlipHeader"", ""#"");
                // END SNIPPET: e3
            }
        };
    }
}
"
org.apache.camel.processor.routingslip.RoutingSlipWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.routingslip;
import java.util.concurrent.TimeUnit;
import javax.naming.Context;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
public class RoutingSlipWithExceptionTest extends ContextTestSupport {
    protected static final String ANSWER = ""answer"";
    protected static final String ROUTING_SLIP_HEADER = ""routingSlipHeader"";
    protected MyBean myBean = new MyBean();
    private MockEndpoint endEndpoint;
    private MockEndpoint exceptionEndpoint;
    private MockEndpoint exceptionSettingEndpoint;
    public void testNoException() throws Exception {
        endEndpoint.expectedMessageCount(1);
        exceptionEndpoint.expectedMessageCount(0);
        sendRoutingSlipWithNoExceptionThrowingComponent();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionThrowingComponentFirstInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionThrowingComponentFirstInList();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionThrowingComponentSecondInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionThrowingComponentSecondInList();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionSettingComponentFirstInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionSettingComponentFirstInList();
        assertEndpointsSatisfied();
    }
    public void testWithExceptionSettingComponentSecondInList() throws Exception {
        endEndpoint.expectedMessageCount(0);
        exceptionEndpoint.expectedMessageCount(1);
        sendRoutingSlipWithExceptionSettingComponentSecondInList();
        assertEndpointsSatisfied();
    }
    private void assertEndpointsSatisfied() throws InterruptedException {
        MockEndpoint.assertIsSatisfied(5, TimeUnit.SECONDS, endEndpoint, exceptionEndpoint);
    }
    protected void sendRoutingSlipWithExceptionThrowingComponentFirstInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""myBean?method=throwException,mock:x"");
    }
    protected void sendRoutingSlipWithExceptionThrowingComponentSecondInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:a,myBean?method=throwException"");
    }
    protected void sendRoutingSlipWithNoExceptionThrowingComponent() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:a"");
    }
    protected void sendRoutingSlipWithExceptionSettingComponentFirstInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:exceptionSetting,mock:a"");
    }
    protected void sendRoutingSlipWithExceptionSettingComponentSecondInList() {
        template.sendBodyAndHeader(""direct:start"", ANSWER, ROUTING_SLIP_HEADER,
                ""mock:a,mock:exceptionSetting"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        endEndpoint = resolveMandatoryEndpoint(""mock:noexception"", MockEndpoint.class);
        exceptionEndpoint = resolveMandatoryEndpoint(""mock:exception"", MockEndpoint.class);
        exceptionSettingEndpoint = resolveMandatoryEndpoint(""mock:exceptionSetting"", MockEndpoint.class);
        exceptionSettingEndpoint.whenAnyExchangeReceived(new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.setException(new Exception(""Throw me!""));
            }
        });
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                    tryBlock().
                        routingSlip().to(""mock:noexception"").
                        handle(Exception.class).
                    to(""mock:exception"");
            }
        };
    }
    public static class MyBean {
        public MyBean() {
        }
        public void throwException() throws Exception {
            throw new Exception(""Throw me!"");
        }
    }
}
"
org.apache.camel.processor.validation.DefaultValidationErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.util.ArrayList;
import java.util.List;
import javax.xml.transform.dom.DOMResult;
import javax.xml.validation.Schema;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A default error handler which just stores all the errors so they can be reported or transformed.
 *
 * @version $Revision: 640438 $
 */
public class DefaultValidationErrorHandler implements ValidatorErrorHandler {
    private static final transient Log LOG = LogFactory.getLog(DefaultValidationErrorHandler.class);
    private List<SAXParseException> warnings = new ArrayList<SAXParseException>();
    private List<SAXParseException> errors = new ArrayList<SAXParseException>();
    private List<SAXParseException> fatalErrors = new ArrayList<SAXParseException>();
    public void warning(SAXParseException e) throws SAXException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""warning: "" + e, e);
        }
        warnings.add(e);
    }
    public void error(SAXParseException e) throws SAXException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""error: "" + e, e);
        }
        errors.add(e);
    }
    public void fatalError(SAXParseException e) throws SAXException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""fatalError: "" + e, e);
        }
        fatalErrors.add(e);
    }
    public void reset() {
        warnings.clear();
        errors.clear();
        fatalErrors.clear();
    }
    public boolean isValid() {
        return errors.isEmpty() && fatalErrors.isEmpty();
    }
    public void handleErrors(Exchange exchange, Schema schema, DOMResult result) throws ValidationException {
        if (!isValid()) {
            throw new SchemaValidationException(exchange, schema, fatalErrors, errors, warnings);
        }
    }
    public void handleErrors(Exchange exchange, Object schema) throws ValidationException {
        if (!isValid()) {
            throw new SchemaValidationException(exchange, schema, fatalErrors, errors, warnings);
        }
    }
}
"
org.apache.camel.processor.validation.NoXmlBodyValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * An exception found if no XML body is available on the inbound message
 *
 * @version $Revision: 630591 $
 */
public class NoXmlBodyValidationException extends ValidationException {
    public NoXmlBodyValidationException(Exchange exchange) {
        super(exchange, ""No XML body could be found on the input message"" + exchange);
    }
}
"
org.apache.camel.processor.validation.SchemaValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.util.List;
import org.xml.sax.SAXParseException;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * A Schema validation exception occurred
 * 
 * @version $Revision: 630591 $
 */
public class SchemaValidationException extends ValidationException {
    private final Object schema;
    private final List<SAXParseException> fatalErrors;
    private final List<SAXParseException> errors;
    private final List<SAXParseException> warnings;
    public SchemaValidationException(Exchange exchange, Object schema, List<SAXParseException> fatalErrors,
                                     List<SAXParseException> errors, List<SAXParseException> warnings) {
        super(exchange, message(schema, fatalErrors, errors, warnings));
        this.schema = schema;
        this.fatalErrors = fatalErrors;
        this.errors = errors;
        this.warnings = warnings;
    }
    /**
     * Returns the schema that failed
     * 
     * @return the schema that failed
     */
    public Object getSchema() {
        return schema;
    }
    /**
     * Returns the validation errors
     * 
     * @return the validation errors
     */
    public List<SAXParseException> getErrors() {
        return errors;
    }
    /**
     * Returns the fatal validation errors
     * 
     * @return the fatal validation errors
     */
    public List<SAXParseException> getFatalErrors() {
        return fatalErrors;
    }
    /**
     * Returns the validation warnings
     * 
     * @return the validation warnings
     */
    public List<SAXParseException> getWarnings() {
        return warnings;
    }
    protected static String message(Object schema, List<SAXParseException> fatalErrors,
                                    List<SAXParseException> errors, List<SAXParseException> warnings) {
        StringBuffer buffer = new StringBuffer(""Validation failed for: "" + schema);
        if (!fatalErrors.isEmpty()) {
            buffer.append("" fatal errors: "");
            buffer.append(fatalErrors);
        }
        if (!errors.isEmpty()) {
            buffer.append("" errors: "");
            buffer.append(errors);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.processor.validation.ValidatingProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import org.xml.sax.SAXException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A processor which validates the XML version of the inbound message body
 * against some schema either in XSD or RelaxNG
 * 
 * @version $Revision: 630591 $
 */
public class ValidatingProcessor implements Processor {
    private Schema schema;
    private ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler();
    // for lazy creation of the Schema
    private String schemaLanguage = XMLConstants.W3C_XML_SCHEMA_NS_URI;
    private Source schemaSource;
    private SchemaFactory schemaFactory;
    private URL schemaUrl;
    private File schemaFile;
    public void process(Exchange exchange) throws Exception {
        Schema schema = getSchema();
        Validator validator = schema.newValidator();
        Source source = exchange.getIn().getBody(DOMSource.class);
        if (source == null) {
            throw new NoXmlBodyValidationException(exchange);
        }
        // create a new errorHandler and set it on the validator
        errorHandler.reset();
        validator.setErrorHandler(errorHandler);
        DOMResult result = new DOMResult();
        validator.validate(source, result);
        errorHandler.handleErrors(exchange, schema, result);
        /*
         * Fault fault = exchange.createFault(); if (errorHandler.hasErrors()) { //
         * set the schema and source document as properties on the fault
         * fault.setProperty(""org.apache.servicemix.schema"", schema);
         * fault.setProperty(""org.apache.servicemix.xml"", source);
         * 
         *//*
             * check if this error handler supports the capturing of error
             * messages.
             *//*
             * if (errorHandler.capturesMessages()) {
             * 
             *//*
             * In descending order of preference select a format to use. If
             * neither DOMSource, StringSource or String are supported throw a
             * messaging exception.
             *//*
             * if (errorHandler.supportsMessageFormat(DOMSource.class)) {
             * fault.setContent( (DOMSource)
             * errorHandler.getMessagesAs(DOMSource.class)); } else if
             * (errorHandler.supportsMessageFormat(StringSource.class)) {
             * fault.setContent(sourceTransformer.toDOMSource( (StringSource)
             * errorHandler.getMessagesAs(StringSource.class))); } else if
             * (errorHandler.supportsMessageFormat(String.class)) {
             * fault.setContent( sourceTransformer.toDOMSource( new
             * StringSource( (String)
             * errorHandler.getMessagesAs(String.class)))); } else { throw new
             * MessagingException(""MessageAwareErrorHandler implementation "" +
             * errorHandler.getClass().getName() + "" does not support a
             * compatible error message format.""); } } else {
             *//*
             * we can't do much here if the ErrorHandler implementation does not
             * support capturing messages
             *//*
             * fault.setContent(new DOMSource(result.getNode(),
             * result.getSystemId())); } throw new FaultException(""Failed to
             * validate against schema: "" + schema, exchange, fault); } else { //
             * Retrieve the ouput of the validation // as it may have been
             * changed by the validator out.setContent(new
             * DOMSource(result.getNode(), result.getSystemId())); } }
             */
    }
    // Properties
    // -----------------------------------------------------------------------
    public Schema getSchema() throws IOException, SAXException {
        if (schema == null) {
            schema = createSchema();
        }
        return schema;
    }
    public void setSchema(Schema schema) {
        this.schema = schema;
    }
    public String getSchemaLanguage() {
        return schemaLanguage;
    }
    public void setSchemaLanguage(String schemaLanguage) {
        this.schemaLanguage = schemaLanguage;
    }
    public Source getSchemaSource() throws IOException {
        if (schemaSource == null) {
            schemaSource = createSchemaSource();
        }
        return schemaSource;
    }
    public void setSchemaSource(Source schemaSource) {
        this.schemaSource = schemaSource;
    }
    public URL getSchemaUrl() {
        return schemaUrl;
    }
    public void setSchemaUrl(URL schemaUrl) {
        this.schemaUrl = schemaUrl;
    }
    public File getSchemaFile() {
        return schemaFile;
    }
    public void setSchemaFile(File schemaFile) {
        this.schemaFile = schemaFile;
    }
    public SchemaFactory getSchemaFactory() {
        if (schemaFactory == null) {
            schemaFactory = createSchemaFactory();
        }
        return schemaFactory;
    }
    public void setSchemaFactory(SchemaFactory schemaFactory) {
        this.schemaFactory = schemaFactory;
    }
    public ValidatorErrorHandler getErrorHandler() {
        return errorHandler;
    }
    public void setErrorHandler(ValidatorErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected SchemaFactory createSchemaFactory() {
        return SchemaFactory.newInstance(schemaLanguage);
    }
    protected Source createSchemaSource() throws IOException {
        throw new IllegalArgumentException(""You must specify a schema, ""
                                           + ""schemaFile, schemaSource or schemaUrl property"");
    }
    protected Schema createSchema() throws SAXException, IOException {
        SchemaFactory factory = getSchemaFactory();
        URL url = getSchemaUrl();
        if (url != null) {
            return factory.newSchema(url);
        }
        File file = getSchemaFile();
        if (file != null) {
            return factory.newSchema(file);
        }
        return factory.newSchema(getSchemaSource());
    }
}
"
org.apache.camel.processor.validation.ValidatorErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import javax.xml.transform.dom.DOMResult;
import javax.xml.validation.Schema;
import org.xml.sax.ErrorHandler;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * Validator error handler.
 *
 * @version $Revision: 659760 $
 */
public interface ValidatorErrorHandler extends ErrorHandler {
    /**
     * Resets any state within this error handler
     */
    void reset();
    /**
     * Process any errors which may have occurred during validation
     *
     * @param exchange the exchange
     * @param schema   the schema
     * @param result   the result
     */
    void handleErrors(Exchange exchange, Schema schema, DOMResult result) throws ValidationException;
}
"
org.apache.camel.spi.BrowsableEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
/**
 * An optional interface an {@link Endpoint} may choose to implement which allows it to expose a way of browsing
 * the exchanges available.
 *
 * @version $Revision: 640438 $
 */
public interface BrowsableEndpoint<T extends Exchange> extends Endpoint<T> {
    /**
     * Return the exchanges available on this endpoint
     *
     * @return the exchanges on this endpoint
     */
    List<Exchange> getExchanges();
}
"
org.apache.camel.spi.ComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
/**
 * Represents a resolver of components from a URI to be able to auto-load them using some
 * discovery mechanism like {@link org.apache.camel.impl.DefaultComponentResolver}
 *
 * @version $Revision: 659849 $
 */
public interface ComponentResolver<E extends Exchange> {
    /**
     * Attempts to resolve the component for the given URI
     *
     * @param name the component name to resolve
     * @param context the context to load the component if it can be resolved
     * @return the component which is added to the context or null if it can not be resolved
     * @throws Exception is thrown if the the component could not be loaded
     */
    Component<E> resolveComponent(String name, CamelContext context) throws Exception;
}
"
org.apache.camel.spi.DataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.camel.Exchange;
/**
 * Represents a
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * used to marshal objects to and from streams
 * such as Java Serialization or using JAXB2 to encode/decode objects using XML
 * or using SOAP encoding.
 *
 * @version $Revision: 640438 $
 */
public interface DataFormat {
    /**
     * Marshals the object to the given Stream.
     */
    void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception;
    /**
     * Unmarshals the given stream into an object.
     */
    Object unmarshal(Exchange exchange, InputStream stream) throws Exception;
}
"
org.apache.camel.spi.ErrorHandlerWrappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
/**
 * The purpose of this interface is to allow an implementation to
 * provide custom logic to wrap a processor with error handler
 * @version $Revision: 673837 $
 */
public interface ErrorHandlerWrappingStrategy {
    /**
     * This method is invoked by
     * {@link ProcessorType#wrapProcessor(RouteContext, Processor)
     * to give the implementor an opportunity to wrap the target processor
     * in a route.
     *
     * @param processorType the object that invokes this method
     * @param target the processor to be wrapped
     * @return processor wrapped with an interceptor or not wrapped
     * @throws Exception
     */
    Processor wrapProcessorInErrorHandler(RouteContext routeContext, ProcessorType processorType,
                                          Processor target) throws Exception;
}
"
org.apache.camel.spi.ExceptionHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A Strategy pattern for handling exceptions; particularly in asynchronous processes such as consumers
 *
 * @version $Revision: 630568 $
 */
public interface ExceptionHandler {
    /**
     * Handles the given exception
     *
     * @param exception the exception
     */
    void handleException(Throwable exception);
}
"
org.apache.camel.spi.ExchangeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
/**
 * This converter is capable of converting from an exchange to another type
 *
 * @version $Revision: 630568 $
 */
public interface ExchangeConverter {
     <T> T  convertTo(Class<T> type, Exchange exchange);
}
"
org.apache.camel.spi.Injector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A pluggable strategy for creating and possibly dependency injecting objects
 * which could be implemented using straight forward reflection or using Spring
 * or Guice to perform dependency injection.
 * 
 * @version $Revision: 659798 $
 */
public interface Injector {
    /**
     * Instantiates a new instance of the given type possibly injecting values
     * into the object in the process
     * 
     * @param type the type of object to create
     * @return a newly created instance
     */
    <T> T newInstance(Class<T> type);
}
"
org.apache.camel.spi.InstrumentationAgent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import org.apache.camel.Service;
/**
 * Camel JMX service agent
 */
public interface InstrumentationAgent extends Service {
    /**
     * Registers object with management infrastructure with a specific name. Object must be annotated or 
     * implement standard MBean interface.
     *
     * @param obj  the object to register
     * @param name the name
     * @throws JMException is thrown if the registration failed
     */
    void register(Object obj, ObjectName name) throws JMException;
    /**
     * Registers object with management infrastructure with a specific name. Object must be annotated or 
     * implement standard MBean interface.
     *
     * @param obj  the object to register
     * @param name the name
     * @param forceRegistration if set to <tt>true</tt>, then object will be registered despite
     * existing object is already registered with the name.
     * @throws JMException is thrown if the registration failed
     */
    void register(Object obj, ObjectName name, boolean forceRegistration) throws JMException;
    /**
     * Unregisters object based upon registered name
     *
     * @param name the name
     * @throws JMException is thrown if the unregistration failed
     */
    void unregister(ObjectName name) throws JMException;
    /**
     * Get the MBeanServer which hosts managed objects.
     * <p/>
     * NOTE: if the JMXEnabled configuration is not set to true, this method will return null.
     * 
     * @return the MBeanServer
     */
    MBeanServer getMBeanServer();
    /**
     * Get domain name for Camel MBeans.  Notice that this can be different that the 
     * default domain name of the MBean Server.  
     * 
     * @return domain name
     */
    String getMBeanObjectDomainName();
}
"
org.apache.camel.spi.InterceptStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Processor;
import org.apache.camel.model.ProcessorType;
 /**
  * The purpose of this interface is to allow an implementation to wrap
  * processors in a route with interceptors.  For example, a possible
  * usecase is to gather performance statistics at the processor's level.
  *
  * @version $Revision: 657300 $
  */
public interface InterceptStrategy {
    /**
     * This method is invoked by
     * {@link ProcessorType#wrapProcessor(RouteContext, Processor)
     * to give the implementor an opportunity to wrap the target processor
     * in a route.
     *
     * @param processorType the object that invokes this method
     * @param target the processor to be wrapped
     * @return processor wrapped with an interceptor or not wrapped
     * @throws Exception
     */
    Processor wrapProcessorInInterceptors(ProcessorType processorType,
            Processor target) throws Exception;
}
"
org.apache.camel.spi.Language,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * Represents a language to be used for {@link Expression} or {@link Predicate} instances
 *
 * @version $Revision: 630568 $
 */
public interface Language {
    Predicate<Exchange> createPredicate(String expression);
    Expression<Exchange> createExpression(String expression);
}
"
org.apache.camel.spi.LanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.CamelContext;
/**
 * A pluggable strategy for resolving different languages in a loosely coupled manner
 * 
 * @version $Revision: 630568 $
 */
public interface LanguageResolver {
    Language resolveLanguage(String name, CamelContext context);
}
"
org.apache.camel.spi.LifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Route;
import org.apache.camel.Service;
/**
 * Strategy for notifications
 */
public interface LifecycleStrategy {
    /**
     * Notification on starting a {@link CamelContext}.
     */
    void onContextStart(CamelContext context);
    /**
     * Notification on adding an {@link Endpoint}.
     */
    void onEndpointAdd(Endpoint<? extends Exchange> endpoint);
    /**
     * Notification on adding a {@link Service}.
     */
    void onServiceAdd(CamelContext context, Service service);
    /**
     * Notification on adding {@link Route}(s).
     */
    void onRoutesAdd(Collection<Route> routes);
    /**
     * Notification on adding {@link RouteContext}(s).
     *
     * @param routeContext
     */
    void onRouteContextCreate(RouteContext routeContext);
}
"
org.apache.camel.spi.NamespaceAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.Map;
/**
 * Represents an object which is aware of the namespaces in which its used such as
 * XPath and XQuery type expressions so that the current namespace context can be injected
 *
 * @version $Revision: 640438 $
 */
public interface NamespaceAware {
    /**
     * Injects the XML Namespaces of prefix -> uri mappings
     *
     * @param namespaces the XML namespaces with the key of prefixes and the value the URIs
     */
    void setNamespaces(Map<String, String> namespaces);
}
"
org.apache.camel.spi.Policy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Processor;
/**
 * A strategy capable of applying interceptors to a processor
 *
 * @version $Revision: 630568 $
 */
public interface Policy<E> {
    /**
     * Wraps any applicable interceptors around the given processor
     *
     * @param processor the processor to be intercepted
     * @return either the original processor or a processor wrapped in one or more interceptors
     */
    Processor wrap(Processor processor);
}
"
org.apache.camel.spi.Provider,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A provider of newly constructed objects
 *
 * @version $Revision: 630568 $
 */
public interface Provider<T> {
    /**
     * Returns the newly constructed instance
     */
    T get();
}
"
org.apache.camel.spi.Registry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * Represents a service registry which may be implemented via a Spring ApplicationContext,
 * via JNDI, a simple Map or the OSGI Service Registry
 *
 * @version $Revision: 630568 $
 */
public interface Registry {
    /**
     * Looks up a service in the registry, returning the service or null if it could not be found.
     *
     * @param name the name of the service
     * @param type the type of the required service
     * @return the service from the registry or null if it could not be found
     */
    <T> T lookup(String name, Class<T> type);
    /**
     * Looks up a service in the registry based purely on name,
     * returning the service or null if it could not be found.
     *
     * @param name the name of the service
     * @return the service from the registry or null if it could not be found
     */
    Object lookup(String name);
}
"
org.apache.camel.spi.RouteContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Intercept;
import org.apache.camel.Processor;
import org.apache.camel.model.FromType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
/**
 * The context used to activate new routing rules
 *
 * @version $Revision: 673335 $
 */
public interface RouteContext {
    Endpoint<? extends Exchange> getEndpoint();
    FromType getFrom();
    RouteType getRoute();
    /**
     * Gets the CamelContext
     */
    CamelContext getCamelContext();
    Processor createProcessor(ProcessorType node) throws Exception;
    /**
     * Resolves an endpoint from the URI
     */
    Endpoint<? extends Exchange> resolveEndpoint(String uri);
    /**
     * Resolves an endpoint from either a URI or a named reference
     */
    Endpoint<? extends Exchange> resolveEndpoint(String uri, String ref);
    /**
     * lookup an object by name and type
     */
    <T> T lookup(String name, Class<T> type);
    /**
     * Lets complete the route creation, creating a single event driven route
     * for the current from endpoint with any processors required
     */
    void commit();
    void addEventDrivenProcessor(Processor processor);
    void intercept(Intercept interceptor);
    Processor createProceedProcessor();
    /**
     * This method retrieves the InterceptStrategy instances this route context.
     *
     * @return InterceptStrategy
     */
    List<InterceptStrategy> getInterceptStrategies();
    /**
     * This method sets the InterceptStrategy instances on this route context.
     *
     * @param interceptStrategies
     */
    void setInterceptStrategies(List<InterceptStrategy> interceptStrategies);
    void addInterceptStrategy(InterceptStrategy interceptStrategy);
    /**
     * This method retrieves the ErrorHandlerWrappingStrategy.
     *  
     * @return ErrorHandlerWrappingStrategy
     */
    ErrorHandlerWrappingStrategy getErrorHandlerWrappingStrategy();
    /**
     * This method sets the ErrorHandlerWrappingStrategy.
     * 
     */
    void setErrorHandlerWrappingStrategy(ErrorHandlerWrappingStrategy strategy);
    /**
     * If this flag is true, {@link ProcessorType#addRoutes(RouteContext, java.util.Collection)
     * will not add processor to addEventDrivenProcessor to the RouteContext and it
     * will prevent from adding an EventDrivenRoute.
     * 
     */
    void setIsRouteAdded(boolean value);
    /**
     * @see {@link #setIsRouteAdded(boolean)}
     * 
     */
    boolean isRouteAdded();
}
"
org.apache.camel.spi.Synchronization,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Provides a hook for custom {@link Processor} or {@link Component} instances to respond to
 * completed or failed processing of an {@link Exchange} rather like Spring's
 * <a href=""http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/transaction/support/TransactionSynchronization.html"">TransactionSynchronization</a>
 *
 * @version $Revision: 640438 $
 */
public interface Synchronization {
    /**
     * Called when the processing of the message exchange is complete
     *
     * @param exchange the excahnge being processed
     */
    void onComplete(Exchange exchange);
    /**
     * Called when the processing of the message exchange has failed for some reason.
     * The exception which caused the problem is in {@link Exchange#getException()} and
     * there could be a fault message via {@link Exchange#getFault()}
     *
     * @param exchange the excahnge being processed
     */
    void onFailure(Exchange exchange);
}
"
org.apache.camel.spi.TypeConverterAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.TypeConverter;
/**
 * An interface for an object which is interested in being injected with the root {@link TypeConverter}
 * such as for implementing a fallback type converter
 *
 * @see org.apache.camel.impl.converter.DefaultTypeConverter#addFallbackConverter(TypeConverter)
 *         DefaultTypeConverter.addFallbackConverter
 * @version $Revision: 642753 $
 */
public interface TypeConverterAware {
    void setTypeConverter(TypeConverter parentTypeConverter);
}
"
org.apache.camel.spi.UnitOfWork,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
/**
 * An object representing the unit of work processing an {@link Exchange}
 * which allows the use of {@link Synchronization} hooks. This object might map one-to-one with
 * a transaction in JPA or Spring; or might not.
 *
 * @version $Revision: 669650 $
 */
public interface UnitOfWork {
    /**
     * Adds a synchronization hook
     *
     * @param synchronization
     */
    void addSynchronization(Synchronization synchronization);
    /**
     * Removes a synchronization hook
     *
     * @param synchronization
     */
    void removeSynchronization(Synchronization synchronization);
    /**
     * Invoked when this unit of work has been completed, whether it has failed or completed
     */
    void done(Exchange exchange);
    /**
     * Returns the unique ID of this unit of work, lazily creating one if it does not yet have one
     *
     * @return
     */
    String getId();
}
"
org.apache.camel.util.AsyncProcessorHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.concurrent.CountDownLatch;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
/**
 * Helper methods for AsyncProcessor objects.
 */
public final class AsyncProcessorHelper {
    private AsyncProcessorHelper() {
        // utility class
    }
    /**
     * Calls the async version of the processor's process method and waits
     * for it to complete before returning. This can be used by AsyncProcessor
     * objects to implement their sync version of the process method.
     */
    public static void process(AsyncProcessor processor, Exchange exchange) throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        boolean sync = processor.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                if (!sync) {
                    latch.countDown();
                }
            }
        });
        if (!sync) {
            latch.await();
        }
    }
}
"
org.apache.camel.util.CamelContextHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.Registry;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A number of helper methods
 *
 * @version $Revision: 673837 $
 */
public final class CamelContextHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private CamelContextHelper() {
    }
    /**
     * Returns the mandatory endpoint for the given URI or the
     * {@link org.apache.camel.NoSuchEndpointException} is thrown
     */
    public static Endpoint getMandatoryEndpoint(CamelContext camelContext, String uri)
        throws NoSuchEndpointException {
        Endpoint endpoint = camelContext.getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        } else {
            return endpoint;
        }
    }
    /**
     * Returns the mandatory endpoint for the given URI and type or the
     * {@link org.apache.camel.NoSuchEndpointException} is thrown
     */
    public static <T extends Endpoint> T getMandatoryEndpoint(CamelContext camelContext, String uri, Class<T> type) {
        Endpoint endpoint = getMandatoryEndpoint(camelContext, uri);
        return ObjectHelper.cast(type, endpoint);
    }
    /**
     * Returns a list of all endpoints of the given type
     *
     * @param camelContext
     * @param type the type of the endpoints requested
     * @return a list which may be empty of all the endpoint instances of the
     *         given type
     */
    public static <T> List<T> getSingletonEndpoints(CamelContext camelContext, Class<T> type) {
        List<T> answer = new ArrayList<T>();
        Collection<Endpoint> endpoints = camelContext.getSingletonEndpoints();
        for (Endpoint endpoint : endpoints) {
            if (type.isInstance(endpoint)) {
                T value = type.cast(endpoint);
                answer.add(value);
            }
        }
        return answer;
    }
    /**
     * Converts the given value to the requested type
     */
    public static <T> T convertTo(CamelContext context, Class<T> type, Object value) {
        notNull(context, ""camelContext"");
        return context.getTypeConverter().convertTo(type, value);
    }
    /**
     * Converts the given value to the specified type throwing an {@link IllegalArgumentException}
     * if the value could not be converted to a non null value
     */
    public static <T> T mandatoryConvertTo(CamelContext context, Class<T> type, Object value) {
        T answer = convertTo(context, type, value);
        if (answer == null) {
            throw new IllegalArgumentException(""Value "" + value + "" converted to "" + type.getName() + "" cannot be null"");
        }
        return answer;
    }
    /**
     * Creates a new instance of the given type using the {@link Injector} on the given
     * {@link CamelContext}
     */
    public static <T> T newInstance(CamelContext context, Class<T> beanType) {
        return context.getInjector().newInstance(beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext}
     */
    public static Object lookup(CamelContext context, String name) {
        return context.getRegistry().lookup(name);
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public static <T> T lookup(CamelContext context, String name, Class<T> beanType) {
        return context.getRegistry().lookup(name, beanType);
    }
    /**
     * Look up the given named bean in the {@link Registry} on the
     * {@link CamelContext} or throws
     */
    public static Object mandatoryLookup(CamelContext context, String name) {
        Object answer = lookup(context, name);
        notNull(answer, ""registry entry called "" + name);
        return answer;
    }
    /**
     * Look up the given named bean of the given type in the {@link Registry} on the
     * {@link CamelContext}
     */
    public static <T> T mandatoryLookup(CamelContext context, String name, Class<T> beanType) {
        T answer = lookup(context, name, beanType);
        notNull(answer, ""registry entry called "" + name + "" of type "" + beanType.getName());
        return answer;
    }
    /**
     * Resolves the given language name into a {@link Language} or throws an exception if it could not be converted
     */
    public static Language resolveMandatoryLanguage(CamelContext camelContext, String languageName) {
        notNull(camelContext, ""camelContext"");
        notNull(languageName, ""languageName"");
        Language language = camelContext.resolveLanguage(languageName);
        if (language == null) {
            throw new IllegalArgumentException(""Could not resolve language: "" + languageName);
        }
        return language;
    }
    /**
     * Resolves the mandatory language name and expression text into a {@link Expression} instance
     * throwing an exception if it could not be created
     */
    public static Expression resolveMandatoryExpression(CamelContext camelContext, String languageName, String expressionText) {
        notNull(expressionText, ""expressionText"");
        Language language = resolveMandatoryLanguage(camelContext, languageName);
        Expression<Exchange> expression = language.createExpression(expressionText);
        if (expression == null) {
            throw new IllegalArgumentException(""Could not create expression: "" + expressionText + "" with language: "" + language);
        }
        return expression;
    }
}
"
org.apache.camel.util.CollectionHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import org.w3c.dom.NodeList;
/**
 * A number of helper methods for working with collections
 *
 * @version $Revision: 640438 $
 */
public final class CollectionHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private CollectionHelper() {
    }
    /**
     * Returns the size of the collection if it can be determined to be a collection
     */
    public static Integer size(Object value) {
        if (value != null) {
            if (value instanceof Collection) {
                Collection collection = (Collection)value;
                return collection.size();
            } else if (value instanceof Map) {
                Map map = (Map)value;
                return map.size();
            } else if (value instanceof Object[]) {
                Object[] array = (Object[])value;
                return array.length;
            } else if (value.getClass().isArray()) {
                return Array.getLength(value);
            } else if (value instanceof NodeList) {
                NodeList nodeList = (NodeList)value;
                return nodeList.getLength();
            }
        }
        return null;
    }
    /**
     * Sets the value of the entry in the map for the given key, though if the
     * map already contains a value for the given key then the value is appended
     * to a list of values.
     *
     * @param map the map to add the entry to
     * @param key the key in the map
     * @param value the value to put in the map
     */
    public static void appendValue(Map map, Object key, Object value) {
        Object oldValue = map.get(key);
        if (oldValue != null) {
            List list;
            if (oldValue instanceof List) {
                list = (List)oldValue;
            } else {
                list = new ArrayList();
                list.add(oldValue);
            }
            list.add(value);
        } else {
            map.put(key, value);
        }
    }
}
"
org.apache.camel.util.CollectionStringBuffer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
/**
 * A little helper class for converting a collection of values to a (usually comma separated) string.
 *
 * @version $Revision: 640438 $
 */
public class CollectionStringBuffer {
    private StringBuffer buffer = new StringBuffer();
    private String separator;
    private boolean first = true;
    public CollectionStringBuffer() {
        this("", "");
    }
    public CollectionStringBuffer(String separator) {
        this.separator = separator;
    }
    @Override
    public String toString() {
        return buffer.toString();
    }
    public void append(Object value) {
        if (first) {
            first = false;
        } else {
            buffer.append(separator);
        }
        buffer.append(value);
    }
    public String getSeparator() {
        return separator;
    }
    public void setSeparator(String separator) {
        this.separator = separator;
    }
}
"
org.apache.camel.util.DefaultTimeoutMap,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Default implementation of the {@link TimeoutMap}.
 *
 * @version $Revision: 660275 $
 */
public class DefaultTimeoutMap implements TimeoutMap, Runnable {
    private static final transient Log LOG = LogFactory.getLog(DefaultTimeoutMap.class);
    private final Map map = new HashMap();
    private SortedSet index = new TreeSet();
    private ScheduledExecutorService executor;
    private long purgePollTime;
    public DefaultTimeoutMap() {
        this(null, 1000L);
    }
    public DefaultTimeoutMap(ScheduledExecutorService executor, long requestMapPollTimeMillis) {
        this.executor = executor;
        this.purgePollTime = requestMapPollTimeMillis;
        schedulePoll();
    }
    public Object get(Object key) {
        TimeoutMapEntry entry = null;
        synchronized (map) {
            entry = (TimeoutMapEntry) map.get(key);
            if (entry == null) {
                return null;
            }
            index.remove(entry);
            updateExpireTime(entry);
            index.add(entry);
        }
        return entry.getValue();
    }
    public void put(Object key, Object value, long timeoutMillis) {
        TimeoutMapEntry entry = new TimeoutMapEntry(key, value, timeoutMillis);
        synchronized (map) {
            Object oldValue = map.put(key, entry);
            if (oldValue != null) {
                index.remove(oldValue);
            }
            updateExpireTime(entry);
            index.add(entry);
        }
    }
    public void remove(Object id) {
        synchronized (map) {
            TimeoutMapEntry entry = (TimeoutMapEntry) map.remove(id);
            if (entry != null) {
                index.remove(entry);
            }
        }
    }
    public Object[] getKeys() {
        Object[] keys = null;
        synchronized (map) {
            Set keySet = map.keySet();
            keys = new Object[keySet.size()];
            keySet.toArray(keys);
        }
        return keys;
    }
    public int size() {
        synchronized (map) {
            return map.size();
        }
    }
    /**
     * The timer task which purges old requests and schedules another poll
     */
    public void run() {
        purge();
        schedulePoll();
    }
    public void purge() {
        long now = currentTime();
        synchronized (map) {
            for (Iterator iter = index.iterator(); iter.hasNext();) {
                TimeoutMapEntry entry = (TimeoutMapEntry) iter.next();
                if (entry == null) {
                    break;
                }
                if (entry.getExpireTime() < now) {
                    if (isValidForEviction(entry)) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Evicting inactive request for correlationID: "" + entry);
                        }
                        map.remove(entry.getKey());
                        iter.remove();
                    }
                } else {
                    break;
                }
            }
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getPurgePollTime() {
        return purgePollTime;
    }
    /**
     * Sets the next purge poll time in milliseconds
     */
    public void setPurgePollTime(long purgePollTime) {
        this.purgePollTime = purgePollTime;
    }
    public ScheduledExecutorService getExecutor() {
        return executor;
    }
    /**
     * Sets the executor used to schedule purge events of inactive requests
     */
    public void setExecutor(ScheduledExecutorService executor) {
        this.executor = executor;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * lets schedule each time to allow folks to change the time at runtime
     */
    protected void schedulePoll() {
        if (executor != null) {
            executor.schedule(this, purgePollTime, TimeUnit.MILLISECONDS);
        }
    }
    /**
     * A hook to allow derivations to avoid evicting the current entry
     */
    protected boolean isValidForEviction(TimeoutMapEntry entry) {
        return true;
    }
    protected void updateExpireTime(TimeoutMapEntry entry) {
        long now = currentTime();
        entry.setExpireTime(entry.getTimeout() + now);
    }
    protected long currentTime() {
        return System.currentTimeMillis();
    }
}
"
org.apache.camel.util.EndpointHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some helper methods for working with {@link Endpoint} instances
 *
 * @version $Revision: 640438 $
 */
public final class EndpointHelper {
    private static final transient Log LOG = LogFactory.getLog(EndpointHelper.class);
    private EndpointHelper() {
        //Utility Class
    }
    /**
     * Creates a {@link PollingConsumer} and polls all pending messages on the endpoint
     * and invokes the given {@link Processor} to process each {@link Exchange} and then closes
     * down the consumer and throws any exceptions thrown.
     *
     * @param endpoint
     * @param processor
     */
    public static void pollEndpoint(Endpoint endpoint, Processor processor, long timeout) throws Exception {
        PollingConsumer consumer = endpoint.createPollingConsumer();
        try {
            consumer.start();
            while (true) {
                Exchange exchange = consumer.receive(timeout);
                if (exchange == null) {
                    break;
                } else {
                    processor.process(exchange);
                }
            }
        } finally {
            try {
                consumer.stop();
            } catch (Exception e) {
                LOG.warn(""Failed to stop PollingConsumer: "" + e, e);
            }
        }
    }
    /**
     * Creates a {@link PollingConsumer} and polls all pending messages on the
     * endpoint and invokes the given {@link Processor} to process each
     * {@link Exchange} and then closes down the consumer and throws any
     * exceptions thrown.
     *
     * @param endpoint
     * @param processor
     */
    public static void pollEndpoint(Endpoint endpoint, Processor processor) throws Exception {
        pollEndpoint(endpoint, processor, 1000L);
    }
}
"
org.apache.camel.util.ExchangeHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.InvalidPayloadException;
import org.apache.camel.InvalidTypeException;
import org.apache.camel.Message;
import org.apache.camel.NoSuchBeanException;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.NoSuchHeaderException;
import org.apache.camel.NoSuchPropertyException;
/**
 * Some helper methods for working with {@link Exchange} objects
 *
 * @version $Revision: 642753 $
 */
public final class ExchangeHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExchangeHelper() {
    }
    /**
     * Extracts the exchange property of the given name and type; if it is not present then the
     * default value will be used
     *
     * @param exchange the message exchange
     * @param propertyName the name of the property on the exchange
     * @param type the expected type of the property
     * @param defaultValue the default value to be used if the property name does not exist or could not be
     * converted to the given type
     * @return the property value as the given type or the defaultValue if it could not be found or converted
     */
    public static <T> T getExchangeProperty(Exchange exchange, String propertyName, Class<T> type, T defaultValue) {
        T answer = exchange.getProperty(propertyName, type);
        if (answer == null) {
            return defaultValue;
        }
        return answer;
    }
    /**
     * Attempts to resolve the endpoint for the given value
     *
     * @param exchange the message exchange being processed
     * @param value the value which can be an {@link Endpoint} or an object
     *                which provides a String representation of an endpoint via
     *                {@link #toString()}
     *
     * @return the endpoint
     * @throws NoSuchEndpointException if the endpoint cannot be resolved
     */
    @SuppressWarnings({""unchecked"" })
    public static <E extends Exchange> Endpoint<E> resolveEndpoint(E exchange, Object value)
        throws NoSuchEndpointException {
        Endpoint<E> endpoint;
        if (value instanceof Endpoint) {
            endpoint = (Endpoint<E>)value;
        } else {
            String uri = value.toString();
            endpoint = CamelContextHelper.getMandatoryEndpoint(exchange.getContext(), uri);
        }
        return endpoint;
    }
    public static <T> T getMandatoryProperty(Exchange exchange, String propertyName, Class<T> type)
        throws NoSuchPropertyException {
        T answer = exchange.getProperty(propertyName, type);
        if (answer == null) {
            throw new NoSuchPropertyException(exchange, propertyName, type);
        }
        return answer;
    }
    public static <T> T getMandatoryHeader(Exchange exchange, String propertyName, Class<T> type)
        throws NoSuchHeaderException {
        T answer = exchange.getIn().getHeader(propertyName, type);
        if (answer == null) {
            throw new NoSuchHeaderException(exchange, propertyName, type);
        }
        return answer;
    }
    /**
     * Returns the mandatory inbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static Object getMandatoryInBody(Exchange exchange) throws InvalidPayloadException {
        Object answer = exchange.getIn().getBody();
        if (answer == null) {
            throw new InvalidPayloadException(exchange, Object.class);
        }
        return answer;
    }
    /**
     * Returns the mandatory inbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static <T> T getMandatoryInBody(Exchange exchange, Class<T> type) throws InvalidPayloadException {
        T answer = exchange.getIn().getBody(type);
        if (answer == null) {
            throw new InvalidPayloadException(exchange, type);
        }
        return answer;
    }
    /**
     * Returns the mandatory outbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static Object getMandatoryOutBody(Exchange exchange) throws InvalidPayloadException {
        Message out = exchange.getOut();
        Object answer = out.getBody();
        if (answer == null) {
            throw new InvalidPayloadException(exchange, Object.class, out);
        }
        return answer;
    }
    /**
     * Returns the mandatory outbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static <T> T getMandatoryOutBody(Exchange exchange, Class<T> type) throws InvalidPayloadException {
        Message out = exchange.getOut();
        T answer = out.getBody(type);
        if (answer == null) {
            throw new InvalidPayloadException(exchange, type, out);
        }
        return answer;
    }
    /**
     * Converts the value to the given expected type or throws an exception
     */
    public static <T> T convertToMandatoryType(Exchange exchange, Class<T> type, Object value)
        throws InvalidTypeException {
        T answer = convertToType(exchange, type, value);
        if (answer == null) {
            throw new InvalidTypeException(exchange, value, type);
        }
        return answer;
    }
    /**
     * Converts the value to the given expected type returning null if it could
     * not be converted
     */
    public static <T> T convertToType(Exchange exchange, Class<T> type, Object value) {
        return exchange.getContext().getTypeConverter().convertTo(type, value);
    }
    /**
     * Copies the results of a message exchange from the source exchange to the result exchange
     * which will copy the out and fault message contents and the exception
     *
     * @param result the result exchange which will have the output and error state added
     * @param source the source exchange which is not modified
     */
    public static void copyResults(Exchange result, Exchange source) {
        if (result != source) {
            result.setException(source.getException());
            Message fault = source.getFault(false);
            if (fault != null) {
                result.getFault(true).copyFrom(fault);
            }
            Message out = source.getOut(false);
            if (out != null) {
                result.getOut(true).copyFrom(out);
            } else {
                // no results so lets copy the last input
                // as the final processor on a pipeline might not
                // have created any OUT; such as a mock:endpoint
                // so lets assume the last IN is the OUT
                result.getOut(true).copyFrom(source.getIn());
            }
            result.getProperties().clear();
            result.getProperties().putAll(source.getProperties());
        }
    }
    /**
     * Returns true if the given exchange pattern (if defined) can support IN messagea
     *
     * @param exchange the exchange to interrogate
     * @return true if the exchange is defined as an {@link ExchangePattern} which supports
     * IN messages
     */
    public static boolean isInCapable(Exchange exchange) {
        ExchangePattern pattern = exchange.getPattern();
        return pattern != null && pattern.isInCapable();
    }
    /**
     * Returns true if the given exchange pattern (if defined) can support OUT messagea
     *
     * @param exchange the exchange to interrogate
     * @return true if the exchange is defined as an {@link ExchangePattern} which supports
     * OUT messages
     */
    public static boolean isOutCapable(Exchange exchange) {
        ExchangePattern pattern = exchange.getPattern();
        return pattern != null && pattern.isOutCapable();
    }
    /**
     * Creates a new instance of the given type from the injector
     */
    public static <T> T newInstance(Exchange exchange, Class<T> type) {
        return exchange.getContext().getInjector().newInstance(type);
    }
    /**
     * Creates a Map of the variables which are made available to a script or template
     *
     * @param exchange the exchange to make available
     * @return a Map populated with the require dvariables
     */
    public static Map createVariableMap(Exchange exchange) {
        Map answer = new HashMap();
        populateVariableMap(exchange, answer);
        return answer;
    }
    /**
     * Populates the Map with the variables which are made available to a script or template
     *
     * @param exchange the exchange to make available
     * @param map      the map to populate
     */
    public static void populateVariableMap(Exchange exchange, Map map) {
        map.put(""exchange"", exchange);
        Message in = exchange.getIn();
        map.put(""in"", in);
        map.put(""request"", in);
        map.put(""headers"", in.getHeaders());
        map.put(""body"", in.getBody());
        if (isOutCapable(exchange)) {
            Message out = exchange.getOut(true);
            map.put(""out"", out);
            map.put(""response"", out);
        }
        map.put(""camelContext"", exchange.getContext());
    }
    /**
     * Returns the MIME content type on the input message or null if one is not defined
     */
    public static String getContentType(Exchange exchange) {
        return exchange.getIn().getHeader(""Content-Type"", String.class);
    }
    /**
     * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found
     */
    public static Object lookupMandatoryBean(Exchange exchange, String name) {
        Object value = lookupBean(exchange, name);
        if (value == null) {
            throw new NoSuchBeanException(name);
        }
        return value;
    }
    /**
     * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found
     */
    public static <T> T lookupMandatoryBean(Exchange exchange, String name, Class<T> type) {
        T value = lookupBean(exchange, name, type);
        if (value == null) {
            throw new NoSuchBeanException(name);
        }
        return value;
    }
    /**
     * Performs a lookup in the registry of the bean name
     */
    public static Object lookupBean(Exchange exchange, String name) {
        return exchange.getContext().getRegistry().lookup(name);
    }
    /**
     * Performs a lookup in the registry of the bean name and type
     */
    public static <T> T lookupBean(Exchange exchange, String name, Class<T> type) {
        return exchange.getContext().getRegistry().lookup(name, type);
    }
}
"
org.apache.camel.util.ExchangeHelperTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.Exchange;
import org.apache.camel.NoSuchPropertyException;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 630591 $
 */
public class ExchangeHelperTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(ExchangeHelperTest.class);
    protected Exchange exchange;
    public void testValidProperty() throws Exception {
        String value = ExchangeHelper.getMandatoryProperty(exchange, ""foo"", String.class);
        assertEquals(""foo property"", ""123"", value);
    }
    public void testMissingProperty() throws Exception {
        try {
            String value = ExchangeHelper.getMandatoryProperty(exchange, ""bar"", String.class);
            fail(""Should have failed but got: "" + value);
        } catch (NoSuchPropertyException e) {
            LOG.debug(""Caught expected: "" + e, e);
        }
    }
    public void testPropertyOfIncompatibleType() throws Exception {
        try {
            List value = ExchangeHelper.getMandatoryProperty(exchange, ""foo"", List.class);
            fail(""Should have failed but got: "" + value);
        } catch (NoSuchPropertyException e) {
            LOG.debug(""Caught expected: "" + e, e);
        }
    }
    @Override
    protected void setUp() throws Exception {
        exchange = new DefaultExchange(new DefaultCamelContext());
        exchange.setProperty(""foo"", 123);
    }
}
"
org.apache.camel.util.ExpressionComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Comparator;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * An implementation of {@link Comparator} which takes an {@link Expression} which is evaluated
 * on each exchange to compare
 *  
 * @version $Revision: 630591 $
 */
public class ExpressionComparator<E extends Exchange> implements Comparator<E> {
    private final Expression<E> expression;
    public ExpressionComparator(Expression<E> expression) {
        this.expression = expression;
    }
    public int compare(E e1, E e2) {
        Object o1 = expression.evaluate(e1);
        Object o2 = expression.evaluate(e2);
        return ObjectHelper.compare(o1, o2);
    }
}
"
org.apache.camel.util.ExpressionHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A collection of helper methods for working with expressions.
 *
 * @version $Revision: 640438 $
 */
public final class ExpressionHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExpressionHelper() {
    }
    /**
     * Evaluates the given expression on the exchange as a String value
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the result of the evaluation as a string.
     */
    public static <E extends Exchange> String evaluateAsString(Expression<E> expression, E exchange) {
        return evaluateAsType(expression, exchange, String.class);
    }
    /**
     * Evaluates the given expression on the exchange, converting the result to
     * the given type
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @param resultType the type of the result that is required
     * @return the result of the evaluation as the specified type.
     */
    public static <T, E extends Exchange> T evaluateAsType(Expression<E> expression, E exchange,
                                                           Class<T> resultType) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(resultType, value);
    }
}
"
org.apache.camel.util.ExpressionListComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Comparator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * An implementation of {@link java.util.Comparator} which takes a list of
 * {@link org.apache.camel.Expression} objects which is evaluated
 * on each exchange to compare them
 *
 * @version $Revision: 630591 $
 */
public class ExpressionListComparator implements Comparator<Exchange> {
    private final List<Expression> expressions;
    public ExpressionListComparator(List<Expression> expressions) {
        this.expressions = expressions;
    }
    public int compare(Exchange e1, Exchange e2) {
        for (Expression expression : expressions) {
            Object o1 = expression.evaluate(e1);
            Object o2 = expression.evaluate(e2);
            int answer = ObjectHelper.compare(o1, o2);
            if (answer != 0) {
                return answer;
            }
        }
        return 0;
    }
}
"
org.apache.camel.util.FactoryFinder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.spi.Injector;
/**
 * Finder to find factories from the resource classpath, usually <b>META-INF/services/org/apache/camel/</b>.
 */
public class FactoryFinder {
    private final String path;
    private final ConcurrentHashMap classMap = new ConcurrentHashMap();
    public FactoryFinder() {
        this(""META-INF/services/org/apache/camel/"");
    }
    public FactoryFinder(String path) {
        this.path = path;
    }
    /**
     * Creates a new instance of the given key
     *
     * @param key is the key to add to the path to find a text file containing
     *            the factory name
     * @return a newly created instance
     */
    public Object newInstance(String key) throws IllegalAccessException, InstantiationException, IOException,
        ClassNotFoundException {
        return newInstance(key, (String)null);
    }
    public Object newInstance(String key, String propertyPrefix) throws IllegalAccessException,
        InstantiationException, IOException, ClassNotFoundException {
        Class clazz = findClass(key, propertyPrefix);
        return clazz.newInstance();
    }
    public Object newInstance(String key, Injector injector) throws IOException, ClassNotFoundException {
        return newInstance(key, injector, (String)null);
    }
    public Object newInstance(String key, Injector injector, String propertyPrefix) throws IOException,
        ClassNotFoundException {
        Class type = findClass(key, propertyPrefix);
        return injector.newInstance(type);
    }
    public <T> T newInstance(String key, Injector injector, Class<T> expectedType) throws IOException,
        ClassNotFoundException {
        return newInstance(key, injector, null, expectedType);
    }
    public <T> T newInstance(String key, Injector injector, String propertyPrefix, Class<T> expectedType)
        throws IOException, ClassNotFoundException {
        Class type = findClass(key, propertyPrefix);
        Object value = injector.newInstance(type);
        if (expectedType.isInstance(value)) {
            return expectedType.cast(value);
        } else {
            throw new ClassCastException(""Not instanceof "" + expectedType.getName() + "" value: "" + value);
        }
    }
    public <T> List<T> newInstances(String key, Injector injector, Class<T> type) throws IOException,
        ClassNotFoundException {
        List<Class> list = findClasses(key);
        List<T> answer = new ArrayList<T>(list.size());
        answer.add(newInstance(key, injector, type));
        return answer;
    }
    public Class findClass(String key) throws ClassNotFoundException, IOException {
        return findClass(key, null);
    }
    public Class findClass(String key, String propertyPrefix) throws ClassNotFoundException, IOException {
        if (propertyPrefix == null) {
            propertyPrefix = """";
        }
        Class clazz = (Class)classMap.get(propertyPrefix + key);
        if (clazz == null) {
            clazz = newInstance(doFindFactoryProperties(key), propertyPrefix);
            classMap.put(propertyPrefix + key, clazz);
        }
        return clazz;
    }
    public List<Class> findClasses(String key) throws ClassNotFoundException, IOException {
        return findClasses(key, null);
    }
    public List<Class> findClasses(String key, String propertyPrefix) throws ClassNotFoundException,
        IOException {
        // TODO change to support finding multiple classes on the classpath!
        Class type = findClass(key, propertyPrefix);
        return Collections.singletonList(type);
    }
    public String getPath() {
        return path;
    }
    private Class newInstance(Properties properties, String propertyPrefix) throws ClassNotFoundException,
        IOException {
        String className = properties.getProperty(propertyPrefix + ""class"");
        if (className == null) {
            throw new IOException(""Expected property is missing: "" + propertyPrefix + ""class"");
        }
        return ObjectHelper.loadClass(className);
    }
    private Properties doFindFactoryProperties(String key) throws IOException {
        String uri = path + key;
        InputStream in = ObjectHelper.loadResourceAsStream(uri);
        if (in == null) {
            throw new NoFactoryAvailableException(uri);
        }
        // lets load the file
        BufferedInputStream reader = null;
        try {
            reader = new BufferedInputStream(in);
            Properties properties = new Properties();
            properties.load(reader);
            return properties;
        } finally {
            ObjectHelper.close(reader, key, null);
            ObjectHelper.close(in, key, null);
        }
    }
}
"
org.apache.camel.util.IntrospectionSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import org.apache.camel.TypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Helper for introspections of beans.
 */
public final class IntrospectionSupport {
    private static final transient Log LOG = LogFactory.getLog(IntrospectionSupport.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private IntrospectionSupport() {
    }
    public static boolean getProperties(Object target, Map props, String optionPrefix) {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        if (optionPrefix == null) {
            optionPrefix = """";
        }
        Class clazz = target.getClass();
        Method[] methods = clazz.getMethods();
        for (Method method : methods) {
            String name = method.getName();
            Class type = method.getReturnType();
            Class params[] = method.getParameterTypes();
            if (name.startsWith(""get"") && params.length == 0 && type != null && isSettableType(type)) {
                try {
                    Object value = method.invoke(target);
                    if (value == null) {
                        continue;
                    }
                    String strValue = convertToString(value, type);
                    if (strValue == null) {
                        continue;
                    }
                    name = name.substring(3, 4).toLowerCase() + name.substring(4);
                    props.put(optionPrefix + name, strValue);
                    rc = true;
                } catch (Throwable ignore) {
                    // ignore
                }
            }
        }
        return rc;
    }
    public static Object getProperty(Object target, String prop) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (prop == null) {
            throw new IllegalArgumentException(""prop was null."");
        }
        prop = prop.substring(0, 1).toUpperCase() + prop.substring(1);
        Class clazz = target.getClass();
        Method method = getPropertyGetter(clazz, prop);
        return method.invoke(target);
    }
    public static Method getPropertyGetter(Class type, String propertyName) throws NoSuchMethodException {
        Method method = type.getMethod(""get"" + ObjectHelper.capitalize(propertyName));
        return method;
    }
    public static boolean setProperties(Object target, Map props, String optionPrefix) throws Exception {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String)iter.next();
            if (name.startsWith(optionPrefix)) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                if (setProperty(target, name, value)) {
                    iter.remove();
                    rc = true;
                }
            }
        }
        return rc;
    }
    public static Map extractProperties(Map props, String optionPrefix) {
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        HashMap rc = new HashMap(props.size());
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String)iter.next();
            if (name.startsWith(optionPrefix)) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                rc.put(name, value);
                iter.remove();
            }
        }
        return rc;
    }
    public static boolean setProperties(TypeConverter typeConverter, Object target, Map props) throws Exception {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        for (Iterator iter = props.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry)iter.next();
            if (setProperty(typeConverter, target, (String)entry.getKey(), entry.getValue())) {
                iter.remove();
                rc = true;
            }
        }
        return rc;
    }
    public static boolean setProperties(Object target, Map props) throws Exception {
        return setProperties(null, target, props);
    }
    public static boolean setProperty(TypeConverter typeConverter, Object target, String name, Object value) throws Exception {
        try {
            Class clazz = target.getClass();
            Method setter = findSetterMethod(typeConverter, clazz, name, value);
            if (setter == null) {
                return false;
            }
            // If the type is null or it matches the needed type, just use the
            // value directly
            if (value == null || value.getClass() == setter.getParameterTypes()[0]) {
                setter.invoke(target, value);
            } else {
                // We need to convert it
                Object convertedValue = convert(typeConverter, setter.getParameterTypes()[0], value);
                setter.invoke(target, convertedValue);
            }
            return true;
        } catch (InvocationTargetException e) {
            Throwable throwable = e.getTargetException();
            if (throwable instanceof Exception) {
                Exception exception = (Exception)throwable;
                throw exception;
            } else {
                Error error = (Error)throwable;
                throw error;
            }
        }
    }
    public static boolean setProperty(Object target, String name, Object value) throws Exception {
        return setProperty(null, target, name, value);
    }
    private static Object convert(TypeConverter typeConverter, Class type, Object value) throws URISyntaxException {
        if (typeConverter != null) {
            Object answer = typeConverter.convertTo(type, value);
            if (answer == null) {
                throw new IllegalArgumentException(""Could not convert \"""" + value + ""\"" to "" + type.getName());
            }
            return answer;
        }
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if (editor != null) {
            editor.setAsText(value.toString());
            return editor.getValue();
        }
        if (type == URI.class) {
            return new URI(value.toString());
        }
        return null;
    }
    private static String convertToString(Object value, Class type) throws URISyntaxException {
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if (editor != null) {
            editor.setValue(value);
            return editor.getAsText();
        }
        if (type == URI.class) {
            return value.toString();
        }
        return null;
    }
    private static Method findSetterMethod(TypeConverter typeConverter, Class clazz, String name, Object value) {
        // Build the method name.
        name = ""set"" + ObjectHelper.capitalize(name);
        while (clazz != Object.class) {
            Method[] methods = clazz.getMethods();
            for (Method method : methods) {
                Class params[] = method.getParameterTypes();
                if (method.getName().equals(name) && params.length == 1) {
                    Class paramType = params[0];
                    if (typeConverter != null || isSettableType(paramType) || paramType.isInstance(value)) {
                        return method;
                    }
                }
            }
            clazz = clazz.getSuperclass();
        }
        return null;
    }
    private static boolean isSettableType(Class clazz) {
        if (PropertyEditorManager.findEditor(clazz) != null) {
            return true;
        }
        if (clazz == URI.class) {
            return true;
        }
        if (clazz == Boolean.class) {
            return true;
        }
        return false;
    }
    public static String toString(Object target) {
        return toString(target, Object.class);
    }
    public static String toString(Object target, Class stopClass) {
        LinkedHashMap map = new LinkedHashMap();
        addFields(target, target.getClass(), stopClass, map);
        StringBuffer buffer = new StringBuffer(simpleName(target.getClass()));
        buffer.append("" {"");
        Set entrySet = map.entrySet();
        boolean first = true;
        for (Iterator iter = entrySet.iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry)iter.next();
            if (first) {
                first = false;
            } else {
                buffer.append("", "");
            }
            buffer.append(entry.getKey());
            buffer.append("" = "");
            appendToString(buffer, entry.getValue());
        }
        buffer.append(""}"");
        return buffer.toString();
    }
    protected static void appendToString(StringBuffer buffer, Object value) {
        // if (value instanceof ActiveMQDestination) {
        // ActiveMQDestination destination = (ActiveMQDestination) value;
        // buffer.append(destination.getQualifiedName());
        // }
        // else {
        buffer.append(value);
        // }
    }
    public static String simpleName(Class clazz) {
        String name = clazz.getName();
        int p = name.lastIndexOf(""."");
        if (p >= 0) {
            name = name.substring(p + 1);
        }
        return name;
    }
    private static void addFields(Object target, Class startClass, Class stopClass, LinkedHashMap map) {
        if (startClass != stopClass) {
            addFields(target, startClass.getSuperclass(), stopClass, map);
        }
        Field[] fields = startClass.getDeclaredFields();
        for (Field field : fields) {
            if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers())
                || Modifier.isPrivate(field.getModifiers())) {
                continue;
            }
            try {
                field.setAccessible(true);
                Object o = field.get(target);
                if (o != null && o.getClass().isArray()) {
                    try {
                        o = Arrays.asList((Object[])o);
                    } catch (Throwable e) {
                        // ignore
                    }
                }
                map.put(field.getName(), o);
            } catch (Throwable e) {
                LOG.debug(""Error adding fields"", e);
            }
        }
    }
}
"
org.apache.camel.util.IOHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
/**
 * IO helper class.
 *
 * @version $Revision: 659836 $
 */
public final class IOHelper {
    private IOHelper() {
        //Utility Class
    }
    /**
     * A factory method which creates an {@link IOException} from the given
     * exception and message
     */
    public static IOException createIOException(Throwable cause) {
        return createIOException(cause.getMessage(), cause);
    }
    /**
     * A factory method which creates an {@link IOException} from the given
     * exception and message
     */
    public static IOException createIOException(String message, Throwable cause) {
        IOException answer = new IOException(message);
        answer.initCause(cause);
        return answer;
    }
}
"
org.apache.camel.util.LRUCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.LinkedHashMap;
import java.util.Map;
/**
 * A Least Recently Used Cache
 *
 * @version $Revision: 655284 $
 */
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final long serialVersionUID = -342098639681884413L;
    private int maxCacheSize = 10000;
    public LRUCache(int maximumCacheSize) {
        this(maximumCacheSize, maximumCacheSize, 0.75f, true);
    }
    /**
     * Constructs an empty <tt>LRUCache</tt> instance with the
     * specified initial capacity, maximumCacheSize,load factor and ordering mode.
     *
     * @param initialCapacity  the initial capacity.
     * @param maximumCacheSize
     * @param loadFactor       the load factor.
     * @param accessOrder      the ordering mode - <tt>true</tt> for
     *                         access-order, <tt>false</tt> for insertion-order.
     * @throws IllegalArgumentException if the initial capacity is negative
     *                                  or the load factor is non positive.
     */
    public LRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor, accessOrder);
        this.maxCacheSize = maximumCacheSize;
    }
    /**
     * Returns the maxCacheSize.
     */
    public int getMaxCacheSize() {
        return maxCacheSize;
    }
    protected boolean removeEldestEntry(Map.Entry entry) {
        return size() > maxCacheSize;
    }
}
"
org.apache.camel.util.NoFactoryAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
/**
 * Thrown if no factory resource is available for the given URI
 *
 * @version $Revision: 630591 $
 */
public class NoFactoryAvailableException extends IOException {
    private final String uri;
    public NoFactoryAvailableException(String uri) {
        super(""Could not find factory class for resource: "" + uri);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.util.ObjectHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A number of useful helper methods for working with Objects
 *
 * @version $Revision: 673642 $
 */
public final class ObjectHelper {
    private static final transient Log LOG = LogFactory.getLog(ObjectHelper.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private ObjectHelper() {
    }
    /**
     * @deprecated use the equal method instead. Will be removed in Camel 2.0.
     *
     * @see #equal(Object, Object)
     */
    @Deprecated
    public static boolean equals(Object a, Object b) {
        return equal(a, b);
    }
    /**
     * A helper method for comparing objects for equality while handling nulls
     */
    public static boolean equal(Object a, Object b) {
        if (a == b) {
            return true;
        }
        if (a instanceof byte[] && b instanceof byte[]) {
            return equalByteArray((byte[]) a, (byte[]) b);
        }
        return a != null && b != null && a.equals(b);
    }
    /**
     * A helper method for comparing byte arrays for equality while handling nulls
     */
    public static boolean equalByteArray(byte[] a, byte[] b) {
        if (a == b) {
            return true;
        }
        // loop and compare each byte
        if (a != null && b != null && a.length == b.length) {
            for (int i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    return false;
                }
            }
            // all bytes are equal
            return true;
        }
        return false;
    }
    /**
     * Returns true if the given object is equal to any of the expected value
     */
    public static boolean isEqualToAny(Object object, Object... values) {
        for (Object value : values) {
            if (equal(object, value)) {
                return true;
            }
        }
        return false;
    }
    /**
     * A helper method for performing an ordered comparsion on the objects
     * handling nulls and objects which do not handle sorting gracefully
     */
    public static int compare(Object a, Object b) {
        if (a == b) {
            return 0;
        }
        if (a == null) {
            return -1;
        }
        if (b == null) {
            return 1;
        }
        if (a instanceof Comparable) {
            Comparable comparable = (Comparable)a;
            return comparable.compareTo(b);
        } else {
            int answer = a.getClass().getName().compareTo(b.getClass().getName());
            if (answer == 0) {
                answer = a.hashCode() - b.hashCode();
            }
            return answer;
        }
    }
    public static Boolean toBoolean(Object value) {
        if (value instanceof Boolean) {
            return (Boolean)value;
        }
        if (value instanceof String) {
            return ""true"".equalsIgnoreCase(value.toString()) ? Boolean.TRUE : Boolean.FALSE;
        }
        if (value instanceof Integer) {
            return (Integer)value > 0 ? Boolean.TRUE : Boolean.FALSE;
        }
        return null;
    }
    public static void notNull(Object value, String name) {
        if (value == null) {
            throw new IllegalArgumentException(name + "" must be specified"");
        }
    }
    public static String[] splitOnCharacter(String value, String needle, int count) {
        String rc[] = new String[count];
        rc[0] = value;
        for (int i = 1; i < count; i++) {
            String v = rc[i - 1];
            int p = v.indexOf(needle);
            if (p < 0) {
                return rc;
            }
            rc[i - 1] = v.substring(0, p);
            rc[i] = v.substring(p + 1);
        }
        return rc;
    }
    /**
     * Removes any starting characters on the given text which match the given
     * character
     *
     * @param text the string
     * @param ch the initial characters to remove
     * @return either the original string or the new substring
     */
    public static String removeStartingCharacters(String text, char ch) {
        int idx = 0;
        while (text.charAt(idx) == ch) {
            idx++;
        }
        if (idx > 0) {
            return text.substring(idx);
        }
        return text;
    }
    public static String capitalize(String text) {
        if (text == null) {
            return null;
        }
        int length = text.length();
        if (length == 0) {
            return text;
        }
        String answer = text.substring(0, 1).toUpperCase();
        if (length > 1) {
            answer += text.substring(1, length);
        }
        return answer;
    }
    /**
     * Returns true if the collection contains the specified value
     */
    @SuppressWarnings(""unchecked"")
    public static boolean contains(Object collectionOrArray, Object value) {
        if (collectionOrArray instanceof Collection) {
            Collection collection = (Collection)collectionOrArray;
            return collection.contains(value);
        } else if (collectionOrArray instanceof String && value instanceof String) {
            String str = (String) collectionOrArray;
            String subStr = (String) value;
            return str.contains(subStr);
        } else {
            Iterator iter = createIterator(collectionOrArray);
            while (iter.hasNext()) {
                if (equal(value, iter.next())) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Creates an iterator over the value if the value is a collection, an
     * Object[] or a primitive type array; otherwise to simplify the caller's
     * code, we just create a singleton collection iterator over a single value
     */
    @SuppressWarnings(""unchecked"")
    public static Iterator createIterator(Object value) {
        if (value == null) {
            return Collections.EMPTY_LIST.iterator();
        } else if (value instanceof Collection) {
            Collection collection = (Collection)value;
            return collection.iterator();
        } else if (value.getClass().isArray()) {
            // TODO we should handle primitive array types?
            List<Object> list = Arrays.asList((Object[]) value);
            return list.iterator();
        } else if (value instanceof NodeList) {
            // lets iterate through DOM results after performing XPaths
            final NodeList nodeList = (NodeList) value;
            return new Iterator<Node>() {
                int idx = -1;
                public boolean hasNext() {
                    return ++idx < nodeList.getLength();
                }
                public Node next() {
                    return nodeList.item(idx);
                }
                public void remove() {
                    throw new UnsupportedOperationException();
                }
            };
        } else {
            return Collections.singletonList(value).iterator();
        }
    }
    /**
     * Returns the predicate matching boolean on a {@link List} result set where
     * if the first element is a boolean its value is used otherwise this method
     * returns true if the collection is not empty
     *
     * @return <tt>true</tt> if the first element is a boolean and its value is true or
     *          if the list is non empty
     */
    public static boolean matches(List list) {
        if (!list.isEmpty()) {
            Object value = list.get(0);
            if (value instanceof Boolean) {
                Boolean flag = (Boolean)value;
                return flag.booleanValue();
            } else {
                // lets assume non-empty results are true
                return true;
            }
        }
        return false;
    }
    public static boolean isNotNullAndNonEmpty(String text) {
        return text != null && text.trim().length() > 0;
    }
    public static boolean isNullOrBlank(String text) {
        return text == null || text.trim().length() <= 0;
    }
    /**
     * A helper method to access a system property, catching any security
     * exceptions
     *
     * @param name the name of the system property required
     * @param defaultValue the default value to use if the property is not
     *                available or a security exception prevents access
     * @return the system property value or the default value if the property is
     *         not available or security does not allow its access
     */
    public static String getSystemProperty(String name, String defaultValue) {
        try {
            return System.getProperty(name, defaultValue);
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Caught security exception accessing system property: "" + name + "". Reason: "" + e,
                          e);
            }
            return defaultValue;
        }
    }
    /**
     * Returns the type name of the given type or null if the type variable is
     * null
     */
    public static String name(Class type) {
        return type != null ? type.getName() : null;
    }
    /**
     * Returns the type name of the given value
     */
    public static String className(Object value) {
        return name(value != null ? value.getClass() : null);
    }
    /**
     * Attempts to load the given class name using the thread context class
     * loader or the class loader used to load this class
     *
     * @param name the name of the class to load
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name) {
        return loadClass(name, ObjectHelper.class.getClassLoader());
    }
    /**
     * Attempts to load the given class name using the thread context class
     * loader or the given class loader
     *
     * @param name the name of the class to load
     * @param loader the class loader to use after the thread context class
     *                loader
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name, ClassLoader loader) {
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        if (contextClassLoader != null) {
            try {
                return contextClassLoader.loadClass(name);
            } catch (ClassNotFoundException e) {
                try {
                    return loader.loadClass(name);
                } catch (ClassNotFoundException e1) {
                    LOG.debug(""Could not find class: "" + name + "". Reason: "" + e);
                }
            }
        }
        return null;
    }
    /**
     * Attempts to load the given resource as a stream using the thread context class
     * loader or the class loader used to load this class
     *
     * @param name the name of the resource to load
     * @return the stream or null if it could not be loaded
     */
    public static InputStream loadResourceAsStream(String name) {
        InputStream in = null;
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        if (contextClassLoader != null) {
            in = contextClassLoader.getResourceAsStream(name);
        }
        if (in == null) {
            in = ObjectHelper.class.getClassLoader().getResourceAsStream(name);
        }
        return in;
    }
    /**
     * A helper method to invoke a method via reflection and wrap any exceptions
     * as {@link RuntimeCamelException} instances
     *
     * @param method the method to invoke
     * @param instance the object instance (or null for static methods)
     * @param parameters the parameters to the method
     * @return the result of the method invocation
     */
    public static Object invokeMethod(Method method, Object instance, Object... parameters) {
        try {
            return method.invoke(instance, parameters);
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeCamelException(e.getCause());
        }
    }
    /**
     * Returns a list of methods which are annotated with the given annotation
     *
     * @param type the type to reflect on
     * @param annotationType the annotation type
     * @return a list of the methods found
     */
    public static List<Method> findMethodsWithAnnotation(Class<?> type,
                                                         Class<? extends Annotation> annotationType) {
        List<Method> answer = new ArrayList<Method>();
        do {
            Method[] methods = type.getDeclaredMethods();
            for (Method method : methods) {
                if (method.getAnnotation(annotationType) != null) {
                    answer.add(method);
                }
            }
            type = type.getSuperclass();
        } while (type != null);
        return answer;
    }
    /**
     * Turns the given object arrays into a meaningful string
     *
     * @param objects an array of objects or null
     * @return a meaningful string
     */
    public static String asString(Object[] objects) {
        if (objects == null) {
            return ""null"";
        } else {
            StringBuffer buffer = new StringBuffer(""{"");
            int counter = 0;
            for (Object object : objects) {
                if (counter++ > 0) {
                    buffer.append("", "");
                }
                String text = (object == null) ? ""null"" : object.toString();
                buffer.append(text);
            }
            buffer.append(""}"");
            return buffer.toString();
        }
    }
    /**
     * Returns true if a class is assignable from another class like the
     * {@link Class#isAssignableFrom(Class)} method but which also includes
     * coercion between primitive types to deal with Java 5 primitive type
     * wrapping
     */
    public static boolean isAssignableFrom(Class a, Class b) {
        a = convertPrimitiveTypeToWrapperType(a);
        b = convertPrimitiveTypeToWrapperType(b);
        return a.isAssignableFrom(b);
    }
    /**
     * Converts primitive types such as int to its wrapper type like
     * {@link Integer}
     */
    public static Class convertPrimitiveTypeToWrapperType(Class type) {
        Class rc = type;
        if (type.isPrimitive()) {
            if (type == int.class) {
                rc = Integer.class;
            } else if (type == long.class) {
                rc = Long.class;
            } else if (type == double.class) {
                rc = Double.class;
            } else if (type == float.class) {
                rc = Float.class;
            } else if (type == short.class) {
                rc = Short.class;
            } else if (type == byte.class) {
                rc = Byte.class;
            // TODO: Why is boolean disabled
/*
            } else if (type == boolean.class) {
                rc = Boolean.class;
*/
            }
        }
        return rc;
    }
    /**
     * Helper method to return the default character set name
     */
    public static String getDefaultCharacterSet() {
        return Charset.defaultCharset().name();
    }
    /**
     * Returns the Java Bean property name of the given method, if it is a setter
     */
    public static String getPropertyName(Method method) {
        String propertyName = method.getName();
        if (propertyName.startsWith(""set"") && method.getParameterTypes().length == 1) {
            propertyName = propertyName.substring(3, 4).toLowerCase() + propertyName.substring(4);
        }
        return propertyName;
    }
    /**
     * Returns true if the given collection of annotations matches the given type
     */
    public static boolean hasAnnotation(Annotation[] annotations, Class<?> type) {
        for (Annotation annotation : annotations) {
            if (type.isInstance(annotation)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Closes the given resource if it is available, logging any closing exceptions to the given log
     *
     * @param closeable the object to close
     * @param name the name of the resource
     * @param log the log to use when reporting closure warnings
     */
    public static void close(Closeable closeable, String name, Log log) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (IOException e) {
                if (log != null) {
                    log.warn(""Could not close: "" + name + "". Reason: "" + e, e);
                }
            }
        }
    }
    /**
     * Converts the given value to the required type or throw a meaningful exception
     */
    public static <T> T cast(Class<T> toType, Object value) {
        if (toType == boolean.class) {
            return (T)cast(Boolean.class, value);
        } else if (toType.isPrimitive()) {
            Class newType = convertPrimitiveTypeToWrapperType(toType);
            if (newType != toType) {
                return (T)cast(newType, value);
            }
        }
        try {
            return toType.cast(value);
        } catch (ClassCastException e) {
            throw new IllegalArgumentException(""Failed to convert: "" + value + "" to type: ""
                                               + toType.getName() + "" due to: "" + e, e);
        }
    }
    /**
     * A helper method to create a new instance of a type using the default constructor arguments.
     */
    public static <T> T newInstance(Class<T> type) {
        try {
            return type.newInstance();
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e.getCause());
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * A helper method to create a new instance of a type using the default constructor arguments.
     */
    public static <T> T newInstance(Class<?> actualType, Class<T> expectedType) {
        try {
            Object value = actualType.newInstance();
            return cast(expectedType, value);
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e.getCause());
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Returns true if the given name is a valid java identifier
     */
    public static boolean isJavaIdentifier(String name) {
        if (name == null) {
            return false;
        }
        int size = name.length();
        if (size < 1) {
            return false;
        }
        if (Character.isJavaIdentifierStart(name.charAt(0))) {
            for (int i = 1; i < size; i++) {
                if (!Character.isJavaIdentifierPart(name.charAt(i))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Returns the type of the given object or null if the value is null
     */
    public static Object type(Object bean) {
        return bean != null ? bean.getClass() : null;
    }
    /**
     * Evaluate the value as a predicate which attempts to convert the value to
     * a boolean otherwise true is returned if the value is not null
     */
    public static boolean evaluateValuePredicate(Object value) {
        if (value instanceof Boolean) {
            Boolean aBoolean = (Boolean)value;
            return aBoolean.booleanValue();
        }
        return value != null;
    }
}
"
org.apache.camel.util.ObjectHelperTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;
import junit.framework.TestCase;
/**
 * @version $Revision: 640438 $
 */
public class ObjectHelperTest extends TestCase {
    public void testRemoveInitialCharacters() throws Exception {
        assertEquals(ObjectHelper.removeStartingCharacters(""foo"", '/'), ""foo"");
        assertEquals(ObjectHelper.removeStartingCharacters(""/foo"", '/'), ""foo"");
        assertEquals(ObjectHelper.removeStartingCharacters(""//foo"", '/'), ""foo"");
    }
    public void testGetPropertyName() throws Exception {
        Method method = getClass().getMethod(""setCheese"", String.class);
        assertNotNull(""should have found a method!"", method);
        String name = ObjectHelper.getPropertyName(method);
        assertEquals(""Property name"", ""cheese"", name);
    }
    public void setCheese(String cheese) {
        // used in the above unit test
    }
    public void testContains() throws Exception {
        String[] array = {""foo"", ""bar""};
        Collection<String> collection = Arrays.asList(array);
        assertTrue(ObjectHelper.contains(array, ""foo""));
        assertTrue(ObjectHelper.contains(collection, ""foo""));
        assertTrue(ObjectHelper.contains(""foo"", ""foo""));
        assertFalse(ObjectHelper.contains(array, ""xyz""));
        assertFalse(ObjectHelper.contains(collection, ""xyz""));
        assertFalse(ObjectHelper.contains(""foo"", ""xyz""));
    }
    public void testEqual() {
        assertTrue(ObjectHelper.equal(null, null));
        assertTrue(ObjectHelper.equal("""", """"));
        assertTrue(ObjectHelper.equal("" "", "" ""));
        assertTrue(ObjectHelper.equal(""Hello"", ""Hello""));
        assertTrue(ObjectHelper.equal(123, 123));
        assertTrue(ObjectHelper.equal(true, true));
        assertFalse(ObjectHelper.equal(null, """"));
        assertFalse(ObjectHelper.equal("""", null));
        assertFalse(ObjectHelper.equal("" "", ""    ""));
        assertFalse(ObjectHelper.equal(""Hello"", ""World""));
        assertFalse(ObjectHelper.equal(true, false));
        assertFalse(ObjectHelper.equal(new Object(), new Object()));
        byte[] a = new byte[] {40, 50, 60};
        byte[] b = new byte[] {40, 50, 60};
        assertTrue(ObjectHelper.equal(a, b));
        a = new byte[] {40, 50, 60};
        b = new byte[] {40, 50, 60, 70};
        assertFalse(ObjectHelper.equal(a, b));
    }
    public void testEqualByteArray() {
        assertTrue(ObjectHelper.equalByteArray(""Hello"".getBytes(), ""Hello"".getBytes()));
        assertFalse(ObjectHelper.equalByteArray(""Hello"".getBytes(), ""World"".getBytes()));
        assertTrue(ObjectHelper.equalByteArray(""Hello Thai Elephant \u0E08"".getBytes(), ""Hello Thai Elephant \u0E08"".getBytes()));
        assertTrue(ObjectHelper.equalByteArray(null, null));
        byte[] empty = new byte[0];
        assertTrue(ObjectHelper.equalByteArray(empty, empty));
        byte[] a = new byte[] {40, 50, 60};
        byte[] b = new byte[] {40, 50, 60};
        assertTrue(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60};
        b = new byte[] {40, 50, 60, 70};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60, 70};
        b = new byte[] {40, 50, 60};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60};
        b = new byte[0];
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[0];
        b = new byte[] {40, 50, 60};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = new byte[] {40, 50, 60};
        b = null;
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = null;
        b = new byte[] {40, 50, 60};
        assertFalse(ObjectHelper.equalByteArray(a, b));
        a = null;
        b = null;
        assertTrue(ObjectHelper.equalByteArray(a, b));
    }
}
"
org.apache.camel.util.PackageHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Some helper methods for working with Java packages and versioning.
 *
 * @version $Revision: 664624 $
 */
public final class PackageHelper {
    private static final transient Log LOG = LogFactory.getLog(PackageHelper.class);
    private PackageHelper() {
        // Utility Class
    }
    /**
     * Returns true if the version number of the given package name can be found and is greater than or equal to the minimum version.
     *
     * For package names which include multiple dots, the dots are removed. So for example a spring version of 2.5.1 is converted to
     * 2.51 so you can assert that its >= 2.51 (so above 2.50 and less than 2.52 etc).
     *
     * @param packageName the Java package name to compare
     * @param minimumVersion the minimum version number
     * @return true if the package name can be determined and if its greater than or equal to the minimum value
     */
    public static boolean isValidVersion(String packageName, double minimumVersion) {
        try {
            Package spring = Package.getPackage(packageName);
            String value = spring.getImplementationVersion();
            if (value != null) {
                // lets remove any extra dots in the string...
                int idx = value.indexOf('.');
                if (idx >= 0) {
                    StringBuffer buffer = new StringBuffer(value.substring(0, ++idx));
                    int i = idx;
                    for (int size = value.length(); i < size; i++) {
                        char ch = value.charAt(i);
                        if (Character.isDigit(ch)) {
                            buffer.append(ch);
                        }
                    }
                    value = buffer.toString();
                }
                double number = Double.parseDouble(value);
                return number >= minimumVersion;
            }
        } catch (Exception e) {
            LOG.debug(""Failed to find out "" + packageName + "" version: "" + e, e);
        }
        return true;
    }
}
"
org.apache.camel.util.ReflectionInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.spi.Injector;
/**
 * A simple implementation of {@link Injector} which just uses reflection to
 * instantiate new objects using their zero argument constructor. For more
 * complex implementations try the Spring or Guice implementations.
 * 
 * @version $Revision: 659638 $
 */
public class ReflectionInjector implements Injector {
    public <T> T newInstance(Class<T> type) {
        return ObjectHelper.newInstance(type);
    }
}
"
org.apache.camel.util.ResolverUtil,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * <p>
 * ResolverUtil is used to locate classes that are available in the/a class path
 * and meet arbitrary conditions. The two most common conditions are that a
 * class implements/extends another class, or that is it annotated with a
 * specific annotation. However, through the use of the {@link Test} class it is
 * possible to search using arbitrary conditions.
 * </p>
 * <p/>
 * <p>
 * A ClassLoader is used to locate all locations (directories and jar files) in
 * the class path that contain classes within certain packages, and then to load
 * those classes and check them. By default the ClassLoader returned by
 * {@code Thread.currentThread().getContextClassLoader()} is used, but this can
 * be overridden by calling {@link #setClassLoaders(Set)} prior to
 * invoking any of the {@code find()} methods.
 * </p>
 * <p/>
 * <p>
 * General searches are initiated by calling the
 * {@link #find(ResolverUtil.Test, String)} ()} method and supplying a package
 * name and a Test instance. This will cause the named package <b>and all
 * sub-packages</b> to be scanned for classes that meet the test. There are
 * also utility methods for the common use cases of scanning multiple packages
 * for extensions of particular classes, or classes annotated with a specific
 * annotation.
 * </p>
 * <p/>
 * <p>
 * The standard usage pattern for the ResolverUtil class is as follows:
 * </p>
 * <p/>
 * <pre>
 * esolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();
 * esolver.findImplementation(ActionBean.class, pkg1, pkg2);
 * esolver.find(new CustomTest(), pkg1);
 * esolver.find(new CustomTest(), pkg2);
 * ollection&lt;ActionBean&gt; beans = resolver.getClasses();
 * </pre>
 *
 * @author Tim Fennell
 */
public class ResolverUtil<T> {
    protected static final transient Log LOG = LogFactory.getLog(ResolverUtil.class);
    /**
     * A simple interface that specifies how to test classes to determine if
     * they are to be included in the results produced by the ResolverUtil.
     */
    public static interface Test {
        /**
         * Will be called repeatedly with candidate classes. Must return True if
         * a class is to be included in the results, false otherwise.
         */
        boolean matches(Class type);
    }
    /**
     * A Test that checks to see if each class is assignable to the provided
     * class. Note that this test will match the parent type itself if it is
     * presented for matching.
     */
    public static class IsA implements Test {
        private Class parent;
        /**
         * Constructs an IsA test using the supplied Class as the parent
         * class/interface.
         */
        public IsA(Class parentType) {
            this.parent = parentType;
        }
        /**
         * Returns true if type is assignable to the parent type supplied in the
         * constructor.
         */
        public boolean matches(Class type) {
            return type != null && parent.isAssignableFrom(type);
        }
        @Override
        public String toString() {
            return ""is assignable to "" + parent.getSimpleName();
        }
    }
    /**
     * A Test that checks to see if each class is annotated with a specific
     * annotation. If it is, then the test returns true, otherwise false.
     */
    public static class AnnotatedWith implements Test {
        private Class<? extends Annotation> annotation;
        /**
         * Constructs an AnnotatedWith test for the specified annotation type.
         */
        public AnnotatedWith(Class<? extends Annotation> annotation) {
            this.annotation = annotation;
        }
        /**
         * Returns true if the type is annotated with the class provided to the
         * constructor.
         */
        public boolean matches(Class type) {
            return type != null && type.isAnnotationPresent(annotation);
        }
        @Override
        public String toString() {
            return ""annotated with @"" + annotation.getSimpleName();
        }
    }
    /**
     * The set of matches being accumulated.
     */
    private Set<Class<? extends T>> matches = new HashSet<Class<? extends T>>();
    /**
     * The ClassLoader to use when looking for classes. If null then the
     * ClassLoader returned by Thread.currentThread().getContextClassLoader()
     * will be used.
     */
    private Set<ClassLoader> classLoaders;
    /**
     * Provides access to the classes discovered so far. If no calls have been
     * made to any of the {@code find()} methods, this set will be empty.
     *
     * @return the set of classes that have been discovered.
     */
    public Set<Class<? extends T>> getClasses() {
        return matches;
    }
    /**
     * Returns the classloaders that will be used for scanning for classes. If no
     * explicit ClassLoader has been set by the calling, the context class
     * loader will and the one that has loaded this class ResolverUtil be used.
     *
     * @return the ClassLoader instances that will be used to scan for classes
     */
    public Set<ClassLoader> getClassLoaders() {
        if (classLoaders == null) {
            classLoaders = new HashSet<ClassLoader>();
            classLoaders.add(Thread.currentThread().getContextClassLoader());
            classLoaders.add(ResolverUtil.class.getClassLoader());
        }
        return classLoaders;
    }
    /**
     * Sets the ClassLoader instances that should be used when scanning for
     * classes. If none is set then the context classloader will be used.
     *
     * @param classLoaders a ClassLoader to use when scanning for classes
     */
    public void setClassLoaders(Set<ClassLoader> classLoaders) {
        this.classLoaders = classLoaders;
    }
    /**
     * Attempts to discover classes that are assignable to the type provided. In
     * the case that an interface is provided this method will collect
     * implementations. In the case of a non-interface class, subclasses will be
     * collected. Accumulated classes can be accessed by calling
     * {@link #getClasses()}.
     *
     * @param parent       the class of interface to find subclasses or
     *                     implementations of
     * @param packageNames one or more package names to scan (including
     *                     subpackages) for classes
     */
    public void findImplementations(Class parent, String... packageNames) {
        if (packageNames == null) {
            return;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Searching for implementations of "" + parent.getName() + "" in packages: "" + Arrays
                .asList(packageNames));
        }
        Test test = new IsA(parent);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found: "" + getClasses());
        }
    }
    /**
     * Attempts to discover classes that are annotated with to the annotation.
     * Accumulated classes can be accessed by calling {@link #getClasses()}.
     *
     * @param annotation   the annotation that should be present on matching
     *                     classes
     * @param packageNames one or more package names to scan (including
     *                     subpackages) for classes
     */
    public void findAnnotated(Class<? extends Annotation> annotation, String... packageNames) {
        if (packageNames == null) {
            return;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Searching for annotations of "" + annotation.getName() + "" in packages: "" + Arrays
                .asList(packageNames));
        }
        Test test = new AnnotatedWith(annotation);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found: "" + getClasses());
        }
    }
    /**
     * Scans for classes starting at the package provided and descending into
     * subpackages. Each class is offered up to the Test as it is discovered,
     * and if the Test returns true the class is retained. Accumulated classes
     * can be fetched by calling {@link #getClasses()}.
     *
     * @param test        an instance of {@link Test} that will be used to filter
     *                    classes
     * @param packageName the name of the package from which to start scanning
     *                    for classes, e.g. {@code net.sourceforge.stripes}
     */
    public void find(Test test, String packageName) {
        packageName = packageName.replace('.', '/');
        Set<ClassLoader> set = getClassLoaders();
        for (ClassLoader classLoader : set) {
            find(test, packageName, classLoader);
        }
    }
    protected void find(Test test, String packageName, ClassLoader loader) {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Searching for: "" + test + "" in package: "" + packageName + "" using classloader: ""
                    + loader.getClass().getName());
        }
        if (loader.getClass().getName().endsWith(
                ""org.apache.felix.framework.searchpolicy.ContentClassLoader"")) {
            LOG.trace(""This is not an URL classloader, skipping"");
            //this classloader is in OSGI env which is not URLClassloader, we should resort to the
            //BundleDelegatingClassLoader in OSGI, so just return
            return;
        }
        try {
            Method mth = loader.getClass().getMethod(""getBundle"", new Class[] {});
            if (mth != null) {
                // it's osgi bundle class loader, so we need to load implementation in bundles
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Loading from osgi buindle using classloader: "" + loader);
                }
                loadImplementationsInBundle(test, packageName, loader, mth);
                return;
            }
        } catch (NoSuchMethodException e) {
            LOG.trace(""It's not an osgi bundle classloader"");
        }
        Enumeration<URL> urls;
        try {
            urls = getResources(loader, packageName);
            if (!urls.hasMoreElements()) {
                LOG.trace(""No URLs returned by classloader"");
            }
        } catch (IOException ioe) {
            LOG.warn(""Could not read package: "" + packageName, ioe);
            return;
        }
        while (urls.hasMoreElements()) {
            URL url = null;
            try {
                url = urls.nextElement();
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""URL from classloader: "" + url);
                }
                String urlPath = url.getFile();
                urlPath = URLDecoder.decode(urlPath, ""UTF-8"");
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Decoded urlPath: "" + urlPath);
                }
                // If it's a file in a directory, trim the stupid file: spec
                if (urlPath.startsWith(""file:"")) {
                    urlPath = urlPath.substring(5);
                }
                // osgi bundles should be skipped
                if (urlPath.startsWith(""bundle:"")) {
                    LOG.trace(""It's a virtual osgi bundle, skipping"");
                    continue;
                }
                // Else it's in a JAR, grab the path to the jar
                if (urlPath.indexOf('!') > 0) {
                    urlPath = urlPath.substring(0, urlPath.indexOf('!'));
                }
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Scanning for classes in ["" + urlPath + ""] matching criteria: "" + test);
                }
                File file = new File(urlPath);
                if (file.isDirectory()) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Loading from directory: "" + file);
                    }
                    loadImplementationsInDirectory(test, packageName, file);
                } else {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Loading from jar: "" + file);
                    }
                    loadImplementationsInJar(test, packageName, file);
                }
            } catch (IOException ioe) {
                LOG.warn(""Could not read entries in url: "" + url, ioe);
            }
        }
    }
    /**
     * Strategy to get the resources by the given classloader.
     * <p/>
     * Notice that in WebSphere platforms there is a {@link org.apache.camel.util.WebSphereResolverUtil}
     * to take care of WebSphere's odditiy of resource loading.
     *
     * @param loader  the classloader
     * @param packageName   the packagename for the package to load
     * @return  URL's for the given package
     * @throws IOException is thrown by the classloader
     */
    protected Enumeration<URL> getResources(ClassLoader loader, String packageName) throws IOException {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Getting resource URL for package: "" + packageName + "" with classloader: "" + loader);
        }
        return loader.getResources(packageName);
    }
    private void loadImplementationsInBundle(Test test, String packageName, ClassLoader loader, Method mth) {
        // Use an inner class to avoid a NoClassDefFoundError when used in a non-osgi env
        Set<String> urls = OsgiUtil.getImplementationsInBundle(test, packageName, loader, mth);
        if (urls != null) {
            for (String url : urls) {
                // substring to avoid leading slashes
                addIfMatching(test, url);
            }
        }
    }
    private static final class OsgiUtil {
        private OsgiUtil() {
            // Helper class
        }
        static Set<String> getImplementationsInBundle(Test test, String packageName, ClassLoader loader, Method mth) {
            try {
                org.osgi.framework.Bundle bundle = (org.osgi.framework.Bundle) mth.invoke(loader);
                org.osgi.framework.Bundle[] bundles = bundle.getBundleContext().getBundles();
                Set<String> urls = new HashSet<String>();
                for (org.osgi.framework.Bundle bd : bundles) {
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Searching in bundle:"" + bd);
                    }
                    Enumeration<URL> paths = bd.findEntries(""/"" + packageName, ""*.class"", true);
                    while (paths != null && paths.hasMoreElements()) {
                        URL path = paths.nextElement();
                        urls.add(path.getPath().substring(1));
                    }
                }
                return urls;
            } catch (Throwable t) {
                LOG.error(""Could not search osgi bundles for classes matching criteria: "" + test
                          + ""due to an Exception: "" + t.getMessage());
                return null;
            }
        }
    }
    /**
     * Finds matches in a physical directory on a filesystem. Examines all files
     * within a directory - if the File object is not a directory, and ends with
     * <i>.class</i> the file is loaded and tested to see if it is acceptable
     * according to the Test. Operates recursively to find classes within a
     * folder structure matching the package structure.
     *
     * @param test     a Test used to filter the classes that are discovered
     * @param parent   the package name up to this directory in the package
     *                 hierarchy. E.g. if /classes is in the classpath and we wish to
     *                 examine files in /classes/org/apache then the values of
     *                 <i>parent</i> would be <i>org/apache</i>
     * @param location a File object representing a directory
     */
    private void loadImplementationsInDirectory(Test test, String parent, File location) {
        File[] files = location.listFiles();
        StringBuilder builder = null;
        for (File file : files) {
            builder = new StringBuilder(100);
            String name = file.getName();
            if (name != null) {
                name = name.trim();
                builder.append(parent).append(""/"").append(name);
                String packageOrClass = parent == null ? name : builder.toString();
                if (file.isDirectory()) {
                    loadImplementationsInDirectory(test, packageOrClass, file);
                } else if (name.endsWith("".class"")) {
                    addIfMatching(test, packageOrClass);
                }
            }
        }
    }
    /**
     * Finds matching classes within a jar files that contains a folder
     * structure matching the package structure. If the File is not a JarFile or
     * does not exist a warning will be logged, but no error will be raised.
     *
     * @param test    a Test used to filter the classes that are discovered
     * @param parent  the parent package under which classes must be in order to
     *                be considered
     * @param jarfile the jar file to be examined for classes
     */
    private void loadImplementationsInJar(Test test, String parent, File jarfile) {
        JarInputStream jarStream = null;
        try {
            jarStream = new JarInputStream(new FileInputStream(jarfile));
            JarEntry entry;
            while ((entry = jarStream.getNextJarEntry()) != null) {
                String name = entry.getName();
                if (name != null) {
                    name = name.trim();
                    if (!entry.isDirectory() && name.startsWith(parent) && name.endsWith("".class"")) {
                        addIfMatching(test, name);
                    }
                }
            }
        } catch (IOException ioe) {
            LOG.error(""Could not search jar file '"" + jarfile + ""' for classes matching criteria: "" + test
                + "" due to an IOException: "" + ioe.getMessage(), ioe);
        } finally {
            ObjectHelper.close(jarStream, jarfile.getPath(), LOG);
        }
    }
    /**
     * Add the class designated by the fully qualified class name provided to
     * the set of resolved classes if and only if it is approved by the Test
     * supplied.
     *
     * @param test the test used to determine if the class matches
     * @param fqn  the fully qualified name of a class
     */
    protected void addIfMatching(Test test, String fqn) {
        try {
            String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
            Set<ClassLoader> set = getClassLoaders();
            boolean found = false;
            for (ClassLoader classLoader : set) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Testing for class "" + externalName + "" matches criteria ["" + test + ""]"");
                }
                try {
                    Class type = classLoader.loadClass(externalName);
                    if (test.matches(type)) {
                        if (LOG.isTraceEnabled()) {
                            LOG.trace(""Found class: "" + type + "" in classloader: "" + classLoader);
                        }
                        matches.add((Class<T>)type);
                    }
                    found = true;
                    break;
                } catch (ClassNotFoundException e) {
                    LOG.debug(""Could not find class '"" + fqn + ""' in classloader: "" + classLoader
                        + "". Reason: "" + e, e);
                } catch (NoClassDefFoundError e) {
                    LOG.debug(""Could not find the class defintion '"" + fqn + ""' in classloader: "" + classLoader
                              + "". Reason: "" + e, e);
                }
            }
            if (!found) {
                LOG.warn(""Could not find class '"" + fqn + ""' in any classloaders: "" + set);
            }
        } catch (Throwable t) {
            LOG.warn(""Could not examine class '"" + fqn + ""' due to a "" + t.getClass().getName()
                + "" with message: "" + t.getMessage(), t);
        }
    }
}
"
org.apache.camel.util.ServiceHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Collection;
import org.apache.camel.Service;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A collection of helper methods for working with {@link Service} objects
 *
 * @version $Revision: 640438 $
 */
public final class ServiceHelper {
    private static final transient Log LOG = LogFactory.getLog(ServiceHelper.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private ServiceHelper() {
    }
    public static void startService(Object value) throws Exception {
        if (value instanceof Service) {
            Service service = (Service)value;
            service.start();
        } else if (value instanceof Collection) {
            startServices((Collection)value);
        }
    }
    /**
     * Starts all of the given services
     */
    public static void startServices(Object... services) throws Exception {
        for (Object value : services) {
            startService(value);
        }
    }
    /**
     * Starts all of the given services
     */
    public static void startServices(Collection services) throws Exception {
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                service.start();
            }
        }
    }
    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Object... services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                try {
                    service.stop();
                } catch (Exception e) {
                    LOG.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
    public static void stopService(Object value) throws Exception {
        if (value instanceof Service) {
            Service service = (Service)value;
            service.stop();
        } else if (value instanceof Collection) {
            stopServices((Collection)value);
        }
    }
    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Collection services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                try {
                    service.stop();
                } catch (Exception e) {
                    LOG.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
}
"
org.apache.camel.util.SystemHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A helper class for various {@link System} related methods
 *
 * @version $Revision: 673954 $
 */
public final class SystemHelper {
    private static final transient Log LOG = LogFactory.getLog(SystemHelper.class);
    private SystemHelper() {
        // Helper class
    }
    /**
     * Looks up the given system property name returning null if any exceptions occur
     */
    public static String getSystemProperty(String name) {
        try {
            return System.getProperty(name);
        } catch (Exception e) {
            LOG.debug(""Caught exception looking for system property: "" + name + "" exception: "" + e, e);
            return null;
        }
    }
    /**
     * Looks up the given system property boolean value. Returns false if the system property doesn't exist.
     */
    public static boolean isSystemProperty(String name) {
        String text = getSystemProperty(name);
        return ObjectConverter.toBool(text);
    }
}
"
org.apache.camel.util.Time,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Date;
import java.util.concurrent.TimeUnit;
/**
 * A helper class for working with times in various units
 * 
 * @version $Revision: 630591 $
 */
public class Time {
    private long number;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    public Time(long number, TimeUnit timeUnit) {
        this.number = number;
        this.timeUnit = timeUnit;
    }
    public static Time millis(long value) {
        return new Time(value, TimeUnit.MILLISECONDS);
    }
    public static Time micros(long value) {
        return new Time(value, TimeUnit.MICROSECONDS);
    }
    public static Time nanos(long value) {
        return new Time(value, TimeUnit.NANOSECONDS);
    }
    public static Time seconds(long value) {
        return new Time(value, TimeUnit.SECONDS);
    }
    public static Time minutes(long value) {
        return new Time(minutesAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public static Time hours(long value) {
        return new Time(hoursAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public static Time days(long value) {
        return new Time(daysAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public long toMillis() {
        return timeUnit.toMillis(number);
    }
    public Date toDate() {
        return new Date(toMillis());
    }
    public long getNumber() {
        return number;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    protected static long minutesAsSeconds(long value) {
        return value * 60;
    }
    protected static long hoursAsSeconds(long value) {
        return minutesAsSeconds(value) * 60;
    }
    protected static long daysAsSeconds(long value) {
        return hoursAsSeconds(value) * 24;
    }
}
"
org.apache.camel.util.TimeoutMap,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
/**
 * Represents a thread safe map of values which timeout after a period of
 * inactivity.
 *
 * @version $Revision: 659798 $
 */
public interface TimeoutMap extends Runnable {
    /**
     * Looks up the value in the map by the given key.
     *
     * @param key the key of the value to search for
     * @return the value for the given key or null if it is not present (or has timed out)
     */
    Object get(Object key);
    /**
     * Returns a copy of the keys in the map
     */
    Object[] getKeys();
    /**
     * Returns the size of the map
     */
    int size();
    /**
     * Adds the key value pair into the map such that some time after the given
     * timeout the entry will be evicted
     */
    void put(Object key, Object value, long timeoutMillis);
    /**
     * Removes the object with the given key
     *
     * @param key  key for the object to remove
     */
    void remove(Object key);
    /**
     * Purges any old entries from the map
     */
    void purge();
}
"
org.apache.camel.util.TimeoutMapEntry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Map;
/**
 * Represents an entry in a {@link TimeoutMap}
 *
 * @version $Revision: 640438 $
 */
public class TimeoutMapEntry implements Comparable, Map.Entry {
    private Object key;
    private Object value;
    private long timeout;
    private long expireTime;
    public TimeoutMapEntry(Object id, Object handler, long timeout) {
        this.key = id;
        this.value = handler;
        this.timeout = timeout;
    }
    public Object getKey() {
        return key;
    }
    public long getExpireTime() {
        return expireTime;
    }
    public void setExpireTime(long expireTime) {
        this.expireTime = expireTime;
    }
    public Object getValue() {
        return value;
    }
    public Object setValue(Object value) {
        Object oldValue = value;
        this.value = value;
        return oldValue;
    }
    public long getTimeout() {
        return timeout;
    }
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    public int compareTo(Object that) {
        if (this == that) {
            return 0;
        }
        if (that instanceof TimeoutMapEntry) {
            return compareTo((TimeoutMapEntry) that);
        }
        return 1;
    }
    public int compareTo(TimeoutMapEntry that) {
        long diff = this.expireTime - that.expireTime;
        if (diff > 0) {
            return 1;
        } else if (diff < 0) {
            return -1;
        }
        return this.key.hashCode() - that.key.hashCode();
    }
    public String toString() {
        return ""Entry for key: "" + key;
    }
}
"
org.apache.camel.util.UnsafeCharactersEncoderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import junit.framework.TestCase;
public class UnsafeCharactersEncoderTest extends TestCase {
    public void testQnameEncoder() {
        String afterEncoding = ""%7Bhttp://www.example.com/test%7DServiceName"";
        String beforeEncoding = ""{http://www.example.com/test}ServiceName"";
        String result = UnsafeUriCharactersEncoder.encode(beforeEncoding);
        assertEquals(""Get the wrong encoding result"", result, afterEncoding);
    }
    public void testNoEncoding() {
        String noEncoding = ""http://www.example.com"";
        String result = UnsafeUriCharactersEncoder.encode(noEncoding);
        assertEquals(""Get the wrong encoding result"", result, noEncoding);
    }
}
"
org.apache.camel.util.UnsafeUriCharactersEncoder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.UnsupportedEncodingException;
import java.util.BitSet;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Encoder for unsafe URI characters.
 */
public final class UnsafeUriCharactersEncoder {
    private static BitSet unsafeCharacters;
    private static final transient Log LOG = LogFactory.getLog(UnsafeUriCharactersEncoder.class);
    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',
                                              'D', 'E', 'F'};
    static {
        unsafeCharacters = new BitSet(256);
        unsafeCharacters.set(' ');
        unsafeCharacters.set('""');
        unsafeCharacters.set('<');
        unsafeCharacters.set('>');
        unsafeCharacters.set('#');
        unsafeCharacters.set('%');
        unsafeCharacters.set('{');
        unsafeCharacters.set('}');
        unsafeCharacters.set('|');
        unsafeCharacters.set('\\');
        unsafeCharacters.set('^');
        unsafeCharacters.set('~');
        unsafeCharacters.set('[');
        unsafeCharacters.set(']');
        unsafeCharacters.set('`');
    }
    private UnsafeUriCharactersEncoder() {
        // util class
    }
    public static String encode(String s) {
        int n = s.length();
        if (n == 0) {
            return s;
        }
        try {
            // First check whether we actually need to encode
            byte[] bytes = s.getBytes(""UTF8"");
            for (int i = 0;;) {
                if (unsafeCharacters.get(bytes[i])) {
                    break;
                }
                if (++i >= bytes.length) {
                    return s;
                }
            }
            // okay there are some unsafe characters so we do need to encode
            StringBuffer sb = new StringBuffer();
            for (byte b : bytes) {
                if (unsafeCharacters.get(b)) {
                    appendEscape(sb, b);
                } else {
                    sb.append((char)b);
                }
            }
            return sb.toString();
        } catch (UnsupportedEncodingException e) {
            LOG.error(""Can't encoding the uri: "", e);
            return null;
        }
    }
    private static void appendEscape(StringBuffer sb, byte b) {
        sb.append('%');
        sb.append(HEX_DIGITS[(b >> 4) & 0x0f]);
        sb.append(HEX_DIGITS[(b >> 0) & 0x0f]);
    }
}
"
org.apache.camel.util.URISupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
/**
 * URI utilities.
 *
 * @version $Revision: 663882 $
 */
public class URISupport {
    /**
     * Holder to get parts of the URI.
     */
    public static class CompositeData {
        public String host;
        String scheme;
        String path;
        URI components[];
        Map parameters;
        String fragment;
        public URI[] getComponents() {
            return components;
        }
        public String getFragment() {
            return fragment;
        }
        public Map getParameters() {
            return parameters;
        }
        public String getScheme() {
            return scheme;
        }
        public String getPath() {
            return path;
        }
        public String getHost() {
            return host;
        }
        public URI toURI() throws URISyntaxException {
            StringBuffer sb = new StringBuffer();
            if (scheme != null) {
                sb.append(scheme);
                sb.append(':');
            }
            if (host != null && host.length() != 0) {
                sb.append(host);
            } else {
                sb.append('(');
                for (int i = 0; i < components.length; i++) {
                    if (i != 0) {
                        sb.append(',');
                    }
                    sb.append(components[i].toString());
                }
                sb.append(')');
            }
            if (path != null) {
                sb.append('/');
                sb.append(path);
            }
            if (!parameters.isEmpty()) {
                sb.append(""?"");
                sb.append(createQueryString(parameters));
            }
            if (fragment != null) {
                sb.append(""#"");
                sb.append(fragment);
            }
            return new URI(sb.toString());
        }
    }
    public static Map parseQuery(String uri) throws URISyntaxException {
        try {
            Map rc = new HashMap();
            if (uri != null) {
                String[] parameters = uri.split(""&"");
                for (String parameter : parameters) {
                    int p = parameter.indexOf(""="");
                    if (p >= 0) {
                        String name = URLDecoder.decode(parameter.substring(0, p), ""UTF-8"");
                        String value = URLDecoder.decode(parameter.substring(p + 1), ""UTF-8"");
                        rc.put(name, value);
                    } else {
                        rc.put(parameter, null);
                    }
                }
            }
            return rc;
        } catch (UnsupportedEncodingException e) {
            throw (URISyntaxException)new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }
    public static Map parseParameters(URI uri) throws URISyntaxException {
        String query = uri.getQuery();
        if (query == null) {
            String schemeSpecificPart = uri.getSchemeSpecificPart();
            int idx = schemeSpecificPart.lastIndexOf('?');
            if (idx < 0) {
                return Collections.EMPTY_MAP;
            } else {
                query = schemeSpecificPart.substring(idx + 1);
            }
        } else {
            query = stripPrefix(query, ""?"");
        }
        return parseQuery(query);
    }
    /**
     * Removes any URI query from the given uri
     */
    public static URI removeQuery(URI uri) throws URISyntaxException {
        return createURIWithQuery(uri, null);
    }
    /**
     * Creates a URI with the given query
     */
    public static URI createURIWithQuery(URI uri, String query) throws URISyntaxException {
        return new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(),
                       query, uri.getFragment());
    }
    public static CompositeData parseComposite(URI uri) throws URISyntaxException {
        CompositeData rc = new CompositeData();
        rc.scheme = uri.getScheme();
        String ssp = stripPrefix(uri.getSchemeSpecificPart().trim(), ""//"").trim();
        parseComposite(uri, rc, ssp);
        rc.fragment = uri.getFragment();
        return rc;
    }
    private static void parseComposite(URI uri, CompositeData rc, String ssp) throws URISyntaxException {
        String componentString;
        String params;
        if (!checkParenthesis(ssp)) {
            throw new URISyntaxException(uri.toString(), ""Not a matching number of '(' and ')' parenthesis"");
        }
        int p;
        int intialParen = ssp.indexOf(""("");
        if (intialParen == 0) {
            rc.host = ssp.substring(0, intialParen);
            p = rc.host.indexOf(""/"");
            if (p >= 0) {
                rc.path = rc.host.substring(p);
                rc.host = rc.host.substring(0, p);
            }
            p = ssp.lastIndexOf("")"");
            componentString = ssp.substring(intialParen + 1, p);
            params = ssp.substring(p + 1).trim();
        } else {
            componentString = ssp;
            params = """";
        }
        String components[] = splitComponents(componentString);
        rc.components = new URI[components.length];
        for (int i = 0; i < components.length; i++) {
            rc.components[i] = new URI(components[i].trim());
        }
        p = params.indexOf(""?"");
        if (p >= 0) {
            if (p > 0) {
                rc.path = stripPrefix(params.substring(0, p), ""/"");
            }
            rc.parameters = parseQuery(params.substring(p + 1));
        } else {
            if (params.length() > 0) {
                rc.path = stripPrefix(params, ""/"");
            }
            rc.parameters = Collections.EMPTY_MAP;
        }
    }
    private static String[] splitComponents(String str) {
        ArrayList l = new ArrayList();
        int last = 0;
        int depth = 0;
        char chars[] = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            switch (chars[i]) {
            case '(':
                depth++;
                break;
            case ')':
                depth--;
                break;
            case ',':
                if (depth == 0) {
                    String s = str.substring(last, i);
                    l.add(s);
                    last = i + 1;
                }
                break;
            default:
            }
        }
        String s = str.substring(last);
        if (s.length() != 0) {
            l.add(s);
        }
        String rc[] = new String[l.size()];
        l.toArray(rc);
        return rc;
    }
    public static String stripPrefix(String value, String prefix) {
        if (value.startsWith(prefix)) {
            return value.substring(prefix.length());
        }
        return value;
    }
    public static URI stripScheme(URI uri) throws URISyntaxException {
        return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), ""//""));
    }
    public static String createQueryString(Map options) throws URISyntaxException {
        try {
            if (options.size() > 0) {
                StringBuffer rc = new StringBuffer();
                boolean first = true;
                for (Iterator iter = options.keySet().iterator(); iter.hasNext();) {
                    if (first) {
                        first = false;
                    } else {
                        rc.append(""&"");
                    }
                    String key = (String)iter.next();
                    String value = (String)options.get(key);
                    rc.append(URLEncoder.encode(key, ""UTF-8""));
                    rc.append(""="");
                    rc.append(URLEncoder.encode(value, ""UTF-8""));
                }
                return rc.toString();
            } else {
                return """";
            }
        } catch (UnsupportedEncodingException e) {
            throw (URISyntaxException)new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }
    /**
     * Creates a URI from the original URI and the remaining parameters
     */
    public static URI createRemainingURI(URI originalURI, Map params) throws URISyntaxException {
        String s = createQueryString(params);
        if (s.length() == 0) {
            s = null;
        }
        return createURIWithQuery(originalURI, s);
    }
    public static URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException {
        return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr
            .getPath(), bindAddr.getQuery(), bindAddr.getFragment());
    }
    public static boolean checkParenthesis(String str) {
        boolean result = true;
        if (str != null) {
            int open = 0;
            int closed = 0;
            int i = 0;
            while ((i = str.indexOf('(', i)) >= 0) {
                i++;
                open++;
            }
            i = 0;
            while ((i = str.indexOf(')', i)) >= 0) {
                i++;
                closed++;
            }
            result = open == closed;
        }
        return result;
    }
    /**
     * @deprecated this method will be removed in Camel 2.0.
     */
    @Deprecated
    public int indexOfParenthesisMatch(String str) {
        int result = -1;
        return result;
    }
}
"
org.apache.camel.util.UuidGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.util.logging.Level;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Generator for Globally unique Strings.
 */
public class UuidGenerator {
    private static final transient Log LOG = LogFactory.getLog(UuidGenerator.class); 
    private static final String UNIQUE_STUB;
    private static int instanceCount;
    private static String hostName;
    private String seed;
    private long sequence;
    static {
        String stub = """";
        boolean canAccessSystemProps = true;
        try {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPropertiesAccess();
            }
        } catch (SecurityException se) {
            canAccessSystemProps = false;
        }
        if (canAccessSystemProps) {
            try {
                hostName = InetAddress.getLocalHost().getHostName();
                ServerSocket ss = new ServerSocket(0);
                stub = ""/"" + ss.getLocalPort() + ""-"" + System.currentTimeMillis() + ""/"";
                Thread.sleep(100);
                ss.close();
            } catch (Exception ioe) {
                LOG.warn(""Could not generate unique stub"", ioe);
            }
        } else {
            hostName = ""localhost"";
            stub = ""-1-"" + System.currentTimeMillis() + ""-"";
        }
        UNIQUE_STUB = stub;
    }
    public UuidGenerator(String prefix) {
        synchronized (UNIQUE_STUB) {
            this.seed = prefix + UNIQUE_STUB + (instanceCount++) + ""-"";
        }
    }
    public UuidGenerator() {
        this(""ID-"" + hostName);
    }
    /**
     * As we have to find the hostname as a side-affect of generating a unique
     * stub, we allow it's easy retrevial here
     * 
     * @return the local host name
     */
    public static String getHostName() {
        return hostName;
    }
    /**
     * Generate a unqiue id
     */
    public synchronized String generateId() {
        return this.seed + (this.sequence++);
    }
    /**
     * Generate a unique ID - that is friendly for a URL or file system
     * 
     * @return a unique id
     */
    public String generateSanitizedId() {
        return generateSanitizedId(generateId());
    }
    /**
     * Ensures that the id is friendly for a URL or file system
     *
     * @param id the unique id
     * @return the id as file friendly id
     */
    public static String generateSanitizedId(String id) {
        id = id.replace(':', '-');
        id = id.replace('_', '-');
        id = id.replace('.', '-');
        return id;
    }
}
"
org.apache.camel.util.UuidGeneratorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import junit.framework.TestCase;
/**
 * Unit test for UuidGenerator
 */
public class UuidGeneratorTest extends TestCase {
    private UuidGenerator generator;
    protected void setUp() throws Exception {
        generator = new UuidGenerator(""unittest"");
    }
    public void testUniqueId() {
        assertNotSame(""Should generate unique ids"", generator.generateId(), generator.generateId());
    }
    public void testSimpleSanitizedId() {
        String out = UuidGenerator.generateSanitizedId(""hello"");
        assertTrue(""Should not contain : "", out.indexOf(':') == -1);
        assertTrue(""Should not contain . "", out.indexOf('.') == -1);
    }
    public void testNotFileFriendlySimpleSanitizedId() {
        String out = UuidGenerator.generateSanitizedId(""c:\\helloworld"");
        assertTrue(""Should not contain : "", out.indexOf(':') == -1);
        assertTrue(""Should not contain . "", out.indexOf('.') == -1);
    }
}
"
org.apache.camel.util.ValueHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
/**
 * Holder object for a given value.
 */
public class ValueHolder<V> {
    private V value;
    public ValueHolder() {
    }
    public ValueHolder(V val) {
        value = val;
    }
    public V get() {
        return value;
    }
    public void set(V val) {
        value = val;
    }
}
"
org.apache.camel.util.WebSphereResolverUtil,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
import java.net.URL;
import java.util.Enumeration;
/**
 * WebSphere specific resolver util to handle loading annotated resources in JAR files.
 */
public class WebSphereResolverUtil extends ResolverUtil {
    private String resourcePath;
    /**
     * Constructor.
     *
     * @param resourcePath  the fixed resource path to use for fetching camel jars in WebSphere.
     */
    public WebSphereResolverUtil(String resourcePath) {
        this.resourcePath = resourcePath;
    }
    /**
     * Is the classloader from IBM and thus the WebSphere platform?
     *
     * @param loader  the classloader
     * @return  <tt>true</tt> if IBM classloader, <tt>false</tt> otherwise.
     */
    public static boolean isWebSphereClassLoader(ClassLoader loader) {
        return loader.getClass().getName().startsWith(""com.ibm"");
    }
    /**
     * Overloaded to handle specific problem with getting resources on the IBM WebSphere platform.
     * <p/>
     * WebSphere can <b>not</b> load resources if the resource to load is a folder name, such as a
     * packagename, you have to explicit name a resource that is a file.
     *
     * @param loader  the classloader
     * @param packageName   the packagename for the package to load
     * @return  URL's for the given package
     * @throws IOException is thrown by the classloader
     */
    @Override
    protected Enumeration<URL> getResources(ClassLoader loader, String packageName) throws IOException {
        // try super first, just in vase
        Enumeration<URL> enumeration = super.getResources(loader, packageName);
        if (!enumeration.hasMoreElements()) {
            LOG.trace(""Using WebSphere workaround to load the camel jars with the annotated converters."");
            // Special WebSphere trick to load a file that exists in the JAR and then let it go from there.
            // The trick is that we just need the URL's for the .jars that contains the type
            // converters that is annotated. So by searching for this resource WebSphere is able to find
            // it and return the URL to the .jar file with the resource. Then the default ResolverUtil
            // can take it from there and find the classes that are annotated.
            enumeration = loader.getResources(resourcePath);
        }
        return enumeration;
    }
}
"
org.apache.camel.util.jndi.CamelInitialContextFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.util.Hashtable;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.naming.spi.InitialContextFactory;
/**
 * A factory of the Camel InitialContext which allows a Map to be used to create a
 * JNDI context.
 *
 * @version $Revision: 656978 $
 */
public class CamelInitialContextFactory implements InitialContextFactory {
    /**
     * Creates a new context with the given environment.
     *
     * @param  environment  the environment, must not be <tt>null</tt>
     * @return the created context.
     * @throws NamingException is thrown if creation failed.
     */
    public Context getInitialContext(Hashtable environment) throws NamingException {
        try {
            return new JndiContext(environment);
        } catch (NamingException e) {
            throw e;
        } catch (Exception e) {
            NamingException exception = new NamingException(e.getMessage());
            exception.initCause(e);
            throw exception;
        }
    }
}
"
org.apache.camel.util.jndi.ExampleBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
/**
 * @version $Revision: 630568 $
 */
public class ExampleBean {
    private String name;
    private double price;
    public String toString() {
        return ""ExampleBean[name: "" + name + "" price: "" + price + ""]"";
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public double getPrice() {
        return price;
    }
    public void setPrice(double price) {
        this.price = price;
    }
}
"
org.apache.camel.util.jndi.JndiContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import javax.naming.Binding;
import javax.naming.CompositeName;
import javax.naming.Context;
import javax.naming.LinkRef;
import javax.naming.Name;
import javax.naming.NameClassPair;
import javax.naming.NameNotFoundException;
import javax.naming.NameParser;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.NotContextException;
import javax.naming.OperationNotSupportedException;
import javax.naming.Reference;
import javax.naming.spi.NamingManager;
import org.apache.camel.spi.Injector;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ReflectionInjector;
/**
 * A default JNDI context
 *
 * @version $Revision: 659638 $ $Date: 2008-05-23 15:37:19 -0400 (Fri, 23 May 2008) $
 */
public class JndiContext implements Context, Serializable {
    public static final String SEPARATOR = ""/"";
    protected static final NameParser NAME_PARSER = new NameParser() {
        public Name parse(String name) throws NamingException {
            return new CompositeName(name);
        }
    };
    protected static final Injector INJETOR = new ReflectionInjector();
    private static final long serialVersionUID = -5754338187296859149L;
    private final Hashtable environment; // environment for this context
    private final Map bindings; // bindings at my level
    private final Map treeBindings; // all bindings under me
    private boolean frozen;
    private String nameInNamespace = """";
    public JndiContext() throws Exception {
        this(new Hashtable());
    }
    public JndiContext(Hashtable env) throws Exception {
        this(env, createBindingsMapFromEnvironment(env));
    }
    public JndiContext(Hashtable environment, Map bindings) {
        if (environment == null) {
            this.environment = new Hashtable();
        } else {
            this.environment = new Hashtable(environment);
        }
        this.bindings = bindings;
        treeBindings = new HashMap();
    }
    public JndiContext(Hashtable environment, Map bindings, String nameInNamespace) {
        this(environment, bindings);
        this.nameInNamespace = nameInNamespace;
    }
    protected JndiContext(JndiContext clone, Hashtable env) {
        this.bindings = clone.bindings;
        this.treeBindings = clone.treeBindings;
        this.environment = new Hashtable(env);
    }
    protected JndiContext(JndiContext clone, Hashtable env, String nameInNamespace) {
        this(clone, env);
        this.nameInNamespace = nameInNamespace;
    }
    /**
     * A helper method to create the JNDI bindings from the input environment
     * properties using $foo.class to point to a class name with $foo.* being
     * properties set on the injected bean
     */
    public static Map createBindingsMapFromEnvironment(Hashtable env) throws Exception {
        Map answer = new HashMap(env);
        for (Object object : env.entrySet()) {
            Map.Entry entry = (Map.Entry)object;
            Object key = entry.getKey();
            Object value = entry.getValue();
            if (key instanceof String && value instanceof String) {
                String keyText = (String)key;
                String valueText = (String)value;
                if (keyText.endsWith("".class"")) {
                    Class<?> type = ObjectHelper.loadClass(valueText);
                    if (type != null) {
                        String newEntry = keyText.substring(0, keyText.length() - "".class"".length());
                        Object bean = createBean(type, answer, newEntry + ""."");
                        if (bean != null) {
                            answer.put(newEntry, bean);
                        }
                    }
                }
            }
        }
        return answer;
    }
    public void freeze() {
        frozen = true;
    }
    boolean isFrozen() {
        return frozen;
    }
    /**
     * internalBind is intended for use only during setup or possibly by
     * suitably synchronized superclasses. It binds every possible lookup into a
     * map in each context. To do this, each context strips off one name segment
     * and if necessary creates a new context for it. Then it asks that context
     * to bind the remaining name. It returns a map containing all the bindings
     * from the next context, plus the context it just created (if it in fact
     * created it). (the names are suitably extended by the segment originally
     * lopped off).
     */
    protected Map internalBind(String name, Object value) throws NamingException {
        assert name != null && name.length() > 0;
        assert !frozen;
        Map newBindings = new HashMap();
        int pos = name.indexOf('/');
        if (pos == -1) {
            if (treeBindings.put(name, value) != null) {
                throw new NamingException(""Something already bound at "" + name);
            }
            bindings.put(name, value);
            newBindings.put(name, value);
        } else {
            String segment = name.substring(0, pos);
            assert segment != null;
            assert !segment.equals("""");
            Object o = treeBindings.get(segment);
            if (o == null) {
                o = newContext();
                treeBindings.put(segment, o);
                bindings.put(segment, o);
                newBindings.put(segment, o);
            } else if (!(o instanceof JndiContext)) {
                throw new NamingException(""Something already bound where a subcontext should go"");
            }
            JndiContext defaultContext = (JndiContext)o;
            String remainder = name.substring(pos + 1);
            Map subBindings = defaultContext.internalBind(remainder, value);
            for (Iterator iterator = subBindings.entrySet().iterator(); iterator.hasNext();) {
                Map.Entry entry = (Map.Entry)iterator.next();
                String subName = segment + ""/"" + (String)entry.getKey();
                Object bound = entry.getValue();
                treeBindings.put(subName, bound);
                newBindings.put(subName, bound);
            }
        }
        return newBindings;
    }
    protected JndiContext newContext() {
        try {
            return new JndiContext();
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }
    public Object addToEnvironment(String propName, Object propVal) throws NamingException {
        return environment.put(propName, propVal);
    }
    public Hashtable getEnvironment() throws NamingException {
        return (Hashtable)environment.clone();
    }
    public Object removeFromEnvironment(String propName) throws NamingException {
        return environment.remove(propName);
    }
    public Object lookup(String name) throws NamingException {
        if (name.length() == 0) {
            return this;
        }
        Object result = treeBindings.get(name);
        if (result == null) {
            result = bindings.get(name);
        }
        if (result == null) {
            int pos = name.indexOf(':');
            if (pos > 0) {
                String scheme = name.substring(0, pos);
                Context ctx = NamingManager.getURLContext(scheme, environment);
                if (ctx == null) {
                    throw new NamingException(""scheme "" + scheme + "" not recognized"");
                }
                return ctx.lookup(name);
            } else {
                // Split out the first name of the path
                // and look for it in the bindings map.
                CompositeName path = new CompositeName(name);
                if (path.size() == 0) {
                    return this;
                } else {
                    String first = path.get(0);
                    Object value = bindings.get(first);
                    if (value == null) {
                        throw new NameNotFoundException(name);
                    } else if (value instanceof Context && path.size() > 1) {
                        Context subContext = (Context)value;
                        value = subContext.lookup(path.getSuffix(1));
                    }
                    return value;
                }
            }
        }
        if (result instanceof LinkRef) {
            LinkRef ref = (LinkRef)result;
            result = lookup(ref.getLinkName());
        }
        if (result instanceof Reference) {
            try {
                result = NamingManager.getObjectInstance(result, null, null, this.environment);
            } catch (NamingException e) {
                throw e;
            } catch (Exception e) {
                throw (NamingException)new NamingException(""could not look up : "" + name).initCause(e);
            }
        }
        if (result instanceof JndiContext) {
            String prefix = getNameInNamespace();
            if (prefix.length() > 0) {
                prefix = prefix + SEPARATOR;
            }
            result = new JndiContext((JndiContext)result, environment, prefix + name);
        }
        return result;
    }
    public Object lookup(Name name) throws NamingException {
        return lookup(name.toString());
    }
    public Object lookupLink(String name) throws NamingException {
        return lookup(name);
    }
    public Name composeName(Name name, Name prefix) throws NamingException {
        Name result = (Name)prefix.clone();
        result.addAll(name);
        return result;
    }
    public String composeName(String name, String prefix) throws NamingException {
        CompositeName result = new CompositeName(prefix);
        result.addAll(new CompositeName(name));
        return result.toString();
    }
    public NamingEnumeration list(String name) throws NamingException {
        Object o = lookup(name);
        if (o == this) {
            return new ListEnumeration();
        } else if (o instanceof Context) {
            return ((Context)o).list("""");
        } else {
            throw new NotContextException();
        }
    }
    public NamingEnumeration listBindings(String name) throws NamingException {
        Object o = lookup(name);
        if (o == this) {
            return new ListBindingEnumeration();
        } else if (o instanceof Context) {
            return ((Context)o).listBindings("""");
        } else {
            throw new NotContextException();
        }
    }
    public Object lookupLink(Name name) throws NamingException {
        return lookupLink(name.toString());
    }
    public NamingEnumeration list(Name name) throws NamingException {
        return list(name.toString());
    }
    public NamingEnumeration listBindings(Name name) throws NamingException {
        return listBindings(name.toString());
    }
    public void bind(Name name, Object value) throws NamingException {
        bind(name.toString(), value);
    }
    public void bind(String name, Object value) throws NamingException {
        if (isFrozen()) {
            throw new OperationNotSupportedException();
        } else {
            internalBind(name, value);
        }
    }
    public void close() throws NamingException {
        // ignore
    }
    public Context createSubcontext(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public Context createSubcontext(String name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void destroySubcontext(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void destroySubcontext(String name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public String getNameInNamespace() throws NamingException {
        return nameInNamespace;
    }
    public NameParser getNameParser(Name name) throws NamingException {
        return NAME_PARSER;
    }
    public NameParser getNameParser(String name) throws NamingException {
        return NAME_PARSER;
    }
    public void rebind(Name name, Object value) throws NamingException {
        bind(name, value);
    }
    public void rebind(String name, Object value) throws NamingException {
        bind(name, value);
    }
    public void rename(Name oldName, Name newName) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void rename(String oldName, String newName) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void unbind(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void unbind(String name) throws NamingException {
        bindings.remove(name);
        treeBindings.remove(name);
    }
    private abstract class LocalNamingEnumeration implements NamingEnumeration {
        private Iterator i = bindings.entrySet().iterator();
        public boolean hasMore() throws NamingException {
            return i.hasNext();
        }
        public boolean hasMoreElements() {
            return i.hasNext();
        }
        protected Map.Entry getNext() {
            return (Map.Entry)i.next();
        }
        public void close() throws NamingException {
        }
    }
    private class ListEnumeration extends LocalNamingEnumeration {
        ListEnumeration() {
        }
        public Object next() throws NamingException {
            return nextElement();
        }
        public Object nextElement() {
            Map.Entry entry = getNext();
            return new NameClassPair((String)entry.getKey(), entry.getValue().getClass().getName());
        }
    }
    private class ListBindingEnumeration extends LocalNamingEnumeration {
        ListBindingEnumeration() {
        }
        public Object next() throws NamingException {
            return nextElement();
        }
        public Object nextElement() {
            Map.Entry entry = getNext();
            return new Binding((String)entry.getKey(), entry.getValue());
        }
    }
    protected static Object createBean(Class<?> type, Map properties, String prefix) throws Exception {
        Object value = INJETOR.newInstance(type);
        IntrospectionSupport.setProperties(value, properties, prefix);
        return value;
    }
}
"
org.apache.camel.util.jndi.JndiTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Properties;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.camel.TestSupport;
/**
 * @version $Revision: 630568 $
 */
public class JndiTest extends TestSupport {
    protected Context context;
    public static Context createInitialContext() throws Exception {
        InputStream in = JndiTest.class.getClassLoader().getResourceAsStream(""jndi-example.properties"");
        assertNotNull(""Cannot find jndi-example.properties on the classpath!"", in);
        Properties properties = new Properties();
        properties.load(in);
        return new InitialContext(new Hashtable(properties));
    }
    public void testLookupOfSimpleName() throws Exception {
        Object value = assertLookup(""foo"");
        assertEquals(""foo"", ""bar"", value);
    }
    public void testLookupOfTypedObject() throws Exception {
        Object value = assertLookup(""example"");
        ExampleBean bean = assertIsInstanceOf(ExampleBean.class, value);
        assertEquals(""Bean.name"", ""James"", bean.getName());
        assertEquals(""Bean.price"", 2.34, bean.getPrice());
        log.info(""Found bean: "" + bean);
    }
    protected Object assertLookup(String name) throws NamingException {
        Object value = context.lookup(name);
        assertNotNull(""Should have found JNDI entry: "" + name + "" in context: "" + context, value);
        return value;
    }
    protected void setUp() throws Exception {
        super.setUp();
        context = createInitialContext();
    }
}
"
org.apache.camel.view.DotViewTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.XPathBuilder;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 659842 $
 */
public class DotViewTest extends ContextTestSupport {
    protected String outputDirectory = ""target/site/cameldoc"";
    public void testGenerateFiles() throws Exception {
        RouteDotGenerator generator = new RouteDotGenerator(outputDirectory);
        generator.drawRoutes(context);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context.addRoutes(new MulticastRoute());
        context.addRoutes(new PipelineRoute());
        context.addRoutes(new ChoiceRoute());
        context.addRoutes(new FilterRoute());
        context.addRoutes(new ComplexRoute());
    }
    static class MulticastRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""seda:multicast.in"").
                    multicast().to(""seda:multicast.out1"", ""seda:multicast.out2"", ""seda:multicast.out3"");
        }
    }
    static class PipelineRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""seda:pipeline.in"").
                    to(""seda:pipeline.out1"", ""seda:pipeline.out2"", ""seda:pipeline.out3"");
        }
    }
    static class ChoiceRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:target/foo/xyz?noop=true"").
                choice().
                  when(xpath(""/person/city = 'London'"")).to(""file:target/messages/uk"").
                  otherwise().to(""file:target/messages/others"");
        }
    }
    static class FilterRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:target/foo/bar?noop=true"").filter(header(""foo"").isEqualTo(""bar""))
                .to(""file:target/xyz?noop=true"");
        }
    }
    static class ComplexRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:target/xyz?noop=true"").filter(header(""foo"").isEqualTo(""bar""))
                .recipientList(header(""bar"")).splitter(XPathBuilder.xpath(""/invoice/lineItems"")).throttler(3)
                .to(""mock:result"");
        }
    }
}
"
org.apache.camel.view.GraphGeneratorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.CamelContext;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.FromType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.ToType;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 640438 $
 */
public abstract class GraphGeneratorSupport {
    private static final transient Log LOG = LogFactory.getLog(RouteDotGenerator.class);
    protected String dir;
    protected int clusterCounter;
    protected String extension;
    //private String imagePrefix = ""http://www.enterpriseintegrationpatterns.com/img/"";
    private String imagePrefix = ""http://activemq.apache.org/camel/images/eip/"";
    private Map<Object, NodeData> nodeMap = new HashMap<Object, NodeData>();
    private boolean makeParentDirs = true;
    private Map<String, List<RouteType>> routeGroupMap;
    protected GraphGeneratorSupport(String dir, String extension) {
        this.dir = dir;
        this.extension = extension;
    }
    public String getDir() {
        return dir;
    }
    /**
     * Sets the destination directory in which to create the diagrams
     */
    public void setDir(String dir) {
        this.dir = dir;
    }
    public void drawRoutes(CamelContext context) throws IOException {
        File parent = new File(dir);
        if (makeParentDirs) {
            parent.mkdirs();
        }
        List<RouteType> routes = context.getRouteDefinitions();
        routeGroupMap = createRouteGroupMap(routes);
        // generate the global file
        generateFile(parent, ""routes"" + extension, routeGroupMap);
        if (routeGroupMap.size() >= 1) {
            Set<Map.Entry<String, List<RouteType>>> entries = routeGroupMap.entrySet();
            for (Map.Entry<String, List<RouteType>> entry : entries) {
                Map<String, List<RouteType>> map = new HashMap<String, List<RouteType>>();
                String group = entry.getKey();
                map.put(group, entry.getValue());
                // generate the file containing just the routes in this group
                generateFile(parent, group + extension, map);
            }
        }
    }
    private void generateFile(File parent, String fileName, Map<String, List<RouteType>> map) throws IOException {
        nodeMap.clear();
        clusterCounter = 0;
        PrintWriter writer = new PrintWriter(new FileWriter(new File(parent, fileName)));
        try {
            generateFile(writer, map);
        } finally {
            writer.close();
        }
    }
    protected abstract void generateFile(PrintWriter writer, Map<String, List<RouteType>> map);
    protected boolean isMulticastNode(ProcessorType node) {
        return node instanceof MulticastType || node instanceof ChoiceType;
    }
    protected String getLabel(List<ExpressionType> expressions) {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        for (ExpressionType expression : expressions) {
            buffer.append(getLabel(expression));
        }
        return buffer.toString();
    }
    protected String getLabel(ExpressionType expression) {
        if (expression != null) {
            return expression.getLabel();
        }
        return """";
    }
    protected NodeData getNodeData(Object node) {
        Object key = node;
        if (node instanceof FromType) {
            FromType fromType = (FromType)node;
            key = fromType.getUriOrRef();
        } else if (node instanceof ToType) {
            ToType toType = (ToType)node;
            key = toType.getUriOrRef();
        }
        NodeData answer = nodeMap.get(key);
        if (answer == null) {
            String id = ""node"" + (nodeMap.size() + 1);
            answer = new NodeData(id, node, imagePrefix);
            nodeMap.put(key, answer);
        }
        return answer;
    }
    protected Map<String, List<RouteType>> createRouteGroupMap(List<RouteType> routes) {
        Map<String, List<RouteType>> map = new HashMap<String, List<RouteType>>();
        for (RouteType route : routes) {
            String group = route.getGroup();
            if (group == null) {
                group = ""Camel Routes"";
            }
            List<RouteType> list = map.get(group);
            if (list == null) {
                list = new ArrayList<RouteType>();
                map.put(group, list);
            }
            list.add(route);
        }
        return map;
    }
}
"
org.apache.camel.view.NodeData,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.model.AggregatorType;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.FilterType;
import org.apache.camel.model.FromType;
import org.apache.camel.model.OtherwiseType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RecipientListType;
import org.apache.camel.model.ResequencerType;
import org.apache.camel.model.RoutingSlipType;
import org.apache.camel.model.SplitterType;
import org.apache.camel.model.ToType;
import org.apache.camel.model.WhenType;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
/**
 * Represents a node in the EIP diagram tree
 *
 * @version $Revision: 660216 $
 */
public class NodeData {
    public String id;
    public String image;
    public String label;
    public String shape;
    public String edgeLabel;
    public String tooltop;
    public String nodeType;
    public boolean nodeWritten;
    public String url;
    public List<ProcessorType> outputs;
    public String association = ""property"";
    private final String imagePrefix;
    public NodeData(String id, Object node, String imagePrefix) {
        this.id = id;
        this.imagePrefix = imagePrefix;
        if (node instanceof ProcessorType) {
            ProcessorType processorType = (ProcessorType)node;
            this.edgeLabel = processorType.getLabel();
        }
        if (node instanceof FromType) {
            FromType fromType = (FromType)node;
            this.tooltop = fromType.getLabel();
            this.label = removeQueryString(this.tooltop);
            this.url = ""http://activemq.apache.org/camel/message-endpoint.html"";
        } else if (node instanceof ToType) {
            ToType toType = (ToType)node;
            this.tooltop = toType.getLabel();
            this.label = removeQueryString(this.tooltop);
            this.edgeLabel = """";
            this.url = ""http://activemq.apache.org/camel/message-endpoint.html"";
        } else if (node instanceof FilterType) {
            this.image = imagePrefix + ""MessageFilterIcon.png"";
            this.nodeType = ""Message Filter"";
        } else if (node instanceof WhenType) {
            this.image = imagePrefix + ""MessageFilterIcon.png"";
            this.nodeType = ""When Filter"";
            this.url = ""http://activemq.apache.org/camel/content-based-router.html"";
        } else if (node instanceof OtherwiseType) {
            this.nodeType = ""Otherwise"";
            this.edgeLabel = """";
            this.url = ""http://activemq.apache.org/camel/content-based-router.html"";
            this.tooltop = ""Otherwise"";
        } else if (node instanceof ChoiceType) {
            this.image = imagePrefix + ""ContentBasedRouterIcon.png"";
            this.nodeType = ""Content Based Router"";
            this.label = """";
            this.edgeLabel = """";
            ChoiceType choice = (ChoiceType)node;
            List<ProcessorType> outputs = new ArrayList<ProcessorType>(choice.getWhenClauses());
            if (choice.getOtherwise() != null) {
                outputs.add(choice.getOtherwise());
            }
            this.outputs = outputs;
        } else if (node instanceof RecipientListType) {
            this.image = imagePrefix + ""RecipientListIcon.png"";
            this.nodeType = ""Recipient List"";
        } else if (node instanceof RoutingSlipType) {
            this.image = imagePrefix + ""RoutingTableIcon.png"";
            this.nodeType = ""Routing Slip"";
            this.url = ""http://activemq.apache.org/camel/routing-slip.html"";
            this.tooltop = ((RoutingSlipType) node).getHeaderName();
        } else if (node instanceof SplitterType) {
            this.image = imagePrefix + ""SplitterIcon.png"";
            this.nodeType = ""Splitter"";
        } else if (node instanceof AggregatorType) {
            this.image = imagePrefix + ""AggregatorIcon.png"";
            this.nodeType = ""Aggregator"";
        } else if (node instanceof ResequencerType) {
            this.image = imagePrefix + ""ResequencerIcon.png"";
            this.nodeType = ""Resequencer"";
        }
        // lets auto-default as many values as we can
        if (isNullOrBlank(this.nodeType) && node != null) {
            // TODO we could add this to the model?
            String name = node.getClass().getName();
            int idx = name.lastIndexOf('.');
            if (idx > 0) {
                name = name.substring(idx + 1);
            }
            if (name.endsWith(""Type"")) {
                name = name.substring(0, name.length() - 4);
            }
            this.nodeType = insertSpacesBetweenCamelCase(name);
        }
        if (this.label == null) {
            if (isNullOrBlank(this.image)) {
                this.label = this.nodeType;
                this.shape = ""box"";
            } else if (isNotNullAndNonEmpty(this.edgeLabel)) {
                this.label = """";
            } else {
                this.label = node.toString();
            }
        }
        if (isNullOrBlank(this.tooltop)) {
            if (isNotNullAndNonEmpty(this.nodeType)) {
                String description = isNotNullAndNonEmpty(this.edgeLabel) ? this.edgeLabel : this.label;
                this.tooltop = this.nodeType + "": "" + description;
            } else {
                this.tooltop = this.label;
            }
        }
        if (isNullOrBlank(this.url) && isNotNullAndNonEmpty(this.nodeType)) {
            this.url = ""http://activemq.apache.org/camel/"" + this.nodeType.toLowerCase().replace(' ', '-')
                       + "".html"";
        }
        if (node instanceof ProcessorType && this.outputs == null) {
            ProcessorType processorType = (ProcessorType)node;
            this.outputs = processorType.getOutputs();
        }
    }
    protected String removeQueryString(String text) {
        int idx = text.indexOf(""?"");
        if (idx <= 0) {
            return text;
        } else {
            return text.substring(0, idx);
        }
    }
    /**
     * Lets insert a space before each upper case letter after a lowercase
     */
    public static String insertSpacesBetweenCamelCase(String name) {
        boolean lastCharacterLowerCase = false;
        StringBuffer buffer = new StringBuffer();
        int i = 0;
        for (int size = name.length(); i < size; i++) {
            char ch = name.charAt(i);
            if (Character.isUpperCase(ch)) {
                if (lastCharacterLowerCase) {
                    buffer.append(' ');
                }
                lastCharacterLowerCase = false;
            } else {
                lastCharacterLowerCase = true;
            }
            buffer.append(ch);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.view.RouteDotGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.model.FromType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
/**
 * A <a href=""http://www.graphviz.org/"">DOT</a> file creator plugin which
 * creates a DOT file showing the current routes
 *
 * @version $Revision: 630591 $
 */
public class RouteDotGenerator extends GraphGeneratorSupport {
    public RouteDotGenerator(String dir) {
        super(dir, "".dot"");
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void printRoutes(PrintWriter writer, Map<String, List<RouteType>> map) {
        Set<Map.Entry<String, List<RouteType>>> entries = map.entrySet();
        for (Map.Entry<String, List<RouteType>> entry : entries) {
            String group = entry.getKey();
            printRoutes(writer, group, entry.getValue());
        }
    }
    protected void printRoutes(PrintWriter writer, String group, List<RouteType> routes) {
        if (group != null) {
            writer.println(""subgraph cluster_"" + (clusterCounter++) + "" {"");
            writer.println(""label = \"""" + group + ""\"";"");
            writer.println(""color = grey;"");
            writer.println(""style = \""dashed\"";"");
            writer.println(""URL = \"""" + group + "".html\"";"");
            writer.println();
        }
        for (RouteType route : routes) {
            List<FromType> inputs = route.getInputs();
            for (FromType input : inputs) {
                printRoute(writer, route, input);
            }
            writer.println();
        }
        if (group != null) {
            writer.println(""}"");
            writer.println();
        }
    }
    protected String escapeNodeId(String text) {
        return text.replace('.', '_').replace(""$"", ""_"");
    }
    protected void printRoute(PrintWriter writer, final RouteType route, FromType input) {
        NodeData nodeData = getNodeData(input);
        printNode(writer, nodeData);
        // TODO we should add a transactional client / event driven consumer / polling client
        NodeData from = nodeData;
        for (ProcessorType output : route.getOutputs()) {
            NodeData newData = printNode(writer, from, output);
            from = newData;
        }
    }
    protected NodeData printNode(PrintWriter writer, NodeData fromData, ProcessorType node) {
        if (node instanceof MulticastType) {
            // no need for a multicast node
            List<ProcessorType> outputs = node.getOutputs();
            for (ProcessorType output : outputs) {
                printNode(writer, fromData, output);
            }
            return fromData;
        }
        NodeData toData = getNodeData(node);
        printNode(writer, toData);
        if (fromData != null) {
            writer.print(fromData.id);
            writer.print("" -> "");
            writer.print(toData.id);
            writer.println("" ["");
            String label = fromData.edgeLabel;
            if (isNotNullAndNonEmpty(label)) {
                writer.println(""label = \"""" + label + ""\"""");
            }
            writer.println(""];"");
        }
        // now lets write any children
        //List<ProcessorType> outputs = node.getOutputs();
        List<ProcessorType> outputs = toData.outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                NodeData newData = printNode(writer, toData, output);
                if (!isMulticastNode(node)) {
                    toData = newData;
                }
            }
        }
        return toData;
    }
    protected void printNode(PrintWriter writer, NodeData data) {
        if (!data.nodeWritten) {
            data.nodeWritten = true;
            writer.println();
            writer.print(data.id);
            writer.println("" ["");
            writer.println(""label = \"""" + data.label + ""\"""");
            writer.println(""tooltip = \"""" + data.tooltop + ""\"""");
            if (data.url != null) {
                writer.println(""URL = \"""" + data.url + ""\"""");
            }
            String image = data.image;
            if (image != null) {
                writer.println(""shapefile = \"""" + image + ""\"""");
                writer.println(""peripheries=0"");
            }
            String shape = data.shape;
            if (shape == null && image != null) {
                shape = ""custom"";
            }
            if (shape != null) {
                writer.println(""shape = \"""" + shape + ""\"""");
            }
            writer.println(""];"");
            writer.println();
        }
    }
    protected void generateFile(PrintWriter writer, Map<String, List<RouteType>> map) {
        writer.println(""digraph CamelRoutes {"");
        writer.println();
        writer.println(""node [style = \""rounded,filled\"", fillcolor = yellow, ""
                + ""fontname=\""Helvetica-Oblique\""];"");
        writer.println();
        printRoutes(writer, map);
        writer.println(""}"");
    }
}
"
org.apache.camel.view.RouteDotGeneratorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import junit.framework.TestCase;
/**
 * @version $Revision: 640438 $
 */
public class RouteDotGeneratorTest extends TestCase {
    public void testInsertSpacesBetweenCamelCase() throws Exception {
        String value = NodeData.insertSpacesBetweenCamelCase(""FooBarType"");
        assertEquals(""Converted value"", ""Foo Bar Type"", value);
    }
}
"
org.apache.camel.view.XmlGraphGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.model.FromType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
/**
 * @version $Revision: 640438 $
 */
public class XmlGraphGenerator extends GraphGeneratorSupport {
    private boolean addUrl = true;
    public XmlGraphGenerator(String dir) {
        super(dir, "".xml"");
    }
    protected void generateFile(PrintWriter writer, Map<String, List<RouteType>> map) {
        writer.println(""<?xml version='1.0' encoding='UTF-8'?>"");
        writer.println(""<Graph>"");
        writer.println();
        if (map.size() > 0) {
            writer.println(""<Node id='root' name='Camel Routes' description='Collection of Camel Routes' nodeType='root'/>"");
        }
        printRoutes(writer, map);
        writer.println();
        writer.println(""</Graph>"");
    }
    protected void printRoutes(PrintWriter writer, Map<String, List<RouteType>> map) {
        Set<Map.Entry<String, List<RouteType>>> entries = map.entrySet();
        for (Map.Entry<String, List<RouteType>> entry : entries) {
            String group = entry.getKey();
            printRoutes(writer, group, entry.getValue());
        }
    }
    protected void printRoutes(PrintWriter writer, String group, List<RouteType> routes) {
        group = encode(group);
        if (group != null) {
            int idx = group.lastIndexOf('.');
            String name = group;
            if (idx > 0 && idx < group.length() - 1) {
                name = group.substring(idx + 1);
            }
            writer.println(""<Node id='"" + group + ""' name='"" + name + ""' description='"" + group + ""' nodeType='group'/>"");
            writer.println(""<Edge fromID='root' toID='"" + group + ""'/>"");
        }
        for (RouteType route : routes) {
            List<FromType> inputs = route.getInputs();
            boolean first = true;
            for (FromType input : inputs) {
                NodeData nodeData = getNodeData(input);
                if (first) {
                    first = false;
                    if (group != null) {
                        writer.println(""<Edge fromID='"" + group + ""' toID='"" + encode(nodeData.id) + ""'/>"");
                    }
                }
                printRoute(writer, route, nodeData);
            }
            writer.println();
        }
    }
    protected void printRoute(PrintWriter writer, final RouteType route, NodeData nodeData) {
        printNode(writer, nodeData);
        // TODO we should add a transactional client / event driven consumer / polling client
        NodeData from = nodeData;
        for (ProcessorType output : route.getOutputs()) {
            NodeData newData = printNode(writer, from, output);
            from = newData;
        }
    }
    protected NodeData printNode(PrintWriter writer, NodeData fromData, ProcessorType node) {
        if (node instanceof MulticastType) {
            // no need for a multicast node
            List<ProcessorType> outputs = node.getOutputs();
            for (ProcessorType output : outputs) {
                printNode(writer, fromData, output);
            }
            return fromData;
        }
        NodeData toData = getNodeData(node);
        printNode(writer, toData);
        if (fromData != null) {
            writer.print(""<Edge fromID=\"""");
            writer.print(encode(fromData.id));
            writer.print(""\"" toID=\"""");
            writer.print(encode(toData.id));
            String association = toData.edgeLabel;
            if (isNullOrBlank(association)) {
                writer.print(""\"" association=\"""");
                writer.print(encode(association));
            }
            writer.println(""\""/>"");
        }
        // now lets write any children
        List<ProcessorType> outputs = toData.outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                NodeData newData = printNode(writer, toData, output);
                if (!isMulticastNode(node)) {
                    toData = newData;
                }
            }
        }
        return toData;
    }
    protected void printNode(PrintWriter writer, NodeData data) {
        if (!data.nodeWritten) {
            data.nodeWritten = true;
            writer.println();
            writer.print(""<Node id=\"""");
            writer.print(encode(data.id));
            writer.print(""\"" name=\"""");
            String name = data.label;
            if (isNullOrBlank(name)) {
                name = data.tooltop;
            }
            writer.print(encode(name));
            writer.print(""\"" nodeType=\"""");
            String nodeType = data.image;
            if (isNullOrBlank(nodeType)) {
                nodeType = data.shape;
                if (isNullOrBlank(nodeType)) {
                    nodeType = ""node"";
                }
            }
            writer.print(encode(nodeType));
            writer.print(""\"" description=\"""");
            writer.print(encode(data.tooltop));
            if (addUrl) {
                writer.print(""\"" url=\"""");
                writer.print(encode(data.url));
            }
            writer.println(""\""/>"");
        }
    }
    protected String encode(String text) {
        if (text == null) {
            return """";
        }
        return text.replaceAll(""\"""", ""&quot;"").replaceAll(""<"", ""&lt;"").
                replaceAll("">"", ""&gt;"").replaceAll(""&"", ""&amp;"");
    }
}
"
org.apache.camel.view.XmlGraphTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
/**
 * @version $Revision: 640438 $
 */
public class XmlGraphTest extends DotViewTest {
    @Override
    public void testGenerateFiles() throws Exception {
        XmlGraphGenerator generator = new XmlGraphGenerator(outputDirectory);
        generator.drawRoutes(context);
    }
}
"
org.apache.camel.component.cxf.feature.MessageInvokerInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.concurrent.Executor;
import org.apache.camel.component.cxf.MessageInvoker;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.Service;
/**
 * This interceptor just works for invoking the MessageInvoker implementor
 *
 */
public class MessageInvokerInterceptor extends AbstractPhaseInterceptor<Message> {
    public MessageInvokerInterceptor() {
        super(Phase.INVOKE);
    }
    public void handleMessage(final Message message) {
        final Exchange exchange = message.getExchange();
        final Endpoint endpoint = exchange.get(Endpoint.class);
        final Service service = endpoint.getService();
        final MessageInvoker invoker = (MessageInvoker)service.getInvoker();
        // How to deal with the oneway messge
        Runnable invocation = new Runnable() {
            public void run() {
                Exchange runableEx = message.getExchange();
                invoker.invoke(runableEx);
                if (!exchange.isOneWay()) {
                    Endpoint ep = exchange.get(Endpoint.class);
                    Message outMessage = runableEx.getOutMessage();
                    copyJaxwsProperties(message, outMessage);
                    if (outMessage == null) {
                        outMessage = ep.getBinding().createMessage();
                        exchange.setOutMessage(outMessage);
                    }
                }
            }
        };
        Executor executor = getExecutor(endpoint);
        if (exchange.get(Executor.class) == executor) {
            // already executing on the appropriate executor
            invocation.run();
        } else {
            exchange.put(Executor.class, executor);
            executor.execute(invocation);
        }
    }
    /**
     * Get the Executor for this invocation.
     * @param endpoint
     * @return
     */
    private Executor getExecutor(final Endpoint endpoint) {
        return endpoint.getService().getExecutor();
    }
    private void copyJaxwsProperties(Message inMsg, Message outMsg) {
        outMsg.put(Message.WSDL_OPERATION, inMsg.get(Message.WSDL_OPERATION));
        outMsg.put(Message.WSDL_SERVICE, inMsg.get(Message.WSDL_SERVICE));
        outMsg.put(Message.WSDL_INTERFACE, inMsg.get(Message.WSDL_INTERFACE));
        outMsg.put(Message.WSDL_PORT, inMsg.get(Message.WSDL_PORT));
        outMsg.put(Message.WSDL_DESCRIPTION, inMsg.get(Message.WSDL_DESCRIPTION));
    }
}
"
org.apache.camel.builder.script.Groovy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of <a href=""http://groovy.codehaus.org/"">Groovy</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""groovy"")
public @interface Groovy {
    String value();
}"
org.apache.camel.component.jhc.JhcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.impl.DefaultConnectionReuseStrategy;
import org.apache.http.impl.nio.DefaultClientIOEventDispatch;
import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
import org.apache.http.message.BasicHttpEntityEnclosingRequest;
import org.apache.http.message.BasicHttpRequest;
import org.apache.http.nio.NHttpConnection;
import org.apache.http.nio.protocol.BufferingHttpClientHandler;
import org.apache.http.nio.protocol.EventListener;
import org.apache.http.nio.protocol.HttpRequestExecutionHandler;
import org.apache.http.nio.reactor.ConnectingIOReactor;
import org.apache.http.nio.reactor.IOEventDispatch;
import org.apache.http.nio.reactor.SessionRequest;
import org.apache.http.nio.reactor.SessionRequestCallback;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.BasicHttpProcessor;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.RequestConnControl;
import org.apache.http.protocol.RequestContent;
import org.apache.http.protocol.RequestExpectContinue;
import org.apache.http.protocol.RequestTargetHost;
import org.apache.http.protocol.RequestUserAgent;
import org.apache.http.util.concurrent.ThreadFactory;
public class JhcProducer extends DefaultProducer<JhcExchange> implements AsyncProcessor {
    public static final String HTTP_RESPONSE_CODE = ""http.responseCode"";
    // This should be a set of lower-case strings
    public static final Set<String> HEADERS_TO_SKIP = new HashSet<String>(Arrays.asList(
            ""content-length"", ""content-type"", HTTP_RESPONSE_CODE.toLowerCase()));
    private static final transient Log LOG = LogFactory.getLog(JhcProducer.class);
    private int nbThreads = 2;
    private ConnectingIOReactor ioReactor;
    private ThreadFactory threadFactory;
    private Thread runner;
    public JhcProducer(JhcEndpoint endpoint) {
        super(endpoint);
    }
    @Override
    public JhcEndpoint getEndpoint() {
        return (JhcEndpoint) super.getEndpoint();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        HttpParams params = getEndpoint().getParams();
        ioReactor = new DefaultConnectingIOReactor(nbThreads, threadFactory, params);
        BasicHttpProcessor httpproc = new BasicHttpProcessor();
        httpproc.addInterceptor(new RequestContent());
        httpproc.addInterceptor(new RequestTargetHost());
        httpproc.addInterceptor(new RequestConnControl());
        httpproc.addInterceptor(new RequestUserAgent());
        httpproc.addInterceptor(new RequestExpectContinue());
        BufferingHttpClientHandler handler = new BufferingHttpClientHandler(
                httpproc,
                new MyHttpRequestExecutionHandler(),
                new DefaultConnectionReuseStrategy(),
                params);
        handler.setEventListener(new EventLogger());
        final IOEventDispatch ioEventDispatch = new DefaultClientIOEventDispatch(handler, params);
        runner = new Thread(new Runnable() {
            public void run() {
                try {
                    ioReactor.execute(ioEventDispatch);
                } catch (InterruptedIOException ex) {
                    LOG.info(""Interrupted"");
                } catch (IOException e) {
                    LOG.warn(""I/O error: "" + e.getMessage());
                }
                LOG.debug(""Shutdown"");
            }
        });
        runner.start();
    }
    @Override
    protected void doStop() throws Exception {
        ioReactor.shutdown();
        runner.join();
        super.doStop();
    }
    public void process(Exchange exchange) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""process: "" + exchange);
        }
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""processAsync: "" + exchange);
        }
        SocketAddress addr = new InetSocketAddress(getEndpoint().getHost(), getEndpoint().getPort());
        exchange.setProperty(AsyncCallback.class.getName(), callback);
        SessionRequest req = ioReactor.connect(addr, null, exchange, new MySessionRequestCallback());
        return false;
    }
    protected HttpRequest createRequest(Exchange exchange) {
        String uri = getEndpoint().getEndpointUri();
        HttpEntity entity = createEntity(exchange);
        HttpRequest req;
        if (entity == null) {
            req = new BasicHttpRequest(""GET"", getEndpoint().getPath());
        } else {
            req = new BasicHttpEntityEnclosingRequest(""POST"", getEndpoint().getPath());
            ((BasicHttpEntityEnclosingRequest)req).setEntity(entity);
        }
        // propagate headers as HTTP headers
        for (String headerName : exchange.getIn().getHeaders().keySet()) {
            String headerValue = exchange.getIn().getHeader(headerName, String.class);
            if (shouldHeaderBePropagated(headerName, headerValue)) {
                req.addHeader(headerName, headerValue);
            }
        }
        return req;
    }
    protected HttpEntity createEntity(Exchange exchange) {
        Message in = exchange.getIn();
        HttpEntity entity = in.getBody(HttpEntity.class);
        if (entity == null) {
            byte[] data = in.getBody(byte[].class);
            if (data == null) {
                return null;
            }
            entity = new ByteArrayEntity(data);
            String contentType = in.getHeader(""Content-Type"", String.class);
            if (contentType != null) {
                ((ByteArrayEntity) entity).setContentType(contentType);
            }
            String contentEncoding = in.getHeader(""Content-Encoding"", String.class);
            if (contentEncoding != null) {
                ((ByteArrayEntity) entity).setContentEncoding(contentEncoding);
            }
        }
        return entity;
    }
    // TODO Should somehow reference to HttpProducer as now it is copy/paste
    protected boolean shouldHeaderBePropagated(String headerName, String headerValue) {
        if (headerValue == null) {
            return false;
        }
        if (headerName.startsWith(""org.apache.camel"")) {
            return false;
        }
        if (HEADERS_TO_SKIP.contains(headerName.toLowerCase())) {
            return false;
        }
        return true;
    }
    static class MySessionRequestCallback implements SessionRequestCallback {
        public void completed(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Completed"");
            }
        }
        public void failed(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Failed"");
            }
        }
        public void timeout(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Timeout"");
            }
        }
        public void cancelled(SessionRequest sessionRequest) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Cancelled"");
            }
        }
    }
    class MyHttpRequestExecutionHandler implements HttpRequestExecutionHandler {
        private static final String REQUEST_SENT       = ""request-sent"";
        private static final String RESPONSE_RECEIVED  = ""response-received"";
        public void initalizeContext(HttpContext httpContext, Object o) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Initialize context"");
            }
            httpContext.setAttribute(Exchange.class.getName(), (Exchange) o);
        }
        public HttpRequest submitRequest(HttpContext httpContext) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Submit request: "" + httpContext);
            }
            Object flag = httpContext.getAttribute(REQUEST_SENT);
            if (flag == null) {
                // Stick some object into the context
                httpContext.setAttribute(REQUEST_SENT, Boolean.TRUE);
                Exchange e = (Exchange) httpContext.getAttribute(Exchange.class.getName());
                return createRequest(e);
            } else {
                return null;
            }
        }
        public void handleResponse(HttpResponse httpResponse, HttpContext httpContext) throws IOException {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Handle response"");
            }
            httpContext.setAttribute(RESPONSE_RECEIVED, Boolean.TRUE);
            Exchange e = (Exchange) httpContext.getAttribute(Exchange.class.getName());
            e.getOut().setBody(httpResponse.getEntity());
            for (Iterator it = httpResponse.headerIterator(); it.hasNext();) {
                Header h = (Header) it.next();
                e.getOut().setHeader(h.getName(), h.getValue());
            }
            e.getOut().setHeader(HTTP_RESPONSE_CODE, httpResponse.getStatusLine().getStatusCode());
            AsyncCallback callback = (AsyncCallback) e.removeProperty(AsyncCallback.class.getName());
            callback.done(false);
        }
        public void finalizeContext(HttpContext httpContext) {
        }
    }
    static class EventLogger implements EventListener {
        public void connectionOpen(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection open: "" + conn);
            }
        }
        public void connectionTimeout(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection timed out: "" + conn);
            }
        }
        public void connectionClosed(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection closed: "" + conn);
            }
        }
        public void fatalIOException(final IOException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""I/O error: "" + ex.getMessage());
            }
        }
        public void fatalProtocolException(final HttpException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""HTTP error: "" + ex.getMessage());
            }
        }
    }
}
"
org.apache.camel.bam.model.ActivityDefinition,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.UniqueConstraint;
/**
 * @version $Revision$
 */
@Entity
@UniqueConstraint(columnNames = {""name"" })
public class ActivityDefinition extends EntitySupport {
    private String name;
    private ProcessDefinition processDefinition;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""Activity["" + getId() + "" name: "" + getName() + ""]"";
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
}
"
org.apache.camel.component.file.remote.FtpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.net.ftp.FTPClient;
public class FtpEndpoint extends RemoteFileEndpoint<RemoteFileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FtpEndpoint.class);
    public FtpEndpoint(String uri, RemoteFileComponent remoteFileComponent, RemoteFileConfiguration configuration) {
        super(uri, remoteFileComponent, configuration);
    }
    public FtpEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public FtpProducer createProducer() throws Exception {
        return new FtpProducer(this, createFtpClient());
    }
    public FtpConsumer createConsumer(Processor processor) throws Exception {
        final FtpConsumer consumer = new FtpConsumer(this, processor, createFtpClient());
        configureConsumer(consumer);
        return consumer;
    }
    protected FTPClient createFtpClient() {
        final FTPClient client = new FTPClient();
        return client;
    }
    public void connect(FTPClient client) throws IOException {
        RemoteFileConfiguration config = getConfiguration();
        String host = config.getHost();
        int port = config.getPort();
        client.connect(host, port);
        if (null != config.getUsername()) {
            client.login(config.getUsername(), config.getPassword());
        } else {
            client.login(""anonymous"", null);
        }
        client.setFileType(config.isBinary() ? FTPClient.BINARY_FILE_TYPE : FTPClient.ASCII_FILE_TYPE);
    }
    public void disconnect(FTPClient client) throws IOException {
        client.disconnect();
    }
}
"
org.apache.camel.spring.CamelBeanPostProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.EndpointInject;
import org.apache.camel.MessageDriven;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Service;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.impl.DefaultProducerTemplate;
import org.apache.camel.spring.util.ReflectionUtils;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
/**
 * A post processor to perform injection of {@link Endpoint} and
 * {@link Producer} instances together with binding methods annotated with
 * {@link MessageDriven @MessageDriven} to a Camel consumer.
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""beanPostProcessor"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware {
    private static final transient Log LOG = LogFactory.getLog(CamelBeanPostProcessor.class);
    @XmlTransient
    private SpringCamelContext camelContext;
    @XmlTransient
    private ApplicationContext applicationContext;
    public CamelBeanPostProcessor() {
    }
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        injectFields(bean);
        injectMethods(bean);
        if (bean instanceof CamelContextAware) {
            CamelContextAware contextAware = (CamelContextAware)bean;
            if (camelContext == null) {
                LOG.warn(""No CamelContext defined yet so cannot inject into: "" + bean);
            } else {
                contextAware.setCamelContext(camelContext);
            }
        }
        return bean;
    }
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    // Properties
    // -------------------------------------------------------------------------
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public SpringCamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(SpringCamelContext camelContext) {
        this.camelContext = camelContext;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A strategy method to allow implementations to perform some custom JBI
     * based injection of the POJO
     *
     * @param bean the bean to be injected
     */
    protected void injectFields(final Object bean) {
        ReflectionUtils.doWithFields(bean.getClass(), new ReflectionUtils.FieldCallback() {
            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
                EndpointInject annotation = field.getAnnotation(EndpointInject.class);
                if (annotation != null) {
                    ReflectionUtils.setField(field, bean, getEndpointInjectionValue(annotation, field.getType(), field.getName()));
                }
            }
        });
    }
    protected void injectMethods(final Object bean) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                setterInjection(method, bean);
                consumerInjection(method, bean);
            }
        });
    }
    protected void setterInjection(Method method, Object bean) {
        EndpointInject annoation = method.getAnnotation(EndpointInject.class);
        if (annoation != null) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes != null) {
                if (parameterTypes.length != 1) {
                    LOG.warn(""Ignoring badly annotated method for injection due to incorrect number of parameters: "" + method);
                } else {
                    String propertyName = ObjectHelper.getPropertyName(method);
                    Object value = getEndpointInjectionValue(annoation, parameterTypes[0], propertyName);
                    ObjectHelper.invokeMethod(method, bean, value);
                }
            }
        }
    }
    protected void consumerInjection(final Object bean) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                /*
                 * TODO support callbacks? if
                 * (method.getAnnotation(Callback.class) != null) { try {
                 * Expression e = ExpressionFactory.createExpression(
                 * method.getAnnotation(Callback.class).condition());
                 * JexlContext jc = JexlHelper.createContext();
                 * jc.getVars().put(""this"", obj); Object r = e.evaluate(jc); if
                 * (!(r instanceof Boolean)) { throw new
                 * RuntimeException(""Expression did not returned a boolean value
                 * but: "" + r); } Boolean oldVal =
                 * req.getCallbacks().get(method); Boolean newVal = (Boolean) r;
                 * if ((oldVal == null || !oldVal) && newVal) {
                 * req.getCallbacks().put(method, newVal); method.invoke(obj,
                 * new Object[0]); // TODO: handle return value and sent it as
                 * the answer } } catch (Exception e) { throw new
                 * RuntimeException(""Unable to invoke callback"", e); } }
                 */
            }
        });
    }
    protected void consumerInjection(Method method, Object bean) {
        MessageDriven annotation = method.getAnnotation(MessageDriven.class);
        if (annotation != null) {
            LOG.info(""Creating a consumer for: "" + annotation);
            // lets bind this method to a listener
            String injectionPointName = method.getName();
            Endpoint endpoint = getEndpointInjection(annotation.uri(), annotation.name(), injectionPointName);
            if (endpoint != null) {
                try {
                    Processor processor = createConsumerProcessor(bean, method, endpoint);
                    LOG.info(""Created processor: "" + processor);
                    Consumer consumer = endpoint.createConsumer(processor);
                    startService(consumer);
                } catch (Exception e) {
                    LOG.warn(e);
                    throw new RuntimeCamelException(e);
                }
            }
        }
    }
    protected void startService(Service service) throws Exception {
        camelContext.addService(service);
    }
    /**
     * Create a processor which invokes the given method when an incoming
     * message exchange is received
     */
    protected Processor createConsumerProcessor(final Object pojo, final Method method, final Endpoint endpoint) {
        BeanProcessor answer = new BeanProcessor(pojo, getCamelContext());
        answer.setMethodObject(method);
        return answer;
    }
    /**
     * Creates the value for the injection point for the given annotation
     */
    protected Object getEndpointInjectionValue(EndpointInject annotation, Class<?> type, String injectionPointName) {
        Endpoint endpoint = getEndpointInjection(annotation.uri(), annotation.name(), injectionPointName);
        if (endpoint != null) {
            if (type.isInstance(endpoint)) {
                return endpoint;
            } else if (type.isAssignableFrom(Producer.class)) {
                return createInjectionProducer(endpoint);
            } else if (type.isAssignableFrom(DefaultProducerTemplate.class)) {
                return new DefaultProducerTemplate(getCamelContext(), endpoint);
            } else if (type.isAssignableFrom(PollingConsumer.class)) {
                return createInjectionPollingConsumer(endpoint);
            } else {
                throw new IllegalArgumentException(""Invalid type: "" + type.getName() + "" which cannot be injected via @EndpointInject for "" + endpoint);
            }
        }
        return null;
    }
    /**
     * Factory method to create a started {@link PollingConsumer} to be injected
     * into a POJO
     */
    protected PollingConsumer createInjectionPollingConsumer(Endpoint endpoint) {
        try {
            PollingConsumer pollingConsumer = endpoint.createPollingConsumer();
            startService(pollingConsumer);
            return pollingConsumer;
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * A Factory method to create a started {@link Producer} to be injected into
     * a POJO
     */
    protected Producer createInjectionProducer(Endpoint endpoint) {
        try {
            Producer producer = endpoint.createProducer();
            startService(producer);
            return producer;
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    protected Endpoint getEndpointInjection(String uri, String name, String injectionPointName) {
        Endpoint endpoint = null;
        if (isNotNullAndNonEmpty(uri)) {
            endpoint = camelContext.getEndpoint(uri);
        } else {
            if (isNullOrBlank(name)) {
                name = injectionPointName;
            }
            endpoint = (Endpoint) applicationContext.getBean(name);
            if (endpoint == null) {
                throw new NoSuchBeanDefinitionException(name);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.component.cxf.feature.MessageDataFormatFeature,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.logging.Logger;
import org.apache.camel.component.cxf.interceptors.FaultOutInterceptor;
import org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.phase.Phase;
/**
 * This feature just setting up the CXF endpoint interceptor for handling the
 * Message in Message data format
 */
public class MessageDataFormatFeature extends AbstractDataFormatFeature {
    private static final Logger LOG = LogUtils.getL7dLogger(MessageDataFormatFeature.class);
    // interceptor filiter
    // filiter the unused phase interceptor
    private static final String[] REMAINING_IN_PHASES = {Phase.RECEIVE , Phase.POST_INVOKE};
    private static final String[] REMAINING_OUT_PHASES = {Phase.PREPARE_SEND, Phase.WRITE, Phase.SEND, Phase.PREPARE_SEND_ENDING};
    @Override
    public void initialize(Client client, Bus bus) {
        removeInterceptorWhichIsOutThePhases(client.getInInterceptors(), REMAINING_IN_PHASES);
        removeInterceptorWhichIsOutThePhases(client.getEndpoint().getInInterceptors(), REMAINING_IN_PHASES);
        client.getEndpoint().getBinding().getInInterceptors().clear();
        removeInterceptorWhichIsOutThePhases(client.getOutInterceptors(), REMAINING_OUT_PHASES);
        removeInterceptorWhichIsOutThePhases(client.getEndpoint().getOutInterceptors(), REMAINING_OUT_PHASES);
        client.getEndpoint().getBinding().getOutInterceptors().clear();
        client.getEndpoint().getOutInterceptors().add(new RawMessageContentRedirectInterceptor());
        client.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
    }
    @Override
    public void initialize(Server server, Bus bus) {
        // currently we do not filiter the bus
        // remove the interceptors
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getService().getInInterceptors(), REMAINING_IN_PHASES);
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getInInterceptors(), REMAINING_IN_PHASES);
        // Do not using the binding interceptor any more
        server.getEndpoint().getBinding().getInInterceptors().clear();
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getService().getOutInterceptors(), REMAINING_OUT_PHASES);
        removeInterceptorWhichIsOutThePhases(server.getEndpoint().getOutInterceptors(), REMAINING_OUT_PHASES);
        // Do not use the binding interceptor any more
        server.getEndpoint().getBinding().getOutInterceptors().clear();
        server.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
        resetServiceInvokerInterceptor(server);
        server.getEndpoint().getOutInterceptors().add(new RawMessageContentRedirectInterceptor());
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.spring.CamelServiceExporterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * The &lt;export&gt; tag element.
 *
 * @version $Revision$
*/
@XmlRootElement(name = ""export"")
public class CamelServiceExporterType extends IdentifiedType {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String serviceRef;
    @XmlAttribute
    private Class serviceInterface;
}
"
org.apache.camel.component.rmi.RmiProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import org.apache.camel.Exchange;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.component.bean.BeanHolder;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.impl.DefaultProducer;
/**
 * @version $Revision$
 */
public class RmiProducer extends DefaultProducer<BeanExchange> {
    private BeanProcessor beanProcessor;
    public RmiProducer(RmiEndpoint endpoint) throws RemoteException, NotBoundException {
        super(endpoint);
        BeanHolder holder = new RmiRegistryBean(endpoint.getCamelContext(), endpoint.getName(), endpoint.getRegistry());
        beanProcessor = new BeanProcessor(holder);
        String method = endpoint.getMethod();
        if (method != null) {
            beanProcessor.setMethod(method);
        }
    }
    public void process(Exchange exchange) throws Exception {
        beanProcessor.process(exchange);
    }
}
"
org.apache.camel.component.jms.ConsumerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
/**
 * @version $Revision$
 */
public enum ConsumerType {
    Simple, Default, ServerSessionPool
}
"
org.apache.camel.component.irc.IrcErrorLogger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.commons.logging.Log;
import org.schwering.irc.lib.IRCEventAdapter;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
/**
 * A helper class which logs errors
 *
 * @version $Revision$
 */
public class IrcErrorLogger extends IRCEventAdapter {
    private Log log;
    public IrcErrorLogger(Log log) {
        this.log = log;
    }
    @Override
    public void onRegistered() {
        super.onRegistered();
        log.info(""onRegistered"");
    }
    @Override
    public void onDisconnected() {
        super.onDisconnected();
        log.info(""onDisconnected"");
    }
    @Override
    public void onMode(String string, IRCUser ircUser, IRCModeParser ircModeParser) {
        super.onMode(string, ircUser, ircModeParser);
        log.info(""onMode.string = "" + string);
        log.info(""onMode.ircUser = "" + ircUser);
        log.info(""onMode.ircModeParser = "" + ircModeParser);
    }
    @Override
    public void onMode(IRCUser ircUser, String string, String string1) {
        super.onMode(ircUser, string, string1);
        log.info(""onMode.ircUser = "" + ircUser);
        log.info(""onMode.string = "" + string);
        log.info(""onMode.string1 = "" + string1);
    }
    @Override
    public void onPing(String string) {
        super.onPing(string);
        log.info(""onPing.string = "" + string);
    }
    @Override
    public void onError(String string) {
        log.info(""onError.string = "" + string);
    }
    @Override
    public void onError(int i, String string) {
        super.onError(i, string);
        log.error(""onError.i = "" + i);
        log.error(""onError.string = "" + string);
    }
    @Override
    public void unknown(String string, String string1, String string2, String string3) {
        super.unknown(string, string1, string2, string3);
        log.error(""unknown.string = "" + string);
        log.error(""unknown.string1 = "" + string1);
        log.error(""unknown.string2 = "" + string2);
        log.error(""unknown.string3 = "" + string3);
    }
}
"
org.apache.camel.component.cxf.transport.CamelConduit,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.IOException;
import java.io.OutputStream;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.camel.component.cxf.CxfSoapBinding;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
/**
 * @version $Revision$
 */
public class CamelConduit extends AbstractConduit implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-conduit"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelConduit.class);
    private CamelContext camelContext;
    private EndpointInfo endpointInfo;
    private String targetCamelEndpointUri;
    private ProducerTemplate<Exchange> camelTemplate;
    private Bus bus;
    public CamelConduit(CamelContext context, Bus b, EndpointInfo endpointInfo) {
        this(context, b, endpointInfo, null);
    }
    public CamelConduit(CamelContext context, Bus b, EndpointInfo epInfo, EndpointReferenceType targetReference) {
        super(targetReference);
        String address = epInfo.getAddress();
        if (address != null) {
            targetCamelEndpointUri = address.substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());
            if (targetCamelEndpointUri.startsWith(""//"")) {
                targetCamelEndpointUri = targetCamelEndpointUri.substring(2);
            }
        }
        camelContext = context;
        endpointInfo = epInfo;
        bus = b;
        initConfig();
    }
    public void setCamelContext(CamelContext context) {
        camelContext = context;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    // prepare the message for send out , not actually send out the message
    public void prepare(Message message) throws IOException {
        getLogger().log(Level.FINE, ""CamelConduit send message"");
        message.setContent(OutputStream.class, new CamelOutputStream(message));
    }
    public void close() {
        getLogger().log(Level.FINE, ""CamelConduit closed "");
    }
    protected Logger getLogger() {
        return LOG;
    }
    public String getBeanName() {
        if (endpointInfo == null || endpointInfo.getName() == null) {
            return ""default"" + BASE_BEAN_NAME_SUFFIX;
        }
        return endpointInfo.getName().toString() + BASE_BEAN_NAME_SUFFIX;
    }
    private void initConfig() {
        // we could configure the camel context here
        if (bus != null) {
            Configurer configurer = bus.getExtension(Configurer.class);
            if (null != configurer) {
                configurer.configureBean(this);
            }
        }
    }
    public ProducerTemplate<Exchange> getCamelTemplate() {
        if (camelTemplate == null) {
            CamelContext ctx = camelContext != null ? camelContext : new DefaultCamelContext();
            camelTemplate = ctx.createProducerTemplate();
        }
        return camelTemplate;
    }
    public void setCamelTemplate(ProducerTemplate<Exchange> template) {
        camelTemplate = template;
    }
    private class CamelOutputStream extends CachedOutputStream {
        private Message outMessage;
        private boolean isOneWay;
        public CamelOutputStream(Message m) {
            outMessage = m;
        }
        protected void doFlush() throws IOException {
            // do nothing here
        }
        protected void doClose() throws IOException {
            isOneWay = outMessage.getExchange().isOneWay();
            commitOutputMessage();
        }
        protected void onWrite() throws IOException {
            // do nothing here
        }
        private void commitOutputMessage() {
            ExchangePattern pattern;
            if (isOneWay) {
                pattern = ExchangePattern.InOnly;
            } else {
                pattern = ExchangePattern.InOut;
            }
            getLogger().log(Level.FINE, ""send the message to endpoint"" + targetCamelEndpointUri);
            // We could wait for the rely asynchronously
            org.apache.camel.Exchange exchange = getCamelTemplate().send(targetCamelEndpointUri, pattern, new Processor() {
                public void process(org.apache.camel.Exchange ex) throws IOException {
                    CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
                    // Send out the request message here, copy the protocolHeader back
                    Map<String, List<String>> protocolHeader = CastUtils.cast((Map<?, ?>)outMessage.get(Message.PROTOCOL_HEADERS));
                    CxfSoapBinding.setProtocolHeader(ex.getIn().getHeaders(), protocolHeader);
                    ex.getIn().setBody(outputStream.getBytes());
                    getLogger().log(Level.FINE, ""template sending request: "", ex.getIn());
                }
            });
            exchange.setProperty(CxfConstants.CXF_EXCHANGE, outMessage.getExchange());
            if (!isOneWay) {
                handleResponse(exchange);
            }
        }
        private void handleResponse(org.apache.camel.Exchange exchange) {
            org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(exchange, true);
            incomingObserver.onMessage(inMessage);
        }
    }
    /**
     * Represented decoupled response endpoint.
     */
    protected class DecoupledDestination implements Destination {
        protected MessageObserver decoupledMessageObserver;
        private EndpointReferenceType address;
        DecoupledDestination(EndpointReferenceType ref, MessageObserver incomingObserver) {
            address = ref;
            decoupledMessageObserver = incomingObserver;
        }
        public EndpointReferenceType getAddress() {
            return address;
        }
        public Conduit getBackChannel(Message inMessage, Message partialResponse, EndpointReferenceType addr) throws IOException {
            // shouldn't be called on decoupled endpoint
            return null;
        }
        public void shutdown() {
        }
        public synchronized void setMessageObserver(MessageObserver observer) {
            decoupledMessageObserver = observer;
        }
        public synchronized MessageObserver getMessageObserver() {
            return decoupledMessageObserver;
        }
    }
}
"
org.apache.camel.component.xmpp.RuntimeXmppException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.jivesoftware.smack.XMPPException;
/**
 * A runtime exception thrown if sending or receiving from XMPP fails
 *
 * @version $Revision:520964 $
 */
public class RuntimeXmppException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeXmppException(XMPPException cause) {
        super(cause);
    }
    public RuntimeXmppException(String message, XMPPException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.cxf.AsyncProcessorDecorator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.util.AsyncProcessorHelper;
/**
 * A simple class to wrap an existing processor (synchronous or asynchronous)
 * with two synchronous processors that will be executed before and after the
 * main processor.
 */
public class AsyncProcessorDecorator implements AsyncProcessor {
    private final AsyncProcessor processor;
    private final Processor before;
    private final Processor after;
    public AsyncProcessorDecorator(Processor processor, Processor before, Processor after) {
        this.processor = AsyncProcessorTypeConverter.convert(processor);
        this.before = before;
        this.after = after;
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        try {
            before.process(exchange);
        } catch (Throwable t) {
            exchange.setException(t);
            callback.done(true);
            return true;
        }
        return processor.process(exchange, new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                try {
                    after.process(exchange);
                    callback.done(doneSynchronously);
                } catch (Throwable t) {
                    exchange.setException(t);
                }
            }
        });
    }
}
"
org.apache.camel.spring.factory.BeanEndpointFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.factory;
import org.apache.camel.component.bean.BeanEndpoint;
import org.springframework.beans.factory.FactoryBean;
/**
 * Spring {@link org.springframework.beans.factory.FactoryBean} for creating
 * Camel {@link BeanEndpoint} objects.
 *
 * @version $Revision$
 */
public class BeanEndpointFactory implements FactoryBean {
    private boolean singleton = true;
    public Object getObject() throws Exception {
        return new BeanEndpoint();
    }
    public Class getObjectType() {
        return BeanEndpoint.class;
    }
    public boolean isSingleton() {
        return singleton;
    }
    protected void setSingleton(boolean singleton) {
        this.singleton = singleton;
    }
    // Properties
    //-------------------------------------------------------------------------
}
"
org.apache.camel.component.rmi.RmiRegistryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.rmi.registry.Registry;
import org.apache.camel.CamelContext;
import org.apache.camel.component.bean.ParameterMappingStrategy;
import org.apache.camel.component.bean.RegistryBean;
/**
 * @version $Revision$
 */
public class RmiRegistryBean extends RegistryBean {
    private final Registry registry;
    public RmiRegistryBean(CamelContext context, String name, Registry registry) {
        super(context, name);
        this.registry = registry;
    }
    public RmiRegistryBean(CamelContext context, String name, ParameterMappingStrategy parameterMappingStrategy, Registry registry) {
        super(context, name, parameterMappingStrategy);
        this.registry = registry;
    }
    @Override
    protected Object lookupBean() throws Exception {
        return registry.lookup(getName());
    }
}
"
org.apache.camel.component.validator.ValidatorComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
/**
 * The <a href=""http://activemq.apache.org/camel/validator.html"">Validator Component</a>
 * for validating XML against some schema
 *
 * @version $Revision$
 */
public class ValidatorComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        SpringValidator validator = new SpringValidator();
        Resource resource = resolveMandatoryResource(remaining);
        validator.setSchemaResource(resource);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        configureValidator(validator, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, validator);
    }
    protected void configureValidator(SpringValidator validator, String uri, String remaining, Map parameters) throws Exception {
        setProperties(validator, parameters);
    }
}
"
org.apache.camel.component.cxf.CxfSoapBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.xml.transform.Source;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
public final class CxfSoapBinding {
    private static final Log LOG = LogFactory.getLog(CxfSoapBinding.class);
    private CxfSoapBinding() {
    }
    public static org.apache.cxf.message.Message getCxfInMessage(org.apache.camel.Exchange exchange, boolean isClient) {
        MessageImpl answer = new MessageImpl();
        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(CxfConstants.CXF_EXCHANGE,
                                                                        org.apache.cxf.message.Exchange.class);
        org.apache.camel.Message message = null;
        if (isClient) {
            message = exchange.getOut();
        } else {
            message = exchange.getIn();
        }
        assert message != null;
        if (cxfExchange == null) {
            cxfExchange = new ExchangeImpl();
            exchange.setProperty(CxfConstants.CXF_EXCHANGE, cxfExchange);
        }
        Map<String, Object> headers = null;
        if (isClient) {
            headers = exchange.getOut().getHeaders();
        } else {
            headers = exchange.getIn().getHeaders();
        }
        answer.put(Message.PROTOCOL_HEADERS, getProtocolHeader(headers));
        Object body = message.getBody(InputStream.class);
        if (body instanceof InputStream) {
            answer.setContent(InputStream.class, body);
        } else {
            LOG.warn(""Can't get right InputStream object here, the message body is "" + message.getBody());
        }
        answer.putAll(message.getHeaders());
        answer.setExchange(cxfExchange);
        cxfExchange.setInMessage(answer);
        return answer;
    }
    public static org.apache.cxf.message.Message getCxfOutMessage(org.apache.camel.Exchange exchange, boolean isClient) {
        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(CxfConstants.CXF_EXCHANGE, org.apache.cxf.message.Exchange.class);
        assert cxfExchange != null;
        org.apache.cxf.endpoint.Endpoint cxfEndpoint = cxfExchange.get(org.apache.cxf.endpoint.Endpoint.class);
        org.apache.cxf.message.Message outMessage = cxfEndpoint.getBinding().createMessage();
        outMessage.setExchange(cxfExchange);
        cxfExchange.setOutMessage(outMessage);
        org.apache.camel.Message message = null;
        if (isClient) {
            message = exchange.getIn();
        } else {
            message = exchange.getOut();
        }
        Map<String, Object> headers = null;
        if (isClient) {
            headers = exchange.getIn().getHeaders();
        } else {
            headers = exchange.getOut().getHeaders();
        }
        outMessage.put(Message.PROTOCOL_HEADERS, getProtocolHeader(headers));
        // send the body back
        Object body = message.getBody(Source.class);
        if (body instanceof Source) {
            outMessage.setContent(Source.class, body);
        } else {
            LOG.warn(""Can't get right Source object here, the message body is "" + message.getBody());
        }
        outMessage.putAll(message.getHeaders());
        return outMessage;
    }
    private static Map<String, List<String>> getProtocolHeader(Map<String, Object> headers) {
        Map<String, List<String>> protocolHeader = new HashMap<String, List<String>>();
        Iterator headersKeySetIterator = headers.keySet().iterator();
        while (headersKeySetIterator.hasNext()) {
            String key = (String)headersKeySetIterator.next();
            Object value = headers.get(key);
            if (value != null) {
                protocolHeader.put(key, Collections.singletonList(value.toString()));
            } else {
                protocolHeader.put(key, null);
            }
        }
        return protocolHeader;
    }
    public static void setProtocolHeader(Map<String, Object> headers, Map<String, List<String>> protocolHeader) {
        if (protocolHeader != null) {
            StringBuilder value = new StringBuilder(256);
            for (Map.Entry<String, List<String>> entry : protocolHeader.entrySet()) {
                value.setLength(0);
                boolean first = true;
                for (String s : entry.getValue()) {
                    if (!first) {
                        value.append(""; "");
                    }
                    value.append(s);
                    first = false;
                }
                headers.put(entry.getKey(), value.toString());
            }
        }
    }
}
"
org.apache.camel.component.ibatis.IBatisComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import com.ibatis.sqlmap.client.SqlMapClient;
import com.ibatis.sqlmap.client.SqlMapClientBuilder;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
/**
 * An <a href=""http://activemq.apache.org/camel/ibatis.html>iBatis Component</a>
 * for performing SQL operations using an XML mapping file to abstract away the SQL
 *
 * @version $Revision$
 */
public class IBatisComponent extends DefaultComponent {
    public static final String DEFAULT_CONFIG_URI = ""SqlMapConfig.xml"";
    private static final transient Log LOG = LogFactory.getLog(IBatisComponent.class);
    private SqlMapClient sqlMapClient;
    private Resource sqlMapResource;
    public IBatisComponent() {
    }
    public IBatisComponent(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }
    // Properties
    //-------------------------------------------------------------------------
    public SqlMapClient getSqlMapClient() throws IOException {
        if (sqlMapClient == null) {
            sqlMapClient = createSqlMapClient();
        }
        return sqlMapClient;
    }
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }
    public Resource getSqlMapResource() {
        if (sqlMapResource == null) {
            sqlMapResource = new ClassPathResource(DEFAULT_CONFIG_URI);
            LOG.debug(""Defaulting to use the iBatis configuration from: "" + sqlMapResource);
        }
        return sqlMapResource;
    }
    public void setSqlMapResource(Resource sqlMapResource) {
        this.sqlMapResource = sqlMapResource;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new IBatisEndpoint(uri, this, remaining);
    }
    protected SqlMapClient createSqlMapClient() throws IOException {
        InputStream in = getSqlMapResource().getInputStream();
        return SqlMapClientBuilder.buildSqlMapClient(in);
    }
}
"
org.apache.camel.dataformat.xstream.XStreamDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.xstream;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.xml.QNameMap;
import com.thoughtworks.xstream.io.xml.StaxReader;
import com.thoughtworks.xstream.io.xml.StaxWriter;
import org.apache.camel.Exchange;
import org.apache.camel.converter.jaxp.StaxConverter;
import org.apache.camel.spi.DataFormat;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * ({@link DataFormat}) using XmlBeans to marshal to and from XML
 *
 * @version $Revision$
 */
public class XStreamDataFormat implements DataFormat {
    private XStream xstream;
    private StaxConverter staxConverter;
    public void marshal(Exchange exchange, Object body, OutputStream stream) throws Exception {
        HierarchicalStreamWriter writer = createHierarchicalStreamWriter(exchange, body, stream);
        getXStream().marshal(body, writer);
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
        HierarchicalStreamReader reader = createHierarchicalStreamReader(exchange, stream);
        return getXStream().unmarshal(reader);
    }
    public XStream getXStream() {
        if (xstream == null) {
            xstream = createXStream();
        }
        return xstream;
    }
    public void setXStream(XStream xstream) {
        this.xstream = xstream;
    }
    public StaxConverter getStaxConverter() {
        if (staxConverter == null) {
            staxConverter = new StaxConverter();
        }
        return staxConverter;
    }
    public void setStaxConverter(StaxConverter staxConverter) {
        this.staxConverter = staxConverter;
    }
    protected XStream createXStream() {
        return new XStream();
    }
    protected HierarchicalStreamWriter createHierarchicalStreamWriter(Exchange exchange, Object body, OutputStream stream) throws XMLStreamException {
        XMLStreamWriter xmlWriter = getStaxConverter().createXMLStreamWriter(stream);
        return new StaxWriter(new QNameMap(), xmlWriter);
    }
    protected HierarchicalStreamReader createHierarchicalStreamReader(Exchange exchange, InputStream stream) throws XMLStreamException {
        XMLStreamReader xmlReader = getStaxConverter().createXMLStreamReader(stream);
        return new StaxReader(new QNameMap(), xmlReader);
    }
}
"
org.apache.camel.component.xmpp.XmppConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.Iterator;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.PacketListener;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.packet.RosterPacket;
/**
 * A {@link org.apache.camel.Consumer Consumer} which listens to XMPP packets
 * 
 * @version $Revision$
 */
public class XmppConsumer extends DefaultConsumer<XmppExchange> implements PacketListener {
    private static final transient Log LOG = LogFactory.getLog(XmppConsumer.class);
    private final XmppEndpoint endpoint;
    public XmppConsumer(XmppEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.getConnection().addPacketListener(this, endpoint.getFilter());
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.getConnection().removePacketListener(this);
        super.doStop();
    }
    public void processPacket(Packet packet) {
        if (packet instanceof Message) {
            Message message = (Message)packet;
            if (LOG.isDebugEnabled()) {
                LOG.debug(""<<<< message: "" + message.getBody());
            }
            XmppExchange exchange = endpoint.createExchange(message);
            try {
                getProcessor().process(exchange);
            } catch (Exception e) {
                // TODO: what should we do when a processing failure occurs??
                e.printStackTrace();
            }
        } else if (packet instanceof RosterPacket) {
            // TODO: what to do with a RosterPacket other than debug logging it
            RosterPacket rosterPacket = (RosterPacket)packet;
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Roster packet with : "" + rosterPacket.getRosterItemCount() + "" item(s)"");
                Iterator rosterItems = rosterPacket.getRosterItems();
                while (rosterItems.hasNext()) {
                    Object item = rosterItems.next();
                    LOG.debug(""Roster item: "" + item);
                }
            }
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""<<<< ignored packet: "" + packet);
            }
        }
    }
}
"
org.apache.camel.component.validator.jing.RelaxNGCompactSyntaxComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.util.Map;
/**
 * A component for validating the XML payload using
 * <a href=""http://www.oasis-open.org/committees/relax-ng/compact-20021121.html"">RelaxNG Compact Syntax</a> using the
 * <a href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing library</a>
 *
 * @version $Revision$
 */
public class RelaxNGCompactSyntaxComponent extends JingComponent {
    protected void configureValidator(JingValidator validator, String uri, String remaining, Map parameters) throws Exception {
        validator.setCompactSyntax(true);
        super.configureValidator(validator, uri, remaining, parameters);
    }
}
"
org.apache.camel.component.jpa.JpaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.lang.reflect.Method;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceException;
import javax.persistence.Query;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaCallback;
/**
 * @version $Revision$
 */
public class JpaConsumer extends ScheduledPollConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(JpaConsumer.class);
    private final JpaEndpoint endpoint;
    private final TransactionStrategy template;
    private QueryFactory queryFactory;
    private DeleteHandler<Object> deleteHandler;
    private String query;
    private String namedQuery;
    private String nativeQuery;
    public JpaConsumer(JpaEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.template = endpoint.createTransactionStrategy();
    }
    protected void poll() throws Exception {
        template.execute(new JpaCallback() {
            public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                Query query = getQueryFactory().createQuery(entityManager);
                configureParameters(query);
                List results = query.getResultList();
                for (Object result : results) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Processing new entity: "" + result);
                    }
                    if (lockEntity(result, entityManager)) {
                        // lets turn the result into an exchange and fire it
                        // into the processor
                        Exchange exchange = createExchange(result);
                        try {
                            getProcessor().process(exchange);
                        } catch (Exception e) {
                            throw new PersistenceException(e);
                        }
                        getDeleteHandler().deleteObject(entityManager, result);
                    }
                }
                entityManager.flush();
                return null;
            }
        });
    }
    // Properties
    // -------------------------------------------------------------------------
    public JpaEndpoint getEndpoint() {
        return endpoint;
    }
    public QueryFactory getQueryFactory() {
        if (queryFactory == null) {
            queryFactory = createQueryFactory();
            if (queryFactory == null) {
                throw new IllegalArgumentException(""No queryType property configured on this consumer, nor an entityType configured on the endpoint so cannot consume"");
            }
        }
        return queryFactory;
    }
    public void setQueryFactory(QueryFactory queryFactory) {
        this.queryFactory = queryFactory;
    }
    public DeleteHandler getDeleteHandler() {
        if (deleteHandler == null) {
            deleteHandler = createDeleteHandler();
        }
        return deleteHandler;
    }
    public void setDeleteHandler(DeleteHandler deleteHandler) {
        this.deleteHandler = deleteHandler;
    }
    public String getNamedQuery() {
        return namedQuery;
    }
    public void setNamedQuery(String namedQuery) {
        this.namedQuery = namedQuery;
    }
    public String getNativeQuery() {
        return nativeQuery;
    }
    public void setNativeQuery(String nativeQuery) {
        this.nativeQuery = nativeQuery;
    }
    public String getQuery() {
        return query;
    }
    public void setQuery(String query) {
        this.query = query;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A strategy method to lock an object with an exclusive lock so that it can
     * be processed
     * 
     * @param entity the entity to be locked
     * @param entityManager
     * @return true if the entity was locked
     */
    protected boolean lockEntity(Object entity, EntityManager entityManager) {
        if (!getEndpoint().isConsumeDelete() || !getEndpoint().isConsumeLockEntity()) {
            return true;
        }
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Acquiring exclusive lock on entity: "" + entity);
            }
            entityManager.lock(entity, LockModeType.WRITE);
            return true;
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Failed to achieve lock on entity: "" + entity + "". Reason: "" + e, e);
            }
            return false;
        }
    }
    protected QueryFactory createQueryFactory() {
        if (query != null) {
            return QueryBuilder.query(query);
        } else if (namedQuery != null) {
            return QueryBuilder.namedQuery(namedQuery);
        } else if (nativeQuery != null) {
            return QueryBuilder.nativeQuery(nativeQuery);
        } else {
            Class<?> entityType = endpoint.getEntityType();
            if (entityType == null) {
                return null;
            } else {
                return QueryBuilder.query(""select x from "" + entityType.getName() + "" x"");
            }
        }
    }
    protected DeleteHandler<Object> createDeleteHandler() {
        // TODO auto-discover an annotation in the entity bean to indicate the
        // process completed method call?
        Class<?> entityType = getEndpoint().getEntityType();
        if (entityType != null) {
            List<Method> methods = ObjectHelper.findMethodsWithAnnotation(entityType, Consumed.class);
            if (methods.size() > 1) {
                throw new IllegalArgumentException(""Only one method can be annotated with the @Consumed annotation but found: "" + methods);
            } else if (methods.size() == 1) {
                final Method method = methods.get(0);
                return new DeleteHandler<Object>() {
                    public void deleteObject(EntityManager entityManager, Object entityBean) {
                        ObjectHelper.invokeMethod(method, entityBean);
                    }
                };
            }
        }
        if (getEndpoint().isConsumeDelete()) {
            return new DeleteHandler<Object>() {
                public void deleteObject(EntityManager entityManager, Object entityBean) {
                    entityManager.remove(entityBean);
                }
            };
        } else {
            return new DeleteHandler<Object>() {
                public void deleteObject(EntityManager entityManager, Object entityBean) {
                    // do nothing
                }
            };
        }
    }
    protected void configureParameters(Query query) {
        int maxResults = endpoint.getMaximumResults();
        if (maxResults > 0) {
            query.setMaxResults(maxResults);
        }
    }
    protected Exchange createExchange(Object result) {
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setBody(result);
        return exchange;
    }
}
"
org.apache.camel.component.rmi.RmiConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.rmi.Remote;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.component.bean.BeanInvocation;
import org.apache.camel.impl.DefaultConsumer;
/**
 * A {@link org.apache.camel.Consumer Consumer} which uses RMI's {@link UnicastRemoteObject} to consume
 * method invocations.
 * 
 * @version $Revision$
 */
public class RmiConsumer extends DefaultConsumer<BeanExchange> implements InvocationHandler {
    private final RmiEndpoint endpoint;
    private Remote stub;
    private Remote proxy;
    public RmiConsumer(RmiEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        Class[] interfaces = new Class[endpoint.getRemoteInterfaces().size()];
        endpoint.getRemoteInterfaces().toArray(interfaces);
        proxy = (Remote)Proxy.newProxyInstance(endpoint.getClassLoader(), interfaces, this);
        stub = UnicastRemoteObject.exportObject(proxy, endpoint.getPort());
        try {
            Registry registry = endpoint.getRegistry();
            String name = endpoint.getName();
            registry.bind(name, stub);
        } catch (Exception e) { // Registration might fail.. clean up..
            try {
                UnicastRemoteObject.unexportObject(stub, true);
            } catch (Throwable ignore) {
            }
            stub = null;
            throw e;
        }
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        try {
            Registry registry = endpoint.getRegistry();
            registry.unbind(endpoint.getName());
        } catch (Throwable e) { // do our best to unregister
        }
        UnicastRemoteObject.unexportObject(proxy, true);
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (!isStarted()) {
            throw new IllegalStateException(""The endpoint is not active: "" + getEndpoint().getEndpointUri());
        }
        BeanInvocation invocation = new BeanInvocation(method, args);
        BeanExchange exchange = getEndpoint().createExchange();
        exchange.setInvocation(invocation);
        getProcessor().process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        return exchange.getOut().getBody();
    }
    public Remote getProxy() {
        return proxy;
    }
    public Remote getStub() {
        return stub;
    }
}
"
org.apache.camel.spring.spi.SpringTransactionPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * Wraps the processor in a Spring transaction
 *
 * @version $Revision$
 */
public class SpringTransactionPolicy<E> implements Policy<E> {
    private static final transient Log LOG = LogFactory.getLog(SpringTransactionPolicy.class);
    private TransactionTemplate template;
    private String propagationBehaviorName;
    private PlatformTransactionManager transactionManager;
    /**
     * Default constructor for easy spring configuration.
     */
    public SpringTransactionPolicy() {
    }
    public SpringTransactionPolicy(TransactionTemplate template) {
        this.template = template;
    }
    public Processor wrap(Processor processor) {
        final TransactionTemplate transactionTemplate = getTemplate();
        if (transactionTemplate == null) {
            LOG.warn(""No TransactionTemplate available so transactions will not be enabled!"");
            return processor;
        }
        TransactionInterceptor answer = new TransactionInterceptor(transactionTemplate);
        answer.setProcessor(processor);
        return answer;
    }
    public TransactionTemplate getTemplate() {
        if (template == null) {
            template = new TransactionTemplate(transactionManager);
            if (propagationBehaviorName != null) {
                template.setPropagationBehaviorName(propagationBehaviorName);
            }
        }
        return template;
    }
    public void setTemplate(TransactionTemplate template) {
        this.template = template;
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }
    public void setPropagationBehaviorName(String propagationBehaviorName) {
        this.propagationBehaviorName = propagationBehaviorName;
    }
    public String getPropagationBehaviorName() {
        return propagationBehaviorName;
    }
}
"
org.apache.camel.spring.SpringCamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.event.EventComponent;
import org.apache.camel.component.event.EventEndpoint;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Registry;
import org.apache.camel.spring.spi.ApplicationContextRegistry;
import org.apache.camel.spring.spi.SpringInjector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.support.ClassPathXmlApplicationContext;
/**
 * A Spring aware implementation of {@link org.apache.camel.CamelContext} which
 * will automatically register itself with Springs lifecycle methods plus allows
 * spring to be used to customize a any <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * as well as supporting accessing components and beans via the Spring
 * {@link ApplicationContext}
 *
 * @version $Revision$
 */
public class SpringCamelContext extends DefaultCamelContext implements InitializingBean, DisposableBean,
    ApplicationContextAware, ApplicationListener {
    private static final transient Log LOG = LogFactory.getLog(SpringCamelContext.class);
    private ApplicationContext applicationContext;
    private EventEndpoint eventEndpoint;
    public SpringCamelContext() {
    }
    public SpringCamelContext(ApplicationContext applicationContext) {
        setApplicationContext(applicationContext);
    }
    public static SpringCamelContext springCamelContext(ApplicationContext applicationContext)
        throws Exception {
        // lets try and look up a configured camel context in the context
        String[] names = applicationContext.getBeanNamesForType(SpringCamelContext.class);
        if (names.length == 1) {
            return (SpringCamelContext)applicationContext.getBean(names[0], SpringCamelContext.class);
        }
        SpringCamelContext answer = new SpringCamelContext();
        answer.setApplicationContext(applicationContext);
        answer.afterPropertiesSet();
        return answer;
    }
    public static SpringCamelContext springCamelContext(String configLocations) throws Exception {
        return springCamelContext(new ClassPathXmlApplicationContext(configLocations));
    }
    public void afterPropertiesSet() throws Exception {
        start();
    }
    public void destroy() throws Exception {
        stop();
    }
    public void onApplicationEvent(ApplicationEvent event) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Publishing event: "" + event);
        }
        if (event instanceof ContextRefreshedEvent) {
            // now lets start the CamelContext so that all its possible
            // dependencies are initailized
            try {
                LOG.debug(""Starting the CamelContext now that the ApplicationContext has started"");
                start();
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
            if (eventEndpoint != null) {
                eventEndpoint.onApplicationEvent(event);
            }
        } else {
            if (eventEndpoint != null) {
                eventEndpoint.onApplicationEvent(event);
            } else {
                LOG.warn(""No eventEndpoint enabled for event: "" + event);
            }
        }
    }
    // Properties
    // -----------------------------------------------------------------------
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        if (applicationContext instanceof ConfigurableApplicationContext) {
            addComponent(""event"", new EventComponent(applicationContext));
        }
    }
    public EventEndpoint getEventEndpoint() {
        return eventEndpoint;
    }
    public void setEventEndpoint(EventEndpoint eventEndpoint) {
        this.eventEndpoint = eventEndpoint;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (eventEndpoint == null) {
            eventEndpoint = createEventEndpoint();
        }
    }
    @Override
    protected Injector createInjector() {
        if (applicationContext instanceof ConfigurableApplicationContext) {
            return new SpringInjector((ConfigurableApplicationContext)applicationContext);
        } else {
            LOG.warn(""Cannot use SpringInjector as applicationContext is not a ConfigurableApplicationContext as its: ""
                      + applicationContext);
            return super.createInjector();
        }
    }
    protected EventEndpoint createEventEndpoint() {
        EventEndpoint endpoint = getEndpoint(""event:default"", EventEndpoint.class);
        return endpoint;
    }
    protected Endpoint convertBeanToEndpoint(String uri, Object bean) {
        //We will use the type convert to build the endpoint first
        Endpoint endpoint = getTypeConverter().convertTo(Endpoint.class, bean);
        if (endpoint != null) {
            endpoint.setCamelContext(this);
            return endpoint;
        }
        Processor processor = new BeanProcessor(bean, this);
        return new ProcessorEndpoint(uri, this, processor);
    }
    @Override
    protected Registry createRegistry() {
        return new ApplicationContextRegistry(getApplicationContext());
    }
}
"
org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.component.spring.integration.SpringIntegrationBinding;
import org.apache.camel.component.spring.integration.SpringIntegrationExchange;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.integration.message.Message;
/**
 * CamelTargeAdapter will redirect the Spring Integration message to the Camel context.
 * When we inject the camel context into it, we need also specify the Camel endpoint url
 * we will route the Spring Integration message to the Camel context
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelTargetAdapter extends AbstractCamelAdapter {
    private final Log logger = LogFactory.getLog(this.getClass());
    private ProducerTemplate<Exchange> camelTemplate;
    private Endpoint camelEndpoint;
    public ProducerTemplate<Exchange> getCamelTemplate() {
        if (camelTemplate == null) {
            CamelContext ctx = getCamelContext();
            if (ctx == null) {
                ctx = new DefaultCamelContext();
            }
            camelTemplate = ctx.createProducerTemplate();
        }
        return camelTemplate;
    }
    public Message<?> handle(Message<?> request) {
        ExchangePattern pattern;
        if (isExpectReply()) {
            pattern = ExchangePattern.InOut;
        } else {
            pattern = ExchangePattern.InOnly;
        }
        Exchange inExchange = new SpringIntegrationExchange(getCamelContext(), pattern);
        SpringIntegrationBinding.storeToCamelMessage(request, inExchange.getIn());
        Exchange outExchange = getCamelTemplate().send(getCamelEndpointUri(), inExchange);
        Message response = null;
        if (isExpectReply()) {
            response = SpringIntegrationBinding.storeToSpringIntegrationMessage(outExchange.getOut());
        }
        return response;
    }
}
"
org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.spring.integration.SpringIntegrationBinding;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.integration.ConfigurationException;
import org.springframework.integration.bus.MessageBus;
import org.springframework.integration.bus.MessageBusAware;
import org.springframework.integration.channel.MessageChannel;
import org.springframework.integration.gateway.RequestReplyTemplate;
import org.springframework.integration.message.Message;
/**
 * A CamelContext will be injected into CameSourceAdapter which will
 * let Spring Integration channel talk to the CamelContext certain endpoint
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelSourceAdapter extends AbstractCamelAdapter implements InitializingBean, MessageBusAware {
    protected final Object lifecycleMonitor = new Object();
    private final Log logger = LogFactory.getLog(this.getClass());
    private Consumer consumer;
    private Endpoint camelEndpoint;
    private MessageChannel requestChannel;
    private RequestReplyTemplate requestReplyTemplate = new RequestReplyTemplate();
    private volatile boolean initialized;
    public void setRequestChannel(MessageChannel channel) {
        requestChannel = channel;
        requestReplyTemplate.setRequestChannel(requestChannel);
    }
    public MessageChannel getChannel() {
        return requestChannel;
    }
    public void setReplyChannel(MessageChannel channel) {
        requestReplyTemplate.setReplyChannel(channel);
    }
    public void setRequestTimeout(long requestTimeout) {
        this.requestReplyTemplate.setRequestTimeout(requestTimeout);
    }
    public void setReplyTimeout(long replyTimeout) {
        this.requestReplyTemplate.setReplyTimeout(replyTimeout);
    }
    private void incoming(Exchange exchange) {
        org.springframework.integration.message.Message request =
            SpringIntegrationBinding.createSpringIntegrationMessage(exchange);
        org.springframework.integration.message.Message response = handle(request);
        if (response != null) {
            // TODO How to deal with the fault message
            SpringIntegrationBinding.storeToCamelMessage(response, exchange.getOut());
        }
    }
    protected class ConsumerProcessor implements Processor {
        public void process(Exchange exchange) {
            try {
                incoming(exchange);
            } catch (Throwable ex) {
                ex.printStackTrace();
                logger.warn(""Failed to process incoming message : "" + ex);
                //TODO Maybe we should set the exception as the fault message
            }
        }
    }
    public final void afterPropertiesSet() throws Exception {
        synchronized (this.lifecycleMonitor) {
            if (this.initialized) {
                return;
            }
        }
        this.initialize();
        this.initialized = true;
    }
    protected void initialize() throws Exception {
        // start the service here
        camelEndpoint = getCamelContext().getEndpoint(getCamelEndpointUri());
        consumer = camelEndpoint.createConsumer(new ConsumerProcessor());
        consumer.start();
    }
    public final Message<?> handle(Message<?> message) {
        if (!this.initialized) {
            try {
                this.afterPropertiesSet();
            } catch (Exception e) {
                throw new ConfigurationException(""unable to initialize "" + this.getClass().getName(), e);
            }
        }
        if (!isExpectReply()) {
            boolean sent = this.requestReplyTemplate.send(message);
            if (!sent && logger.isWarnEnabled()) {
                logger.warn(""failed to send message to channel within timeout"");
            }
            return null;
        }
        return this.requestReplyTemplate.request(message);
    }
    public void setMessageBus(MessageBus bus) {
        requestReplyTemplate.setMessageBus(bus);
    }
}
"
org.apache.camel.spring.EndpointFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.model.IdentifiedType;
import org.springframework.beans.factory.FactoryBean;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A {@link FactoryBean} which instantiates {@link Endpoint} objects
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""endpoint"")
@XmlAccessorType(XmlAccessType.FIELD)
public class EndpointFactoryBean extends IdentifiedType implements FactoryBean, CamelContextAware {
    @XmlAttribute
    private String uri;
    @XmlTransient
    private CamelContext context;
    @XmlTransient
    private Endpoint endpoint;
    @XmlTransient
    private boolean singleton;
    public Object getObject() throws Exception {
        if (endpoint == null) {
            endpoint = createEndpoint();
        }
        return endpoint;
    }
    public Class getObjectType() {
        return Endpoint.class;
    }
    public boolean isSingleton() {
        return singleton;
    }
    public CamelContext getCamelContext() {
        return context;
    }
    /**
     * Sets the context to use to resolve endpoints
     *
     * @param context the context used to resolve endpoints
     */
    public void setCamelContext(CamelContext context) {
        this.context = context;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public void setSingleton(boolean singleton) {
        this.singleton = singleton;
    }
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI to use to resolve the endpoint
     *
     * @param uri the URI used to set the endpoint
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    protected Endpoint createEndpoint() {
        notNull(context, ""context"");
        notNull(uri, ""uri"");
        Endpoint endpoint = context.getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.camel.util.ObjectHelper;
import org.springframework.integration.channel.ChannelRegistry;
import org.springframework.integration.channel.MessageChannel;
import org.springframework.integration.config.MessageBusParser;
/**
 * A consumer of exchanges for the Spring Integration
 * Please specify the inputChannel in the endpoint url for this consumer.
 * If the message pattern is inOut, the outputChannel property
 * should be set for the outgoing message.
 *
 * @version $Revision$
 */
public class SpringIntegrationConsumer  extends ScheduledPollConsumer<SpringIntegrationExchange> {
    private SpringCamelContext context;
    private MessageChannel inputChannel;
    private MessageChannel outputChannel;
    private String inputChannelName;
    private ChannelRegistry channelRegistry;
    private SpringIntegrationEndpoint endpoint;
    public SpringIntegrationConsumer(SpringIntegrationEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        context = (SpringCamelContext) endpoint.getCamelContext();
        if (context != null && endpoint.getMessageChannel() == null) {
            channelRegistry = (ChannelRegistry) context.getApplicationContext().getBean(MessageBusParser.MESSAGE_BUS_BEAN_NAME);
            inputChannelName = endpoint.getDefaultChannel();
            if (ObjectHelper.isNullOrBlank(inputChannelName)) {
                inputChannelName = endpoint.getInputChannel();
            }
            if (!ObjectHelper.isNullOrBlank(inputChannelName)) {
                inputChannel = (MessageChannel) channelRegistry.lookupChannel(inputChannelName);
                ObjectHelper.notNull(inputChannel, ""The inputChannel with the name ["" + inputChannelName + ""]"");
            } else {
                throw new RuntimeCamelException(""Can't find the right inputChannelName, , please check your configuration."");
            }
        } else {
            if (endpoint.getMessageChannel() != null) {
                inputChannel = endpoint.getMessageChannel();
            } else {
                throw new RuntimeCamelException(""Can't find the right message channel, please check your configuration."");
            }
        }
        if (endpoint.isInOut()) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
        }
    }
    @Override
    protected void poll() throws Exception {
        org.springframework.integration.message.Message siInMessage = inputChannel.receive(this.getDelay());
        SpringIntegrationExchange  exchange = getEndpoint().createExchange();
        exchange.setIn(new SpringIntegrationMessage(siInMessage));
        getProcessor().process(exchange);
        if (endpoint.isInOut()) {
            // get the output channel from message header
            Object returnAddress = siInMessage.getHeader().getReturnAddress();
            MessageChannel reply = null;
            if (returnAddress != null) {
                if (returnAddress instanceof String) {
                    reply = (MessageChannel)context.getApplicationContext().getBean((String)returnAddress);
                } else if (returnAddress instanceof MessageChannel) {
                    reply = (MessageChannel) returnAddress;
                }
            } else {
                if (outputChannel != null) {
                    // using the outputChannel
                    reply = outputChannel;
                } else {
                    if (ObjectHelper.isNullOrBlank(endpoint.getOutputChannel())) {
                        outputChannel = (MessageChannel) channelRegistry.lookupChannel(endpoint.getOutputChannel());
                        ObjectHelper.notNull(inputChannel, ""The outputChannel with the name ["" + endpoint.getOutputChannel() + ""]"");
                        reply = outputChannel;
                    } else {
                        throw new RuntimeCamelException(""Can't find the right outputChannelName"");
                    }
                }
            }
            // put the message back the outputChannel if we need
            org.springframework.integration.message.Message siOutMessage =
                SpringIntegrationBinding.storeToSpringIntegrationMessage(exchange.getOut());
            reply.send(siOutMessage);
        }
    }
    //TODO We need to clean the channel when shutdown the endpoint
}
"
org.apache.camel.component.cxf.transport.CamelConstants,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
/**
 * @version $Revision$
 */
public final class CamelConstants {
    public static final String TEXT_MESSAGE_TYPE = ""text"";
    public static final String BINARY_MESSAGE_TYPE = ""binary"";
    public static final String CAMEL_TARGET_ENDPOINT_URI = ""org.apache.cxf.camel.target.endpoint.uri"";
    public static final String CAMEL_SERVER_REQUEST_HEADERS = ""org.apache.cxf.camel.server.request.headers"";
    public static final String CAMEL_SERVER_RESPONSE_HEADERS = ""org.apache.cxf.camel.server.response.headers"";
    public static final String CAMEL_REQUEST_MESSAGE = ""org.apache.cxf.camel.request.message"";
    public static final String CAMEL_RESPONSE_MESSAGE = ""org.apache.cxf.camel.reponse.message"";
    public static final String CAMEL_CLIENT_REQUEST_HEADERS = ""org.apache.cxf.camel.template.request.headers"";
    public static final String CAMEL_CLIENT_RESPONSE_HEADERS =
            ""org.apache.cxf.camel.template.response.headers"";
    public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = ""org.apache.cxf.camel.template.timeout"";
    public static final String CAMEL_SERVER_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-server"";
    public static final String CAMEL_CLIENT_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-template"";
    public static final String ENDPOINT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/endpoint-config"";
    public static final String SERVICE_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/service-config"";
    public static final String PORT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/port-config"";
    public static final String CAMEL_CLIENT_CONFIG_ID = ""camel-template"";
    public static final String CAMEL_SERVER_CONFIG_ID = ""camel-server"";
    public static final String CAMEL_REBASED_REPLY_TO = ""org.apache.cxf.camel.server.replyto"";
    public static final String CAMEL_CORRELATION_ID = ""org.apache.cxf.camel.correlationId"";
    private CamelConstants() {
        // Utility class
    }
}
"
org.apache.camel.spring.RouteBuilderFinder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.ResolverUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
/**
 * A helper class which will find all {@link RouteBuilder} instances on the classpath
 *
 * @version $Revision$
 */
public class RouteBuilderFinder {
    private static final transient Log LOG = LogFactory.getLog(RouteBuilderFinder.class);
    private final SpringCamelContext camelContext;
    private final String[] packages;
    private ApplicationContext applicationContext;
    private ResolverUtil resolver = new ResolverUtil();
    private BeanPostProcessor beanPostProcessor;
    public RouteBuilderFinder(SpringCamelContext camelContext, String[] packages, ClassLoader classLoader, BeanPostProcessor postProcessor) {
        this.camelContext = camelContext;
        this.applicationContext = camelContext.getApplicationContext();
        this.packages = packages;
        this.beanPostProcessor = postProcessor;
        // lets add all the available class loaders just in case of weirdness
        // we could make this more strict once we've worked out all the gremlins
        // in servicemix-camel
        Set set = resolver.getClassLoaders();
        set.clear();
        set.add(classLoader);
/*
        set.add(classLoader);
        set.add(applicationContext.getClassLoader());
        set.add(getClass().getClassLoader());
*/
    }
    public String[] getPackages() {
        return packages;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    /**
     * Appends all the {@link RouteBuilder} instances that can be found on the classpath
     */
    public void appendBuilders(List<RouteBuilder> list) throws IllegalAccessException, InstantiationException {
        resolver.findImplementations(RouteBuilder.class, packages);
        Set<Class> classes = resolver.getClasses();
        for (Class aClass : classes) {
            if (shouldIgnoreBean(aClass)) {
                continue;
            }
            if (isValidClass(aClass)) {
                RouteBuilder builder = instantiateBuilder(aClass);
                if (beanPostProcessor != null) {
                    // Inject the annotated resource
                    beanPostProcessor.postProcessBeforeInitialization(builder, builder.toString());
                }
                list.add(builder);
            }
        }
    }
    public void destroy() throws Exception {
    }
    /**
     * Lets ignore beans that are not explicitly configured in the spring.xml
     */
    protected boolean shouldIgnoreBean(Class type) {
        Map beans = applicationContext.getBeansOfType(type, true, true);
        if (beans == null || beans.isEmpty()) {
            return false;
        }
        // TODO apply some filter?
        return true;
    }
    /**
     * Returns true if the object is non-abstract and supports a zero argument constructor
     */
    protected boolean isValidClass(Class type) {
        if (!Modifier.isAbstract(type.getModifiers()) && !type.isInterface()) {
            return true;
        }
        return false;
    }
    protected RouteBuilder instantiateBuilder(Class type) throws IllegalAccessException, InstantiationException {
        return (RouteBuilder) camelContext.getInjector().newInstance(type);
    }
}"
org.apache.camel.bam.model.EntitySupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
/**
 * A base class for persistent entities
 *
 * @version $Revision$
 */
public class EntitySupport {
    private Long id;
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String toString() {
        return getClass().getName() + ""["" + id + ""]"";
    }
}
"
org.apache.camel.component.http.HttpExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Represents a HTTP exchange which exposes the underlying HTTP abtractions via
 * {@link #getRequest()} and {@link #getResponse()}
 *
 * @version $Revision$
 */
public class HttpExchange extends DefaultExchange {
    private final HttpEndpoint endpoint;
    private HttpServletRequest request;
    private HttpServletResponse response;
    public HttpExchange(HttpEndpoint endpoint, ExchangePattern pattern) {
        super(endpoint.getCamelContext(), pattern);
        this.endpoint = endpoint;
    }
    public HttpExchange(HttpEndpoint endpoint, HttpServletRequest request, HttpServletResponse response) {
        this(endpoint, getPatternFromRequest(request));
        this.request = request;
        this.response = response;
        setIn(new HttpMessage(this, request));
    }
    /**
     * Returns the underlying Servlet request for inbound HTTP requests
     *
     * @return the underlying Servlet request for inbound HTTP requests
     */
    public HttpServletRequest getRequest() {
        return request;
    }
    /**
     * Returns the underlying Servlet response for inbound HTTP requests
     *
     * @return the underlying Servlet response for inbound HTTP requests
     */
    public HttpServletResponse getResponse() {
        return response;
    }
    public HttpEndpoint getEndpoint() {
        return endpoint;
    }
    protected static ExchangePattern getPatternFromRequest(HttpServletRequest request) {
        // TODO for now just default to InOut?
        return ExchangePattern.InOut;
    }
}
"
org.apache.camel.language.juel.JuelLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * The <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
 * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
 *
 * @version $Revision$
 */
public class JuelLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return new JuelExpression(expression, Boolean.class);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new JuelExpression(expression, Object.class);
    }
}
"
org.apache.camel.component.jcr.JcrConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import java.io.InputStream;
import java.util.Calendar;
import javax.jcr.Value;
import org.apache.camel.Converter;
import org.apache.jackrabbit.value.BinaryValue;
import org.apache.jackrabbit.value.BooleanValue;
import org.apache.jackrabbit.value.DateValue;
import org.apache.jackrabbit.value.StringValue;
/**
 * A helper class to transform Object into JCR {@link Value} implementations 
 */
@Converter
public class JcrConverter {
    /**
     * Converts a {@link Boolean} into a {@link Value}
     * @param bool the boolean
     * @return the value
     */
    @Converter
    public Value toValue(Boolean bool) {
        return new BooleanValue(bool);
    }
    /**
     * Converts an {@link InputStream} into a {@link Value}
     * @param stream the input stream
     * @return the value
     */
    @Converter
    public Value toValue(InputStream stream) {
        return new BinaryValue(stream);
    }
    /**
     * Converts a {@link Calendar} into a {@link Value}
     * @param calendar the calendar
     * @return the value
     */
    @Converter
    public Value toValue(Calendar calendar) {
        return new DateValue(calendar);
    }
    /**
     * Converts a {@link String} into a {@link Value}
     * @param value the string
     * @return the value
     */
    @Converter
    public Value toValue(String value) {
        return new StringValue(value);
    }
}
"
org.apache.camel.component.cxf.CxfConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.ArrayList;
import java.util.List;
import javax.xml.ws.WebServiceProvider;
import org.apache.camel.Processor;
import org.apache.camel.component.cxf.feature.MessageDataFormatFeature;
import org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.bus.spring.SpringBusFactory;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.feature.AbstractFeature;
import org.apache.cxf.frontend.ServerFactoryBean;
/**
 * A consumer of exchanges for a service in CXF
 *
 * @version $Revision$
 */
public class CxfConsumer extends DefaultConsumer<CxfExchange> {
    private CxfEndpoint endpoint;
    private Server server;
    public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {
        super(endpoint, processor);
        Bus bus = null;
        this.endpoint = endpoint;
        boolean isWebServiceProvider = false;
        if (endpoint.getApplicationContext() != null) {
            SpringBusFactory bf = new SpringBusFactory(endpoint.getApplicationContext());
            bus = bf.createBus();
            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {
                BusFactory.setDefaultBus(bus);
            }
        } else {
            // now we just use the default bus here
            bus = BusFactory.getDefaultBus();
        }
        ServerFactoryBean svrBean = null;
        if (endpoint.isSpringContextEndpoint()) {
            CxfEndpointBean endpointBean = endpoint.getCxfEndpointBean();
            svrBean = CxfEndpointUtils.getServerFactoryBean(endpointBean.getServiceClass());
            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(endpointBean.getServiceClass(),
                                                                  WebServiceProvider.class);
            endpoint.configure(svrBean);
        } else { // setup the serverFactoryBean with the URI parameters
            Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());
            svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);
            isWebServiceProvider = CxfEndpointUtils.hasAnnotation(serviceClass, WebServiceProvider.class);
            svrBean.setAddress(endpoint.getAddress());
            svrBean.setServiceClass(serviceClass);
            if (endpoint.getServiceName() != null) {
                svrBean.setServiceName(CxfEndpointUtils.getServiceName(endpoint));
            }
            if (endpoint.getPortName() != null) {
                svrBean.setEndpointName(CxfEndpointUtils.getPortName(endpoint));
            }
            if (endpoint.getWsdlURL() != null) {
                svrBean.setWsdlURL(endpoint.getWsdlURL());
            }
        }
        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        svrBean.setInvoker(new CamelInvoker(this));
        // apply feature here
        if (!dataFormat.equals(DataFormat.POJO) && !isWebServiceProvider) {
            List<AbstractFeature> features = new ArrayList<AbstractFeature>();
            if (dataFormat.equals(DataFormat.PAYLOAD)) {
                features.add(new PayLoadDataFormatFeature());
                // adding the logging feature here for debug
                //features.add(new LoggingFeature());
            } else if (dataFormat.equals(DataFormat.MESSAGE)) {
                features.add(new MessageDataFormatFeature());
                //features.add(new LoggingFeature());
            }
            svrBean.setFeatures(features);
        }
        svrBean.setBus(bus);
        svrBean.setStart(false);
        server = svrBean.create();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        server.start();
    }
    @Override
    protected void doStop() throws Exception {
        server.stop();
        super.doStop();
    }
    public CxfEndpoint getEndpoint() {
        return endpoint;
    }
}
"
org.apache.camel.component.atom.UpdatedDateFilter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.util.Date;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Filters out all entries which occur before the last time of the entry we saw (assuming
 * entries arrive sorted in order).
 *
 * @version $Revision$
 */
public class UpdatedDateFilter implements EntryFilter {
    private static final transient Log LOG = LogFactory.getLog(UpdatedDateFilter.class);
    private Date lastUpdate;
    public UpdatedDateFilter(Date lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
    public boolean isValidEntry(AtomEndpoint endpoint, Document<Feed> feed, Entry entry) {
        Date updated = entry.getUpdated();
        if (updated == null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""No updated time for entry so assuming its valid: entry=["" + entry + ""]"");
            }
            return true;
        }
        if (lastUpdate != null) {
            if (lastUpdate.after(updated)) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Entry is older than lastupdate=["" + lastUpdate
                        + ""], no valid entry=["" + entry + ""]"");
                }
                return false;
            }
        }
        lastUpdate = updated;
        return true;
    }
}
"
org.apache.camel.builder.script.Python,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of Python expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""python"")
public @interface Python {
    String value();
}"
org.apache.camel.component.quartz.QuartzEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.util.Date;
import java.util.Map;
import java.util.Set;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.JobDetail;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SimpleTrigger;
import org.quartz.Trigger;
/**
 * A <a href=""http://activemq.apache.org/quartz.html"">Quartz Endpoint</a>
 *
 * @version $Revision:520964 $
 */
public class QuartzEndpoint extends DefaultEndpoint<QuartzExchange> {
    public static final String ENDPOINT_KEY = ""org.apache.camel.quartz"";
    private static final transient Log LOG = LogFactory.getLog(QuartzEndpoint.class);
    private Scheduler scheduler;
    private LoadBalancer loadBalancer;
    private Trigger trigger;
    private JobDetail jobDetail;
    private boolean started;
    public QuartzEndpoint(String endpointUri, QuartzComponent component, Scheduler scheduler) {
        super(endpointUri, component);
        this.scheduler = scheduler;
    }
    public QuartzEndpoint(String endpointUri, Scheduler scheduler) {
        super(endpointUri);
        this.scheduler = scheduler;
    }
    public void addTriggers(Map<Trigger, JobDetail> triggerMap) throws SchedulerException {
        if (triggerMap != null) {
            Set<Map.Entry<Trigger, JobDetail>> entries = triggerMap.entrySet();
            for (Map.Entry<Trigger, JobDetail> entry : entries) {
                Trigger key = entry.getKey();
                JobDetail value = entry.getValue();
                ObjectHelper.notNull(key, ""key"");
                ObjectHelper.notNull(value, ""value"");
                addTrigger(key, value);
            }
        }
    }
    public void addTrigger(Trigger trigger, JobDetail detail) throws SchedulerException {
        // lets default the trigger name to the job name
        if (trigger.getName() == null) {
            trigger.setName(detail.getName());
        }
        // lets default the trigger group to the job group
        if (trigger.getGroup() == null) {
            trigger.setGroup(detail.getGroup());
        }
        // default start time to now if not specified
        if (trigger.getStartTime() == null) {
            trigger.setStartTime(new Date());
        }
        detail.getJobDataMap().put(ENDPOINT_KEY, this);
        Class jobClass = detail.getJobClass();
        if (jobClass == null) {
            detail.setJobClass(CamelJob.class);
        }
        if (detail.getName() == null) {
            detail.setName(getEndpointUri());
        }
        getScheduler().scheduleJob(detail, trigger);
    }
    public void removeTrigger(Trigger trigger, JobDetail jobDetail) throws SchedulerException {
        getScheduler().unscheduleJob(trigger.getName(), trigger.getGroup());
    }
    /**
     * This method is invoked when a Quartz job is fired.
     *
     * @param jobExecutionContext the Quartz Job context
     */
    public void onJobExecute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Firing Quartz Job with context: "" + jobExecutionContext);
        }
        QuartzExchange exchange = createExchange(jobExecutionContext);
        try {
            getLoadBalancer().process(exchange);
        } catch (JobExecutionException e) {
            throw e;
        } catch (Exception e) {
            throw new JobExecutionException(e);
        }
    }
    @Override
    public QuartzExchange createExchange(ExchangePattern pattern) {
        return new QuartzExchange(getCamelContext(), pattern, null);
    }
    public QuartzExchange createExchange(JobExecutionContext jobExecutionContext) {
        return new QuartzExchange(getCamelContext(), getExchangePattern(), jobExecutionContext);
    }
    public Producer<QuartzExchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""You cannot send messages to this endpoint"");
    }
    public QuartzConsumer createConsumer(Processor processor) throws Exception {
        return new QuartzConsumer(this, processor);
    }
    // Properties
    // -------------------------------------------------------------------------
    @Override
    public QuartzComponent getComponent() {
        return (QuartzComponent)super.getComponent();
    }
    public boolean isSingleton() {
        return true;
    }
    public Scheduler getScheduler() {
        return scheduler;
    }
    public LoadBalancer getLoadBalancer() {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer();
        }
        return loadBalancer;
    }
    public void setLoadBalancer(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    public JobDetail getJobDetail() {
        if (jobDetail == null) {
            jobDetail = createJobDetail();
        }
        return jobDetail;
    }
    public void setJobDetail(JobDetail jobDetail) {
        this.jobDetail = jobDetail;
    }
    public Trigger getTrigger() {
        if (trigger == null) {
            trigger = createTrigger();
        }
        return trigger;
    }
    public void setTrigger(Trigger trigger) {
        this.trigger = trigger;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public synchronized void consumerStarted(QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().addProcessor(consumer.getProcessor());
        // if we have not yet added our default trigger, then lets do it
        if (!started) {
            addTrigger(getTrigger(), getJobDetail());
            started = true;
        }
    }
    public synchronized void consumerStopped(QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().removeProcessor(consumer.getProcessor());
        if (getLoadBalancer().getProcessors().isEmpty() && started) {
            removeTrigger(getTrigger(), getJobDetail());
            started = false;
        }
    }
    protected LoadBalancer createLoadBalancer() {
        return new RoundRobinLoadBalancer();
    }
    protected JobDetail createJobDetail() {
        return new JobDetail();
    }
    protected Trigger createTrigger() {
        return new SimpleTrigger();
    }
}
"
org.apache.camel.osgi.OsgiComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.io.BufferedInputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.spi.ComponentResolver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.SynchronousBundleListener;
import org.springframework.osgi.util.BundleDelegatingClassLoader;
public class OsgiComponentResolver implements ComponentResolver {
    private static final transient Log LOG = LogFactory.getLog(OsgiComponentResolver.class);
    private BundleContext bundleContext;
    private Map<String, ComponentEntry> components;
    private class BundleListener implements SynchronousBundleListener {
        public void bundleChanged(BundleEvent event) {
            try {
                Bundle bundle = event.getBundle();
                if (event.getType() == BundleEvent.RESOLVED) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Bundle resolved: "" + bundle.getSymbolicName());
                    }
                    mayBeAddComponentFor(bundle);
                } else if (event.getType() == BundleEvent.UNRESOLVED) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Bundle unresolved: "" + bundle.getSymbolicName());
                    }
                    mayBeRemoveComponentFor(bundle);
                }
            } catch (Throwable e) {
                LOG.fatal(""Exception handing bundle changed event"", e);
            }
        }
    }
    private class ComponentEntry {
        Bundle bundle;
        String path;
        String name;
        Class type;
    }
    public OsgiComponentResolver(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }
    protected void init() {
        if (components != null) {
            return;
        }
        LOG.debug(""Initializing OsgiComponentResolver"");
        components = new HashMap<String, ComponentEntry>();
        bundleContext.addBundleListener(new BundleListener());
        Bundle[] previousBundles = bundleContext.getBundles();
        for (int i = 0; i < previousBundles.length; i++) {
            int state = previousBundles[i].getState();
            if (state == Bundle.RESOLVED || state == Bundle.ACTIVE) {
                try {
                    mayBeAddComponentFor(previousBundles[i]);
                } catch (Exception e) {
                    LOG.error(""Component "" + previousBundles[i] + "" not added due to "" + e.toString(), e);
                }
            }
        }
    }
    protected synchronized void mayBeAddComponentFor(Bundle bundle) {
        Enumeration e = bundle.getEntryPaths(""/META-INF/services/org/apache/camel/component/"");
        if (e != null) {
            while (e.hasMoreElements()) {
                String path = (String)e.nextElement();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Found entry: "" + path + "" in bundle "" + bundle.getSymbolicName());
                }
                ComponentEntry entry = new ComponentEntry();
                entry.bundle = bundle;
                entry.path = path;
                entry.name = path.substring(path.lastIndexOf(""/"") + 1);
                components.put(entry.name, entry);
            }
        }
    }
    protected synchronized void mayBeRemoveComponentFor(Bundle bundle) {
        for (ComponentEntry entry : components.values()) {
            if (entry.bundle == bundle) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Removing entry: "" + entry.path + "" in bundle "" + bundle.getSymbolicName());
                }
                components.remove(entry.name);
            }
        }
    }
    protected synchronized Class getComponent(String name) throws Exception {
        ComponentEntry entry = components.get(name);
        if (entry == null) {
            return null;
        }
        if (entry.type == null) {
            URL url = entry.bundle.getEntry(entry.path);
            // lets load the file
            Properties properties = new Properties();
            BufferedInputStream reader = null;
            try {
                reader = new BufferedInputStream(url.openStream());
                properties.load(reader);
            } finally {
                try {
                    reader.close();
                } catch (Exception ignore) {
                }
            }
            String classname = (String)properties.get(""class"");
            ClassLoader loader = BundleDelegatingClassLoader.createBundleClassLoaderFor(entry.bundle);
            entry.type = loader.loadClass(classname);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found component: "" + name + "" via type: "" + entry.type.getName());
        }
        return entry.type;
    }
    public Component resolveComponent(String name, CamelContext context) throws Exception {
        Object bean = null;
        try {
            bean = context.getRegistry().lookup(name);
            if (bean != null && LOG.isDebugEnabled()) {
                LOG.debug(""Found component: "" + name + "" in registry: "" + bean);
            }
        } catch (Exception e) {
            LOG.debug(""Ignored error looking up bean: "" + name + "". Error: "" + e);
        }
        if (bean != null) {
            if (bean instanceof Component) {
                return (Component)bean;
            }
            // we do not throw the exception here and try to auto create a component
        }
        // Check in OSGi bundles
        init();
        Class type = null;
        try {
            type = getComponent(name);
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Component registered for scheme : "" + name, e);
        }
        if (type == null) {
            return null;
        }
        if (Component.class.isAssignableFrom(type)) {
            return (Component)context.getInjector().newInstance(type);
        } else {
            throw new IllegalArgumentException(""Type is not a Component implementation. Found: ""
                                               + type.getName());
        }
    }
}
"
org.apache.camel.component.jms.requestor.FailedToProcessResponse,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import javax.jms.JMSException;
import javax.jms.Message;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if a response message from an InOut could not be processed
 *
 * @version $Revision$
 */
public class FailedToProcessResponse extends RuntimeCamelException {
    private final Message response;
    public FailedToProcessResponse(Message response, JMSException e) {
        super(""Failed to process response: "" + e + "". Message: "" + response, e);
        this.response = response;
    }
    /**
     * The response message which caused the exception
     */
    public Message getResponse() {
        return response;
    }
}
"
org.apache.camel.component.uface.UFaceComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision$
 */
public class UFaceComponent extends DefaultComponent {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new UFaceEndpoint(uri, this);
    }
}
"
org.apache.camel.language.ognl.OgnlLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * An <a href=""http://www.ognl.org/"">OGNL</a> {@link Language} plugin
 *
 * @version $Revision$
 */
public class OgnlLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return new OgnlExpression(this, expression, Boolean.class);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new OgnlExpression(this, expression, Object.class);
    }
}
"
org.apache.camel.component.mina.MinaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoAcceptorConfig;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoConnectorConfig;
import org.apache.mina.common.IoSession;
/**
 * Endpoint for Camel MINA.
 *
 * @version $Revision$
 */
public class MinaEndpoint extends DefaultEndpoint<MinaExchange> {
    private static final long DEFAULT_TIMEOUT = 30000;
    private long timeout = DEFAULT_TIMEOUT;
    private final IoAcceptor acceptor;
    private final SocketAddress address;
    private final IoConnector connector;
    private final IoAcceptorConfig acceptorConfig;
    private final IoConnectorConfig connectorConfig;
    private final boolean lazySessionCreation;
    private final boolean transferExchange;
    public MinaEndpoint(String endpointUri, MinaComponent component, SocketAddress address,
                        IoAcceptor acceptor, IoAcceptorConfig acceptorConfig, IoConnector connector,
                        IoConnectorConfig connectorConfig, boolean lazySessionCreation, long timeout,
                        boolean transferExchange) {
        super(endpointUri, component);
        this.address = address;
        this.acceptor = acceptor;
        this.acceptorConfig = acceptorConfig;
        this.connectorConfig = connectorConfig;
        this.connector = connector;
        this.lazySessionCreation = lazySessionCreation;
        if (timeout > 0) {
            // override default timeout if provided
            this.timeout = timeout;
        }
        this.transferExchange = transferExchange;
    }
    @SuppressWarnings({""unchecked""})
    public Producer<MinaExchange> createProducer() throws Exception {
        return new MinaProducer(this);
    }
    public Consumer<MinaExchange> createConsumer(Processor processor) throws Exception {
        return new MinaConsumer(this, processor);
    }
    @Override
    public MinaExchange createExchange(ExchangePattern pattern) {
        return new MinaExchange(getCamelContext(), pattern, null);
    }
    public MinaExchange createExchange(IoSession session, Object payload) {
        MinaExchange exchange = new MinaExchange(getCamelContext(), getExchangePattern(), session);
        MinaPayloadHelper.setIn(exchange, payload);
        return exchange;
    }
    // Properties
    // -------------------------------------------------------------------------
    public IoAcceptor getAcceptor() {
        return acceptor;
    }
    public SocketAddress getAddress() {
        return address;
    }
    public IoConnector getConnector() {
        return connector;
    }
    public boolean isLazySessionCreation() {
        return lazySessionCreation;
    }
    public IoAcceptorConfig getAcceptorConfig() {
        return acceptorConfig;
    }
    public IoConnectorConfig getConnectorConfig() {
        return connectorConfig;
    }
    public boolean isSingleton() {
        return true;
    }
    public long getTimeout() {
        return timeout;
    }
    public boolean isTransferExchange() {
        return transferExchange;
    }
}
"
org.apache.camel.component.validator.jing.JingValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.io.IOException;
import java.io.InputStream;
import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.sax.SAXSource;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import com.thaiopensource.relaxng.SchemaFactory;
import com.thaiopensource.util.PropertyMap;
import com.thaiopensource.util.PropertyMapBuilder;
import com.thaiopensource.validate.IncorrectSchemaException;
import com.thaiopensource.validate.Schema;
import com.thaiopensource.validate.ValidateProperty;
import com.thaiopensource.validate.Validator;
import com.thaiopensource.xml.sax.Jaxp11XMLReaderCreator;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.processor.validation.DefaultValidationErrorHandler;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.Resource;
/**
 * A validator which uses the <a
 * href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing</a> library to
 * validate XML against RelaxNG
 * 
 * @version $Revision$
 */
public class JingValidator implements Processor {
    private static final transient Log LOG = LogFactory.getLog(JingValidator.class);
    private Schema schema;
    private SchemaFactory schemaFactory;
    private String schemaNamespace = XMLConstants.RELAXNG_NS_URI;
    private Resource schemaResource;
    private InputSource inputSource;
    private boolean compactSyntax;
    public void process(Exchange exchange) throws Exception {
        Jaxp11XMLReaderCreator xmlCreator = new Jaxp11XMLReaderCreator();
        DefaultValidationErrorHandler errorHandler = new DefaultValidationErrorHandler();
        PropertyMapBuilder mapBuilder = new PropertyMapBuilder();
        mapBuilder.put(ValidateProperty.XML_READER_CREATOR, xmlCreator);
        mapBuilder.put(ValidateProperty.ERROR_HANDLER, errorHandler);
        PropertyMap propertyMap = mapBuilder.toPropertyMap();
        Validator validator = getSchema().createValidator(propertyMap);
        Message in = exchange.getIn();
        SAXSource saxSource = in.getBody(SAXSource.class);
        if (saxSource == null) {
            Source source = ExchangeHelper.getMandatoryInBody(exchange, Source.class);
            saxSource = ExchangeHelper.convertToMandatoryType(exchange, SAXSource.class, source);
        }
        InputSource bodyInput = saxSource.getInputSource();
        // now lets parse the body using the validator
        XMLReader reader = xmlCreator.createXMLReader();
        reader.setContentHandler(validator.getContentHandler());
        reader.setDTDHandler(validator.getDTDHandler());
        reader.setErrorHandler(errorHandler);
        reader.parse(bodyInput);
        errorHandler.handleErrors(exchange, schema);
    }
    // Properties
    // -------------------------------------------------------------------------
    public Schema getSchema() throws IOException, IncorrectSchemaException, SAXException {
        if (schema == null) {
            SchemaFactory factory = getSchemaFactory();
            schema = factory.createSchema(getInputSource());
        }
        return schema;
    }
    public void setSchema(Schema schema) {
        this.schema = schema;
    }
    public InputSource getInputSource() throws IOException {
        if (inputSource == null) {
            Resource resource = getSchemaResource();
            if (resource == null) {
                throw new IllegalArgumentException(""No schemaResource or inputSource specified"");
            } else {
                InputStream inputStream = resource.getInputStream();
                if (inputStream == null) {
                    throw new IllegalArgumentException(""No inputStream available for: "" + resource);
                }
                inputSource = new InputSource(inputStream);
            }
        }
        return inputSource;
    }
    public void setInputSource(InputSource inputSource) {
        this.inputSource = inputSource;
    }
    public SchemaFactory getSchemaFactory() {
        if (schemaFactory == null) {
            schemaFactory = new SchemaFactory();
            schemaFactory.setCompactSyntax(compactSyntax);
            schemaFactory.setXMLReaderCreator(new Jaxp11XMLReaderCreator());
        }
        return schemaFactory;
    }
    public void setSchemaFactory(SchemaFactory schemaFactory) {
        this.schemaFactory = schemaFactory;
    }
    public Resource getSchemaResource() {
        return schemaResource;
    }
    public void setSchemaResource(Resource schemaResource) {
        this.schemaResource = schemaResource;
    }
    public String getSchemaNamespace() {
        return schemaNamespace;
    }
    public void setSchemaNamespace(String schemaNamespace) {
        this.schemaNamespace = schemaNamespace;
    }
    public boolean isCompactSyntax() {
        return compactSyntax;
    }
    public void setCompactSyntax(boolean compactSyntax) {
        this.compactSyntax = compactSyntax;
    }
}
"
org.apache.camel.component.spring.integration.adapter.AbstractCamelAdapter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.springframework.integration.handler.MessageHandler;
/**
 * The Abstract class for the Spring Integration Camel Adapter
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public abstract class AbstractCamelAdapter implements MessageHandler {
    private CamelContext camelContext;
    private String camelEndpointUri;
    private volatile boolean expectReply = true;
    public void setCamelContext(CamelContext context) {
        camelContext = context;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public String getCamelEndpointUri() {
        return camelEndpointUri;
    }
    public void setCamelEndpointUri(String uri) {
        camelEndpointUri = uri;
    }
    public void setExpectReply(boolean expectReply) {
        this.expectReply = expectReply;
    }
    public boolean isExpectReply() {
        return expectReply;
    }
}
"
org.apache.camel.spring.handler.ScriptDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.w3c.dom.Element;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
/**
 * A parser of the various scripting language expressions
 *
 * @version $Revision$
 */
public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser {
    private final String scriptEngineName;
    public ScriptDefinitionParser(String scriptEngineName) {
        super(""org.apache.camel.builder.script.ScriptBuilder"", ""camel-script"");
        this.scriptEngineName = scriptEngineName;
    }
    @Override
    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
        // lets create a child context
        String engine = scriptEngineName;
        if (engine == null) {
            engine = element.getAttribute(""language"");
        }
        builder.addConstructorArgValue(engine);
        super.doParse(element, parserContext, builder);
        String scriptText = DomUtils.getTextValue(element).trim();
        if (scriptText.length() > 0) {
            builder.addPropertyValue(""scriptText"", scriptText);
        }
    }
}
"
org.apache.camel.component.jhc.JhcConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.HttpEntity;
import org.apache.http.HttpEntityEnclosingRequest;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseFactory;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.ProtocolVersion;
import org.apache.http.impl.DefaultHttpResponseFactory;
import org.apache.http.nio.NHttpConnection;
import org.apache.http.nio.protocol.EventListener;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpParamsLinker;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpRequestHandler;
/**
 * Created by IntelliJ IDEA. User: gnodet Date: Sep 7, 2007 Time: 8:15:54 PM To
 * change this template use File | Settings | File Templates.
 */
public class JhcConsumer extends DefaultConsumer<JhcExchange> {
    private static final Log LOG = LogFactory.getLog(JhcConsumer.class);
    private JhcServerEngine engine;
    private MyHandler handler;
    public JhcConsumer(JhcEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        engine = JhcServerEngineFactory.getJhcServerEngine(endpoint.getParams(), endpoint.getPort(), endpoint
            .getProtocol());
        handler = new MyHandler(endpoint.getParams(), endpoint.getPath());
    }
    public JhcEndpoint getEndpoint() {
        return (JhcEndpoint)super.getEndpoint();
    }
    protected void doStart() throws Exception {
        super.doStart();
        engine.register(handler.getPath() + ""*"", handler);
        if (!engine.isStarted()) {
            engine.start();
        }
    }
    protected void doStop() throws Exception {
        engine.unregister(handler.getPath() + ""*"");
        if (engine.getReferenceCounter() == 0) {
            engine.stop();
        }
        super.doStop();
    }
    class MyHttpRequestHandler implements HttpRequestHandler {
        public void handle(HttpRequest httpRequest, HttpResponse httpResponse, HttpContext httpContext)
            throws HttpException, IOException {
            LOG.debug(""handle"");
        }
    }
    static class EventLogger implements EventListener {
        public void connectionOpen(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection open: "" + conn);
            }
        }
        public void connectionTimeout(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection timed out: "" + conn);
            }
        }
        public void connectionClosed(final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connection closed: "" + conn);
            }
        }
        public void fatalIOException(final IOException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""I/O error: "" + ex.getMessage());
            }
        }
        public void fatalProtocolException(final HttpException ex, final NHttpConnection conn) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""HTTP error: "" + ex.getMessage());
            }
        }
    }
    class MyHandler implements AsyncHttpRequestHandler {
        private final HttpParams params;
        private final HttpResponseFactory responseFactory;
        private final String path;
        public MyHandler(HttpParams params, String path) {
            this(params, path, new DefaultHttpResponseFactory());
        }
        public MyHandler(HttpParams params, String path, HttpResponseFactory responseFactory) {
            this.params = params;
            this.path = path;
            this.responseFactory = responseFactory;
        }
        public String getPath() {
            return path;
        }
        public void handle(final HttpRequest request, final HttpContext context,
                           final AsyncResponseHandler handler) throws HttpException, IOException {
            final Exchange exchange = getEndpoint().createExchange();
            exchange.getIn().setHeader(""http.uri"", request.getRequestLine().getUri());
            if (request instanceof HttpEntityEnclosingRequest) {
                exchange.getIn().setBody(((HttpEntityEnclosingRequest)request).getEntity());
            }
            getAsyncProcessor().process(exchange, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    LOG.debug(""handleExchange"");
                    // create the default response to this request
                    ProtocolVersion httpVersion = (HttpVersion)request.getRequestLine().getProtocolVersion();
                    HttpResponse response = responseFactory.newHttpResponse(httpVersion, HttpStatus.SC_OK,
                                                                            context);
                    HttpParamsLinker.link(response, params);
                    HttpEntity entity = exchange.getOut().getBody(HttpEntity.class);
                    response.setEntity(entity);
                    response.setParams(getEndpoint().getParams());
                    try {
                        handler.sendResponse(response);
                    } catch (Exception e) {
                        LOG.info(e);
                    }
                }
            });
        }
        public void handle(HttpRequest request, HttpResponse response, HttpContext context)
            throws HttpException, IOException {
            // now we just handler the requset async, do nothing here
        }
    }
}
"
org.apache.camel.component.rmi.RmiComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class RmiComponent extends DefaultComponent<BeanExchange> {
    public RmiComponent() {
    }
    public RmiComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<BeanExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new RmiEndpoint(uri, this);
    }
}
"
org.apache.camel.component.cxf.transport.CamelDestination,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.IOException;
import java.io.OutputStream;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.camel.component.cxf.CxfSoapBinding;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.AbstractDestination;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
import org.apache.cxf.wsdl.EndpointReferenceUtils;
/**
 * @version $Revision$
 */
public class CamelDestination extends AbstractDestination implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-destination"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelDestination.class);
    final ConduitInitiator conduitInitiator;
    CamelContext camelContext;
    Consumer consumer;
    String camelDestinationUri;
    private ProducerTemplate<Exchange> camelTemplate;
    private Endpoint distinationEndpoint;
    public CamelDestination(CamelContext camelContext, Bus bus, ConduitInitiator ci, EndpointInfo info) throws IOException {
        super(bus, getTargetReference(info, bus), info);
        this.camelContext = camelContext;
        conduitInitiator = ci;
        camelDestinationUri = endpointInfo.getAddress().substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());
        if (camelDestinationUri.startsWith(""//"")) {
            camelDestinationUri = camelDestinationUri.substring(2);
        }
        initConfig();
    }
    protected Logger getLogger() {
        return LOG;
    }
    /**
     * @param inMessage the incoming message
     * @return the inbuilt backchannel
     */
    protected Conduit getInbuiltBackChannel(Message inMessage) {
        //we can pass the message back by looking up the camelExchange from inMessage
        return new BackChannelConduit(inMessage);
    }
    public void activate() {
        getLogger().log(Level.FINE, ""CamelDestination activate().... "");
        try {
            getLogger().log(Level.FINE, ""establishing Camel connection"");
            distinationEndpoint = camelContext.getEndpoint(camelDestinationUri);
            consumer = distinationEndpoint.createConsumer(new ConsumerProcessor());
            consumer.start();
        } catch (Exception ex) {
            // TODO: Is it okay just to log severe errors such as this?
            getLogger().log(Level.SEVERE, ""Camel connect failed with Exception : "", ex);
        }
    }
    public void deactivate() {
        try {
            consumer.stop();
        } catch (Exception e) {
            // TODO: Is it okay just to log severe errors such as this?
            getLogger().log(Level.SEVERE, ""Camel stop failed with Exception : "", e);
        }
    }
    public void shutdown() {
        getLogger().log(Level.FINE, ""CamelDestination shutdown()"");
        this.deactivate();
    }
    public ProducerTemplate<Exchange> getCamelTemplate() {
        if (camelTemplate == null) {
            CamelContext ctx = camelContext != null ? camelContext : new DefaultCamelContext();
            camelTemplate = ctx.createProducerTemplate();
        }
        return camelTemplate;
    }
    public void setCamelTemplate(ProducerTemplate<Exchange> template) {
        camelTemplate = template;
    }
    public void setCamelContext(CamelContext context) {
        camelContext = context;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    protected void incoming(org.apache.camel.Exchange camelExchange) {
        getLogger().log(Level.FINE, ""server received request: "", camelExchange);
        org.apache.cxf.message.Message inMessage =
            CxfSoapBinding.getCxfInMessage(camelExchange, false);
        inMessage.put(CxfConstants.CAMEL_EXCHANGE, camelExchange);
        ((MessageImpl)inMessage).setDestination(this);
        // Handling the incoming message
        // The response message will be send back by the outgoingchain
        incomingObserver.onMessage(inMessage);
    }
    public String getBeanName() {
        if (endpointInfo == null || endpointInfo.getName() == null) {
            return ""default"" + BASE_BEAN_NAME_SUFFIX;
        }
        return endpointInfo.getName().toString() + BASE_BEAN_NAME_SUFFIX;
    }
    private void initConfig() {
        //we could configure the camel context here
        if (bus != null) {
            Configurer configurer = bus.getExtension(Configurer.class);
            if (null != configurer) {
                configurer.configureBean(this);
            }
        }
    }
    protected class ConsumerProcessor implements Processor {
        public void process(Exchange exchange) {
            try {
                incoming(exchange);
            } catch (Throwable ex) {
                getLogger().log(Level.WARNING, ""Failed to process incoming message : "", ex);
            }
        }
    }
    // this should deal with the cxf message
    protected class BackChannelConduit extends AbstractConduit {
        protected Message inMessage;
        Exchange camelExchange;
        org.apache.cxf.message.Exchange cxfExchange;
        BackChannelConduit(Message message) {
            super(EndpointReferenceUtils.getAnonymousEndpointReference());
            inMessage = message;
            cxfExchange = inMessage.getExchange();
            camelExchange = cxfExchange.get(Exchange.class);
        }
        /**
         * Register a message observer for incoming messages.
         *
         * @param observer the observer to notify on receipt of incoming
         */
        public void setMessageObserver(MessageObserver observer) {
            // shouldn't be called for a back channel conduit
        }
        /**
         * Send an outbound message, assumed to contain all the name-value
         * mappings of the corresponding input message (if any).
         *
         * @param message the message to be sent.
         */
        public void prepare(Message message) throws IOException {
            message.put(CxfConstants.CAMEL_EXCHANGE, inMessage.get(CxfConstants.CAMEL_EXCHANGE));
            message.setContent(OutputStream.class, new CamelOutputStream(message));
        }
        protected Logger getLogger() {
            return LOG;
        }
    }
    /**
     * Mark message as a partial message.
     *
     * @param partialResponse the partial response message
     * @param decoupledTarget the decoupled target
     * @return <tt>true</tt> if partial responses is supported
     */
    protected boolean markPartialResponse(Message partialResponse,
                                       EndpointReferenceType decoupledTarget) {
        return true;
    }
    /**
     * @return the associated conduit initiator
     */
    protected ConduitInitiator getConduitInitiator() {
        return conduitInitiator;
    }
    private class CamelOutputStream extends CachedOutputStream {
        private Message outMessage;
        public CamelOutputStream(Message m) {
            super();
            outMessage = m;
        }
        // Prepare the message and get the send out message
        private void commitOutputMessage() throws IOException {
            Exchange camelExchange = (Exchange)outMessage.get(CxfConstants.CAMEL_EXCHANGE);
            Map<String, List<String>> protocolHeader = CastUtils.cast((Map<?, ?>)outMessage.get(Message.PROTOCOL_HEADERS));
            CxfSoapBinding.setProtocolHeader(camelExchange.getOut().getHeaders(), protocolHeader);
            CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
            camelExchange.getOut().setBody(outputStream.getBytes());
            getLogger().log(Level.FINE, ""send the response message: "" + outputStream);
        }
        @Override
        protected void doFlush() throws IOException {
            // Do nothing here
        }
        @Override
        protected void doClose() throws IOException {
            commitOutputMessage();
        }
        @Override
        protected void onWrite() throws IOException {
            // Do nothing here
        }
    }
}
"
org.apache.camel.component.mail.MailConverters,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.io.IOException;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import org.apache.camel.Converter;
/**
 * JavaMail specific converters.
 *
 * @version $Revision$
 */
@Converter
public class MailConverters {
    /**
     * Converts the given JavaMail message to a String body.
     * Can return null.
     */
    @Converter
    public String toString(Message message) throws MessagingException, IOException {
        Object content = message.getContent();
        if (content instanceof MimeMultipart) {
            MimeMultipart multipart = (MimeMultipart) content;
            if (multipart.getCount() > 0) {
                BodyPart part = multipart.getBodyPart(0);
                content = part.getContent();
            }
        }
        if (content != null) {
            return content.toString();
        }
        return null;
    }
    /**
     * Converts the given JavaMail multipart to a String body, where the contenttype of the multipart
     * must be text based (ie start with text). Can return null.
     */
    @Converter
    public static String toString(Multipart multipart) throws MessagingException, IOException {
        int size = multipart.getCount();
        for (int i = 0; i < size; i++) {
            BodyPart part = multipart.getBodyPart(i);
            if (part.getContentType().startsWith(""text"")) {
                return part.getContent().toString();
            }
        }
        return null;
    }
}
"
org.apache.camel.component.jms.JmsProviderMetadata,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
import javax.jms.Session;
import javax.jms.TemporaryQueue;
import javax.jms.TemporaryTopic;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.SessionCallback;
/**
 * A class which represents some metadata about the underlying JMS provider
 * so that we can properly bridge JMS providers such as for dealing with temporary destinations.
 *
 * @version $Revision$
 */
public class JmsProviderMetadata {
    private Class<? extends TemporaryQueue> temporaryQueueType;
    private Class<? extends TemporaryTopic> temporaryTopicType;
    /**
     * Lazily loads the temporary queue type if one has not been explicitly configured
     * via calling the {@link #setTemporaryQueueType(Class)}
     */
    public Class<? extends TemporaryQueue> getTemporaryQueueType(JmsOperations template) {
        Class<? extends TemporaryQueue> answer = getTemporaryQueueType();
        if (answer == null) {
            loadTemporaryDestinationTypes(template);
            answer = getTemporaryQueueType();
        }
        return answer;
    }
    /**
     * Lazily loads the temporary topic type if one has not been explicitly configured
     * via calling the {@link #setTemporaryTopicType(Class)}
     */
    public Class<? extends TemporaryTopic> getTemporaryTopicType(JmsOperations template) {
        Class<? extends TemporaryTopic> answer = getTemporaryTopicType();
        if (answer == null) {
            loadTemporaryDestinationTypes(template);
            answer = getTemporaryTopicType();
        }
        return answer;
    }
    // Properties
    //-------------------------------------------------------------------------
    public Class<? extends TemporaryQueue> getTemporaryQueueType() {
        return temporaryQueueType;
    }
    public void setTemporaryQueueType(Class<? extends TemporaryQueue> temporaryQueueType) {
        this.temporaryQueueType = temporaryQueueType;
    }
    public Class<? extends TemporaryTopic> getTemporaryTopicType() {
        return temporaryTopicType;
    }
    public void setTemporaryTopicType(Class<? extends TemporaryTopic> temporaryTopicType) {
        this.temporaryTopicType = temporaryTopicType;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void loadTemporaryDestinationTypes(JmsOperations template) {
        if (template == null) {
            throw new IllegalArgumentException(""No JmsTemplate supplied!"");
        }
        template.execute(new SessionCallback() {
            public Object doInJms(Session session) throws JMSException {
                TemporaryQueue queue = session.createTemporaryQueue();
                setTemporaryQueueType(queue.getClass());
                TemporaryTopic topic = session.createTemporaryTopic();
                setTemporaryTopicType(topic.getClass());
                queue.delete();
                topic.delete();
                return null;
            }
        });
    }
}
"
org.apache.camel.component.jms.requestor.DeferredRequestReplyMap,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.concurrent.FutureTask;
import javax.jms.JMSException;
import javax.jms.Message;
import org.apache.camel.component.jms.JmsConfiguration.MessageSentCallback;
import org.apache.camel.component.jms.JmsProducer;
import org.apache.camel.util.TimeoutMap;
import org.apache.camel.util.UuidGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class DeferredRequestReplyMap  {
    private static final transient Log LOG = LogFactory.getLog(DeferredRequestReplyMap.class);
    private Requestor requestor;
    private JmsProducer producer;
    private TimeoutMap deferredRequestMap;
    private TimeoutMap deferredReplyMap;
    public static class DeferredMessageSentCallback implements MessageSentCallback {
        private DeferredRequestReplyMap map;
        private String transitionalID;
        private Message message;
        private Object monitor;
        public DeferredMessageSentCallback(DeferredRequestReplyMap map, UuidGenerator uuidGenerator, Object monitor) {
            transitionalID = uuidGenerator.generateId();
            this.map = map;
            this.monitor = monitor;
        }
        public DeferredRequestReplyMap getDeferredRequestReplyMap() {
            return map;
        }
        public String getID() {
            return transitionalID;
        }
        public Message getMessage() {
            return message;
        }
        public void sent(Message message) {
            this.message = message;
            map.processDeferredReplies(monitor, getID(), message);
        }
    }
    public DeferredRequestReplyMap(Requestor requestor,
                                   JmsProducer producer,
                                   TimeoutMap deferredRequestMap,
                                   TimeoutMap deferredReplyMap) {
        this.requestor = requestor;
        this.producer = producer;
        this.deferredRequestMap = deferredRequestMap;
        this.deferredReplyMap = deferredReplyMap;
    }
    public long getRequestTimeout() {
        return producer.getRequestTimeout();
    }
    public DeferredMessageSentCallback createDeferredMessageSentCallback() {
        return new DeferredMessageSentCallback(this, getUuidGenerator(), requestor);
    }
    public void put(DeferredMessageSentCallback callback, FutureTask futureTask) {
        deferredRequestMap.put(callback.getID(), futureTask, getRequestTimeout());
    }
    public void processDeferredRequests(String correlationID, Message inMessage) {
        processDeferredRequests(requestor, deferredRequestMap, deferredReplyMap,
                                correlationID, requestor.getMaxRequestTimeout(), inMessage);
    }
    public static void processDeferredRequests(Object monitor,
                                               TimeoutMap requestMap,
                                               TimeoutMap replyMap,
                                               String correlationID,
                                               long timeout,
                                               Message inMessage) {
        synchronized (monitor) {
            try {
                Object handler = requestMap.get(correlationID);
                if (handler == null) {
                    if (requestMap.size() > replyMap.size()) {
                        replyMap.put(correlationID, inMessage, timeout);
                    } else {
                        LOG.warn(""Response received for unknown correlationID: "" + correlationID + ""; response: "" + inMessage);
                    }
                }
                if (handler != null && handler instanceof ReplyHandler) {
                    ReplyHandler replyHandler = (ReplyHandler) handler;
                    boolean complete = replyHandler.handle(inMessage);
                    if (complete) {
                        requestMap.remove(correlationID);
                    }
                }
            } catch (JMSException e) {
                throw new FailedToProcessResponse(inMessage, e);
            }
        }
    }
    public void processDeferredReplies(Object monitor, String transitionalID, Message outMessage) {
        synchronized (monitor) {
            try {
                Object handler = deferredRequestMap.get(transitionalID);
                if (handler == null) {
                    return;
                }
                deferredRequestMap.remove(transitionalID);
                String correlationID = outMessage.getJMSMessageID();
                Object in = deferredReplyMap.get(correlationID);
                if (in != null && in instanceof Message) {
                    Message inMessage = (Message)in;
                    if (handler instanceof ReplyHandler) {
                        ReplyHandler replyHandler = (ReplyHandler)handler;
                        try {
                            boolean complete = replyHandler.handle(inMessage);
                            if (complete) {
                                deferredReplyMap.remove(correlationID);
                            }
                        } catch (JMSException e) {
                            throw new FailedToProcessResponse(inMessage, e);
                        }
                    }
                } else {
                    deferredRequestMap.put(correlationID, handler, getRequestTimeout());
                }
            } catch (JMSException e) {
                throw new FailedToProcessResponse(outMessage, e);
            }
        }
    }
    protected UuidGenerator getUuidGenerator() {
        return producer.getUuidGenerator();
    }
}
"
org.apache.camel.component.file.remote.RemoteFileExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
public class RemoteFileExchange<T extends RemoteFileBinding> extends DefaultExchange {
    private T binding;
    public RemoteFileExchange(CamelContext context, ExchangePattern pattern, T binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public RemoteFileExchange(CamelContext context, ExchangePattern pattern, T binding, String host, String fullFileName, ByteArrayOutputStream outputStream) {
        this(context, pattern, binding);
        setIn(new RemoteFileMessage(host, fullFileName, outputStream));
    }
    public T getBinding() {
        return binding;
    }
    public void setBinding(T binding) {
        this.binding = binding;
    }
}
"
org.apache.camel.component.uface.UFaceEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.component.list.ListEndpoint;
import org.apache.camel.util.ObjectHelper;
import org.eclipse.core.databinding.observable.Realm;
import org.eclipse.core.databinding.observable.list.WritableList;
/**
 * @version $Revision$
 */
public class UFaceEndpoint extends ListEndpoint {
    public UFaceEndpoint(String uri, UFaceComponent component) {
        super(uri, component);
    }
    public UFaceEndpoint(String endpointUri) {
        super(endpointUri);
    }
    @Override
    protected List<Exchange> createExchangeList() {
        Realm realm = Realm.getDefault();
        ObjectHelper.notNull(realm, ""DataBinding Realm"");
        return new WritableList(realm);
    }
}
"
org.apache.camel.component.mina.MinaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.URI;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.ByteBuffer;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoServiceConfig;
import org.apache.mina.common.IoSession;
import org.apache.mina.filter.LoggingFilter;
import org.apache.mina.filter.codec.ProtocolCodecFactory;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.ProtocolDecoder;
import org.apache.mina.filter.codec.ProtocolDecoderOutput;
import org.apache.mina.filter.codec.ProtocolEncoder;
import org.apache.mina.filter.codec.ProtocolEncoderOutput;
import org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;
import org.apache.mina.filter.codec.textline.TextLineCodecFactory;
import org.apache.mina.transport.socket.nio.DatagramAcceptor;
import org.apache.mina.transport.socket.nio.DatagramAcceptorConfig;
import org.apache.mina.transport.socket.nio.DatagramConnector;
import org.apache.mina.transport.socket.nio.DatagramConnectorConfig;
import org.apache.mina.transport.socket.nio.SocketAcceptor;
import org.apache.mina.transport.socket.nio.SocketAcceptorConfig;
import org.apache.mina.transport.socket.nio.SocketConnector;
import org.apache.mina.transport.socket.nio.SocketConnectorConfig;
import org.apache.mina.transport.vmpipe.VmPipeAcceptor;
import org.apache.mina.transport.vmpipe.VmPipeAddress;
import org.apache.mina.transport.vmpipe.VmPipeConnector;
/**
 * Component for Apache MINA.
 *
 * @version $Revision$
 *
 * @see org.apache.camel.Component
 */
public class MinaComponent extends DefaultComponent<MinaExchange> {
    private static final transient Log LOG = LogFactory.getLog(MinaComponent.class);
    private static final long DEFAULT_CONNECT_TIMEOUT = 30000;
    // encoder used for datagram
    private CharsetEncoder encoder;
    public MinaComponent() {
    }
    public MinaComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<MinaExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating MinaEndpoint from uri: "" + uri);
        }
        URI u = new URI(remaining);
        String protocol = u.getScheme();
        // if mistyped uri then protocol can be null
        if (protocol != null) {
            if (protocol.equals(""tcp"")) {
                return createSocketEndpoint(uri, u, parameters);
            } else if (protocol.equals(""udp"") || protocol.equals(""mcast"") || protocol.equals(""multicast"")) {
                return createDatagramEndpoint(uri, u, parameters);
            } else if (protocol.equals(""vm"")) {
                return createVmEndpoint(uri, u);
            }
        }
        // protocol not resolved so error
        throw new IllegalArgumentException(""Unrecognised MINA protocol: "" + protocol + "" for uri: "" + uri);
    }
    protected MinaEndpoint createVmEndpoint(String uri, URI connectUri) {
        IoAcceptor acceptor = new VmPipeAcceptor();
        SocketAddress address = new VmPipeAddress(connectUri.getPort());
        IoConnector connector = new VmPipeConnector();
        return new MinaEndpoint(uri, this, address, acceptor, null, connector, null, false, 0, false);
    }
    protected MinaEndpoint createSocketEndpoint(String uri, URI connectUri, Map parameters) {
        IoAcceptor acceptor = new SocketAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new SocketConnector();
        boolean lazySessionCreation = getAndRemoveParameter(parameters, ""lazySessionCreation"", Boolean.class, false);
        long timeout = getAndRemoveParameter(parameters, ""timeout"", Long.class, 0L);
        boolean transferExchange = getAndRemoveParameter(parameters, ""transferExchange"", Boolean.class, false);
        boolean sync = getAndRemoveParameter(parameters, ""sync"", Boolean.class, false);
        boolean minaLogger = getAndRemoveParameter(parameters, ""minaLogger"", Boolean.class, false);
        boolean textline = getAndRemoveParameter(parameters, ""textline"", Boolean.class, false);
        String encoding = getAndRemoveParameter(parameters, ""encoding"", String.class);
        String codec = getAndRemoveParameter(parameters, ""codec"", String.class);
        // connector config
        SocketConnectorConfig connectorConfig = new SocketConnectorConfig();
        configureSocketCodecFactory(""MinaProducer"", connectorConfig, textline, encoding, codec);
        if (minaLogger) {
            connectorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        // set connect timeout to mina in seconds
        long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT;
        connectorConfig.setConnectTimeout((int)(connectTimeout / 1000));
        // acceptor connectorConfig
        SocketAcceptorConfig acceptorConfig = new SocketAcceptorConfig();
        configureSocketCodecFactory(""MinaConsumer"", acceptorConfig, textline, encoding, codec);
        acceptorConfig.setReuseAddress(true);
        acceptorConfig.setDisconnectOnUnbind(true);
        if (minaLogger) {
            acceptorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        MinaEndpoint endpoint = new MinaEndpoint(uri, this, address, acceptor, acceptorConfig, connector, connectorConfig, lazySessionCreation, timeout, transferExchange);
        // set sync or async mode after endpoint is created
        if (sync) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
        } else {
            endpoint.setExchangePattern(ExchangePattern.InOnly);
        }
        return endpoint;
    }
    protected void configureSocketCodecFactory(String type, IoServiceConfig config, boolean textline, String encoding, String codec) {
        ProtocolCodecFactory codecFactory = getCodecFactory(type, codec);
        if (codecFactory == null) {
            if (textline) {
                Charset charset = getEncodingParameter(type, encoding);
                codecFactory = new TextLineCodecFactory(charset);
                if (LOG.isDebugEnabled()) {
                    LOG.debug(type + "": Using TextLineCodecFactory: "" + codecFactory + "" using encoding: ""
                              + encoding);
                }
            } else {
                codecFactory = new ObjectSerializationCodecFactory();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(type + "": Using ObjectSerializationCodecFactory: "" + codecFactory);
                }
            }
        }
        addCodecFactory(config, codecFactory);
    }
    protected MinaEndpoint createDatagramEndpoint(String uri, URI connectUri, Map parameters) {
        IoAcceptor acceptor = new DatagramAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new DatagramConnector();
        boolean lazySessionCreation = getAndRemoveParameter(parameters, ""lazySessionCreation"", Boolean.class, false);
        long timeout = getAndRemoveParameter(parameters, ""timeout"", Long.class, 0L);
        boolean transferExchange = false; // transfer exchange is not supported for datagram protocol
        boolean sync = getAndRemoveParameter(parameters, ""sync"", Boolean.class, false);
        boolean minaLogger = getAndRemoveParameter(parameters, ""minaLogger"", Boolean.class, false);
        String encoding = getAndRemoveParameter(parameters, ""encoding"", String.class);
        String codec = getAndRemoveParameter(parameters, ""codec"", String.class);
        DatagramConnectorConfig connectorConfig = new DatagramConnectorConfig();
        configureDataGramCodecFactory(""MinaProducer"", connectorConfig, encoding, codec);
        if (minaLogger) {
            connectorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        // set connect timeout to mina in seconds
        long connectTimeout = timeout > 0 ? timeout : DEFAULT_CONNECT_TIMEOUT;
        connectorConfig.setConnectTimeout((int)(connectTimeout / 1000));
        DatagramAcceptorConfig acceptorConfig = new DatagramAcceptorConfig();
        configureDataGramCodecFactory(""MinaConsumer"", acceptorConfig, encoding, codec);
        acceptorConfig.setDisconnectOnUnbind(true);
        // reuse address is default true for datagram
        if (minaLogger) {
            acceptorConfig.getFilterChain().addLast(""logger"", new LoggingFilter());
        }
        MinaEndpoint endpoint = new MinaEndpoint(uri, this, address, acceptor, acceptorConfig, connector, connectorConfig, lazySessionCreation, timeout, transferExchange);
        // set sync or async mode after endpoint is created
        if (sync) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
        } else {
            endpoint.setExchangePattern(ExchangePattern.InOnly);
        }
        return endpoint;
    }
    private Charset getEncodingParameter(String type, String encoding) {
        if (encoding == null) {
            encoding = Charset.defaultCharset().name();
            if (LOG.isDebugEnabled()) {
                LOG.debug(type + "": No encoding parameter using default charset: "" + encoding);
            }
        }
        if (!Charset.isSupported(encoding)) {
            throw new IllegalArgumentException(""The encoding: "" + encoding + "" is not supported"");
        }
        return Charset.forName(encoding);
    }
    /**
     * For datagrams the entire message is available as a single ByteBuffer so lets just pass those around by default
     * and try converting whatever they payload is into ByteBuffers unless some custom converter is specified
     */
    protected void configureDataGramCodecFactory(String type, IoServiceConfig config, String encoding, String codec) {
        ProtocolCodecFactory codecFactory = getCodecFactory(type, codec);
        if (codecFactory == null) {
            codecFactory = new ProtocolCodecFactory() {
                public ProtocolEncoder getEncoder() throws Exception {
                    return new ProtocolEncoder() {
                        public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception {
                            ByteBuffer buf = toByteBuffer(message);
                            buf.flip();
                            out.write(buf);
                        }
                        public void dispose(IoSession session) throws Exception {
                        }
                    };
                }
                public ProtocolDecoder getDecoder() throws Exception {
                    return new ProtocolDecoder() {
                        public void decode(IoSession session, ByteBuffer in, ProtocolDecoderOutput out) throws Exception {
                            // must acquire the bytebuffer since we just pass it below instead of creating a new one (CAMEL-257)
                            in.acquire();
                            // lets just pass the ByteBuffer in
                            out.write(in);
                        }
                        public void finishDecode(IoSession session, ProtocolDecoderOutput out) throws Exception {
                        }
                        public void dispose(IoSession session) throws Exception {
                        }
                    };
                }
            };
            // set the encoder used for this datagram codec factory
            Charset charset = getEncodingParameter(type, encoding);
            encoder = charset.newEncoder();
            if (LOG.isDebugEnabled()) {
                LOG.debug(type + "": Using CodecFactory: "" + codecFactory + "" using encoding: "" + encoding);
            }
        }
        addCodecFactory(config, codecFactory);
    }
    protected ByteBuffer toByteBuffer(Object message) throws CharacterCodingException {
        ByteBuffer answer = convertTo(ByteBuffer.class, message);
        if (answer == null) {
            String value = convertTo(String.class, message);
            answer = ByteBuffer.allocate(value.length()).setAutoExpand(true);
            answer.putString(value, encoder);
        }
        return answer;
    }
    protected ProtocolCodecFactory getCodecFactory(String type, String codec) {
        ProtocolCodecFactory codecFactory = null;
        if (codec != null) {
            codecFactory = getCamelContext().getRegistry().lookup(codec, ProtocolCodecFactory.class);
            if (LOG.isDebugEnabled()) {
                LOG.debug(type + "": Using custom CodecFactory: "" + codecFactory);
            }
        }
        return codecFactory;
    }
    protected void addCodecFactory(IoServiceConfig config, ProtocolCodecFactory codecFactory) {
        config.getFilterChain().addLast(""codec"", new ProtocolCodecFilter(codecFactory));
    }
}
"
org.apache.camel.component.mail.security.DummyTrustManager,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail.security;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import javax.net.ssl.X509TrustManager;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 *  DummyTrustManager that accepts any given certificate - <b>NOT SECURE</b>.
 */
public class DummyTrustManager implements X509TrustManager {
    private static final transient Log LOG = LogFactory.getLog(DummyTrustManager.class);
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        // everything is trusted
        logCertificateChain(""Client"", chain);
    }
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        // everything is trusted
        logCertificateChain(""Server"", chain);
    }
    public X509Certificate[] getAcceptedIssuers() {
        // everything is trusted
        return new X509Certificate[0];
    }
    private static void logCertificateChain(String type, X509Certificate[] chain) {
        if (LOG.isDebugEnabled()) {
            for (X509Certificate certificate : chain) {
                LOG.debug(type + "" certificate is trusted: "" + certificate);
            }
        }
    }
}
"
org.apache.camel.component.cxf.spring.NamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.spring;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
public class NamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser(""cxfEndpoint"", new CxfEndpointBeanDefinitionParser());
    }
}
"
org.apache.camel.component.http.HttpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision$
 */
public class HttpConsumer extends DefaultConsumer<HttpExchange> {
    private final HttpEndpoint endpoint;
    public HttpConsumer(HttpEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    public HttpEndpoint getEndpoint() {
        return (HttpEndpoint)super.getEndpoint();
    }
    public HttpBinding getBinding() {
        return endpoint.getBinding();
    }
    public String getPath() {
        return endpoint.getPath();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.connect(this);
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.disconnect(this);
        super.doStop();
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.integration.channel.MessageChannel;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/springIntergration.html"">Spring Intergration Endpoint</a>
 *
 * @version $Revision$
 */
public class SpringIntegrationEndpoint extends ScheduledPollEndpoint<SpringIntegrationExchange> {
    private static final Log LOG = LogFactory.getLog(SpringIntegrationEndpoint.class);
    private String inputChannel;
    private String outputChannel;
    private String defaultChannel;
    private MessageChannel messageChannel;
    private boolean inOut;
    public SpringIntegrationEndpoint(String uri, String channel, SpringIntegrationComponent component) {
        super(uri, component);
        defaultChannel = channel;
    }
    public SpringIntegrationEndpoint(String uri, MessageChannel channel, CamelContext context) {
        super(uri, context);
        messageChannel = channel;
    }
    public SpringIntegrationEndpoint(String endpointUri, MessageChannel messageChannel) {
        super(endpointUri);
        this.messageChannel = messageChannel;
    }
    public Producer<SpringIntegrationExchange> createProducer() throws Exception {
        return new SpringIntegrationProducer(this);
    }
    public Consumer<SpringIntegrationExchange> createConsumer(Processor processor) throws Exception {
        return new SpringIntegrationConsumer(this, processor);
    }
    public SpringIntegrationExchange createExchange() {
        return createExchange(getExchangePattern());
    }
    public SpringIntegrationExchange createExchange(ExchangePattern pattern) {
        return new SpringIntegrationExchange(getCamelContext(), pattern);
    }
    public void setInputChannel(String input) {
        inputChannel = input;
    }
    public String getInputChannel() {
        return inputChannel;
    }
    public void setOutputChannel(String output) {
        outputChannel = output;
    }
    public String getOutputChannel() {
        return outputChannel;
    }
    public String getDefaultChannel() {
        return defaultChannel;
    }
    public MessageChannel getMessageChannel() {
        return messageChannel;
    }
    public boolean isSingleton() {
        return false;
    }
    public void setInOut(boolean inOut) {
        this.inOut = inOut;
    }
    public boolean isInOut() {
        return this.inOut;
    }
}
"
org.apache.camel.builder.script.ScriptBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
/**
 * A builder class for creating {@link Processor}, {@link Expression} and
 * {@link Predicate} objects using the JSR 223 scripting engine.
 *
 * @version $Revision$
 */
public class ScriptBuilder<E extends Exchange> implements Expression<E>, Predicate<E>, Processor {
    private static final transient Log LOG = LogFactory.getLog(ScriptBuilder.class);
    private String scriptEngineName;
    private Resource scriptResource;
    private String scriptText;
    private ScriptEngine engine;
    private CompiledScript compiledScript;
    public ScriptBuilder(String scriptEngineName) {
        this.scriptEngineName = scriptEngineName;
    }
    public ScriptBuilder(String scriptEngineName, String scriptText) {
        this(scriptEngineName);
        this.scriptText = scriptText;
    }
    public ScriptBuilder(String scriptEngineName, Resource scriptResource) {
        this(scriptEngineName);
        this.scriptResource = scriptResource;
    }
    @Override
    public String toString() {
        return getScriptDescription();
    }
    public Object evaluate(E exchange) {
        return evaluateScript(exchange);
    }
    public boolean matches(E exchange) {
        Object scriptValue = evaluateScript(exchange);
        return matches(exchange, scriptValue);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        Object scriptValue = evaluateScript(exchange);
        if (!matches(exchange, scriptValue)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as script returned <"" + scriptValue + "">"");
        }
    }
    public void process(Exchange exchange) {
        evaluateScript(exchange);
    }
    // Builder API
    // -------------------------------------------------------------------------
    /**
     * Sets the attribute on the context so that it is available to the script
     * as a variable in the {@link ScriptContext#ENGINE_SCOPE}
     *
     * @param name the name of the attribute
     * @param value the attribute value
     * @return this builder
     */
    public ScriptBuilder attribute(String name, Object value) {
        getScriptContext().setAttribute(name, value, ScriptContext.ENGINE_SCOPE);
        return this;
    }
    // Create any scripting language builder recognised by JSR 223
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the named language and script contents
     *
     * @param language the language to use for the script
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder script(String language, String scriptText) {
        return new ScriptBuilder(language, scriptText);
    }
    /**
     * Creates a script builder for the named language and script {@link Resource}
     *
     * @param language the language to use for the script
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, Resource scriptResource) {
        return new ScriptBuilder(language, scriptResource);
    }
    /**
     * Creates a script builder for the named language and script {@link File}
     *
     * @param language the language to use for the script
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, File scriptFile) {
        return new ScriptBuilder(language, new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the named language and script {@link URL}
     *
     * @param language the language to use for the script
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, URL scriptURL) {
        return new ScriptBuilder(language, new UrlResource(scriptURL));
    }
    // Groovy
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the groovy script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder groovy(String scriptText) {
        return new ScriptBuilder(""groovy"", scriptText);
    }
    /**
     * Creates a script builder for the groovy script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(Resource scriptResource) {
        return new ScriptBuilder(""groovy"", scriptResource);
    }
    /**
     * Creates a script builder for the groovy script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(File scriptFile) {
        return new ScriptBuilder(""groovy"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the groovy script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(URL scriptURL) {
        return new ScriptBuilder(""groovy"", new UrlResource(scriptURL));
    }
    // JavaScript
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the JavaScript/ECMAScript script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder javaScript(String scriptText) {
        return new ScriptBuilder(""js"", scriptText);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script
     *
     * @{link Resource}
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(Resource scriptResource) {
        return new ScriptBuilder(""js"", scriptResource);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(File scriptFile) {
        return new ScriptBuilder(""js"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(URL scriptURL) {
        return new ScriptBuilder(""js"", new UrlResource(scriptURL));
    }
    // PHP
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the PHP script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder php(String scriptText) {
        return new ScriptBuilder(""php"", scriptText);
    }
    /**
     * Creates a script builder for the PHP script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(Resource scriptResource) {
        return new ScriptBuilder(""php"", scriptResource);
    }
    /**
     * Creates a script builder for the PHP script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(File scriptFile) {
        return new ScriptBuilder(""php"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the PHP script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(URL scriptURL) {
        return new ScriptBuilder(""php"", new UrlResource(scriptURL));
    }
    // Python
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the Python script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder python(String scriptText) {
        return new ScriptBuilder(""python"", scriptText);
    }
    /**
     * Creates a script builder for the Python script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(Resource scriptResource) {
        return new ScriptBuilder(""python"", scriptResource);
    }
    /**
     * Creates a script builder for the Python script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(File scriptFile) {
        return new ScriptBuilder(""python"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Python script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(URL scriptURL) {
        return new ScriptBuilder(""python"", new UrlResource(scriptURL));
    }
    // Ruby/JRuby
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the Ruby/JRuby script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder ruby(String scriptText) {
        return new ScriptBuilder(""jruby"", scriptText);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script {@link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(Resource scriptResource) {
        return new ScriptBuilder(""jruby"", scriptResource);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script {@link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(File scriptFile) {
        return new ScriptBuilder(""jruby"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Ruby/JRuby script {@link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(URL scriptURL) {
        return new ScriptBuilder(""jruby"", new UrlResource(scriptURL));
    }
    // Properties
    // -------------------------------------------------------------------------
    public ScriptEngine getEngine() {
        checkInitialised();
        if (engine == null) {
            throw new IllegalArgumentException(""No script engine could be created for: "" + getScriptEngineName());
        }
        return engine;
    }
    public CompiledScript getCompiledScript() {
        return compiledScript;
    }
    public String getScriptText() {
        return scriptText;
    }
    public void setScriptText(String scriptText) {
        this.scriptText = scriptText;
    }
    public String getScriptEngineName() {
        return scriptEngineName;
    }
    /**
     * Returns a description of the script
     *
     * @return the script description
     */
    public String getScriptDescription() {
        if (scriptText != null) {
            return scriptEngineName + "": "" + scriptText;
        } else if (scriptResource != null) {
            return scriptEngineName + "": "" + scriptResource.getDescription();
        } else {
            return scriptEngineName + "": null script"";
        }
    }
    /**
     * Access the script context so that it can be configured such as adding
     * attributes
     */
    public ScriptContext getScriptContext() {
        return getEngine().getContext();
    }
    /**
     * Sets the context to use by the script
     */
    public void setScriptContext(ScriptContext scriptContext) {
        getEngine().setContext(scriptContext);
    }
    public Resource getScriptResource() {
        return scriptResource;
    }
    public void setScriptResource(Resource scriptResource) {
        this.scriptResource = scriptResource;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void checkInitialised() {
        if (scriptText == null && scriptResource == null) {
            throw new IllegalArgumentException(""Neither scriptText or scriptResource are specified"");
        }
        if (engine == null) {
            engine = createScriptEngine();
        }
        if (compiledScript == null) {
            if (engine instanceof Compilable) {
                compileScript((Compilable)engine);
            }
        }
    }
    protected boolean matches(E exchange, Object scriptValue) {
        return ObjectConverter.toBool(scriptValue);
    }
    protected ScriptEngine createScriptEngine() {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(scriptEngineName);
        if (isPython()) {
            ScriptContext context = engine.getContext();
            context.setAttribute(""com.sun.script.jython.comp.mode"", ""eval"", ScriptContext.ENGINE_SCOPE);
        }
        return engine;
    }
    protected void compileScript(Compilable compilable) {
        try {
            if (scriptText != null) {
                compiledScript = compilable.compile(scriptText);
            } else if (scriptResource != null) {
                compiledScript = compilable.compile(createScriptReader());
            }
        } catch (ScriptException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Script compile failed: "" + e, e);
            }
            throw createScriptCompileException(e);
        } catch (IOException e) {
            throw createScriptCompileException(e);
        }
    }
    protected synchronized Object evaluateScript(Exchange exchange) {
        try {
            getScriptContext();
            populateBindings(getEngine(), exchange);
            Object result = runScript();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""The script evaluation result is: "" + result);
            }
            return result;
        } catch (ScriptException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Script evaluation failed: "" + e, e);
            }
            throw createScriptEvaluationException(e.getCause());
        } catch (IOException e) {
            throw createScriptEvaluationException(e);
        }
    }
    protected Object runScript() throws ScriptException, IOException {
        checkInitialised();
        Object result = null;
        if (compiledScript != null) {
            result = compiledScript.eval();
        } else {
            if (scriptText != null) {
                result = getEngine().eval(scriptText);
            } else {
                result = getEngine().eval(createScriptReader());
            }
        }
        return result;
    }
    protected void populateBindings(ScriptEngine engine, Exchange exchange) {
        ScriptContext context = engine.getContext();
        int scope = ScriptContext.ENGINE_SCOPE;
        context.setAttribute(""context"", exchange.getContext(), scope);
        context.setAttribute(""exchange"", exchange, scope);
        context.setAttribute(""request"", exchange.getIn(), scope);
        context.setAttribute(""response"", exchange.getOut(), scope);
    }
    protected InputStreamReader createScriptReader() throws IOException {
        // TODO consider character sets?
        return new InputStreamReader(scriptResource.getInputStream());
    }
    protected ScriptEvaluationException createScriptCompileException(Exception e) {
        return new ScriptEvaluationException(""Failed to compile: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
    protected ScriptEvaluationException createScriptEvaluationException(Throwable e) {
        if (e.getClass().getName().equals(""org.jruby.exceptions.RaiseException"")) {
            // Only the nested exception has the specific problem
            try {
                Object ex = e.getClass().getMethod(""getException"").invoke(e);
                return new ScriptEvaluationException(""Failed to evaluate: "" + getScriptDescription() + "".  Error: "" + ex + "". Cause: "" + e, e);
            } catch (Exception e1) {
                // do nothing here
            }
        }
        return new ScriptEvaluationException(""Failed to evaluate: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
    protected boolean isPython() {
        return ""python"".equals(scriptEngineName) || ""jython"".equals(scriptEngineName);
    }
}
"
org.apache.camel.component.cxf.interceptors.DOMInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ResourceBundle;
import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.interceptor.CheckFaultInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapActionInInterceptor;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class DOMInInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(DOMOutInterceptor.class);
    private final XMLMessageInInterceptor xmlInterceptor = new XMLMessageInInterceptor();
    private final SoapMessageInInterceptor soapInterceptor = new SoapMessageInInterceptor();
    public DOMInInterceptor() {
        super(Phase.POST_PROTOCOL);
        this.addAfter(CheckFaultInterceptor.class.getName());
    }
    public boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    public void handleMessage(Message message) throws Fault {
        if (message instanceof XMLMessage) {
            xmlInterceptor.handleMessage((XMLMessage)message);
        } else if (message instanceof SoapMessage) {
            soapInterceptor.handleMessage((SoapMessage)message);
        } else {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""NOT_SUPPORTED_MESSAGE"",
                                                                   LOG, message.getClass().getName()));
        }
    }
}
"
org.apache.camel.builder.script.JavaScript,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of JavaScript expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""js"")
public @interface JavaScript {
    String value();
}"
org.apache.camel.converter.xmlbeans.XmlBeansConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.xmlbeans;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.nio.ByteBuffer;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.NIOConverter;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.xmlbeans.XmlException;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.impl.piccolo.xml.XMLStreamReader;
/**
 * A <a href=""http://activemq.apache.org/camel/type-coverter.html"">Type Converter</a>
 * of XMLBeans objects
 *
 * @version $Revision$
 */
@Converter
public class XmlBeansConverter {
    private XmlConverter xmlConverter = new XmlConverter();
    @Converter
    public static XmlObject toXmlObject(File value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(Reader value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(Node value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(InputStream value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public static XmlObject toXmlObject(String value) throws IOException, XmlException {
        return toXmlObject(IOConverter.toInputStream(value));
    }
    @Converter
    public static XmlObject toXmlObject(byte[] value) throws IOException, XmlException {
        return toXmlObject(IOConverter.toInputStream(value));
    }
    @Converter
    public static XmlObject toXmlObject(ByteBuffer value) throws IOException, XmlException {
        return toXmlObject(NIOConverter.toInputStream(value));
    }
    @Converter
    public static XmlObject toXmlObject(XMLStreamReader value) throws IOException, XmlException {
        return XmlObject.Factory.parse(value);
    }
    @Converter
    public XmlObject toXmlObject(Source value) throws IOException, XmlException, TransformerException, ParserConfigurationException, SAXException {
        Document document = getXmlConverter().toDOMDocument(value);
        return toXmlObject(document);
    }
    // Properties
    //-------------------------------------------------------------------------
    public XmlConverter getXmlConverter() {
        return xmlConverter;
    }
    public void setXmlConverter(XmlConverter xmlConverter) {
        this.xmlConverter = xmlConverter;
    }
}
"
org.apache.camel.component.quartz.CamelJob,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
/**
 * @version $Revision$
 */
public class CamelJob implements Job {
    public void execute(JobExecutionContext context) throws JobExecutionException {
        QuartzEndpoint component = (QuartzEndpoint) context.getJobDetail().getJobDataMap().get(QuartzEndpoint.ENDPOINT_KEY);
        if (component == null) {
            throw new JobExecutionException(""No quartz endpoint available for key: "" + QuartzEndpoint.ENDPOINT_KEY + "". Bad job data map"");
        }
        component.onJobExecute(context);
    }
}"
org.apache.camel.component.stream.StreamProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Producer that can write to streams
 */
public class StreamProducer extends DefaultProducer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(StreamProducer.class);
    private static final String TYPES = ""out,err,file,header,url"";
    private static final String INVALID_URI = ""Invalid uri, valid form: 'stream:{"" + TYPES + ""}'"";
    private static final List<String> TYPES_LIST = Arrays.asList(TYPES.split("",""));
    private OutputStream outputStream = System.out;
    private StreamEndpoint endpoint;
    private String uri;
    public StreamProducer(StreamEndpoint endpoint, String uri)
        throws Exception {
        super(endpoint);
        this.endpoint = endpoint;
        validateUri(uri);
    }
    @Override
    public void doStop() throws Exception {
        // important: do not close the stream as it will close the standard system.out etc.
        super.doStop();
    }
    public void process(Exchange exchange) throws Exception {
        delay(endpoint.getDelay());
        if (""out"".equals(uri)) {
            outputStream = System.out;
        } else if (""err"".equals(uri)) {
            outputStream = System.err;
        } else if (""file"".equals(uri)) {
            outputStream = resolveStreamFromFile();
        } else if (""header"".equals(uri)) {
            outputStream = resolveStreamFromHeader(exchange.getIn().getHeader(""stream""), exchange);
        } else if (""url"".equals(uri)) {
            outputStream = resolveStreamFromUrl();
        }
        writeToStream(exchange);
    }
    private OutputStream resolveStreamFromUrl() throws IOException {
        String u = endpoint.getUrl();
        URL url = new URL(u);
        URLConnection c = url.openConnection();
        return c.getOutputStream();
    }
    private OutputStream resolveStreamFromFile() throws IOException {
        String fileName = endpoint.getFile() != null ? endpoint.getFile().trim() : ""_file"";
        File f = new File(fileName);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""About to write to file: "" + f);
        }
        f.createNewFile();
        return new FileOutputStream(f);
    }
    private OutputStream resolveStreamFromHeader(Object o, Exchange exchange) throws CamelExchangeException {
        if (o != null && o instanceof OutputStream) {
            return (OutputStream)o;
        } else {
            throw new CamelExchangeException(""Expected OutputStream in header('stream'), found: "" + o,
                exchange);
        }
    }
    private void delay(long ms) throws InterruptedException {
        if (ms == 0) {
            return;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Delaying "" + ms + "" millis"");
        }
        Thread.sleep(ms);
    }
    private void writeToStream(Exchange exchange) throws IOException, CamelExchangeException {
        Object body = exchange.getIn().getBody();
        if (body instanceof String) {
            Charset charset = endpoint.getCharset();
            Writer writer = new OutputStreamWriter(outputStream, charset);
            BufferedWriter bw = new BufferedWriter(writer);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Writing as text: "" + body + "" to "" + outputStream + "" using encoding:"" + charset);
            }
            bw.write((String)body);
            bw.write(""\n"");
            bw.flush();
            // important: do not close the writer as it will close the standard system.out etc.
        } else if (body instanceof byte[]) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Writing as text: "" + body + "" to "" + outputStream);
            }
            outputStream.write((byte[])body);
        } else {
            throw new CamelExchangeException(""The body is neither a String or byte array. ""
                + ""Can not write body to output stream"", exchange);
        }
    }
    private void validateUri(String uri) throws Exception {
        String[] s = uri.split("":"");
        if (s.length < 2) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        String[] t = s[1].split(""\\?"");
        if (t.length < 1) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        this.uri = t[0].trim();
        if (!TYPES_LIST.contains(this.uri)) {
            throw new IllegalArgumentException(INVALID_URI);
        }
    }
}
"
org.apache.camel.spring.CamelJMXAgentType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * The JAXB type class for the configuration of jmxAgent
 * @author Willem Jiang
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""jmxAgent"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelJMXAgentType extends IdentifiedType {
    /**
     * Disable JMI (default false)
     */
    @XmlAttribute(required = false)
    private Boolean disabled;
    /**
     * RMI connector registry port (default 1099)
     */
    @XmlAttribute(required = false)
    private Integer registryPort;
    /**
     * RMI connector server port (default -1 not used)
     */
    @XmlAttribute(required = false)
    private Integer connectorPort;
    /**
     * MBean server default domain name (default org.apache.camel)
     */
    @XmlAttribute(required = false)
    private String mbeanServerDefaultDomain;
    /**
     * MBean object domain name (default org.apache.camel)
     */
    @XmlAttribute(required = false)
    private String mbeanObjectDomainName;
    /**
     * JMX Service URL path (default /jmxrmi)
     */
    @XmlAttribute(required = false)
    private String serviceUrlPath;
    /**
     * A flag that indicates whether the agent should be created
     */
    @XmlAttribute(required = false)
    private Boolean createConnector;
    /**
     * A flag that indicates whether the platform mbean server should be used
     */
    @XmlAttribute(required = false)
    private Boolean usePlatformMBeanServer;
    public Integer getConnectorPort() {
        return connectorPort;
    }
    public void setConnectorPort(Integer value) {
        connectorPort = value;
    }
    public Integer getRegistryPort() {
        return registryPort;
    }
    public void setRegistryPort(Integer value) {
        registryPort = value;
    }
    public String getMbeanServerDefaultDomain() {
        return mbeanServerDefaultDomain;
    }
    public void setMbeanServerDefaultDomain(String value) {
        mbeanServerDefaultDomain = value;
    }
    public String getMbeanObjectDomainName() {
        return mbeanObjectDomainName;
    }
    public void setMbeanObjectDomainName(String value) {
        mbeanObjectDomainName = value;
    }
    public String getServiceUrlPath() {
        return serviceUrlPath;
    }
    public void setServiceUrlPath(String value) {
        serviceUrlPath = value;
    }
    public Boolean isCreateConnector() {
        return createConnector;
    }
    public void setCreateConnector(Boolean value) {
        createConnector = value;
    }
    public Boolean isUsePlatformMBeanServer() {
        return usePlatformMBeanServer;
    }
    public void setUsePlatformMBeanServer(Boolean value) {
        usePlatformMBeanServer = value;
    }
    public Boolean isDisabled() {
        return disabled;
    }
    public void setDisabled(Boolean value) {
        disabled = value;
    }
}
"
org.apache.camel.component.jhc.JhcExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
public class JhcExchange extends DefaultExchange {
    public JhcExchange(CamelContext context) {
        super(context);
    }
    public JhcExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
}"
org.apache.camel.component.uface.UFaceBrowser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.Collection;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DelegateLifecycleStrategy;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
import org.eclipse.core.databinding.observable.Realm;
import org.eclipse.core.databinding.observable.list.IObservableList;
import org.eclipse.core.databinding.observable.list.WritableList;
import org.eclipse.core.databinding.observable.value.WritableValue;
import org.ufacekit.model.ModelHelper;
import org.ufacekit.ui.AttributeDescriptor;
import org.ufacekit.ui.UIComposite;
import org.ufacekit.ui.UIFactory;
import org.ufacekit.ui.beanform.BeanForm;
import org.ufacekit.ui.controls.CellLabelProvider;
import org.ufacekit.ui.controls.UITable;
import org.ufacekit.ui.controls.UITableColumn;
import org.ufacekit.ui.layouts.GridLayoutData;
/**
 * @version $Revision$
 */
public class UFaceBrowser {
    private final DefaultCamelContext camelContext;
    private IObservableList endpoints;
    private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
    public UFaceBrowser(DefaultCamelContext camelContext) {
        ObjectHelper.notNull(camelContext, ""camelContext"");
        this.camelContext = camelContext;
        this.endpoints = new WritableList(Realm.getDefault());
        // lets add any endpoints already added
        List<BrowsableEndpoint> list = CamelContextHelper.getSingletonEndpoints(camelContext, BrowsableEndpoint.class);
        for (BrowsableEndpoint endpoint : list) {
            if (!endpoints.contains(endpoint)) {
                endpoints.add(endpoint);
            }
        }
        camelContext.setLifecycleStrategy(new DelegateLifecycleStrategy(camelContext.getLifecycleStrategy()) {
            @Override
            public void onEndpointAdd(Endpoint<? extends Exchange> endpoint) {
                super.onEndpointAdd(endpoint);
                if (endpoint instanceof BrowsableEndpoint) {
                    onBrowsableEndpoint((BrowsableEndpoint) endpoint);
                }
            }
        });
    }
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.addPropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        propertyChangeSupport.removePropertyChangeListener(listener);
    }
    public IObservableList getEndpoints() {
        return endpoints;
    }
    public DefaultCamelContext getCamelContext() {
        return camelContext;
    }
    public void createBrowserUI(UIComposite root) {
        UIFactory ui = root.getFactory();
        UIComposite splitter = ui.newHorizontalSplitPanel(root, new GridLayoutData(GridLayoutData.ALIGN_CENTER, GridLayoutData.ALIGN_CENTER));
        UITable tree = createEndpointTableUI(splitter);
        BeanForm selectionForm = new BeanForm();
        UITable table = ui.newTable(splitter, new UITable.TableUIInfo(new GridLayoutData(GridLayoutData.ALIGN_FILL, GridLayoutData.ALIGN_FILL, true, true)));
        selectionForm.add(table, new UITable.TableBindingInfo(selectionForm.detailList(""exchanges"", Collection.class)));
        ui.newTableColumn(table, new UITableColumn.TableColumnUIInfo(null, new CellLabelProvider() {
            public String getLabel(Object object) {
                Exchange exchange = (Exchange) object;
                return exchange.getIn().getBody(String.class);
            }
        }));
        ui.newTableColumn(table, new UITableColumn.TableColumnUIInfo(null, new CellLabelProvider() {
            public String getLabel(Object object) {
                Exchange exchange = (Exchange) object;
                return exchange.getIn().getHeaders().toString();
            }
        }));
        selectionForm.bind(tree.getSelectionObservable());
    }
    protected UITable createEndpointTableUI(UIComposite root) {
        BeanForm form = new BeanForm();
        UIFactory ui = root.getFactory();
        AttributeDescriptor bindingData = form.detailList(""endpoints"", Collection.class);
        UITable table = ui.newTable(root, new UITable.TableUIInfo(null));
        form.add(table, new UITable.TableBindingInfo(bindingData));
        ui.newTableColumn(table, new UITableColumn.TableColumnUIInfo(null, new CellLabelProvider() {
            public String getLabel(Object object) {
                BrowsableEndpoint endpoint = (BrowsableEndpoint) object;
                return endpoint.getEndpointUri();
            }
        }));
        WritableValue value = ModelHelper.createWritableValue(this);
        form.bind(value);
        return table;
    }
    protected void onBrowsableEndpoint(BrowsableEndpoint endpoint) {
        endpoints.add(endpoint);
    }
}
"
org.apache.camel.component.jpa.Callback,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
/**
 * @version $Revision$
 */
public interface Callback<R, P> {
    R callback(P parameter);
}
"
org.apache.camel.component.file.remote.RemoteFileMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.OutputStream;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
public class RemoteFileMessage extends DefaultMessage {
    private OutputStream outputStream;
    private String fullFileName;
    private String hostname;
    public RemoteFileMessage() {
    }
    public RemoteFileMessage(String hostname, String fullFileName, OutputStream outputStream) {
        this.hostname = hostname;
        this.fullFileName = fullFileName;
        this.outputStream = outputStream;
        setMessageId(hostname + "":"" + fullFileName);
    }
    public String getHostname() {
        return hostname;
    }
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    public String getFullFileName() {
        return fullFileName;
    }
    public void setFullFileName(String fullFileName) {
        this.fullFileName = fullFileName;
    }
    public OutputStream getOutputStream() {
        return outputStream;
    }
    public void setOutputStream(OutputStream outputStream) {
        this.outputStream = outputStream;
    }
    @Override
    public RemoteFileExchange getExchange() {
        return (RemoteFileExchange) super.getExchange();
    }
    @Override
    protected Object createBody() {
        if (outputStream != null) {
            return getExchange().getBinding().extractBodyFromOutputStream(getExchange(), outputStream);
        }
        return null;
    }
    @Override
    public RemoteFileMessage newInstance() {
        return new RemoteFileMessage();
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        super.populateInitialHeaders(map);
        map.put(""file.remote.host"", hostname);
        map.put(""file.remote.name"", fullFileName);
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.Exchange;
import org.springframework.integration.message.GenericMessage;
/**
 * The helper class for Mapping between the Spring Integration message and
 * the Camel Message
 * @version $Revision$
 */
public final class SpringIntegrationBinding {
    private SpringIntegrationBinding() {
        // Helper class
    }
    @SuppressWarnings(""unchecked"")
    public static org.springframework.integration.message.Message createSpringIntegrationMessage(Exchange exchange) {
        org.apache.camel.Message message = exchange.getIn();
        GenericMessage siMessage = new GenericMessage(message.getBody());
        return siMessage;
    }
    @SuppressWarnings(""unchecked"")
    public static org.springframework.integration.message.Message storeToSpringIntegrationMessage(org.apache.camel.Message message) {
        GenericMessage siMessage = new GenericMessage(message.getBody());
        return siMessage;
    }
    public static void storeToCamelMessage(org.springframework.integration.message.Message siMessage, org.apache.camel.Message cMessage) {
        cMessage.setBody(siMessage.getPayload());
        //TODO copy the message header
    }
}
"
org.apache.camel.component.cxf.interceptors.FaultOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapFault;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.xml.XMLFault;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingOperationInfo;
public class FaultOutInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(FaultOutInterceptor.class);
    public FaultOutInterceptor() {
        super(Phase.PREPARE_SEND);
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        // To walk around the FaultOutInterceptor NPE issue of CXF 2.0.4
        checkBindingOperationInfor(message);
        Exception ex = message.getContent(Exception.class);
        if (ex != null) {
            if (!(ex instanceof Fault)) {
                ex = new Fault(ex);
            }
            if (message instanceof XMLMessage) {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""FaultOutInterceptor Creating XMLFault"");
                }
                ex = XMLFault.createFault((Fault)ex);
            } else if (message instanceof SoapMessage) {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""FaultOutInterceptor Creating SoapFault"");
                }
                SoapMessage sm = (SoapMessage)message;
                ex = SoapFault.createFault((Fault)ex, sm.getVersion());
            }
            message.setContent(Exception.class, ex);
        }
    }
    /*
     * This method is used to walk around the NPE issue of CXF 2.0.4
     * org.apache.cxf.interceptor.FaultOutInterceptor.
     * This issue was fixed in CXF 2.0.5 and CXF 2.1, when we upgrade CXF to that version
     * we could remove this method from the interceptor
     */
    private void checkBindingOperationInfor(Message message) {
        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);
        if (bop == null) {
            bop = new FakeBindingOperationInfo();
            message.getExchange().put(BindingOperationInfo.class, bop);
        }
    }
}
"
org.apache.camel.spring.remoting.SendBeforeInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
import org.apache.camel.component.bean.CamelInvocationHandler;
import org.apache.camel.util.CamelContextHelper;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A Spring interceptor which sends a message exchange to an endpoint before the method is invoked
 * 
 * @version $Revision$
 */
public class SendBeforeInterceptor implements MethodInterceptor, CamelContextAware, InitializingBean, DisposableBean {
    private String uri;
    private CamelContext camelContext;
    private CamelInvocationHandler invocationHandler;
    private Producer producer;
    public Object invoke(MethodInvocation invocation) throws Throwable {
        invocationHandler.invoke(invocation.getThis(), invocation.getMethod(), invocation.getArguments());
        return invocation.proceed();
    }
    public void afterPropertiesSet() throws Exception {
        notNull(uri, ""uri"");
        notNull(camelContext, ""camelContext"");
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);
        producer = endpoint.createProducer();
        producer.start();
        invocationHandler = new CamelInvocationHandler(endpoint, producer);
    }
    public void destroy() throws Exception {
        if (producer != null) {
            producer.stop();
        }
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    // Properties
    //-----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
}
"
org.apache.camel.osgi.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/osgi"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.osgi;
"
org.apache.camel.component.cxf.transport.CamelTransportFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import org.apache.camel.CamelContext;
import org.apache.cxf.Bus;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractTransportFactory;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.ConduitInitiatorManager;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.DestinationFactory;
import org.apache.cxf.transport.DestinationFactoryManager;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
/**
 * @version $Revision$
 */
public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator, DestinationFactory {
    public static final String TRANSPORT_ID = ""http://cxf.apache.org/transports/camel"";
    private static final Set<String> URI_PREFIXES = new HashSet<String>();
    private Collection<String> activationNamespaces;
    static {
        URI_PREFIXES.add(""camel://"");
    }
    private Bus bus;
    private CamelContext camelContext;
    @Resource(name = ""bus"")
    public void setBus(Bus b) {
        bus = b;
    }
    public Bus getBus() {
        return bus;
    }
    @Resource
    public void setActivationNamespaces(Collection<String> ans) {
        activationNamespaces = ans;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    @Resource(name = ""camelContext"")
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public Conduit getConduit(EndpointInfo targetInfo) throws IOException {
        return getConduit(targetInfo, null);
    }
    public Conduit getConduit(EndpointInfo endpointInfo, EndpointReferenceType target) throws IOException {
        return new CamelConduit(camelContext, bus, endpointInfo, target);
    }
    public Destination getDestination(EndpointInfo endpointInfo) throws IOException {
        return new CamelDestination(camelContext, bus, this, endpointInfo);
    }
    public Set<String> getUriPrefixes() {
        return URI_PREFIXES;
    }
    @PostConstruct
    void registerWithBindingManager() {
        if (null == bus) {
            return;
        }
        ConduitInitiatorManager cim = bus.getExtension(ConduitInitiatorManager.class);
        if (null != cim && null != activationNamespaces) {
            for (String ns : activationNamespaces) {
                cim.registerConduitInitiator(ns, this);
            }
        }
        DestinationFactoryManager dfm = bus.getExtension(DestinationFactoryManager.class);
        if (null != dfm && null != activationNamespaces) {
            for (String ns : activationNamespaces) {
                dfm.registerDestinationFactory(ns, this);
            }
        }
    }
}
"
org.apache.camel.component.cxf.util.DataInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.util.logging.Logger;
import javax.xml.stream.XMLStreamException;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import org.w3c.dom.Document;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.AbstractInDatabindingInterceptor;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.staxutils.DepthXMLStreamReader;
import org.apache.cxf.staxutils.StaxUtils;
public class DataInInterceptor extends AbstractInDatabindingInterceptor {
    private static final Logger LOG = LogUtils.getL7dLogger(DataInInterceptor.class);
    public DataInInterceptor() {
        super(Phase.UNMARSHAL);
    }
    public void handleMessage(Message message) throws Fault {
        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);
        try {
            // put the payload source as a document
            Document doc = StaxUtils.read(xmlReader);
            message.setContent(Source.class, new DOMSource(doc));
        } catch (XMLStreamException e) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""XMLSTREAM_EXCEPTION"",
                                                                   LOG),
                            e);
        }
    }
}
"
org.apache.camel.component.cxf.util.CxfEndpointUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.lang.annotation.Annotation;
import java.net.URI;
import java.net.URL;
import java.util.logging.Logger;
import javax.jws.WebService;
import javax.xml.namespace.QName;
import javax.xml.ws.WebServiceProvider;
import org.apache.camel.CamelException;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.camel.component.cxf.CxfEndpoint;
import org.apache.camel.component.cxf.DataFormat;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.cxf.Bus;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.common.i18n.Message;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.frontend.ServerFactoryBean;
import org.apache.cxf.jaxws.JaxWsClientFactoryBean;
import org.apache.cxf.jaxws.JaxWsServerFactoryBean;
import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.factory.AbstractServiceFactoryBean;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.wsdl11.WSDLServiceFactory;
public final class CxfEndpointUtils {
    public static final String PROP_NAME_PORT = ""port"";
    public static final String PROP_NAME_SERVICE = ""service"";
    public static final String PROP_NAME_SERVICECLASS = ""serviceClass"";
    public static final String PROP_NAME_DATAFORMAT = ""dataFormat"";
    public static final String DATAFORMAT_POJO = ""pojo"";
    public static final String DATAFORMAT_MESSAGE = ""message"";
    public static final String DATAFORMAT_PAYLOAD = ""payload"";
    private static final Logger LOG = LogUtils.getL7dLogger(CxfEndpointUtils.class);
    private CxfEndpointUtils() {
        // not constructed
    }
    static QName getQName(final String name) {
        QName qName = null;
        if (name != null) {
            try {
                qName =  QName.valueOf(name);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        return qName;
    }
    public static QName getPortName(final CxfEndpoint endpoint) {
        return getQName(endpoint.getPortName());
    }
    public static QName getServiceName(final CxfEndpoint endpoint) {
        return getQName(endpoint.getServiceName());
    }
    public static EndpointInfo getEndpointInfo(final Service service, final CxfEndpoint endpoint) {
        EndpointInfo endpointInfo = null;
        final java.util.Collection<EndpointInfo> endpoints = service.getServiceInfos().get(0).getEndpoints();
        if (endpoints.size() == 1) {
            endpointInfo = endpoints.iterator().next();
        } else {
            final String port = endpoint.getPortName();
            if (port != null) {
                final QName endpointName = QName.valueOf(port);
                endpointInfo = service.getServiceInfos().get(0).getEndpoint(endpointName);
            }
            //TBD may be delegate to the EndpointUri params.
        }
        return endpointInfo;
    }
    public static Class getSEIClass(String className) throws ClassNotFoundException {
        if (className == null) {
            return null;
        } else {
            return ClassLoaderUtils.loadClass(className, CxfEndpointUtils.class);
        }
    }
    public static boolean hasWebServiceAnnotation(Class<?> cls) {
        return hasAnnotation(cls, WebService.class) || hasAnnotation(cls, WebServiceProvider.class);
    }
    public static boolean hasAnnotation(Class<?> cls, Class<? extends Annotation> annotation) {
        if (cls == null || cls == Object.class) {
            return false;
        }
        if (null != cls.getAnnotation(annotation)) {
            return true;
        }
        for (Class<?> interfaceClass : cls.getInterfaces()) {
            if (null != interfaceClass.getAnnotation(annotation)) {
                return true;
            }
        }
        return hasAnnotation(cls.getSuperclass(), annotation);
    }
    public static ServerFactoryBean getServerFactoryBean(Class<?> cls) throws CamelException {
        ServerFactoryBean serverFactory  = null;
        try {
            if (cls == null) {
                serverFactory = new ServerFactoryBean();
                serverFactory.setServiceFactory(new WSDLSoapServiceFactoryBean());
            } else {
                boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
                serverFactory = isJSR181SEnabled ? new JaxWsServerFactoryBean()
                            : new ServerFactoryBean();
            }
            return serverFactory;
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    public static ClientFactoryBean getClientFactoryBean(Class<?> cls) throws CamelException {
        ClientFactoryBean clientFactory = null;
        try {
            if (cls == null) {
                clientFactory = new ClientFactoryBean();
                clientFactory.setServiceFactory(new WSDLSoapServiceFactoryBean());
            } else {
                boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
                clientFactory = isJSR181SEnabled ? new JaxWsClientFactoryBean()
                        : new ClientFactoryBean();
            }
            return clientFactory;
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    //TODO check the CxfEndpoint information integration
    public static void checkEndpiontIntegration(CxfEndpoint endpoint, Bus bus) throws CamelException {
        String wsdlLocation = endpoint.getWsdlURL();
        QName serviceQName = CxfEndpointUtils.getQName(endpoint.getServiceName());
        String serviceClassName = endpoint.getServiceClass();
        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        URL wsdlUrl = null;
        if (wsdlLocation != null) {
            try {
                wsdlUrl = UriUtils.getWsdlUrl(new URI(wsdlLocation));
            } catch (Exception e) {
                throw new CamelException(e);
            }
        }
        if (serviceQName == null) {
            throw new CamelException(new Message(""SVC_QNAME_NOT_FOUND_X"", LOG, endpoint.getServiceName()).toString());
        }
        if (serviceClassName == null && dataFormat == DataFormat.POJO) {
            throw new CamelException(new Message(""SVC_CLASS_PROP_IS_REQUIRED_X"", LOG).toString());
        }
        AbstractServiceFactoryBean serviceFactory = null;
        try {
            if (serviceClassName != null) {
                Class<?> cls = ClassLoaderUtils.loadClass(serviceClassName, CxfEndpointUtils.class);
                boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
                serviceFactory = isJSR181SEnabled
                    ? new JaxWsServiceFactoryBean() : new ReflectionServiceFactoryBean();
                serviceFactory.setBus(bus);
                if (wsdlUrl != null) {
                    ((ReflectionServiceFactoryBean)serviceFactory).setWsdlURL(wsdlUrl);
                }
                if (serviceQName != null) {
                    ((ReflectionServiceFactoryBean)serviceFactory).setServiceName(serviceQName);
                }
                ((ReflectionServiceFactoryBean)serviceFactory).setServiceClass(cls);
            } else {
                if (wsdlUrl == null) {
                    throw new CamelException(new Message(""SVC_WSDL_URL_IS_NULL_X"", LOG, wsdlLocation).toString());
                }
                serviceFactory = new WSDLServiceFactory(bus, wsdlUrl, serviceQName);
            }
        } catch (ClassNotFoundException cnfe) {
            throw new CamelException(new Message(""CLASS_X_NOT_FOUND "", LOG, serviceClassName).toString(), cnfe);
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    public static boolean getSetDefaultBus(CxfEndpoint endpoint) {
        Boolean isSetDefaultBus = null;
        // check the value of cxfEndpointBean's property
        CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
        if (cxfEndpointBean != null && cxfEndpointBean.getProperties() != null) {
            String value =  (String)cxfEndpointBean.getProperties().get(CxfConstants.SET_DEFAULT_BUS);
            isSetDefaultBus = Boolean.valueOf(value);
        }
        // We will get the value from the cxfEndpontBean's properties
        if (isSetDefaultBus != null && endpoint.isSetDefaultBus() == null) {
            return isSetDefaultBus.booleanValue();
        } else if (endpoint.isSetDefaultBus() != null) {
            return endpoint.isSetDefaultBus().booleanValue();
        } else { // return the default value false
            return false;
        }
    }
    public static DataFormat getDataFormat(CxfEndpoint endpoint) throws CamelException {
        String dataFormatString = endpoint.getDataFormat();
        if (dataFormatString == null) {
            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
            if (cxfEndpointBean != null && cxfEndpointBean.getProperties() != null) {
                dataFormatString = (String) cxfEndpointBean.getProperties().get(CxfConstants.DATA_FORMAT);
            }
        }
        // return the default value if nothing is set
        if (dataFormatString == null) {
            return DataFormat.POJO;
        }
        DataFormat retval = DataFormat.asEnum(dataFormatString);
        if (retval == DataFormat.UNKNOWN) {
            throw new CamelException(new Message(""INVALID_MESSAGE_FORMAT_XXXX"", LOG, dataFormatString).toString());
        }
        return retval;
    }
}
"
org.apache.camel.component.event.EventConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Consumer</a>
 * for working with Spring ApplicationEvents
 *
 * @version $Revision$
 */
public class EventConsumer extends DefaultConsumer<Exchange> {
    private EventEndpoint endpoint;
    public EventConsumer(EventEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.consumerStarted(this);
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.consumerStopped(this);
        super.doStop();
    }
}
"
org.apache.camel.component.validator.jing.JingComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
/**
 * A component for validating XML payloads using the
 * <a href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing library</a>
 *
 * @version $Revision$
 */
public class JingComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        JingValidator validator = new JingValidator();
        Resource resource = resolveMandatoryResource(remaining);
        validator.setSchemaResource(resource);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        configureValidator(validator, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, validator);
    }
    protected void configureValidator(JingValidator validator, String uri, String remaining, Map parameters) throws Exception {
        setProperties(validator, parameters);
    }
}
"
org.apache.camel.component.xquery.XQueryLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * @version $Revision$
 */
public class XQueryLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return XQueryBuilder.xquery(expression);
    }
    public Expression<Exchange> createExpression(String expression) {
        return XQueryBuilder.xquery(expression);
    }
}
"
org.apache.camel.component.cxf.CxfBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.jaxws.support.ContextPropertiesMapping;
import org.apache.cxf.message.Message;
/**
 * The binding/mapping of Camel messages to Apache CXF and back again
 *
 * @version $Revision$
 */
public final class CxfBinding {
    private CxfBinding() {
        // Helper class
    }
    public static Object extractBodyFromCxf(CxfExchange exchange, Message message) {
        // TODO how do we choose a format?
        return getBody(message);
    }
    protected static Object getBody(Message message) {
        Set<Class<?>> contentFormats = message.getContentFormats();
        if (contentFormats != null) {
            for (Class<?> contentFormat : contentFormats) {
                Object answer = message.getContent(contentFormat);
                if (answer != null) {
                    return answer;
                }
            }
        }
        return null;
    }
    public static Message createCxfMessage(CxfExchange exchange) {
        Message answer = exchange.getInMessage();
        CxfMessage in = exchange.getIn();
        // Check the body if the POJO parameter list first
        Object body = in.getBody(List.class);
        if (body instanceof List) {
            // just set the operation's parameter
            answer.setContent(List.class, body);
            // just set the method name
            answer.put(CxfConstants.OPERATION_NAME, (String)in.getHeader(CxfConstants.OPERATION_NAME));
            answer.put(CxfConstants.OPERATION_NAMESPACE, (String)in.getHeader(CxfConstants.OPERATION_NAMESPACE));
        } else {
            // CXF uses StAX which is based on the stream API to parse the XML,
            // so the CXF transport is also based on the stream API.
            // And the interceptors are also based on the stream API,
            // so let's use an InputStream to host the CXF on wire message.
            body = in.getBody(InputStream.class);
            if (body instanceof InputStream) {
                answer.setContent(InputStream.class, body);
            }
        }
        return answer;
    }
    // Store
    public static void storeCxfResponse(CxfExchange exchange, Message response) {
        // no need to process headers as we use the CXF message
        CxfMessage out = exchange.getOut();
        if (response != null) {
            out.setMessage(response);
            DataFormat dataFormat = (DataFormat) exchange.getProperty(CxfExchange.DATA_FORMAT);
            if (dataFormat.equals(DataFormat.MESSAGE)) {
                out.setBody(response.getContent(InputStream.class));
            }
            if (dataFormat.equals(DataFormat.PAYLOAD)) {
                out.setBody(response);
            }
        }
    }
    // Copy the Camel message to CXF message
    public static void copyMessage(org.apache.camel.Message camelMessage, org.apache.cxf.message.Message cxfMessage) {
        InputStream is = camelMessage.getBody(InputStream.class);
        if (is != null) {
            cxfMessage.setContent(InputStream.class, is);
        } else {
            Object result = camelMessage.getBody();
            if (result != null) {
                if (result instanceof InputStream) {
                    cxfMessage.setContent(InputStream.class, result);
                } else {
                    cxfMessage.setContent(result.getClass(), result);
                }
            }
        }
    }
    public static void storeCXfResponseContext(Message response, Map<String, Object> context) {
        if (context != null) {
            ContextPropertiesMapping.mapResponsefromCxf2Jaxws(context);
            response.put(Client.RESPONSE_CONTEXT, context);
        }
    }
    public static void storeCxfResponse(CxfExchange exchange, Object response) {
        CxfMessage out = exchange.getOut();
        if (response != null) {
            out.setBody(response);
        }
    }
    public static void storeCxfFault(CxfExchange exchange, Message message) {
        CxfMessage fault = exchange.getFault();
        if (fault != null) {
            fault.setBody(getBody(message));
        }
    }
    public static Map<String, Object> propogateContext(Message message, Map<String, Object> context) {
        Map<String, Object> requestContext = CastUtils.cast((Map)message.get(Client.REQUEST_CONTEXT));
        Map<String, Object> responseContext = CastUtils.cast((Map)message.get(Client.RESPONSE_CONTEXT));
        // TODO map the JAXWS properties to cxf
        if (requestContext != null) {
            ContextPropertiesMapping.mapRequestfromJaxws2Cxf(requestContext);
        }
        if (responseContext == null) {
            responseContext = new HashMap<String, Object>();
        } else {
            // clear the response context
            responseContext.clear();
        }
        context.put(Client.REQUEST_CONTEXT, requestContext);
        context.put(Client.RESPONSE_CONTEXT, responseContext);
        return responseContext;
    }
}
"
org.apache.camel.component.ibatis.IBatisEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.io.IOException;
import java.sql.SQLException;
import java.util.List;
import com.ibatis.sqlmap.client.SqlMapClient;
import org.apache.camel.Message;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultPollingEndpoint;
/**
 * An <a href=""http://activemq.apache.org/camel/ibatis.html>iBatis Endpoint</a>
 * for performing SQL operations using an XML mapping file to abstract away the SQL
 *
 * @version $Revision$
 */
public class IBatisEndpoint extends DefaultPollingEndpoint {
    private final String entityName;
    public IBatisEndpoint(String endpointUri, IBatisComponent component, String entityName) {
        super(endpointUri, component);
        this.entityName = entityName;
    }
    public IBatisEndpoint(String endpointUri, String entityName) {
        super(endpointUri);
        this.entityName = entityName;
    }
    @Override
    public IBatisComponent getComponent() {
        return (IBatisComponent) super.getComponent();
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer createProducer() throws Exception {
        return new IBatisProducer(this);
    }
    @Override
    public PollingConsumer createPollingConsumer() throws Exception {
        return new IBatisPollingConsumer(this);
    }
    /**
     * Returns the iBatis SQL client
     */
    public SqlMapClient getSqlClient() throws IOException {
        return getComponent().getSqlMapClient();
    }
    public String getEntityName() {
        return entityName;
    }
    public void query(Message message) throws IOException, SQLException {
        String name = getEntityName();
        List list = getSqlClient().queryForList(name);
        message.setBody(list);
        message.setHeader(""org.apache.camel.ibatis.queryName"", name);
    }
}
"
org.apache.camel.language.ognl.OGNL,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of <a href=""http://www.ognl.org/"">OGNL</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""ognl"")
public @interface OGNL {
    String value();
}"
org.apache.camel.processor.idempotent.jpa.MessageProcessed,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent.jpa;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.UniqueConstraint;
/**
 * @version $Revision$
 */
@Entity
@UniqueConstraint(columnNames = {""processorName"", ""messageId"" })
public class MessageProcessed {
    private Long id;
    private String messageId;
    private String processorName;
    @Override
    public String toString() {
        return ""MessageProcessed[processorName: "" + getProcessorName() + "" messageId: "" + getMessageId() + ""]"";
    }
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getMessageId() {
        return messageId;
    }
    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }
    public String getProcessorName() {
        return processorName;
    }
    public void setProcessorName(String processorName) {
        this.processorName = processorName;
    }
}
"
org.apache.camel.component.cxf.CxfProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.namespace.QName;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.cxf.feature.MessageDataFormatFeature;
import org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature;
import org.apache.camel.component.cxf.invoker.CxfClient;
import org.apache.camel.component.cxf.invoker.CxfClientFactoryBean;
import org.apache.camel.component.cxf.invoker.InvokingContext;
import org.apache.camel.component.cxf.invoker.InvokingContextFactory;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.bus.spring.SpringBusFactory;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.feature.AbstractFeature;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.BindingOperationInfo;
/**
 * Sends messages from Camel into the CXF endpoint
 *
 * @version $Revision$
 */
public class CxfProducer extends DefaultProducer<CxfExchange> {
    private CxfEndpoint endpoint;
    private Client client;
    private DataFormat dataFormat;
    public CxfProducer(CxfEndpoint endpoint) throws CamelException {
        super(endpoint);
        this.endpoint = endpoint;
        dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        if (dataFormat.equals(DataFormat.POJO)) {
            client = createClientFromClientFactoryBean(null);
        } else {
            // Create CxfClient for message or payload type
            client = createClientForStreamMessage();
        }
    }
    private Client createClientForStreamMessage() throws CamelException {
        CxfClientFactoryBean cfb = new CxfClientFactoryBean();
        Class serviceClass = null;
        if (endpoint.isSpringContextEndpoint()) {
            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
            serviceClass = cxfEndpointBean.getServiceClass();
        } else {
            if (endpoint.getServiceClass() == null) {
                throw new CamelException(""serviceClass setting missing from CXF endpoint configuration"");
            }
            try {
                serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());
            } catch (ClassNotFoundException e) {
                throw new CamelException(e);
            }
        }
        boolean jsr181Enabled = CxfEndpointUtils.hasWebServiceAnnotation(serviceClass);
        cfb.setJSR181Enabled(jsr181Enabled);
        dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        List<AbstractFeature> features = new ArrayList<AbstractFeature>();
        if (dataFormat.equals(DataFormat.MESSAGE)) {
            features.add(new MessageDataFormatFeature());
            // features.add(new LoggingFeature());
        } else if (dataFormat.equals(DataFormat.PAYLOAD)) {
            features.add(new PayLoadDataFormatFeature());
            // features.add(new LoggingFeature());
        }
        cfb.setFeatures(features);
        return createClientFromClientFactoryBean(cfb);
    }
    // If cfb is null, we will try to find the right cfb to use.
    private Client createClientFromClientFactoryBean(ClientFactoryBean cfb) throws CamelException {
        Bus bus = null;
        if (endpoint.getApplicationContext() != null) {
            SpringBusFactory bf = new SpringBusFactory(endpoint.getApplicationContext());
            bus = bf.createBus();
            if (CxfEndpointUtils.getSetDefaultBus(endpoint)) {
                BusFactory.setDefaultBus(bus);
            }
        } else {
            // now we just use the default bus here
            bus = BusFactory.getDefaultBus();
        }
        if (endpoint.isSpringContextEndpoint()) {
            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
            if (cfb == null) {
                cfb = CxfEndpointUtils.getClientFactoryBean(cxfEndpointBean.getServiceClass());
            }
            endpoint.configure(cfb);
        } else { // set up the clientFactoryBean by using URI information
            if (null != endpoint.getServiceClass()) {
                try {
                    // We need to choose the right front end to create the
                    // clientFactoryBean
                    Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this
                        .getClass());
                    if (cfb == null) {
                        cfb = CxfEndpointUtils.getClientFactoryBean(serviceClass);
                    }
                    cfb.setAddress(endpoint.getAddress());
                    if (null != endpoint.getServiceClass()) {
                        cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));
                    }
                    if (null != endpoint.getWsdlURL()) {
                        cfb.setWsdlURL(endpoint.getWsdlURL());
                    }
                } catch (ClassNotFoundException e) {
                    throw new CamelException(e);
                }
            } else { // we can't see any service class from the endpoint
                if (cfb == null) {
                    cfb = new ClientFactoryBean();
                }
                if (null != endpoint.getWsdlURL()) {
                    cfb.setWsdlURL(endpoint.getWsdlURL());
                } else {
                    // Throw an exception indicating insufficient endpoint info
                    throw new CamelException(""Not enough information to create a CXF endpoint. (Provide WSDL url or service class name.)"");
                }
            }
            if (endpoint.getServiceName() != null) {
                cfb.setServiceName(CxfEndpointUtils.getServiceName(endpoint));
            }
            if (endpoint.getPortName() != null) {
                cfb.setEndpointName(CxfEndpointUtils.getPortName(endpoint));
            }
            if (endpoint.getWsdlURL() != null) {
                cfb.setWsdlURL(endpoint.getWsdlURL());
            }
        }
        cfb.setBus(bus);
        return cfb.create();
    }
    public void process(Exchange exchange) {
        CxfExchange cxfExchange = endpoint.createExchange(exchange);
        process(cxfExchange);
        exchange.copyFrom(cxfExchange);
    }
    public void process(CxfExchange exchange) {
        Message inMessage = CxfBinding.createCxfMessage(exchange);
        exchange.setProperty(CxfExchange.DATA_FORMAT, dataFormat);
        try {
            if (dataFormat.equals(DataFormat.POJO)) {
                // InputStream is = m.getContent(InputStream.class);
                // now we just deal with the POJO invocations
                List parameters = inMessage.getContent(List.class);
                if (parameters == null) {
                    parameters = new ArrayList();
                }
                String operationName = (String)inMessage.get(CxfConstants.OPERATION_NAME);
                String operationNameSpace = (String)inMessage.get(CxfConstants.OPERATION_NAMESPACE);
                // Get context from message
                Map<String, Object> context = new HashMap<String, Object>();
                Map<String, Object> responseContext = CxfBinding.propogateContext(inMessage, context);
                Message response = new MessageImpl();
                if (operationName != null) {
                    // we need to check out the operation Namespace
                    try {
                        Object[] result = null;
                        // call for the client with the parameters
                        result = invokeClient(operationNameSpace, operationName, parameters, context);
                        response.setContent(Object[].class, result);
                        // copy the response context to the response
                        CxfBinding.storeCXfResponseContext(response, responseContext);
                        CxfBinding.storeCxfResponse(exchange, response);
                    } catch (Exception ex) {
                        response.setContent(Exception.class, ex);
                        CxfBinding.storeCxfFault(exchange, response);
                    }
                } else {
                    throw new RuntimeCamelException(""Can't find the operation name in the message!"");
                }
            } else {
                // get the invocation context
                org.apache.cxf.message.Exchange ex = exchange.getExchange();
                if (ex == null) {
                    ex = (org.apache.cxf.message.Exchange)exchange.getProperty(CxfConstants.CXF_EXCHANGE);
                    exchange.setExchange(ex);
                }
                if (ex == null) {
                    ex = new ExchangeImpl();
                    exchange.setExchange(ex);
                }
                assert ex != null;
                InvokingContext invokingContext = ex.get(InvokingContext.class);
                if (invokingContext == null) {
                    invokingContext = InvokingContextFactory.createContext(dataFormat);
                    ex.put(InvokingContext.class, invokingContext);
                }
                Map<Class, Object> params = invokingContext.getRequestContent(inMessage);
                // invoke the stream message with the exchange context
                CxfClient cxfClient = (CxfClient)client;
                // need to get the binding object to create the message
                BindingOperationInfo boi = ex.get(BindingOperationInfo.class);
                Message response = null;
                if (boi == null) {
                    // it should be the raw message
                    response = new MessageImpl();
                } else {
                    // create the message here
                    Endpoint ep = ex.get(Endpoint.class);
                    response = ep.getBinding().createMessage();
                }
                response.setExchange(ex);
                // invoke the message prepare the context
                Map<String, Object> context = new HashMap<String, Object>();
                Map<String, Object> responseContext = CxfBinding.propogateContext(inMessage, context);
                try {
                    Object result = cxfClient.dispatch(params, context, ex);
                    ex.setOutMessage(response);
                    invokingContext.setResponseContent(response, result);
                    // copy the response context to the response
                    CxfBinding.storeCXfResponseContext(response, responseContext);
                    CxfBinding.storeCxfResponse(exchange, response);
                } catch (Exception e) {
                    response.setContent(Exception.class, e);
                    CxfBinding.storeCxfFault(exchange, response);
                }
            }
        } catch (Exception e) {
            // TODO add the fault message handling work
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
    }
    private Object[] invokeClient(String operationNameSpace, String operationName, List parameters, Map<String, Object> context) throws Exception {
        QName operationQName = null;
        if (operationNameSpace == null) {
            operationQName = new QName(client.getEndpoint().getService().getName().getNamespaceURI(), operationName);
        } else {
            operationQName = new QName(operationNameSpace, operationName);
        }
        BindingOperationInfo op = client.getEndpoint().getEndpointInfo().getBinding().getOperation(operationQName);
        if (op == null) {
            throw new RuntimeCamelException(""No operation found in the CXF client, the operation is "" + operationQName);
        }
        if (!endpoint.isWrapped()) {
            if (op.isUnwrappedCapable()) {
                op = op.getUnwrappedOperation();
            }
        }
        Object[] result = client.invoke(op, parameters.toArray(), context);
        return result;
    }
}
"
org.apache.camel.component.mail.MailExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Message;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Represents an {@link Exchange} for working with Mail
 *
 * @version $Revision:520964 $
 */
public class MailExchange extends DefaultExchange {
    private MailBinding binding;
    public MailExchange(CamelContext context, ExchangePattern pattern, MailBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public MailExchange(CamelContext context, ExchangePattern pattern, MailBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new MailMessage(message));
    }
    public MailExchange(DefaultExchange parent, MailBinding binding) {
        super(parent);
        this.binding = binding;
    }
    @Override
    public MailMessage getIn() {
        return (MailMessage) super.getIn();
    }
    @Override
    public MailMessage getOut() {
        return (MailMessage) super.getOut();
    }
    @Override
    public MailMessage getOut(boolean lazyCreate) {
        return (MailMessage) super.getOut(lazyCreate);
    }
    @Override
    public MailMessage getFault() {
        return (MailMessage) super.getFault();
    }
    public MailBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new MailExchange(this, binding);
    }
    // Expose Email APIs
    //-------------------------------------------------------------------------
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected MailMessage createInMessage() {
        return new MailMessage();
    }
    @Override
    protected MailMessage createOutMessage() {
        return new MailMessage();
    }
}
"
org.apache.camel.component.spring.integration.adapter.config.CamelSourceAdpaterParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
/**
 * Parser for the &lt;camelSource/&gt; element
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelSourceAdpaterParser extends AbstractCamelContextBeanDefinitionParaser {
    @Override
    protected Class<?> getBeanClass(Element element) {
        return CamelSourceAdapter.class;
    }
}
"
org.apache.camel.component.jms.MessageJMSPropertyAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision$
 */
public class MessageJMSPropertyAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessageJMSPropertyAccessException(JMSException e) {
        super(""Failed to access a JMS property: "" + e, e);
    }
}
"
org.apache.camel.component.http.HttpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Producer;
import org.apache.camel.component.http.helper.LoadingByteArrayOutputStream;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.EntityEnclosingMethod;
import org.apache.commons.httpclient.methods.RequestEntity;
import org.apache.commons.httpclient.methods.StringRequestEntity;
import org.apache.commons.io.IOUtils;
import static org.apache.camel.component.http.HttpMethods.HTTP_METHOD;
/**
 * @version $Revision$
 */
public class HttpProducer extends DefaultProducer<HttpExchange> implements Producer<HttpExchange> {
    public static final String HTTP_RESPONSE_CODE = ""http.responseCode"";
    public static final String QUERY = ""org.apache.camel.component.http.query"";
    // This should be a set of lower-case strings
    public static final Set<String> HEADERS_TO_SKIP = new HashSet<String>(Arrays.asList(""content-length"",
                                                                                        ""content-type"",
                                                                                        HTTP_RESPONSE_CODE
                                                                                            .toLowerCase()));
    private HttpClient httpClient;
    public HttpProducer(HttpEndpoint endpoint) {
        super(endpoint);
        httpClient = endpoint.createHttpClient();
    }
    public void process(Exchange exchange) throws Exception {
        HttpMethod method = createMethod(exchange);
        Message in = exchange.getIn();
        HttpBinding binding = ((HttpEndpoint)getEndpoint()).getBinding();
        // propagate headers as HTTP headers
        for (String headerName : in.getHeaders().keySet()) {
            String headerValue = in.getHeader(headerName, String.class);
            if (binding.shouldHeaderBePropagated(headerName, headerValue)) {
                method.addRequestHeader(headerName, headerValue);
            }
        }
        // lets store the result in the output message.
        Message out = exchange.getOut(true);
        try {
            int responseCode = httpClient.executeMethod(method);
            out.setHeaders(in.getHeaders());
            out.setHeader(HTTP_RESPONSE_CODE, responseCode);
            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();
            InputStream is = method.getResponseBodyAsStream();
            IOUtils.copy(is, bos);
            bos.flush();
            is.close();
            out.setBody(bos.createInputStream());
        } finally {
            method.releaseConnection();
        }
        // lets set the headers
        Header[] headers = method.getResponseHeaders();
        for (Header header : headers) {
            String name = header.getName();
            String value = header.getValue();
            out.setHeader(name, value);
        }
    }
    public HttpClient getHttpClient() {
        return httpClient;
    }
    public void setHttpClient(HttpClient httpClient) {
        this.httpClient = httpClient;
    }
    protected HttpMethod createMethod(Exchange exchange) {
        String uri = ((HttpEndpoint)getEndpoint()).getHttpUri().toString();
        RequestEntity requestEntity = createRequestEntity(exchange);
        Object m = exchange.getIn().getHeader(HTTP_METHOD);
        HttpMethods ms = m instanceof HttpMethods
            ? (HttpMethods)m : HttpMethods.valueOf(m == null
                                                       ? requestEntity == null
                                                           ? ""GET"" : ""POST""
                                                               : m.toString());
        HttpMethod method = ms.createMethod(uri);
        if (exchange.getIn().getHeader(QUERY) != null) {
            method.setQueryString(exchange.getIn().getHeader(QUERY, String.class));
        }
        if (ms.isEntityEnclosing()) {
            ((EntityEnclosingMethod)method).setRequestEntity(requestEntity);
        }
        return method;
    }
    protected RequestEntity createRequestEntity(Exchange exchange) {
        Message in = exchange.getIn();
        if (in.getBody() == null) {
            return null;
        }
        RequestEntity entity = in.getBody(RequestEntity.class);
        if (entity == null) {
            String data = in.getBody(String.class);
            String contentType = in.getHeader(""Content-Type"", String.class);
            try {
                if (contentType != null) {
                    return new StringRequestEntity(data, contentType, null);
                }
                return new StringRequestEntity(data, null, null);
            } catch (UnsupportedEncodingException e) {
                throw new RuntimeException(e);
            }
        }
        return entity;
    }
    protected boolean shouldHeaderBePropagated(String headerName, String headerValue) {
        if (headerValue == null) {
            return false;
        }
        if (HTTP_METHOD.equals(headerName)) {
            return false;
        }
        if (headerName.startsWith(""org.apache.camel"")) {
            return false;
        }
        if (HEADERS_TO_SKIP.contains(headerName.toLowerCase())) {
            return false;
        }
        return true;
    }
}
"
org.apache.camel.component.ibatis.IBatisPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.PollingConsumerSupport;
/**
 * @version $Revision$
 */
public class IBatisPollingConsumer extends PollingConsumerSupport {
    private final IBatisEndpoint endpoint;
    public IBatisPollingConsumer(IBatisEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public Exchange receive(long timeout) {
        return receiveNoWait();
    }
    public Exchange receive() {
        return receiveNoWait();
    }
    public Exchange receiveNoWait() {
        try {
            Exchange exchange = endpoint.createExchange();
            Message in = exchange.getIn();
            endpoint.query(in);
            return exchange;
        } catch (Exception e) {
            throw new RuntimeCamelException(""Failed to poll: "" + endpoint + "". Reason: "" + e, e);
        }
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.jhc.DefaultListeningIOReactor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;
import org.apache.http.impl.nio.reactor.AbstractMultiworkerIOReactor;
import org.apache.http.impl.nio.reactor.ChannelEntry;
import org.apache.http.nio.reactor.IOReactorException;
import org.apache.http.nio.reactor.ListeningIOReactor;
import org.apache.http.params.HttpParams;
import org.apache.http.util.concurrent.ThreadFactory;
/**
 * Trunk version of DefaultListenerIOReactor.
 * Should be removed when upgrading to httpcore > alpha5
 */
public class DefaultListeningIOReactor extends AbstractMultiworkerIOReactor
        implements ListeningIOReactor {
    private volatile boolean closed;
    private final HttpParams params;
    public DefaultListeningIOReactor(
            int workerCount,
            final ThreadFactory threadFactory,
            final HttpParams params) throws IOReactorException {
        super(workerCount, threadFactory, params);
        this.params = params;
    }
    public DefaultListeningIOReactor(
            int workerCount,
            final HttpParams params) throws IOReactorException {
        this(workerCount, null, params);
    }
    private void processEvents(final Set selectedKeys) throws IOReactorException {
        for (Iterator it = selectedKeys.iterator(); it.hasNext();) {
            SelectionKey key = (SelectionKey)it.next();
            processEvent(key);
        }
        selectedKeys.clear();
    }
    private void processEvent(final SelectionKey key) throws IOReactorException {
        try {
            if (key.isAcceptable()) {
                ServerSocketChannel serverChannel = (ServerSocketChannel)key.channel();
                SocketChannel socketChannel = null;
                try {
                    socketChannel = serverChannel.accept();
                } catch (IOException ex) {
                    if (this.exceptionHandler == null || !this.exceptionHandler.handle(ex)) {
                        throw new IOReactorException(""Failure accepting connection"", ex);
                    }
                }
                if (socketChannel != null) {
                    try {
                        prepareSocket(socketChannel.socket());
                    } catch (IOException ex) {
                        if (this.exceptionHandler == null || !this.exceptionHandler.handle(ex)) {
                            throw new IOReactorException(""Failure initalizing socket"", ex);
                        }
                    }
                    ChannelEntry entry = new ChannelEntry(socketChannel);
                    addChannel(entry);
                }
            }
        } catch (CancelledKeyException ex) {
            key.attach(null);
        }
    }
    public SocketAddress listen(
            final SocketAddress address) throws IOException {
        if (this.closed) {
            throw new IllegalStateException(""I/O reactor has been shut down"");
        }
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.configureBlocking(false);
        serverChannel.socket().bind(address);
        SelectionKey key = serverChannel.register(this.selector, SelectionKey.OP_ACCEPT);
        key.attach(null);
        return serverChannel.socket().getLocalSocketAddress();
    }
    @Override
    protected void processEvents(int count) throws IOReactorException {
        processEvents(this.selector.selectedKeys());
    }
}
"
org.apache.camel.component.uface.swing.SwingBrowser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface.swing;
import java.awt.*;
import javax.swing.*;
import org.apache.camel.component.uface.UFaceBrowser;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.spring.Main;
import org.ufacekit.ui.UIComposite;
import org.ufacekit.ui.swing.SwingComposite;
import org.ufacekit.ui.swing.SwingFactory;
import org.ufacekit.ui.swing.databinding.swing.SwingRealm;
/**
 * @version $Revision$
 */
public class SwingBrowser extends UFaceBrowser {
    static {
        SwingRealm.createDefault();
    }
    public SwingBrowser(DefaultCamelContext camelContext) {
        super(camelContext);
    }
    public void run() {
        JFrame frame = new JFrame();
        frame.setTitle(""Camel Browser"");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        Container container = frame.getContentPane();
        UIComposite composite = new SwingComposite(container, new SwingFactory().newFillLayout());
        createBrowserUI(composite);
        frame.pack();
        frame.setSize(650, 500);
        frame.setVisible(true);
    }
}
"
org.apache.camel.component.jpa.QueryBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import javax.persistence.EntityManager;
import javax.persistence.Query;
/**
 * A builder of query expressions
 * 
 * @version $Revision$
 */
public abstract class QueryBuilder implements QueryFactory {
    ParameterBuilder parameterBuilder;
    /**
     * Creates a query builder using the JPA query syntax
     * 
     * @param query JPA query language to create
     * @return a query builder
     */
    public static QueryBuilder query(final String query) {
        return new QueryBuilder() {
            protected Query makeQueryObject(EntityManager entityManager) {
                return entityManager.createQuery(query);
            }
            @Override
            public String toString() {
                return ""Query: "" + query + "" params: "" + getParameterDescription();
            }
        };
    }
    /**
     * Creates a named query
     */
    public static QueryBuilder namedQuery(final String namedQuery) {
        return new QueryBuilder() {
            protected Query makeQueryObject(EntityManager entityManager) {
                return entityManager.createNamedQuery(namedQuery);
            }
            @Override
            public String toString() {
                return ""Named: "" + namedQuery + getParameterDescription();
            }
        };
    }
    /**
     * Creates a native SQL query
     */
    public static QueryBuilder nativeQuery(final String nativeQuery) {
        return new QueryBuilder() {
            protected Query makeQueryObject(EntityManager entityManager) {
                return entityManager.createNativeQuery(nativeQuery);
            }
            @Override
            public String toString() {
                return ""NativeQuery: "" + nativeQuery + getParameterDescription();
            }
        };
    }
    /**
     * Specifies the parameters to the query
     * 
     * @param parameters the parameters to be configured on the query
     * @return this query builder
     */
    public QueryBuilder parameters(Object... parameters) {
        return parameters(Arrays.asList(parameters));
    }
    /**
     * Specifies the parameters to the query as an ordered collection of
     * parameters
     * 
     * @param parameters the parameters to be configured on the query
     * @return this query builder
     */
    public QueryBuilder parameters(final Collection parameters) {
        checkNoParametersConfigured();
        parameterBuilder = new ParameterBuilder() {
            public void populateQuery(EntityManager entityManager, Query query) {
                int counter = 0;
                for (Object parameter : parameters) {
                    query.setParameter(counter++, parameter);
                }
            }
            @Override
            public String toString() {
                return ""Parameters: "" + parameters;
            }
        };
        return this;
    }
    /**
     * Specifies the parameters to the query as a Map of key/value pairs
     * 
     * @param parameterMap the parameters to be configured on the query
     * @return this query builder
     */
    public QueryBuilder parameters(final Map<String, Object> parameterMap) {
        checkNoParametersConfigured();
        parameterBuilder = new ParameterBuilder() {
            public void populateQuery(EntityManager entityManager, Query query) {
                Set<Map.Entry<String, Object>> entries = parameterMap.entrySet();
                for (Map.Entry<String, Object> entry : entries) {
                    query.setParameter(entry.getKey(), entry.getValue());
                }
            }
            @Override
            public String toString() {
                return ""Parameters: "" + parameterMap;
            }
        };
        return this;
    }
    protected void checkNoParametersConfigured() {
        if (parameterBuilder != null) {
            throw new IllegalArgumentException(""Cannot add parameters to a QueryBuilder which already has parameters configured"");
        }
    }
    public Query createQuery(EntityManager entityManager) {
        Query query = makeQueryObject(entityManager);
        populateQuery(entityManager, query);
        return query;
    }
    protected String getParameterDescription() {
        if (parameterBuilder == null) {
            return """";
        } else {
            return "" "" + parameterBuilder.toString();
        }
    }
    protected void populateQuery(EntityManager entityManager, Query query) {
        if (parameterBuilder != null) {
            parameterBuilder.populateQuery(entityManager, query);
        }
    }
    protected abstract Query makeQueryObject(EntityManager entityManager);
    /**
     * A plugin strategy to populate the query with parameters
     */
    protected abstract static class ParameterBuilder {
        public abstract void populateQuery(EntityManager entityManager, Query query);
    }
}
"
org.apache.camel.bam.ProcessBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.processor.ActivityMonitorEngine;
import org.apache.camel.bam.processor.JpaBamProcessor;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A builder of a process definition
 * 
 * @version $Revision$
 */
public abstract class ProcessBuilder extends RouteBuilder {
    private static int processCounter;
    private JpaTemplate jpaTemplate;
    private final TransactionTemplate transactionTemplate;
    private final String processName;
    private List<ActivityBuilder> activityBuilders = new ArrayList<ActivityBuilder>();
    private Class entityType = ProcessInstance.class;
    private ProcessRules processRules = new ProcessRules();
    private ProcessDefinition processDefinition;
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate) {
        this(jpaTemplate, transactionTemplate, createProcessName());
    }
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate, String processName) {
        this.jpaTemplate = jpaTemplate;
        this.transactionTemplate = transactionTemplate;
        this.processName = processName;
    }
    protected static synchronized String createProcessName() {
        return ""Process-"" + (++processCounter);
    }
    public ActivityBuilder activity(String endpointUri) {
        return activity(endpoint(endpointUri));
    }
    public ActivityBuilder activity(Endpoint endpoint) {
        ActivityBuilder answer = new ActivityBuilder(this, endpoint);
        activityBuilders.add(answer);
        return answer;
    }
    /**
     * Sets the process entity type used to perform state management
     */
    public ProcessBuilder entityType(Class entityType) {
        this.entityType = entityType;
        return this;
    }
    public Processor createActivityProcessor(ActivityBuilder activityBuilder) {
        notNull(jpaTemplate, ""jpaTemplate"");
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                processRules.setProcessDefinition(getProcessDefinition());
            }
        });
        return new JpaBamProcessor(getTransactionTemplate(), getJpaTemplate(), activityBuilder.getCorrelationExpression(), activityBuilder.getActivityRules(), getEntityType());
    }
    // Properties
    // -----------------------------------------------------------------------
    public List<ActivityBuilder> getActivityBuilders() {
        return activityBuilders;
    }
    public Class getEntityType() {
        return entityType;
    }
    public JpaTemplate getJpaTemplate() {
        return jpaTemplate;
    }
    public void setJpaTemplate(JpaTemplate jpaTemplate) {
        this.jpaTemplate = jpaTemplate;
    }
    public TransactionTemplate getTransactionTemplate() {
        return transactionTemplate;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public String getProcessName() {
        return processName;
    }
    public ProcessDefinition getProcessDefinition() {
        if (processDefinition == null) {
            processDefinition = findOrCreateProcessDefinition();
        }
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void populateRoutes(List<Route> routes) throws Exception {
        boolean first = true;
        for (ActivityBuilder builder : activityBuilders) {
            Route route = builder.createRoute();
            if (first) {
                route.getServices().add(new ActivityMonitorEngine(getJpaTemplate(), getTransactionTemplate(), getProcessRules()));
                first = false;
            }
            routes.add(route);
        }
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public ActivityDefinition findOrCreateActivityDefinition(String activityName) {
        ProcessDefinition definition = getProcessDefinition();
        List<ActivityDefinition> list = jpaTemplate.find(""select x from "" + ActivityDefinition.class.getName() + "" x where x.processDefinition = ?1 and x.name = ?2"", definition, activityName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ActivityDefinition answer = new ActivityDefinition();
            answer.setName(activityName);
            answer.setProcessDefinition(ProcessDefinition.getRefreshedProcessDefinition(jpaTemplate, definition));
            jpaTemplate.persist(answer);
            return answer;
        }
    }
    protected ProcessDefinition findOrCreateProcessDefinition() {
        List<ProcessDefinition> list = jpaTemplate.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            jpaTemplate.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.component.cxf.interceptors.AbstractMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
//import java.util.ResourceBundle;
//import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
//import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
/**
 * This is the base class for message interceptors that intercepts
 * binding specific headers and message parts as DOM Element.
 * Then moves dom elements between header and message part list based on the
 * binding operation info provided in the exchange.
 */
public abstract class AbstractMessageOutInterceptor<T extends Message>
       extends AbstractPhaseInterceptor<T> {
    public AbstractMessageOutInterceptor(String phase) {
        super(phase);
    }
    protected boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    protected abstract Logger getLogger();
    protected Element createElement(QName elName, List<Element> childEl) {
        Document doc = DOMUtils.createDocument();
        String prefix = elName.getPrefix();
        StringBuilder tagName = new StringBuilder();
        if (!"""".equals(prefix)) {
            tagName.append(prefix);
            tagName.append("":"");
        }
        tagName.append(elName.getLocalPart());
        Element el = doc.createElementNS(elName.getNamespaceURI(),
                                         tagName.toString());
        if (!"""".equals(elName.getPrefix())) {
            StringBuilder attrName = new StringBuilder(""xmlns"");        
            attrName.append(':');
            attrName.append(elName.getPrefix());
            el.setAttribute(attrName.toString(), elName.getNamespaceURI());
        }
        for (Element part : childEl) {
            Node adoptedNode = doc.adoptNode(part);
            el.appendChild(adoptedNode);
        }
        return el;
    }    
}
"
org.apache.camel.component.file.remote.RemoteFileConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
public abstract class RemoteFileConsumer<T extends RemoteFileExchange> extends ScheduledPollConsumer<T> {
    RemoteFileEndpoint<T> endpoint;
    public RemoteFileConsumer(RemoteFileEndpoint<T> endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    public RemoteFileConsumer(RemoteFileEndpoint<T> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
    }
}
"
org.apache.camel.builder.script.ScriptEvaluationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if the script evaluation fails
 * 
 * @version $Revision$
 */
public class ScriptEvaluationException extends RuntimeCamelException {
    public ScriptEvaluationException(String message) {
        super(message);
    }
    public ScriptEvaluationException(String message, Throwable cause) {
        super(message, cause);
    }
    public ScriptEvaluationException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.net.URI;
import org.apache.camel.RuntimeCamelException;
public class RemoteFileConfiguration implements Cloneable {
    private String protocol;
    private String username;
    private String host;
    private int port;
    private String password;
    private String file;
    private boolean binary;
    private boolean directory = true;
    public RemoteFileConfiguration() {
    }
    public RemoteFileConfiguration(URI uri) {
        configure(uri);
    }
    public RemoteFileConfiguration copy() {
        try {
            return (RemoteFileConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public String toString() {
        return protocol + ""://"" + username + ""@"" + host + "":"" + port + ""/"" + file;
    }
    public void configure(URI uri) {
        setProtocol(uri.getScheme());
        setDefaultPort();
        setUsername(uri.getUserInfo());
        setHost(uri.getHost());
        setPort(uri.getPort());
        setFile(uri.getPath());
    }
    protected void setDefaultPort() {
        if (""ftp"".equalsIgnoreCase(protocol)) {
            setPort(21);
        } else if (""sftp"".equalsIgnoreCase(protocol)) {
            setPort(22);
        }
    }
    public String getFile() {
        return file;
    }
    public void setFile(String file) {
        // Avoid accidentally putting everything in root on
        // servers that expose the full filesystem
        if (file.startsWith(""/"")) {
            file = file.substring(1);
        }
        this.file = file;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        if (port != -1) { // use default
            this.port = port;
        }
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getProtocol() {
        return protocol;
    }
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public boolean isBinary() {
        return binary;
    }
    public void setBinary(boolean binary) {
        this.binary = binary;
    }
    public boolean isDirectory() {
        return directory;
    }
    public void setDirectory(boolean directory) {
        this.directory = directory;
    }
    public String dump() {
        return ""RemoteFileConfiguration{"" + ""protocol='"" + protocol + '\'' + "", username='"" + username + '\'' + "", host='"" + host + '\'' + "", port="" + port + "", password='"" + password + '\''
               + "", file='"" + file + '\'' + "", binary="" + binary + "", directory="" + directory + '}';
    }
}
"
org.apache.camel.component.jhc.JhcServerEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import javax.net.ssl.SSLContext;
import org.apache.camel.component.jhc.JhcConsumer.MyHandler;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.impl.nio.DefaultServerIOEventDispatch;
import org.apache.http.impl.nio.reactor.SSLServerIOEventDispatch;
import org.apache.http.nio.reactor.IOEventDispatch;
import org.apache.http.nio.reactor.IOReactorException;
import org.apache.http.nio.reactor.ListeningIOReactor;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.HttpRequestHandler;
import org.apache.http.protocol.HttpRequestHandlerRegistry;
import org.apache.http.protocol.HttpRequestHandlerResolver;
import org.apache.http.util.concurrent.ThreadFactory;
public class JhcServerEngine {
    private static final Log LOG = LogFactory.getLog(JhcServerEngine.class);
    private final HttpParams params;
    private int port;
    private String protocol;
    private int nbThreads = 2;
    private ListeningIOReactor ioReactor;
    private ThreadFactory threadFactory;
    private Thread runner;
    private SSLContext sslContext;
    private AsyncBufferingHttpServiceHandler serviceHandler;
    private HttpRequestHandlerRegistry handlerRegistry;
    private boolean isStarted;
    private int referenceCounter;
    JhcServerEngine(HttpParams params, int port, String protocol) {
        this.params = params;
        serviceHandler = new AsyncBufferingHttpServiceHandler(params);
        handlerRegistry = new HttpRequestHandlerRegistry();
        serviceHandler.setHandlerResolver(handlerRegistry);
        this.port = port;
        this.protocol = protocol;
    }
    public int getPort() {
        return port;
    }
    public String getProtocol() {
        return this.protocol;
    }
    public void setSslContext(SSLContext sslContext) {
        this.sslContext = sslContext;
    }
    public SSLContext getSslContext() {
        return this.sslContext;
    }
    public synchronized void register(String pattern, AsyncHttpRequestHandler handler) {
        handlerRegistry.register(pattern, handler);
        referenceCounter++;
    }
    public synchronized void unregister(String pattern) {
        handlerRegistry.unregister(pattern);
        referenceCounter--;
    }
    public int getReferenceCounter() {
        return referenceCounter;
    }
    public boolean isStarted() {
        return isStarted;
    }
    public void start() throws IOReactorException {
        final SocketAddress addr = new InetSocketAddress(port);
        ioReactor = new DefaultListeningIOReactor(nbThreads, threadFactory, params);
        final IOEventDispatch ioEventDispatch;
        if (""https"".equals(protocol)) {
            ioEventDispatch = new SSLServerIOEventDispatch(serviceHandler, sslContext, params);
        } else {
            ioEventDispatch = new DefaultServerIOEventDispatch(serviceHandler, params);
        }
        runner = new Thread() {
            public void run() {
                try {
                    ioReactor.listen(addr);
                    isStarted = true;
                    ioReactor.execute(ioEventDispatch);
                } catch (InterruptedIOException ex) {
                    LOG.info(""Interrupted"");
                } catch (IOException e) {
                    LOG.warn(""I/O error: "" + e.getMessage());
                }
                LOG.debug(""Shutdown"");
            }
        };
        runner.start();
    }
    public void stop() throws IOException {
        LOG.debug(""Stopping the jhc ioReactor "");
        ioReactor.shutdown();
        LOG.debug(""Waiting the runner"");
        try {
            runner.join();
        } catch (InterruptedException e) {
            //do nothing here
        }
        isStarted = false;
        LOG.debug(""Runner stopped"");
    }
}
"
org.apache.camel.osgi.CamelNamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import java.util.HashSet;
import java.util.Set;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
public class CamelNamespaceHandler extends org.apache.camel.spring.handler.CamelNamespaceHandler {
    public void init() {
        super.init();
        registerParser(""camelContext"", new CamelContextBeanDefinitionParser(CamelContextFactoryBean.class));
    }
    protected JAXBContext createJaxbContext() throws JAXBException {
        StringBuilder packages = new StringBuilder();
        for (Class cl : getJaxbPackages()) {
            if (packages.length() > 0) {
                packages.append("":"");
            }
            packages.append(cl.getName().substring(0, cl.getName().lastIndexOf('.')));
        }
        return JAXBContext.newInstance(packages.toString(), getClass().getClassLoader());
    }
    protected Set<Class> getJaxbPackages() {
        Set<Class> classes = new HashSet<Class>();
        classes.add(org.apache.camel.osgi.CamelContextFactoryBean.class);
        classes.add(org.apache.camel.spring.CamelContextFactoryBean.class);
        classes.add(org.apache.camel.model.RouteType.class);
        classes.add(org.apache.camel.model.config.StreamResequencerConfig.class);
        classes.add(org.apache.camel.model.dataformat.DataFormatType.class);
        classes.add(org.apache.camel.model.language.ExpressionType.class);
        classes.add(org.apache.camel.model.loadbalancer.LoadBalancerType.class);
        return classes;
    }
}
"
org.apache.camel.component.jdbc.JdbcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.net.URI;
import java.net.URISyntaxException;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision:520964 $
 */
public class JdbcEndpoint extends DefaultEndpoint<DefaultExchange> {
    private URI uri;
    private String remaining;
    /** The maximum size for reading a result set <code>readSize</code> */
    private int readSize = 20000;
    protected JdbcEndpoint(String endpointUri, String remaining, JdbcComponent component) throws URISyntaxException {
        super(endpointUri, component);
        this.uri = new URI(endpointUri);
        this.remaining = remaining;
    }
    public JdbcEndpoint(String endpointUri, String remaining) throws URISyntaxException {
        super(endpointUri);
        this.remaining = remaining;
        this.uri = new URI(endpointUri);
    }
    public boolean isSingleton() {
        return false;
    }
    public Consumer<DefaultExchange> createConsumer(Processor processor) throws Exception {
        throw new RuntimeCamelException(""A JDBC Consumer would be the server side of database! No such support here"");
    }
    public Producer<DefaultExchange> createProducer() throws Exception {
        return new JdbcProducer(this, remaining, readSize);
    }
    public String getName() {
        String path = uri.getPath();
        if (path == null) {
            path = uri.getSchemeSpecificPart();
        }
        return path;
    }
    public int getReadSize() {
        return this.readSize;
    }
    public void setReadSize(int readSize) {
        this.readSize = readSize;
    }
}
"
org.apache.camel.component.cxf.transport.spring.NamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
public class NamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser(""conduit"", new CamelConduitDefinitionParser());
        registerBeanDefinitionParser(""destination"", new CamelDestinationDefinitionParser());
    }
}
"
org.apache.camel.component.uface.swing.Main,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface.swing;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultCamelContext;
/**
 * @version $Revision$
 */
public class Main extends org.apache.camel.spring.Main {
    public static void main(String... args) {
        new Main().run(args);
    }
    protected void postProcesCamelContext(CamelContext camelContext) throws Exception {
        super.postProcesCamelContext(camelContext);
        SwingBrowser browser = new SwingBrowser((DefaultCamelContext) camelContext);
        browser.run();
    }
}
"
org.apache.camel.converter.jaxb.ObjectHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""objectHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class ObjectHeader extends HeaderType {
    @XmlAnyElement(lax = true)
    private Object value;
    public ObjectHeader() {
    }
    public ObjectHeader(String name, Object value) {
        super(name);
        this.value = value;
    }
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
}
"
org.apache.camel.builder.sql.SqlBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.sql;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.util.ObjectHelper;
import org.josql.Query;
import org.josql.QueryExecutionException;
import org.josql.QueryParseException;
/**
 * A builder of SQL {@link org.apache.camel.Expression} and
 * {@link org.apache.camel.Predicate} implementations
 * 
 * @version $Revision$
 */
public class SqlBuilder<E extends Exchange> implements Expression<E>, Predicate<E> {
    private Query query;
    private Map<String, Object> variables = new HashMap<String, Object>();
    public SqlBuilder(Query query) {
        this.query = query;
    }
    public Object evaluate(E exchange) {
        return evaluateQuery(exchange);
    }
    public boolean matches(E exchange) {
        List list = evaluateQuery(exchange);
        return matches(exchange, list);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        List list = evaluateQuery(exchange);
        if (!matches(exchange, list)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as found "" + list);
        }
    }
    // Builder API
    // -----------------------------------------------------------------------
    /**
     * Creates a new builder for the given SQL query string
     * 
     * @param sql the SQL query to perform
     * @return a new builder
     * @throws QueryParseException if there is an issue with the SQL
     */
    public static <E extends Exchange> SqlBuilder<E> sql(String sql) throws QueryParseException {
        Query q = new Query();
        q.parse(sql);
        return new SqlBuilder(q);
    }
    /**
     * Adds the variable value to be used by the SQL query
     */
    public SqlBuilder<E> variable(String name, Object value) {
        getVariables().put(name, value);
        return this;
    }
    // Properties
    // -----------------------------------------------------------------------
    public Map<String, Object> getVariables() {
        return variables;
    }
    public void setVariables(Map<String, Object> properties) {
        this.variables = properties;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected boolean matches(E exchange, List list) {
        return ObjectHelper.matches(list);
    }
    protected List evaluateQuery(E exchange) {
        configureQuery(exchange);
        Message in = exchange.getIn();
        List list = in.getBody(List.class);
        if (list == null) {
            list = Collections.singletonList(in.getBody());
        }
        try {
            return query.execute(list).getResults();
        } catch (QueryExecutionException e) {
            throw new RuntimeExpressionException(e);
        }
    }
    protected void configureQuery(E exchange) {
        // lets pass in the headers as variables that the SQL can use
        addVariables(exchange.getProperties());
        addVariables(exchange.getIn().getHeaders());
        addVariables(getVariables());
        query.setVariable(""exchange"", exchange);
        query.setVariable(""in"", exchange.getIn());
        query.setVariable(""out"", exchange.getOut());
    }
    protected void addVariables(Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            query.setVariable(entry.getKey(), entry.getValue());
        }
    }
}
"
org.apache.camel.component.jms.JmsBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.Serializable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.jms.BytesMessage;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import javax.xml.transform.TransformerException;
import org.w3c.dom.Node;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ExchangeHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A Strategy used to convert between a Camel {@link JmsExchange} and {@link JmsMessage}
 * to and from a JMS {@link Message}
 *
 * @version $Revision$
 */
public class JmsBinding {
    private static final transient Log LOG = LogFactory.getLog(JmsBinding.class);
    private JmsEndpoint endpoint;
    private Set<String> ignoreJmsHeaders;
    private XmlConverter xmlConverter = new XmlConverter();
    public JmsBinding() {
    }
    public JmsBinding(JmsEndpoint endpoint) {
        this.endpoint = endpoint;
    }
    /**
     * Extracts the body from the JMS message
     *
     * @param exchange the exchange
     * @param message  the message to extract its body
     * @return the body, can be <tt>null</tt>
     */
    public Object extractBodyFromJms(Exchange exchange, Message message) {
        try {
            if (message instanceof ObjectMessage) {
                ObjectMessage objectMessage = (ObjectMessage)message;
                return objectMessage.getObject();
            } else if (message instanceof TextMessage) {
                TextMessage textMessage = (TextMessage)message;
                return textMessage.getText();
            } else if (message instanceof MapMessage) {
                return createMapFromMapMessage((MapMessage)message);
            } else if (message instanceof BytesMessage) {
                return createByteArrayFromBytesMessage((BytesMessage)message);
            } else if (message instanceof StreamMessage) {
                return message;
            } else {
                return null;
            }
        } catch (JMSException e) {
            throw new RuntimeJmsException(""Failed to extract body due to: "" + e + "". Message: "" + message, e);
        }
    }
    protected byte[] createByteArrayFromBytesMessage(BytesMessage message) throws JMSException {
        if (message.getBodyLength() > Integer.MAX_VALUE) {
            return null;
        }
        byte[] result = new byte[(int)message.getBodyLength()];
        message.readBytes(result);
        return result;
    }
    /**
     * Creates a JMS message from the Camel exchange and message
     *
     * @param session the JMS session used to create the message
     * @return a newly created JMS Message instance containing the
     * @throws JMSException if the message could not be created
     */
    public Message makeJmsMessage(Exchange exchange, Session session) throws JMSException {
        return makeJmsMessage(exchange, exchange.getIn(), session);
    }
    /**
     * Creates a JMS message from the Camel exchange and message
     *
     * @param session the JMS session used to create the message
     * @return a newly created JMS Message instance containing the
     * @throws JMSException if the message could not be created
     */
    public Message makeJmsMessage(Exchange exchange, org.apache.camel.Message camelMessage, Session session)
        throws JMSException {
        Message answer = null;
        boolean alwaysCopy = (endpoint != null) ? endpoint.getConfiguration().isAlwaysCopyMessage() : false;
        if (!alwaysCopy && camelMessage instanceof JmsMessage) {
            JmsMessage jmsMessage = (JmsMessage)camelMessage;
            if (!jmsMessage.shouldCreateNewMessage()) {
                answer = jmsMessage.getJmsMessage();
            }
        }
        if (answer == null) {
            answer = createJmsMessage(camelMessage.getBody(), session, exchange.getContext());
            appendJmsProperties(answer, exchange, camelMessage);
        }
        return answer;
    }
    /**
     * Appends the JMS headers from the Camel {@link JmsMessage}
     */
    public void appendJmsProperties(Message jmsMessage, Exchange exchange) throws JMSException {
        appendJmsProperties(jmsMessage, exchange, exchange.getIn());
    }
    /**
     * Appends the JMS headers from the Camel {@link JmsMessage}
     */
    public void appendJmsProperties(Message jmsMessage, Exchange exchange, org.apache.camel.Message in)
        throws JMSException {
        Set<Map.Entry<String, Object>> entries = in.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            appendJmsProperty(jmsMessage, exchange, in, headerName, headerValue);
        }
    }
    public void appendJmsProperty(Message jmsMessage, Exchange exchange, org.apache.camel.Message in,
                                  String headerName, Object headerValue) throws JMSException {
        if (headerName.startsWith(""JMS"") && !headerName.startsWith(""JMSX"")) {
            if (headerName.equals(""JMSCorrelationID"")) {
                jmsMessage.setJMSCorrelationID(ExchangeHelper.convertToType(exchange, String.class,
                    headerValue));
            } else if (headerName.equals(""JMSCorrelationID"")) {
                jmsMessage.setJMSCorrelationID(ExchangeHelper.convertToType(exchange, String.class,
                    headerValue));
            } else if (headerName.equals(""JMSReplyTo"") && headerValue != null) {
                jmsMessage.setJMSReplyTo(ExchangeHelper.convertToType(exchange, Destination.class,
                    headerValue));
            } else if (headerName.equals(""JMSType"")) {
                jmsMessage.setJMSType(ExchangeHelper.convertToType(exchange, String.class, headerValue));
            } else if (LOG.isDebugEnabled()) {
                // The following properties are set by the MessageProducer
                // JMSDeliveryMode, JMSDestination, JMSExpiration,
                // JMSPriority,
                // The following are set on the underlying JMS provider
                // JMSMessageID, JMSTimestamp, JMSRedelivered
                LOG.debug(""Ignoring JMS header: "" + headerName + "" with value: "" + headerValue);
            }
        } else if (shouldOutputHeader(in, headerName, headerValue)) {
            // must encode to safe JMS header name before setting property on jmsMessage
            String key = encodeToSafeJmsHeaderName(headerName);
            // only primitive headers and strings is allowed as properties
            // see message properties: http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html
            Object value = getValidJMSHeaderValue(headerName, headerValue);
            if (value != null) {
                jmsMessage.setObjectProperty(key, headerValue);
            } else if (LOG.isDebugEnabled()) {
                // okay the value is not a primitive or string so we can not sent it over the wire
                LOG.debug(""Ignoring non primitive header: "" + headerName + "" of class: ""
                    + headerValue.getClass().getName() + "" with value: "" + headerValue);
            }
        }
    }
    /**
     * Strategy to test if the given header is valid according to the JMS spec to be set as a property
     * on the JMS message.
     * <p/>
     * This default implementation will allow:
     * <ul>
     *   <li>any primitives and their counter Objects (Integer, Double etc.)</li>
     *   <li>String and any other litterals, Character, CharSequence</li>
     *   <li>BigDecimal and BigInteger</li>
     *   <li>java.util.Date</li>
     * </ul>
     *
     * @param headerName   the header name
     * @param headerValue  the header value
     * @return  the value to use, <tt>null</tt> to ignore this header
     */
    protected Object getValidJMSHeaderValue(String headerName, Object headerValue) {
        if (headerValue.getClass().isPrimitive()) {
            return headerValue;
        } else if (headerValue instanceof String) {
            return headerValue;
        } else if (headerValue instanceof Number) {
            return headerValue;
        } else if (headerValue instanceof Character) {
            return headerValue.toString();
        } else if (headerValue instanceof BigDecimal || headerValue instanceof BigInteger) {
            return headerValue.toString();
        } else if (headerValue instanceof CharSequence) {
            return headerValue.toString();
        } else if (headerValue instanceof Date) {
            return headerValue.toString();
        }
        return null;
    }
    protected Message createJmsMessage(Object body, Session session, CamelContext context)
        throws JMSException {
        if (body instanceof Node) {
            // lets convert the document to a String format
            try {
                body = xmlConverter.toString((Node)body);
            } catch (TransformerException e) {
                JMSException jmsException = new JMSException(e.getMessage());
                jmsException.setLinkedException(e);
                throw jmsException;
            }
        }
        if (body instanceof byte[]) {
            BytesMessage result = session.createBytesMessage();
            result.writeBytes((byte[])body);
            return result;
        }
        if (body instanceof Map) {
            MapMessage result = session.createMapMessage();
            Map<?, ?> map = (Map<?, ?>)body;
            try {
                populateMapMessage(result, map, context);
                return result;
            } catch (JMSException e) {
                // if MapMessage creation failed then fall back to Object
                // Message
            }
        }
        if (body instanceof String) {
            return session.createTextMessage((String)body);
        }
        if (body instanceof Serializable) {
            return session.createObjectMessage((Serializable)body);
        }
        return session.createMessage();
    }
    /**
     * Populates a {@link MapMessage} from a {@link Map} instance.
     */
    protected void populateMapMessage(MapMessage message, Map<?, ?> map, CamelContext context)
        throws JMSException {
        for (Object key : map.keySet()) {
            String keyString = CamelContextHelper.convertTo(context, String.class, key);
            if (keyString != null) {
                message.setObject(keyString, map.get(key));
            }
        }
    }
    /**
     * Extracts a {@link Map} from a {@link MapMessage}
     */
    public Map<String, Object> createMapFromMapMessage(MapMessage message) throws JMSException {
        Map<String, Object> answer = new HashMap<String, Object>();
        Enumeration names = message.getMapNames();
        while (names.hasMoreElements()) {
            String name = names.nextElement().toString();
            Object value = message.getObject(name);
            answer.put(name, value);
        }
        return answer;
    }
    public Set<String> getIgnoreJmsHeaders() {
        if (ignoreJmsHeaders == null) {
            ignoreJmsHeaders = new HashSet<String>();
            populateIgnoreJmsHeaders(ignoreJmsHeaders);
        }
        return ignoreJmsHeaders;
    }
    public void setIgnoreJmsHeaders(Set<String> ignoreJmsHeaders) {
        this.ignoreJmsHeaders = ignoreJmsHeaders;
    }
    /**
     * Strategy to allow filtering of headers which are put on the JMS message
     * <p/>
     * <b>Note</b>: Currently only supports sending java identifiers as keys
     */
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName,
                                         Object headerValue) {
        String key = encodeToSafeJmsHeaderName(headerName);
        return headerValue != null && !getIgnoreJmsHeaders().contains(headerName)
            && ObjectHelper.isJavaIdentifier(key);
    }
    /**
     * Encoder to encode JMS header keys that is that can be sent over the JMS transport.
     * <p/>
     * For example: Sending dots is the key is not allowed. Especially the Bean component has
     * this problem if you want to provide the method name to invoke on the bean.
     * <p/>
     * <b>Note</b>: Currently this encoder is simple as it only supports encoding dots to underscores.
     *
     * @param headerName the header name
     * @return the key to use instead for storing properties and to be for lookup of the same property
     */
    public static String encodeToSafeJmsHeaderName(String headerName) {
        return headerName.replace(""."", ""_"");
    }
    /**
     * Decode operation for the {@link #encodeToSafeJmsHeaderName(String)}.
     *
     * @param headerName the header name
     * @return the original key
     */
    public static String decodeFromSafeJmsHeaderName(String headerName) {
        return headerName.replace(""_"", ""."");
    }
    /**
     * Populate any JMS headers that should be excluded from being copied from
     * an input message onto an outgoing message
     */
    protected void populateIgnoreJmsHeaders(Set<String> set) {
        // ignore provider specified JMS extension headers see page 39 of JMS 1.1 specification
        // added ""JMSXRecvTimestamp"" as a workaround for an Oracle bug/typo in AqjmsMessage
        String[] ignore = {""JMSXUserID"", ""JMSXAppID"", ""JMSXDeliveryCount"", ""JMSXProducerTXID"",
            ""JMSXConsumerTXID"", ""JMSXRcvTimestamp"", ""JMSXRecvTimestamp"", ""JMSXState""};
        set.addAll(Arrays.asList(ignore));
    }
}
"
org.apache.camel.component.cxf.CxfExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
/**
 * An {@link Exchange} for working with Apache CXF which exposes the underlying
 * CXF messages via {@link #getInMessage()} and {@link #getOutMessage()} along with the
 * {@link #getExchange()}
 *
 * @version $Revision$
 */
public class CxfExchange extends DefaultExchange {
    public static final String DATA_FORMAT = ""DATA_FORMAT"";
    private Exchange exchange;
    public CxfExchange(CamelContext context, ExchangePattern pattern, Exchange exchange) {
        super(context, pattern);
        this.exchange = exchange;
        // TO avoid the NPE here
        if (exchange != null) {
            if (exchange.getOutMessage() != null) {
                setOut(new CxfMessage(exchange.getOutMessage()));
            }
            if (exchange.getInMessage() != null) {
                setIn(new CxfMessage(exchange.getInMessage()));
            }
            if (exchange.getInFaultMessage() != null) {
                setFault(new CxfMessage(exchange.getInFaultMessage()));
            }
        }
    }
    public CxfExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    public CxfExchange(CamelContext context, ExchangePattern pattern, Message inMessage) {
        this(context, pattern);
        this.exchange = inMessage.getExchange();
        setIn(new CxfMessage(inMessage));
        if (exchange != null) {
            if (exchange.getOutMessage() != null) {
                setOut(new CxfMessage(exchange.getOutMessage()));
            }
            if (exchange.getInFaultMessage() != null) {
                setFault(new CxfMessage(exchange.getInFaultMessage()));
            }
        }
    }
    @Override
    public org.apache.camel.Exchange newInstance() {
        return new CxfExchange(this.getContext(), this.getPattern(), this.getExchange());
    }
    @Override
    public CxfMessage getIn() {
        return (CxfMessage) super.getIn();
    }
    @Override
    public CxfMessage getOut() {
        return (CxfMessage) super.getOut();
    }
    @Override
    public CxfMessage getOut(boolean lazyCreate) {
        return (CxfMessage) super.getOut(lazyCreate);
    }
    @Override
    public CxfMessage getFault() {
        return (CxfMessage) super.getFault();
    }
    @Override
    protected org.apache.camel.Message createFaultMessage() {
        return new CxfMessage();
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    // Expose CXF APIs directly on the exchange
    //-------------------------------------------------------------------------
    /**
     * Returns the underlying CXF message exchange for an inbound exchange
     * or null for outbound messages
     *
     * @return the inbound message exchange
     */
    public Exchange getExchange() {
        return exchange;
    }
    public Message getInMessage() {
        return getIn().getMessage();
    }
    public Message getOutMessage() {
        return getOut().getMessage();
    }
    public Message getOutFaultMessage() {
        return getExchange().getOutFaultMessage();
    }
    public Message getInFaultMessage() {
        return getExchange().getInFaultMessage();
    }
    public Destination getDestination() {
        return getExchange().getDestination();
    }
    public Conduit getConduit(Message message) {
        return getExchange().getConduit(message);
    }
    @Override
    protected CxfMessage createInMessage() {
        return new CxfMessage();
    }
    @Override
    protected CxfMessage createOutMessage() {
        return new CxfMessage();
    }
}
"
org.apache.camel.component.jpa.JpaTemplateTransactionStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceException;
import org.apache.camel.impl.ServiceSupport;
import org.springframework.orm.jpa.JpaCallback;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * Delegates the strategy to the {@link JpaTemplate} and {@link TransactionTemplate} for transaction handling
 *
 * @version $Revision$
 */
public class JpaTemplateTransactionStrategy extends ServiceSupport implements TransactionStrategy {
    private final JpaTemplate jpaTemplate;
    private final TransactionTemplate transactionTemplate;
    public JpaTemplateTransactionStrategy(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate) {
        this.jpaTemplate = jpaTemplate;
        this.transactionTemplate = transactionTemplate;
    }
    /**
     * Creates a new implementation from the given JPA factory
     */
    public static JpaTemplateTransactionStrategy newInstance(EntityManagerFactory emf) {
        JpaTemplate template = new JpaTemplate(emf);
        return newInstance(emf, template);
    }
    public static JpaTemplateTransactionStrategy newInstance(EntityManagerFactory emf, JpaTemplate template) {
        JpaTransactionManager transactionManager = new JpaTransactionManager(emf);
        transactionManager.afterPropertiesSet();
        TransactionTemplate tranasctionTemplate = new TransactionTemplate(transactionManager);
        tranasctionTemplate.afterPropertiesSet();
        return new JpaTemplateTransactionStrategy(template, tranasctionTemplate);
    }
    public Object execute(final JpaCallback callback) {
        return transactionTemplate.execute(new TransactionCallback() {
            public Object doInTransaction(TransactionStatus status) {
                return jpaTemplate.execute(new JpaCallback() {
                    public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                        return callback.doInJpa(entityManager);
                    }
                });
            }
        });
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.jms.MessagePropertyAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -3996286386119163309L;
    private final String propertyName;
    public MessagePropertyAccessException(String propertyName, JMSException e) {
        super(""Error accessing header: "" + propertyName, e);
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.converter.jaxb.FallbackTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.util.JAXBSource;
import javax.xml.transform.Source;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.TypeConverterAware;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision$
 */
public class FallbackTypeConverter implements TypeConverter, TypeConverterAware {
    private static final transient Log LOG = LogFactory.getLog(FallbackTypeConverter.class);
    private TypeConverter parentTypeConverter;
    private boolean prettyPrint = true;
    public boolean isPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    public void setTypeConverter(TypeConverter parentTypeConverter) {
        this.parentTypeConverter = parentTypeConverter;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        try {
            if (isJaxbType(type)) {
                return unmarshall(type, value);
            }
            if (value != null) {
                if (isJaxbType(value.getClass())) {
                    return marshall(type, value);
                }
            }
            return null;
        } catch (JAXBException e) {
            throw new RuntimeCamelException(e);
        }
    }
    protected <T> boolean isJaxbType(Class<T> type) {
        XmlRootElement element = type.getAnnotation(XmlRootElement.class);
        boolean jaxbType = element != null;
        return jaxbType;
    }
    /**
     * Lets try parse via JAXB
     */
    protected <T> T unmarshall(Class<T> type, Object value) throws JAXBException {
        JAXBContext context = createContext(type);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        if (parentTypeConverter != null) {
            InputStream inputStream = parentTypeConverter.convertTo(InputStream.class, value);
            if (inputStream != null) {
                Object unmarshalled = unmarshaller.unmarshal(inputStream);
                return type.cast(unmarshalled);
            }
            Reader reader = parentTypeConverter.convertTo(Reader.class, value);
            if (reader != null) {
                Object unmarshalled = unmarshaller.unmarshal(reader);
                return type.cast(unmarshalled);
            }
            Source source = parentTypeConverter.convertTo(Source.class, value);
            if (source != null) {
                Object unmarshalled = unmarshaller.unmarshal(source);
                return type.cast(unmarshalled);
            }
        }
        if (value instanceof String) {
            value = new StringReader((String) value);
        }
        if (value instanceof InputStream) {
            Object unmarshalled = unmarshaller.unmarshal((InputStream) value);
            return type.cast(unmarshalled);
        }
        if (value instanceof Reader) {
            Object unmarshalled = unmarshaller.unmarshal((Reader) value);
            return type.cast(unmarshalled);
        }
        return null;
    }
    protected <T> T marshall(Class<T> type, Object value) throws JAXBException {
        if (parentTypeConverter != null) {
            // lets convert the object to a JAXB source and try convert that to
            // the required source
            JAXBContext context = createContext(value.getClass());
            JAXBSource source = new JAXBSource(context, value);
            T answer = parentTypeConverter.convertTo(type, source);
            if (answer == null) {
                // lets try a stream
                StringWriter buffer = new StringWriter();
                Marshaller marshaller = context.createMarshaller();
                marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, isPrettyPrint() ? Boolean.TRUE : Boolean.FALSE);
                marshaller.marshal(value, buffer);
                return parentTypeConverter.convertTo(type, buffer.toString());
            }
            return answer;
        }
        // lets try convert to the type from JAXB
        return null;
    }
    protected <T> JAXBContext createContext(Class<T> type) throws JAXBException {
        JAXBContext context = JAXBContext.newInstance(type);
        return context;
    }
}
"
org.apache.camel.component.mina.MinaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import org.apache.camel.CamelException;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
/**
 * A {@link org.apache.camel.Consumer Consumer} implementation for Apache MINA.
 *
 * @version $Revision$
 */
public class MinaConsumer extends DefaultConsumer<MinaExchange> {
    private static final transient Log LOG = LogFactory.getLog(MinaConsumer.class);
    private final MinaEndpoint endpoint;
    private final SocketAddress address;
    private final IoAcceptor acceptor;
    public MinaConsumer(final MinaEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.address = endpoint.getAddress();
        this.acceptor = endpoint.getAcceptor();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Binding to server address: "" + address + "" using acceptor: "" + acceptor);
        }
        IoHandler handler = new ReceiveHandler();
        acceptor.bind(address, handler, endpoint.getAcceptorConfig());
    }
    @Override
    protected void doStop() throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Unbinding from server address: "" + address + "" using acceptor: "" + acceptor);
        }
        acceptor.unbind(address);
        super.doStop();
    }
    /**
     * Handles comsuming messages and replying if the exchange is out capable.
     */
    private final class ReceiveHandler extends IoHandlerAdapter {
        @Override
        public void exceptionCaught(IoSession session, Throwable cause) throws Exception {
            // close invalid session
            if (session != null) {
                LOG.debug(""Closing session as an exception was thrown from MINA"");
                session.close();
            }
            // must wrap and rethrow since cause can be of Throwable and we must only throw Exception
            throw new CamelException(cause);
        }
        @Override
        public void messageReceived(IoSession session, Object object) throws Exception {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Received body: "" + object);
            }
            MinaExchange exchange = endpoint.createExchange(session, object);
            getProcessor().process(exchange);
            if (ExchangeHelper.isOutCapable(exchange)) {
                Object body = MinaPayloadHelper.getOut(endpoint, exchange);
                boolean failed = exchange.isFailed();
                if (failed) {
                    // can not write a response since the exchange is failed and we don't know in what state the
                    // in/out messages are in so the session is closed
                    LOG.warn(""Can not write body since the exchange is failed, closing session: "" + exchange);
                    session.close();
                } else if (body == null) {
                    // must close session if no data to write otherwise client will never receive a response
                    // and wait forever (if not timing out)
                    LOG.warn(""Can not write body since its null, closing session: "" + exchange);
                    session.close();
                } else {
                    // we got a response to write
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Writing body: "" + body);
                    }
                    MinaHelper.writeBody(session, body, exchange);
                }
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Can not write body since this exchange is not out capable: "" + exchange);
                }
            }
        }
    }
}
"
org.apache.camel.component.mina.MinaProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangeTimedOutException;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.ConnectFuture;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
import org.apache.mina.transport.socket.nio.SocketConnector;
/**
 * A {@link Producer} implementation for MINA
 *
 * @version $Revision$
 */
public class MinaProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(MinaProducer.class);
    private IoSession session;
    private MinaEndpoint endpoint;
    private CountDownLatch latch;
    private boolean lazySessionCreation;
    private long timeout;
    private IoConnector connector;
    private boolean sync;
    @SuppressWarnings({""unchecked""})
    public MinaProducer(MinaEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        this.lazySessionCreation = this.endpoint.isLazySessionCreation();
        this.timeout = this.endpoint.getTimeout();
    }
    public void process(Exchange exchange) throws Exception {
        if (session == null && !lazySessionCreation) {
            throw new IllegalStateException(""Not started yet!"");
        }
        if (session == null || !session.isConnected()) {
            openConnection();
        }
        Object body = MinaPayloadHelper.getIn(endpoint, exchange);
        if (body == null) {
            LOG.warn(""No payload to send for exchange: "" + exchange);
            return; // exit early since nothing to write
        }
        // if sync is true then we should also wait for a response (synchronous mode)
        sync = ExchangeHelper.isOutCapable(exchange);
        if (sync) {
            // only initialize latch if we should get a response
            latch = new CountDownLatch(1);
        }
        // write the body
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Writing body: "" + body);
        }
        MinaHelper.writeBody(session, body, exchange);
        if (sync) {
            // wait for response, consider timeout
            LOG.debug(""Waiting for response"");
            latch.await(timeout, TimeUnit.MILLISECONDS);
            if (latch.getCount() == 1) {
                throw new ExchangeTimedOutException(exchange, timeout);
            }
            // did we get a response
            ResponseHandler handler = (ResponseHandler) session.getHandler();
            if (handler.getCause() != null) {
                throw new CamelException(""Response Handler had an exception"", handler.getCause());
            } else {
                MinaPayloadHelper.setOut(exchange, handler.getMessage());
            }
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (!lazySessionCreation) {
            openConnection();
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Stopping connector: "" + connector + "" at address: "" + endpoint.getAddress());
        }
        if (connector instanceof SocketConnector) {
            // Change the worker timeout to 0 second to make the I/O thread quit soon when there's no connection to manage.
            // Default worker timeout is 60 sec and therefore the client using MinaProducer can not terminate the JVM
            // asap but must wait for the timeout to happend, so to speed this up we set the timeout to 0.
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Setting SocketConnector WorkerTimeout=0 to force MINA stopping its resources faster"");
            }
            ((SocketConnector) connector).setWorkerTimeout(0);
        }
        if (session != null) {
            session.close();
        }
        super.doStop();
    }
    private void openConnection() {
        SocketAddress address = endpoint.getAddress();
        connector = endpoint.getConnector();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating connector to address: "" + address + "" using connector: "" + connector + "" timeout: "" + timeout + "" millis."");
        }
        IoHandler ioHandler = new ResponseHandler(endpoint);
        // connect and wait until the connection is established
        ConnectFuture future = connector.connect(address, ioHandler, endpoint.getConnectorConfig());
        future.join();
        session = future.getSession();
    }
    /**
     * Handles response from session writes
     *
     * @author <a href=""mailto:karajdaar@gmail.com"">nsandhu</a>
     */
    private final class ResponseHandler extends IoHandlerAdapter {
        private MinaEndpoint endpoint;
        private Object message;
        private Throwable cause;
        private ResponseHandler(MinaEndpoint endpoint) {
            this.endpoint = endpoint;
        }
        @Override
        public void messageReceived(IoSession ioSession, Object message) throws Exception {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Message received: "" + message);
            }
            cause = null;
            this.message = message;
            countDown();
        }
        protected void countDown() {
            CountDownLatch downLatch = latch;
            if (downLatch != null) {
                downLatch.countDown();
            }
        }
        @Override
        public void sessionClosed(IoSession session) throws Exception {
            if (sync && message == null) {
                // sync=true (InOut mode) so we expected a message as reply but did not get one before the session is closed
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Session closed but no message received from address: "" + this.endpoint.getAddress());
                }
                // session was closed but no message received. This could be because the remote server had an internal error
                // and could not return a response. We should count down to stop waiting for a response
                countDown();
            }
        }
        @Override
        public void exceptionCaught(IoSession ioSession, Throwable cause) {
            LOG.error(""Exception on receiving message from address: "" + this.endpoint.getAddress()
                    + "" using connector: "" + this.endpoint.getConnector(), cause);
            this.message = null;
            this.cause = cause;
            if (ioSession != null) {
                ioSession.close();
            }
        }
        public Throwable getCause() {
            return this.cause;
        }
        public Object getMessage() {
            return this.message;
        }
    }
}
"
org.apache.camel.component.mail.MailComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * Component for JavaMail.
 *
 * @version $Revision:520964 $
 */
public class MailComponent extends DefaultComponent<MailExchange> {
    private MailConfiguration configuration;
    public MailComponent() {
        this.configuration = new MailConfiguration();
    }
    public MailComponent(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    public MailComponent(CamelContext context) {
        super(context);
        this.configuration = new MailConfiguration();
    }
    /**
     * Static builder method
     */
    public static MailComponent mailComponent() {
        return new MailComponent();
    }
    /**
     * Static builder method
     */
    public static MailComponent mailComponent(MailConfiguration configuration) {
        return new MailComponent(configuration);
    }
    @Override
    protected Endpoint<MailExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        URI url = new URI(uri);
        if (""nntp"".equalsIgnoreCase(url.getScheme())) {
            throw new UnsupportedOperationException(""nntp protocol is not supported"");
        }
        MailConfiguration config = new MailConfiguration();
        config.configure(url);
        // lets make sure we copy the configuration as each endpoint can customize its own version
        MailEndpoint endpoint = new MailEndpoint(uri, this, config);
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public MailConfiguration getConfiguration() {
        return configuration;
    }
    /**
     * Sets the Mail configuration
     *
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    /**
     * A strategy method allowing the URI destination to be translated into the actual Mail destination name
     * (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path) {
        return path;
    }
}
"
org.apache.camel.language.groovy.GroovyRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import groovy.lang.GroovyShell;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision$
 */
public abstract class GroovyRouteBuilder extends RouteBuilder {
    public GroovyRouteBuilder() {
        init();
    }
    public GroovyRouteBuilder(CamelContext context) {
        super(context);
        init();
    }
    private void init() {
        ClassLoader loader = getClass().getClassLoader();
        GroovyShell shell = new GroovyShell(loader);
        shell.evaluate(loader.getResourceAsStream(""org/apache/camel/language/groovy/ConfigureCamel.groovy""));
        // TODO compile Groovy as part of build!
        //new ConfigureCamel().run();
    }
}
"
org.apache.camel.component.file.remote.SftpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.apache.camel.Processor;
import org.apache.camel.component.file.FileComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class SftpConsumer extends RemoteFileConsumer<RemoteFileExchange> {
    private static final transient Log LOG = LogFactory.getLog(SftpConsumer.class);
    private final SftpEndpoint endpoint;
    private boolean recursive = true;
    private String regexPattern = """";
    private long lastPollTime;
    private ChannelSftp channel;
    private Session session;
    private boolean setNames;
    public SftpConsumer(SftpEndpoint endpoint, Processor processor, Session session) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.session = session;
    }
    public SftpConsumer(SftpEndpoint endpoint, Processor processor, Session session, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
        this.endpoint = endpoint;
        this.session = session;
    }
    protected void connectIfNecessary() throws JSchException {
        if (channel == null || !channel.isConnected()) {
            if (session == null || !session.isConnected()) {
                LOG.info(""Session isn't connected, trying to recreate and connect..."");
                session = endpoint.createSession();
                session.connect();
            }
            LOG.info(""Channel isn't connected, trying to recreate and connect..."");
            channel = endpoint.createChannelSftp(session);
            channel.connect();
            LOG.info(""Connected to "" + endpoint.getConfiguration().toString());
        }
    }
    protected void disconnect() throws JSchException {
        if (session != null) {
            LOG.info(""Session is being explicitly disconnected"");
            session.disconnect();
        }
        if (channel != null) {
            LOG.info(""Channel is being explicitly disconnected"");
            channel.disconnect();
        }
    }
    protected void poll() throws Exception {
        // TODO: is there a way to avoid copy-pasting the reconnect logic?
        connectIfNecessary();
        // If the attempt to connect isn't successful, then the thrown
        // exception will signify that we couldn't poll
        try {
            final String fileName = endpoint.getConfiguration().getFile();
            if (endpoint.getConfiguration().isDirectory()) {
                pollDirectory(fileName);
            } else {
                channel.cd(fileName.substring(0, fileName.lastIndexOf('/')));
                final ChannelSftp.LsEntry file = (ChannelSftp.LsEntry)channel.ls(fileName.substring(fileName.lastIndexOf('/') + 1)).get(0);
                pollFile(file);
            }
            lastPollTime = System.currentTimeMillis();
        } catch (JSchException e) {
            // If the connection has gone stale, then we must manually disconnect
            // the client before attempting to reconnect
            LOG.warn(""Disconnecting due to exception: "" + e.toString());
            disconnect();
            // Rethrow to signify that we didn't poll
            throw e;
        } catch (SftpException e) {
            // Still not sure if/when these come up and what we should do about them
            // client.disconnect();
            LOG.warn(""Caught SftpException:"" + e.toString());
            LOG.warn(""Doing nothing for now, need to determine an appropriate action"");
            // Rethrow to signify that we didn't poll
            throw e;
        }
    }
    protected void pollDirectory(String dir) throws Exception {
        channel.cd(dir);
        for (ChannelSftp.LsEntry sftpFile : (ChannelSftp.LsEntry[])channel.ls(""."").toArray(new ChannelSftp.LsEntry[] {})) {
            if (sftpFile.getFilename().startsWith(""."")) {
                // skip
            } else if (sftpFile.getAttrs().isDir()) {
                if (isRecursive()) {
                    pollDirectory(getFullFileName(sftpFile));
                }
            } else {
                pollFile(sftpFile);
            }
        }
    }
    protected String getFullFileName(ChannelSftp.LsEntry sftpFile) throws IOException, SftpException {
        return channel.pwd() + ""/"" + sftpFile.getFilename();
    }
    private void pollFile(ChannelSftp.LsEntry sftpFile) throws Exception {
        if (sftpFile.getAttrs().getMTime() * 1000L > lastPollTime) {
            if (isMatched(sftpFile)) {
                final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                channel.get(sftpFile.getFilename(), byteArrayOutputStream);
                RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(sftpFile), byteArrayOutputStream);
                if (isSetNames()) {
                    String relativePath = getFullFileName(sftpFile).substring(endpoint.getConfiguration().getFile().length());
                    if (relativePath.startsWith(""/"")) {
                        relativePath = relativePath.substring(1);
                    }
                    exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
                }
                getProcessor().process(exchange);
            }
        }
    }
    protected boolean isMatched(ChannelSftp.LsEntry sftpFile) {
        boolean result = true;
        if (regexPattern != null && regexPattern.length() > 0) {
            result = sftpFile.getFilename().matches(getRegexPattern());
        }
        return result;
    }
    public boolean isRecursive() {
        return recursive;
    }
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    public long getLastPollTime() {
        return lastPollTime;
    }
    public void setLastPollTime(long lastPollTime) {
        this.lastPollTime = lastPollTime;
    }
    public String getRegexPattern() {
        return regexPattern;
    }
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isSetNames() {
        return setNames;
    }
    public void setSetNames(boolean setNames) {
        this.setNames = setNames;
    }
}
"
org.apache.camel.spring.CamelTemplateFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultProducerTemplate;
import org.apache.camel.model.IdentifiedType;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
/**
 * A Spring {@link FactoryBean} for creating a new {@link ProducerTemplate}
 * instance with a minimum of XML
 * 
 * @version $Revision$
 */
@XmlRootElement(name = ""template"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelTemplateFactoryBean extends IdentifiedType implements FactoryBean, InitializingBean, CamelContextAware {
    @XmlAttribute(required = false)
    private String defaultEndpoint;
    @XmlTransient
    private CamelContext camelContext;
    public void afterPropertiesSet() throws Exception {
        if (camelContext == null) {
            throw new IllegalArgumentException(""A CamelContext must be injected!"");
        }
    }
    public Object getObject() throws Exception {
        CamelContext context = getCamelContext();
        if (defaultEndpoint != null) {
            Endpoint endpoint = context.getEndpoint(defaultEndpoint);
            if (endpoint == null) {
                throw new IllegalArgumentException(""No endpoint found for URI: "" + defaultEndpoint);
            } else {
                return new DefaultProducerTemplate(context, endpoint);
            }
        }
        return new DefaultProducerTemplate(context);
    }
    public Class getObjectType() {
        return DefaultProducerTemplate.class;
    }
    public boolean isSingleton() {
        return true;
    }
    // Properties
    // -------------------------------------------------------------------------
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public String getDefaultEndpoint() {
        return defaultEndpoint;
    }
    /**
     * Sets the default endpoint URI used by default for sending message
     * exchanges
     */
    public void setDefaultEndpoint(String defaultEndpoint) {
        this.defaultEndpoint = defaultEndpoint;
    }
}
"
org.apache.camel.component.xslt.XsltComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xslt;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.xml.XsltBuilder;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
/**
 * An <a href=""http://activemq.apache.org/camel/xslt.html"">XSLT Component</a>
 * for performing XSLT transforms of messages
 *
 * @version $Revision$
 */
public class XsltComponent extends ResourceBasedComponent {
    private XmlConverter xmlConverter;
    public XmlConverter getXmlConverter() {
        return xmlConverter;
    }
    public void setXmlConverter(XmlConverter xmlConverter) {
        this.xmlConverter = xmlConverter;
    }
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Resource resource = resolveMandatoryResource(remaining);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        XsltBuilder xslt = newInstance(XsltBuilder.class);
        // lets allow the converter to be configured
        XmlConverter converter = null;
        String converterName = getAndRemoveParameter(parameters, ""converter"", String.class);
        if (converterName != null) {
            converter = mandatoryLookup(converterName, XmlConverter.class);
        }
        if (converter == null) {
            converter = getXmlConverter();
        }
        if (converter != null) {
            xslt.setConverter(converter);
        }
        xslt.setTransformerInputStream(resource.getInputStream());
        configureXslt(xslt, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, xslt);
    }
    protected void configureXslt(XsltBuilder xslt, String uri, String remaining, Map parameters) throws Exception {
        setProperties(xslt, parameters);
    }
}
"
org.apache.camel.bam.processor.ActivityMonitorEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import java.util.Date;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceException;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.impl.ServiceSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaCallback;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A timer engine to monitor for expired activities and perform whatever actions
 * are required.
 * 
 * @version $Revision$
 */
public class ActivityMonitorEngine extends ServiceSupport implements Runnable {
    private static final Log LOG = LogFactory.getLog(ActivityMonitorEngine.class);
    private JpaTemplate template;
    private TransactionTemplate transactionTemplate;
    private ProcessRules rules;
    private int escalateLevel;
    private long windowMillis = 1000L;
    private Thread thread;
    private boolean useLocking;
    public ActivityMonitorEngine(JpaTemplate template, TransactionTemplate transactionTemplate, ProcessRules rules) {
        this.template = template;
        this.transactionTemplate = transactionTemplate;
        this.rules = rules;
    }
    public boolean isUseLocking() {
        return useLocking;
    }
    public void setUseLocking(boolean useLocking) {
        this.useLocking = useLocking;
    }
    public void run() {
        LOG.debug(""Starting to poll for timeout events"");
        while (!isStopped()) {
            try {
                long now = System.currentTimeMillis();
                long nextPoll = now + windowMillis;
                final Date timeNow = new Date(now);
                transactionTemplate.execute(new TransactionCallbackWithoutResult() {
                    protected void doInTransactionWithoutResult(TransactionStatus status) {
                        //List<ActivityState> list = template.find(""select x from "" + ActivityState.class.getName() + "" x where x.escalationLevel = ?1 and x.timeOverdue < ?2"", escalateLevel, timeNow);
                        List<ActivityState> list = template.find(""select x from "" + ActivityState.class.getName() + "" x where x.timeOverdue < ?1"", timeNow);
                        for (ActivityState activityState : list) {
                            fireExpiredEvent(activityState);
                        }
                    }
                });
                long timeToSleep = nextPoll - System.currentTimeMillis();
                if (timeToSleep > 0) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Sleeping for "" + timeToSleep + "" millis"");
                    }
                    try {
                        Thread.sleep(timeToSleep);
                    } catch (InterruptedException e) {
                        LOG.debug(""Caught: "" + e, e);
                    }
                }
            } catch (Exception e) {
                LOG.error(""Caught: "" + e, e);
            }
        }
    }
    protected void fireExpiredEvent(final ActivityState activityState) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Trying to fire expiration of: "" + activityState);
        }
        template.execute(new JpaCallback() {
            public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                // lets try lock the object first
                if (isUseLocking()) {
                    LOG.info(""Attempting to lock: "" + activityState);
                    entityManager.lock(activityState, LockModeType.WRITE);
                    LOG.info(""Grabbed lock: "" + activityState);
                }
                try {
                    rules.processExpired(activityState);
                } catch (Exception e) {
                    LOG.error(""Failed to process expiration of: "" + activityState + "". Reason: "" + e, e);
                }
                activityState.setTimeOverdue(null);
                //activityState.setEscalationLevel(escalateLevel + 1);
                return null;
            }
        });
    }
    protected void doStart() throws Exception {
        rules.start();
        thread = new Thread(this, ""ActivityMonitorEngine"");
        thread.start();
    }
    protected void doStop() throws Exception {
        if (thread != null) {
            thread = null;
        }
        rules.stop();
    }
}
"
org.apache.camel.component.cxf.CxfSoapConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.OutputStream;
import javax.xml.transform.Source;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.component.cxf.util.NullConduit;
import org.apache.camel.component.cxf.util.NullDestinationFactory;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.frontend.ServerFactoryBean;
import org.apache.cxf.interceptor.InterceptorChain;
import org.apache.cxf.interceptor.OutgoingChainInterceptor;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.transport.MessageObserver;
/**
 * A CXF based SOAP consumer (client).
 * The consumer will delegate to another endpoint for the transport layer
 * and will provide SOAP support on top of it.
 */
public class CxfSoapConsumer implements Consumer {
    private static final Log LOG = LogFactory.getLog(CxfSoapConsumer.class);
    private final CxfSoapEndpoint endpoint;
    private final Consumer consumer;
    private MessageObserver inMessageObserver;
    private Server server;
    public CxfSoapConsumer(CxfSoapEndpoint endpoint, Processor processor) throws Exception {
        this.endpoint = endpoint;
        Processor soapProcessor = new AsyncProcessorDecorator(processor,
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapConsumerIn(exchange);
                    }
                },
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapConsumerOut(exchange);
                    }
                });
        this.consumer = endpoint.getInnerEndpoint().createConsumer(soapProcessor);
        Class sei = CxfEndpointUtils.getSEIClass(endpoint.getServiceClass());
        ServerFactoryBean sfb = CxfEndpointUtils.getServerFactoryBean(sei);
        sfb.setWsdlURL(endpoint.getWsdl().getURL().toString());
        if (endpoint.getServiceName() != null) {
            sfb.setServiceName(endpoint.getServiceName());
        }
        if (endpoint.getEndpointName() != null) {
            sfb.setEndpointName(endpoint.getEndpointName());
        }
        // we do not need use the destination here
        sfb.setDestinationFactory(new NullDestinationFactory());
        sfb.setStart(false);
        server = sfb.create();
    }
    public void start() throws Exception {
        server.start();
        inMessageObserver = server.getDestination().getMessageObserver();
        consumer.start();
    }
    public void stop() throws Exception {
        server.stop();
        consumer.stop();
    }
    protected Bus getBus() {
        return endpoint.getBus();
    }
    protected void processSoapConsumerIn(Exchange exchange) throws Exception {
        LOG.info(""processSoapConsumerIn: "" + exchange);
        org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(exchange, false);
        org.apache.cxf.message.Exchange cxfExchange = inMessage.getExchange();
        cxfExchange.put(org.apache.cxf.endpoint.Endpoint.class, server.getEndpoint());
        cxfExchange.put(Bus.class, getBus());
        cxfExchange.setConduit(new NullConduit());
        // get the message input stream, deal with the exchange in message
        inMessageObserver.onMessage(inMessage);
        exchange.getIn().setBody(inMessage.getContent(Source.class));
        //TODO copy the right header information
        exchange.getIn().setHeaders(inMessage);
    }
    protected void processSoapConsumerOut(Exchange exchange) throws Exception {
        LOG.info(""processSoapConsumerOut: "" + exchange);
        // TODO check if the message is one-way message
        // Get the method name from the soap endpoint
        org.apache.cxf.message.Message outMessage = CxfSoapBinding.getCxfOutMessage(exchange, false);
        org.apache.cxf.message.Exchange cxfExchange = outMessage.getExchange();
        InterceptorChain chain = OutgoingChainInterceptor.getOutInterceptorChain(cxfExchange);
        outMessage.setInterceptorChain(chain);
        chain.doIntercept(outMessage);
        CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
        exchange.getOut().setBody(outputStream.getInputStream());
    }
}
"
org.apache.camel.converter.xmlbeans.XmlBeansDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.xmlbeans;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
import org.apache.xmlbeans.XmlObject;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * ({@link DataFormat}) using XmlBeans to marshal to and from XML
 *
 * @version $Revision$
 */
public class XmlBeansDataFormat implements DataFormat {
    public void marshal(Exchange exchange, Object body, OutputStream stream) throws Exception {
        XmlObject object = ExchangeHelper.convertToMandatoryType(exchange, XmlObject.class, body);
        object.save(stream);
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
        return XmlObject.Factory.parse(stream);
    }
}
"
org.apache.camel.component.file.remote.FtpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPConnectionClosedException;
public class FtpProducer extends RemoteFileProducer<RemoteFileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FtpProducer.class);
    private FtpEndpoint endpoint;
    private FTPClient client;
    public FtpProducer(FtpEndpoint endpoint, FTPClient client) {
        super(endpoint);
        this.endpoint = endpoint;
        this.client = client;
    }
    public void process(Exchange exchange) throws Exception {
        connectIfNecessary();
        // If the attempt to connect isn't successful, then the thrown
        // exception will signify that we couldn't deliver
        try {
            process(endpoint.createExchange(exchange));
        } catch (FTPConnectionClosedException e) {
            // If the server disconnected us, then we must manually disconnect
            // the client before attempting to reconnect
            LOG.warn(""Disconnecting due to exception: "" + e.toString());
            disconnect();
            // Rethrow to signify that we didn't deliver
            throw e;
        } catch (RuntimeCamelException e) {
            LOG.warn(""Caught RuntimeCamelException: "" + e.toString());
            LOG.warn(""Hoping an explicit disconnect/reconnect will solve the problem"");
            disconnect();
            // Rethrow to signify that we didn't deliver
            throw e;
        }
    }
    protected void connectIfNecessary() throws IOException {
        // TODO: is there a way to avoid copy-pasting the reconnect logic?
        if (!client.isConnected()) {
            LOG.warn(""FtpProducer's client isn't connected, trying to reconnect..."");
            endpoint.connect(client);
            LOG.info(""Connected to "" + endpoint.getConfiguration());
        }
    }
    public void disconnect() throws IOException {
        LOG.info(""FtpProducer's client is being explicitly disconnected"");
        endpoint.disconnect(client);
    }
    public void process(RemoteFileExchange exchange) throws Exception {
        InputStream payload = exchange.getIn().getBody(InputStream.class);
        try {
            String fileName = createFileName(exchange.getIn(), endpoint.getConfiguration());
            int lastPathIndex = fileName.lastIndexOf('/');
            if (lastPathIndex != -1) {
                String directory = fileName.substring(0, lastPathIndex);
                if (!buildDirectory(client, directory)) {
                    LOG.warn(""Couldn't build directory: "" + directory + "" (either permissions deny it, or it already exists)"");
                }
            }
            final boolean success = client.storeFile(fileName, payload);
            if (!success) {
                // TODO: Should we not have better exception for this?
                throw new RuntimeCamelException(""Error sending file: "" + fileName);
            }
            RemoteFileConfiguration config = endpoint.getConfiguration();
            LOG.info(""Sent: "" + fileName + "" to "" + config.toString().substring(0, config.toString().indexOf(config.getFile())));
        } finally {
            if (payload != null) {
                payload.close();
            }
        }
    }
    @Override
    protected void doStart() throws Exception {
        LOG.info(""Starting"");
        try {
            connectIfNecessary();
        } catch (IOException e) {
            LOG.warn(""Couldn't connect to "" + endpoint.getConfiguration());
        }
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        LOG.info(""Stopping"");
        disconnect();
        super.doStop();
    }
    protected static boolean buildDirectory(FTPClient ftpClient, String dirName) throws IOException {
        boolean atLeastOneSuccess = false;
        final StringBuilder sb = new StringBuilder(dirName.length());
        final String[] dirs = dirName.split(""\\/"");
        for (String dir : dirs) {
            sb.append(dir).append('/');
            String directory = sb.toString();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Trying to build directory: "" + directory);
            }
            final boolean success = ftpClient.makeDirectory(directory);
            if (!atLeastOneSuccess && success) {
                atLeastOneSuccess = true;
            }
        }
        return atLeastOneSuccess;
    }
}
"
org.apache.camel.component.cxf.invoker.AbstractInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import java.util.logging.Logger;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
/**
 * A RoutingContext encapulates specific knowledge about how to route messages of
 * a particular data format.
 *
 */
public abstract class AbstractInvokingContext implements InvokingContext {
    protected abstract Logger getLogger();
    protected <T> T getResponseObject(Message inMessage, Map<String, Object> responseContext,
            Class <T> clazz) {
        T retval = null;
        if (inMessage != null) {
            if (null != responseContext) {
                responseContext.putAll(inMessage);
                getLogger().info(""set responseContext to be"" + responseContext);
            }
            retval = inMessage.getContent(clazz);
        }
        return retval;
    }
    protected void loggerTheMessage(Message message, String messageTile) {
        StringBuffer buffer = new StringBuffer(messageTile + ""\n""
                                               + ""--------------------------------------"");
        InputStream is = message.getContent(InputStream.class);
        if (is != null) {
            CachedOutputStream bos = new CachedOutputStream();
            try {
                IOUtils.copy(is, bos);
                is.close();
                bos.close();
                buffer.append(""\nMessage:\n"");
                buffer.append(bos.getOut().toString());
                message.setContent(InputStream.class, bos.getInputStream());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        buffer.append(""\n--------------------------------------"");
        getLogger().info(buffer.toString());
    }
}
"
org.apache.camel.bam.rules.ProcessRules,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * @version $Revision$
 */
public class ProcessRules extends ServiceSupport {
    private ProcessDefinition processDefinition;
    private List<ActivityRules> activities = new ArrayList<ActivityRules>();
    public void processExpired(ActivityState activityState) throws Exception {
        for (ActivityRules activityRules : activities) {
            activityRules.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (ActivityRules activityRules : activities) {
            activityRules.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public List<ActivityRules> getActivities() {
        return activities;
    }
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(activities);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(activities);
    }
}
"
org.apache.camel.component.rmi.RmiEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.net.URI;
import java.net.URISyntaxException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.impl.DefaultEndpoint;
/**
 * @version $Revision:520964 $
 */
public class RmiEndpoint extends DefaultEndpoint<BeanExchange> {
    private List<Class> remoteInterfaces;
    private ClassLoader classLoader;
    private URI uri;
    private int port;
    private String method;
    protected RmiEndpoint(String endpointUri, RmiComponent component) throws URISyntaxException {
        super(endpointUri, component);
        this.uri = new URI(endpointUri);
    }
    public RmiEndpoint(String endpointUri) throws URISyntaxException {
        super(endpointUri);
        this.uri = new URI(endpointUri);
    }
    public boolean isSingleton() {
        return false;
    }
    @Override
    public BeanExchange createExchange(ExchangePattern pattern) {
        return new BeanExchange(getCamelContext(), pattern);
    }
    public Consumer<BeanExchange> createConsumer(Processor processor) throws Exception {
        if (remoteInterfaces == null || remoteInterfaces.size() == 0) {
            throw new RuntimeCamelException(""To create an RMI consumer, the RMI endpoint's remoteInterfaces property must be be configured."");
        }
        return new RmiConsumer(this, processor);
    }
    public Producer<BeanExchange> createProducer() throws Exception {
        return new RmiProducer(this);
    }
    public String getName() {
        String path = uri.getPath();
        if (path == null) {
            path = uri.getSchemeSpecificPart();
        }
        return path;
    }
    public Registry getRegistry() throws RemoteException {
        if (uri.getHost() != null) {
            if (uri.getPort() == -1) {
                return LocateRegistry.getRegistry(uri.getHost());
            } else {
                return LocateRegistry.getRegistry(uri.getHost(), uri.getPort());
            }
        } else {
            return LocateRegistry.getRegistry();
        }
    }
    public List<Class> getRemoteInterfaces() {
        return remoteInterfaces;
    }
    public void setRemoteInterfaces(List<Class> remoteInterfaces) {
        this.remoteInterfaces = remoteInterfaces;
        if (classLoader == null && !remoteInterfaces.isEmpty()) {
            classLoader = remoteInterfaces.get(0).getClassLoader();
        }
    }
    public void setRemoteInterfaces(Class... remoteInterfaces) {
        setRemoteInterfaces(Arrays.asList(remoteInterfaces));
    }
    public ClassLoader getClassLoader() {
        return classLoader;
    }
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
}
"
org.apache.camel.bam.processor.BamProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A base {@link Processor} for working on <a
 * href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which a derived
 * class would do the actual persistence such as the {@link JpaBamProcessor}
 *
 * @version $Revision$
 */
public abstract class BamProcessorSupport<T> implements Processor {
    private static final transient Log LOG = LogFactory.getLog(BamProcessorSupport.class);
    private Class<T> entityType;
    private Expression<Exchange> correlationKeyExpression;
    private TransactionTemplate transactionTemplate;
    private int retryCount = 20;
    private long retrySleep = 1000L;
    protected BamProcessorSupport(TransactionTemplate transactionTemplate,
                                  Expression<Exchange> correlationKeyExpression) {
        this.transactionTemplate = transactionTemplate;
        this.correlationKeyExpression = correlationKeyExpression;
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType)type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    this.entityType = (Class<T>)argumentType;
                }
            }
        }
        if (entityType == null) {
            throw new IllegalArgumentException(""Could not infer the entity type!"");
        }
    }
    protected BamProcessorSupport(TransactionTemplate transactionTemplate,
                                  Expression<Exchange> correlationKeyExpression, Class<T> entitytype) {
        this.transactionTemplate = transactionTemplate;
        this.entityType = entitytype;
        this.correlationKeyExpression = correlationKeyExpression;
    }
    public void process(final Exchange exchange) {
        for (int i = 1; i <= retryCount; i++) {
            if (i > 1) {
                LOG.info(""Retrying attempt: "" + i);
                try {
                    Thread.sleep(retryCount);
                } catch (InterruptedException e) {
                    LOG.debug(""Caught: "" + e, e);
                }
            }
            try {
                transactionTemplate.execute(new TransactionCallback() {
                    public Object doInTransaction(TransactionStatus status) {
                        try {
                            Object key = getCorrelationKey(exchange);
                            T entity = loadEntity(exchange, key);
                            if (LOG.isDebugEnabled()) {
                                LOG.debug(""Correlation key: "" + key + "" with entity: "" + entity);
                            }
                            processEntity(exchange, entity);
                            return entity;
                        } catch (Exception e) {
                            return onError(status, e);
                        }
                    }
                });
                if (i > 1) {
                    LOG.info(""Attempt "" + i + "" worked!"");
                }
                return;
            } catch (Exception e) {
                LOG.warn(""Failed to complete transaction: "" + e, e);
            }
        }
    }
    // Properties
    // -----------------------------------------------------------------------
    public Expression<Exchange> getCorrelationKeyExpression() {
        return correlationKeyExpression;
    }
    public Class<T> getEntityType() {
        return entityType;
    }
    // Implemenation methods
    // -----------------------------------------------------------------------
    protected abstract void processEntity(Exchange exchange, T entity) throws Exception;
    protected abstract T loadEntity(Exchange exchange, Object key) throws Exception;
    protected abstract Class getKeyType();
    protected Object getCorrelationKey(Exchange exchange) throws NoCorrelationKeyException {
        Object value = correlationKeyExpression.evaluate(exchange);
        Class keyType = getKeyType();
        if (keyType != null) {
            value = ExchangeHelper.convertToType(exchange, keyType, value);
        }
        if (value == null) {
            throw new NoCorrelationKeyException(this, exchange);
        }
        return value;
    }
    protected Object onError(TransactionStatus status, Exception e) {
        status.setRollbackOnly();
        LOG.error(""Caught: "" + e, e);
        throw new RuntimeCamelException(e);
    }
}
"
org.apache.camel.spring.CamelProxyFactoryType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * The &lt;proxy&gt; tag element.
 *
 * @version $Revision$
*/ // to fudge the XSD generation
@XmlRootElement(name = ""proxy"")
public class CamelProxyFactoryType extends IdentifiedType {
    @XmlAttribute
    private String serviceUrl;
    @XmlAttribute
    private Class serviceInterface;
}
"
org.apache.camel.component.xquery.XQueryBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringWriter;
import java.net.URL;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Node;
import net.sf.saxon.Configuration;
import net.sf.saxon.om.DocumentInfo;
import net.sf.saxon.om.Item;
import net.sf.saxon.om.SequenceIterator;
import net.sf.saxon.query.DynamicQueryContext;
import net.sf.saxon.query.StaticQueryContext;
import net.sf.saxon.query.XQueryExpression;
import net.sf.saxon.trans.XPathException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.jaxp.BytesSource;
import org.apache.camel.converter.jaxp.StringSource;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Creates an XQuery builder
 *
 * @version $Revision$
 */
public abstract class XQueryBuilder implements Expression<Exchange>, Predicate<Exchange>, NamespaceAware, Processor {
    private static final transient Log LOG = LogFactory.getLog(XQueryBuilder.class);
    private Configuration configuration;
    private XQueryExpression expression;
    private StaticQueryContext staticQueryContext;
    private Map<String, Object> parameters = new HashMap<String, Object>();
    private Map<String, String> namespacePrefixes = new HashMap<String, String>();
    private XmlConverter converter = new XmlConverter();
    private ResultFormat resultsFormat = ResultFormat.DOM;
    private Properties properties = new Properties();
    private Class resultType;
    private final AtomicBoolean initialized = new AtomicBoolean(false);
    @Override
    public String toString() {
        return ""XQuery["" + expression + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Object body = evaluate(exchange);
        exchange.getOut(true).setBody(body);
        // propogate headers
        exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
    }
    public Object evaluate(Exchange exchange) {
        try {
            initialize();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Evaluation "" + expression + "" for exchange: "" + exchange);
            }
            if (resultType != null) {
                if (resultType.equals(String.class)) {
                    return evaluateAsString(exchange);
                } else if (resultType.isAssignableFrom(Collection.class)) {
                    return evaluateAsList(exchange);
                } else if (resultType.isAssignableFrom(Node.class)) {
                    return evaluateAsDOM(exchange);
                } else {
                    // TODO figure out how to convert to the given type
                }
            }
            switch (resultsFormat) {
            case Bytes:
                return evaluateAsBytes(exchange);
            case BytesSource:
                return evaluateAsBytesSource(exchange);
            case DOM:
                return evaluateAsDOM(exchange);
            case List:
                return evaluateAsList(exchange);
            case StringSource:
                return evaluateAsStringSource(exchange);
            case String:
            default:
                return evaluateAsString(exchange);
            }
        } catch (Exception e) {
            throw new RuntimeExpressionException(e);
        }
    }
    public List evaluateAsList(Exchange exchange) throws Exception {
        initialize();
        return getExpression().evaluate(createDynamicContext(exchange));
    }
    public Object evaluateAsStringSource(Exchange exchange) throws Exception {
        initialize();
        String text = evaluateAsString(exchange);
        return new StringSource(text);
    }
    public Object evaluateAsBytesSource(Exchange exchange) throws Exception {
        initialize();
        byte[] bytes = evaluateAsBytes(exchange);
        return new BytesSource(bytes);
    }
    public Node evaluateAsDOM(Exchange exchange) throws Exception {
        initialize();
        DOMResult result = new DOMResult();
        DynamicQueryContext context = createDynamicContext(exchange);
        XQueryExpression expression = getExpression();
        expression.pull(context, result, properties);
        return result.getNode();
    }
    public byte[] evaluateAsBytes(Exchange exchange) throws Exception {
        initialize();
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        Result result = new StreamResult(buffer);
        getExpression().pull(createDynamicContext(exchange), result, properties);
        byte[] bytes = buffer.toByteArray();
        return bytes;
    }
    public String evaluateAsString(Exchange exchange) throws Exception {
        initialize();
        StringWriter buffer = new StringWriter();
        SequenceIterator iter = getExpression().iterator(createDynamicContext(exchange));
        for (Item item = iter.next(); item != null; item = iter.next()) {
            buffer.append(item.getStringValueCS());
        }
        return buffer.toString();
    }
    public boolean matches(Exchange exchange) {
        try {
            List list = evaluateAsList(exchange);
            return matches(exchange, list);
        } catch (Exception e) {
            throw new RuntimeExpressionException(e);
        }
    }
    public void assertMatches(String text, Exchange exchange) throws AssertionError {
        try {
            List list = evaluateAsList(exchange);
            if (!matches(exchange, list)) {
                throw new AssertionError(this + "" failed on "" + exchange + "" as evaluated: "" + list);
            }
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
    // Static helper methods
    //-------------------------------------------------------------------------
    public static XQueryBuilder xquery(final String queryText) {
        return new XQueryBuilder() {
            protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
                throws XPathException {
                return staticQueryContext.compileQuery(queryText);
            }
        };
    }
    public static XQueryBuilder xquery(final Reader reader) {
        return new XQueryBuilder() {
            protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
                throws XPathException, IOException {
                return staticQueryContext.compileQuery(reader);
            }
        };
    }
    public static XQueryBuilder xquery(final InputStream in, final String characterSet) {
        return new XQueryBuilder() {
            protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
                throws XPathException, IOException {
                return staticQueryContext.compileQuery(in, characterSet);
            }
        };
    }
    public static XQueryBuilder xquery(File file, String characterSet) throws FileNotFoundException {
        return xquery(IOConverter.toInputStream(file), characterSet);
    }
    public static XQueryBuilder xquery(URL url, String characterSet) throws IOException {
        return xquery(IOConverter.toInputStream(url), characterSet);
    }
    public static XQueryBuilder xquery(File file) throws FileNotFoundException {
        return xquery(IOConverter.toInputStream(file), ObjectHelper.getDefaultCharacterSet());
    }
    public static XQueryBuilder xquery(URL url) throws IOException {
        return xquery(IOConverter.toInputStream(url), ObjectHelper.getDefaultCharacterSet());
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public XQueryBuilder parameter(String name, Object value) {
        parameters.put(name, value);
        return this;
    }
    public XQueryBuilder namespace(String prefix, String uri) {
        namespacePrefixes.put(prefix, uri);
        // more namespace, we must re initialize
        initialized.set(false);
        return this;
    }
    public XQueryBuilder resultType(Class resultType) {
        setResultType(resultType);
        return this;
    }
    public XQueryBuilder asBytes() {
        setResultsFormat(ResultFormat.Bytes);
        return this;
    }
    public XQueryBuilder asBytesSource() {
        setResultsFormat(ResultFormat.BytesSource);
        return this;
    }
    public XQueryBuilder asDOM() {
        setResultsFormat(ResultFormat.DOM);
        return this;
    }
    public XQueryBuilder asDOMSource() {
        setResultsFormat(ResultFormat.DOMSource);
        return this;
    }
    public XQueryBuilder asList() {
        setResultsFormat(ResultFormat.List);
        return this;
    }
    public XQueryBuilder asString() {
        setResultsFormat(ResultFormat.String);
        return this;
    }
    public XQueryBuilder asStringSource() {
        setResultsFormat(ResultFormat.StringSource);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    /**
     * Configures the namespace context from the given DOM element
     */
    public void setNamespaces(Map<String, String> namespaces) {
        namespacePrefixes.putAll(namespaces);
        // more namespace, we must re initialize
        initialized.set(false);
    }
    public XQueryExpression getExpression() throws IOException, XPathException {
        return expression;
    }
    public Configuration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(Configuration configuration) {
        this.configuration = configuration;
        // change configuration, we must re intialize
        initialized.set(false);
    }
    public StaticQueryContext getStaticQueryContext() {
        return staticQueryContext;
    }
    public void setStaticQueryContext(StaticQueryContext staticQueryContext) {
        this.staticQueryContext = staticQueryContext;
        // change context, we must re intialize
        initialized.set(false);
    }
    public Map<String, Object> getParameters() {
        return parameters;
    }
    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }
    public Properties getProperties() {
        return properties;
    }
    public void setProperties(Properties properties) {
        this.properties = properties;
    }
    public ResultFormat getResultsFormat() {
        return resultsFormat;
    }
    public void setResultsFormat(ResultFormat resultsFormat) {
        this.resultsFormat = resultsFormat;
    }
    public Class getResultType() {
        return resultType;
    }
    public void setResultType(Class resultType) {
        this.resultType = resultType;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A factory method to create the XQuery expression
     */
    protected abstract XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext)
        throws XPathException, IOException;
    /**
     * Creates a dynamic context for the given exchange
     */
    protected DynamicQueryContext createDynamicContext(Exchange exchange) throws Exception {
        Configuration config = getConfiguration();
        DynamicQueryContext dynamicQueryContext = new DynamicQueryContext(config);
        Message in = exchange.getIn();
        Item item = in.getBody(Item.class);
        Source source = null;
        if (item != null) {
            dynamicQueryContext.setContextItem(item);
        } else {
            source = in.getBody(Source.class);
            if (source == null) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""No body available on exchange so using an empty document: "" + exchange);
                }
                source = converter.toSource(converter.createDocument());
            }
            DocumentInfo doc = getStaticQueryContext().buildDocument(source);
            dynamicQueryContext.setContextItem(doc);
        }
        configureQuery(dynamicQueryContext, exchange);
        return dynamicQueryContext;
    }
    /**
     * Configures the dynamic context with exchange specific parameters
     *
     * @param dynamicQueryContext
     * @param exchange
     * @throws Exception
     */
    protected void configureQuery(DynamicQueryContext dynamicQueryContext, Exchange exchange)
        throws Exception {
        addParameters(dynamicQueryContext, exchange.getProperties());
        addParameters(dynamicQueryContext, exchange.getIn().getHeaders());
        addParameters(dynamicQueryContext, getParameters());
        dynamicQueryContext.setParameter(""exchange"", exchange);
        if (exchange.getPattern().isOutCapable()) {
            dynamicQueryContext.setParameter(""out"", exchange.getOut());
        }
    }
    protected void addParameters(DynamicQueryContext dynamicQueryContext, Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            dynamicQueryContext.setParameter(entry.getKey(), entry.getValue());
        }
    }
    protected boolean matches(Exchange exchange, List results) {
        return ObjectHelper.matches(results);
    }
    /**
     * Initializes this builder - <b>Must be invoked before evaluation</b>.
     */
    protected synchronized void initialize() throws XPathException, IOException {
        // must use synchronized for concurrency issues and only let it initialize once
        if (!initialized.get()) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Initializing XQueryBuilder "" + this);
            }
            configuration = new Configuration();
            configuration.setHostLanguage(Configuration.XQUERY);
            staticQueryContext = new StaticQueryContext(getConfiguration());
            Set<Map.Entry<String, String>> entries = namespacePrefixes.entrySet();
            for (Map.Entry<String, String> entry : entries) {
                String prefix = entry.getKey();
                String uri = entry.getValue();
                staticQueryContext.declareNamespace(prefix, uri);
                staticQueryContext.setInheritNamespaces(true);
            }
            expression = createQueryExpression(staticQueryContext);
            initialized.set(true);
        }
    }
}
"
org.apache.camel.component.jdbc.JdbcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision:520964 $
 */
public class JdbcComponent extends DefaultComponent<DefaultExchange> {
    public JdbcComponent() {
    }
    public JdbcComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<DefaultExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new JdbcEndpoint(uri, remaining, this);
    }
}
"
org.apache.camel.language.ognl.RootObject,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
/**
 * @version $Revision$
 */
public class RootObject {
    private final Exchange exchange;
    public RootObject(Exchange exchange) {
        this.exchange = exchange;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public CamelContext getContext() {
        return exchange.getContext();
    }
    public Throwable getException() {
        return exchange.getException();
    }
    public String getExchangeId() {
        return exchange.getExchangeId();
    }
    public Message getFault() {
        return exchange.getFault();
    }
    public Message getRequest() {
        return exchange.getIn();
    }
    public Message getIn() {
        return exchange.getIn();
    }
    public Message getOut() {
        return exchange.getOut();
    }
    public Message getResponse() {
        return exchange.getOut();
    }
    public Map<String, Object> getProperties() {
        return exchange.getProperties();
    }
    public Object getProperty(String name) {
        return exchange.getProperty(name);
    }
    public <T> T getProperty(String name, Class<T> type) {
        return exchange.getProperty(name, type);
    }
}
"
org.apache.camel.component.quartz.QuartzComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.CronTrigger;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.Trigger;
import org.quartz.impl.StdSchedulerFactory;
/**
 * A <a href=""http://activemq.apache.org/camel/quartz.html"">Quartz Component</a>
 *
 * @version $Revision:520964 $
 */
public class QuartzComponent extends DefaultComponent<QuartzExchange> {
    private static final transient Log LOG = LogFactory.getLog(QuartzComponent.class);
    private SchedulerFactory factory;
    private Scheduler scheduler;
    private Map<Trigger, JobDetail> triggers;
    public QuartzComponent() {
    }
    public QuartzComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected QuartzEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        QuartzEndpoint answer = new QuartzEndpoint(uri, this, getScheduler());
        // lets split the remaining into a group/name
        URI u = new URI(uri);
        String name;
        String group = ""Camel"";
        String path = u.getPath();
        CronTrigger cronTrigger = null;
        if (path != null && path.length() > 1) {
            if (path.startsWith(""/"")) {
                path = path.substring(1);
            }
            int idx = path.indexOf('/');
            if (idx > 0) {
                cronTrigger = new CronTrigger();
                name = path.substring(0, idx);
                String cronExpression = path.substring(idx + 1);
                // lets allow / instead of spaces and allow $ instead of ?
                cronExpression = cronExpression.replace('/', ' ');
                cronExpression = cronExpression.replace('$', '?');
                LOG.debug(""Creating cron trigger: "" + cronExpression);
                cronTrigger.setCronExpression(cronExpression);
                answer.setTrigger(cronTrigger);
            } else {
                name = path;
            }
            group = u.getHost();
        } else {
            name = u.getHost();
        }
        /*
         * String[] names = ObjectHelper.splitOnCharacter(remaining, ""/"", 2); if
         * (names[1] != null) { group = names[0]; name = names[1]; } else { name =
         * names[0]; }
         */
        Trigger trigger = cronTrigger;
        if (trigger == null) {
            trigger = answer.getTrigger();
        }
        trigger.setName(name);
        trigger.setGroup(group);
        Map triggerParameters = IntrospectionSupport.extractProperties(parameters, ""trigger."");
        Map jobParameters = IntrospectionSupport.extractProperties(parameters, ""job."");
        setProperties(trigger, triggerParameters);
        setProperties(answer.getJobDetail(), jobParameters);
        return answer;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getScheduler().start();
    }
    @Override
    protected void doStop() throws Exception {
        if (scheduler != null) {
            scheduler.shutdown();
        }
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public SchedulerFactory getFactory() {
        if (factory == null) {
            factory = createSchedulerFactory();
        }
        return factory;
    }
    public void setFactory(SchedulerFactory factory) {
        this.factory = factory;
    }
    public Scheduler getScheduler() throws SchedulerException {
        if (scheduler == null) {
            scheduler = createScheduler();
        }
        return scheduler;
    }
    public void setScheduler(Scheduler scheduler) {
        this.scheduler = scheduler;
    }
    public Map getTriggers() {
        return triggers;
    }
    public void setTriggers(Map triggers) {
        this.triggers = triggers;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected SchedulerFactory createSchedulerFactory() {
        return new StdSchedulerFactory();
    }
    protected Scheduler createScheduler() throws SchedulerException {
        return getFactory().getScheduler();
    }
}
"
org.apache.camel.language.juel.BeanAndMethodELResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import javax.el.BeanELResolver;
import javax.el.ELContext;
import javax.el.PropertyNotFoundException;
/**
 * An extension of the JUEL {@link BeanELResolver} which also supports the resolving of methods
 *
 * @version $Revision$
 */
public class BeanAndMethodELResolver extends BeanELResolver {
    public BeanAndMethodELResolver() {
        super(false);
    }
    @Override
    public Object getValue(ELContext elContext, Object base, Object property) {
        try {
            return super.getValue(elContext, base, property);
        } catch (PropertyNotFoundException e) {
            // lets see if its a method call...
            Method method = findMethod(elContext, base, property);
            if (method != null) {
                elContext.setPropertyResolved(true);
                return method;
            } else {
                throw e;
            }
        }
    }
    protected Method findMethod(ELContext elContext, Object base, Object property) {
        if (base != null && property instanceof String) {
            Method[] methods = base.getClass().getMethods();
            List<Method> matching = new ArrayList<Method>();
            for (Method method : methods) {
                if (method.getName().equals(property) && Modifier.isPublic(method.getModifiers())) {
                    matching.add(method);
                }
            }
            int size = matching.size();
            if (size > 0) {
                if (size > 1) {
                    // TODO there's currently no way for JUEL to tell us how many parameters there are
                    // so lets just pick the first one that has a single param by default
                    for (Method method : matching) {
                        Class<?>[] paramTypes = method.getParameterTypes();
                        if (paramTypes.length == 1) {
                            return method;
                        }
                    }
                }
                // lets default to the first one
                return matching.get(0);
            }
        }
        return null;
    }
}
"
org.apache.camel.component.cxf.util.UriUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
public final class UriUtils {
    private UriUtils() {
        // not constructred
    }
    static URL getWsdlUrl(final URI uri) throws MalformedURLException {
        URL wsdlUrl = null;
        if (uri.getScheme().equals(CxfConstants.PROTOCOL_NAME_RES)) {       
            if (uri.getPath() != null) {
                String path = uri.isAbsolute() ? getRelativePath(uri) : uri.getPath();
                wsdlUrl = ClassLoaderUtils.getResource(path, UriUtils.class);
            }
        } else {
            wsdlUrl = new URL(uri.getScheme(), uri.getHost(), uri.getPort(), uri.getPath());
        }
        return wsdlUrl;
    }
    private static String getRelativePath(URI uri) {
        URI base = null;
        try {
            base = new URI(CxfConstants.PROTOCOL_NAME_RES, """", ""/"", """");
        } catch (URISyntaxException e) {
            // this shouldn't fail
            e.printStackTrace();
        }
        return base.relativize(uri).getPath();
    }
}
"
org.apache.camel.component.jms.JmsQueueEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.Collections;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.spi.BrowsableEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
/**
 * An endpoint for a JMS Queue which is also browsable
 *
 * @version $Revision$
 */
public class JmsQueueEndpoint extends JmsEndpoint implements BrowsableEndpoint<JmsExchange> {
    private static final transient Log LOG = LogFactory.getLog(JmsQueueEndpoint.class);
    private int maximumBrowseSize = -1;
    private final QueueBrowseStrategy queueBrowseStrategy;
    public JmsQueueEndpoint(String uri, JmsComponent component, String destination,
            JmsConfiguration configuration) {
        this(uri, component, destination, configuration, null);
    }
    public JmsQueueEndpoint(String uri, JmsComponent component, String destination,
            JmsConfiguration configuration, QueueBrowseStrategy queueBrowseStrategy) {
        super(uri, component, destination, false, configuration);
        if (queueBrowseStrategy == null) {
            this.queueBrowseStrategy = createQueueBrowseStrategy();
        } else {
            this.queueBrowseStrategy = queueBrowseStrategy;
        }
    }
    public JmsQueueEndpoint(String endpointUri, String destination, QueueBrowseStrategy queueBrowseStrategy) {
        super(endpointUri, destination, false);
        if (queueBrowseStrategy == null) {
            this.queueBrowseStrategy = createQueueBrowseStrategy();
        } else {
            this.queueBrowseStrategy = queueBrowseStrategy;
        }
    }
    public JmsQueueEndpoint(String endpointUri, String destination) {
        super(endpointUri, destination, false);
        queueBrowseStrategy = createQueueBrowseStrategy();
    }
    public int getMaximumBrowseSize() {
        return maximumBrowseSize;
    }
    /**
     * If a number is set > 0 then this limits the number of messages that are
     * returned when browsing the queue
     */
    public void setMaximumBrowseSize(int maximumBrowseSize) {
        this.maximumBrowseSize = maximumBrowseSize;
    }
    public List<Exchange> getExchanges() {
        if (queueBrowseStrategy == null) {
            return Collections.EMPTY_LIST;
        }
        String queue = getDestination();
        JmsOperations template = getConfiguration().createInOnlyTemplate(this, false, queue);
        return queueBrowseStrategy.browse(template, queue, this);
    }
    protected static QueueBrowseStrategy createQueueBrowseStrategy() {
        QueueBrowseStrategy answer = null;
        try {
            answer = JmsComponent.tryCreateDefaultQueueBrowseStrategy();
        } catch (Throwable e) {
            LOG.debug(""Caught exception trying to create default QueueBrowseStrategy. ""
                      + ""This could be due to spring 2.0.x on classpath? Cause: "" + e, e);
        }
        if (answer == null) {
            LOG.warn(""Cannot browse queues as no QueueBrowseStrategy specified. Are you using Spring 2.0.x by any chance? If you upgrade to 2.5.x or later then queue browsing is supported"");
        }
        return answer;
    }
}
"
org.apache.camel.component.cxf.invoker.CxfClient,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.transport.MessageObserver;
/**
 * Just deal with the PayLoadMessage and RawMessage
 *
 */
public class CxfClient extends ClientImpl {
    private static final Logger LOG = LogUtils.getL7dLogger(CxfClient.class);
    public CxfClient(Bus b, Endpoint e) {
        super(b, e);
    }
    public Object dispatch(Map<Class, Object> params,
                           Map<String, Object> context,
                           Exchange exchange) throws Exception {
        Object retval = null;
        InvokingContext invokingContext = exchange.get(InvokingContext.class);
        assert invokingContext != null;
        // get InBound binding operation info from the exchange object
        BindingOperationInfo inBoundOp = exchange.get(BindingOperationInfo.class);
        BindingOperationInfo outBoundOp = null;
        if (inBoundOp != null) {
            //Get the BindingOperationInfo for the outbound binding.
            BindingInfo bi = getEndpoint().getEndpointInfo().getBinding();
            outBoundOp = bi.getOperation(inBoundOp.getOperationInfo().getName());
            if (outBoundOp != null
                && inBoundOp.isUnwrapped()) {
                outBoundOp = outBoundOp.getUnwrappedOperation();
            }
        }
        retval = invokeWithMessageStream(outBoundOp, params, context, invokingContext);
        return retval;
    }
    @SuppressWarnings(""unchecked"")
    public Object invokeWithMessageStream(BindingOperationInfo bi,
                                          Map<Class, Object> param,
                                          Map<String, Object> context,
                                          InvokingContext invokingContext) throws Exception {
        Object retval = null;
        Map<String, Object> requestContext = null;
        Map<String, Object> responseContext = null;
        if (null != context) {
            requestContext = (Map<String, Object>) context.get(REQUEST_CONTEXT);
            responseContext = (Map<String, Object>) context.get(RESPONSE_CONTEXT);
        }
        Exchange exchange = new ExchangeImpl();
        // put the message Observer to call the CxfClient onMessage()
        setExchangeProperties(exchange, getEndpoint(), bi);
        exchange.put(InvokingContext.class, invokingContext);
        if (bi != null) {
            //Set The InputMessage
            exchange.put(BindingMessageInfo.class, bi.getInput());
            exchange.setOneWay(bi.getOperationInfo().isOneWay());
        }
        Message message = prepareMessage(exchange, requestContext, param, invokingContext);
        // add the invocation context
        message.put(Message.INVOCATION_CONTEXT, context);
        // add the endpoint props to the message
        Endpoint ep = getEndpoint();
        // the ep should not be null , just in case if it set to be null
        if (ep != null) {
            message.putAll(ep);
        }
        PhaseInterceptorChain chain = setupInterceptorChain(getEndpoint());
        message.setInterceptorChain(chain);
        modifyChain(chain, requestContext);
        chain.setFaultObserver(outFaultObserver);
        // setup conduit selector
        prepareConduitSelector(message);
        modifyChain(chain, null);
        // execute chain
        chain.doIntercept(message);
        //it will close all the stream in the message, so we do not call it
        //getConduitSelector().complete(exchange);
        // Check to see if there is a Fault from the outgoing chain
        Exception ex = message.getContent(Exception.class);
        if (ex != null) {
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Exception in outgoing chain: "" + ex.toString());
            }
            throw ex;
        }
        if (!exchange.isOneWay()) {
            synchronized (exchange) {
                waitResponse(exchange);
            }
            ex = getException(exchange);
            if (ex != null) {
                if (LOG.isLoggable(Level.FINE)) {
                    LOG.fine(""Exception in incoming chain: "" + ex.toString());
                }
                throw ex;
            }
            retval = invokingContext.getResponseObject(exchange, responseContext);
        }
        return retval;
    }
    private void waitResponse(Exchange exchange) {
        int remaining = synchronousTimeout;
        while (!Boolean.TRUE.equals(exchange.get(FINISHED)) && remaining > 0) {
            long start = System.currentTimeMillis();
            try {
                exchange.wait(remaining);
            } catch (InterruptedException ex) {
                // ignore
            }
            long end = System.currentTimeMillis();
            remaining -= (int)(end - start);
        }
        if (!Boolean.TRUE.equals(exchange.get(FINISHED))) {
            LogUtils.log(LOG, Level.WARNING, ""RESPONSE_TIMEOUT"",
                exchange.get(OperationInfo.class).getName().toString());
        }
    }
    private Message prepareMessage(Exchange exchange, Map<String, Object> requestContext,
            Map<Class, Object> param, InvokingContext invokingContext) {
        Message message = getEndpoint().getBinding().createMessage();
        message.put(Message.REQUESTOR_ROLE, Boolean.TRUE);
        message.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        // setup the message context
        if (requestContext != null) {
            message.putAll(requestContext);
        }
        if (param != null) {
            invokingContext.setRequestOutMessageContent(message, param);
        }
        if (null != requestContext) {
            exchange.putAll(requestContext);
        }
        exchange.setOutMessage(message);
        return message;
    }
}
"
org.apache.camel.component.cxf.CxfSoapComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.URISupport;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">SOAP Component</a>
 *
 * @version $Revision$
 */
public class CxfSoapComponent extends DefaultComponent {
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Map soapProps = IntrospectionSupport.extractProperties(parameters, ""soap."");
        if (parameters.size() > 0) {
            remaining += ""?"" + URISupport.createQueryString(parameters);
        }
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(getCamelContext(), remaining);
        CxfSoapEndpoint soapEndpoint = new CxfSoapEndpoint(endpoint);
        setProperties(soapEndpoint, soapProps);
        soapEndpoint.init();
        return soapEndpoint;
    }
    @Override
    protected boolean useIntrospectionOnEndpoint() {
        return false;
    }
}
"
org.apache.camel.component.stream.StreamMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import org.apache.camel.impl.DefaultMessage;
/**
 * @deprecated Camel Stream uses a DefaultMessage to contain the body. Will be removed in Camel 2.0
 */
public class StreamMessage extends DefaultMessage {
    private Object o;
    public StreamMessage(Object o) {
        this.o = o;
    }
    @Override
    protected Object createBody() {
        return o;
    }
    @Override
    public Object getBody() {
        return o;
    }
    @Override
    public String toString() {
        return o.toString();
    }
}
"
org.apache.camel.component.jms.JmsTemporaryQueueEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Session;
import javax.jms.TemporaryQueue;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.SessionCallback;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 * for working with a {@link TemporaryQueue}
 *
 * @version $Revision$
 */
// TODO need to be really careful to always use the same Connection otherwise the destination goes stale
public class JmsTemporaryQueueEndpoint extends JmsQueueEndpoint implements DestinationEndpoint {
    private Destination jmsDestination;
    public JmsTemporaryQueueEndpoint(String uri, JmsComponent component, String destination, JmsConfiguration configuration) {
        super(uri, component, destination, configuration);
    }
    public JmsTemporaryQueueEndpoint(String uri, JmsComponent component, String destination, JmsConfiguration configuration, QueueBrowseStrategy queueBrowseStrategy) {
        super(uri, component, destination, configuration, queueBrowseStrategy);
    }
    public JmsTemporaryQueueEndpoint(String endpointUri, String destination) {
        super(endpointUri, destination);
    }
    /**
     * This endpoint is a singleton so that the temporary destination instances are shared across all
     * producers and consumers of the same endpoint URI
     *
     * @return true
     */
    public boolean isSingleton() {
        return true;
    }
    public synchronized Destination getJmsDestination(Session session) throws JMSException {
        if (jmsDestination == null) {
            jmsDestination = createJmsDestination(session);
        }
        return jmsDestination;
    }
    protected Destination createJmsDestination(Session session) throws JMSException {
        return session.createTemporaryQueue();
    }
}
"
org.apache.camel.component.mina.MinaHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
import org.apache.mina.common.IoSession;
import org.apache.mina.common.WriteFuture;
/**
 * Helper class used internally by camel-mina using Apache MINA.
 */
public final class MinaHelper {
    private MinaHelper() {
        //Utility Class
    }
    /**
     * Writes the given body to MINA session. Will wait until the body has been written.
     *
     * @param session   the MINA session
     * @param body      the body to write (send)
     * @param exchange  the mina exchange used for error reporting
     * @throws CamelExchangeException is thrown if the body could not be written for some reasons
     *                                (eg remote connection is closed etc.)
     */
    public static void writeBody(IoSession session, Object body, Exchange exchange) throws CamelExchangeException {
        // the write operation is asynchronous. Use WriteFuture to wait until the session has been written
        WriteFuture future = session.write(body);
        future.join();
        if (!future.isWritten()) {
            throw new CamelExchangeException(""Could not write body"", exchange);
        }
    }
}
"
org.apache.camel.component.atom.AtomPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Feed;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Consumer to poll atom feeds and return the full feed.
 *
 * @version $Revision$
 */
public class AtomPollingConsumer extends AtomConsumerSupport {
    public AtomPollingConsumer(AtomEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
    }
    protected void poll() throws Exception {
        Document<Feed> document = AtomUtils.parseDocument(endpoint.getAtomUri());
        Feed feed = document.getRoot();
        Exchange exchange = endpoint.createExchange(feed);
        getProcessor().process(exchange);
    }
}
"
org.apache.camel.component.irc.IrcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultEndpoint;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/irc.html"">IRC Endpoint</a>
 *
 * @version $Revision$
 */
public class IrcEndpoint extends DefaultEndpoint<IrcExchange> {
    private IrcBinding binding;
    private IrcConfiguration configuration;
    private IrcComponent component;
    public IrcEndpoint(String endpointUri, IrcComponent component, IrcConfiguration configuration) {
        super(endpointUri, component);
        this.component = component;
        this.configuration = configuration;
    }
    public boolean isSingleton() {
        return true;
    }
    public IrcExchange createExchange(ExchangePattern pattern) {
        return new IrcExchange(getCamelContext(), pattern, getBinding());
    }
    public IrcExchange createOnPrivmsgExchange(String target, IRCUser user, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""PRIVMSG"", target, user, msg));
    }
    public IrcExchange createOnNickExchange(IRCUser user, String newNick) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""NICK"", user, newNick));
    }
    public IrcExchange createOnQuitExchange(IRCUser user, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""QUIT"", user, msg));
    }
    public IrcExchange createOnJoinExchange(String channel, IRCUser user) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""JOIN"", channel, user));
    }
    public IrcExchange createOnKickExchange(String channel, IRCUser user, String whoWasKickedNick, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""KICK"", channel, user, whoWasKickedNick, msg));
    }
    public IrcExchange createOnModeExchange(String channel, IRCUser user, IRCModeParser modeParser) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""MODE"", channel, user, modeParser.getLine()));
    }
    public IrcExchange createOnPartExchange(String channel, IRCUser user, String msg) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""PART"", channel, user, msg));
    }
    public IrcExchange createOnTopicExchange(String channel, IRCUser user, String topic) {
        return new IrcExchange(getCamelContext(), getExchangePattern(), getBinding(), new IrcMessage(""TOPIC"", channel, user, topic));
    }
    public IrcProducer createProducer() throws Exception {
        return new IrcProducer(this, component.getIRCConnection(configuration));
    }
    public IrcConsumer createConsumer(Processor processor) throws Exception {
        return new IrcConsumer(this, processor, component.getIRCConnection(configuration));
    }
    public IrcComponent getComponent() {
        return component;
    }
    public void setComponent(IrcComponent component) {
        this.component = component;
    }
    public IrcBinding getBinding() {
        if (binding == null) {
            binding = new IrcBinding();
        }
        return binding;
    }
    public void setBinding(IrcBinding binding) {
        this.binding = binding;
    }
    public IrcConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
}
"
org.apache.camel.component.jms.JmsTemporaryTopicEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Session;
import javax.jms.TemporaryTopic;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.SessionCallback;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 * for working with a {@link TemporaryTopic}
 *
 * @version $Revision$
 */
// TODO need to be really careful to always use the same Connection otherwise the destination goes stale
public class JmsTemporaryTopicEndpoint extends JmsEndpoint implements DestinationEndpoint {
    private Destination jmsDestination;
    public JmsTemporaryTopicEndpoint(String uri, JmsComponent component, String destination, JmsConfiguration configuration) {
        super(uri, component, destination, true, configuration);
    }
    public JmsTemporaryTopicEndpoint(String endpointUri, String destination) {
        super(endpointUri, destination);
    }
    /**
     * This endpoint is a singleton so that the temporary destination instances are shared across all
     * producers and consumers of the same endpoint URI
     *
     * @return true
     */
    public boolean isSingleton() {
        return true;
    }
    public synchronized Destination getJmsDestination(Session session) throws JMSException {
        if (jmsDestination == null) {
            jmsDestination = createJmsDestination(session);
        }
        return jmsDestination;
    }
    protected Destination createJmsDestination(Session session) throws JMSException {
        return session.createTemporaryTopic();
    }
}"
org.apache.camel.component.xquery.XQuery,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.language.NamespacePrefix;
/**
 * An annotation for injection of an XQuery expressions into a field, property, method or parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>.
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""xquery"", factory = XQueryAnnotationExpressionFactory.class)
public @interface XQuery {
    String value();
    NamespacePrefix[] namespaces() default {
    @NamespacePrefix(prefix = ""soap"", uri = ""http://www.w3.org/2003/05/soap-envelope""),
    @NamespacePrefix(prefix = ""xsd"", uri = ""http://www.w3.org/2001/XMLSchema"")};
}
"
org.apache.camel.spring.remoting.CamelProxyFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.ProxyHelper;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.remoting.support.UrlBasedRemoteAccessor;
/**
 * A {@link FactoryBean} to create a Proxy to a a Camel Pojo Endpoint.
 * 
 * @author chirino
 */
public class CamelProxyFactoryBean extends UrlBasedRemoteAccessor implements FactoryBean, CamelContextAware {
    private CamelContext camelContext;
    private Endpoint endpoint;
    private Object serviceProxy;
    @Override
    public void afterPropertiesSet() {
        super.afterPropertiesSet();
        try {
            if (endpoint == null) {
                if (getServiceUrl() == null || camelContext == null) {
                    throw new IllegalArgumentException(""If endpoint is not specified, the serviceUrl and camelContext must be specified."");
                }
                endpoint = camelContext.getEndpoint(getServiceUrl());
                if (endpoint == null) {
                    throw new IllegalArgumentException(""Could not resolve endpoint: "" + getServiceUrl());
                }
            }
            this.serviceProxy = ProxyHelper.createProxy(endpoint, getServiceInterface());
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }
    public Class getServiceInterface() {
        return super.getServiceInterface();
    }
    public String getServiceUrl() {
        return super.getServiceUrl();
    }
    public Object getObject() throws Exception {
        return serviceProxy;
    }
    public Class getObjectType() {
        return getServiceInterface();
    }
    public boolean isSingleton() {
        return true;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
}
"
org.apache.camel.component.cxf.CxfMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageContentsList;
import org.apache.cxf.message.MessageImpl;
/**
 * An Apache CXF {@link Message} which provides access to the underlying CXF
 * features
 *
 * @version $Revision$
 */
public class CxfMessage extends DefaultMessage {
    private Message cxfMessage;
    public CxfMessage() {
        this(new MessageImpl());
    }
    public CxfMessage(Message cxfMessage) {
        if (cxfMessage == null) {
            this.cxfMessage = new MessageImpl();
        } else {
            this.cxfMessage = cxfMessage;
        }
    }
    @Override
    public void copyFrom(org.apache.camel.Message that) {
        setMessageId(that.getMessageId());
        setBody(that.getBody());
        if (that.getBody() instanceof Message) {
            setMessage((Message)that.getBody());
        }
        getHeaders().putAll(that.getHeaders());
        if (that instanceof CxfMessage) {
            CxfMessage orig = (CxfMessage) that;
            setMessage(orig.getMessage());
        }
    }
    @Override
    public String toString() {
        if (cxfMessage != null) {
            return ""CxfMessage: "" + cxfMessage;
        } else {
            return ""CxfMessage: "" + getBody();
        }
    }
    @Override
    public CxfExchange getExchange() {
        return (CxfExchange)super.getExchange();
    }
    /**
     * Returns the underlying CXF message
     *
     * @return the CXF message
     */
    public Message getMessage() {
        return cxfMessage;
    }
    public void setMessage(Message cxfMessage) {
        this.cxfMessage = cxfMessage;
    }
    public Object getHeader(String name) {
        return cxfMessage.get(name);
    }
    @Override
    public void setHeader(String name, Object value) {
        cxfMessage.put(name, value);
    }
    @Override
    public Map<String, Object> getHeaders() {
        return cxfMessage;
    }
    @Override
    public CxfMessage newInstance() {
        return new CxfMessage();
    }
    @Override
    protected Object createBody() {
        return CxfBinding.extractBodyFromCxf(getExchange(), cxfMessage);
    }
    @Override
    public void setBody(Object body) {
        super.setBody(body);
        if (body instanceof Message) {
            setMessage((Message) body);
        }
    }
    public <T> T getBody(Class<T> type) {
        if (!(MessageContentsList.class.isAssignableFrom(type)) && getBody() instanceof MessageContentsList) {
            // if the body is the MessageContentsList then try to convert its payload
            // to make it easier for end-users to use camel-cxf
            MessageContentsList list = (MessageContentsList)getBody();
            for (int i = 0; i < list.size(); i++) {
                Object value = list.get(i);
                T answer = getBody(type, value);
                if (answer != null) {
                    return answer;
                }
            }
        }
        // default to super
        return super.getBody(type);
    }
}
"
org.apache.camel.converter.jaxb.HeaderType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.Message;
/**
 * Represents a JAXB2 representation of a Camel {@link Message} header
 *
 * @version $Revision$
 */
@XmlType(name = ""headerType"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public abstract class HeaderType {
    @XmlAttribute
    private String name;
    public HeaderType() {
    }
    protected HeaderType(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public abstract Object getValue();
    public abstract void setValue(Object value);
}"
org.apache.camel.component.cxf.interceptors.AbstractMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.staxutils.StaxUtils;
/**
 * This is the base class for message interceptors that intercepts message as DOM content
 * infers the BindingOperationInfo and then set the
 *
 */
public abstract class AbstractMessageInInterceptor<T extends Message>
       extends AbstractPhaseInterceptor<T> {
    public AbstractMessageInInterceptor(String phase) {
        super(phase);
    }
    protected boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    /**
     * Infer the OperationInfo from the XML Document and get the list of
     * parts as DOM Element
     */
    public void handleMessage(T message) throws Fault {
        Logger logger = getLogger();
        if (isFaultMessage(message)) {
            message.getInterceptorChain().abort();
            Endpoint ep = message.getExchange().get(Endpoint.class);
            if (ep.getInFaultObserver() != null) {
                ep.getInFaultObserver().onMessage(message);
                return;
            }
            //Fault f = createFault(message, payloadEl);
            //message.setContent(Exception.class, f);
            //return;
        }
        Document document = createDOMMessage(message);
        //Document document = message.getContent(Document.class);
        Element payloadEl = (Element)document.getChildNodes().item(0);
        Exchange ex = message.getExchange();
        BindingOperationInfo boi = ex.get(BindingOperationInfo.class);
        if (boi == null) {
            BindingInfo bi = ex.get(BindingInfo.class);
            if (bi == null) {
                Endpoint ep = ex.get(Endpoint.class);
                bi = ep.getEndpointInfo().getBinding();
                ex.put(BindingInfo.class, bi);
            }
            // handling inbound message
            if (logger.isLoggable(Level.INFO)) {
                logger.info(""AbstractRoutingMessageInInterceptor Infer BindingOperationInfo."");
            }
            boi = getBindingOperation(message, document);
            if (boi == null) {
                QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
                throw new Fault(new org.apache.cxf.common.i18n.Message(
                                ""REQ_NOT_UNDERSTOOD"", getLogger(), startQName));
            }
            if (boi != null) {
                ex.put(BindingOperationInfo.class, boi);
                ex.put(OperationInfo.class, boi.getOperationInfo());
                ex.setOneWay(boi.getOperationInfo().isOneWay());
                if (logger.isLoggable(Level.INFO)) {
                    logger.info(""DOMInInterceptor- BindingOperation is:"" + boi.getName());
                }
            }
        }
        BindingMessageInfo bmi = isRequestor(message) ?  boi.getOutput() : boi.getInput();
        List<Element> partList = getPartList(message, payloadEl, bmi);
        message.put(List.class, partList);
        Element header = getHeader(message);
        message.put(Element.class, header);
    }
    /**
     * This method is called to convert a incoming message format e.g Stax Stream
     * to a DOM Tree. Default Implementation converts Stax Stream to a DOM
     */
    protected Document createDOMMessage(T message) {
        Document doc = null;
        try {
            if (getLogger().isLoggable(Level.INFO)) {
                getLogger().info(""AbstractMessageInInterceptor Converting Stax Stream to DOM"");
            }
            XMLStreamReader xsr = message.getContent(XMLStreamReader.class);
            doc = StaxUtils.read(xsr);
        } catch (XMLStreamException xe) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""STAX_READ_EXC"", getLogger()), xe);
        }
        return doc;
    }
    protected abstract Logger getLogger();
    /**
     * This method is called on incoming to check if it is a fault.
     */
    protected abstract boolean isFaultMessage(T message);
    /**
     * This method is called when the routing message interceptor has received a inbound message
     * It infers the binding operation by matching the root Element with a binding operation
     * from the service model.
     */
    protected abstract BindingOperationInfo getBindingOperation(T inMessage, Document document);
    /**
     * This method is called when the routing message interceptor has intercepted a inbound
     * message as a DOM Content.  It retreives the message parts as DOM Element
     * and returns a List of Element.
     */
    protected abstract List<Element> getPartList(T inMessage, Element rootElement, BindingMessageInfo boi);
    /**
     * This method is called when the routing message interceptor has intercepted a inbound
     * message as a DOM Content.  It retreives the header parts as DOM Element
     * and returns a Element.
     */
    protected abstract Element getHeader(T inMessage);
}
"
org.apache.camel.component.xmpp.XmppBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.jivesoftware.smack.packet.Message;
/**
 * A Strategy used to convert between a Camel {@link XmppExchange} and {@link XmppMessage} to and from a
 * XMPP {@link Message}
 *
 * @version $Revision$
 */
public class XmppBinding {
    /**
     * Populates the given XMPP message from the inbound exchange
     */
    public void populateXmppMessage(Message message, Exchange exchange) {
        message.setBody(exchange.getIn().getBody(String.class));
        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String name = entry.getKey();
            Object value = entry.getValue();
            if (shouldOutputHeader(exchange, name, value)) {
                message.setProperty(name, value);
            }
        }
        String id = exchange.getExchangeId();
        if (id != null) {
            message.setProperty(""exchangeId"", id);
        }
    }
    /**
     * Extracts the body from the XMPP message
     *
     * @param exchange
     * @param message
     */
    public Object extractBodyFromXmpp(XmppExchange exchange, Message message) {
        return message.getBody();
    }
    /**
     * Strategy to allow filtering of headers which are put on the XMPP message
     */
    protected boolean shouldOutputHeader(Exchange exchange, String headerName, Object headerValue) {
        return true;
    }
}
"
org.apache.camel.component.spring.integration.converter.SpringIntegrationConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.converter;
import java.util.Map;
import org.apache.camel.Converter;
import org.apache.camel.Endpoint;
import org.apache.camel.component.spring.integration.SpringIntegrationEndpoint;
import org.apache.camel.component.spring.integration.SpringIntegrationMessage;
import org.springframework.integration.channel.MessageChannel;
import org.springframework.integration.message.DefaultMessageHeader;
import org.springframework.integration.message.GenericMessage;
/**
 * The <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * for turning the Spring Integration types into Camel native type.
 *
 * @version $Revision$
 */
@Converter
public final class SpringIntegrationConverter {
    private SpringIntegrationConverter() {
        // Helper class
    }
    /**
     * @param Spring Integration MessageChannel
     * @return an Camel Endpoint
     * @throws Exception
     */
    @Converter
    public static Endpoint toEndpoint(final MessageChannel channel) throws Exception {
        if (channel == null) {
            throw new IllegalArgumentException(""The MessageChannel is null"");
        }
        Endpoint answer = new SpringIntegrationEndpoint(""URL"", channel, null);
        // check the channel
        return answer;
    }
    @SuppressWarnings(""unchecked"")
    @Converter
    public static org.springframework.integration.message.Message toSpringMessage(final org.apache.camel.Message camelMessage) throws Exception {
        if (camelMessage instanceof SpringIntegrationMessage) {
            SpringIntegrationMessage siMessage = (SpringIntegrationMessage)camelMessage;
            org.springframework.integration.message.Message message =  siMessage.getMessage();
            if (message != null) {
                return message;
            }
        }
        // Create a new spring message and copy the attributes and body from the camel message
        DefaultMessageHeader messageHeader = new DefaultMessageHeader();
        Map<String, Object> headers = camelMessage.getHeaders();
        for (String key : headers.keySet()) {
            Object value = headers.get(key);
            messageHeader.setAttribute(key, value);
        }
        return new GenericMessage(camelMessage.getBody(), messageHeader);
    }
    @Converter
    public static org.apache.camel.Message toCamelMessage(final org.springframework.integration.message.Message springMessage) throws Exception {
        return new SpringIntegrationMessage(springMessage);
    }
}
"
org.apache.camel.component.jms.JmsComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.Map;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import javax.jms.Session;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.component.jms.requestor.Requestor;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.connection.JmsTransactionManager;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
import static org.apache.camel.util.ObjectHelper.removeStartingCharacters;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Component</a>
 *
 * @version $Revision:520964 $
 */
public class JmsComponent extends DefaultComponent<JmsExchange> implements ApplicationContextAware {
    private static final transient Log LOG = LogFactory.getLog(JmsComponent.class);
    private static final String DEFAULT_QUEUE_BROWSE_STRATEGY = ""org.apache.camel.component.jms.DefaultQueueBrowseStrategy"";
    private JmsConfiguration configuration;
    private ApplicationContext applicationContext;
    private Requestor requestor;
    private QueueBrowseStrategy queueBrowseStrategy;
    private boolean attemptedToCreateQueueBrowserStrategy;
    public JmsComponent() {
    }
    public JmsComponent(JmsConfiguration configuration) {
        this.configuration = configuration;
    }
    public JmsComponent(CamelContext context) {
        super(context);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent() {
        return new JmsComponent();
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(JmsConfiguration configuration) {
        return new JmsComponent(configuration);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(ConnectionFactory connectionFactory) {
        return jmsComponent(new JmsConfiguration(connectionFactory));
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentClientAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.CLIENT_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentAutoAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.AUTO_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory) {
        JmsTransactionManager transactionManager = new JmsTransactionManager();
        transactionManager.setConnectionFactory(connectionFactory);
        return jmsComponentTransacted(connectionFactory, transactionManager);
    }
    public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory,
                                                      PlatformTransactionManager transactionManager) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setTransactionManager(transactionManager);
        template.setTransacted(true);
        return jmsComponent(template);
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsConfiguration getConfiguration() {
        if (configuration == null) {
            configuration = createConfiguration();
            // If we are being configured with spring...
            if (applicationContext != null) {
                Map beansOfType = applicationContext.getBeansOfType(ConnectionFactory.class);
                if (!beansOfType.isEmpty()) {
                    ConnectionFactory cf = (ConnectionFactory)beansOfType.values().iterator().next();
                    configuration.setConnectionFactory(cf);
                }
                beansOfType = applicationContext.getBeansOfType(DestinationResolver.class);
                if (!beansOfType.isEmpty()) {
                    DestinationResolver destinationResolver = (DestinationResolver)beansOfType.values()
                        .iterator().next();
                    configuration.setDestinationResolver(destinationResolver);
                }
            }
        }
        return configuration;
    }
    /**
     * Sets the JMS configuration
     *
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(JmsConfiguration configuration) {
        this.configuration = configuration;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        getConfiguration().setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementMode(consumerAcknowledgementMode);
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementModeName(consumerAcknowledgementMode);
    }
    public void setAutoStartup(boolean autoStartup) {
        getConfiguration().setAutoStartup(autoStartup);
    }
    public void setCacheLevel(int cacheLevel) {
        getConfiguration().setCacheLevel(cacheLevel);
    }
    public void setCacheLevelName(String cacheName) {
        getConfiguration().setCacheLevelName(cacheName);
    }
    public void setClientId(String consumerClientId) {
        getConfiguration().setClientId(consumerClientId);
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        getConfiguration().setConcurrentConsumers(concurrentConsumers);
    }
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        getConfiguration().setConnectionFactory(connectionFactory);
    }
    public void setConsumerType(ConsumerType consumerType) {
        getConfiguration().setConsumerType(consumerType);
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        getConfiguration().setDeliveryPersistent(deliveryPersistent);
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        getConfiguration().setDurableSubscriptionName(durableSubscriptionName);
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        getConfiguration().setExceptionListener(exceptionListener);
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        getConfiguration().setExplicitQosEnabled(explicitQosEnabled);
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        getConfiguration().setExposeListenerSession(exposeListenerSession);
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        getConfiguration().setIdleTaskExecutionLimit(idleTaskExecutionLimit);
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        getConfiguration().setMaxConcurrentConsumers(maxConcurrentConsumers);
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        getConfiguration().setMaxMessagesPerTask(maxMessagesPerTask);
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        getConfiguration().setMessageConverter(messageConverter);
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        getConfiguration().setMessageIdEnabled(messageIdEnabled);
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        getConfiguration().setMessageTimestampEnabled(messageTimestampEnabled);
    }
    public void setAlwaysCopyMessage(boolean alwaysCopyMessage) {
        getConfiguration().setAlwaysCopyMessage(alwaysCopyMessage);
    }
    public void setUseMessageIDAsCorrelationID(boolean useMessageIDAsCorrelationID) {
        getConfiguration().setUseMessageIDAsCorrelationID(useMessageIDAsCorrelationID);
    }
    public void setPriority(int priority) {
        getConfiguration().setPriority(priority);
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        getConfiguration().setPubSubNoLocal(pubSubNoLocal);
    }
    public void setReceiveTimeout(long receiveTimeout) {
        getConfiguration().setReceiveTimeout(receiveTimeout);
    }
    public void setRecoveryInterval(long recoveryInterval) {
        getConfiguration().setRecoveryInterval(recoveryInterval);
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        getConfiguration().setServerSessionFactory(serverSessionFactory);
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        getConfiguration().setSubscriptionDurable(subscriptionDurable);
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        getConfiguration().setTaskExecutor(taskExecutor);
    }
    public void setTimeToLive(long timeToLive) {
        getConfiguration().setTimeToLive(timeToLive);
    }
    public void setTransacted(boolean consumerTransacted) {
        getConfiguration().setTransacted(consumerTransacted);
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        getConfiguration().setTransactionManager(transactionManager);
    }
    public void setTransactionName(String transactionName) {
        getConfiguration().setTransactionName(transactionName);
    }
    public void setTransactionTimeout(int transactionTimeout) {
        getConfiguration().setTransactionTimeout(transactionTimeout);
    }
    public void setUseVersion102(boolean useVersion102) {
        getConfiguration().setUseVersion102(useVersion102);
    }
    public void setJmsOperations(JmsOperations jmsOperations) {
        getConfiguration().setJmsOperations(jmsOperations);
    }
    public void setDestinationResolver(DestinationResolver destinationResolver) {
        getConfiguration().setDestinationResolver(destinationResolver);
    }
    public synchronized Requestor getRequestor() throws Exception {
        if (requestor == null) {
            requestor = new Requestor(getConfiguration(), getExecutorService());
            requestor.start();
        }
        return requestor;
    }
    public void setRequestor(Requestor requestor) {
        this.requestor = requestor;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public QueueBrowseStrategy getQueueBrowseStrategy() {
        if (queueBrowseStrategy == null) {
            if (!attemptedToCreateQueueBrowserStrategy) {
                attemptedToCreateQueueBrowserStrategy = true;
                try {
                    queueBrowseStrategy = tryCreateDefaultQueueBrowseStrategy();
                } catch (Throwable e) {
                    LOG.warn(""Could not instantiate the QueueBrowseStrategy are you using Spring 2.0.x""
                        + "" by any chance? Error: "" + e, e);
                }
            }
        }
        return queueBrowseStrategy;
    }
    public void setQueueBrowseStrategy(QueueBrowseStrategy queueBrowseStrategy) {
        this.queueBrowseStrategy = queueBrowseStrategy;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    @Override
    protected void doStop() throws Exception {
        if (requestor != null) {
            requestor.stop();
        }
        super.doStop();
    }
    @Override
    protected Endpoint<JmsExchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        boolean pubSubDomain = false;
        boolean tempDestination = false;
        if (remaining.startsWith(JmsConfiguration.QUEUE_PREFIX)) {
            pubSubDomain = false;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.QUEUE_PREFIX.length()), '/');
        } else if (remaining.startsWith(JmsConfiguration.TOPIC_PREFIX)) {
            pubSubDomain = true;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.TOPIC_PREFIX.length()), '/');
        } else if (remaining.startsWith(JmsConfiguration.TEMP_QUEUE_PREFIX)) {
            pubSubDomain = false;
            tempDestination = true;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.TEMP_QUEUE_PREFIX.length()), '/');
        } else if (remaining.startsWith(JmsConfiguration.TEMP_TOPIC_PREFIX)) {
            pubSubDomain = true;
            tempDestination = true;
            remaining = removeStartingCharacters(remaining.substring(JmsConfiguration.TEMP_TOPIC_PREFIX.length()), '/');
        }
        final String subject = convertPathToActualDestination(remaining, parameters);
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        JmsConfiguration newConfiguration = getConfiguration().copy();
        JmsEndpoint endpoint;
        if (pubSubDomain) {
            if (tempDestination) {
                endpoint = new JmsTemporaryTopicEndpoint(uri, this, subject, newConfiguration);
            } else {
                endpoint = new JmsEndpoint(uri, this, subject, pubSubDomain, newConfiguration);
            }
        } else {
            QueueBrowseStrategy strategy = getQueueBrowseStrategy();
            if (tempDestination) {
                endpoint = new JmsTemporaryQueueEndpoint(uri, this, subject, newConfiguration, strategy);
            } else {
                endpoint = new JmsQueueEndpoint(uri, this, subject, newConfiguration, strategy);
            }
        }
        String selector = getAndRemoveParameter(parameters, ""selector"", String.class);
        if (selector != null) {
            endpoint.setSelector(selector);
        }
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    /**
     * A strategy method allowing the URI destination to be translated into the
     * actual JMS destination name (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path, Map parameters) {
        return path;
    }
    /**
     * Factory method to create the default configuration instance
     *
     * @return a newly created configuration object which can then be further
     *         customized
     */
    protected JmsConfiguration createConfiguration() {
        return new JmsConfiguration();
    }
    /**
     * Attempts to instantiate the default {@link QueueBrowseStrategy} which
     * should work fine if Spring 2.5.x or later is on the classpath but this
     * will fail if 2.0.x are on the classpath. We can continue to operate on
     * this version we just cannot support the browseable queues supported by
     * {@link JmsQueueEndpoint}
     *
     * @return the queue browse strategy or null if it cannot be supported
     */
    protected static QueueBrowseStrategy tryCreateDefaultQueueBrowseStrategy() {
        // lets try instantiate the default implementation
        Class<?> type = ObjectHelper.loadClass(DEFAULT_QUEUE_BROWSE_STRATEGY);
        if (type == null) {
            LOG.warn(""Could not load class: "" + DEFAULT_QUEUE_BROWSE_STRATEGY
                     + "" maybe you are on Spring 2.0.x?"");
            return null;
        } else {
            return (QueueBrowseStrategy)ObjectHelper.newInstance(type);
        }
    }
}
"
org.apache.camel.component.jpa.Consumed,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation to mark a method to be invoked when an entity bean has been succesfully processed
 * by a Camel consumer, so that it can be updated in some way to remove it from the query set.
 * <p/>
 * For example a method may be marked to set an active flag to false or to update some status value to the next step in a workflow
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD })
public @interface Consumed {
}
"
org.apache.camel.component.cxf.CxfConstants,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
/**
 * Constants used in this module
 *
 * @version $Revision$
 */
public interface CxfConstants {
    String METHOD = ""method"";
    String SERVICE_CLASS = ""serviceClass"";
    String DATA_FORMAT = ""dataFormat"";
    String SET_DEFAULT_BUS = ""setDefaultBus"";
    String WSDL_URL = ""wsdlURL"";
    String ADDRESS = ""address"";
    String SERVICE_NAME = ""serviceName"";
    String PORT_NAME = ""portName"";
    String PROTOCOL_NAME_RES = ""res"";
    String OPERATION_NAME = ""operationName"";
    String OPERATION_NAMESPACE = ""operationNameSpace"";
    String SPRING_CONTEXT_ENDPOINT = ""bean:"";
    String CAMEL_TRANSPORT_PREFIX = ""camel:"";
    String CXF_EXCHANGE = ""org.apache.cxf.message.exchange"";
    String CAMEL_EXCHANGE = ""org.apache.camel.exchange"";
}
"
org.apache.camel.spring.spi.TransactionInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangeProperty;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * The <a href=""http://activemq.apache.org/camel/transactional-client.html"">Transactional Client</a>
 * EIP pattern.
 *
 * @version $Revision$
 */
public class TransactionInterceptor extends DelegateProcessor {
    public static final ExchangeProperty<Boolean> TRANSACTED =
        new ExchangeProperty<Boolean>(""transacted"", ""org.apache.camel.transacted"", Boolean.class);
    private static final transient Log LOG = LogFactory.getLog(TransactionInterceptor.class);
    private final TransactionTemplate transactionTemplate;
    private ThreadLocal<RedeliveryData> previousRollback = new ThreadLocal<RedeliveryData>() {
        @Override
        protected RedeliveryData initialValue() {
            return new RedeliveryData();
        }
    };
    private RedeliveryPolicy redeliveryPolicy;
    public TransactionInterceptor(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }
    public TransactionInterceptor(Processor processor, TransactionTemplate transactionTemplate) {
        super(processor);
        this.transactionTemplate = transactionTemplate;
    }
    public TransactionInterceptor(Processor processor, TransactionTemplate transactionTemplate, RedeliveryPolicy redeliveryPolicy) {
        this(processor, transactionTemplate);
        this.redeliveryPolicy = redeliveryPolicy;
    }
    @Override
    public String toString() {
        return ""TransactionInterceptor:""
            + propagationBehaviorToString(transactionTemplate.getPropagationBehavior())
            + ""["" + getProcessor() + ""]"";
    }
    public void process(final Exchange exchange) {
        LOG.debug(""Transaction begin"");
        final RedeliveryData redeliveryData = previousRollback.get();
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // TODO: The delay is in some cases never triggered - see CAMEL-663
                if (redeliveryPolicy != null && redeliveryData.previousRollback) {
                    // lets delay
                    redeliveryData.redeliveryDelay = redeliveryPolicy.sleep(redeliveryData.redeliveryDelay);
                }
                // wrapper exception to throw if the exchange failed
                // IMPORTANT: Must be a runtime exception to let Spring regard it as to do ""rollback""
                RuntimeCamelException rce = null;
                boolean activeTx = false;
                try {
                    // find out if there is an actual transaction alive, and thus we are in transacted mode
                    activeTx = TransactionSynchronizationManager.isActualTransactionActive();
                    if (!activeTx) {
                        activeTx = status.isNewTransaction() && !status.isCompleted();
                        if (!activeTx) {
                            if (DefaultTransactionStatus.class.isAssignableFrom(status.getClass())) {
                                DefaultTransactionStatus defStatus = DefaultTransactionStatus.class
                                    .cast(status);
                                activeTx = defStatus.hasTransaction() && !status.isCompleted();
                            }
                        }
                    }
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Is actual transaction active: "" + activeTx);
                    }
                    // okay mark the exchange as transacted, then the DeadLetterChannel or others know
                    // its an transacted exchange
                    if (activeTx) {
                        TRANSACTED.set(exchange, Boolean.TRUE);
                    }
                    // process the exchange
                    processNext(exchange);
                    // wrap if the exchange failed with an exception
                    if (exchange.getException() != null) {
                        rce = new RuntimeCamelException(exchange.getException());
                    }
                } catch (Exception e) {
                     // wrap if the exchange threw an exception
                    rce = new RuntimeCamelException(e);
                }
                // rehrow exception if the exchange failed
                if (rce != null) {
                    redeliveryData.previousRollback = true;
                    if (activeTx) {
                        status.setRollbackOnly();
                        LOG.debug(""Transaction rollback"");
                    }
                    throw rce;
                }
            }
        });
        redeliveryData.previousRollback = false;
        redeliveryData.redeliveryDelay = 0L;
        LOG.debug(""Transaction commit"");
    }
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    protected static class RedeliveryData {
        boolean previousRollback;
        long redeliveryDelay;
    }
    protected String propagationBehaviorToString(int propagationBehavior) {
        String rc;
        switch (propagationBehavior) {
        case TransactionDefinition.PROPAGATION_MANDATORY:
            rc = ""PROPAGATION_MANDATORY"";
            break;
        case TransactionDefinition.PROPAGATION_NESTED:
            rc = ""PROPAGATION_NESTED"";
            break;
        case TransactionDefinition.PROPAGATION_NEVER:
            rc = ""PROPAGATION_NEVER"";
            break;
        case TransactionDefinition.PROPAGATION_NOT_SUPPORTED:
            rc = ""PROPAGATION_NOT_SUPPORTED"";
            break;
        case TransactionDefinition.PROPAGATION_REQUIRED:
            rc = ""PROPAGATION_REQUIRED"";
            break;
        case TransactionDefinition.PROPAGATION_REQUIRES_NEW:
            rc = ""PROPAGATION_REQUIRES_NEW"";
            break;
        case TransactionDefinition.PROPAGATION_SUPPORTS:
            rc = ""PROPAGATION_SUPPORTS"";
            break;
        default:
            rc = ""UNKNOWN"";
        }
        return rc;
    }
}
"
org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.commons.io.IOUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class RawMessageContentRedirectInterceptor extends AbstractPhaseInterceptor<Message> {
    public RawMessageContentRedirectInterceptor() {
        super(Phase.WRITE);
    }
    public void handleMessage(Message message) throws Fault {
        // check the fault from the message
        Exception ex = message.getContent(Exception.class);
        if (ex != null) {
            if (ex instanceof Fault) {
                throw (Fault)ex;
            } else {
                throw new Fault(ex);
            }
        }
        InputStream is = message.getContent(InputStream.class);
        OutputStream os = message.getContent(OutputStream.class);
        try {
            IOUtils.copy(is, os);
            is.close();
            os.flush();
        } catch (Exception e) {
            throw new Fault(e);
        }
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.integration.channel.ChannelRegistry;
import org.springframework.integration.channel.MessageChannel;
import org.springframework.integration.config.MessageBusParser;
/**
 * A producer of exchanges for the Spring Integration
 * Please specify the outputChannel in the endpoint url for this producer.
 * If the message pattern is inOut, the inputChannel property
 * should be set for receiving the response message.
 * @version $Revision$
 */
public class SpringIntegrationProducer extends DefaultProducer<SpringIntegrationExchange> {
    private static final transient Log LOG = LogFactory.getLog(SpringIntegrationProducer.class);
    private SpringCamelContext context;
    private MessageChannel inputChannel;
    private MessageChannel outputChannel;
    private String outputChannelName;
    private ChannelRegistry channelRegistry;
    private SpringIntegrationEndpoint endpoint;
    public SpringIntegrationProducer(SpringIntegrationEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        context = (SpringCamelContext) endpoint.getCamelContext();
        if (context != null && endpoint.getMessageChannel() == null) {
            outputChannelName = endpoint.getDefaultChannel();
            channelRegistry = (ChannelRegistry) context.getApplicationContext().getBean(MessageBusParser.MESSAGE_BUS_BEAN_NAME);
            if (ObjectHelper.isNullOrBlank(outputChannelName)) {
                outputChannelName = endpoint.getInputChannel();
            }
            if (ObjectHelper.isNullOrBlank(outputChannelName)) {
                throw new RuntimeCamelException(""Can't find the right outputChannelName,""
                                                + ""please check the endpoint uri outputChannel part!"");
            } else {
                outputChannel = (MessageChannel) channelRegistry.lookupChannel(outputChannelName);
            }
        } else {
            if (endpoint.getMessageChannel() != null) {
                outputChannel = endpoint.getMessageChannel();
            } else {
                throw new RuntimeCamelException(""Can't find the right message channel, please check your configuration."");
            }
        }
        if (endpoint.isInOut()) {
            endpoint.setExchangePattern(ExchangePattern.InOut);
            // we need to setup right inputChannel for further processing
            if (ObjectHelper.isNullOrBlank(endpoint.getInputChannel())) {
                throw new RuntimeCamelException(""Can't find the right inputChannel, ""
                                                + ""please check the endpoint uri inputChannel part!"");
            } else {
                inputChannel = (MessageChannel) channelRegistry.lookupChannel(endpoint.getInputChannel());
            }
        }
    }
    public void process(Exchange exchange) throws Exception {
        org.springframework.integration.message.Message siOutmessage = SpringIntegrationBinding.createSpringIntegrationMessage(exchange);
        if (exchange.getPattern().isInCapable()) {
            //Set the return channel address
            siOutmessage.getHeader().setReturnAddress(inputChannel);
            outputChannel.send(siOutmessage);
            org.springframework.integration.message.Message siInMessage =
                inputChannel.receive();
            SpringIntegrationBinding.storeToCamelMessage(siInMessage, exchange.getOut());
        } else {
            outputChannel.send(siOutmessage);
        }
    }
}
"
org.apache.camel.bam.model.ProcessDefinition,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.List;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.UniqueConstraint;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
/**
 * @version $Revision$
 */
@Entity
@UniqueConstraint(columnNames = {""name"" })
public class ProcessDefinition extends EntitySupport {
    private static final transient Log LOG = LogFactory.getLog(ProcessDefinition.class);
    private String name;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public static ProcessDefinition getRefreshedProcessDefinition(JpaTemplate template, ProcessDefinition definition) {
        // TODO refresh doesn't tend to work - maybe its a spring thing?
        // template.refresh(definition);
        ObjectHelper.notNull(definition, ""definition"");
        Long id = definition.getId();
        if (id == null) {
            LOG.warn(""No primary key is available!"");
            return findOrCreateProcessDefinition(template, definition.getName());
        }
        definition = template.find(ProcessDefinition.class, id);
        return definition;
    }
    public static ProcessDefinition findOrCreateProcessDefinition(JpaTemplate template, String processName) {
        List<ProcessDefinition> list = template.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            template.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.spring.util.MainRunner,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.InitializingBean;
import static org.apache.camel.util.ObjectHelper.name;
/**
 * A simple helper bean for running main classes from within the spring.xml
 * usually asynchronous in a background thread; which is useful for demos such
 * as running Swing programs in the same JVM.
 * 
 * @version $Revision$
 */
public class MainRunner implements InitializingBean, Runnable {
    private static final Log LOG = LogFactory.getLog(MainRunner.class);
    private Class main;
    private String[] args = {};
    private boolean asyncRun = true;
    private long delay;
    public String toString() {
        return ""MainRunner("" + name(main) + "" "" + Arrays.asList(getArgs()) + "")"";
    }
    public void run() {
        try {
            runMethodWithoutCatchingExceptions();
        } catch (NoSuchMethodException e) {
            LOG.error(""Class: "" + name(main) + "" does not have a main method: "" + e, e);
        } catch (IllegalAccessException e) {
            LOG.error(""Failed to run: "" + this + "". Reason: "" + e, e);
        } catch (InvocationTargetException e) {
            Throwable throwable = e.getTargetException();
            LOG.error(""Failed to run: "" + this + "". Reason: "" + throwable, throwable);
        }
    }
    public void runMethodWithoutCatchingExceptions() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        if (delay > 0) {
            try {
                Thread.sleep(delay);
            } catch (InterruptedException e) {
                LOG.info(""Caught: "" + e, e);
            }
        }
        Method method = main.getMethod(""main"", String[].class);
        if (!Modifier.isStatic(method.getModifiers())) {
            throw new IllegalArgumentException(""The main method is not static!: "" + method);
        }
        Object[] arguments = {getArgs()};
        method.invoke(null, arguments);
    }
    public String[] getArgs() {
        return args;
    }
    public void setArgs(String[] args) {
        this.args = args;
    }
    public boolean isAsyncRun() {
        return asyncRun;
    }
    public void setAsyncRun(boolean asyncRun) {
        this.asyncRun = asyncRun;
    }
    public Class getMain() {
        return main;
    }
    public void setMain(Class main) {
        this.main = main;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public void afterPropertiesSet() throws Exception {
        if (main == null) {
            throw new IllegalArgumentException(""You must specify a main class!"");
        }
        if (isAsyncRun()) {
            Thread thread = new Thread(this, ""Thread for: "" + this);
            thread.start();
        } else {
            runMethodWithoutCatchingExceptions();
        }
    }
}
"
org.apache.camel.component.amqp.AMQPComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.amqp;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.component.jms.JmsComponent;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.qpid.client.AMQConnectionFactory;
import org.apache.qpid.url.URLSyntaxException;
/**
 * @version $Revision$
 */
public class AMQPComponent extends JmsComponent {
    public AMQPComponent() {
        init();
    }
    public AMQPComponent(JmsConfiguration configuration) {
        super(configuration);
    }
    public AMQPComponent(CamelContext context) {
        super(context);
        init();
    }
    public AMQPComponent(AMQConnectionFactory connectionFactory) {
        setConnectionFactory(connectionFactory);
    }
    public static Component amqpComponent(String uri) throws URLSyntaxException {
        AMQConnectionFactory connectionFactory = new AMQConnectionFactory(uri);
        return new AMQPComponent(connectionFactory);
    }
    /**
     * Lets install the default connection factory
     */
    private void init() {
        AMQConnectionFactory connectionFactory = new AMQConnectionFactory();
        setConnectionFactory(connectionFactory);
    }
}
"
org.apache.camel.component.jdbc.JdbcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.sql.DataSource;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision$
 */
public class JdbcProducer extends DefaultProducer<DefaultExchange> {
    private static final transient Log LOG = LogFactory.getLog(JdbcProducer.class);
    private DataSource source;
    /** The maximum size for reading a result set <code>readSize</code> */
    private int readSize = 2000;
    public JdbcProducer(JdbcEndpoint endpoint, String remaining, int readSize) throws Exception {
        super(endpoint);
        this.readSize = readSize;
        source = (DataSource) getEndpoint().getCamelContext().getRegistry().lookup(remaining);
    }
    /**
     * Execute sql of exchange and set results on output
     *
     * @see org.apache.camel.Processor#process(org.apache.camel.Exchange)
     */
    public void process(Exchange exchange) throws Exception {
        String sql = exchange.getIn().getBody(String.class);
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            conn = source.getConnection();
            stmt = conn.createStatement();
            if (stmt.execute(sql)) {
                rs = stmt.getResultSet();
                setResultSet(exchange, rs);
            } else {
                int updateCount = stmt.getUpdateCount();
                exchange.getOut().setHeader(""jdbc.updateCount"", updateCount);
            }
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (stmt != null) {
                    stmt.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e) {
                LOG.warn(""Error closing JDBC resource: "" + e, e);
            }
        }
    }
    public int getReadSize() {
        return this.readSize;
    }
    public void setReadSize(int readSize) {
        this.readSize = readSize;
    }
    public void setResultSet(Exchange exchange, ResultSet rs) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        HashMap<String, Object> props = new HashMap<String, Object>();
        IntrospectionSupport.getProperties(meta, props, ""jdbc."");
        exchange.getOut().setHeaders(props);
        int count = meta.getColumnCount();
        List<HashMap<String, Object>> data = new ArrayList<HashMap<String, Object>>();
        int rowNumber = 0;
        while (rs.next() && rowNumber < readSize) {
            HashMap<String, Object> row = new HashMap<String, Object>();
            for (int i = 0; i < count; i++) {
                int columnNumber = i + 1;
                String columnName = meta.getColumnName(columnNumber);
                row.put(columnName, rs.getObject(columnName));
            }
            data.add(row);
            rowNumber++;
        }
        exchange.getOut().setBody(data);
    }
}
"
org.apache.camel.bam.model.ProcessInstance,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a single business process
 *
 * @version $Revision$
 */
@Entity
public class ProcessInstance  {
    private static final transient Log LOG = LogFactory.getLog(ProcessInstance.class);
    private ProcessDefinition processDefinition;
    private Collection<ActivityState> activityStates = new HashSet<ActivityState>();
    private String correlationKey;
    private Date timeStarted;
    private Date timeCompleted;
    public ProcessInstance() {
        setTimeStarted(new Date());
    }
    public String toString() {
        return ""ProcessInstance["" + getCorrelationKey() + ""]"";
    }
    @Id
    public String getCorrelationKey() {
        return correlationKey;
    }
    public void setCorrelationKey(String correlationKey) {
        this.correlationKey = correlationKey;
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    @OneToMany(mappedBy = ""processInstance"", fetch = FetchType.LAZY, cascade = {CascadeType.ALL })
    public Collection<ActivityState> getActivityStates() {
        return activityStates;
    }
    public void setActivityStates(Collection<ActivityState> activityStates) {
        this.activityStates = activityStates;
    }
    @Transient
    public boolean isStarted() {
        return timeStarted != null;
    }
    @Transient
    public boolean isCompleted() {
        return timeCompleted != null;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeStarted() {
        return timeStarted;
    }
    public void setTimeStarted(Date timeStarted) {
        this.timeStarted = timeStarted;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeCompleted() {
        return timeCompleted;
    }
    public void setTimeCompleted(Date timeCompleted) {
        this.timeCompleted = timeCompleted;
    }    // Helper methods
    //-------------------------------------------------------------------------
    /**
     * Returns the activity state for the given activity
     *
     * @param activityRules the activity to find the state for
     * @return the activity state or null if no state could be found for the
     *         given activity
     */
    public ActivityState getActivityState(ActivityRules activityRules) {
        for (ActivityState activityState : getActivityStates()) {
            if (activityState.isActivity(activityRules)) {
                return activityState;
            }
        }
        return null;
    }
    public ActivityState getOrCreateActivityState(ActivityRules activityRules) {
        ActivityState state = getActivityState(activityRules);
        if (state == null) {
            state = createActivityState();
            state.setProcessInstance(this);
            state.setActivityDefinition(activityRules.getActivityDefinition());
            // we don't need to do: getTemplate().persist(state);
        }
        return state;
    }
    protected ActivityState createActivityState() {
        return new ActivityState();
    }
}
"
org.apache.camel.component.ResourceBasedEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Component;
import org.apache.camel.Processor;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
/**
 * A useful base class for endpoints which depend on a resource
 * such as things like Velocity or XQuery based components.
 *
 * @version $Revision$
 */
public abstract class ResourceBasedEndpoint extends ProcessorEndpoint {
    protected final transient Log log = LogFactory.getLog(getClass());
    private final String resourceUri;
    private ResourceLoader resourceLoader = new DefaultResourceLoader();
    private Resource resource;
    private boolean contentCache;
    private byte[] buffer;
    public ResourceBasedEndpoint(String endpointUri, Component component, String resourceUri, Processor processor) {
        super(endpointUri, component, processor);
        this.resourceUri = resourceUri;
    }
    protected ResourceBasedEndpoint(String endpointUri, Processor processor, String resourceUri) {
        super(endpointUri, processor);
        this.resourceUri = resourceUri;
    }
    public Resource getResource() {
        if (resource == null) {
            if (log.isDebugEnabled()) {
                log.debug(""Loading resource: "" + resourceUri + "" using: "" + getResourceLoader());
            }
            resource = getResourceLoader().getResource(resourceUri);
            if (resource == null) {
                throw new IllegalArgumentException(""Could not find resource for URI: "" + resourceUri + "" using: "" + getResourceLoader());
            }
        }
        return resource;
    }
    public boolean isContentCache() {
        return contentCache;
    }
    /**
     * Sets wether to use resource content cache or not - default is <tt>false</tt>.
     *
     * @see #getResourceAsInputStream()
     */
    public void setContentCache(boolean contentCache) {
        this.contentCache = contentCache;
    }
    /**
     * Gets the resource as an input stream considering the cache flag as well.
     * <p/>
     * If cache is enabled then the resource content is cached in an internal buffer and this content is
     * returned to avoid loading the resource over and over again.
     *
     * @return  the input stream
     * @throws IOException is thrown if error loading the content of the resource to the local cache buffer
     */
    public InputStream getResourceAsInputStream() throws IOException {
        if (resource == null) {
            // get the resource if not already done
            resource = getResource();
        }
        if (contentCache) {
            synchronized (resource) {
                if (buffer == null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Reading resource: "" + resourceUri + "" into the content cache"");
                    }
                    buffer = IOConverter.toBytes(resource.getInputStream());
                }
            }
            if (log.isDebugEnabled()) {
                log.debug(""Using resource: "" + resourceUri + "" from the content cache"");
            }
            return new ByteArrayInputStream(buffer);
        }
        return resource.getInputStream();
    }
    public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }
}"
org.apache.camel.converter.jaxb.JaxbDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.IOHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a> ({@link DataFormat})
 * using JAXB2 to marshal to and from XML
 *
 * @version $Revision$
 */
public class JaxbDataFormat implements DataFormat {
    private JAXBContext context;
    private String contextPath;
    private boolean prettyPrint = true;
    private Marshaller marshaller;
    private Unmarshaller unmarshaller;
    public JaxbDataFormat() {
    }
    public JaxbDataFormat(JAXBContext context) {
        this.context = context;
    }
    public JaxbDataFormat(String contextPath) {
        this.contextPath = contextPath;
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        try {
            getMarshaller().marshal(graph, stream);
        } catch (JAXBException e) {
            throw IOHelper.createIOException(e);
        }
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        try {
            return getUnmarshaller().unmarshal(stream);
        } catch (JAXBException e) {
            throw IOHelper.createIOException(e);
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public JAXBContext getContext() throws JAXBException {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(JAXBContext context) {
        this.context = context;
    }
    public String getContextPath() {
        return contextPath;
    }
    public void setContextPath(String contextPath) {
        this.contextPath = contextPath;
    }
    public Marshaller getMarshaller() throws JAXBException {
        if (marshaller == null) {
            marshaller = getContext().createMarshaller();
        }
        return marshaller;
    }
    public void setMarshaller(Marshaller marshaller) {
        this.marshaller = marshaller;
    }
    public boolean isPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    public Unmarshaller getUnmarshaller() throws JAXBException {
        if (unmarshaller == null) {
            unmarshaller = getContext().createUnmarshaller();
        }
        return unmarshaller;
    }
    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.unmarshaller = unmarshaller;
    }
    protected JAXBContext createContext() throws JAXBException {
        if (contextPath != null) {
            return JAXBContext.newInstance(contextPath);
        } else {
            return JAXBContext.newInstance();
        }
    }
}
"
org.apache.camel.converter.jaxb.StringHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""header"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class StringHeader extends HeaderType {
    @XmlAttribute(name = ""value"", required = true)
    private String text;
    public StringHeader() {
    }
    public StringHeader(String name, String text) {
        super(name);
        this.text = text;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    public Object getValue() {
        return getText();
    }
    public void setValue(Object value) {
        if (value instanceof String) {
            setText((String) value);
        } else {
            throw new IllegalArgumentException(""Value must be a String"");
        }
    }
}
"
org.apache.camel.bam.TimeExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.Date;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.TemporalRule;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.equal;
/**
 * @version $Revision$
 */
public abstract class TimeExpression {
    private ActivityRules activityRules;
    private ActivityBuilder builder;
    private ActivityLifecycle lifecycle;
    public TimeExpression(ActivityBuilder builder, ActivityLifecycle lifecycle) {
        this.lifecycle = lifecycle;
        this.builder = builder;
        this.activityRules = builder.getActivityRules();
    }
    public boolean isActivityLifecycle(ActivityRules activityRules, ActivityLifecycle lifecycle) {
        return equal(activityRules, this.activityRules) && equal(lifecycle, this.lifecycle);
    }
    /**
     * Creates a new temporal rule on this expression and the other expression
     */
    public TemporalRule after(TimeExpression expression) {
        TemporalRule rule = new TemporalRule(expression, this);
        rule.getSecond().getActivityRules().addRule(rule);
        return rule;
    }
    public Date evaluate(ProcessInstance processInstance) {
        ActivityState state = processInstance.getActivityState(activityRules);
        if (state != null) {
            return evaluate(processInstance, state);
        }
        return null;
    }
    public abstract Date evaluate(ProcessInstance instance, ActivityState state);
    // Properties
    //-------------------------------------------------------------------------
    public ActivityBuilder getBuilder() {
        return builder;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ActivityLifecycle getLifecycle() {
        return lifecycle;
    }
    public ActivityState getActivityState(ProcessInstance instance) {
        return instance.getActivityState(activityRules);
    }
    public ActivityState getOrCreateActivityState(ProcessInstance instance) {
        return instance.getOrCreateActivityState(activityRules);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.ScheduledPollEndpoint;
public abstract class RemoteFileEndpoint<T extends RemoteFileExchange> extends ScheduledPollEndpoint<T> {
    private RemoteFileBinding binding;
    private RemoteFileConfiguration configuration;
    public RemoteFileEndpoint(String uri, RemoteFileComponent component, RemoteFileConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
    }
    protected RemoteFileEndpoint(String endpointUri, RemoteFileConfiguration configuration) {
        super(endpointUri);
        this.configuration = configuration;
    }
    protected RemoteFileEndpoint(String endpointUri) {
        this(endpointUri, new RemoteFileConfiguration());
    }
    protected RemoteFileBinding createRemoteFileBinding() {
        return new RemoteFileBinding();
    }
    public T createExchange() {
        return (T) new RemoteFileExchange(getCamelContext(), getExchangePattern(), getBinding());
    }
    public T createExchange(ExchangePattern pattern) {
        return (T) new RemoteFileExchange(getCamelContext(), pattern, getBinding());
    }
    public T createExchange(String fullFileName, ByteArrayOutputStream outputStream) {
        return (T) new RemoteFileExchange(getCamelContext(), getExchangePattern(), getBinding(), getConfiguration().getHost(), fullFileName, outputStream);
    }
    public RemoteFileBinding getBinding() {
        if (binding == null) {
            binding = createRemoteFileBinding();
        }
        return binding;
    }
    public void setBinding(RemoteFileBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return true;
    }
    public RemoteFileConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
}
"
org.apache.camel.spring.spi.SpringConverters,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.Converter;
import org.apache.camel.component.bean.BeanInvocation;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
/**
 * Some Spring based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class SpringConverters {
    private SpringConverters() {        
    }
    @Converter
    public static InputStream toInputStream(Resource resource) throws IOException {
        return resource.getInputStream();
    }
    @Converter
    public static File toFile(Resource resource) throws IOException {
        return resource.getFile();
    }
    @Converter
    public static URL toUrl(Resource resource) throws IOException {
        return resource.getURL();
    }
    @Converter
    public static UrlResource toResource(String uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static UrlResource toResource(URL uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static FileSystemResource toResource(File file) throws IOException {
        return new FileSystemResource(file);
    }
    @Converter
    public static ByteArrayResource toResource(byte[] data) throws IOException {
        return new ByteArrayResource(data);
    }
    @Converter
    public static BeanInvocation toBeanInvocation(MethodInvocation invocation) {
        return new BeanInvocation(invocation.getMethod(), invocation.getArguments());
    }
}
"
org.apache.camel.component.file.remote.FtpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.file.FileComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPConnectionClosedException;
import org.apache.commons.net.ftp.FTPFile;
public class FtpConsumer extends RemoteFileConsumer<RemoteFileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FtpConsumer.class);
    private FtpEndpoint endpoint;
    private long lastPollTime;
    private FTPClient client;
    private boolean recursive = true;
    private String regexPattern;
    private boolean setNames = true;
    public FtpConsumer(FtpEndpoint endpoint, Processor processor, FTPClient client) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.client = client;
    }
    public FtpConsumer(FtpEndpoint endpoint, Processor processor, FTPClient client, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
        this.endpoint = endpoint;
        this.client = client;
    }
    protected void connectIfNecessary() throws IOException {
        // TODO: is there a way to avoid copy-pasting the reconnect logic?
        if (!client.isConnected()) {
            LOG.warn(""FtpConsumer's client isn't connected, trying to reconnect..."");
            endpoint.connect(client);
            LOG.info(""Connected to "" + endpoint.getConfiguration());
        }
    }
    protected void disconnect() throws IOException {
        LOG.info(""FtpConsumer's client is being explicitly disconnected"");
        endpoint.disconnect(client);
    }
    protected void poll() throws Exception {
        connectIfNecessary();
        // If the attempt to connect isn't successful, then the thrown
        // exception will signify that we couldn't poll
        try {
            final String fileName = endpoint.getConfiguration().getFile();
            if (endpoint.getConfiguration().isDirectory()) {
                pollDirectory(fileName);
            } else {
                client.changeWorkingDirectory(fileName.substring(0, fileName.lastIndexOf('/')));
                final FTPFile[] files = client.listFiles(fileName.substring(fileName.lastIndexOf('/') + 1));
                pollFile(files[0]);
            }
            lastPollTime = System.currentTimeMillis();
        } catch (FTPConnectionClosedException e) {
            // If the server disconnected us, then we must manually disconnect
            // the client before attempting to reconnect
            LOG.warn(""Disconnecting due to exception: "" + e.toString());
            disconnect();
            // Rethrow to signify that we didn't poll
            throw e;
        } catch (RuntimeCamelException e) {
            LOG.warn(""Caught RuntimeCamelException: "" + e.toString());
            LOG.warn(""Hoping an explicit disconnect/reconnect will solve the problem"");
            disconnect();
            // Rethrow to signify that we didn't poll
            throw e;
        }
    }
    protected void pollDirectory(String dir) throws Exception {
        client.changeWorkingDirectory(dir);
        for (FTPFile ftpFile : client.listFiles()) {
            if (ftpFile.isFile()) {
                pollFile(ftpFile);
            } else if (ftpFile.isDirectory()) {
                if (isRecursive()) {
                    pollDirectory(getFullFileName(ftpFile));
                }
            } else {
                // TODO: Type can be symbolic link etc. so what should we do?
                LOG.warn(""Unsupported type of FTPFile: "" + ftpFile + "" not a file or directory"");
            }
        }
    }
    protected String getFullFileName(FTPFile ftpFile) throws IOException {
        return client.printWorkingDirectory() + ""/"" + ftpFile.getName();
    }
    private void pollFile(FTPFile ftpFile) throws Exception {
        // TODO do we need to adjust the TZ? can we?
        if (ftpFile.getTimestamp().getTimeInMillis() > lastPollTime) {
            if (isMatched(ftpFile)) {
                String fullFileName = getFullFileName(ftpFile);
                final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                client.retrieveFile(ftpFile.getName(), byteArrayOutputStream);
                RemoteFileExchange exchange = endpoint.createExchange(fullFileName, byteArrayOutputStream);
                if (isSetNames()) {
                    // set the filename in the special header filename marker to the ftp filename
                    String ftpBasePath = endpoint.getConfiguration().getFile();
                    String relativePath = fullFileName.substring(ftpBasePath.length() + 1);
                    relativePath = relativePath.replaceFirst(""/"", """");
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Setting exchange filename to "" + relativePath);
                    }
                    exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
                }
                getProcessor().process(exchange);
            }
        }
    }
    protected boolean isMatched(FTPFile file) {
        boolean result = true;
        if (regexPattern != null && regexPattern.length() > 0) {
            result = file.getName().matches(regexPattern);
        }
        return result;
    }
    public boolean isRecursive() {
        return recursive;
    }
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    public long getLastPollTime() {
        return lastPollTime;
    }
    public void setLastPollTime(long lastPollTime) {
        this.lastPollTime = lastPollTime;
    }
    public String getRegexPattern() {
        return regexPattern;
    }
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isSetNames() {
        return setNames;
    }
    public void setSetNames(boolean setNames) {
        this.setNames = setNames;
    }
}
"
org.apache.camel.component.cxf.DataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
/**
 * The data format the user expects to see at the Camel CXF components.  It can be
 * configured as a property (DataFormat) in the Camel CXF endpoint.
 */
public enum DataFormat {
    /**
     * PAYLOAD is the message payload of the message after message configured in
     * the CXF endpoint is applied.  Streaming and non-streaming are both
     * supported.
     */
    PAYLOAD,
    /**
     * MESSAGE is the raw message that is received from the transport layer.
     * Streaming and non-streaming are both supported.
     */
    MESSAGE,
    /**
     * POJOs (Plain old Java objects) are the Java parameters to the method
     * it is invoking on the target server.  The ""serviceClass"" property
     * must be included in the endpoint.  Streaming is not available for this
     * data format.
     */
    POJO,
    /**
     * For UNKNOWN cases.
     */
    UNKNOWN;
    public static DataFormat asEnum(String value) {
        try {
            return valueOf(value.toUpperCase());
        } catch (Exception e) {
            return UNKNOWN;
        }
    }
}
"
org.apache.camel.builder.script.ScriptLanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.CamelContext;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
/**
 * @version $Revision$
 */
public class ScriptLanguageResolver implements LanguageResolver {
    public Language resolveLanguage(String name, CamelContext context) {
        return new ScriptLanguage(name);
    }
}
"
org.apache.camel.component.quartz.QuartzMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.quartz.JobExecutionContext;
import org.quartz.Trigger;
/**
 * @version $Revision$
 */
public class QuartzMessage extends DefaultMessage {
    private final JobExecutionContext jobExecutionContext;
    public QuartzMessage(QuartzExchange exchange, JobExecutionContext jobExecutionContext) {
        this.jobExecutionContext = jobExecutionContext;
        setExchange(exchange);
        if (jobExecutionContext != null) {
            setBody(jobExecutionContext.getJobDetail());
        }
    }
    public JobExecutionContext getJobExecutionContext() {
        return jobExecutionContext;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        super.populateInitialHeaders(map);
        if (jobExecutionContext != null) {
            map.put(""calendar"", jobExecutionContext.getCalendar());
            map.put(""fireTime"", jobExecutionContext.getFireTime());
            map.put(""jobDetail"", jobExecutionContext.getJobDetail());
            map.put(""jobInstance"", jobExecutionContext.getJobInstance());
            map.put(""jobRunTime"", jobExecutionContext.getJobRunTime());
            map.put(""mergedJobDataMap"", jobExecutionContext.getMergedJobDataMap());
            map.put(""nextFireTime"", jobExecutionContext.getNextFireTime());
            map.put(""previousFireTime"", jobExecutionContext.getPreviousFireTime());
            map.put(""refireCount"", jobExecutionContext.getRefireCount());
            map.put(""result"", jobExecutionContext.getResult());
            map.put(""scheduledFireTime"", jobExecutionContext.getScheduledFireTime());
            map.put(""scheduler"", jobExecutionContext.getScheduler());
            Trigger trigger = jobExecutionContext.getTrigger();
            map.put(""trigger"", trigger);
            map.put(""triggerName"", trigger.getName());
            map.put(""triggerGroup"", trigger.getGroup());
        }
    }
}
"
org.apache.camel.language.jxpath.JXPathLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.jxpath;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * <a href=""http://commons.apache.org/jxpath/"">JXPath</a> {@link Language}
 * provider
 */
public class JXPathLanguage implements Language {
    public Expression<Exchange> createExpression(String expression) {
        return new JXPathExpression(expression, Object.class);
    }
    public Predicate<Exchange> createPredicate(String predicate) {
        return new JXPathExpression(predicate, Boolean.class);
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultExchange;
/**
 * An {@link Exchange} for working with Spring Integration endpoints which exposes the underlying
 * Spring messages via {@link #getInMessage()} and {@link #getOutMessage()}
 *
 * @version $Revision$
 */
public class SpringIntegrationExchange  extends DefaultExchange {
    public SpringIntegrationExchange(CamelContext context) {
        super(context);
    }
    public SpringIntegrationExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    @Override
    public Exchange newInstance() {
        return new SpringIntegrationExchange(this.getContext());
    }
    @Override
    public SpringIntegrationMessage getIn() {
        return (SpringIntegrationMessage) super.getIn();
    }
    @Override
    public SpringIntegrationMessage getOut() {
        return (SpringIntegrationMessage) super.getOut();
    }
    @Override
    public SpringIntegrationMessage getOut(boolean lazyCreate) {
        return (SpringIntegrationMessage) super.getOut(lazyCreate);
    }
    @Override
    public SpringIntegrationMessage getFault() {
        return (SpringIntegrationMessage) super.getFault();
    }
    @Override
    protected Message createFaultMessage() {
        return new SpringIntegrationMessage();
    }
    @Override
    protected Message createInMessage() {
        return new SpringIntegrationMessage();
    }
    @Override
    protected Message createOutMessage() {
        return new SpringIntegrationMessage();
    }
}
"
org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import org.w3c.dom.Element;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.staxutils.StaxUtils;
public class PayloadContentRedirectInterceptor extends AbstractPhaseInterceptor<Message> {
    public PayloadContentRedirectInterceptor() {
        super(Phase.POST_STREAM);
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        // check the fault from the message
        Exception ex = message.getContent(Exception.class);
        if (ex != null) {
            if (ex instanceof Fault) {
                throw (Fault)ex;
            } else {
                throw new Fault(ex);
            }
        }
        XMLStreamWriter out = message.getContent(XMLStreamWriter.class);
        List<Element> in = message.get(List.class);
        try {
            for (Element el : in) {
                StaxUtils.writeElement(el, out, false, true);
            }
        } catch (XMLStreamException e) {
            throw new Fault(e);
        }
    }
}
"
org.apache.camel.spring.spi.SpringInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.spi.Injector;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.context.ConfigurableApplicationContext;
/**
 * A Spring implementation of {@link Injector} allowing Spring to be used to dependency inject newly created POJOs
 *
 * @version $Revision$
 */
public class SpringInjector implements Injector {
    private final ConfigurableApplicationContext applicationContext;
    private int autowireMode = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;
    private boolean dependencyCheck;
    public SpringInjector(ConfigurableApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public <T> T newInstance(Class<T> type) {
        // TODO support annotations for mandatory injection points?
        Object value = applicationContext.getBeanFactory().createBean(type, autowireMode, dependencyCheck);
        return type.cast(value);
    }
    public int getAutowireMode() {
        return autowireMode;
    }
    public void setAutowireMode(int autowireMode) {
        this.autowireMode = autowireMode;
    }
    public boolean isDependencyCheck() {
        return dependencyCheck;
    }
    public void setDependencyCheck(boolean dependencyCheck) {
        this.dependencyCheck = dependencyCheck;
    }
}
"
org.apache.camel.component.jms.JmsConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageProducer;
import javax.jms.QueueSender;
import javax.jms.Session;
import javax.jms.TopicPublisher;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.PackageHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.JmsException;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.SessionCallback;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer102;
import org.springframework.jms.listener.SimpleMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer102;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer102;
import org.springframework.jms.support.JmsUtils;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.util.Assert;
import static org.apache.camel.util.ObjectHelper.removeStartingCharacters;
/**
 * @version $Revision$
 */
public class JmsConfiguration implements Cloneable {
    public static final String QUEUE_PREFIX = ""queue:"";
    public static final String TOPIC_PREFIX = ""topic:"";
    public static final String TEMP_QUEUE_PREFIX = ""temp:queue:"";
    public static final String TEMP_TOPIC_PREFIX = ""temp:topic:"";
    protected static final String TRANSACTED = ""TRANSACTED"";
    protected static final String CLIENT_ACKNOWLEDGE = ""CLIENT_ACKNOWLEDGE"";
    protected static final String AUTO_ACKNOWLEDGE = ""AUTO_ACKNOWLEDGE"";
    protected static final String DUPS_OK_ACKNOWLEDGE = ""DUPS_OK_ACKNOWLEDGE"";
    protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_COMPONENT = ""component"";
    protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT = ""endpoint"";
    protected static final String REPLYTO_TEMP_DEST_AFFINITY_PER_PRODUCER = ""producer"";
    private static final transient Log LOG = LogFactory.getLog(JmsConfiguration.class);
    private JmsOperations jmsOperations;
    private DestinationResolver destinationResolver;
    private ConnectionFactory connectionFactory;
    private ConnectionFactory templateConnectionFactory;
    private ConnectionFactory listenerConnectionFactory;
    private int acknowledgementMode = -1;
    private String acknowledgementModeName;
    // Used to configure the spring Container
    private ExceptionListener exceptionListener;
    private ConsumerType consumerType = ConsumerType.Default;
    private boolean autoStartup = true;
    private boolean acceptMessagesWhileStopping;
    private String clientId;
    private String durableSubscriptionName;
    private boolean subscriptionDurable;
    private boolean exposeListenerSession = true;
    private TaskExecutor taskExecutor;
    private boolean pubSubNoLocal;
    private int concurrentConsumers = 1;
    private int maxMessagesPerTask = 1;
    private ServerSessionFactory serverSessionFactory;
    private int cacheLevel = -1;
    private String cacheLevelName;
    private long recoveryInterval = -1;
    private long receiveTimeout = -1;
    private long requestTimeout = 20000L;
    private int idleTaskExecutionLimit = 1;
    private int maxConcurrentConsumers = 1;
    // JmsTemplate only
    private boolean useVersion102;
    private Boolean explicitQosEnabled;
    private boolean deliveryPersistent = true;
    private boolean replyToDeliveryPersistent = true;
    private long timeToLive = -1;
    private MessageConverter messageConverter;
    private boolean messageIdEnabled = true;
    private boolean messageTimestampEnabled = true;
    private int priority = -1;
    // Transaction related configuration
    private boolean transacted;
    private PlatformTransactionManager transactionManager;
    private String transactionName;
    private int transactionTimeout = -1;
    private boolean preserveMessageQos;
    private long requestMapPurgePollTimeMillis = 1000L;
    private boolean disableReplyTo;
    private boolean eagerLoadingOfProperties;
    // Always make a JMS message copy when it's passed to Producer
    private boolean alwaysCopyMessage;
    private boolean useMessageIDAsCorrelationID;
    private JmsProviderMetadata providerMetadata = new JmsProviderMetadata();
    private JmsOperations metadataJmsOperations;
    // defines the component created temporary replyTo destination sharing strategy:
    // possible values are: ""component"", ""endpoint"", ""producer""
    // component - a single temp queue is shared among all producers for a given component instance
    // endpoint - a single temp queue is shared among all producers for a given endpoint instance
    // producer - a single temp queue is created per producer
    private String replyToTempDestinationAffinity = REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT;
    private String replyToDestination;
    private String replyToDestinationSelectorName;
    public JmsConfiguration() {
    }
    public JmsConfiguration(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    /**
     * Returns a copy of this configuration
     */
    public JmsConfiguration copy() {
        try {
            return (JmsConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public static interface MessageSentCallback {
        void sent(Message message);
    }
    public static class CamelJmsTemplate extends JmsTemplate {
        private JmsConfiguration config;
        public CamelJmsTemplate(JmsConfiguration config, ConnectionFactory connectionFactory) {
            super(connectionFactory);
            this.config = config;
        }
        public void send(final String destinationName,
                         final MessageCreator messageCreator,
                         final MessageSentCallback callback) throws JmsException {
            execute(new SessionCallback() {
                public Object doInJms(Session session) throws JMSException {
                    Destination destination = resolveDestinationName(session, destinationName);
                    Assert.notNull(messageCreator, ""MessageCreator must not be null"");
                    MessageProducer producer = createProducer(session, destination);
                    Message message = null;
                    try {
                        message = messageCreator.createMessage(session);
                        if (logger.isDebugEnabled()) {
                            logger.debug(""Sending created message: "" + message);
                        }
                        doSend(producer, message);
                        // Check commit - avoid commit call within a JTA transaction.
                        if (session.getTransacted() && isSessionLocallyTransacted(session)) {
                            // Transacted session created by this template -> commit.
                            JmsUtils.commitIfNecessary(session);
                        }
                    } finally {
                        JmsUtils.closeMessageProducer(producer);
                    }
                    if (message != null && callback != null) {
                        callback.sent(message);
                    }
                    return null;
                }
            }, false);
        }
        /**
         * Override so we can support preserving the Qos settings that have
         * been set on the message.
         */
        @Override
        protected void doSend(MessageProducer producer, Message message) throws JMSException {
            if (config.isPreserveMessageQos()) {
                long ttl = message.getJMSExpiration();
                if (ttl != 0) {
                    ttl = ttl - System.currentTimeMillis();
                    // Message had expired.. so set the ttl as small as
                    // possible
                    if (ttl <= 0) {
                        ttl = 1;
                    }
                }
                producer.send(message, message.getJMSDeliveryMode(), message.getJMSPriority(), ttl);
            } else {
                super.doSend(producer, message);
            }
        }
    }
    public static class CamelJmsTeemplate102 extends JmsTemplate102 {
        private JmsConfiguration config;
        public CamelJmsTeemplate102(JmsConfiguration config, ConnectionFactory connectionFactory, boolean pubSubDomain) {
            super(connectionFactory, pubSubDomain);
            this.config = config;
        }
        public void send(final String destinationName,
                final MessageCreator messageCreator,
                final MessageSentCallback callback) throws JmsException {
            execute(new SessionCallback() {
                public Object doInJms(Session session) throws JMSException {
                    Destination destination = resolveDestinationName(session, destinationName);
                    Assert.notNull(messageCreator, ""MessageCreator must not be null"");
                    MessageProducer producer = createProducer(session, destination);
                    Message message = null;
                    try {
                        message = messageCreator.createMessage(session);
                        if (logger.isDebugEnabled()) {
                            logger.debug(""Sending created message: "" + message);
                        }
                        doSend(producer, message);
                        // Check commit - avoid commit call within a JTA
                        // transaction.
                        if (session.getTransacted() && isSessionLocallyTransacted(session)) {
                            // Transacted session created by this template ->
                            // commit.
                            JmsUtils.commitIfNecessary(session);
                        }
                    } finally {
                        JmsUtils.closeMessageProducer(producer);
                    }
                    if (message != null && callback != null) {
                        callback.sent(message);
                    }
                    return null;
                }
            }, false);
        }
        /**
         * Override so we can support preserving the Qos settings that have
         * been set on the message.
         */
        @Override
        protected void doSend(MessageProducer producer, Message message) throws JMSException {
            if (config.isPreserveMessageQos()) {
                long ttl = message.getJMSExpiration();
                if (ttl != 0) {
                    ttl = ttl - System.currentTimeMillis();
                    // Message had expired.. so set the ttl as small as
                    // possible
                    if (ttl <= 0) {
                        ttl = 1;
                    }
                }
                if (isPubSubDomain()) {
                    ((TopicPublisher) producer).publish(message, message.getJMSDeliveryMode(),
                                                        message.getJMSPriority(), ttl);
                } else {
                    ((QueueSender) producer).send(message, message.getJMSDeliveryMode(),
                                                  message.getJMSPriority(), ttl);
                }
            } else {
                super.doSend(producer, message);
            }
        }
    }
    /**
     * Creates a {@link JmsOperations} object used for request/response using a request
     * timeout value
     */
    public JmsOperations createInOutTemplate(JmsEndpoint endpoint, boolean pubSubDomain, String destination, long requestTimeout) {
        JmsOperations answer = createInOnlyTemplate(endpoint, pubSubDomain, destination);
        if (answer instanceof JmsTemplate && requestTimeout > 0) {
            JmsTemplate jmsTemplate = (JmsTemplate)answer;
            jmsTemplate.setExplicitQosEnabled(true);
            jmsTemplate.setTimeToLive(requestTimeout);
        }
        return answer;
    }
    /**
     * Creates a {@link JmsOperations} object used for one way messaging
     */
    public JmsOperations createInOnlyTemplate(JmsEndpoint endpoint, boolean pubSubDomain, String destination) {
        if (jmsOperations != null) {
            return jmsOperations;
        }
        ConnectionFactory factory = getTemplateConnectionFactory();
        JmsTemplate template = useVersion102
            ? new CamelJmsTeemplate102(this, factory, pubSubDomain)
            : new CamelJmsTemplate(this, factory);
        template.setPubSubDomain(pubSubDomain);
        if (destinationResolver != null) {
            template.setDestinationResolver(destinationResolver);
            if (endpoint instanceof DestinationEndpoint) {
                LOG.debug(""You are overloading the destinationResolver property on a DestinationEndpoint; are you sure you want to do that?"");
            }
        } else if (endpoint instanceof DestinationEndpoint) {
            DestinationEndpoint destinationEndpoint = (DestinationEndpoint) endpoint;
            template.setDestinationResolver(createDestinationResolver(destinationEndpoint));
        }
        template.setDefaultDestinationName(destination);
        template.setExplicitQosEnabled(isExplicitQosEnabled());
        template.setDeliveryPersistent(deliveryPersistent);
        if (messageConverter != null) {
            template.setMessageConverter(messageConverter);
        }
        template.setMessageIdEnabled(messageIdEnabled);
        template.setMessageTimestampEnabled(messageTimestampEnabled);
        if (priority >= 0) {
            template.setPriority(priority);
        }
        template.setPubSubNoLocal(pubSubNoLocal);
        if (receiveTimeout >= 0) {
            template.setReceiveTimeout(receiveTimeout);
        }
        if (timeToLive >= 0) {
            template.setTimeToLive(timeToLive);
        }
        template.setSessionTransacted(transacted);
        if (transacted) {
            template.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        } else {
            // This is here for completeness, but the template should not get
            // used
            // for receiving messages.
            if (acknowledgementMode >= 0) {
                template.setSessionAcknowledgeMode(acknowledgementMode);
            } else if (acknowledgementModeName != null) {
                template.setSessionAcknowledgeModeName(acknowledgementModeName);
            }
        }
        return template;
    }
    public AbstractMessageListenerContainer createMessageListenerContainer(JmsEndpoint endpoint) {
        AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation();
        configureMessageListenerContainer(container, endpoint);
        return container;
    }
    // Properties
    // -------------------------------------------------------------------------
    public ConnectionFactory getConnectionFactory() {
        if (connectionFactory == null) {
            connectionFactory = createConnectionFactory();
        }
        return connectionFactory;
    }
    /**
     * Sets the default connection factory to be used if a connection factory is
     * not specified for either
     * {@link #setTemplateConnectionFactory(ConnectionFactory)} or
     * {@link #setListenerConnectionFactory(ConnectionFactory)}
     *
     * @param connectionFactory the default connection factory to use
     */
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    public ConnectionFactory getListenerConnectionFactory() {
        if (listenerConnectionFactory == null) {
            listenerConnectionFactory = createListenerConnectionFactory();
        }
        return listenerConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for consuming messages via the
     * {@link #createMessageListenerContainer(JmsEndpoint)}
     *
     * @param listenerConnectionFactory the connection factory to use for
     *                consuming messages
     */
    public void setListenerConnectionFactory(ConnectionFactory listenerConnectionFactory) {
        this.listenerConnectionFactory = listenerConnectionFactory;
    }
    public ConnectionFactory getTemplateConnectionFactory() {
        if (templateConnectionFactory == null) {
            templateConnectionFactory = createTemplateConnectionFactory();
        }
        return templateConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for sending messages via the
     * {@link JmsTemplate} via {@link #createInOnlyTemplate(JmsEndpoint,boolean, String)}
     *
     * @param templateConnectionFactory the connection factory for sending
     *                messages
     */
    public void setTemplateConnectionFactory(ConnectionFactory templateConnectionFactory) {
        this.templateConnectionFactory = templateConnectionFactory;
    }
    public boolean isUseVersion102() {
        return useVersion102;
    }
    public void setUseVersion102(boolean useVersion102) {
        this.useVersion102 = useVersion102;
    }
    public boolean isAutoStartup() {
        return autoStartup;
    }
    public void setAutoStartup(boolean autoStartup) {
        this.autoStartup = autoStartup;
    }
    public boolean isAcceptMessagesWhileStopping() {
        return acceptMessagesWhileStopping;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;
    }
    public String getClientId() {
        return clientId;
    }
    public void setClientId(String consumerClientId) {
        this.clientId = consumerClientId;
    }
    public String getDurableSubscriptionName() {
        return durableSubscriptionName;
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        this.durableSubscriptionName = durableSubscriptionName;
    }
    public ExceptionListener getExceptionListener() {
        return exceptionListener;
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        this.exceptionListener = exceptionListener;
    }
    public boolean isSubscriptionDurable() {
        return subscriptionDurable;
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        this.subscriptionDurable = subscriptionDurable;
    }
    public String getAcknowledgementModeName() {
        return acknowledgementModeName;
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        this.acknowledgementModeName = consumerAcknowledgementMode;
        this.acknowledgementMode = -1;
    }
    public boolean isExposeListenerSession() {
        return exposeListenerSession;
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        this.exposeListenerSession = exposeListenerSession;
    }
    public TaskExecutor getTaskExecutor() {
        return taskExecutor;
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }
    public boolean isPubSubNoLocal() {
        return pubSubNoLocal;
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        this.pubSubNoLocal = pubSubNoLocal;
    }
    public int getConcurrentConsumers() {
        return concurrentConsumers;
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        this.concurrentConsumers = concurrentConsumers;
    }
    public int getMaxMessagesPerTask() {
        return maxMessagesPerTask;
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        this.maxMessagesPerTask = maxMessagesPerTask;
    }
    public ServerSessionFactory getServerSessionFactory() {
        return serverSessionFactory;
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        this.serverSessionFactory = serverSessionFactory;
    }
    public int getCacheLevel() {
        return cacheLevel;
    }
    public void setCacheLevel(int cacheLevel) {
        this.cacheLevel = cacheLevel;
    }
    public String getCacheLevelName() {
        return cacheLevelName;
    }
    public void setCacheLevelName(String cacheName) {
        this.cacheLevelName = cacheName;
    }
    public long getRecoveryInterval() {
        return recoveryInterval;
    }
    public void setRecoveryInterval(long recoveryInterval) {
        this.recoveryInterval = recoveryInterval;
    }
    public long getReceiveTimeout() {
        return receiveTimeout;
    }
    public void setReceiveTimeout(long receiveTimeout) {
        this.receiveTimeout = receiveTimeout;
    }
    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    public String getTransactionName() {
        return transactionName;
    }
    public void setTransactionName(String transactionName) {
        this.transactionName = transactionName;
    }
    public int getTransactionTimeout() {
        return transactionTimeout;
    }
    public void setTransactionTimeout(int transactionTimeout) {
        this.transactionTimeout = transactionTimeout;
    }
    public int getIdleTaskExecutionLimit() {
        return idleTaskExecutionLimit;
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        this.idleTaskExecutionLimit = idleTaskExecutionLimit;
    }
    public int getMaxConcurrentConsumers() {
        return maxConcurrentConsumers;
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        this.maxConcurrentConsumers = maxConcurrentConsumers;
    }
    public boolean isExplicitQosEnabled() {
        return explicitQosEnabled != null ? explicitQosEnabled : false;
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        this.explicitQosEnabled = explicitQosEnabled;
    }
    public boolean isDeliveryPersistent() {
        return deliveryPersistent;
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        this.deliveryPersistent = deliveryPersistent;
        configuredQoS();
    }
    public boolean isReplyToDeliveryPersistent() {
        return replyToDeliveryPersistent;
    }
    public void setReplyToDeliveryPersistent(boolean replyToDeliveryPersistent) {
        this.replyToDeliveryPersistent = replyToDeliveryPersistent;
    }
    public long getTimeToLive() {
        return timeToLive;
    }
    public void setTimeToLive(long timeToLive) {
        this.timeToLive = timeToLive;
        configuredQoS();
    }
    public MessageConverter getMessageConverter() {
        return messageConverter;
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        this.messageConverter = messageConverter;
    }
    public boolean isMessageIdEnabled() {
        return messageIdEnabled;
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        this.messageIdEnabled = messageIdEnabled;
    }
    public boolean isMessageTimestampEnabled() {
        return messageTimestampEnabled;
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        this.messageTimestampEnabled = messageTimestampEnabled;
    }
    public int getPriority() {
        return priority;
    }
    public void setPriority(int priority) {
        this.priority = priority;
        configuredQoS();
    }
    public ConsumerType getConsumerType() {
        return consumerType;
    }
    public void setConsumerType(ConsumerType consumerType) {
        this.consumerType = consumerType;
    }
    public int getAcknowledgementMode() {
        return acknowledgementMode;
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        this.acknowledgementMode = consumerAcknowledgementMode;
        this.acknowledgementModeName = null;
    }
    public boolean isTransacted() {
        return transacted;
    }
    public void setTransacted(boolean consumerTransacted) {
        this.transacted = consumerTransacted;
    }
    public boolean isEagerLoadingOfProperties() {
        return eagerLoadingOfProperties;
    }
    /**
     * Enables eager loading of JMS properties as soon as a message is loaded
     * which generally is inefficient as the JMS properties may not be required
     * but sometimes can catch early any issues with the underlying JMS provider
     * and the use of JMS properties
     *
     * @param eagerLoadingOfProperties whether or not to enable eager loading of
     *                JMS properties on inbound messages
     */
    public void setEagerLoadingOfProperties(boolean eagerLoadingOfProperties) {
        this.eagerLoadingOfProperties = eagerLoadingOfProperties;
    }
    public boolean isDisableReplyTo() {
        return disableReplyTo;
    }
    /**
     * Disables the use of the JMSReplyTo header for consumers so that inbound
     * messages are treated as InOnly rather than InOut requests.
     *
     * @param disableReplyTo whether or not to disable the use of JMSReplyTo
     *                header indicating an InOut
     */
    public void setDisableReplyTo(boolean disableReplyTo) {
        this.disableReplyTo = disableReplyTo;
    }
    /**
     * Set to true if you want to send message using the QoS settings specified
     * on the message. Normally the QoS settings used are the one configured on
     * this Object.
     *
     * @param preserveMessageQos
     */
    public void setPreserveMessageQos(boolean preserveMessageQos) {
        this.preserveMessageQos = preserveMessageQos;
    }
    public JmsOperations getJmsOperations() {
        return jmsOperations;
    }
    public void setJmsOperations(JmsOperations jmsOperations) {
        this.jmsOperations = jmsOperations;
    }
    public DestinationResolver getDestinationResolver() {
        return destinationResolver;
    }
    public void setDestinationResolver(DestinationResolver destinationResolver) {
        this.destinationResolver = destinationResolver;
    }
    public long getRequestMapPurgePollTimeMillis() {
        return requestMapPurgePollTimeMillis;
    }
    /**
     * Sets the frequency that the requestMap for InOut exchanges is purged for
     * timed out message exchanges
     *
     * @param requestMapPurgePollTimeMillis
     */
    public void setRequestMapPurgePollTimeMillis(long requestMapPurgePollTimeMillis) {
        this.requestMapPurgePollTimeMillis = requestMapPurgePollTimeMillis;
    }
    public JmsProviderMetadata getProviderMetadata() {
        return providerMetadata;
    }
    /**
     * Allows the provider metadata to be explicitly configured. Typically this is not required
     * and Camel will auto-detect the provider metadata from the underlying provider.
     */
    public void setProviderMetadata(JmsProviderMetadata providerMetadata) {
        this.providerMetadata = providerMetadata;
    }
    public JmsOperations getMetadataJmsOperations(JmsEndpoint endpoint) {
        if (metadataJmsOperations == null) {
            metadataJmsOperations = getJmsOperations();
            if (metadataJmsOperations == null) {
                metadataJmsOperations = createInOnlyTemplate(endpoint, false, null);
            }
        }
        return metadataJmsOperations;
    }
    /**
     * Sets the {@link JmsOperations} used to deduce the {@link JmsProviderMetadata} details which if none
     * is customized one is lazily created on demand
     *
     * @param metadataJmsOperations
     */
    public void setMetadataJmsOperations(JmsOperations metadataJmsOperations) {
        this.metadataJmsOperations = metadataJmsOperations;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public static DestinationResolver createDestinationResolver(final DestinationEndpoint destinationEndpoint) {
        return new DestinationResolver() {
            public Destination resolveDestinationName(Session session, String destinationName, boolean pubSubDomain) throws JMSException {
                return destinationEndpoint.getJmsDestination(session);
            }
        };
    }
    protected void configureMessageListenerContainer(AbstractMessageListenerContainer container,
                                                     JmsEndpoint endpoint) {
        container.setConnectionFactory(getListenerConnectionFactory());
        if (endpoint instanceof DestinationEndpoint) {
            container.setDestinationResolver(createDestinationResolver((DestinationEndpoint) endpoint));
        } else if (destinationResolver != null) {
            container.setDestinationResolver(destinationResolver);
        }
        if (autoStartup) {
            container.setAutoStartup(true);
        }
        if (clientId != null) {
            container.setClientId(clientId);
        }
        container.setSubscriptionDurable(subscriptionDurable);
        if (durableSubscriptionName != null) {
            container.setDurableSubscriptionName(durableSubscriptionName);
        }
        // lets default to durable subscription if the subscriber name and
        // client ID are specified (as there's
        // no reason to specify them if not! :)
        if (durableSubscriptionName != null && clientId != null) {
            container.setSubscriptionDurable(true);
        }
        if (exceptionListener != null) {
            container.setExceptionListener(exceptionListener);
        }
        container.setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
        container.setExposeListenerSession(exposeListenerSession);
        container.setSessionTransacted(transacted);
        if (transacted) {
            container.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        } else {
            if (acknowledgementMode >= 0) {
                container.setSessionAcknowledgeMode(acknowledgementMode);
            } else if (acknowledgementModeName != null) {
                container.setSessionAcknowledgeModeName(acknowledgementModeName);
            }
        }
        if (endpoint.getSelector() != null && endpoint.getSelector().length() != 0) {
            container.setMessageSelector(endpoint.getSelector());
        }
        if (container instanceof DefaultMessageListenerContainer) {
            // this includes DefaultMessageListenerContainer102
            DefaultMessageListenerContainer listenerContainer = (DefaultMessageListenerContainer)container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            if (cacheLevel >= 0) {
                listenerContainer.setCacheLevel(cacheLevel);
            } else if (cacheLevelName != null) {
                listenerContainer.setCacheLevelName(cacheLevelName);
            } else {
                listenerContainer.setCacheLevel(defaultCacheLevel(endpoint));
            }
            if (idleTaskExecutionLimit >= 0) {
                listenerContainer.setIdleTaskExecutionLimit(idleTaskExecutionLimit);
            }
            if (maxConcurrentConsumers >= 0) {
                listenerContainer.setMaxConcurrentConsumers(maxConcurrentConsumers);
            }
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (receiveTimeout >= 0) {
                listenerContainer.setReceiveTimeout(receiveTimeout);
            }
            if (recoveryInterval >= 0) {
                listenerContainer.setRecoveryInterval(recoveryInterval);
            }
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
            PlatformTransactionManager tm = getTransactionManager();
            if (tm != null) {
                listenerContainer.setTransactionManager(tm);
            } else if (transacted) {
                throw new IllegalArgumentException(
                                                   ""Property transacted is enabled but a transactionManager was not injected!"");
            }
            if (transactionName != null) {
                listenerContainer.setTransactionName(transactionName);
            }
            if (transactionTimeout >= 0) {
                listenerContainer.setTransactionTimeout(transactionTimeout);
            }
        } else if (container instanceof ServerSessionMessageListenerContainer) {
            // this includes ServerSessionMessageListenerContainer102
            ServerSessionMessageListenerContainer listenerContainer = (ServerSessionMessageListenerContainer)container;
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            if (serverSessionFactory != null) {
                listenerContainer.setServerSessionFactory(serverSessionFactory);
            }
        } else if (container instanceof SimpleMessageListenerContainer) {
            // this includes SimpleMessageListenerContainer102
            SimpleMessageListenerContainer listenerContainer = (SimpleMessageListenerContainer)container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
        }
    }
    public void configure(EndpointMessageListener listener) {
        if (isDisableReplyTo()) {
            listener.setDisableReplyTo(true);
        }
        if (isEagerLoadingOfProperties()) {
            listener.setEagerLoadingOfProperties(true);
        }
        // REVISIT: We really ought to change the model and let JmsProducer
        // and JmsConsumer have their own JmsConfiguration instance
        // This way producer's and consumer's QoS can differ and be
        // independently configured
        JmsOperations operations = listener.getTemplate();
        if (operations instanceof JmsTemplate) {
            JmsTemplate template = (JmsTemplate)operations;
            template.setDeliveryPersistent(isReplyToDeliveryPersistent());
        }
    }
    public AbstractMessageListenerContainer chooseMessageListenerContainerImplementation() {
        // TODO we could allow a spring container to auto-inject these objects?
        switch (consumerType) {
        case Simple:
            return isUseVersion102()
                ? new SimpleMessageListenerContainer102() : new SimpleMessageListenerContainer();
        case ServerSessionPool:
            return isUseVersion102()
                ? new ServerSessionMessageListenerContainer102()
                : new ServerSessionMessageListenerContainer();
        case Default:
            return isUseVersion102()
                ? new DefaultMessageListenerContainer102() : new DefaultMessageListenerContainer();
        default:
            throw new IllegalArgumentException(""Unknown consumer type: "" + consumerType);
        }
    }
    /**
     * Defaults the JMS cache level if none is explicitly specified. Note that
     * due to this <a
     * href=""http://opensource.atlassian.com/projects/spring/browse/SPR-3890"">Spring
     * Bug</a> we cannot use CACHE_CONSUMER by default (which we should do as
     * its most efficient) unless the spring version is 2.5.1 or later. Instead
     * we use CACHE_CONNECTION - part from for non-durable topics which must use
     * CACHE_CONSUMER to avoid missing messages (due to the consumer being
     * created and destroyed per message).
     *
     * @param endpoint the endpoint
     * @return the cacne level
     */
    protected int defaultCacheLevel(JmsEndpoint endpoint) {
        // if we are on a new enough spring version we can assume CACHE_CONSUMER
        if (PackageHelper.isValidVersion(""org.springframework.jms"", 2.51D)) {
            return DefaultMessageListenerContainer.CACHE_CONSUMER;
        } else {
            if (endpoint.isPubSubDomain() && !isSubscriptionDurable()) {
                // we must cache the consumer or we will miss messages
                // see https://issues.apache.org/activemq/browse/CAMEL-253
                return DefaultMessageListenerContainer.CACHE_CONSUMER;
            } else {
                // to enable consuming and sending with a single JMS session (to
                // avoid XA) we can only use CACHE_CONNECTION
                // due to this bug :
                // http://opensource.atlassian.com/projects/spring/browse/SPR-3890
                return DefaultMessageListenerContainer.CACHE_CONNECTION;
            }
        }
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createConnectionFactory() {
        ObjectHelper.notNull(connectionFactory, ""connectionFactory"");
        return null;
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createListenerConnectionFactory() {
        return getConnectionFactory();
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createTemplateConnectionFactory() {
        return getConnectionFactory();
    }
    public boolean isPreserveMessageQos() {
        return preserveMessageQos;
    }
    /**
     * When one of the QoS properties are configured such as {@link #setDeliveryPersistent(boolean)},
     * {@link #setPriority(int)} or {@link #setTimeToLive(long)} then we should auto default the
     * setting of {@link #setExplicitQosEnabled(boolean)} if its not been configured yet
     */
    protected void configuredQoS() {
        if (explicitQosEnabled == null) {
            explicitQosEnabled = true;
        }
    }
    public boolean isAlwaysCopyMessage() {
        return alwaysCopyMessage;
    }
    public void setAlwaysCopyMessage(boolean alwaysCopyMessage) {
        this.alwaysCopyMessage = alwaysCopyMessage;
    }
    public boolean isUseMessageIDAsCorrelationID() {
        return useMessageIDAsCorrelationID;
    }
    public void setUseMessageIDAsCorrelationID(boolean useMessageIDAsCorrelationID) {
        this.useMessageIDAsCorrelationID = useMessageIDAsCorrelationID;
    }
    public String getReplyToTempDestinationAffinity() {
        return replyToTempDestinationAffinity;
    }
    public void setReplyToTempDestinationAffinity(
            String replyToTempDestinationAffinity) {
        this.replyToTempDestinationAffinity = replyToTempDestinationAffinity;
    }
    public long getRequestTimeout() {
        return requestTimeout;
    }
    public void setRequestTimeout(long requestTimeout) {
        this.requestTimeout = requestTimeout;
    }
    public String getReplyTo() {
        return replyToDestination;
    }
    public void setReplyTo(String replyToDestination) {
        if (!replyToDestination.startsWith(QUEUE_PREFIX)) {
            throw new IllegalArgumentException(""ReplyTo destination value has to be of type queue; ""
                                              + ""e.g: \""queue:replyQueue\"""");
        }
        this.replyToDestination =
            removeStartingCharacters(replyToDestination.substring(QUEUE_PREFIX.length()), '/');
    }
    public String getReplyToDestinationSelectorName() {
        return replyToDestinationSelectorName;
    }
    public void setReplyToDestinationSelectorName(String replyToDestinationSelectorName) {
        this.replyToDestinationSelectorName = replyToDestinationSelectorName;
        // in case of consumer -> producer and a named replyTo correlation selector
        // message passthough is impossible as we need to set the value of selector into
        // outgoing message, which would be read-only if passthough were to remain enabled
        if (replyToDestinationSelectorName != null) {
            setAlwaysCopyMessage(true);
        }
    }
}
"
org.apache.camel.component.test.TestEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.test;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.EndpointHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A <a href=""http://activemq.apache.org/camel/test.html"">Test Endpoint</a> is a
 * <a href=""http://activemq.apache.org/camel/mock.html"">Mock Endpoint</a> for testing but it will
 * pull all messages from the nested endpoint and use those as expected message body assertions.
 *
 * @version $Revision$
 */
public class TestEndpoint extends MockEndpoint implements Service {
    private static final transient Log LOG = LogFactory.getLog(TestEndpoint.class);
    private final Endpoint expectedMessageEndpoint;
    private long timeout = 2000L;
    public TestEndpoint(String endpointUri, Component component, Endpoint expectedMessageEndpoint) {
        super(endpointUri, component);
        this.expectedMessageEndpoint = expectedMessageEndpoint;
    }
    public TestEndpoint(String endpointUri, Endpoint expectedMessageEndpoint) {
        super(endpointUri);
        this.expectedMessageEndpoint = expectedMessageEndpoint;
    }
    public void start() throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Consuming expected messages from: "" + expectedMessageEndpoint);
        }
        final List expectedBodies = new ArrayList();
        EndpointHelper.pollEndpoint(expectedMessageEndpoint, new Processor() {
            public void process(Exchange exchange) throws Exception {
                Object body = getInBody(exchange);
                expectedBodies.add(body);
            }
        }, timeout);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Received: "" + expectedBodies.size() + "" expected message(s) from: "" + expectedMessageEndpoint);
        }
        expectedBodiesReceived(expectedBodies);
    }
    public void stop() throws Exception {
    }
    /**
     * This method allows us to convert or coerce the expected message body into some other type
     */
    protected Object getInBody(Exchange exchange) {
        return exchange.getIn().getBody();
    }
}
"
org.apache.camel.component.jhc.JhcServerEngineFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.util.HashMap;
import java.util.Map;
import org.apache.http.params.HttpParams;
public final class JhcServerEngineFactory {
    private static Map<Integer, JhcServerEngine> portMap = new HashMap<Integer, JhcServerEngine>();
    private JhcServerEngineFactory() {
        //Utility Class
    }
    public static synchronized JhcServerEngine getJhcServerEngine(final HttpParams params, final int port, final String protocol) {
        JhcServerEngine engine = portMap.get(port);
        // check the engine parament
        if (engine == null) {
            engine = new JhcServerEngine(params, port, protocol.trim());
            portMap.put(port, engine);
        } else {
            if (!engine.getProtocol().equals(protocol.trim())) {
                throw new IllegalArgumentException(""Jhc protocol error, the engine's protocol is ""
                                                   + engine.getProtocol() + "" you want is "" + protocol);
            }
        }
        return engine;
    }
}
"
org.apache.camel.builder.script.ScriptLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * @version $Revision$
 */
public class ScriptLanguage implements Language {
    private final String language;
    public ScriptLanguage(String language) {
        this.language = language;
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return new ScriptBuilder(language, expression);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new ScriptBuilder(language, expression);
    }
}
"
org.apache.camel.component.http.HttpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.net.URI;
import java.net.URISyntaxException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultPollingEndpoint;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpConnectionManager;
import org.apache.commons.httpclient.params.HttpClientParams;
/**
 * Represents a <a href=""http://activemq.apache.org/camel/http.html"">HTTP
 * endpoint</a>
 *
 * @version $Revision$
 */
public class HttpEndpoint extends DefaultPollingEndpoint<HttpExchange> {
    private HttpBinding binding;
    private HttpComponent component;
    private URI httpUri;
    private HttpClientParams clientParams;
    private HttpClientConfigurer httpClientConfigurer;
    private HttpConnectionManager httpConnectionManager;
    public HttpEndpoint(String endPointURI, HttpComponent component, URI httpURI, HttpConnectionManager httpConnectionManager) throws URISyntaxException {
        this(endPointURI, component, httpURI, new HttpClientParams(), httpConnectionManager, null);
    }
    public HttpEndpoint(String endPointURI, HttpComponent component, URI httpURI, HttpClientParams clientParams,
                        HttpConnectionManager httpConnectionManager, HttpClientConfigurer clientConfigurer) throws URISyntaxException {
        super(endPointURI, component);
        this.component = component;
        this.httpUri = httpURI;
        this.clientParams = clientParams;
        this.httpClientConfigurer = clientConfigurer;
        this.httpConnectionManager = httpConnectionManager;
    }
    public Producer<HttpExchange> createProducer() throws Exception {
        return new HttpProducer(this);
    }
    @Override
    public PollingConsumer<HttpExchange> createPollingConsumer() throws Exception {
        return new HttpPollingConsumer(this);
    }
    public HttpExchange createExchange(ExchangePattern pattern) {
        return new HttpExchange(this, pattern);
    }
    public HttpExchange createExchange(HttpServletRequest request, HttpServletResponse response) {
        return new HttpExchange(this, request, response);
    }
    /**
     * Factory method used by producers and consumers to create a new {@link HttpClient} instance
     */
    public HttpClient createHttpClient() {
        HttpClient answer = new HttpClient(getClientParams());
        answer.setHttpConnectionManager(httpConnectionManager);
        HttpClientConfigurer configurer = getHttpClientConfigurer();
        if (configurer != null) {
            configurer.configureHttpClient(answer);
        }
        return answer;
    }
    public void connect(HttpConsumer consumer) throws Exception {
        component.connect(consumer);
    }
    public void disconnect(HttpConsumer consumer) throws Exception {
        component.disconnect(consumer);
    }
    // Properties
    //-------------------------------------------------------------------------
    /**
     * Provide access to the client parameters used on new {@link HttpClient} instances
     * used by producers or consumers of this endpoint.
     */
    public HttpClientParams getClientParams() {
        return clientParams;
    }
    /**
     * Provide access to the client parameters used on new {@link HttpClient} instances
     * used by producers or consumers of this endpoint.
     *
     * @param clientParams
     */
    public void setClientParams(HttpClientParams clientParams) {
        this.clientParams = clientParams;
    }
    public HttpClientConfigurer getHttpClientConfigurer() {
        return httpClientConfigurer;
    }
    /**
     * Register a custom configuration strategy for new {@link HttpClient} instances
     * created by producers or consumers such as to configure authentication mechanisms etc
     *
     * @param httpClientConfigurer the strategy for configuring new {@link HttpClient} instances
     */
    public void setHttpClientConfigurer(HttpClientConfigurer httpClientConfigurer) {
        this.httpClientConfigurer = httpClientConfigurer;
    }
    public HttpBinding getBinding() {
        if (binding == null) {
            binding = new HttpBinding();
        }
        return binding;
    }
    public void setBinding(HttpBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return true;
    }
    public String getPath() {
        return httpUri.getPath();
    }
    public int getPort() {
        if (httpUri.getPort() == -1) {
            if (""https"".equals(getProtocol())) {
                return 443;
            } else {
                return 80;
            }
        }
        return httpUri.getPort();
    }
    public String getProtocol() {
        return httpUri.getScheme();
    }
    public URI getHttpUri() {
        return httpUri;
    }
}
"
org.apache.camel.component.jhc.AsyncResponseHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.http.HttpException;
import org.apache.http.HttpResponse;
public interface AsyncResponseHandler {
    void sendResponse(HttpResponse response) throws IOException, HttpException;
}
"
org.apache.camel.component.cxf.transport.spring.CamelDestinationDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.apache.camel.component.cxf.transport.CamelDestination;
public class CamelDestinationDefinitionParser extends AbstractCamelContextBeanDefinitionParser {
    public CamelDestinationDefinitionParser() {
        super();
        setBeanClass(CamelDestination.class);
    }
}
"
org.apache.camel.component.sql.SqlEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.sql;
import java.util.Map;
import javax.sql.DataSource;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.util.IntrospectionSupport;
import org.springframework.jdbc.core.JdbcTemplate;
/**
 * SQL Endpoint. Endpoint URI should contain valid SQL statement, but instead of
 * question marks (that are parameter placeholders), sharp signs should be used.
 * This is because in camel question mark has other meaning.
 *
 * @author romkal
 */
public class SqlEndpoint extends DefaultEndpoint {
    private JdbcTemplate jdbcTemplate;
    private String query;
    public SqlEndpoint(String uri, String query, Component component, DataSource dataSource, Map parameters) throws Exception {
        super(uri, component);
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        IntrospectionSupport.setProperties(jdbcTemplate, parameters, ""template."");
        this.query = query;
    }
    public SqlEndpoint(String endpointUri, JdbcTemplate jdbcTemplate, String query) {
        super(endpointUri);
        this.jdbcTemplate = jdbcTemplate;
        this.query = query;
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        throw new UnsupportedOperationException(""Not yet implemented"");
    }
    public Producer createProducer() throws Exception {
        return new SqlProducer(this, query, jdbcTemplate);
    }
    public boolean isSingleton() {
        return false;
    }
}
"
org.apache.camel.component.jms.RuntimeJmsException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class RuntimeJmsException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeJmsException(String message, JMSException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.cxf.transport.spring.AbstractCamelContextBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.configuration.spring.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
public class AbstractCamelContextBeanDefinitionParser extends AbstractBeanDefinitionParser {
    private static final String DEFAULT_CAMEL_CONTEXT_NAME = ""camelContext"";
    private String getContextId(String contextId) {
        if (ObjectHelper.isNullOrBlank(contextId)) {
            //Set the contextId default value here
            return DEFAULT_CAMEL_CONTEXT_NAME;
        } else {
            return contextId;
        }
    }
    protected void wireCamelContext(BeanDefinitionBuilder bean, String camelContextId) {
        bean.addPropertyReference(""camelContext"", camelContextId);
    }
    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        // Parser the id attribute
        bean.setAbstract(true);
        NodeList children = element.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType() == Node.ELEMENT_NODE) {
                String name = n.getLocalName();
                if (""camelContext"".equals(name)) {
                    // Parser the camel context
                    BeanDefinition bd = ctx.getDelegate().parseCustomElement((Element)n);
                    // Get the inner camel context id
                    String contextId = (String)bd.getPropertyValues().getPropertyValue(""id"").getValue();
                    wireCamelContext(bean, getContextId(contextId));
                } else if (""camelContextRef"".equals(name)) {
                    String contextId = n.getTextContent();
                    wireCamelContext(bean, getContextId(contextId));
                }
            }
        }
    }
}
"
org.apache.camel.spring.handler.CamelNamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.xml.bind.Binder;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.builder.xml.Namespaces;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy;
import org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy;
import org.apache.camel.spi.NamespaceAware;
import org.apache.camel.spring.CamelBeanPostProcessor;
import org.apache.camel.spring.CamelContextFactoryBean;
import org.apache.camel.spring.CamelJMXAgentType;
import org.apache.camel.spring.CamelTemplateFactoryBean;
import org.apache.camel.spring.EndpointFactoryBean;
import org.apache.camel.spring.remoting.CamelProxyFactoryBean;
import org.apache.camel.spring.remoting.CamelServiceExporter;
import org.apache.camel.util.ObjectHelper;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.parsing.BeanComponentDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
import org.springframework.beans.factory.xml.ParserContext;
/**
 * Camel namespace for the spring XML configuration file.
 */
public class CamelNamespaceHandler extends NamespaceHandlerSupport {
    protected BeanDefinitionParser endpointParser = new BeanDefinitionParser(EndpointFactoryBean.class);
    protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser(CamelBeanPostProcessor.class);
    protected Set<String> parserElementNames = new HashSet<String>();
    private JAXBContext jaxbContext;
    private Map<String, BeanDefinitionParser> parserMap = new HashMap<String, BeanDefinitionParser>();
    private Binder<Node> binder;
    public void init() {
        // remoting
        addBeanDefinitionParser(""proxy"", CamelProxyFactoryBean.class);
        addBeanDefinitionParser(""template"", CamelTemplateFactoryBean.class);
        addBeanDefinitionParser(""export"", CamelServiceExporter.class);
        // data types
        addBeanDefinitionParser(""artixDS"", ArtixDSDataFormat.class);
        addBeanDefinitionParser(""jaxb"", JaxbDataFormat.class);
        addBeanDefinitionParser(""serialization"", SerializationDataFormat.class);
        addBeanDefinitionParser(""xmlBeans"", XMLBeansDataFormat.class);
        // load balancers
        addBeanDefinitionParser(""roundRobin"", RoundRobinLoadBalanceStrategy.class);
        addBeanDefinitionParser(""random"", RandomLoadBalanceStrategy.class);
        addBeanDefinitionParser(""sticky"", StickyLoadBalanceStrategy.class);
        addBeanDefinitionParser(""topic"", TopicLoadBalanceStrategy.class);
        // jmx agent
        addBeanDefinitionParser(""jmxAgent"", CamelJMXAgentType.class);
        // TODO switch to use the above mechanism?
        registerParser(""endpoint"", endpointParser);
        Class cl = CamelContextFactoryBean.class;
        try {
            cl = Class.forName(""org.apache.camel.osgi.CamelContextFactoryBean"");
        } catch (Throwable t) {
        }
        registerParser(""camelContext"", new CamelContextBeanDefinitionParser(cl));
    }
    private void addBeanDefinitionParser(String elementName, Class<?> type) {
        BeanDefinitionParser parser = new BeanDefinitionParser(type);
        registerParser(elementName, parser);
        parserMap.put(elementName, parser);
    }
    protected void createBeanPostProcessor(ParserContext parserContext, String contextId, Element childElement, BeanDefinitionBuilder parentBuilder) {
        String beanPostProcessorId = contextId + "":beanPostProcessor"";
        childElement.setAttribute(""id"", beanPostProcessorId);
        BeanDefinition definition = beanPostProcessorParser.parse(childElement, parserContext);
        definition.getPropertyValues().addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
        parentBuilder.addPropertyReference(""beanPostProcessor"", beanPostProcessorId);
    }
    protected void registerScriptParser(String elementName, String engineName) {
        registerParser(elementName, new ScriptDefinitionParser(engineName));
    }
    protected void registerParser(String name,
                                  org.springframework.beans.factory.xml.BeanDefinitionParser parser) {
        parserElementNames.add(name);
        registerBeanDefinitionParser(name, parser);
    }
    public Set<String> getParserElementNames() {
        return parserElementNames;
    }
    protected Object parseUsingJaxb(Element element, ParserContext parserContext) {
        try {
            binder = getJaxbContext().createBinder();
            return binder.unmarshal(element);
            /*
             * Unmarshaller unmarshaller =
             * getJaxbContext().createUnmarshaller(); return
             * unmarshaller.unmarshal(element);
             */
        } catch (JAXBException e) {
            throw new BeanDefinitionStoreException(""Failed to parse JAXB element: "" + e, e);
        }
    }
    protected JAXBContext getJaxbContext() throws JAXBException {
        if (jaxbContext == null) {
            jaxbContext = createJaxbContext();
        }
        return jaxbContext;
    }
    protected JAXBContext createJaxbContext() throws JAXBException {
        StringBuilder packages = new StringBuilder();
        for (Class cl : getJaxbPackages()) {
            if (packages.length() > 0) {
                packages.append("":"");
            }
            packages.append(cl.getName().substring(0, cl.getName().lastIndexOf('.')));
        }
        return JAXBContext.newInstance(packages.toString(), getClass().getClassLoader());
    }
    protected Set<Class> getJaxbPackages() {
        Set<Class> classes = new HashSet<Class>();
        classes.add(org.apache.camel.spring.CamelContextFactoryBean.class);
        classes.add(org.apache.camel.model.RouteType.class);
        classes.add(org.apache.camel.model.config.StreamResequencerConfig.class);
        classes.add(org.apache.camel.model.dataformat.DataFormatType.class);
        classes.add(org.apache.camel.model.language.ExpressionType.class);
        classes.add(org.apache.camel.model.loadbalancer.LoadBalancerType.class);
        return classes;
    }
    protected class CamelContextBeanDefinitionParser extends BeanDefinitionParser {
        public CamelContextBeanDefinitionParser(Class type) {
            super(type);
        }
        @Override
        protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
            super.doParse(element, parserContext, builder);
            String contextId = element.getAttribute(""id"");
            // lets avoid folks having to explicitly give an ID to a camel
            // context
            if (ObjectHelper.isNullOrBlank(contextId)) {
                contextId = ""camelContext"";
                element.setAttribute(""id"", contextId);
            }
            // now lets parse the routes
            Object value = parseUsingJaxb(element, parserContext);
            if (value instanceof CamelContextFactoryBean) {
                CamelContextFactoryBean factoryBean = (CamelContextFactoryBean)value;
                builder.addPropertyValue(""id"", contextId);
                builder.addPropertyValue(""routes"", factoryBean.getRoutes());
                builder.addPropertyValue(""builderRefs"", factoryBean.getBuilderRefs());
                if (factoryBean.getPackages().length > 0) {
                    builder.addPropertyValue(""packages"", factoryBean.getPackages());
                }
            }
            boolean createdBeanPostProcessor = false;
            NodeList list = element.getChildNodes();
            int size = list.getLength();
            for (int i = 0; i < size; i++) {
                Node child = list.item(i);
                if (child instanceof Element) {
                    Element childElement = (Element)child;
                    String localName = child.getLocalName();
                    if (localName.equals(""beanPostProcessor"")) {
                        createBeanPostProcessor(parserContext, contextId, childElement, builder);
                        createdBeanPostProcessor = true;
                    } else if (localName.equals(""endpoint"")) {
                        BeanDefinition definition = endpointParser.parse(childElement, parserContext);
                        String id = childElement.getAttribute(""id"");
                        if (ObjectHelper.isNotNullAndNonEmpty(id)) {
                            // TODO we can zap this?
                            definition.getPropertyValues()
                                .addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
                            // definition.getPropertyValues().addPropertyValue(""context"",
                            // builder.getBeanDefinition());
                            parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                        }
                    } else {
                        BeanDefinitionParser parser = parserMap.get(localName);
                        if (parser != null) {
                            BeanDefinition definition = parser.parse(childElement, parserContext);
                            String id = childElement.getAttribute(""id"");
                            if (ObjectHelper.isNotNullAndNonEmpty(id)) {
                                parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                                if (localName.equals(""jmxAgent"")) {
                                    builder.addPropertyReference(""camelJMXAgent"", id);
                                }
                            }
                        }
                    }
                }
            }
            // lets inject the namespaces into any namespace aware POJOs
            injectNamespaces(element);
            if (!createdBeanPostProcessor) {
                // no bean processor element so lets create it by ourself
                Element childElement = element.getOwnerDocument().createElement(""beanPostProcessor"");
                element.appendChild(childElement);
                createBeanPostProcessor(parserContext, contextId, childElement, builder);
            }
        }
    }
    protected void injectNamespaces(Element element) {
        NodeList list = element.getChildNodes();
        Namespaces namespaces = null;
        int size = list.getLength();
        for (int i = 0; i < size; i++) {
            Node child = list.item(i);
            if (child instanceof Element) {
                Element childElement = (Element)child;
                Object object = binder.getJAXBNode(child);
                if (object instanceof NamespaceAware) {
                    NamespaceAware namespaceAware = (NamespaceAware)object;
                    if (namespaces == null) {
                        namespaces = new Namespaces(element);
                    }
                    namespaces.configure(namespaceAware);
                }
                injectNamespaces(childElement);
            }
        }
    }
}
"
org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.spring;
import java.util.Map;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.apache.cxf.common.util.StringUtils;
import org.apache.cxf.configuration.spring.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
public class CxfEndpointBeanDefinitionParser extends AbstractBeanDefinitionParser {
    @Override
    protected Class getBeanClass(Element arg0) {
        return CxfEndpointBean.class;
    }
    @Override
    protected void mapAttribute(BeanDefinitionBuilder bean, Element e, String name, String val) {
        if (""endpointName"".equals(name) || ""serviceName"".equals(name)) {
            QName q = parseQName(e, val);
            bean.addPropertyValue(name, q);
        } else {
            mapToProperty(bean, name, val);
        }
    }
    @Override
    protected void mapElement(ParserContext ctx, BeanDefinitionBuilder bean, Element el, String name) {
        if (""properties"".equals(name)) {
            Map map = ctx.getDelegate().parseMapElement(el, bean.getBeanDefinition());
            bean.addPropertyValue(""properties"", map);
        } else if (""binding"".equals(name)) {
            setFirstChildAsProperty(el, ctx, bean, ""bindingConfig"");
        } else if (""inInterceptors"".equals(name) || ""inFaultInterceptors"".equals(name)
            || ""outInterceptors"".equals(name) || ""outFaultInterceptors"".equals(name)
            || ""features"".equals(name) || ""schemaLocations"".equals(name)) {
            java.util.List list = (java.util.List)ctx.getDelegate().parseListElement(el, bean.getBeanDefinition());
            bean.addPropertyValue(name, list);
        } else {
            setFirstChildAsProperty(el, ctx, bean, name);
        }
    }
    @Override
    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        super.doParse(element, ctx, bean);
        bean.setLazyInit(false);
    }
    @Override
    protected String resolveId(Element elem,
                               AbstractBeanDefinition definition,
                               ParserContext ctx)
        throws BeanDefinitionStoreException {
        String id = super.resolveId(elem, definition, ctx);
        if (StringUtils.isEmpty(id)) {
            throw new BeanDefinitionStoreException(""The bean id is needed."");
        }
        return id;
    }
    @Override
    protected boolean hasBusProperty() {
        return true;
    }
}
"
org.apache.camel.bam.ActivityLifecycle,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
/**
 * @version $Revision$
 */
public enum ActivityLifecycle {
    Started, Completed
}
"
org.apache.camel.spring.handler.LazyLoadingBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link BeanDefinitionParser} which lazy loads the type on which it creates to allow the schema to be loosly coupled
 * with the camel jars.
 *
 * @version $Revision$
 */
public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser {
    private String className;
    private String moduleName;
    public LazyLoadingBeanDefinitionParser(String className, String moduleName) {
        this.className = className;
        this.moduleName = moduleName;
    }
    @Override
    protected Class loadType() {
        Class<?> answer = ObjectHelper.loadClass(className, getClass().getClassLoader());
        if (answer == null) {
            throw new IllegalArgumentException(""Class: "" + className + "" could not be found. You need to add Camel module: "" + moduleName + "" to your classpath"");
        }
        return answer;
    }
}
"
org.apache.camel.component.cxf.transport.spring.CamelConduitDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport.spring;
import org.apache.camel.component.cxf.transport.CamelConduit;
public class CamelConduitDefinitionParser extends AbstractCamelContextBeanDefinitionParser {
    public CamelConduitDefinitionParser() {
        super();
        setBeanClass(CamelConduit.class);
    }
}
"
org.apache.camel.component.cxf.CxfEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.cxf.configuration.spring.ConfigurerImpl;
import org.apache.cxf.message.Message;
import org.springframework.context.ApplicationContext;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Endpoint</a>
 *
 * @version $Revision$
 */
public class CxfEndpoint extends DefaultEndpoint<CxfExchange> {
    private final CxfComponent component;
    private final String address;
    private String wsdlURL;
    private String serviceClass;
    private String portName;
    private String serviceName;
    private String dataFormat;
    private String beanId;
    private boolean isWrapped;
    private boolean isSpringContextEndpoint;
    private boolean inOut = true;
    private Boolean isSetDefaultBus;
    private ConfigurerImpl configurer;
    private CxfEndpointBean cxfEndpointBean;
    public CxfEndpoint(String uri, String address, CxfComponent component) {
        super(uri, component);
        this.component = component;
        this.address = address;
        if (address.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {
            isSpringContextEndpoint = true;
            // Get the bean from the Spring context
            beanId = address.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());
            if (beanId.startsWith(""//"")) {
                beanId = beanId.substring(2);
            }
            SpringCamelContext context = (SpringCamelContext) this.getCamelContext();
            configurer = new ConfigurerImpl(context.getApplicationContext());
            cxfEndpointBean = (CxfEndpointBean) context.getApplicationContext().getBean(beanId);
            assert cxfEndpointBean != null;
        }
    }
    public Producer<CxfExchange> createProducer() throws Exception {
        return new CxfProducer(this);
    }
    public Consumer<CxfExchange> createConsumer(Processor processor) throws Exception {
        return new CxfConsumer(this, processor);
    }
    public CxfExchange createExchange() {
        return new CxfExchange(getCamelContext(), getExchangePattern());
    }
    public CxfExchange createExchange(ExchangePattern pattern) {
        return new CxfExchange(getCamelContext(), pattern);
    }
    public CxfExchange createExchange(Message inMessage) {
        return new CxfExchange(getCamelContext(), getExchangePattern(), inMessage);
    }
    public String getDataFormat() {
        return dataFormat;
    }
    public void setDataFormat(String format) {
        dataFormat = format;
    }
    public boolean isSpringContextEndpoint() {
        return isSpringContextEndpoint;
    }
    public String getAddress() {
        return address;
    }
    public String getWsdlURL() {
        return wsdlURL;
    }
    public void setWsdlURL(String url) {
        wsdlURL = url;
    }
    public void setSetDefaultBus(Boolean set) {
        isSetDefaultBus = set;
    }
    public Boolean isSetDefaultBus() {
        return isSetDefaultBus;
    }
    public String getServiceClass() {
        return serviceClass;
    }
    public void setServiceClass(String className) {
        serviceClass = className;
    }
    public void setPortName(String port) {
        portName = port;
    }
    public void setServiceName(String service) {
        serviceName = service;
    }
    public String getPortName() {
        return portName;
    }
    public String getServiceName() {
        return serviceName;
    }
    public boolean isInOut() {
        return inOut;
    }
    public void setInOut(boolean inOut) {
        this.inOut = inOut;
    }
    public boolean isWrapped() {
        return isWrapped;
    }
    public void setWrapped(boolean wrapped) {
        isWrapped = wrapped;
    }
    public CxfComponent getComponent() {
        return component;
    }
    public boolean isSingleton() {
        return true;
    }
    public String getBeanId() {
        return beanId;
    }
    public CxfEndpointBean getCxfEndpointBean() {
        return cxfEndpointBean;
    }
    public void configure(Object beanInstance) {
        configurer.configureBean(beanId, beanInstance);
    }
    public ApplicationContext getApplicationContext() {
        if (getCamelContext() instanceof SpringCamelContext) {
            SpringCamelContext context = (SpringCamelContext) getCamelContext();
            return context.getApplicationContext();
        } else {
            return null;
        }
    }
}
"
org.apache.camel.component.http.HttpClientConfigurer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.commons.httpclient.HttpClient;
/**
 * A plugable strategy for configuring the HttpClient used by this component
 *
 * @version $Revision$
 */
public interface HttpClientConfigurer {
    /**
     * Configure the HttpClient such as setting the authentication or proxying details
     *
     * @param client
     */
    void configureHttpClient(HttpClient client);
}
"
org.apache.camel.component.cxf.CamelInvoker,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.ExchangePattern;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.frontend.MethodDispatcher;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageContentsList;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.invoker.Invoker;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
public class CamelInvoker implements Invoker, MessageInvoker {
    private static final Logger LOG = LogUtils.getL7dLogger(CamelInvoker.class);
    private CxfConsumer cxfConsumer;
    public CamelInvoker(CxfConsumer consumer) {
        cxfConsumer = consumer;
    }
    /**
    * This method is called when the incoming message is to
    * be passed into the Camel processor. The return value is the response
    * from the processor
    */
    public void invoke(Exchange exchange) {
        Message inMessage = exchange.getInMessage();
        //TODO set the request context here
        CxfEndpoint endpoint = cxfConsumer.getEndpoint();
        CxfExchange cxfExchange = endpoint.createExchange(inMessage);
        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);
        if (bop != null && bop.getOperationInfo().isOneWay()) {
            cxfExchange.setPattern(ExchangePattern.InOnly);
        } else {
            cxfExchange.setPattern(ExchangePattern.InOut);
        }
        try {
            cxfConsumer.getProcessor().process(cxfExchange);
        } catch (Exception ex) {
            // catch the exception and send back to cxf client
            throw new Fault(ex);
        }
        // make sure the client has returned back the message
        copybackExchange(cxfExchange, exchange);
        Message outMessage = exchange.getOutMessage();
        // update the outMessageContext
        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);
        if (boi != null) {
            exchange.put(BindingMessageInfo.class, boi.getOutput());
        }
    }
    public void copybackExchange(CxfExchange result, Exchange exchange) {
        final Endpoint endpoint = exchange.get(Endpoint.class);
        Message outMessage = null;
        if (result.isFailed()) {
            CxfMessage fault = result.getFault();
            outMessage = exchange.getInFaultMessage();
            if (outMessage == null) {
                outMessage = endpoint.getBinding().createMessage();
                outMessage.setExchange(exchange);
                exchange.setInFaultMessage(outMessage);
            }
            Exception ex = (Exception) fault.getBody();
            outMessage.setContent(Exception.class, ex);
        } else {
            outMessage = result.getOutMessage();
            if (LOG.isLoggable(Level.FINEST)) {
                LOG.finest(""Get the response outMessage "" + outMessage);
            }
            // Copy the outMessage back if we set the out's body
            org.apache.camel.Message camelMessage = result.getOut();
            CxfBinding.copyMessage(camelMessage, outMessage);
        }
        // set the CXF outMessage back to the exchange
        exchange.setOutMessage(outMessage);
    }
    @SuppressWarnings(""unchecked"")
    public void updateContext(Map<String, Object> from, Map<String, Object> to) {
        if (to != null && from != null) {
            for (Iterator iter = from.entrySet().iterator(); iter.hasNext();) {
                Map.Entry entry = (Map.Entry) iter.next();
                String key = (String)entry.getKey();
                //Requires deep copy.
                if (!(Message.INBOUND_MESSAGE.equals(key)
                      || Message.REQUESTOR_ROLE.equals(key)
                      || Message.PROTOCOL_HEADERS.equals(key))) {
                    to.put(key, entry.getValue());
                }
            }
        }
    }
    /**
     * This method is called when the incoming pojo or WebServiceProvider invocation is called
     * from the service invocation interceptor. The return value is the response
     * from the processor
     */
    public Object invoke(Exchange exchange, Object o) {
        CxfEndpoint endpoint = cxfConsumer.getEndpoint();
        Object params = null;
        if (o instanceof List) {
            params = CastUtils.cast((List<?>)o);
        } else if (o != null) {
            params = new MessageContentsList(o);
        }
        CxfExchange cxfExchange = endpoint.createExchange(exchange.getInMessage());
        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);
        MethodDispatcher md = (MethodDispatcher)
            exchange.get(Service.class).get(MethodDispatcher.class.getName());
        Method m = md.getMethod(bop);
        // The SEI could be the provider class which will not have the bop information.
        if (bop != null && bop.getOperationInfo().isOneWay()) {
            cxfExchange.setPattern(ExchangePattern.InOnly);
        } else {
            cxfExchange.setPattern(ExchangePattern.InOut);
        }
        if (bop != null && bop.getName() != null) {
            cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAMESPACE, bop.getName().getNamespaceURI());
            cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, bop.getName().getLocalPart());
        } else {
            cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, m.getName());
        }
        cxfExchange.getIn().setBody(params);
        try {
            cxfConsumer.getProcessor().process(cxfExchange);
        } catch (Exception ex) {
            // catch the exception and send back to cxf client
            throw new Fault(ex);
        }
        Object result = null;
        if (cxfExchange.isFailed()) {
            Exception ex = (Exception)cxfExchange.getFault().getBody();
            if (ex instanceof Fault) {
                throw (Fault)ex;
            } else {
                throw new Fault(ex);
            }
        } else {
            result = cxfExchange.getOut().getBody();
            if (result != null) {
                if (result instanceof MessageContentsList || result instanceof List || result.getClass().isArray()) {
                    return result;
                } else { // if the result is the single object
                    MessageContentsList resList = new MessageContentsList();
                    resList.add(result);
                    return resList;
                }
            }
        }
        return result;
    }
}
"
org.apache.camel.component.jpa.TransactionStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import org.apache.camel.Service;
import org.springframework.orm.jpa.JpaCallback;
/**
 * @version $Revision$
 */
public interface TransactionStrategy extends Service {
    Object execute(JpaCallback callback);
}
"
org.apache.camel.component.mail.MailConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Flags;
import javax.mail.Folder;
import javax.mail.FolderNotFoundException;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Store;
import javax.mail.search.FlagTerm;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.mail.javamail.JavaMailSenderImpl;
/**
 * A {@link org.apache.camel.Consumer Consumer} which consumes messages from JavaMail using a
 * {@link javax.mail.Transport Transport} and dispatches them to the {@link Processor}
 *
 * @version $Revision$
 */
public class MailConsumer extends ScheduledPollConsumer<MailExchange> {
    public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L;
    private static final transient Log LOG = LogFactory.getLog(MailConsumer.class);
    private final MailEndpoint endpoint;
    private final JavaMailSenderImpl sender;
    private Folder folder;
    private Store store;
    public MailConsumer(MailEndpoint endpoint, Processor processor, JavaMailSenderImpl sender) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.sender = sender;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        if (folder != null && folder.isOpen()) {
            folder.close(true);
        }
        if (store != null && store.isConnected()) {
            store.close();
        }
        super.doStop();
    }
    protected void poll() throws Exception {
        ensureIsConnected();
        if (store == null || folder == null) {
            throw new IllegalStateException(""MailConsumer did not connect properly to the MailStore: ""
                                            + endpoint.getConfiguration().getMailStoreLogInformation());
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Polling mailfolder: "" + endpoint.getConfiguration().getMailStoreLogInformation());
        }
        if (endpoint.getConfiguration().getFetchSize() == 0) {
            LOG.warn(""Fetch size is 0 meaning the configuration is set to poll no new messages at all. Camel will skip this poll."");
            return;
        }
        // ensure folder is open
        if (!folder.isOpen()) {
            folder.open(Folder.READ_WRITE);
        }
        try {
            int count = folder.getMessageCount();
            if (count > 0) {
                Message[] messages;
                // should we process all messages or only unseen messages
                if (endpoint.getConfiguration().isProcessOnlyUnseenMessages()) {
                    messages = folder.search(new FlagTerm(new Flags(Flags.Flag.SEEN), false));
                } else {
                    messages = folder.getMessages();
                }
                processMessages(messages);
            } else if (count == -1) {
                throw new MessagingException(""Folder: "" + folder.getFullName() + "" is closed"");
            }
        } finally {
            // need to ensure we release resources
            if (folder.isOpen()) {
                folder.close(true);
            }
        }
    }
    protected void ensureIsConnected() throws MessagingException {
        MailConfiguration config = endpoint.getConfiguration();
        if (store == null || !store.isConnected()) {
            store = sender.getSession().getStore(config.getProtocol());
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Connecting to MailStore "" + endpoint.getConfiguration().getMailStoreLogInformation());
            }
            store.connect(config.getHost(), config.getPort(), config.getUsername(), config.getPassword());
        }
        if (folder == null) {
            folder = store.getFolder(config.getFolderName());
            if (folder == null || !folder.exists()) {
                throw new FolderNotFoundException(folder, ""Folder not found or invalid: "" + config.getFolderName());
            }
        }
    }
    /**
     * Process all the messages
     */
    protected void processMessages(Message[] messages) throws Exception {
        int fetchSize = endpoint.getConfiguration().getFetchSize();
        int count = fetchSize == -1 ? messages.length : Math.min(fetchSize, messages.length);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Fetching "" + count + "" messages. Total "" + messages.length + "" messages."");
        }
        for (int i = 0; i < count; i++) {
            Message message = messages[i];
            if (!message.getFlags().contains(Flags.Flag.DELETED)) {
                processMessage(message);
                flagMessageProcessed(message);
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Skipping message as it was flagged as deleted: "" + MailUtils.dumpMessage(message));
                }
            }
        }
    }
    /**
     * Strategy to process the mail message.
     */
    protected void processMessage(Message message) throws Exception {
        MailExchange exchange = endpoint.createExchange(message);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Processing message: "" + MailUtils.dumpMessage(message));
        }
        getProcessor().process(exchange);
    }
    /**
     * Strategy to flag the message after being processed.
     */
    protected void flagMessageProcessed(Message message) throws MessagingException {
        if (endpoint.getConfiguration().isDeleteProcessedMessages()) {
            message.setFlag(Flags.Flag.DELETED, true);
        } else {
            message.setFlag(Flags.Flag.SEEN, true);
        }
    }
}
"
org.apache.camel.component.xmpp.XmppExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.jivesoftware.smack.packet.Message;
/**
 * Represents an {@link Exchange} for working with XMPP
 *
 * @version $Revision:520964 $
 */
public class XmppExchange extends DefaultExchange {
    private XmppBinding binding;
    public XmppExchange(CamelContext context, ExchangePattern pattern, XmppBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public XmppExchange(CamelContext context, ExchangePattern pattern, XmppBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new XmppMessage(message));
    }
    public XmppExchange(DefaultExchange parent, XmppBinding binding) {
        super(parent);
        this.binding = binding;
    }
    @Override
    public XmppMessage getIn() {
        return (XmppMessage) super.getIn();
    }
    @Override
    public XmppMessage getOut() {
        return (XmppMessage) super.getOut();
    }
    @Override
    public XmppMessage getOut(boolean lazyCreate) {
        return (XmppMessage) super.getOut(lazyCreate);
    }
    @Override
    public XmppMessage getFault() {
        return (XmppMessage) super.getFault();
    }
    public XmppBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new XmppExchange(this, binding);
    }
    // Expose the underlying XMPP APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying XMPP In message
     *
     * @return the XMPP In message
     */
    public Message getInMessage() {
        return getIn().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Out message
     *
     * @return the XMPP out message
     */
    public Message getOutMessage() {
        return getOut().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Fault message
     *
     * @return the XMPP fault message
     */
    public Message getFaultMessage() {
        return getOut().getXmppMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected XmppMessage createInMessage() {
        return new XmppMessage();
    }
    @Override
    protected XmppMessage createOutMessage() {
        return new XmppMessage();
    }
}
"
org.apache.camel.component.http.HttpBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.Message;
/**
 * @version $Revision$
 */
public class HttpBinding {
    // This should be a set of lower-case strings
    public static final Set<String> DEFAULT_HEADERS_TO_IGNORE = new HashSet<String>(Arrays.asList(
            ""content-length"", ""content-type"", HttpProducer.HTTP_RESPONSE_CODE.toLowerCase()));
    private Set<String> ignoredHeaders = DEFAULT_HEADERS_TO_IGNORE;
    private boolean useReaderForPayload;
    /**
     * Writes the exchange to the servlet response
     *
     * @param response
     * @throws IOException
     */
    public void writeResponse(HttpExchange exchange, HttpServletResponse response) throws IOException {
        Message out = exchange.getOut();
        if (out != null) {
            // Set the status code in the response.  Default is 200.
            if (out.getHeader(HttpProducer.HTTP_RESPONSE_CODE) != null) {
                int responseCode = ((Integer)out.getHeader(HttpProducer.HTTP_RESPONSE_CODE)).intValue();
                response.setStatus(responseCode);
            }
            // Write out the headers...
            for (String key : out.getHeaders().keySet()) {
                String value = out.getHeader(key, String.class);
                if (shouldHeaderBePropagated(key, value)) {
                    response.setHeader(key, value);
                }
            }
            // Write out the body.
            if (out.getBody() != null) {
                // Try to stream the body since that would be the most
                // efficient..
                InputStream is = out.getBody(InputStream.class);
                if (is != null) {
                    ServletOutputStream os = response.getOutputStream();
                    int c;
                    while ((c = is.read()) >= 0) {
                        os.write(c);
                    }
                } else {
                    String data = out.getBody(String.class);
                    if (data != null) {
                        response.getWriter().print(data);
                    }
                }
            }
        }
    }
    /**
     * Parses the body from a HTTP message
     */
    public Object parseBody(HttpMessage httpMessage) throws IOException {
        // lets assume the body is a reader
        HttpServletRequest request = httpMessage.getRequest();
        if (isUseReaderForPayload()) {
            return request.getReader();
        } else {
            return request.getInputStream();
        }
    }
    /*
     * Exclude a set of headers from responses and new requests as all headers
     * get propagated between exchanges by default
     */
    public boolean shouldHeaderBePropagated(String headerName, String headerValue) {
        if (headerValue == null) {
            return false;
        }
        if (headerName.startsWith(""org.apache.camel"")) {
            return false;
        }
        if (getIgnoredHeaders().contains(headerName.toLowerCase())) {
            return false;
        }
        return true;
    }
    /*
     * override the set of headers to ignore for responses and new requests
     * @param headersToIgnore should be a set of lower-case strings
     */
    public void setIgnoredHeaders(Set<String> headersToIgnore) {
        ignoredHeaders  = headersToIgnore;
    }
    public Set<String> getIgnoredHeaders() {
        return ignoredHeaders;
    }
    public boolean isUseReaderForPayload() {
        return useReaderForPayload;
    }
    /**
     * Should the {@link HttpServletRequest#getReader()} be exposed as the payload of input messages in the Camel
     * {@link Message#getBody()} or not. If false then the {@link HttpServletRequest#getInputStream()} will be exposed.
     *
     * @param useReaderForPayload
     */
    public void setUseReaderForPayload(boolean useReaderForPayload) {
        this.useReaderForPayload = useReaderForPayload;
    }
}
"
org.apache.camel.component.cxf.invoker.InvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.Map;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
public interface InvokingContext {
    /**
     * This method is called when the router is preparing an outbound message
     * (orignated from the router's client) to be sent to the target CXF server.
     * It sets the content in the given (out) message object.
     */
    void setRequestOutMessageContent(Message message, Map<Class, Object> contents);
    /**
     * This method is call when the CxfClient receives a response from a CXF server and needs
     * to extract the response object from the message.
     */
    Object getResponseObject(Exchange exchange, Map<String, Object> responseContext);
    /**
     * This method is called when the routing interceptor has received a response message
     * from the target CXF server and needs to set the response in the outgoing message
     * that is to be sent to the client.
     */
    void setResponseContent(Message outMessage, Object resultPayload);
    /**
     * This method is called when the routing interceptor has intercepted a message from
     * the client and needs to extract the request content from the message.  It retreives
     * and receives the request content from the incoming message.
     */
    Map<Class, Object> getRequestContent(Message inMessage);
}
"
org.apache.camel.component.test.TestComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.test;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.UnsafeUriCharactersEncoder;
/**
 * Test Component.
 *
 * @see org.apache.camel.component.test.TestEndpoint
 *
 * @version $Revision$
 */
public class TestComponent extends DefaultComponent<Exchange> {
    public Endpoint<Exchange> createEndpoint(String uri) throws Exception {
        // lets not use the normal parameter handling so that all parameters are sent to the nested endpoint
        ObjectHelper.notNull(getCamelContext(), ""camelContext"");
        URI u = new URI(UnsafeUriCharactersEncoder.encode(uri));
        String path = u.getSchemeSpecificPart();
        return createEndpoint(uri, path, new HashMap());
    }
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(getCamelContext(), remaining);
        return new TestEndpoint(uri, this, endpoint);
    }
}"
org.apache.camel.component.cxf.invoker.PayloadMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.List;
import org.w3c.dom.Element;
public class PayloadMessage {
    private List<Element> payload;
    private Element header;
    public PayloadMessage(List<Element> payload, Element header) {
        this.payload = payload;
        this.header = header;
    }
    public List<Element> getPayload() {
        return payload;
    }
    public Element getHeader() {
        return header;
    }
    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(""payload: "" + payload);
        buf.append("" header: "" + header);
        return buf.toString();
    }
}
"
org.apache.camel.component.jhc.AsyncBufferingHttpServiceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.http.ConnectionReuseStrategy;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseFactory;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.ProtocolVersion;
import org.apache.http.impl.DefaultConnectionReuseStrategy;
import org.apache.http.impl.DefaultHttpResponseFactory;
import org.apache.http.nio.NHttpServerConnection;
import org.apache.http.nio.util.ByteBufferAllocator;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpParamsLinker;
import org.apache.http.protocol.BasicHttpProcessor;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpProcessor;
import org.apache.http.protocol.HttpRequestHandler;
import org.apache.http.protocol.ResponseConnControl;
import org.apache.http.protocol.ResponseContent;
import org.apache.http.protocol.ResponseDate;
import org.apache.http.protocol.ResponseServer;
/**
 * Created by IntelliJ IDEA.
 * User: gnodet
 * Date: Sep 11, 2007
 * Time: 6:57:34 PM
 * To change this template use File | Settings | File Templates.
 */
public class AsyncBufferingHttpServiceHandler extends BufferingHttpServiceHandler {
    public AsyncBufferingHttpServiceHandler(final HttpParams params) {
        super(createDefaultProcessor(),
              new DefaultHttpResponseFactory(),
              new DefaultConnectionReuseStrategy(),
              params);
    }
    public AsyncBufferingHttpServiceHandler(final HttpProcessor httpProcessor,
                                            final HttpResponseFactory responseFactory,
                                            final ConnectionReuseStrategy connStrategy,
                                            final HttpParams params) {
        super(httpProcessor, responseFactory, connStrategy, params);
    }
    public AsyncBufferingHttpServiceHandler(final HttpProcessor httpProcessor,
                                            final HttpResponseFactory responseFactory,
                                            final ConnectionReuseStrategy connStrategy,
                                            final ByteBufferAllocator allocator,
                                            final HttpParams params) {
        super(httpProcessor, responseFactory, connStrategy, allocator, params);
    }
    protected static HttpProcessor createDefaultProcessor() {
        BasicHttpProcessor httpproc = new BasicHttpProcessor();
        httpproc.addInterceptor(new ResponseDate());
        httpproc.addInterceptor(new ResponseServer());
        httpproc.addInterceptor(new ResponseContent());
        httpproc.addInterceptor(new ResponseConnControl());
        return httpproc;
    }
    protected void processRequest(
            final NHttpServerConnection conn,
            final HttpRequest request) throws IOException, HttpException {
        HttpContext context = conn.getContext();
        ProtocolVersion ver = request.getRequestLine().getProtocolVersion();
        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
            // Downgrade protocol version if greater than HTTP/1.1
            ver = HttpVersion.HTTP_1_1;
        }
        context.setAttribute(ExecutionContext.HTTP_REQUEST, request);
        context.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
        try {
            this.httpProcessor.process(request, context);
            HttpRequestHandler handler = null;
            if (handlerResolver != null) {
                String requestURI = request.getRequestLine().getUri();
                handler = handlerResolver.lookup(requestURI);
            }
            if (handler != null) {
                if (handler instanceof AsyncHttpRequestHandler) {
                    ((AsyncHttpRequestHandler)handler).handle(request, context, new AsyncResponseHandler() {
                        public void sendResponse(HttpResponse response) throws IOException, HttpException {
                            try {
                                AsyncBufferingHttpServiceHandler.this.sendResponse(conn, response);
                            } catch (HttpException ex) {
                                response = AsyncBufferingHttpServiceHandler.this.responseFactory.newHttpResponse(
                                            HttpVersion.HTTP_1_0,
                                            HttpStatus.SC_INTERNAL_SERVER_ERROR,
                                            conn.getContext());
                                HttpParamsLinker.link(response, AsyncBufferingHttpServiceHandler.this.params);
                                AsyncBufferingHttpServiceHandler.this.handleException(ex, response);
                                AsyncBufferingHttpServiceHandler.this.sendResponse(conn, response);
                            }
                        }
                    });
                } else { // just hanlder the request with sync request handler
                    HttpResponse response = this.responseFactory.newHttpResponse(
                                                                                 ver,
                                                                                 HttpStatus.SC_OK,
                                                                                 conn.getContext());
                    HttpParamsLinker.link(response, this.params);
                    context.setAttribute(ExecutionContext.HTTP_RESPONSE, response);
                    handler.handle(request, response, context);
                    sendResponse(conn, response);
                }
            } else {
                // add the default handler here
                HttpResponse response = this.responseFactory.newHttpResponse(
                                                                             ver,
                                                                             HttpStatus.SC_OK,
                                                                             conn.getContext());
                response.setStatusCode(HttpStatus.SC_NOT_IMPLEMENTED);
            }
        } catch (HttpException ex) {
            HttpResponse response = this.responseFactory.newHttpResponse(
                        HttpVersion.HTTP_1_0,
                        HttpStatus.SC_INTERNAL_SERVER_ERROR,
                    context);
            HttpParamsLinker.link(response, this.params);
            handleException(ex, response);
            sendResponse(conn, response);
        }
    }
}
"
org.apache.camel.dataformat.csv.CsvDataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.dataformat.csv;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVStrategy;
import org.apache.commons.csv.writer.CSVConfig;
import org.apache.commons.csv.writer.CSVField;
import org.apache.commons.csv.writer.CSVWriter;
/**
 * @version $Revision$
 */
public class CsvDataFormat implements DataFormat {
    private CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;
    private CSVConfig config = new CSVConfig();
    public void marshal(Exchange exchange, Object object, OutputStream outputStream) throws Exception {
        Map map = ExchangeHelper.convertToMandatoryType(exchange, Map.class, object);
        OutputStreamWriter out = new OutputStreamWriter(outputStream);
        try {
            CSVConfig conf = getConfig();
            // lets add fields
            Set set = map.keySet();
            for (Object value : set) {
                if (value != null) {
                    String text = value.toString();
                    CSVField field = new CSVField(text);
                    conf.addField(field);
                }
            }
            CSVWriter writer = new CSVWriter(conf);
            writer.setWriter(out);
            writer.writeRecord(map);
        } finally {
            out.close();
        }
    }
    public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {
        InputStreamReader in = new InputStreamReader(inputStream);
        try {
            CSVParser parser = new CSVParser(in, getStrategy());
            List<List<String>> list = new ArrayList<List<String>>();
            while (true) {
                String[] strings = parser.getLine();
                if (strings == null) {
                    break;
                }
                List<String> line = Arrays.asList(strings);
                list.add(line);
            }
            if (list.size() == 1) {
                return list.get(0);
            } else {
                return list;
            }
        } finally {
            in.close();
        }
    }
    public CSVConfig getConfig() {
        if (config == null) {
            config = createConfig();
        }
        return config;
    }
    public void setConfig(CSVConfig config) {
        this.config = config;
    }
    public CSVStrategy getStrategy() {
        return strategy;
    }
    public void setStrategy(CSVStrategy strategy) {
        this.strategy = strategy;
    }
    protected CSVConfig createConfig() {
        return new CSVConfig();
    }
}
"
org.apache.camel.component.jms.requestor.PersistentReplyToRequestor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.math.BigInteger;
import java.util.Random;
import java.util.concurrent.ScheduledExecutorService;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer102;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
public class PersistentReplyToRequestor extends Requestor {
    private String replyToSelectorValue;
    public class DestinationResolverDelegate implements DestinationResolver {
        private DestinationResolver delegate;
        private Destination destination;
        public DestinationResolverDelegate(DestinationResolver delegate) {
            this.delegate = delegate;
        }
        public Destination resolveDestinationName(Session session, String destinationName,
                                                  boolean pubSubDomain) throws JMSException {
            synchronized (getOutterInstance()) {
                try {
                    if (destination == null) {
                        destination = delegate.resolveDestinationName(session, destinationName, pubSubDomain);
                        setReplyTo(destination);
                    }
                } finally {
                    getOutterInstance().notifyAll();
                }
            }
            return destination;
        }
    };
    public static interface MessageSelectorComposer {
        void addCorrelationID(String id);
        void removeCorrelationID(String id);
    }
    public static class CamelDefaultMessageListenerContainer102 extends DefaultMessageListenerContainer102
                                                                implements MessageSelectorComposer {
        MessageSelectorProvider provider = new MessageSelectorProvider();
        public void addCorrelationID(String id) {
            provider.addCorrelationID(id);
        }
        public void removeCorrelationID(String id) {
            provider.removeCorrelationID(id);
        }
        @Override
        public void setMessageSelector(String messageSelector) {
            throw new UnsupportedOperationException();
        }
        @Override
        public String getMessageSelector() {
            return provider.get();
        }
    }
    public static class CamelDefaultMessageListenerContainer extends DefaultMessageListenerContainer
                                                             implements MessageSelectorComposer {
        MessageSelectorProvider provider = new MessageSelectorProvider();
        public void addCorrelationID(String id) {
            provider.addCorrelationID(id);
        }
        public void removeCorrelationID(String id) {
            provider.removeCorrelationID(id);
        }
        @Override
        public void setMessageSelector(String messageSelector) {
            throw new UnsupportedOperationException();
        }
        @Override
        public String getMessageSelector() {
            return provider.get();
        }
    }
    public PersistentReplyToRequestor(JmsConfiguration configuration,
                                      ScheduledExecutorService executorService) {
        super(configuration, executorService);
    }
    @Override
    protected FutureHandler createFutureHandler(String correlationID) {
        boolean dynamicSelector = getConfiguration().getReplyToDestinationSelectorName() == null;
        if (dynamicSelector) {
            return new PersistentReplyToFutureHandler(this, correlationID);
        }
        return new FutureHandler();
    }
    @Override
    protected FutureHandler createFutureHandler(DeferredMessageSentCallback callback) {
        boolean dynamicSelector = getConfiguration().getReplyToDestinationSelectorName() == null;
        if (dynamicSelector) {
            return new PersistentReplyToFutureHandler(this, callback);
        }
        return new FutureHandler();
    }
    @Override
    public AbstractMessageListenerContainer createListenerContainer() {
        JmsConfiguration config = getConfiguration();
        String replyToSelectorName = getConfiguration().getReplyToDestinationSelectorName();
        AbstractMessageListenerContainer container =
            config.isUseVersion102()
                    ? (replyToSelectorName != null) ? new DefaultMessageListenerContainer102()
                           : new CamelDefaultMessageListenerContainer102()
                    : (replyToSelectorName != null) ? new DefaultMessageListenerContainer()
                           : new CamelDefaultMessageListenerContainer();
        container.setConnectionFactory(config.getListenerConnectionFactory());
        DestinationResolver resolver = config.getDestinationResolver();
        if (resolver == null) {
            resolver = container.getDestinationResolver();
        }
        container.setDestinationResolver(new DestinationResolverDelegate(resolver));
        container.setDestinationName(getConfiguration().getReplyTo());
        if (replyToSelectorName != null) {
            replyToSelectorValue = ""ID:"" + new BigInteger(24 * 8, new Random()).toString(16);
            container.setMessageSelector(replyToSelectorName + ""='"" + replyToSelectorValue + ""'"");
        } else {
            ((MessageSelectorComposer)container).addCorrelationID(""ID:"" + new BigInteger(24 * 8, new Random()).toString(16));
        }
        container.setAutoStartup(true);
        container.setMessageListener(this);
        container.setPubSubDomain(false);
        container.setSubscriptionDurable(false);
        ExceptionListener exceptionListener = config.getExceptionListener();
        if (exceptionListener != null) {
            container.setExceptionListener(exceptionListener);
        }
        container.setSessionTransacted(config.isTransacted());
        if (config.isTransacted()) {
            container.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        } else {
            if (config.getAcknowledgementMode() >= 0) {
                container.setSessionAcknowledgeMode(config.getAcknowledgementMode());
            } else if (config.getAcknowledgementModeName() != null) {
                container.setSessionAcknowledgeModeName(config.getAcknowledgementModeName());
            }
        }
        if (container instanceof DefaultMessageListenerContainer) {
            DefaultMessageListenerContainer defContainer = (DefaultMessageListenerContainer)container;
            defContainer.setConcurrentConsumers(1);
            defContainer.setCacheLevel(DefaultMessageListenerContainer.CACHE_SESSION);
            if (config.getReceiveTimeout() >= 0) {
                defContainer.setReceiveTimeout(config.getReceiveTimeout());
            }
            if (config.getRecoveryInterval() >= 0) {
                defContainer.setRecoveryInterval(config.getRecoveryInterval());
            }
            TaskExecutor taskExecutor = config.getTaskExecutor();
            if (taskExecutor != null) {
                defContainer.setTaskExecutor(taskExecutor);
            }
            PlatformTransactionManager tm = config.getTransactionManager();
            if (tm != null) {
                defContainer.setTransactionManager(tm);
            } else if (config.isTransacted()) {
                throw new IllegalArgumentException(""Property transacted is enabled but a transactionManager was not injected!"");
            }
            if (config.getTransactionName() != null) {
                defContainer.setTransactionName(config.getTransactionName());
            }
            if (config.getTransactionTimeout() >= 0) {
                defContainer.setTransactionTimeout(config.getTransactionTimeout());
            }
        }
        return container;
    }
    @Override
    public void setReplyToSelectorHeader(org.apache.camel.Message in, Message jmsIn) throws JMSException {
        String replyToSelectorName = getConfiguration().getReplyToDestinationSelectorName();
        if (replyToSelectorValue != null) {
            in.setHeader(replyToSelectorName, replyToSelectorValue);
            jmsIn.setStringProperty(replyToSelectorName, replyToSelectorValue);
        }
    }
}
"
org.apache.camel.component.quartz.QuartzExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.quartz.JobExecutionContext;
/**
 * @version $Revision$
 */
public class QuartzExchange extends DefaultExchange {
    public QuartzExchange(CamelContext context, ExchangePattern pattern, JobExecutionContext jobExecutionContext) {
        super(context, pattern);
        setIn(new QuartzMessage(this, jobExecutionContext));
    }
    @Override
    public QuartzMessage getIn() {
        return (QuartzMessage) super.getIn();
    }
    public JobExecutionContext getJobExecutionContext() {
        return getIn().getJobExecutionContext();
    }
}
"
org.apache.camel.component.validator.SpringValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator;
import java.io.IOException;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.processor.validation.ValidatingProcessor;
import org.springframework.core.io.Resource;
/**
 * Validator that uses Spring for reading the scheme resource.
 *
 * @version $Revision$
 */
public class SpringValidator extends ValidatingProcessor {
    private Resource schemaResource;
    public Resource getSchemaResource() {
        return schemaResource;
    }
    public void setSchemaResource(Resource schemaResource) {
        this.schemaResource = schemaResource;
    }
    @Override
    protected Source createSchemaSource() throws IOException {
        if (schemaResource != null) {
            if (schemaResource.getURL() == null) {
                return new StreamSource(schemaResource.getInputStream());
            } else {
                return new StreamSource(schemaResource.getInputStream(), schemaResource.getURL().toExternalForm());
            }
        } else {
            throw new IllegalArgumentException(""You must specify a schema, schemaFile, schemaResource, schemaSource or schemaUrl property"");
        }
    }
}
"
org.apache.camel.component.spring.integration.adapter.config.NamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
/**
 * The name space handler Spring Integration Camel Adapter
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class NamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser(""camelSource"", new CamelSourceAdpaterParser());
        registerBeanDefinitionParser(""camelTarget"", new CamelTargetAdapterParser());
    }
}
"
org.apache.camel.component.cxf.interceptors.DOMOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ResourceBundle;
import java.util.logging.Logger;
//import java.util.logging.Level;
//import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.interceptor.MessageSenderInterceptor;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class DOMOutInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(DOMOutInterceptor.class);
    private final XMLMessageOutInterceptor xmlInterceptor = new XMLMessageOutInterceptor();
    private final SoapMessageOutInterceptor soapInterceptor = new SoapMessageOutInterceptor();
    public DOMOutInterceptor() {
        super(Phase.PREPARE_SEND);
        this.addBefore(MessageSenderInterceptor.class.getName());
    }
    public boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        if (message instanceof XMLMessage) {
            xmlInterceptor.handleMessage((XMLMessage)message);
        } else if (message instanceof SoapMessage) {
            soapInterceptor.handleMessage((SoapMessage)message);
        } else {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""NOT_SUPPORTED_MESSAGE"", 
                                                                   LOG, message.getClass().getName()));
        }        
    }
}
"
org.apache.camel.component.cxf.invoker.RawMessageInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.io.InputStream;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
public class RawMessageInvokingContext extends AbstractInvokingContext {
    private static final Logger LOG = LogUtils.getL7dLogger(RawMessageInvokingContext.class);
    public RawMessageInvokingContext() {
    }
    public void setRequestOutMessageContent(Message message, Map<Class, Object> contents) {
        Set entries = contents.keySet();
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            Object obj = iter.next();
            if (obj instanceof Class) {
                message.setContent((Class<?>)obj, contents.get((Class<?>)obj));
            }
        }
    }
    public Object getResponseObject(Exchange exchange, Map<String, Object> responseContext) {
        return getResponseObject(exchange.getInMessage(), responseContext, InputStream.class);
    }
    public void setResponseContent(Message outMessage, Object resultPayload) {
        LOG.info(""Set content: "" + resultPayload);
        outMessage.setContent(InputStream.class, resultPayload);
        //loggerTheMessage(outMessage, ""Out Message"");
    }
    public Map<Class, Object> getRequestContent(Message inMessage) {
        //loggerTheMessage(inMessage, ""In Message"");
        IdentityHashMap<Class, Object> contents = new IdentityHashMap<Class, Object>();
        Set set = inMessage.getContentFormats();
        Iterator iter = set.iterator();
        while (iter.hasNext()) {
            Object obj = iter.next();
            if (obj instanceof Class) {
                contents.put((Class<?>)obj, inMessage.getContent((Class<?>)obj));
            }
        }
        return contents;
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.component.jms.JmsEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import javax.jms.TemporaryQueue;
import javax.jms.TemporaryTopic;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.component.jms.requestor.Requestor;
import org.apache.camel.impl.DefaultEndpoint;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 *
 * @version $Revision:520964 $
 */
public class JmsEndpoint extends DefaultEndpoint<JmsExchange> {
    private final boolean pubSubDomain;
    private JmsBinding binding;
    private String destination;
    private String selector;
    private JmsConfiguration configuration;
    private Requestor requestor;
    private long requestTimeout;
    public JmsEndpoint(String uri, JmsComponent component, String destination, boolean pubSubDomain, JmsConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
        this.destination = destination;
        this.pubSubDomain = pubSubDomain;
        this.requestTimeout = configuration.getRequestTimeout();
    }
    public JmsEndpoint(String endpointUri, JmsBinding binding, JmsConfiguration configuration, String destination, boolean pubSubDomain) {
        super(endpointUri);
        this.binding = binding;
        this.configuration = configuration;
        this.destination = destination;
        this.pubSubDomain = pubSubDomain;
        this.requestTimeout = configuration.getRequestTimeout();
    }
    public JmsEndpoint(String endpointUri, String destination, boolean pubSubDomain) {
        this(endpointUri, new JmsBinding(), new JmsConfiguration(), destination, pubSubDomain);
    }
    /**
     * Creates a pub-sub endpoint with the given destination
     */
    public JmsEndpoint(String endpointUri, String destination) {
        this(endpointUri, destination, true);
    }
    public JmsProducer createProducer() throws Exception {
        return new JmsProducer(this);
    }
    /**
     * Creates a producer using the given template for InOnly message exchanges
     */
    public JmsProducer createProducer(JmsOperations template) throws Exception {
        JmsProducer answer = createProducer();
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate) template;
            jmsTemplate.setPubSubDomain(pubSubDomain);
            jmsTemplate.setDefaultDestinationName(destination);
        }
        answer.setInOnlyTemplate(template);
        return answer;
    }
    public JmsConsumer createConsumer(Processor processor) throws Exception {
        AbstractMessageListenerContainer listenerContainer = configuration.createMessageListenerContainer(this);
        return createConsumer(processor, listenerContainer);
    }
    /**
     * Creates a consumer using the given processor and listener container
     *
     * @param processor         the processor to use to process the messages
     * @param listenerContainer the listener container
     * @return a newly created consumer
     * @throws Exception if the consumer cannot be created
     */
    public JmsConsumer createConsumer(Processor processor, AbstractMessageListenerContainer listenerContainer) throws Exception {
        listenerContainer.setDestinationName(destination);
        listenerContainer.setPubSubDomain(pubSubDomain);
        return new JmsConsumer(this, processor, listenerContainer);
    }
    @Override
    public PollingConsumer<JmsExchange> createPollingConsumer() throws Exception {
        JmsOperations template = createInOnlyTemplate();
        return new JmsPollingConsumer(this, template);
    }
    @Override
    public JmsExchange createExchange(ExchangePattern pattern) {
        return new JmsExchange(getCamelContext(), pattern, getBinding());
    }
    public JmsExchange createExchange(Message message) {
        return new JmsExchange(getCamelContext(), getExchangePattern(), getBinding(), message);
    }
    /**
     * Factory method for creating a new template for InOnly message exchanges
     */
    public JmsOperations createInOnlyTemplate() {
        return configuration.createInOnlyTemplate(this, pubSubDomain, destination);
    }
    /**
     * Factory method for creating a new template for InOut message exchanges
     */
    public JmsOperations createInOutTemplate() {
        return configuration.createInOutTemplate(this, pubSubDomain, destination, getRequestTimeout());
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding(this);
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS
     * message
     *
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public String getDestination() {
        return destination;
    }
    public JmsConfiguration getConfiguration() {
        return configuration;
    }
    public String getSelector() {
        return selector;
    }
    /**
     * Sets the JMS selector to use
     */
    public void setSelector(String selector) {
        this.selector = selector;
    }
    public boolean isSingleton() {
        return false;
    }
    public synchronized Requestor getRequestor() throws Exception {
        if (requestor == null) {
            requestor = new Requestor(getConfiguration(), getExecutorService());
            requestor.start();
        }
        return requestor;
    }
    public void setRequestor(Requestor requestor) {
        this.requestor = requestor;
    }
    public long getRequestTimeout() {
        return requestTimeout;
    }
    /**
     * Sets the timeout in milliseconds which requests should timeout after
     *
     * @param requestTimeout
     */
    public void setRequestTimeout(long requestTimeout) {
        this.requestTimeout = requestTimeout;
    }
    public boolean isPubSubDomain() {
        return pubSubDomain;
    }
    /**
     * Lazily loads the temporary queue type if one has not been explicitly configured
     * via calling the {@link JmsProviderMetadata#setTemporaryQueueType(Class)}
     * on the {@link #getConfiguration()} instance
     */
    public Class<? extends TemporaryQueue> getTemporaryQueueType() {
        JmsProviderMetadata metadata = getProviderMetadata();
        JmsOperations template = getMetadataJmsOperations();
        return metadata.getTemporaryQueueType(template);
    }
    /**
     * Lazily loads the temporary topic type if one has not been explicitly configured
     * via calling the {@link JmsProviderMetadata#setTemporaryTopicType(Class)}
     * on the {@link #getConfiguration()} instance
     */
    public Class<? extends TemporaryTopic> getTemporaryTopicType() {
        JmsOperations template = getMetadataJmsOperations();
        JmsProviderMetadata metadata = getProviderMetadata();
        return metadata.getTemporaryTopicType(template);
    }
    /**
     * Returns the provider metadata
     */
    protected JmsProviderMetadata getProviderMetadata() {
        JmsConfiguration conf = getConfiguration();
        JmsProviderMetadata metadata = conf.getProviderMetadata();
        return metadata;
    }
    /**
     * Returns the {@link JmsOperations} used for metadata operations such as creating temporary destinations
     */
    protected JmsOperations getMetadataJmsOperations() {
        JmsOperations template = getConfiguration().getMetadataJmsOperations(this);
        if (template == null) {
            throw new IllegalArgumentException(""No Metadata JmsTemplate supplied!"");
        }
        return template;
    }
    public void checkValidTemplate(JmsTemplate template) {
        if (template.getDestinationResolver() == null) {
            if (this instanceof DestinationEndpoint) {
                final DestinationEndpoint destinationEndpoint = (DestinationEndpoint) this;
                template.setDestinationResolver(JmsConfiguration.createDestinationResolver(destinationEndpoint));
            }
        }
    }
}
"
org.apache.camel.component.atom.AtomProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * AtomProducer is currently not implemented
 *
 * @version $Revision$
 */
public class AtomProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(AtomProducer.class);
    private final AtomEndpoint endpoint;
    public AtomProducer(AtomEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) throws Exception {
        throw new UnsupportedOperationException(""AtomProducer is not implemented"");
    }
}
"
org.apache.camel.component.jetty.CamelContinuationServlet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jetty;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.AsyncCallback;
import org.apache.camel.component.http.CamelServlet;
import org.apache.camel.component.http.HttpConsumer;
import org.apache.camel.component.http.HttpExchange;
import org.mortbay.util.ajax.Continuation;
import org.mortbay.util.ajax.ContinuationSupport;
/**
 * @version $Revision$
 */
public class CamelContinuationServlet extends CamelServlet {
    // private static final String EXCHANGE_ATTRIBUTE =
    // CamelContinuationServlet.class.getName()+"".EXCHANGE_ATTRIBUTE"";
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            // Is there a consumer registered for the request.
            HttpConsumer consumer = resolve(request);
            if (consumer == null) {
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            // HttpExchange exchange =
            // (HttpExchange)request.getAttribute(EXCHANGE_ATTRIBUTE);
            // if( exchange == null ) {
            // exchange = new HttpExchange(consumer.getEndpoint(), request,
            // response);
            // }
            // Continuation continuation =
            // ContinuationSupport.getContinuation(request, exchange);
            final Continuation continuation = ContinuationSupport.getContinuation(request, null);
            if (continuation.isNew()) {
                // Have the camel process the HTTP exchange.
                final HttpExchange exchange = new HttpExchange(consumer.getEndpoint(), request, response);
                boolean sync = consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        if (sync) {
                            return;
                        }
                        continuation.setObject(exchange);
                        continuation.resume();
                    }
                });
                if (!sync) {
                    // Wait for the exchange to get processed.
                    // This might block until it completes or it might return via an exception and
                    // then this method is re-invoked once the the exchange has finished processing
                    continuation.suspend(0);
                }
                // HC: The getBinding() is interesting because it illustrates the
                // impedance miss-match between
                // HTTP's stream oriented protocol, and Camels more message oriented
                // protocol exchanges.
                // now lets output to the response
                consumer.getBinding().writeResponse(exchange, response);
                return;
            }
            if (continuation.isResumed()) {
                HttpExchange exchange = (HttpExchange)continuation.getObject();
                // now lets output to the response
                consumer.getBinding().writeResponse(exchange, response);
                return;
            }
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }
}
"
org.apache.camel.spring.util.SimpleRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.util.ObjectHelper;
/**
 * A simple {@link RouteBuilder} which can be configured directly with one or more from URIs, zero or more to URIs
 * and an optional bean processing step.
 *
 * @version $Revision$
 */
public class SimpleRouteBuilder extends RouteBuilder {
    private List<String> fromUris = new ArrayList<String>();
    private List<String> toUris = new ArrayList<String>();
    private Class beanType;
    private String beanClass;
    private String beanRef;
    private String beanMethod;
    public void configure() throws Exception {
        if (fromUris.isEmpty()) {
            throw new IllegalArgumentException(""the fromUris property must contain at least one valid URI"");
        }
        for (String fromUri : fromUris) {
            ProcessorType route = from(fromUri);
            addBeanCall(route);
            for (String toUri : toUris) {
                route = route.to(toUri);
            }
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public void setFromUri(String uri) {
        setFromUris(singletonList(uri));
    }
    public void setToUri(String uri) {
        setToUris(singletonList(uri));
    }
    public List<String> getFromUris() {
        return fromUris;
    }
    public void setFromUris(List<String> fromUris) {
        this.fromUris = fromUris;
    }
    public List<String> getToUris() {
        return toUris;
    }
    public void setToUris(List<String> toUris) {
        this.toUris = toUris;
    }
    public String getBeanClass() {
        return beanClass;
    }
    public void setBeanClass(String beanClass) {
        this.beanClass = beanClass;
    }
    public String getBeanRef() {
        return beanRef;
    }
    public void setBeanRef(String beanRef) {
        this.beanRef = beanRef;
    }
    public Class getBeanType() {
        if (beanType == null) {
            if (beanClass != null) {
                beanType = ObjectHelper.loadClass(beanClass, getClass().getClassLoader());
            }
        }
        return beanType;
    }
    public void setBeanType(Class beanType) {
        this.beanType = beanType;
    }
    public String getBeanMethod() {
        return beanMethod;
    }
    public void setBeanMethod(String beanMethod) {
        this.beanMethod = beanMethod;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void addBeanCall(ProcessorType route) {
        Class type = getBeanType();
        if (type != null) {
            if (beanMethod != null) {
                route = route.bean(type, beanMethod);
            } else {
                route = route.bean(type);
            }
        } else if (beanRef != null) {
            if (beanMethod != null) {
                route = route.beanRef(beanRef, beanMethod);
            } else {
                route = route.beanRef(beanRef);
            }
        }
    }
    protected List<String> singletonList(String value) {
        List<String> uris = new ArrayList<String>();
        uris.add(value);
        return uris;
    }
}
"
org.apache.camel.component.jms.JmsExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Represents an {@link Exchange} for working with JMS messages while exposing the inbound and outbound JMS {@link Message}
 * objects via {@link #getInMessage()} and {@link #getOutMessage()}
 *
 * @version $Revision:520964 $
 */
public class JmsExchange extends DefaultExchange {
    private JmsBinding binding;
    public JmsExchange(CamelContext context, ExchangePattern pattern, JmsBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public JmsExchange(CamelContext context, ExchangePattern pattern, JmsBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new JmsMessage(message));
    }
    public JmsExchange(DefaultExchange parent, JmsBinding binding) {
        super(parent);
        this.binding = binding;
    }
    @Override
    public JmsMessage getIn() {
        return (JmsMessage) super.getIn();
    }
    @Override
    public JmsMessage getOut() {
        return (JmsMessage) super.getOut();
    }
    @Override
    public JmsMessage getOut(boolean lazyCreate) {
        return (JmsMessage) super.getOut(lazyCreate);
    }
    @Override
    public JmsMessage getFault() {
        return (JmsMessage) super.getFault();
    }
    public JmsBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new JmsExchange(this, binding);
    }
    // Expose JMS APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying JMS In message
     *
     * @return the JMS In message
     */
    public Message getInMessage() {
        return getIn().getJmsMessage();
    }
    /**
     * Return the underlying JMS Out message
     *
     * @return the JMS out message
     */
    public Message getOutMessage() {
        return getOut().getJmsMessage();
    }
    /**
     * Return the underlying JMS Fault message
     *
     * @return the JMS fault message
     */
    public Message getFaultMessage() {
        return getOut().getJmsMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected JmsMessage createInMessage() {
        return new JmsMessage();
    }
    @Override
    protected JmsMessage createOutMessage() {
        return new JmsMessage();
    }
    @Override
    protected org.apache.camel.Message createFaultMessage() {
        return new JmsMessage();
    }
}
"
org.apache.camel.component.stream.StreamComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * Component providing streams connectivity
 */
public class StreamComponent extends DefaultComponent<Exchange> {
    // TODO: remove file and url support in this component. Will be removed in Camel 2.0
    // (Should use other components for such needs.)
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        return new StreamEndpoint(uri, this);
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import java.util.Map;
import org.apache.camel.impl.DefaultComponent;
/**
 * Represents the component that manages {@link SpringIntegrationEndpoint}. It holds the
 * list of named direct endpoints.
 *
 * @version $Revision$
 */
public class SpringIntegrationComponent extends DefaultComponent<SpringIntegrationExchange> {
    protected SpringIntegrationEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        SpringIntegrationEndpoint endpoint = new SpringIntegrationEndpoint(uri, remaining, this);
        setProperties(endpoint, parameters);
        return endpoint;
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.springframework.integration.message.MessageHeader;
/**
 * The Message {@link DefaultMessage} implementation
 * for accessing the SpringIntegrationMessage
 *
 * @version $Revision$
 */
public class SpringIntegrationMessage extends DefaultMessage {
    private org.springframework.integration.message.Message siMessage;
    public SpringIntegrationMessage(org.springframework.integration.message.Message message) {
        siMessage = message;
    }
    public SpringIntegrationMessage() {
    }
    public void setMessage(org.springframework.integration.message.Message message) {
        siMessage = message;
    }
    public org.springframework.integration.message.Message getMessage() {
        return siMessage;
    }
    @Override
    public void copyFrom(org.apache.camel.Message that) {
        setMessageId(that.getMessageId());
        setBody(that.getBody());
        getHeaders().putAll(that.getHeaders());
        if (that instanceof SpringIntegrationMessage) {
            SpringIntegrationMessage orig = (SpringIntegrationMessage) that;
            setMessage(orig.getMessage());
        }
    }
    @Override
    public String toString() {
        if (siMessage != null) {
            return ""SpringIntegrationMessage: "" + siMessage;
        } else {
            return ""SpringIntegrationMessage: "" + getBody();
        }
    }
    @Override
    public SpringIntegrationExchange getExchange() {
        return (SpringIntegrationExchange)super.getExchange();
    }
    public Object getHeader(String name) {
        if (siMessage != null) {
            return siMessage.getHeader().getAttribute(name);
        } else {
            return super.getHeader(name);
        }
    }
    @Override
    public void setHeader(String name, Object value) {
        if (siMessage != null) {
            siMessage.getHeader().setAttribute(name, value);
        } else {
            super.setHeader(name, value);
        }
    }
    @Override
    public Map<String, Object> getHeaders() {
        if (siMessage != null) {
            Map<String, Object> answer = new HashMap<String, Object>();
            MessageHeader header = siMessage.getHeader();
            for (String name : header.getAttributeNames()) {
                answer.put(name, header.getAttribute(name));
            }
            return answer;
        } else {
            return super.getHeaders();
        }
    }
    @Override
    public SpringIntegrationMessage newInstance() {
        return new SpringIntegrationMessage();
    }
    @Override
    protected Object createBody() {
        return siMessage.getPayload();
    }
}
"
org.apache.camel.converter.jaxb.IntegerHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""intHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class IntegerHeader extends HeaderType {
    @XmlAttribute(name = ""value"")
    private Integer number;
    public IntegerHeader() {
    }
    public IntegerHeader(String name, Integer number) {
        super(name);
        this.number = number;
    }
    public Integer getNumber() {
        return number;
    }
    public void setNumber(Integer number) {
        this.number = number;
    }
    public Object getValue() {
        return getNumber();
    }
    public void setValue(Object value) {
        if (value instanceof Number) {
            Number n = (Number) value;
            setNumber(n.intValue());
        } else {
            throw new IllegalArgumentException(""Value must be an Integer"");
        }
    }
}"
org.apache.camel.component.jetty.JettyHttpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jetty;
import java.net.URI;
import java.net.URISyntaxException;
import org.apache.camel.Consumer;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.component.http.HttpConsumer;
import org.apache.camel.component.http.HttpEndpoint;
import org.apache.camel.component.http.HttpExchange;
import org.apache.camel.impl.EventDrivenPollingConsumer;
import org.apache.commons.httpclient.HttpConnectionManager;
/**
 * @version $Revision$
 */
public class JettyHttpEndpoint extends HttpEndpoint {
    private JettyHttpComponent component;
    private boolean sessionSupport;
    public JettyHttpEndpoint(JettyHttpComponent component, String uri, URI httpURL, HttpConnectionManager httpConnectionManager) throws URISyntaxException {
        super(uri, component, httpURL, httpConnectionManager);
        this.component = component;
    }
    @Override
    public Producer<HttpExchange> createProducer() throws Exception {
        return super.createProducer();
        // return new JettyHttpProducer(this);
    }
    @Override
    public Consumer<HttpExchange> createConsumer(Processor processor) throws Exception {
        return new HttpConsumer(this, processor);
    }
    @Override
    public PollingConsumer<HttpExchange> createPollingConsumer() throws Exception {
        return new EventDrivenPollingConsumer<HttpExchange>(this);
    }
    @Override
    public JettyHttpComponent getComponent() {
        return component;
    }
    public void setSessionSupport(boolean support) {
        sessionSupport = support;
    }
    public boolean isSessionSupport() {
        return sessionSupport;
    }
}
"
org.apache.camel.component.jhc.JhcConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import org.apache.camel.Converter;
import org.apache.http.HttpEntity;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity;
import org.apache.http.util.EntityUtils;
/**
 * Created by IntelliJ IDEA.
 * User: gnodet
 * Date: Sep 10, 2007
 * Time: 8:26:44 AM
 * To change this template use File | Settings | File Templates.
 */
@Converter
public final class JhcConverter {
    private JhcConverter() {
    }
    @Converter
    public static InputStream toInputStream(HttpEntity entity) throws IOException {
        return entity.getContent();
    }
    @Converter
    public static byte[] toByteArray(HttpEntity entity) throws IOException {
        return EntityUtils.toByteArray(entity);
    }
    @Converter
    public static String toString(HttpEntity entity) throws IOException {
        return EntityUtils.toString(entity);
    }
    @Converter
    public static HttpEntity toEntity(InputStream is) {
        return new InputStreamEntity(is, -1);
    }
    @Converter
    public static HttpEntity toEntity(String str) throws UnsupportedEncodingException {
        return new StringEntity(str);
    }
}
"
org.apache.camel.component.atom.AtomConsumerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
/**
 * Base class for consuming Atom feeds.
 */
public abstract class AtomConsumerSupport extends ScheduledPollConsumer<Exchange> {
    public static final long DEFAULT_CONSUMER_DELAY = 60 * 1000L;
    protected final AtomEndpoint endpoint;
    public AtomConsumerSupport(AtomEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
}
"
org.apache.camel.component.http.HttpComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.net.URI;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.httpclient.HttpConnectionManager;
import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
import org.apache.commons.httpclient.params.HttpClientParams;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/http.html"">HTTP
 * Component</a>
 *
 * @version $Revision$
 */
public class HttpComponent extends DefaultComponent<HttpExchange> {
    private HttpClientConfigurer httpClientConfigurer;
    private HttpConnectionManager httpConnectionManager = new MultiThreadedHttpConnectionManager();
    /**
     * Connects the URL specified on the endpoint to the specified processor.
     *
     * @throws Exception
     */
    public void connect(HttpConsumer consumer) throws Exception {
    }
    /**
     * Disconnects the URL specified on the endpoint from the specified
     * processor.
     *
     * @throws Exception
     */
    public void disconnect(HttpConsumer consumer) throws Exception {
    }
    public HttpClientConfigurer getHttpClientConfigurer() {
        return httpClientConfigurer;
    }
    public void setHttpClientConfigurer(HttpClientConfigurer httpClientConfigurer) {
        this.httpClientConfigurer = httpClientConfigurer;
    }
    public HttpConnectionManager getHttpConnectionManager() {
        return httpConnectionManager;
    }
    public void setHttpConnectionManager(HttpConnectionManager httpConnectionManager) {
        this.httpConnectionManager = httpConnectionManager;
    }
    @Override
    protected Endpoint<HttpExchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        HttpClientParams params = new HttpClientParams();
        IntrospectionSupport.setProperties(params, parameters, ""httpClient."");
        return new HttpEndpoint(uri, this, new URI(uri), params, httpConnectionManager, httpClientConfigurer);
    }
    @Override
    protected boolean useIntrospectionOnEndpoint() {
        return false;
    }
}
"
org.apache.camel.component.mina.MinaPayloadHolder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.io.Serializable;
import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.camel.Exchange;
/**
 * Holder object for sending an exchange over the wire using the MINA ObjectSerializationCodecFactory codec.
 * This is configured using the <tt>transferExchange=true</tt> option for the TCP protocol.
 * <p/>
 * As opposed to normal usage of camel-mina where only the body part of the exchange is transfered, this holder
 * object serializes the following fields over the wire:
 * <ul>
 *     <li>in body</li>
 *     <li>out body</li>
 *     <li>in headers</li>
 *     <li>out headers</li>
 *     <li>exchange properties</li>
 *     <li>exception</li>
 * </ul>
 *
 * @version $Revision$
 */
public class MinaPayloadHolder implements Serializable {
    private static final long serialVersionUID = 1L;
    private Object inBody;
    private Object outBody;
    private Map<String, Object> inHeaders = new LinkedHashMap<String, Object>();
    private Map<String, Object> outHeaders = new LinkedHashMap<String, Object>();
    private Map<String, Object> properties = new LinkedHashMap<String, Object>();
    private Throwable exception;
    /**
     * Creates a payload object with the information from the given exchange.
     *
     * @param exchange     the exchange
     * @return the holder object with information copied form the exchange
     */
    public static MinaPayloadHolder marshal(Exchange exchange) {
        MinaPayloadHolder payload = new MinaPayloadHolder();
        payload.inBody = exchange.getIn().getBody();
        if (exchange.getOut(false) != null) {
            payload.outBody = exchange.getOut().getBody();
        }
        payload.inHeaders.putAll(exchange.getIn().getHeaders());
        payload.outHeaders.putAll(exchange.getOut().getHeaders());
        payload.properties.putAll(exchange.getProperties());
        payload.exception = exchange.getException();
        return payload;
    }
    /**
     * Transfers the information from the payload to the exchange.
     *
     * @param exchange   the exchange to set values from the payload
     * @param payload    the payload with the values
     */
    public static void unmarshal(Exchange exchange, MinaPayloadHolder payload) {
        exchange.getIn().setBody(payload.inBody);
        exchange.getOut().setBody(payload.outBody);
        exchange.getIn().setHeaders(payload.inHeaders);
        exchange.getOut().setHeaders(payload.outHeaders);
        for (String key : payload.properties.keySet()) {
            exchange.setProperty(key, payload.properties.get(key));
        }
        exchange.setException(payload.exception);
    }
    public String toString() {
        return ""MinaPayloadHolder{"" + ""inBody="" + inBody + "", outBody="" + outBody + "", inHeaders=""
               + inHeaders + "", outHeaders="" + outHeaders + "", properties="" + properties + "", exception=""
               + exception + '}';
    }
}
"
org.apache.camel.builder.sql.SQL,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.sql;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of SQL expressions into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""sql"")
public @interface SQL {
    String value();
}"
org.apache.camel.component.jms.requestor.ReplyHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import javax.jms.JMSException;
import javax.jms.Message;
/**
 * @version $Revision$
 */
public interface ReplyHandler {
    /**
     * Processes the message, returning true if this is the last method of a lifecycle
     * so that the handler can be discarded
     */
    boolean handle(Message message) throws JMSException;
}
"
org.apache.camel.component.jms.DestinationTransformProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
/**
 * A processor which is capable of transforming the
 *
 * @version $Revision$
 */
public class DestinationTransformProcessor {
}
"
org.apache.camel.component.cxf.interceptors.FakeBindingOperationInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.Collection;
import java.util.Collections;
import org.apache.cxf.service.model.BindingFaultInfo;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.service.model.ServiceInfo;
/**
 * This class is used to provide the BindingOperationInfo for
 * the FaultOutInterceptor which serves for the RawMessage DataFormat
 *
 */
public class FakeBindingOperationInfo extends BindingOperationInfo {
    public FakeBindingOperationInfo() {
        super();
    }
    public boolean isUnwrapped() {
        return false;
    }
}
"
org.apache.camel.language.jxpath.JXPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.jxpath;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.language.ExpressionEvaluationException;
import org.apache.commons.jxpath.CompiledExpression;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
/**
 * <a href=""http://commons.apache.org/jxpath/"">JXPath</a> {@link Expression} support 
 */
public class JXPathExpression extends ExpressionSupport<Exchange> {
    private String expression;
    private CompiledExpression compiledExpression;
    private final Class<?> type;
    /**
     * Creates a new JXPathExpression instance
     * 
     * @param expression the JXPath expression to be evaluated
     * @param type the expected result type
     */
    public JXPathExpression(String expression, Class<?> type) {
        super();
        this.expression = expression;
        this.type = type;
    }
    public Object evaluate(Exchange exchange) {
        try {
            JXPathContext context = JXPathContext.newContext(exchange);
            Object result = getJXPathExpression().getValue(context, type);
            assertResultType(exchange, result);
            return result;
        } catch (JXPathException e) {
            throw new ExpressionEvaluationException(this, exchange, e);
        }
    }
    /*
     * Check if the result is of the specified type
     */
    private void assertResultType(Exchange exchange, Object result) {
        if (result != null && !type.isAssignableFrom(result.getClass())) {
            throw new JXPathException(""JXPath result type is "" + result.getClass() + "" instead of required type "" + type);
        }
    }
    @Override
    protected String assertionFailureMessage(Exchange exchange) {
        return expression.toString();
    }
    /*
     * Get a compiled expression instance for better performance
     */
    private synchronized CompiledExpression getJXPathExpression() {
        if (compiledExpression == null) {
            compiledExpression = JXPathContext.compile(expression);
        }
        return compiledExpression;
    }
}
"
org.apache.camel.component.ResourceBasedComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
/**
 * A useful base class for components which depend on a resource
 * such as things like Velocity or XQuery based components.
 *
 * @version $Revision$
 */
public abstract class ResourceBasedComponent extends DefaultComponent<Exchange> {
    protected final transient Log log = LogFactory.getLog(getClass());
    private ResourceLoader resourceLoader = new DefaultResourceLoader();
    public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }
    protected Resource resolveMandatoryResource(String uri) {
        Resource resource = getResourceLoader().getResource(uri);
        if (resource == null) {
            throw new IllegalArgumentException(""Could not find resource for URI: "" + uri + "" using: "" + getResourceLoader());
        } else {
            return resource;
        }
    }
}
"
org.apache.camel.component.irc.IrcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/irc.html"">IRC Component</a>
 *
 * @version $Revision$
 */
public class IrcComponent extends DefaultComponent<IrcExchange> {
    private static final transient Log LOG = LogFactory.getLog(IrcComponent.class);
    private IrcConfiguration configuration;
    private final Map<String, IRCConnection> connectionCache = new HashMap<String, IRCConnection>();
    public IrcComponent() {
        configuration = new IrcConfiguration();
    }
    public IrcComponent(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
    public IrcComponent(CamelContext context) {
        super(context);
        configuration = new IrcConfiguration();
    }
    public static IrcComponent ircComponent() {
        return new IrcComponent();
    }
    protected IrcEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        IrcConfiguration config = getConfiguration().copy();
        config.configure(new URI(uri));
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        final IrcEndpoint endpoint = new IrcEndpoint(uri, this, config);
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public IrcConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
    public synchronized IRCConnection getIRCConnection(IrcConfiguration configuration) {
        final IRCConnection connection;
        if (connectionCache.containsKey(configuration.getCacheKey())) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Returning Cached Connection to "" + configuration.getHostname() + "" "" + configuration.getTarget());
            }
            connection = connectionCache.get(configuration.getCacheKey());
        } else {
            connection = createConnection(configuration);
            connectionCache.put(configuration.getCacheKey(), connection);
        }
        return connection;
    }
    protected IRCConnection createConnection(IrcConfiguration configuration) {
        LOG.debug(""Creating Connection to "" + configuration.getHostname() + "" destination: "" + configuration.getTarget() + "" nick: "" + configuration.getNickname() + "" user: ""
                  + configuration.getUsername());
        final IRCConnection conn = new IRCConnection(configuration.getHostname(), configuration.getPorts(), configuration.getPassword(), configuration.getNickname(), configuration.getUsername(),
                                                     configuration.getRealname());
        conn.setEncoding(""UTF-8"");
        // conn.setDaemon(true);
        conn.setColors(configuration.isColors());
        conn.setPong(true);
        try {
            conn.connect();
        } catch (Exception e) {
            LOG.error(""Failed to connect: "" + e, e);
            // TODO use checked exceptions?
            throw new RuntimeCamelException(e);
        }
        return conn;
    }
    public void closeConnection(String key, IRCConnection connection) {
        try {
            connection.doQuit();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected synchronized void doStop() throws Exception {
        // lets use a copy so we can clear the connections eagerly in case of
        // exceptions
        Map<String, IRCConnection> map = new HashMap<String, IRCConnection>(connectionCache);
        connectionCache.clear();
        for (Map.Entry<String, IRCConnection> entry : map.entrySet()) {
            closeConnection(entry.getKey(), entry.getValue());
        }
        super.doStop();
    }
}
"
org.apache.camel.builder.script.PHP,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of PHP expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""php"")
public @interface PHP {
    String value();
}"
org.apache.camel.component.jpa.JpaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Map;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.NoTypeConversionAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.springframework.orm.jpa.JpaTemplate;
/**
 * @version $Revision$
 */
public class JpaEndpoint extends ScheduledPollEndpoint<Exchange> {
    private EntityManagerFactory entityManagerFactory;
    private String persistenceUnit = ""camel"";
    private JpaTemplate template;
    private Expression<Exchange> producerExpression;
    private int maximumResults = -1;
    private Class<?> entityType;
    private Map entityManagerProperties;
    private boolean consumeDelete = true;
    private boolean consumeLockEntity = true;
    private boolean flushOnSend = true;
    public JpaEndpoint(String uri, JpaComponent component) {
        super(uri, component);
        entityManagerFactory = component.getEntityManagerFactory();
    }
    public JpaEndpoint(String endpointUri, EntityManagerFactory entityManagerFactory) {
        super(endpointUri);
        this.entityManagerFactory = entityManagerFactory;
    }
    public JpaEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<Exchange> createProducer() throws Exception {
        validate();
        return new JpaProducer(this, getProducerExpression());
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        validate();
        JpaConsumer consumer = new JpaConsumer(this, processor);
        configureConsumer(consumer);
        return consumer;
    }
    @Override
    public void configureProperties(Map options) {
        super.configureProperties(options);
        Map emProperties = IntrospectionSupport.extractProperties(options, ""emf."");
        if (emProperties != null) {
            setEntityManagerProperties(emProperties);
        }
    }
    public boolean isSingleton() {
        return false;
    }
    // Properties
    // -------------------------------------------------------------------------
    public JpaTemplate getTemplate() {
        if (template == null) {
            template = createTemplate();
        }
        return template;
    }
    public void setTemplate(JpaTemplate template) {
        this.template = template;
    }
    public Expression<Exchange> getProducerExpression() {
        if (producerExpression == null) {
            producerExpression = createProducerExpression();
        }
        return producerExpression;
    }
    public void setProducerExpression(Expression<Exchange> producerExpression) {
        this.producerExpression = producerExpression;
    }
    public int getMaximumResults() {
        return maximumResults;
    }
    public void setMaximumResults(int maximumResults) {
        this.maximumResults = maximumResults;
    }
    public Class<?> getEntityType() {
        return entityType;
    }
    public void setEntityType(Class<?> entityType) {
        this.entityType = entityType;
    }
    public EntityManagerFactory getEntityManagerFactory() {
        if (entityManagerFactory == null) {
            entityManagerFactory = createEntityManagerFactory();
        }
        return entityManagerFactory;
    }
    public void setEntityManagerFactory(EntityManagerFactory entityManagerFactory) {
        this.entityManagerFactory = entityManagerFactory;
    }
    public Map getEntityManagerProperties() {
        if (entityManagerProperties == null) {
            entityManagerProperties = System.getProperties();
        }
        return entityManagerProperties;
    }
    public void setEntityManagerProperties(Map entityManagerProperties) {
        this.entityManagerProperties = entityManagerProperties;
    }
    public String getPersistenceUnit() {
        return persistenceUnit;
    }
    public void setPersistenceUnit(String persistenceUnit) {
        this.persistenceUnit = persistenceUnit;
    }
    public boolean isConsumeDelete() {
        return consumeDelete;
    }
    public void setConsumeDelete(boolean consumeDelete) {
        this.consumeDelete = consumeDelete;
    }
    public boolean isConsumeLockEntity() {
        return consumeLockEntity;
    }
    public void setConsumeLockEntity(boolean consumeLockEntity) {
        this.consumeLockEntity = consumeLockEntity;
    }
    public boolean isFlushOnSend() {
        return flushOnSend;
    }
    public void setFlushOnSend(boolean flushOnSend) {
        this.flushOnSend = flushOnSend;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void validate() {
        ObjectHelper.notNull(getEntityManagerFactory(), ""entityManagerFactory property"");
    }
    protected JpaTemplate createTemplate() {
        return new JpaTemplate(getEntityManagerFactory());
    }
    protected EntityManagerFactory createEntityManagerFactory() {
        return Persistence.createEntityManagerFactory(persistenceUnit, getEntityManagerProperties());
    }
    protected EntityManager createEntityManager() {
        return getEntityManagerFactory().createEntityManager();
    }
    protected TransactionStrategy createTransactionStrategy() {
        EntityManagerFactory emf = getEntityManagerFactory();
        return JpaTemplateTransactionStrategy.newInstance(emf, getTemplate());
        // return new DefaultTransactionStrategy(emf);
    }
    protected Expression<Exchange> createProducerExpression() {
        final Class<?> type = getEntityType();
        if (type == null) {
            return ExpressionBuilder.bodyExpression();
        } else {
            return new Expression<Exchange>() {
                public Object evaluate(Exchange exchange) {
                    Object answer = exchange.getIn().getBody(type);
                    if (answer == null) {
                        Object defaultValue = exchange.getIn().getBody();
                        if (defaultValue != null) {
                            throw new NoTypeConversionAvailableException(defaultValue, type);
                        }
                        // if we don't have a body then
                        // lets instantiate and inject a new instance
                        answer = exchange.getContext().getInjector().newInstance(type);
                    }
                    return answer;
                }
            };
        }
    }
}
"
org.apache.camel.language.juel.JuelExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import java.util.Properties;
import javax.el.ArrayELResolver;
import javax.el.CompositeELResolver;
import javax.el.ELContext;
import javax.el.ELResolver;
import javax.el.ExpressionFactory;
import javax.el.ListELResolver;
import javax.el.MapELResolver;
import javax.el.ResourceBundleELResolver;
import javax.el.ValueExpression;
import de.odysseus.el.util.SimpleContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.impl.ExpressionSupport;
/**
 * The <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
 * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
 *
 * @version $Revision$
 */
public class JuelExpression extends ExpressionSupport<Exchange> {
    private final String expression;
    private final Class<?> type;
    private ExpressionFactory expressionFactory;
    private Properties expressionFactoryProperties;
    public JuelExpression(String expression, Class<?> type) {
        this.expression = expression;
        this.type = type;
    }
    public static JuelExpression el(String expression) {
        return new JuelExpression(expression, Object.class);
    }
    public Object evaluate(Exchange exchange) {
        // TODO we could use caching here but then we'd have possible concurrency issues
        // so lets assume that the provider caches
        ELContext context = populateContext(createContext(), exchange);
        ValueExpression valueExpression = getExpressionFactory().createValueExpression(context, expression, type);
        return valueExpression.getValue(context);
    }
    public ExpressionFactory getExpressionFactory() {
        if (expressionFactory == null) {
            Properties properties = getExpressionFactoryProperties();
            expressionFactory = ExpressionFactory.newInstance(properties);
        }
        return expressionFactory;
    }
    public void setExpressionFactory(ExpressionFactory expressionFactory) {
        this.expressionFactory = expressionFactory;
    }
    public Properties getExpressionFactoryProperties() {
        if (expressionFactoryProperties == null) {
            expressionFactoryProperties = new Properties();
            populateDefaultExpressionProperties(expressionFactoryProperties);
        }
        return expressionFactoryProperties;
    }
    public void setExpressionFactoryProperties(Properties expressionFactoryProperties) {
        this.expressionFactoryProperties = expressionFactoryProperties;
    }
    protected ELContext populateContext(ELContext context, Exchange exchange) {
        setVariable(context, ""exchange"", exchange, Exchange.class);
        setVariable(context, ""in"", exchange.getIn(), Message.class);
        Message out = exchange.getOut(false);
        setVariable(context, ""out"", out, Message.class);
        return context;
    }
    /**
     * A Strategy Method to populate the default properties used to create the expression factory
     */
    protected void populateDefaultExpressionProperties(Properties properties) {
        // lets enable method invocations
        properties.setProperty(""javax.el.methodInvocations"", ""true"");
    }
    protected void setVariable(ELContext context, String name, Object value, Class<?> type) {
        ValueExpression valueExpression = getExpressionFactory().createValueExpression(value, type);
        SimpleContext simpleContext = (SimpleContext) context;
        simpleContext.setVariable(name, valueExpression);
    }
    /**
     * Factory method to create the EL context
     */
    protected ELContext createContext() {
        ELResolver resolver = new CompositeELResolver() {
            {
                //add(methodResolver);
                add(new ArrayELResolver(false));
                add(new ListELResolver(false));
                add(new MapELResolver(false));
                add(new ResourceBundleELResolver());
                add(new BeanAndMethodELResolver());
            }
        };
        return new SimpleContext(resolver);
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return expression;
    }
}
"
org.apache.camel.component.velocity.VelocityComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.velocity;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.velocity.app.VelocityEngine;
/**
 * @version $Revision$
 */
public class VelocityComponent extends DefaultComponent {
    private VelocityEngine velocityEngine = new VelocityEngine();
    public VelocityEngine getVelocityEngine() {
        return velocityEngine;
    }
    public void setVelocityEngine(VelocityEngine velocityEngine) {
        this.velocityEngine = velocityEngine;
    }
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new VelocityEndpoint(uri, this, remaining, parameters);
    }
}
"
org.apache.camel.component.stream.StreamEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.nio.charset.Charset;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class StreamEndpoint extends DefaultEndpoint<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(StreamEndpoint.class);
    private String uri;
    private String file;
    private String url;
    private long delay;
    private String encoding;
    public StreamEndpoint(String endpointUri, Component component) throws Exception {
        super(endpointUri, component);
        this.uri = endpointUri;
    }
    public StreamEndpoint(String endpointUri) {
        super(endpointUri);
        this.uri = endpointUri;
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new StreamConsumer(this, processor, uri);
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new StreamProducer(this, uri);
    }
    public boolean isSingleton() {
        return true;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getFile() {
        return file;
    }
    /**
     * @deprecated use camel-file component. Will be removed in Camel 2.0
     */
    public void setFile(String file) {
        this.file = file;
    }
    public String getUrl() {
        return url;
    }
    /**
     * @deprecated use camel-jetty or camel-http component. Will be removed in Camel 2.0
     */
    public void setUrl(String url) {
        this.url = url;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public String getEncoding() {
        return encoding;
    }
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }
    // Implementations
    //-------------------------------------------------------------------------
    Charset getCharset() {
        if (encoding == null) {
            encoding = Charset.defaultCharset().name();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""No encoding parameter using default charset: "" + encoding);
            }
        }
        if (!Charset.isSupported(encoding)) {
            throw new IllegalArgumentException(""The encoding: "" + encoding + "" is not supported"");
        }
        return Charset.forName(encoding);
    }
}
"
org.apache.camel.component.cxf.util.WSDLSoapServiceFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import javax.xml.namespace.QName;
import org.apache.cxf.binding.AbstractBindingFactory;
import org.apache.cxf.binding.soap.interceptor.CheckFaultInterceptor;
import org.apache.cxf.binding.soap.interceptor.MustUnderstandInterceptor;
import org.apache.cxf.binding.soap.interceptor.ReadHeadersInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapActionInInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapActionOutInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapHeaderInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapHeaderOutFilterInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapOutInterceptor;
import org.apache.cxf.binding.soap.interceptor.SoapPreProtocolOutInterceptor;
import org.apache.cxf.interceptor.AttachmentInInterceptor;
import org.apache.cxf.interceptor.AttachmentOutInterceptor;
import org.apache.cxf.interceptor.StaxInInterceptor;
import org.apache.cxf.interceptor.StaxOutInterceptor;
import org.apache.cxf.interceptor.URIMappingInterceptor;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.service.model.ServiceInfo;
import org.apache.cxf.wsdl11.WSDLServiceFactory;
//The service factorybean which just create the service for soap component
public class WSDLSoapServiceFactoryBean extends ReflectionServiceFactoryBean {
    private QName serviceName;
    private QName endpointName;
    @Override
    public Service create() {
        WSDLServiceFactory factory = new WSDLServiceFactory(getBus(), getWsdlURL(), getServiceQName());
        setService(factory.create());
        initializeSoapInterceptors();
        //disable the date interceptors
        updateEndpointInfors();
        createEndpoints();
        return getService();
    }
    private void updateEndpointInfors() {
        Service service = getService();
        for (ServiceInfo inf : service.getServiceInfos()) {
            for (EndpointInfo ei : inf.getEndpoints()) {
                //setup the endpoint address
                ei.setAddress(""local://"" + ei.getService().getName().toString() + ""/"" + ei.getName().getLocalPart());
                // working as the dispatch mode, the binding factory will not add interceptor
                ei.getBinding().setProperty(AbstractBindingFactory.DATABINDING_DISABLED, Boolean.TRUE);
            }
        }
    }
    // do not handle any payload information here
    private void initializeSoapInterceptors() {
        getService().getInInterceptors().add(new DataInInterceptor());
        getService().getInInterceptors().add(new ReadHeadersInterceptor(getBus()));
        getService().getInInterceptors().add(new MustUnderstandInterceptor());
        getService().getInInterceptors().add(new AttachmentInInterceptor());
        getService().getInInterceptors().add(new SoapHeaderInterceptor());
        getService().getInInterceptors().add(new CheckFaultInterceptor());
        getService().getInInterceptors().add(new URIMappingInterceptor());
        getService().getInInterceptors().add(new StaxInInterceptor());
        getService().getInInterceptors().add(new SoapActionInInterceptor());
        getService().getOutInterceptors().add(new DataOutInterceptor());
        getService().getOutInterceptors().add(new SoapActionOutInterceptor());
        getService().getOutInterceptors().add(new AttachmentOutInterceptor());
        getService().getOutInterceptors().add(new StaxOutInterceptor());
        getService().getOutInterceptors().add(new SoapHeaderOutFilterInterceptor());
        getService().getOutInterceptors().add(new SoapPreProtocolOutInterceptor());
        getService().getOutInterceptors().add(new SoapOutInterceptor(getBus()));
        getService().getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));
    }
    public void setServiceName(QName name) {
        serviceName = name;
    }
    public String getServiceName() {
        return serviceName.toString();
    }
    public QName getServiceQName() {
        return serviceName;
    }
    public QName getEndpointName() {
        // get the endpoint name if it is not set
        if (endpointName == null) {
            endpointName = getService().getEndpoints().keySet().iterator().next();
        }
        return endpointName;
    }
    public void setEndpointName(QName name) {
        endpointName = name;
    }
}
"
org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.logging.Logger;
import org.apache.camel.component.cxf.interceptors.DOMInInterceptor;
import org.apache.camel.component.cxf.interceptors.DOMOutInterceptor;
import org.apache.camel.component.cxf.interceptors.FaultOutInterceptor;
import org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor;
import org.apache.cxf.Bus;
import org.apache.cxf.binding.Binding;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.phase.Phase;
/**
 * This feature just setting up the CXF endpoint interceptor for handling the
 * Message in PAYLOAD data format
 */
public class PayLoadDataFormatFeature extends AbstractDataFormatFeature {
    private static final Logger LOG = LogUtils.getL7dLogger(PayLoadDataFormatFeature.class);
    // filter the unused phase
    private static final String[] REMOVING_IN_PHASES = {Phase.UNMARSHAL, Phase.PRE_LOGICAL, Phase.PRE_LOGICAL_ENDING, Phase.POST_LOGICAL, Phase.POST_LOGICAL_ENDING };
    private static final String[] REMOVING_OUT_PHASES = {Phase.MARSHAL, Phase.MARSHAL_ENDING, Phase.PRE_LOGICAL, Phase.PRE_LOGICAL_ENDING, Phase.POST_LOGICAL, Phase.POST_LOGICAL_ENDING };
    @Override
    public void initialize(Client client, Bus bus) {
        removeInterceptorWhichIsInThePhases(client.getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getService().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getBinding().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(client.getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getService().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(client.getEndpoint().getBinding().getOutInterceptors(), REMOVING_OUT_PHASES);
        addDataHandlingInterceptors(client.getEndpoint().getBinding());
        client.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
    }
    @Override
    public void initialize(Server server, Bus bus) {
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getService().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getBinding().getInInterceptors(), REMOVING_IN_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getService().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getOutInterceptors(), REMOVING_OUT_PHASES);
        removeInterceptorWhichIsInThePhases(server.getEndpoint().getBinding().getOutInterceptors(), REMOVING_OUT_PHASES);
        // set the invoker interceptor
        resetServiceInvokerInterceptor(server);
        addDataHandlingInterceptors(server.getEndpoint().getBinding());
        server.getEndpoint().getBinding().getOutFaultInterceptors().add(new FaultOutInterceptor());
    }
    private void addDataHandlingInterceptors(Binding binding) {
        binding.getInInterceptors().add(new DOMInInterceptor());
        binding.getOutInterceptors().add(new DOMOutInterceptor());
        binding.getOutInterceptors().add(new PayloadContentRedirectInterceptor());
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.component.http.HttpMethods,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.DeleteMethod;
import org.apache.commons.httpclient.methods.EntityEnclosingMethod;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.HeadMethod;
import org.apache.commons.httpclient.methods.OptionsMethod;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.methods.PutMethod;
import org.apache.commons.httpclient.methods.TraceMethod;
public enum HttpMethods implements Expression<Exchange> {
    GET(GetMethod.class), POST(PostMethod.class), PUT(PutMethod.class), DELETE(DeleteMethod.class), HEAD(
        HeadMethod.class), OPTIONS(OptionsMethod.class), TRACE(TraceMethod.class);
    public static final String HTTP_METHOD = ""http.requestMethod"";
    final Class<? extends HttpMethod> clazz;
    final boolean entity;
    HttpMethods(Class<? extends HttpMethod> clazz) {
        this.clazz = clazz;
        entity = EntityEnclosingMethod.class.isAssignableFrom(clazz);
    }
    public HttpMethod createMethod(final String url) {
        try {
            return clazz.getDeclaredConstructor(String.class).newInstance(url);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public HttpMethod createMethod() {
        try {
            return clazz.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public final boolean isEntityEnclosing() {
        return entity;
    }
    public Object evaluate(Exchange exchange) {
        return ExpressionBuilder.constantExpression(name()).evaluate(exchange);
    }
}
"
org.apache.camel.component.jms.requestor.Requestor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ScheduledExecutorService;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.Session;
import javax.jms.TemporaryQueue;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.camel.component.jms.JmsProducer;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.DefaultTimeoutMap;
import org.apache.camel.util.TimeoutMap;
import org.apache.camel.util.UuidGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer102;
import org.springframework.jms.support.destination.DestinationResolver;
/**
 * @version $Revision$
 */
public class Requestor extends ServiceSupport implements MessageListener {
    private static final transient Log LOG = LogFactory.getLog(Requestor.class);
    private static UuidGenerator uuidGenerator;
    private final JmsConfiguration configuration;
    private ScheduledExecutorService executorService;
    private AbstractMessageListenerContainer listenerContainer;
    private TimeoutMap requestMap;
    private Map<JmsProducer, DeferredRequestReplyMap> producerDeferredRequestReplyMap;
    private TimeoutMap deferredRequestMap;
    private TimeoutMap deferredReplyMap;
    private Destination replyTo;
    private long maxRequestTimeout = -1;
    private long replyToResolverTimeout = 5000;
    public Requestor(JmsConfiguration configuration, ScheduledExecutorService executorService) {
        this.configuration = configuration;
        this.executorService = executorService;
        requestMap = new DefaultTimeoutMap(executorService, configuration.getRequestMapPurgePollTimeMillis());
        producerDeferredRequestReplyMap = new HashMap<JmsProducer, DeferredRequestReplyMap>();
        deferredRequestMap = new DefaultTimeoutMap(executorService, configuration.getRequestMapPurgePollTimeMillis());
        deferredReplyMap = new DefaultTimeoutMap(executorService, configuration.getRequestMapPurgePollTimeMillis());
    }
    public synchronized DeferredRequestReplyMap getDeferredRequestReplyMap(JmsProducer producer) {
        DeferredRequestReplyMap map = producerDeferredRequestReplyMap.get(producer);
        if (map == null) {
            map = new DeferredRequestReplyMap(this, producer, deferredRequestMap, deferredReplyMap);
            producerDeferredRequestReplyMap.put(producer, map);
            if (maxRequestTimeout == -1) {
                maxRequestTimeout = producer.getRequestTimeout();
            } else if (maxRequestTimeout < producer.getRequestTimeout()) {
                maxRequestTimeout = producer.getRequestTimeout();
            }
        }
        return map;
    }
    public synchronized void removeDeferredRequestReplyMap(JmsProducer producer) {
        DeferredRequestReplyMap map = producerDeferredRequestReplyMap.remove(producer);
        if (map == null) {
            // already removed;
            return;
        }
        if (maxRequestTimeout == producer.getRequestTimeout()) {
            long max = -1;
            for (Map.Entry<JmsProducer, DeferredRequestReplyMap> entry : producerDeferredRequestReplyMap.entrySet()) {
                if (max < entry.getKey().getRequestTimeout()) {
                    max = entry.getKey().getRequestTimeout();
                }
            }
            maxRequestTimeout = max;
        }
    }
    public synchronized long getMaxRequestTimeout() {
        return maxRequestTimeout;
    }
    public TimeoutMap getRequestMap() {
        return requestMap;
    }
    public TimeoutMap getDeferredRequestMap() {
        return deferredRequestMap;
    }
    public TimeoutMap getDeferredReplyMap() {
        return deferredReplyMap;
    }
    public FutureTask getReceiveFuture(String correlationID, long requestTimeout) {
        FutureHandler future = createFutureHandler(correlationID);
        requestMap.put(correlationID, future, requestTimeout);
        return future;
    }
    public FutureTask getReceiveFuture(DeferredMessageSentCallback callback) {
        FutureHandler future = createFutureHandler(callback);
        DeferredRequestReplyMap map = callback.getDeferredRequestReplyMap();
        map.put(callback, future);
        return future;
    }
    protected FutureHandler createFutureHandler(String correlationID) {
        return new FutureHandler();
    }
    protected FutureHandler createFutureHandler(DeferredMessageSentCallback callback) {
        return new FutureHandler();
    }
    public void onMessage(Message message) {
        try {
            String correlationID = message.getJMSCorrelationID();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Message correlationID: "" + correlationID);
            }
            if (correlationID == null) {
                LOG.warn(""Ignoring message with no correlationID! "" + message);
                return;
            }
            // lets notify the monitor for this response
            Object handler = requestMap.get(correlationID);
            if (handler != null && handler instanceof ReplyHandler) {
                ReplyHandler replyHandler = (ReplyHandler) handler;
                boolean complete = replyHandler.handle(message);
                if (complete) {
                    requestMap.remove(correlationID);
                }
            } else {
                DeferredRequestReplyMap.processDeferredRequests(
                        this, deferredRequestMap, deferredReplyMap,
                        correlationID, getMaxRequestTimeout(), message);
            }
        } catch (JMSException e) {
            throw new FailedToProcessResponse(message, e);
        }
    }
    public AbstractMessageListenerContainer getListenerContainer() {
        if (listenerContainer == null) {
            listenerContainer = createListenerContainer();
        }
        return listenerContainer;
    }
    public void setListenerContainer(AbstractMessageListenerContainer listenerContainer) {
        this.listenerContainer = listenerContainer;
    }
    public Destination getReplyTo() {
        synchronized (this) {
            try {
                if (replyTo == null) {
                    wait(replyToResolverTimeout);
                }
            } catch (Throwable e) {
                // eat it
            }
        }
        return replyTo;
    }
    public void setReplyTo(Destination replyTo) {
        this.replyTo = replyTo;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void doStart() throws Exception {
        AbstractMessageListenerContainer container = getListenerContainer();
        container.afterPropertiesSet();
    }
    @Override
    protected void doStop() throws Exception {
        if (listenerContainer != null) {
            listenerContainer.stop();
            listenerContainer.destroy();
        }
    }
    protected Requestor getOutterInstance() {
        return this;
    }
    protected AbstractMessageListenerContainer createListenerContainer() {
        SimpleMessageListenerContainer answer = configuration.isUseVersion102()
            ? new SimpleMessageListenerContainer102() : new SimpleMessageListenerContainer();
        answer.setDestinationName(""temporary"");
        answer.setDestinationResolver(new DestinationResolver() {
            public Destination resolveDestinationName(Session session, String destinationName,
                                                      boolean pubSubDomain) throws JMSException {
                TemporaryQueue queue = null;
                synchronized (getOutterInstance()) {
                    try {
                        queue = session.createTemporaryQueue();
                        setReplyTo(queue);
                    } finally {
                        getOutterInstance().notifyAll();
                    }
                }
                return queue;
            }
        });
        answer.setAutoStartup(true);
        answer.setMessageListener(this);
        answer.setPubSubDomain(false);
        answer.setSubscriptionDurable(false);
        answer.setConcurrentConsumers(1);
        answer.setConnectionFactory(configuration.getConnectionFactory());
        String clientId = configuration.getClientId();
        if (clientId != null) {
            clientId += "".Requestor"";
            answer.setClientId(clientId);
        }
        TaskExecutor taskExecutor = configuration.getTaskExecutor();
        if (taskExecutor != null) {
            answer.setTaskExecutor(taskExecutor);
        }
        ExceptionListener exceptionListener = configuration.getExceptionListener();
        if (exceptionListener != null) {
            answer.setExceptionListener(exceptionListener);
        }
        return answer;
    }
    public static synchronized UuidGenerator getUuidGenerator() {
        if (uuidGenerator == null) {
            uuidGenerator = new UuidGenerator();
        }
        return uuidGenerator;
    }
    protected JmsConfiguration getConfiguration() {
        return configuration;
    }
    public void setReplyToSelectorHeader(org.apache.camel.Message in, Message jmsIn) throws JMSException {
        // complete
    }
}
"
org.apache.camel.builder.script.BeanShell,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of BeanShell expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""beanshell"")
public @interface BeanShell {
    String value();
}"
org.apache.camel.component.cxf.CxfSoapProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.OutputStream;
import javax.xml.transform.Source;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.component.cxf.util.Dummy;
import org.apache.camel.component.cxf.util.NullConduit;
import org.apache.camel.component.cxf.util.NullConduitSelector;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.interceptor.InterceptorChain;
import org.apache.cxf.interceptor.OutgoingChainInterceptor;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
/**
 * A CXF based soap provider.
 * The consumer will delegate to another endpoint for the transport layer
 * and will provide SOAP support on top of it.
 */
public class CxfSoapProducer implements Producer, AsyncProcessor {
    private static final Log LOG = LogFactory.getLog(CxfSoapProducer.class);
    private final CxfSoapEndpoint endpoint;
    private final Producer producer;
    private final AsyncProcessor processor;
    private ClientImpl client;
    public CxfSoapProducer(CxfSoapEndpoint endpoint) throws Exception {
        this.endpoint = endpoint;
        this.producer = endpoint.getInnerEndpoint().createProducer();
        this.processor = new AsyncProcessorDecorator(producer,
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapProviderIn(exchange);
                    }
                },
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapProviderOut(exchange);
                    }
                });
        //create the endpoint and setup the interceptors
        Class sei = CxfEndpointUtils.getSEIClass(endpoint.getServiceClass());
        ClientFactoryBean cfb = CxfEndpointUtils.getClientFactoryBean(sei);
        if (sei == null) {
            cfb.setServiceClass(Dummy.class);
        } else {
            cfb.setServiceClass(sei);
        }
        cfb.setWsdlURL(endpoint.getWsdl().getURL().toString());
        if (endpoint.getServiceName() != null) {
            cfb.setServiceName(endpoint.getServiceName());
        }
        if (endpoint.getEndpointName() != null) {
            cfb.setEndpointName(endpoint.getEndpointName());
        }
        cfb.setConduitSelector(new NullConduitSelector());
        client = (ClientImpl) cfb.create();
    }
    public org.apache.camel.Endpoint getEndpoint() {
        return producer.getEndpoint();
    }
    public Exchange createExchange() {
        return producer.createExchange();
    }
    public Exchange createExchange(ExchangePattern pattern) {
        return producer.createExchange(pattern);
    }
    public Exchange createExchange(Exchange exchange) {
        return producer.createExchange(exchange);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        return processor.process(exchange, callback);
    }
    public void start() throws Exception {
        producer.start();
    }
    public void stop() throws Exception {
        producer.stop();
    }
    protected void processSoapProviderOut(Exchange exchange) throws Exception {
        LOG.info(""processSoapProviderOut: "" + exchange);
        org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(exchange, true);
        client.setInInterceptors(client.getEndpoint().getService().getInInterceptors());
        client.onMessage(inMessage);
        exchange.getOut().setBody(inMessage.getContent(Source.class));
        exchange.getOut().setHeaders(inMessage);
    }
    protected Bus getBus() {
        return endpoint.getBus();
    }
    protected void processSoapProviderIn(Exchange exchange) throws Exception {
        LOG.info(""processSoapProviderIn: "" + exchange);
        org.apache.cxf.endpoint.Endpoint cxfEndpoint = client.getEndpoint();
        org.apache.cxf.message.Exchange cxfExchange = new ExchangeImpl();
        cxfExchange.put(org.apache.cxf.endpoint.Endpoint.class, cxfEndpoint);
        cxfExchange.put(Bus.class, getBus());
        cxfExchange.setConduit(new NullConduit());
        exchange.setProperty(CxfConstants.CXF_EXCHANGE, cxfExchange);
        org.apache.cxf.message.Message outMessage = CxfSoapBinding.getCxfOutMessage(exchange, true);
        outMessage.put(Message.REQUESTOR_ROLE, Boolean.TRUE);
        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        InterceptorChain chain = OutgoingChainInterceptor.getOutInterceptorChain(cxfExchange);
        outMessage.setInterceptorChain(chain);
        chain.doIntercept(outMessage);
        CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);
        exchange.getOut().setBody(outputStream.getInputStream());
        exchange.getIn().setBody(outputStream.getInputStream());
    }
}
"
org.apache.camel.component.mina.MinaConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
import org.apache.mina.common.ByteBuffer;
/**
 * A set of converter methods for working with MINA types
 *
 * @version $Revision$
 */
@Converter
public final class MinaConverter {
    private MinaConverter() {
        //Utility Class
    }
    @Converter
    public static byte[] toByteArray(ByteBuffer buffer) {
        byte[] answer = new byte[buffer.remaining()];
        try {
            // must acquire the Byte buffer to avoid release if more than twice
            buffer.acquire();
        } catch (IllegalStateException ex) {
            // catch the exception if we acquire the buffer which is already released.
        }
        buffer.get(answer);
        return answer;
    }
    @Converter
    public static String toString(ByteBuffer buffer) {
        // TODO: CAMEL-381, we should have type converters to strings that accepts a Charset parameter to handle encoding
        return IOConverter.toString(toByteArray(buffer));
    }
    @Converter
    public static InputStream toInputStream(ByteBuffer buffer) {
        return buffer.asInputStream();
    }
    @Converter
    public static ObjectInput toObjectInput(ByteBuffer buffer) throws IOException {
        return IOConverter.toObjectInput(toInputStream(buffer));
    }
    @Converter
    public static ByteBuffer toByteBuffer(byte[] bytes) {
        ByteBuffer buf = ByteBuffer.allocate(bytes.length);
        buf.put(bytes);
        return buf;
    }
}
"
org.apache.camel.component.jms.JmsConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.MessageListener;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
/**
 * A {@link Consumer} which uses Spring's {@link AbstractMessageListenerContainer} implementations to consume JMS messages
 *
 * @version $Revision$
 */
public class JmsConsumer extends DefaultConsumer<JmsExchange> {
    private final AbstractMessageListenerContainer listenerContainer;
    private EndpointMessageListener messageListener;
    public JmsConsumer(JmsEndpoint endpoint, Processor processor, AbstractMessageListenerContainer listenerContainer) {
        super(endpoint, processor);
        this.listenerContainer = listenerContainer;
        createMessageListener(endpoint, processor);
        this.listenerContainer.setMessageListener(messageListener);
    }
    public AbstractMessageListenerContainer getListenerContainer() {
        return listenerContainer;
    }
    public EndpointMessageListener getEndpointMessageListener() {
        return messageListener;
    }
    protected void createMessageListener(JmsEndpoint endpoint, Processor processor) {
        messageListener = new EndpointMessageListener(endpoint, processor);
        messageListener.setBinding(endpoint.getBinding());
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        listenerContainer.afterPropertiesSet();
        listenerContainer.start();
    }
    @Override
    protected void doStop() throws Exception {
        listenerContainer.stop();
        listenerContainer.destroy();
        super.doStop();
    }
}
"
org.apache.camel.component.irc.IrcConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
import org.schwering.irc.lib.IRCEventAdapter;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
public class IrcConsumer extends DefaultConsumer<IrcExchange> {
    private static final transient Log LOG = LogFactory.getLog(IrcConsumer.class);
    private final IrcConfiguration configuration;
    private final IrcEndpoint endpoint;
    private final IRCConnection connection;
    private FilteredIRCEventAdapter listener;
    public IrcConsumer(IrcEndpoint endpoint, Processor processor, IRCConnection connection) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.connection = connection;
        configuration = endpoint.getConfiguration();
    }
    @Override
    protected void doStop() throws Exception {
        String target = endpoint.getConfiguration().getTarget();
        connection.doPart(target);
        connection.removeIRCEventListener(listener);
        super.doStop();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        String target = endpoint.getConfiguration().getTarget();
        connection.addIRCEventListener(new FilteredIRCEventAdapter(target));
        LOG.debug(""joining: "" + target);
        connection.doJoin(target);
    }
    public IRCConnection getConnection() {
        return connection;
    }
    class FilteredIRCEventAdapter extends IRCEventAdapter {
        final String target;
        public FilteredIRCEventAdapter(String target) {
            this.target = target;
        }
        @Override
        public void onNick(IRCUser user, String newNick) {
            if (configuration.isOnNick()) {
                IrcExchange exchange = endpoint.createOnNickExchange(user, newNick);
                try {
                    getProcessor().process(exchange);
                } catch (Exception e) {
                    // TODO: what should we do when a processing failure
                    // occurs??
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void onQuit(IRCUser user, String msg) {
            if (configuration.isOnQuit()) {
                IrcExchange exchange = endpoint.createOnQuitExchange(user, msg);
                try {
                    getProcessor().process(exchange);
                } catch (Exception e) {
                    // TODO: what should we do when a processing failure
                    // occurs??
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void onJoin(String channel, IRCUser user) {
            if (configuration.isOnJoin()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnJoinExchange(channel, user);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onKick(String channel, IRCUser user, String passiveNick, String msg) {
            if (configuration.isOnKick()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnKickExchange(channel, user, passiveNick, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onMode(String channel, IRCUser user, IRCModeParser modeParser) {
            if (configuration.isOnMode()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnModeExchange(channel, user, modeParser);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onPart(String channel, IRCUser user, String msg) {
            if (configuration.isOnPart()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnPartExchange(channel, user, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onTopic(String channel, IRCUser user, String topic) {
            if (configuration.isOnTopic()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnTopicExchange(channel, user, topic);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onPrivmsg(String target, IRCUser user, String msg) {
            if (configuration.isOnPrivmsg()) {
                if (target.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnPrivmsgExchange(target, user, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
"
org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent.jpa;
import java.util.List;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * @version $Revision$
 */
public class JpaMessageIdRepository implements MessageIdRepository {
    protected static final String QUERY_STRING = ""select x from "" + MessageProcessed.class.getName() + "" x where x.processorName = ?1 and x.messageId = ?2"";
    private JpaTemplate jpaTemplate;
    private String processorName;
    private TransactionTemplate transactionTemplate;
    public JpaMessageIdRepository(JpaTemplate template, String processorName) {
        this(template, createTransactionTemplate(template), processorName);
    }
    public JpaMessageIdRepository(JpaTemplate template, TransactionTemplate transactionTemplate, String processorName) {
        this.jpaTemplate = template;
        this.processorName = processorName;
        this.transactionTemplate = transactionTemplate;
    }
    public static JpaMessageIdRepository jpaMessageIdRepository(String persistenceUnit, String processorName) {
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(persistenceUnit);
        return jpaMessageIdRepository(new JpaTemplate(entityManagerFactory), processorName);
    }
    public static JpaMessageIdRepository jpaMessageIdRepository(JpaTemplate jpaTemplate, String processorName) {
        return new JpaMessageIdRepository(jpaTemplate, processorName);
    }
    private static TransactionTemplate createTransactionTemplate(JpaTemplate jpaTemplate) {
        TransactionTemplate transactionTemplate = new TransactionTemplate();
        transactionTemplate.setTransactionManager(new JpaTransactionManager(jpaTemplate.getEntityManagerFactory()));
        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        return transactionTemplate;
    }
    public boolean contains(final String messageId) {
        // Run this in single transaction.
        Boolean rc = (Boolean)transactionTemplate.execute(new TransactionCallback() {
            public Object doInTransaction(TransactionStatus arg0) {
                List list = jpaTemplate.find(QUERY_STRING, processorName, messageId);
                if (list.isEmpty()) {
                    MessageProcessed processed = new MessageProcessed();
                    processed.setProcessorName(processorName);
                    processed.setMessageId(messageId);
                    jpaTemplate.persist(processed);
                    jpaTemplate.flush();
                    return Boolean.FALSE;
                } else {
                    return Boolean.TRUE;
                }
            }
        });
        return rc.booleanValue();
    }
}
"
org.apache.camel.converter.jaxb.MessageType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlMixed;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Message;
/**
 * Represents a JAXB2 representation of a Camel {@link Message} - <b>Important</b>: work in progress!
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""message"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class MessageType {
    // TODO: XmlElementRef to the abstrac class HeaderType does not work (CAMEL-583)
    //@XmlElementRef(type = HeaderType.class)
    @XmlAnyElement(lax = true)
    @XmlMixed
    List<HeaderType> headers = new ArrayList<HeaderType>();
    @XmlAnyElement(lax = true)
    @XmlMixed
    private List content = new ArrayList();
    @XmlTransient
    private Object body;
    public Object getBody() {
        if (body == null) {
            if (content != null) {
                if (content.size() == 1) {
                    return content.get(0);
                } else {
                    return content;
                }
            }
        }
        return body;
    }
    public void setBody(Object body) {
        this.body = body;
        if (body instanceof List) {
            content = (List)body;
        } else {
            content = new ArrayList();
            content.add(body);
        }
    }
    public List<HeaderType> getHeaders() {
        return headers;
    }
    public void setHeaders(List<HeaderType> headers) {
        this.headers = headers;
    }
    public Map<String, Object> getHeaderMap() {
        Map<String, Object> answer = new HashMap<String, Object>();
        for (HeaderType header : headers) {
            answer.put(header.getName(), header.getValue());
        }
        return answer;
    }
    /**
     * Copies the headers and body of this object from the given Camel message
     *
     * @param message the Camel message to read the headers and body from
     */
    public void copyFrom(Message message) {
        headers.clear();
        Set<Map.Entry<String, Object>> entries = message.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            Object value = entry.getValue();
            if (value != null) {
                headers.add(createHeader(entry.getKey(), value));
            }
        }
        setBody(message.getBody());
    }
    /**
     * Copies the headers and body of this object to the given Camel message
     *
     * @param message the camel message to overwrite its headers and body
     */
    public void copyTo(Message message) {
        message.setHeaders(getHeaderMap());
        message.setBody(getBody());
    }
    protected HeaderType createHeader(String key, Object value) {
        if (value instanceof String) {
            return new StringHeader(key, (String)value);
        } else if (value instanceof Integer) {
            return new IntegerHeader(key, (Integer)value);
        } else if (value instanceof Long) {
            return new LongHeader(key, (Long)value);
        } else {
            // lets convert to a String
            return new StringHeader(key, value.toString());
            //return new ObjectHeader(key, value);
        }
    }
}
"
org.apache.camel.component.http.HttpPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.http.helper.LoadingByteArrayOutputStream;
import org.apache.camel.impl.PollingConsumerSupport;
import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.io.IOUtils;
/**
 * A polling HTTP consumer which by default performs a GET
 *
 * @version $Revision$
 */
public class HttpPollingConsumer extends PollingConsumerSupport<HttpExchange> {
    private final HttpEndpoint endpoint;
    private HttpClient httpClient;
    public HttpPollingConsumer(HttpEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        httpClient = endpoint.createHttpClient();
    }
    public HttpExchange receive() {
        return receiveNoWait();
    }
    public HttpExchange receive(long timeout) {
        return receiveNoWait();
    }
    public HttpExchange receiveNoWait() {
        HttpExchange exchange = endpoint.createExchange();
        HttpMethod method = createMethod();
        try {
            int responseCode = httpClient.executeMethod(method);
            // lets store the result in the output message.
            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();
            InputStream is = method.getResponseBodyAsStream();
            IOUtils.copy(is, bos);
            bos.flush();
            is.close();
            Message message = exchange.getIn();
            message.setBody(bos.createInputStream());
            // lets set the headers
            Header[] headers = method.getResponseHeaders();
            for (Header header : headers) {
                String name = header.getName();
                String value = header.getValue();
                message.setHeader(name, value);
            }
            message.setHeader(""http.responseCode"", responseCode);
            return exchange;
        } catch (IOException e) {
            throw new RuntimeCamelException(e);
        } finally {
            method.releaseConnection();
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public HttpClient getHttpClient() {
        return httpClient;
    }
    public void setHttpClient(HttpClient httpClient) {
        this.httpClient = httpClient;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected HttpMethod createMethod() {
        String uri = endpoint.getEndpointUri();
        return new GetMethod(uri);
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.converter.jaxb.ExchangeType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""exchange"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class ExchangeType {
    @XmlElement(name = ""property"", required = false)
    List<PropertyType> properties = new ArrayList<PropertyType>();
    @XmlAnyElement(lax = true)
    private Object body;
    public Object getBody() {
        return body;
    }
    public void setBody(Object body) {
        this.body = body;
    }
    public List<PropertyType> getProperties() {
        return properties;
    }
    public void setProperties(List<PropertyType> properties) {
        this.properties = properties;
    }
}"
org.apache.camel.component.mail.MailEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Message;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
/**
 * Endpoint for Camel Mail.
 *
 * @version $Revision:520964 $
 */
public class MailEndpoint extends ScheduledPollEndpoint<MailExchange> {
    private MailBinding binding;
    private MailConfiguration configuration;
    public MailEndpoint(String uri, MailComponent component, MailConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
    }
    public MailEndpoint(String endpointUri, MailConfiguration configuration) {
        super(endpointUri);
        this.configuration = configuration;
    }
    public MailEndpoint(String endpointUri) {
        this(endpointUri, new MailConfiguration());
    }
    public Producer<MailExchange> createProducer() throws Exception {
        JavaMailSender sender = configuration.createJavaMailSender();
        return createProducer(sender);
    }
    /**
     * Creates a producer using the given sender
     */
    public Producer<MailExchange> createProducer(JavaMailSender sender) throws Exception {
        return new MailProducer(this, sender);
    }
    public Consumer<MailExchange> createConsumer(Processor processor) throws Exception {
        if (configuration.getProtocol().startsWith(""smtp"")) {
            throw new IllegalArgumentException(""Protocol "" + configuration.getProtocol()
                + "" can not be used for a MailConsumer. Please use another protocol such as pop3 or imap."");
        }
        JavaMailSenderImpl sender = configuration.createJavaMailSender();
        return createConsumer(processor, sender);
    }
    /**
     * Creates a consumer using the given processor and sender
     */
    public Consumer<MailExchange> createConsumer(Processor processor, JavaMailSenderImpl sender) throws Exception {
        MailConsumer answer = new MailConsumer(this, processor, sender);
        // ScheduledPollConsumer default delay is 500 millis and that is too often for polling a mailbox,
        // so we override with a new default value. End user can override this value by providing a consumer.delay parameter
        answer.setDelay(MailConsumer.DEFAULT_CONSUMER_DELAY);
        configureConsumer(answer);
        return answer;
    }
    @Override
    public MailExchange createExchange(ExchangePattern pattern) {
        return new MailExchange(getCamelContext(), pattern, getBinding());
    }
    public MailExchange createExchange(Message message) {
        return new MailExchange(getCamelContext(), getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public MailBinding getBinding() {
        if (binding == null) {
            binding = new MailBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a Mail
     * message
     *
     * @param binding the binding to use
     */
    public void setBinding(MailBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return false;
    }
    public MailConfiguration getConfiguration() {
        return configuration;
    }
}
"
org.apache.camel.spring.handler.BeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.core.Conventions;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
/**
 * A base class for a parser for a bean.
 *
 * @version $Revision$
 */
// TODO cannot use AbstractSimpleBeanDefinitionParser
// as doParse() is final and isEligableAttribute does not allow us to filter out attributes
// with the name ""xmlns:""
public class BeanDefinitionParser extends AbstractSingleBeanDefinitionParser {
    private Class type;
    protected BeanDefinitionParser() {
    }
    public BeanDefinitionParser(Class type) {
        this.type = type;
    }
    protected Class getBeanClass(Element element) {
        if (type == null) {
            type = loadType();
        }
        return type;
    }
    protected Class loadType() {
        throw new IllegalArgumentException(""No type specified!"");
    }
    protected boolean isEligibleAttribute(String attributeName) {
        return attributeName != null && !ID_ATTRIBUTE.equals(attributeName)
                && !attributeName.equals(""xmlns"") && !attributeName.startsWith(""xmlns:"");
    }
    // TODO the following code is copied from AbstractSimpleBeanDefinitionParser
    // it can be removed if ever the doParse() method is not final!
    // or the Spring bug http://jira.springframework.org/browse/SPR-4599 is resolved
    /**
     * Parse the supplied {@link Element} and populate the supplied
     * {@link BeanDefinitionBuilder} as required.
     * <p>This implementation maps any attributes present on the
     * supplied element to {@link org.springframework.beans.PropertyValue}
     * instances, and
     * {@link BeanDefinitionBuilder#addPropertyValue(String, Object) adds them}
     * to the
     * {@link org.springframework.beans.factory.config.BeanDefinition builder}.
     * <p>The {@link #extractPropertyName(String)} method is used to
     * reconcile the name of an attribute with the name of a JavaBean
     * property.
     *
     * @param element the XML element being parsed
     * @param builder used to define the <code>BeanDefinition</code>
     * @see #extractPropertyName(String)
     */
    protected final void doParse(Element element, BeanDefinitionBuilder builder) {
        NamedNodeMap attributes = element.getAttributes();
        for (int x = 0; x < attributes.getLength(); x++) {
            Attr attribute = (Attr) attributes.item(x);
            String name = attribute.getLocalName();
            String fullName = attribute.getName();
            if (!fullName.startsWith(""xmlns:"") && !fullName.equals(""xmlns"") && isEligibleAttribute(name)) {
                String propertyName = extractPropertyName(name);
                Assert.state(StringUtils.hasText(propertyName),
                        ""Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty."");
                builder.addPropertyValue(propertyName, attribute.getValue());
            }
        }
        postProcess(builder, element);
    }
    /**
     * Extract a JavaBean property name from the supplied attribute name.
     * <p>The default implementation uses the
     * {@link Conventions#attributeNameToPropertyName(String)}
     * method to perform the extraction.
     * <p>The name returned must obey the standard JavaBean property name
     * conventions. For example for a class with a setter method
     * '<code>setBingoHallFavourite(String)</code>', the name returned had
     * better be '<code>bingoHallFavourite</code>' (with that exact casing).
     *
     * @param attributeName the attribute name taken straight from the
     *                      XML element being parsed (never <code>null</code>)
     * @return the extracted JavaBean property name (must never be <code>null</code>)
     */
    protected String extractPropertyName(String attributeName) {
        return Conventions.attributeNameToPropertyName(attributeName);
    }
    /**
     * Hook method that derived classes can implement to inspect/change a
     * bean definition after parsing is complete.
     * <p>The default implementation does nothing.
     *
     * @param beanDefinition the parsed (and probably totally defined) bean definition being built
     * @param element        the XML element that was the source of the bean definition's metadata
     */
    protected void postProcess(BeanDefinitionBuilder beanDefinition, Element element) {
    }
}"
org.apache.camel.component.jhc.JhcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.net.URI;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
/**
 * Created by IntelliJ IDEA.
 * User: gnodet
 * Date: Sep 7, 2007
 * Time: 8:06:42 PM
 * To change this template use File | Settings | File Templates.
 */
public class JhcEndpoint extends DefaultEndpoint<JhcExchange> {
    private HttpParams params;
    private URI httpUri;
    public JhcEndpoint(String endpointUri, JhcComponent component, URI httpUri) {
        super(endpointUri, component);
        params = new BasicHttpParams(component.getParams());
        this.httpUri = httpUri;
    }
    public JhcEndpoint(String endpointUri, URI httpUri, HttpParams params) {
        super(endpointUri);
        this.httpUri = httpUri;
        this.params = params;
    }
    public HttpParams getParams() {
        return params;
    }
    public void setParams(HttpParams params) {
        this.params = params;
    }
    public URI getHttpUri() {
        return httpUri;
    }
    public void setHttpUri(URI httpUri) {
        this.httpUri = httpUri;
    }
    public String getProtocol() {
        return httpUri.getScheme();
    }
    public String getHost() {
        return httpUri.getHost();
    }
    public int getPort() {
        if (httpUri.getPort() == -1) {
            if (""https"".equals(getProtocol())) {
                return 443;
            } else {
                return 80;
            }
        }
        return httpUri.getPort();
    }
    public String getPath() {
        return httpUri.getPath();
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer<JhcExchange> createProducer() throws Exception {
        return new JhcProducer(this);
    }
    public Consumer<JhcExchange> createConsumer(Processor processor) throws Exception {
        return new JhcConsumer(this, processor);
    }
}
"
org.apache.camel.component.jms.EndpointMessageListener,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.Session;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.MessageCreator;
/**
 * A JMS {@link MessageListener} which can be used to delegate processing to a
 * Camel endpoint.
 *
 * Note that instance of this object has to be thread safe (reentrant)
 * 
 * @version $Revision$    ;';;;
 */
public class EndpointMessageListener implements MessageListener {
    private static final transient Log LOG = LogFactory.getLog(EndpointMessageListener.class);
    private JmsEndpoint endpoint;
    private Processor processor;
    private JmsBinding binding;
    private boolean eagerLoadingOfProperties;
    private Destination replyToDestination;
    private JmsOperations template;
    private boolean disableReplyTo;
    public EndpointMessageListener(JmsEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
        endpoint.getConfiguration().configure(this);
    }
    public void onMessage(final Message message) {
        RuntimeCamelException rce = null;
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(endpoint + "" consumer receiving JMS message: "" + message);
            }
            Destination replyDestination = getReplyToDestination(message);
            final JmsExchange exchange = createExchange(message, replyDestination);
            if (eagerLoadingOfProperties) {
                exchange.getIn().getHeaders();
            }
            processor.process(exchange);
            final JmsMessage out = exchange.getOut(false);
            if (exchange.getException() != null) {
                rce = new RuntimeCamelException(exchange.getException());
            }
            if (rce == null && out != null && !disableReplyTo) {
                sendReply(replyDestination, message, exchange, out);
            }
        } catch (Exception e) {
            rce = new RuntimeCamelException(e);
        }
        if (rce != null) {
            LOG.warn(endpoint + "" consumer caught an exception while processing ""
                     + ""JMS message: "" + message, rce);
            throw rce;
        }
    }
    public JmsExchange createExchange(Message message, Destination replyDestination) {
        JmsExchange exchange = new JmsExchange(endpoint.getCamelContext(), endpoint.getExchangePattern(), getBinding(), message);
        // lets set to an InOut if we have some kind of reply-to destination
        if (replyDestination != null && !disableReplyTo) {
            exchange.setProperty(""org.apache.camel.jms.replyDestination"", replyDestination);
            exchange.setPattern(ExchangePattern.InOut);
        }
        return exchange;
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding(endpoint);
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS
     * message
     *
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public boolean isEagerLoadingOfProperties() {
        return eagerLoadingOfProperties;
    }
    public void setEagerLoadingOfProperties(boolean eagerLoadingOfProperties) {
        this.eagerLoadingOfProperties = eagerLoadingOfProperties;
    }
    public synchronized JmsOperations getTemplate() {
        if (template == null) {
            template = endpoint.createInOnlyTemplate();
        }
        return template;
    }
    public void setTemplate(JmsOperations template) {
        this.template = template;
    }
    public boolean isDisableReplyTo() {
        return disableReplyTo;
    }
    /**
     * Allows the reply-to behaviour to be disabled
     */
    public void setDisableReplyTo(boolean disableReplyTo) {
        this.disableReplyTo = disableReplyTo;
    }
    public Destination getReplyToDestination() {
        return replyToDestination;
    }
    /**
     * Provides an explicit reply to destination which overrides
     * any incoming value of {@link Message#getJMSReplyTo()}
     *
     * @param replyToDestination the destination that should be used to send replies to
     */
    public void setReplyToDestination(Destination replyToDestination) {
        this.replyToDestination = replyToDestination;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void sendReply(Destination replyDestination, final Message message, final JmsExchange exchange, final JmsMessage out) {
        if (replyDestination == null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Cannot send reply message as there is no replyDestination for: "" + out);
            }
            return;
        }
        getTemplate().send(replyDestination, new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                Message reply = endpoint.getBinding().makeJmsMessage(exchange, out, session);
                if (endpoint.getConfiguration().isUseMessageIDAsCorrelationID()) {
                    String messageID = exchange.getIn().getHeader(""JMSMessageID"", String.class);
                    reply.setJMSCorrelationID(messageID);
                } else {
                    String correlationID = message.getJMSCorrelationID();
                    if (correlationID != null) {
                        reply.setJMSCorrelationID(correlationID);
                    }
                }
                if (LOG.isDebugEnabled()) {
                    LOG.debug(endpoint + "" sending reply JMS message: "" + reply);
                }
                return reply;
            }
        });
    }
    protected Destination getReplyToDestination(Message message) throws JMSException {
        // lets send a response back if we can
        Destination destination = replyToDestination;
        if (destination == null) {
            destination = message.getJMSReplyTo();
        }
        return destination;
    }
}
"
org.apache.camel.component.event.CamelEvent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.springframework.context.ApplicationEvent;
/**
 * Represents a Spring {@link ApplicationEvent} which contains a Camel {@link Exchange}
 *
 * @version $Revision$
 */
public class CamelEvent extends ApplicationEvent {
    private final Exchange exchange;
    public CamelEvent(EventEndpoint source, Exchange exchange) {
        super(source);
        this.exchange = exchange;
    }
    @Override
    public EventEndpoint getSource() {
        return (EventEndpoint) super.getSource();
    }
    /**
     * Returns the message exchange
     *
     * @return the camel message exchange
     */
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.bam.ActivityBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.Date;
import org.apache.camel.Endpoint;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.builder.ProcessorFactory;
import org.apache.camel.impl.EventDrivenConsumerRoute;
/**
 * @version $Revision$
 */
public class ActivityBuilder implements ProcessorFactory {
    private ProcessBuilder processBuilder;
    private Endpoint endpoint;
    private ActivityRules activityRules;
    private Expression correlationExpression;
    public ActivityBuilder(ProcessBuilder processBuilder, Endpoint endpoint) {
        this.processBuilder = processBuilder;
        this.endpoint = endpoint;
        this.activityRules = new ActivityRules(processBuilder);
        this.activityRules.setActivityName(endpoint.getEndpointUri());
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public Processor createProcessor() throws Exception {
        return processBuilder.createActivityProcessor(this);
    }
    public Route createRoute() throws Exception {
        Processor processor = createProcessor();
        if (processor == null) {
            throw new IllegalArgumentException(""No processor created for ActivityBuilder: "" + this);
        }
        return new EventDrivenConsumerRoute(getEndpoint(), processor);
    }
    // Builder methods
    //-----------------------------------------------------------------------
    public ActivityBuilder correlate(Expression correlationExpression) {
        this.correlationExpression = correlationExpression;
        return this;
    }
    public ActivityBuilder name(String name) {
        activityRules.setActivityName(name);
        return this;
    }
    /**
     * Create a temporal rule for when this step starts
     */
    public TimeExpression starts() {
        return new TimeExpression(this, ActivityLifecycle.Started) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeStarted();
            }
        };
    }
    /**
     * Create a temporal rule for when this step completes
     */
    public TimeExpression completes() {
        return new TimeExpression(this, ActivityLifecycle.Completed) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeCompleted();
            }
        };
    }
    // Properties
    //-----------------------------------------------------------------------
    public Expression getCorrelationExpression() {
        return correlationExpression;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ProcessBuilder getProcessBuilder() {
        return processBuilder;
    }
}
"
org.apache.camel.language.ognl.OgnlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import ognl.Ognl;
import ognl.OgnlContext;
import ognl.OgnlException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.language.ExpressionEvaluationException;
import org.apache.camel.language.IllegalSyntaxException;
/**
 * An <a href=""http://www.ognl.org/"">OGNL</a> {@link Expression}
 *
 * @version $Revision$
 */
public class OgnlExpression extends ExpressionSupport<Exchange> {
    private final String expressionString;
    private final Class<?> type;
    private Object expression;
    public OgnlExpression(OgnlLanguage language, String expressionString, Class<?> type) {
        this.expressionString = expressionString;
        this.type = type;
        try {
            this.expression = Ognl.parseExpression(expressionString);
        } catch (OgnlException e) {
            throw new IllegalSyntaxException(language, expressionString);
        }
    }
    public static OgnlExpression ognl(String expression) {
        return new OgnlExpression(new OgnlLanguage(), expression, Object.class);
    }
    public Object evaluate(Exchange exchange) {
        // TODO we could use caching here but then we'd have possible
        // concurrency issues
        // so lets assume that the provider caches
        OgnlContext oglContext = new OgnlContext();
        try {
            return Ognl.getValue(expression, oglContext, new RootObject(exchange));
        } catch (OgnlException e) {
            throw new ExpressionEvaluationException(this, exchange, e);
        }
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return expressionString;
    }
}
"
org.apache.camel.component.jhc.JhcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.net.URI;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
public class JhcComponent extends DefaultComponent<JhcExchange> {
    private static final Log LOG = LogFactory.getLog(JhcComponent.class);
    private HttpParams params;
    public JhcComponent() {
        params = new BasicHttpParams(null)
            .setIntParameter(HttpConnectionParams.SO_TIMEOUT, 5000)
            .setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT, 10000)
            .setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024)
            .setBooleanParameter(HttpConnectionParams.STALE_CONNECTION_CHECK, false)
            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY, true)
            .setParameter(HttpProtocolParams.USER_AGENT, ""Camel-JhcComponent/1.1"");
    }
    public HttpParams getParams() {
        return params;
    }
    public void setParams(HttpParams params) {
        this.params = params;
    }
    protected Endpoint<JhcExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new JhcEndpoint(uri, this, new URI(uri.substring(uri.indexOf(':') + 1)));
    }
}"
org.apache.camel.component.jcr.JcrComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultExchange;
/**
 * A component for integrating with JSR-170 (JCR) compliant content repositories
 */
public class JcrComponent extends DefaultComponent<DefaultExchange> {
    /**
     * Property key for specifying the name of a node in the repository 
     */
    public static final String NODE_NAME = ""org.apache.camel.component.jcr.node_name"";
    @Override @SuppressWarnings(""unchecked"")
    protected Endpoint<DefaultExchange> createEndpoint(String uri, String remaining, Map properties) throws Exception {
        return new JcrEndpoint(uri, this);
    }
}
"
org.apache.camel.component.atom.AtomUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import org.apache.abdera.Abdera;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Feed;
import org.apache.abdera.parser.ParseException;
import org.apache.abdera.parser.Parser;
/**
 * Atom utilities.
 */
public final class AtomUtils {
    private AtomUtils() {
        // Helper class
    }
    /**
     * Gets the Atom parser.
     */
    public static Parser getAtomParser() {
        return Abdera.getInstance().getParser();
    }
    /**
     * Parses the given uri and returns the response as a atom feed document.
     *
     * @param uri the uri for the atom feed.
     * @return  the document
     * @throws IOException is thrown if error reading from the uri
     * @throws ParseException is thrown if the parsing failed
     */
    public static Document<Feed> parseDocument(String uri) throws IOException, ParseException {
        InputStream in = new URL(uri).openStream();
        return getAtomParser().parse(in);
    }
}
"
org.apache.camel.component.jms.requestor.PersistentReplyToFutureHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import javax.jms.ExceptionListener;
import javax.jms.Message;
import javax.jms.Session;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.camel.component.jms.JmsProducer;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.apache.camel.component.jms.requestor.PersistentReplyToRequestor.MessageSelectorComposer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.transaction.PlatformTransactionManager;
public class PersistentReplyToFutureHandler extends FutureHandler {
    private static final transient Log LOG = LogFactory.getLog(PersistentReplyToFutureHandler.class);
    protected PersistentReplyToRequestor requestor;
    protected DeferredMessageSentCallback callback;
    protected String correlationID;
    public PersistentReplyToFutureHandler(PersistentReplyToRequestor requestor,
                                          String correlationID) {
        super();
        this.requestor = requestor;
        this.correlationID = correlationID;
    }
    public PersistentReplyToFutureHandler(PersistentReplyToRequestor requestor,
                                          DeferredMessageSentCallback callback) {
        super();
        this.requestor = requestor;
        this.callback = callback;
    }
    @Override
    public Message get() throws InterruptedException, ExecutionException {
        Message result = null;
        try {
            updateSelector();
            result = super.get();
        } finally {
            revertSelector();
        }
        return result;
    }
    @Override
    public Message get(long timeout, TimeUnit unit) throws InterruptedException,
                                                           ExecutionException,
                                                           TimeoutException {
        Message result = null;
        try {
            updateSelector();
            result = super.get(timeout, unit);
        } finally {
            revertSelector();
        }
        return result;
    }
    protected void updateSelector() throws ExecutionException {
        try {
            MessageSelectorComposer composer = (MessageSelectorComposer)requestor.getListenerContainer();
            composer.addCorrelationID((correlationID != null) ? correlationID : callback.getMessage().getJMSMessageID());
        } catch (Exception e) {
            throw new ExecutionException(e);
        }
    }
    protected void revertSelector() throws ExecutionException {
        try {
            MessageSelectorComposer composer = (MessageSelectorComposer)requestor.getListenerContainer();
            composer.removeCorrelationID((correlationID != null) ? correlationID : callback.getMessage().getJMSMessageID());
        } catch (Exception e) {
            throw new ExecutionException(e);
        }
    }
}
"
org.apache.camel.component.atom.AtomComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * An <a href=""http://activemq.apache.org/camel/atom.html"">Atom Component</a>.
 * <p/>
 * Camel uses Apache Abdera as the Atom implementation. 
 *
 * @version $Revision$
 */
public class AtomComponent extends DefaultComponent {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new AtomEndpoint(uri, this, remaining);
    }
}
"
org.apache.camel.converter.jaxb.LongHeader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""longHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class LongHeader extends HeaderType {
    @XmlAttribute(name = ""value"")
    private Long number;
    public LongHeader() {
    }
    public LongHeader(String name, Long number) {
        super(name);
        this.number = number;
    }
    public Long getNumber() {
        return number;
    }
    public void setNumber(Long number) {
        this.number = number;
    }
    public Object getValue() {
        return getNumber();
    }
    public void setValue(Object value) {
        if (value instanceof Number) {
            Number n = (Number)value;
            setNumber(n.longValue());
        } else {
            throw new IllegalArgumentException(""Value must be a Long"");
        }
    }
}"
org.apache.camel.component.http.HttpMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Map;
import javax.servlet.http.HttpServletRequest;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultMessage;
/**
 * @version $Revision$
 */
public class HttpMessage extends DefaultMessage {
    private HttpServletRequest request;
    public HttpMessage(HttpExchange exchange, HttpServletRequest request) {
        setExchange(exchange);
        this.request = request;
        // lets force a parse of the body and headers
        getBody();
        getHeaders();
    }
    @Override
    public HttpExchange getExchange() {
        return (HttpExchange)super.getExchange();
    }
    public HttpServletRequest getRequest() {
        return request;
    }
    @Override
    protected Object createBody() {
        try {
            return getExchange().getEndpoint().getBinding().parseBody(this);
        } catch (IOException e) {
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        Enumeration names = request.getHeaderNames();
        while (names.hasMoreElements()) {
            String name = (String)names.nextElement();
            Object value = request.getHeader(name);
            map.put(name, value);
        }
    }
}
"
org.apache.camel.component.sql.SqlComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.sql;
import java.util.Map;
import javax.sql.DataSource;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class SqlComponent extends DefaultComponent {
    private DataSource dataSource;
    public SqlComponent() {
    }
    public SqlComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        return new SqlEndpoint(uri, remaining.replaceAll(""#"", ""?""), this, dataSource, parameters);
    }
    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
"
org.apache.camel.bam.processor.NoCorrelationKeyException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
/**
 * An exception thrown if no correlation key could be found for a message
 * exchange preventing any particular orchestration or
 * <a href=""http://activemq.apache.org/camel/bam.html"">BAM</a>
 *
 * @version $Revision$
 */
public class NoCorrelationKeyException extends CamelExchangeException {
    private final BamProcessorSupport processor;
    public NoCorrelationKeyException(BamProcessorSupport processor, Exchange exchange) {
        super(""No correlation key could be found for "" + processor.getCorrelationKeyExpression(), exchange);
        this.processor = processor;
    }
    public BamProcessorSupport getProcessor() {
        return processor;
    }
}
"
org.apache.camel.component.file.remote.RemoteFileConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import org.apache.camel.Converter;
/**
 * A set of converter methods for working with remote file types
 *
 * @version $Revision$
 */
@Converter
public final class RemoteFileConverter {
    private RemoteFileConverter() {
        // Helper Class
    }
    @Converter
    public static byte[] toByteArray(ByteArrayOutputStream os) {
        return os.toByteArray();
    }
    @Converter
    public static String toString(ByteArrayOutputStream os) {
        return os.toString();
    }
    @Converter
    public static InputStream toInputStream(ByteArrayOutputStream os) {
        return new ByteArrayInputStream(os.toByteArray());
    }
}
"
org.apache.camel.component.cxf.interceptors.XMLMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.cxf.bindings.xformat.XMLBindingMessageFormat;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingMessageInfo;
//import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
public class XMLMessageOutInterceptor extends AbstractMessageOutInterceptor<XMLMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(XMLMessageOutInterceptor.class);
    public XMLMessageOutInterceptor() {
        super(Phase.PREPARE_SEND);        
        addAfter(DOMOutInterceptor.class.getName());
    }
    protected Logger getLogger() {
        return LOG;
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(XMLMessage message) throws Fault {
        Exchange exchange = message.getExchange();        
        //BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);
        BindingMessageInfo bmi = exchange.get(BindingMessageInfo.class);
        List<Element> payload = message.get(List.class);
        if (bmi == null && payload.size() > 1) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(
                            ""NO_XML_ROOT_NODE"", LOG));            
        }
        if (bmi != null) {
            Element header = message.get(Element.class);
            if (header != null) {
                //Headers -represent as -Element,
                //Body -represent as StaxStream in CXF Runtime.
                //Copy inbound Header parts to outbound payload
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""DOMOutInterceptor Copy Message Part related Headers to Payload."");
                }
                moveHeaderPartToPayload(bmi, header, payload);
            }
            XMLBindingMessageFormat msgFormat = 
                bmi.getExtensor(XMLBindingMessageFormat.class);
            QName rootName = msgFormat != null ? msgFormat.getRootNode() : null;
            if (rootName == null) {
                if (payload.size() > 1) {
                    throw new Fault(new org.apache.cxf.common.i18n.Message(
                                    ""NO_XML_ROOT_NODE"", LOG));
                }
            } else {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""DOMOutInterceptor Create xmlformat RootNode element"");
                }                
                Element el = createElement(rootName, payload);
                payload = new ArrayList<Element>();
                payload.add(el);
            }
            message.put(List.class, payload);
            message.remove(Element.class);
        }
    }
    private void moveHeaderPartToPayload(BindingMessageInfo bmi,
                                         Element header,
                                         List<Element> payload) {
        Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
        NodeList nodes = header.getChildNodes();
        for (int idx = 0; idx < nodes.getLength(); idx++) {
            Node node = nodes.item(idx);
            int index = 0;
            for (MessagePartInfo mpi : bodyParts) {
                QName name = mpi.getConcreteName();
                if (name.getLocalPart().equals(node.getLocalName())
                    && name.getNamespaceURI().equals(node.getNamespaceURI())) {
                    payload.add(index, (Element)node);
                    break;
                } 
                ++index;
            }
        }
    }
}
"
org.apache.camel.component.jms.DestinationEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Session;
/**
 * An optional interface that a {@link JmsEndpoint} may implement to return the
 * underlying {@link Destination} object
 *
 * @version $Revision$
 */
public interface DestinationEndpoint {
    Destination getJmsDestination(Session session) throws JMSException;
}
"
org.apache.camel.component.jms.requestor.MessageSelectorProvider,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.HashMap;
import java.util.Map;
public class MessageSelectorProvider {
    protected Map<String, String> correlationIds;
    protected boolean dirty = true;
    protected StringBuilder expression;
    public MessageSelectorProvider() {
        correlationIds = new HashMap<String, String>();
    }
    public synchronized void addCorrelationID(String id) {
        correlationIds.put(id, id);
        dirty = true;
    }
    public synchronized void removeCorrelationID(String id) {
        correlationIds.remove(id);
        dirty = true;
    }
    public synchronized String get() {
        if (!dirty) {
            return expression.toString();
        }
        expression = new StringBuilder(""JMSCorrelationID='"");
        boolean first = true;
        for (Map.Entry<String, String> entry : correlationIds.entrySet()) {
            if (!first) {
                expression.append("" OR JMSCorrelationID='"");
            }
            expression.append(entry.getValue()).append(""'"");
            if (first) {
                first = false;
            }
        }
        dirty = false;
        return expression.toString();
    }
}
"
org.apache.camel.component.jhc.JhcMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import org.apache.camel.impl.DefaultMessage;
public class JhcMessage extends DefaultMessage {
}"
org.apache.camel.component.atom.EntryFilter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
/**
 * Filter used by the {@link org.apache.camel.component.atom.AtomEntryPollingConsumer} to filter entries
 * from the feed.
 *
 * @version $Revision$
 */
public interface EntryFilter {
    /**
     * Tests to be used as filtering the feed for only entries of interest, such as only new entries, etc.
     *
     * @param endpoint  the endpoint
     * @param feed      the Atom feed
     * @param entry     the given entry to filter
     * @return  <tt>true</tt> to include the entry, <ff>false</tt> to skip it
     */
    boolean isValidEntry(AtomEndpoint endpoint, Document<Feed> feed, Entry entry);
}
"
org.apache.camel.bam.rules.ActivityRules,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.bam.ProcessBuilder;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a activity which is typically a system or could be an endpoint
 *
 * @version $Revision$
 */
public class ActivityRules extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(ActivityRules.class);
    private int expectedMessages = 1;
    private ProcessRules processRules;
    private List<TemporalRule> rules = new ArrayList<TemporalRule>();
    private ActivityDefinition activityDefinition;
    private String activityName;
    private final org.apache.camel.bam.ProcessBuilder builder;
    public ActivityRules(ProcessBuilder builder) {
        this.builder = builder;
        this.processRules = builder.getProcessRules();
        processRules.getActivities().add(this);
    }
    public void addRule(TemporalRule rule) {
        rules.add(rule);
    }
    /**
     * Handles overdue activities
     */
    public void processExpired(ActivityState activityState) throws Exception {
        for (TemporalRule rule : rules) {
            rule.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (TemporalRule rule : rules) {
            rule.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public ActivityDefinition getActivityDefinition() {
        // lets always query for it, to avoid issues with refreshing before a commit etc
        return builder.findOrCreateActivityDefinition(activityName);
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public int getExpectedMessages() {
        return expectedMessages;
    }
    public void setExpectedMessages(int expectedMessages) {
        this.expectedMessages = expectedMessages;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public void setActivityName(String activityName) {
        this.activityName = activityName;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(rules);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(rules);
    }
}
"
org.apache.camel.spring.spi.BeanInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.springframework.beans.factory.wiring.BeanConfigurerSupport;
import org.springframework.context.ApplicationContext;
/**
 * Dependeny Injected Bean injector. 
 *
 * @version $Revision$
 * @deprecated not used. Will be removed in Camel 2.0.
 */
public class BeanInjector extends BeanConfigurerSupport {
    public BeanInjector(ApplicationContext applicationContext) throws Exception {
        setBeanFactory(applicationContext);
        afterPropertiesSet();
    }
    public void inject(Object bean) {
        configureBean(bean);
    }
}
"
org.apache.camel.component.velocity.VelocityEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.velocity;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.component.ResourceBasedEndpoint;
import org.apache.camel.util.ExchangeHelper;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;
import org.apache.velocity.runtime.log.SimpleLog4JLogSystem;
import org.springframework.core.io.Resource;
/**
 * @version $Revision$
 */
public class VelocityEndpoint extends ResourceBasedEndpoint {
    private final VelocityComponent component;
    private VelocityEngine velocityEngine;
    private boolean loaderCache = true;
    public VelocityEndpoint(String uri, VelocityComponent component, String resourceUri, Map parameters) {
        super(uri, component, resourceUri, null);
        this.component = component;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
    @Override
    public ExchangePattern getExchangePattern() {
        return ExchangePattern.InOut;
    }
    private VelocityEngine getVelocityEngine() throws Exception {
        if (velocityEngine == null) {
            velocityEngine = component.getVelocityEngine();
            velocityEngine.setProperty(Velocity.FILE_RESOURCE_LOADER_CACHE, isLoaderCache() ? Boolean.TRUE : Boolean.FALSE);
            velocityEngine.setProperty(Velocity.RUNTIME_LOG_LOGSYSTEM_CLASS, SimpleLog4JLogSystem.class.getName());
            velocityEngine.setProperty(""runtime.log.logsystem.log4j.category"", VelocityEndpoint.class.getName());
            velocityEngine.init();
        }
        return velocityEngine;
    }
    public void setVelocityEngine(VelocityEngine velocityEngine) {
        this.velocityEngine = velocityEngine;
    }
    public boolean isLoaderCache() {
        return loaderCache;
    }
    /**
     * Enables / disables the velocity resource loader cache which is enabled by default
     *
     * @param loaderCache a flag to enable/disable the cache
     */
    public void setLoaderCache(boolean loaderCache) {
        this.loaderCache = loaderCache;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    protected void onExchange(Exchange exchange) throws Exception {
        Resource resource = getResource();
        // getResourceAsInputStream also considers the content cache
        Reader reader = new InputStreamReader(getResourceAsInputStream());
        StringWriter buffer = new StringWriter();
        String logTag = getClass().getName();
        Map variableMap = ExchangeHelper.createVariableMap(exchange);
        Context velocityContext = new VelocityContext(variableMap);
        // let velocity parse and generate the result in buffer
        VelocityEngine engine = getVelocityEngine();
        if (log.isDebugEnabled()) {
            log.debug(""Velocity is evaluating using velocity context: "" + variableMap);
        }
        engine.evaluate(velocityContext, buffer, logTag, reader);
        // now lets output the results to the exchange
        Message out = exchange.getOut(true);
        out.setBody(buffer.toString());
        out.setHeader(""org.apache.camel.velocity.resource"", resource);
        Map<String, Object> headers = (Map<String, Object>)velocityContext.get(""headers"");
        for (String key : headers.keySet()) {
            out.setHeader(key, headers.get(key));
        }
    }
}
"
org.apache.camel.bam.rules.TemporalRule,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.Date;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.TimeExpression;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultRouteContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.OutputType;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.Time;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;
/**
 * A temporal rule for use within BAM
 *
 * @version $Revision$
 */
public class TemporalRule extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(TemporalRule.class);
    private TimeExpression first;
    private TimeExpression second;
    private long expectedMillis;
    private long overdueMillis;
    private Processor overdueAction;
    private OutputType overdueProcessors = new OutputType();
    public TemporalRule(TimeExpression first, TimeExpression second) {
        this.first = first;
        this.second = second;
    }
    public TemporalRule expectWithin(Time builder) {
        return expectWithin(builder.toMillis());
    }
    public TemporalRule expectWithin(long millis) {
        expectedMillis = millis;
        return this;
    }
    public OutputType errorIfOver(Time builder) {
        return errorIfOver(builder.toMillis());
    }
    public OutputType errorIfOver(long millis) {
        overdueMillis = millis;
        if (overdueProcessors == null) {
            overdueProcessors = new OutputType();
        }
        return overdueProcessors;
    }
    public TimeExpression getFirst() {
        return first;
    }
    public TimeExpression getSecond() {
        return second;
    }
    public Processor getOverdueAction() throws Exception {
        if (overdueAction == null && overdueProcessors != null) {
            // TOOD refactor to avoid this messyness...
            ArrayList<Route> list = new ArrayList<Route>();
            RouteType route = new RouteType();
            route.setCamelContext(first.getBuilder().getProcessBuilder().getContext());
            RouteContext routeContext = new DefaultRouteContext(route, null, list);
            overdueAction = overdueProcessors.createOutputsProcessor(routeContext);
        }
        return overdueAction;
    }
    public void processExchange(Exchange exchange, ProcessInstance instance) {
        Date firstTime = first.evaluate(instance);
        if (firstTime == null) {
            // ignore as first event has not accurred yet
            return;
        }
        // TODO now we might need to set the second activity state
        // to 'grey' to indicate it now could happen?
        // lets force the lazy creation of the second state
        ActivityState secondState = second.getOrCreateActivityState(instance);
        if (expectedMillis > 0L) {
            Date expected = secondState.getTimeExpected();
            if (expected == null) {
                expected = add(firstTime, expectedMillis);
                secondState.setTimeExpected(expected);
            }
        }
        if (overdueMillis > 0L) {
            Date overdue = secondState.getTimeOverdue();
            if (overdue == null) {
                overdue = add(firstTime, overdueMillis);
                secondState.setTimeOverdue(overdue);
            }
        }
    }
    public void processExpired(ActivityState activityState) throws Exception {
        Processor processor = getOverdueAction();
        if (processor != null) {
            Date now = new Date();
/*
            TODO this doesn't work and returns null for some strange reason
            ProcessInstance instance = activityState.getProcessInstance();
            ActivityState secondState = second.getActivityState(instance);
            if (secondState == null) {
                log.error(""Could not find the second state! Process is: "" 
                + instance + "" with first state: "" + first.getActivityState(instance) 
                + "" and the state I was called with was: "" + activityState);
            }
*/
            ActivityState secondState = activityState;
            Date overdue = secondState.getTimeOverdue();
            if (now.compareTo(overdue) >= 0) {
                Exchange exchange = createExchange();
                exchange.getIn().setBody(activityState);
                processor.process(exchange);
            } else {
                LOG.warn(""Process has not actually expired; the time is: "" + now + "" but the overdue time is: "" + overdue);
            }
        }
    }
    protected Exchange createExchange() {
        return new DefaultExchange(second.getBuilder().getProcessBuilder().getContext());
    }
    /**
     * Returns the date in the future adding the given number of millis
     *
     * @param date
     * @param millis
     * @return the date in the future
     */
    protected Date add(Date date, long millis) {
        return new Date(date.getTime() + millis);
    }
    protected void doStart() throws Exception {
        startServices(getOverdueAction());
    }
    protected void doStop() throws Exception {
        stopServices(getOverdueAction());
    }
}
"
org.apache.camel.component.jms.JmsProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangeTimedOutException;
import org.apache.camel.FailedToCreateProducerException;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.RuntimeExchangeException;
import org.apache.camel.component.jms.JmsConfiguration.CamelJmsTemplate;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap;
import org.apache.camel.component.jms.requestor.DeferredRequestReplyMap.DeferredMessageSentCallback;
import org.apache.camel.component.jms.requestor.PersistentReplyToRequestor;
import org.apache.camel.component.jms.requestor.Requestor;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.UuidGenerator;
import org.apache.camel.util.ValueHolder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.MessageCreator;
/**
 * @version $Revision$
 */
public class JmsProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(JmsProducer.class);
    RequestorAffinity affinity;
    private final JmsEndpoint endpoint;
    private JmsOperations inOnlyTemplate;
    private JmsOperations inOutTemplate;
    private UuidGenerator uuidGenerator;
    private DeferredRequestReplyMap deferredRequestReplyMap;
    private Requestor requestor;
    private AtomicBoolean started = new AtomicBoolean(false);
    private enum RequestorAffinity {
        PER_COMPONENT(0),
        PER_ENDPOINT(1),
        PER_PRODUCER(2);
        private int value;
        private RequestorAffinity(int value) {
            this.value = value;
        }
    };
    public JmsProducer(JmsEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        JmsConfiguration c = endpoint.getConfiguration();
        affinity = RequestorAffinity.PER_PRODUCER;
        if (c.getReplyTo() != null) {
            if (c.getReplyToTempDestinationAffinity().equals(c.REPLYTO_TEMP_DEST_AFFINITY_PER_ENDPOINT)) {
                affinity = RequestorAffinity.PER_ENDPOINT;
            } else if (c.getReplyToTempDestinationAffinity().equals(c.REPLYTO_TEMP_DEST_AFFINITY_PER_COMPONENT)) {
                affinity = RequestorAffinity.PER_COMPONENT;
            }
        }
    }
    public long getRequestTimeout() {
        return endpoint.getRequestTimeout();
    }
    protected void doStart() throws Exception {
        super.doStart();
    }
    protected void testAndSetRequestor() throws RuntimeCamelException {
        if (!started.get()) {
            synchronized (this) {
                if (started.get()) {
                    return;
                }
                try {
                    JmsConfiguration c = endpoint.getConfiguration();
                    if (c.getReplyTo() != null) {
                        requestor = new PersistentReplyToRequestor(endpoint.getConfiguration(), endpoint
                            .getExecutorService());
                        requestor.start();
                    } else {
                        if (affinity == RequestorAffinity.PER_PRODUCER) {
                            requestor = new Requestor(endpoint.getConfiguration(), endpoint
                                .getExecutorService());
                            requestor.start();
                        } else if (affinity == RequestorAffinity.PER_ENDPOINT) {
                            requestor = endpoint.getRequestor();
                        } else if (affinity == RequestorAffinity.PER_COMPONENT) {
                            requestor = ((JmsComponent)endpoint.getComponent()).getRequestor();
                        }
                    }
                } catch (Exception e) {
                    throw new FailedToCreateProducerException(endpoint, e);
                }
                deferredRequestReplyMap = requestor.getDeferredRequestReplyMap(this);
                started.set(true);
            }
        }
    }
    protected void testAndUnsetRequestor() throws Exception  {
        if (started.get()) {
            synchronized (this) {
                if (!started.get()) {
                    return;
                }
                requestor.removeDeferredRequestReplyMap(this);
                if (affinity == RequestorAffinity.PER_PRODUCER) {
                    requestor.stop();
                }
                started.set(false);
            }
        }
    }
    protected void doStop() throws Exception {
        testAndUnsetRequestor();
        super.doStop();
    }
    public void process(final Exchange exchange) {
        final org.apache.camel.Message in = exchange.getIn();
        if (exchange.getPattern().isOutCapable()) {
            testAndSetRequestor();
            // note due to JMS transaction semantics we cannot use a single transaction
            // for sending the request and receiving the response
            final Destination replyTo = requestor.getReplyTo();
            if (replyTo == null) {
                throw new RuntimeExchangeException(""Failed to resolve replyTo destination"", exchange);
            }
            final boolean msgIdAsCorrId = endpoint.getConfiguration().isUseMessageIDAsCorrelationID();
            String correlationId = in.getHeader(""JMSCorrelationID"", String.class);
            if (correlationId == null && !msgIdAsCorrId) {
                in.setHeader(""JMSCorrelationID"", getUuidGenerator().generateId());
            }
            final ValueHolder<FutureTask> futureHolder = new ValueHolder<FutureTask>();
            final DeferredMessageSentCallback callback = msgIdAsCorrId ? deferredRequestReplyMap.createDeferredMessageSentCallback() : null;
            final CamelJmsTemplate template = (CamelJmsTemplate)getInOutTemplate();
            template.send(endpoint.getDestination(), new MessageCreator() {
                public Message createMessage(Session session) throws JMSException {
                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);
                    message.setJMSReplyTo(replyTo);
                    requestor.setReplyToSelectorHeader(in, message);
                    FutureTask future = null;
                    future = (!msgIdAsCorrId)
                        ? requestor.getReceiveFuture(message.getJMSCorrelationID(), endpoint
                            .getRequestTimeout()) : requestor.getReceiveFuture(callback);
                    futureHolder.set(future);
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(endpoint + "" sending JMS message: "" + message);
                    }
                    return message;
                }
            }, callback);
            setMessageId(exchange);
            // lets wait and return the response
            long requestTimeout = endpoint.getRequestTimeout();
            try {
                Message message = null;
                try {
                    if (requestTimeout < 0) {
                        message = (Message)futureHolder.get().get();
                    } else {
                        message = (Message)futureHolder.get().get(requestTimeout, TimeUnit.MILLISECONDS);
                    }
                } catch (InterruptedException e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Future interupted: "" + e, e);
                    }
                } catch (TimeoutException e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Future timed out: "" + e, e);
                    }
                }
                if (message != null) {
                    exchange.setOut(new JmsMessage(message, endpoint.getBinding()));
                    if (correlationId != null) {
                        message.setJMSCorrelationID(correlationId);
                        exchange.getOut(false).setHeader(""JMSCorrelationID"", correlationId);
                    }
                } else {
                    // lets set a timed out exception
                    exchange.setException(new ExchangeTimedOutException(exchange, requestTimeout));
                }
            } catch (Exception e) {
                exchange.setException(e);
            }
        } else {
            getInOnlyTemplate().send(endpoint.getDestination(), new MessageCreator() {
                public Message createMessage(Session session) throws JMSException {
                    Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session);
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(endpoint + "" sending JMS message: "" + message);
                    }
                    return message;
                }
            });
            setMessageId(exchange);
        }
    }
    protected void setMessageId(Exchange exchange) {
        if (!(exchange instanceof JmsExchange)) {
            return;
        }
        try {
            JmsExchange jmsExchange = JmsExchange.class.cast(exchange);
            JmsMessage out = jmsExchange.getOut(false);
            if (out != null) {
                out.setMessageId(out.getJmsMessage().getJMSMessageID());
            }
        } catch (JMSException e) {
            LOG.warn(""Unable to retrieve JMSMessageID from outgoing JMS Message and ""
                     + ""set it into Camel's MessageId"", e);
        }
    }
    /**
     * Preserved for backwards compatibility.
     *
     * @deprecated
     * @see #getInOnlyTemplate()
     */
    public JmsOperations getTemplate() {
        return getInOnlyTemplate();
    }
    public JmsOperations getInOnlyTemplate() {
        if (inOnlyTemplate == null) {
            inOnlyTemplate = endpoint.createInOnlyTemplate();
        }
        return inOnlyTemplate;
    }
    public void setInOnlyTemplate(JmsOperations inOnlyTemplate) {
        this.inOnlyTemplate = inOnlyTemplate;
    }
    public JmsOperations getInOutTemplate() {
        if (inOutTemplate == null) {
            inOutTemplate = endpoint.createInOutTemplate();
        }
        return inOutTemplate;
    }
    public void setInOutTemplate(JmsOperations inOutTemplate) {
        this.inOutTemplate = inOutTemplate;
    }
    public UuidGenerator getUuidGenerator() {
        if (uuidGenerator == null) {
            uuidGenerator = new UuidGenerator();
        }
        return uuidGenerator;
    }
    public void setUuidGenerator(UuidGenerator uuidGenerator) {
        this.uuidGenerator = uuidGenerator;
    }
}
"
org.apache.camel.component.irc.IrcExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
public class IrcExchange extends DefaultExchange {
    private IrcBinding binding;
    public IrcExchange(CamelContext context, ExchangePattern pattern, IrcBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public IrcExchange(CamelContext context, ExchangePattern pattern, IrcBinding binding, IrcMessage inMessage) {
        this(context, pattern, binding);
        setIn(inMessage);
    }
    public IrcExchange(DefaultExchange parent, IrcBinding binding) {
        super(parent);
        this.binding = binding;
    }
    public IrcBinding getBinding() {
        return binding;
    }
    public void setBinding(IrcBinding binding) {
        this.binding = binding;
    }
    @Override
    public IrcMessage getIn() {
        return (IrcMessage) super.getIn();
    }
    @Override
    public IrcMessage getOut() {
        return (IrcMessage) super.getOut();
    }
    @Override
    public IrcMessage getOut(boolean lazyCreate) {
        return (IrcMessage) super.getOut(lazyCreate);
    }
    @Override
    public IrcMessage getFault() {
        return (IrcMessage) super.getFault();
    }
    @Override
    public IrcExchange newInstance() {
        return new IrcExchange(this, getBinding());
    }
    @Override
    protected IrcMessage createInMessage() {
        return new IrcMessage();
    }
    @Override
    protected IrcMessage createOutMessage() {
        return new IrcMessage();
    }
}
"
org.apache.camel.language.jxpath.JXPath,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.jxpath;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation used to inject a <a href=""http://commons.apache.org/jxpath/"">JXPath</a>
 * expression into a method parameter when using
 * <a href=""http://activemq.apache.org/camel/bean-integration.html"">Bean Integration</a>
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""jxpath"")
public @interface JXPath {
    String value();
}"
org.apache.camel.spring.util.ReflectionUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
/**
 * Reflection utilities, extending Spring ReflectionUtils.
 */
public class ReflectionUtils extends org.springframework.util.ReflectionUtils {
    public static <T extends Annotation> void callLifecycleMethod(final Object bean, final Class<T> annotation) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                if (method.getAnnotation(annotation) != null) {
                    try {
                        method.invoke(bean, (Object[])null);
                    } catch (IllegalArgumentException ex) {
                        throw new IllegalStateException(""Failure to invoke "" + method + "" on "" + bean.getClass() + "": args=[]"", ex);
                    } catch (IllegalAccessException ex) {
                        throw new UnsupportedOperationException(ex.toString());
                    } catch (InvocationTargetException ex) {
                        throw new UnsupportedOperationException(""PostConstruct method on bean threw exception"", ex.getTargetException());
                    }
                }
            }
        });
    }
    public static void setField(Field f, Object instance, Object value) {
        try {
            boolean oldAccessible = f.isAccessible();
            boolean shouldSetAccessible = !Modifier.isPublic(f.getModifiers()) && !oldAccessible;
            if (shouldSetAccessible) {
                f.setAccessible(true);
            }
            f.set(instance, value);
            if (shouldSetAccessible) {
                f.setAccessible(oldAccessible);
            }
        } catch (IllegalArgumentException ex) {
            throw new UnsupportedOperationException(""Cannot inject value of class '"" + value.getClass() + ""' into "" + f);
        } catch (IllegalAccessException ex) {
            ReflectionUtils.handleReflectionException(ex);
        }
    }
}
"
org.apache.camel.component.irc.IrcConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.net.URI;
import org.apache.camel.RuntimeCamelException;
public class IrcConfiguration implements Cloneable {
    String target;
    String hostname;
    String password;
    String nickname;
    String realname;
    String username;
    boolean persistent = true;
    boolean colors = true;
    boolean onNick = true;
    boolean onQuit = true;
    boolean onJoin = true;
    boolean onKick = true;
    boolean onMode = true;
    boolean onPart = true;
    boolean onTopic = true;
    boolean onPrivmsg = true;
    int[] ports = {6667, 6668, 6669};
    public IrcConfiguration() {
    }
    public IrcConfiguration(String hostname, String nickname, String displayname, String target) {
        this.target = target;
        this.hostname = hostname;
        this.nickname = nickname;
        this.username = nickname;
        this.realname = displayname;
    }
    public IrcConfiguration(String hostname, String username, String password, String nickname, String displayname, String target) {
        this.target = target;
        this.hostname = hostname;
        this.username = username;
        this.password = password;
        this.nickname = nickname;
        this.realname = displayname;
    }
    public IrcConfiguration copy() {
        try {
            return (IrcConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public String getCacheKey() {
        return hostname + "":"" + nickname;
    }
    public void configure(URI uri) {
        setNickname(uri.getUserInfo());
        setUsername(uri.getUserInfo());
        setRealname(uri.getUserInfo());
        setHostname(uri.getHost());
        setTarget(uri.getPath().substring(1));
    }
    public String getHostname() {
        return hostname;
    }
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getNickname() {
        return nickname;
    }
    public void setNickname(String nickname) {
        this.nickname = nickname;
    }
    public String getRealname() {
        return realname;
    }
    public void setRealname(String realname) {
        this.realname = realname;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public int[] getPorts() {
        return ports;
    }
    public void setPorts(int[] ports) {
        this.ports = ports;
    }
    public String getTarget() {
        return target;
    }
    public void setTarget(String target) {
        this.target = target;
    }
    public boolean isPersistent() {
        return persistent;
    }
    public void setPersistent(boolean persistent) {
        this.persistent = persistent;
    }
    public boolean isColors() {
        return colors;
    }
    public void setColors(boolean colors) {
        this.colors = colors;
    }
    public boolean isOnNick() {
        return onNick;
    }
    public void setOnNick(boolean onNick) {
        this.onNick = onNick;
    }
    public boolean isOnQuit() {
        return onQuit;
    }
    public void setOnQuit(boolean onQuit) {
        this.onQuit = onQuit;
    }
    public boolean isOnJoin() {
        return onJoin;
    }
    public void setOnJoin(boolean onJoin) {
        this.onJoin = onJoin;
    }
    public boolean isOnKick() {
        return onKick;
    }
    public void setOnKick(boolean onKick) {
        this.onKick = onKick;
    }
    public boolean isOnMode() {
        return onMode;
    }
    public void setOnMode(boolean onMode) {
        this.onMode = onMode;
    }
    public boolean isOnPart() {
        return onPart;
    }
    public void setOnPart(boolean onPart) {
        this.onPart = onPart;
    }
    public boolean isOnTopic() {
        return onTopic;
    }
    public void setOnTopic(boolean onTopic) {
        this.onTopic = onTopic;
    }
    public boolean isOnPrivmsg() {
        return onPrivmsg;
    }
    public void setOnPrivmsg(boolean onPrivmsg) {
        this.onPrivmsg = onPrivmsg;
    }
    public String toString() {
        return ""IrcConfiguration{"" + ""target='"" + target + '\'' + "", hostname='"" + hostname + '\'' + "", password='"" + password + '\'' + "", nickname='"" + nickname + '\'' + "", realname='"" + realname
               + '\'' + "", username='"" + username + '\'' + "", persistent="" + persistent + "", colors="" + colors + "", onNick="" + onNick + "", onQuit="" + onQuit + "", onJoin="" + onJoin + "", onKick=""
               + onKick + "", onMode="" + onMode + "", onPart="" + onPart + "", onTopic="" + onTopic + "", onPrivmsg="" + onPrivmsg + "", ports="" + ports + '}';
    }
}
"
org.apache.camel.component.irc.IrcMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.schwering.irc.lib.IRCUser;
public class IrcMessage extends DefaultMessage {
    private String messageType;
    private String target;
    private IRCUser user;
    private String whoWasKickedNick;
    private String message;
    public IrcMessage() {
    }
    public IrcMessage(String messageType, IRCUser user, String message) {
        this.messageType = messageType;
        this.user = user;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user, String message) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user, String whoWasKickedNick, String message) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
        this.whoWasKickedNick = whoWasKickedNick;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
    }
    public String getMessageType() {
        return messageType;
    }
    public void setMessageType(String messageType) {
        this.messageType = messageType;
    }
    public String getTarget() {
        return target;
    }
    public void setTarget(String target) {
        this.target = target;
    }
    public IRCUser getUser() {
        return user;
    }
    public void setUser(IRCUser user) {
        this.user = user;
    }
    public String getWhoWasKickedNick() {
        return whoWasKickedNick;
    }
    public void setWhoWasKickedNick(String whoWasKickedNick) {
        this.whoWasKickedNick = whoWasKickedNick;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
    @Override
    public IrcExchange getExchange() {
        return (IrcExchange)super.getExchange();
    }
    @Override
    protected Object createBody() {
        IrcExchange ircExchange = getExchange();
        IrcBinding binding = ircExchange.getBinding();
        return binding.extractBodyFromIrc(ircExchange, this);
    }
    @Override
    public IrcMessage newInstance() {
        return new IrcMessage();
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        map.put(""irc.messageType"", messageType);
        if (target != null) {
            map.put(""irc.target"", target);
        }
        if (whoWasKickedNick != null) {
            map.put(""irc.user.kicked"", whoWasKickedNick);
        }
        if (user != null) {
            map.put(""irc.user.host"", user.getHost());
            map.put(""irc.user.nick"", user.getNick());
            map.put(""irc.user.servername"", user.getServername());
            map.put(""irc.user.username"", user.getUsername());
        }
    }
    @Override
    public String toString() {
        if (message != null) {
            return ""IrcMessage: "" + message;
        } else {
            return ""IrcMessage: "" + getBody();
        }
    }
}
"
org.apache.camel.component.atom.AtomEntryPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import org.apache.abdera.model.Document;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
import org.apache.abdera.parser.ParseException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Consumer to poll atom feeds and return each entry from the feed step by step.
 *
 * @version $Revision$
 */
public class AtomEntryPollingConsumer extends AtomPollingConsumer {
    private Document<Feed> document;
    private int entryIndex;
    private EntryFilter entryFilter;
    private List<Entry> list;
    public AtomEntryPollingConsumer(AtomEndpoint endpoint, Processor processor, boolean filter,
                                    Date lastUpdate) {
        super(endpoint, processor);
        if (filter) {
            entryFilter = new UpdatedDateFilter(lastUpdate);
        }
    }
    public void poll() throws Exception {
        getDocument();
        Feed feed = document.getRoot();
        while (hasNextEntry()) {
            Entry entry = list.get(entryIndex--);
            boolean valid = true;
            if (entryFilter != null) {
                valid = entryFilter.isValidEntry(endpoint, document, entry);
            }
            if (valid) {
                Exchange exchange = endpoint.createExchange(feed, entry);
                getProcessor().process(exchange);
                // return and wait for the next poll to continue from last time (this consumer is stateful)
                return;
            }
        }
        // reset document to be able to poll again
        document = null;
    }
    private Document<Feed> getDocument() throws IOException, ParseException {
        if (document == null) {
            document = AtomUtils.parseDocument(endpoint.getAtomUri());
            list = document.getRoot().getEntries();
            entryIndex = list.size() - 1;
        }
        return document;
    }
    private boolean hasNextEntry() {
        return entryIndex >= 0;
    }
}
"
org.apache.camel.component.file.remote.SftpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import java.io.InputStream;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.apache.camel.Exchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class SftpProducer extends RemoteFileProducer<RemoteFileExchange> {
    private static final transient Log LOG = LogFactory.getLog(SftpProducer.class);
    private SftpEndpoint endpoint;
    private ChannelSftp channel;
    private Session session;
    public SftpProducer(SftpEndpoint endpoint, Session session) {
        super(endpoint);
        this.endpoint = endpoint;
        this.session = session;
    }
    protected void connectIfNecessary() throws JSchException {
        if (channel == null || !channel.isConnected()) {
            if (session == null || !session.isConnected()) {
                LOG.info(""Session isn't connected, trying to recreate and connect..."");
                session = endpoint.createSession();
                session.connect();
            }
            LOG.info(""Channel isn't connected, trying to recreate and connect..."");
            channel = endpoint.createChannelSftp(session);
            channel.connect();
            LOG.info(""Connected to "" + endpoint.getConfiguration().toString());
        }
    }
    protected void disconnect() throws JSchException {
        if (session != null) {
            LOG.info(""Session is being explicitly disconnected"");
            session.disconnect();
        }
        if (channel != null) {
            LOG.info(""Channel is being explicitly disconnected"");
            channel.disconnect();
        }
    }
    public void process(Exchange exchange) throws Exception {
        // TODO: is there a way to avoid copy-pasting the reconnect logic?
        connectIfNecessary();
        // If the attempt to connect isn't successful, then the thrown
        // exception will signify that we couldn't deliver
        try {
            process(endpoint.createExchange(exchange));
        } catch (JSchException e) {
            // If the connection has gone stale, then we must manually disconnect
            // the client before attempting to reconnect
            LOG.warn(""Disconnecting due to exception: "" + e.toString());
            disconnect();
            // Rethrow to signify that we didn't deliver
            throw e;
        } catch (SftpException e) {
            // Still not sure if/when these come up and what we should do about them
            // client.disconnect();
            LOG.warn(""Caught SftpException:"" + e.toString());
            LOG.warn(""Doing nothing for now, need to determine an appropriate action"");
            // Rethrow to signify that we didn't deliver
            throw e;
        }
    }
    public void process(RemoteFileExchange exchange) throws Exception {
        InputStream payload = exchange.getIn().getBody(InputStream.class);
        try {
            String fileName = createFileName(exchange.getIn(), endpoint.getConfiguration());
            int lastPathIndex = fileName.lastIndexOf('/');
            if (lastPathIndex != -1) {
                String directory = fileName.substring(0, lastPathIndex);
                boolean success = buildDirectory(channel, directory);
                if (!success) {
                    LOG.warn(""Couldn't build directory: "" + directory + "" (either permissions deny it, or it already exists)"");
                }
            }
            channel.put(payload, fileName);
            LOG.info(""Sent: "" + fileName + "" to "" + endpoint.getConfiguration());
        } finally {
            if (payload != null) {
                payload.close();
            }
        }
    }
    @Override
    protected void doStart() throws Exception {
        LOG.info(""Starting"");
        try {
            connectIfNecessary();
        } catch (JSchException e) {
            LOG.warn(""Couldn't connect to "" + endpoint.getConfiguration());
        }
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        LOG.info(""Stopping"");
        disconnect();
        super.doStop();
    }
    protected static boolean buildDirectory(ChannelSftp sftpClient, String dirName)
        throws IOException, SftpException {
        boolean atLeastOneSuccess = false;
        final StringBuilder sb = new StringBuilder(dirName.length());
        final String[] dirs = dirName.split(""\\/"");
        for (String dir : dirs) {
            sb.append(dir).append('/');
            String directory = sb.toString();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Trying to build directory: "" + directory);
            }
            sftpClient.mkdir(directory);
            if (!atLeastOneSuccess) {
                atLeastOneSuccess = true;
            }
        }
        return atLeastOneSuccess;
    }
}"
org.apache.camel.spring.spi.TransactionErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Processor;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.ErrorHandlerBuilderSupport;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.spi.RouteContext;
import org.apache.camel.util.ObjectHelper;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * An error handler which will roll the exception back if there is an error
 * rather than using the dead letter channel and retry logic.
 *
 * A delay is also used after a rollback
 *
 * @version $Revision: 1.1 $
 */
public class TransactionErrorHandlerBuilder extends ErrorHandlerBuilderSupport implements Cloneable, InitializingBean {
    private TransactionTemplate transactionTemplate;
    private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
    public TransactionErrorHandlerBuilder() {
    }
    public TransactionTemplate getTransactionTemplate() {
        return transactionTemplate;
    }
    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public ErrorHandlerBuilder copy() {
        try {
            return (ErrorHandlerBuilder) clone();
        } catch (CloneNotSupportedException e) {
            throw new Error(""Clone should be supported: "" + e, e);
        }
    }
    public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {
        return new TransactionInterceptor(processor, transactionTemplate, redeliveryPolicy);
    }
    public void afterPropertiesSet() throws Exception {
        ObjectHelper.notNull(transactionTemplate, ""transactionTemplate"");
    }
    // Builder methods
    // -------------------------------------------------------------------------
    public TransactionErrorHandlerBuilder backOffMultiplier(double backOffMultiplier) {
        getRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    public TransactionErrorHandlerBuilder collisionAvoidancePercent(short collisionAvoidancePercent) {
        getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    public TransactionErrorHandlerBuilder initialRedeliveryDelay(long initialRedeliveryDelay) {
        getRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public TransactionErrorHandlerBuilder maximumRedeliveries(int maximumRedeliveries) {
        getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public TransactionErrorHandlerBuilder maximumRedeliveryDelay(long maximumRedeliveryDelay) {
        getRedeliveryPolicy().maximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }
    public TransactionErrorHandlerBuilder useCollisionAvoidance() {
        getRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    public TransactionErrorHandlerBuilder useExponentialBackOff() {
        getRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
}
"
org.apache.camel.component.mail.MailMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Map;
import javax.activation.DataHandler;
import javax.mail.Header;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Part;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultMessage;
import org.apache.camel.util.CollectionHelper;
/**
 * Represents a {@link org.apache.camel.Message} for working with Mail
 *
 * @version $Revision:520964 $
 */
public class MailMessage extends DefaultMessage {
    private Message mailMessage;
    public MailMessage() {
    }
    public MailMessage(Message message) {
        this.mailMessage = message;
    }
    @Override
    public String toString() {
        if (mailMessage != null) {
            return ""MailMessage: "" + MailUtils.dumpMessage(mailMessage);
        } else {
            return ""MailMessage: "" + getBody();
        }
    }
    @Override
    public MailExchange getExchange() {
        return (MailExchange)super.getExchange();
    }
    public MailMessage copy() {
        MailMessage answer = (MailMessage)super.copy();
        answer.mailMessage = mailMessage;
        return answer;
    }
    /**
     * Returns the underlying Mail message
     */
    public Message getMessage() {
        return mailMessage;
    }
    public void setMessage(Message mailMessage) {
        this.mailMessage = mailMessage;
    }
    public Object getHeader(String name) {
        String[] answer = null;
        if (mailMessage != null) {
            try {
                answer = mailMessage.getHeader(name);
            } catch (MessagingException e) {
                throw new RuntimeCamelException(""Error accessing header: "" + name, e);
            }
        }
        if (answer == null) {
            return super.getHeader(name);
        }
        if (answer.length == 1) {
            return answer[0];
        }
        return answer;
    }
    @Override
    public MailMessage newInstance() {
        return new MailMessage();
    }
    @Override
    protected Object createBody() {
        if (mailMessage != null) {
            return getExchange().getBinding().extractBodyFromMail(getExchange(), mailMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (mailMessage != null) {
            try {
                Enumeration names = mailMessage.getAllHeaders();
                while (names.hasMoreElements()) {
                    Header header = (Header)names.nextElement();
                    String value = header.getValue();
                    String name = header.getName();
                    CollectionHelper.appendValue(map, name, value);
                }
            } catch (MessagingException e) {
                throw new RuntimeCamelException(""Error accessing headers due to: "" + e.getMessage(), e);
            }
        }
    }
    @Override
    protected void populateInitialAttachments(Map<String, DataHandler> map) {
        if (mailMessage != null) {
            try {
                extractAttachments(mailMessage, map);
            } catch (Exception e) {
                throw new RuntimeCamelException(""Error populating the initial mail message attachments"", e);
            }
        }
    }
    public void copyFrom(org.apache.camel.Message that) {
        super.copyFrom(that);
        if (that instanceof MailMessage) {
            MailMessage mailMessage = (MailMessage) that;
            this.mailMessage = mailMessage.mailMessage;
        }
    }
    /**
     * Parses the attachments of the given mail message and adds them to the map
     *
     * @param  message  the mail message with attachments
     * @param  map      the map to add found attachments (attachmentFilename is the key)
     */
    protected static void extractAttachments(Message message, Map<String, DataHandler> map)
        throws javax.mail.MessagingException, IOException {
        Object content = message.getContent();
        if (content instanceof Multipart) {
            // mail with attachment
            Multipart mp = (Multipart)content;
            for (int i = 0; i < mp.getCount(); i++) {
                Part part = mp.getBodyPart(i);
                String disposition = part.getDisposition();
                if (disposition != null) {
                    if (disposition.equalsIgnoreCase(Part.ATTACHMENT) || disposition.equalsIgnoreCase(Part.INLINE)) {
                        // only add named attachments
                        if (part.getFileName() != null) {
                            // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments
                            CollectionHelper.appendValue(map, part.getFileName(), part.getDataHandler());
                        }
                    }
                }
            }
        }
    }
}
"
org.apache.camel.component.cxf.invoker.PayloadInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.w3c.dom.Element;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
public class PayloadInvokingContext extends AbstractInvokingContext {
    private static final Logger LOG = LogUtils.getL7dLogger(PayloadInvokingContext.class);
    public PayloadInvokingContext() {
    }
    public void setRequestOutMessageContent(Message message, Map<Class, Object> contents) {
        PayloadMessage request = (PayloadMessage)contents.get(PayloadMessage.class);
        Element header = request.getHeader();
        List<Element> payload = request.getPayload();
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""header = "" + header + "", paylaod = "" + payload);
        }
        message.put(Element.class, header);
        message.put(List.class, payload);
    }
    @SuppressWarnings(""unchecked"")
    public Object getResponseObject(Exchange exchange, Map<String, Object> responseContext) {
        PayloadMessage payloadMsg = null;
        Message msg = exchange.getInMessage();
        List<Element> payload = getResponseObject(msg , responseContext, List.class);
        Element header = exchange.getInMessage().get(Element.class);
        payloadMsg = new PayloadMessage(payload, header);
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(payloadMsg.toString());
        }
        return payloadMsg;
    }
    @Override
    protected <T> T getResponseObject(Message inMessage, Map<String, Object> responseContext,
                                      Class <T> clazz) {
        T retval = null;
        if (inMessage != null) {
            if (null != responseContext) {
                responseContext.putAll(inMessage);
                LOG.info(""set responseContext to be"" + responseContext);
            }
            retval = inMessage.get(clazz);
        }
        return retval;
    }
    public void setResponseContent(Message outMessage, Object resultPayload) {
        if (resultPayload != null) {
            PayloadMessage payloadMessage = (PayloadMessage) resultPayload;
            if (LOG.isLoggable(Level.FINEST)) {
                LOG.finest(payloadMessage.toString());
            }
            outMessage.put(List.class, payloadMessage.getPayload());
            outMessage.put(Element.class, payloadMessage.getHeader());
        }
    }
    @SuppressWarnings(""unchecked"")
    public Map<Class, Object> getRequestContent(Message inMessage) {
        List<Element> payload = inMessage.get(List.class);
        Element header = inMessage.get(Element.class);
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""Header = "" + header + "", Payload = "" + payload);
        }
        Map<Class, Object> contents = new IdentityHashMap<Class, Object>();
        contents.put(PayloadMessage.class, new PayloadMessage(payload, header));
        return contents;
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.bam.processor.JpaBamProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A concrete {@link Processor} for working on <a
 * href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which uses JPA as
 * the persistence and uses the {@link ProcessInstance} entity to store the
 * process information.
 * 
 * @version $Revision$
 */
public class JpaBamProcessor extends JpaBamProcessorSupport<ProcessInstance> {
    private static final transient Log LOG = LogFactory.getLog(JpaBamProcessor.class);
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules);
    }
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, 
                           ActivityRules activityRules, Class<ProcessInstance> entitytype) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules, entitytype);
    }
    protected void processEntity(Exchange exchange, ProcessInstance process) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Processing process instance: "" + process);
        }
        // lets force the lazy creation of this activity
        ActivityRules rules = getActivityRules();
        ActivityState state = process.getOrCreateActivityState(rules);
        state.processExchange(rules, new ProcessContext(exchange, rules, state));
        rules.getProcessRules().processExchange(exchange, process);
    }
}
"
org.apache.camel.component.xquery.XQueryAnnotationExpressionFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.lang.annotation.Annotation;
import net.sf.saxon.functions.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.component.bean.DefaultAnnotationExpressionFactory;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.language.NamespacePrefix;
/**
 * @version $Revision$
 */
public class XQueryAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
    @Override
    public Expression createExpression(CamelContext camelContext, Annotation annotation,
                                       LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String xQuery = getExpressionFromAnnotation(annotation);
        XQueryBuilder builder = XQueryBuilder.xquery(xQuery);
        if (annotation instanceof XQuery) {
            XQuery xQueryAnnotation = (XQuery)annotation;
            NamespacePrefix[] namespaces = xQueryAnnotation.namespaces();
            if (namespaces != null) {
                for (NamespacePrefix namespacePrefix : namespaces) {
                    // TODO
                    // builder = builder.namespace(namespacePrefix.prefix(),
                    // namespacePrefix.uri());
                }
            }
        }
        if (expressionReturnType.isAssignableFrom(String.class)) {
            builder.setResultsFormat(ResultFormat.String);
        } else if (expressionReturnType.isAssignableFrom(Collection.class)) {
            builder.setResultsFormat(ResultFormat.List);
        }
        return builder;
    }
}
"
org.apache.camel.component.file.remote.RemoteFileBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.OutputStream;
public class RemoteFileBinding {
    public Object extractBodyFromOutputStream(RemoteFileExchange exchange, OutputStream outputStream) {
        return outputStream;
    }
}
"
org.apache.camel.component.jhc.BufferingHttpServiceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.http.ConnectionReuseStrategy;
import org.apache.http.HttpEntity;
import org.apache.http.HttpEntityEnclosingRequest;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseFactory;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.MethodNotSupportedException;
import org.apache.http.ProtocolException;
import org.apache.http.ProtocolVersion;
import org.apache.http.UnsupportedHttpVersionException;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.nio.ContentDecoder;
import org.apache.http.nio.ContentEncoder;
import org.apache.http.nio.NHttpServerConnection;
import org.apache.http.nio.NHttpServiceHandler;
import org.apache.http.nio.entity.ContentBufferEntity;
import org.apache.http.nio.entity.ContentOutputStream;
import org.apache.http.nio.protocol.NHttpServiceHandlerBase;
import org.apache.http.nio.util.ByteBufferAllocator;
import org.apache.http.nio.util.ContentInputBuffer;
import org.apache.http.nio.util.ContentOutputBuffer;
import org.apache.http.nio.util.HeapByteBufferAllocator;
import org.apache.http.nio.util.SimpleInputBuffer;
import org.apache.http.nio.util.SimpleOutputBuffer;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpParamsLinker;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpProcessor;
import org.apache.http.protocol.HttpRequestHandler;
import org.apache.http.util.EncodingUtils;
/**
 * HTTP service handler implementation that buffers the content of HTTP messages
 * entirely in memory and processes HTTP requests on the main I/O thread.
 *
 * <p>This service handler should be used only when dealing with HTTP messages
 * that are known to be limited in length</p>
 *
 * @author <a href=""mailto:oleg at ural.ru"">Oleg Kalnichevski</a>
 *
 */
public class BufferingHttpServiceHandler extends NHttpServiceHandlerBase
                                         implements NHttpServiceHandler {
    public BufferingHttpServiceHandler(
            final HttpProcessor httpProcessor,
            final HttpResponseFactory responseFactory,
            final ConnectionReuseStrategy connStrategy,
            final ByteBufferAllocator allocator,
            final HttpParams params) {
        super(httpProcessor, responseFactory, connStrategy, allocator, params);
    }
    public BufferingHttpServiceHandler(
            final HttpProcessor httpProcessor,
            final HttpResponseFactory responseFactory,
            final ConnectionReuseStrategy connStrategy,
            final HttpParams params) {
        this(httpProcessor, responseFactory, connStrategy,
                new HeapByteBufferAllocator(), params);
    }
    public void connected(final NHttpServerConnection conn) {
        HttpContext context = conn.getContext();
        ServerConnState connState = new ServerConnState(allocator);
        context.setAttribute(CONN_STATE, connState);
        if (this.eventListener != null) {
            this.eventListener.connectionOpen(conn);
        }
    }
    public void requestReceived(final NHttpServerConnection conn) {
        HttpContext context = conn.getContext();
        HttpRequest request = conn.getHttpRequest();
        HttpParamsLinker.link(request, this.params);
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        // Update connection state
        connState.resetInput();
        connState.setRequest(request);
        connState.setInputState(ServerConnState.REQUEST_RECEIVED);
        ProtocolVersion ver = request.getRequestLine().getProtocolVersion();
        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
            // Downgrade protocol version if greater than HTTP/1.1
            ver = HttpVersion.HTTP_1_1;
        }
        HttpResponse response;
        try {
            if (request instanceof HttpEntityEnclosingRequest) {
                if (((HttpEntityEnclosingRequest) request).expectContinue()) {
                    response = this.responseFactory.newHttpResponse(
                            ver, HttpStatus.SC_CONTINUE, context);
                    HttpParamsLinker.link(response, this.params);
                    if (this.expectationVerifier != null) {
                        try {
                            this.expectationVerifier.verify(request, response, context);
                        } catch (HttpException ex) {
                            response = this.responseFactory.newHttpResponse(
                                    HttpVersion.HTTP_1_0,
                                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
                                    context);
                            HttpParamsLinker.link(response, this.params);
                            handleException(ex, response);
                        }
                    }
                    if (response.getStatusLine().getStatusCode() < 200) {
                        // Send 1xx response indicating the server expections
                        // have been met
                        conn.submitResponse(response);
                    } else {
                        // The request does not meet the server expections
                        conn.resetInput();
                        connState.resetInput();
                        sendResponse(conn, response);
                    }
                }
                // Request content is expected.
                // Wait until the request content is fully received
            } else {
                // No request content is expected.
                // Process request right away
                conn.suspendInput();
                processRequest(conn, request);
            }
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        } catch (HttpException ex) {
            closeConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalProtocolException(ex, conn);
            }
        }
    }
    public void closed(final NHttpServerConnection conn) {
        if (this.eventListener != null) {
            this.eventListener.connectionClosed(conn);
        }
    }
    public void exception(final NHttpServerConnection conn, final HttpException httpex) {
        HttpContext context = conn.getContext();
        try {
            HttpResponse response = this.responseFactory.newHttpResponse(
                    HttpVersion.HTTP_1_0, HttpStatus.SC_INTERNAL_SERVER_ERROR, context);
            HttpParamsLinker.link(response, this.params);
            handleException(httpex, response);
            response.setEntity(null);
            sendResponse(conn, response);
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        } catch (HttpException ex) {
            closeConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalProtocolException(ex, conn);
            }
        }
    }
    public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {
        HttpContext context = conn.getContext();
        HttpRequest request = conn.getHttpRequest();
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        ContentInputBuffer buffer = connState.getInbuffer();
        // Update connection state
        connState.setInputState(ServerConnState.REQUEST_BODY_STREAM);
        try {
            buffer.consumeContent(decoder);
            if (decoder.isCompleted()) {
                // Request entity has been fully received
                connState.setInputState(ServerConnState.REQUEST_BODY_DONE);
                // Create a wrapper entity instead of the original one
                HttpEntityEnclosingRequest entityReq = (HttpEntityEnclosingRequest) request;
                if (entityReq.getEntity() != null) {
                    entityReq.setEntity(new ContentBufferEntity(
                            entityReq.getEntity(),
                            connState.getInbuffer()));
                }
                conn.suspendInput();
                processRequest(conn, request);
            }
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        } catch (HttpException ex) {
            closeConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalProtocolException(ex, conn);
            }
        }
    }
    public void responseReady(final NHttpServerConnection conn) {
    }
    public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {
        HttpContext context = conn.getContext();
        HttpResponse response = conn.getHttpResponse();
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        ContentOutputBuffer buffer = connState.getOutbuffer();
        // Update connection state
        connState.setOutputState(ServerConnState.RESPONSE_BODY_STREAM);
        try {
            buffer.produceContent(encoder);
            if (encoder.isCompleted()) {
                connState.setOutputState(ServerConnState.RESPONSE_BODY_DONE);
                connState.resetOutput();
                if (!this.connStrategy.keepAlive(response, context)) {
                    conn.close();
                } else {
                    conn.requestInput();
                }
            }
        } catch (IOException ex) {
            shutdownConnection(conn, ex);
            if (this.eventListener != null) {
                this.eventListener.fatalIOException(ex, conn);
            }
        }
    }
    protected void handleException(final HttpException ex, final HttpResponse response) {
        int code = HttpStatus.SC_INTERNAL_SERVER_ERROR;
        if (ex instanceof MethodNotSupportedException) {
            code = HttpStatus.SC_NOT_IMPLEMENTED;
        } else if (ex instanceof UnsupportedHttpVersionException) {
            code = HttpStatus.SC_HTTP_VERSION_NOT_SUPPORTED;
        } else if (ex instanceof ProtocolException) {
            code = HttpStatus.SC_BAD_REQUEST;
        }
        response.setStatusCode(code);
        byte[] msg = EncodingUtils.getAsciiBytes(ex.getMessage());
        ByteArrayEntity entity = new ByteArrayEntity(msg);
        entity.setContentType(""text/plain; charset=US-ASCII"");
        response.setEntity(entity);
    }
    protected void processRequest(
            final NHttpServerConnection conn,
            final HttpRequest request) throws IOException, HttpException {
        HttpContext context = conn.getContext();
        ProtocolVersion ver = request.getRequestLine().getProtocolVersion();
        if (!ver.lessEquals(HttpVersion.HTTP_1_1)) {
            // Downgrade protocol version if greater than HTTP/1.1
            ver = HttpVersion.HTTP_1_1;
        }
        HttpResponse response = this.responseFactory.newHttpResponse(
                ver,
                HttpStatus.SC_OK,
                conn.getContext());
        HttpParamsLinker.link(response, this.params);
        context.setAttribute(ExecutionContext.HTTP_REQUEST, request);
        context.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
        context.setAttribute(ExecutionContext.HTTP_RESPONSE, response);
        try {
            this.httpProcessor.process(request, context);
            HttpRequestHandler handler = null;
            if (this.handlerResolver != null) {
                String requestURI = request.getRequestLine().getUri();
                handler = this.handlerResolver.lookup(requestURI);
            }
            if (handler != null) {
                handler.handle(request, response, context);
            } else {
                response.setStatusCode(HttpStatus.SC_NOT_IMPLEMENTED);
            }
        } catch (HttpException ex) {
            response = this.responseFactory.newHttpResponse(HttpVersion.HTTP_1_0,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR, context);
            HttpParamsLinker.link(response, this.params);
            handleException(ex, response);
        }
        sendResponse(conn, response);
    }
    protected void sendResponse(
            final NHttpServerConnection conn,
            final HttpResponse response) throws IOException, HttpException {
        HttpContext context = conn.getContext();
        ServerConnState connState = (ServerConnState) context.getAttribute(CONN_STATE);
        ContentOutputBuffer buffer = connState.getOutbuffer();
        this.httpProcessor.process(response, context);
        if (!canResponseHaveBody(connState.getRequest(), response)) {
            response.setEntity(null);
        }
        conn.submitResponse(response);
        // Update connection state
        connState.setOutputState(ServerConnState.RESPONSE_SENT);
        HttpEntity entity = response.getEntity();
        if (entity != null) {
            OutputStream outstream = new ContentOutputStream(buffer);
            entity.writeTo(outstream);
            outstream.flush();
            outstream.close();
        } else {
            connState.resetOutput();
            if (!this.connStrategy.keepAlive(response, context)) {
                conn.close();
            } else {
                conn.requestInput();
            }
        }
    }
    static class ServerConnState {
        public static final int READY                      = 0;
        public static final int REQUEST_RECEIVED           = 1;
        public static final int REQUEST_BODY_STREAM        = 2;
        public static final int REQUEST_BODY_DONE          = 4;
        public static final int RESPONSE_SENT              = 8;
        public static final int RESPONSE_BODY_STREAM       = 16;
        public static final int RESPONSE_BODY_DONE         = 32;
        private SimpleInputBuffer inbuffer;
        private ContentOutputBuffer outbuffer;
        private int inputState;
        private int outputState;
        private HttpRequest request;
        private final ByteBufferAllocator allocator;
        public ServerConnState(final ByteBufferAllocator allocator) {
            super();
            this.inputState = READY;
            this.outputState = READY;
            this.allocator = allocator;
        }
        public ContentInputBuffer getInbuffer() {
            if (this.inbuffer == null) {
                this.inbuffer = new SimpleInputBuffer(2048, allocator);
            }
            return this.inbuffer;
        }
        public ContentOutputBuffer getOutbuffer() {
            if (this.outbuffer == null) {
                this.outbuffer = new SimpleOutputBuffer(2048, allocator);
            }
            return this.outbuffer;
        }
        public int getInputState() {
            return this.inputState;
        }
        public void setInputState(int inputState) {
            this.inputState = inputState;
        }
        public int getOutputState() {
            return this.outputState;
        }
        public void setOutputState(int outputState) {
            this.outputState = outputState;
        }
        public HttpRequest getRequest() {
            return this.request;
        }
        public void setRequest(final HttpRequest request) {
            this.request = request;
        }
        public void resetInput() {
            this.inbuffer = null;
            this.request = null;
            this.inputState = READY;
        }
        public void resetOutput() {
            this.outbuffer = null;
            this.outputState = READY;
        }
    }
}
"
org.apache.camel.component.file.remote.FtpOperationFailedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.RuntimeCamelException;
/**
 * @version $Revision$
 */
public class FtpOperationFailedException extends RuntimeCamelException {
    private final int code;
    private final String reason;
    public FtpOperationFailedException(int code, String reason) {
        super(""Ftp Operation failed: "" + reason.trim() + "" Code: "" + code);
        this.code = code;
        this.reason = reason;
    }
    /**
     * Return the failure code
     */
    public int getCode() {
        return code;
    }
    /**
     * Return the failure reason
     */
    public String getReason() {
        return reason;
    }
}
"
org.apache.camel.component.mail.MailUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.text.DateFormat;
import java.util.Date;
import javax.mail.Address;
import javax.mail.Message;
import javax.mail.MessagingException;
/**
 * Mail utility class.
 * <p>
 * Parts of the code copied from Apache ServiceMix.
 *
 * @version $Revision$
 */
public final class MailUtils {
    public static final int DEFAULT_PORT_SMTP = 25;
    public static final int DEFAULT_PORT_SMTPS = 465;
    public static final int DEFAULT_PORT_POP3 = 110;
    public static final int DEFAULT_PORT_POP3S = 995;
    public static final int DEFAULT_PORT_NNTP = 119;
    public static final int DEFAULT_PORT_IMAP = 143;
    public static final int DEFAULT_PORT_IMAPS = 993;
    public static final String PROTOCOL_SMTP = ""smtp"";
    public static final String PROTOCOL_SMTPS = ""smtps"";
    public static final String PROTOCOL_POP3 = ""pop3"";
    public static final String PROTOCOL_POP3S = ""pop3s"";
    public static final String PROTOCOL_NNTP = ""nntp"";
    public static final String PROTOCOL_IMAP = ""imap"";
    public static final String PROTOCOL_IMAPS = ""imaps"";
    private MailUtils() {
    }
    /**
     * Returns the default port for a given protocol.
     * <p>
     * If a protocol could not successfully be determined the default port number for SMTP protocol is returned.
     *
     * @param protocol the protocol
     * @return the default port
     */
    public static int getDefaultPortForProtocol(final String protocol) {
        int port = DEFAULT_PORT_SMTP;
        if (protocol != null) {
            if (protocol.equalsIgnoreCase(PROTOCOL_IMAP)) {
                port = DEFAULT_PORT_IMAP;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_IMAPS)) {
                port = DEFAULT_PORT_IMAPS;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_NNTP)) {
                port = DEFAULT_PORT_NNTP;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_POP3)) {
                port = DEFAULT_PORT_POP3;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_POP3S)) {
                port = DEFAULT_PORT_POP3S;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_SMTP)) {
                port = DEFAULT_PORT_SMTP;
            } else if (protocol.equalsIgnoreCase(PROTOCOL_SMTPS)) {
                port = DEFAULT_PORT_SMTPS;
            } else {
                port = DEFAULT_PORT_SMTP;
            }
        }
        return port;
    }
    /**
     * Gets a log dump of the given message that can be used for tracing etc.
     *
     * @param message the Mail message
     * @return a log string with important fields dumped
     */
    public static String dumpMessage(Message message) {
        try {
            StringBuilder sb = new StringBuilder();
            int number = message.getMessageNumber();
            sb.append(""messageNumber=["").append(number).append(""]"");
            Address[] from = message.getFrom();
            if (from != null) {
                for (Address adr : from) {
                    sb.append("", from=["").append(adr).append(""]"");
                }
            }
            Address[] to = message.getRecipients(Message.RecipientType.TO);
            if (to != null) {
                for (Address adr : to) {
                    sb.append("", to=["").append(adr).append(""]"");
                }
            }
            String subject = message.getSubject();
            if (subject != null) {
                sb.append("", subject=["").append(subject).append(""]"");
            }
            Date sentDate = message.getSentDate();
            if (sentDate != null) {
                sb.append("", sentDate=["").append(DateFormat.getDateTimeInstance().format(sentDate)).append(""]"");
            }
            Date receivedDate = message.getReceivedDate();
            if (receivedDate != null) {
                sb.append("", receivedDate=["").append(DateFormat.getDateTimeInstance().format(receivedDate)).append(""]"");
            }
            return sb.toString();
        } catch (MessagingException e) {
            // ignore the error and just return tostring 
            return message.toString();
        }
    }
}
"
org.apache.camel.component.sql.SqlProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.sql;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ColumnMapRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.RowMapperResultSetExtractor;
public class SqlProducer extends DefaultProducer {
    public static final String UPDATE_COUNT = ""org.apache.camel.sql.update-count"";
    private String query;
    private JdbcTemplate jdbcTemplate;
    public SqlProducer(SqlEndpoint endpoint, String query, JdbcTemplate jdbcTemplate) {
        super(endpoint);
        this.jdbcTemplate = jdbcTemplate;
        this.query = query;
    }
    public void process(final Exchange exchange) throws Exception {
        jdbcTemplate.execute(query, new PreparedStatementCallback() {
            public Object doInPreparedStatement(PreparedStatement ps) throws SQLException,
                DataAccessException {
                int argNumber = 1;
                for (Iterator<?> i = exchange.getIn().getBody(Iterator.class); i.hasNext();) {
                    ps.setObject(argNumber++, i.next());
                }
                boolean isResultSet = ps.execute();
                if (isResultSet) {
                    RowMapperResultSetExtractor mapper = new RowMapperResultSetExtractor(
                                                                                         new ColumnMapRowMapper());
                    List<?> result = (List<?>)mapper.extractData(ps.getResultSet());
                    exchange.getOut().setBody(result);
                } else {
                    exchange.getIn().setHeader(UPDATE_COUNT, ps.getUpdateCount());
                }
                return null;
            }
        });
    }
}
"
org.apache.camel.component.xquery.ResultFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
/**
 * @version $Revision$
 */
public enum ResultFormat {
    Bytes, BytesSource, DOM, DOMSource, List, String, StringSource
}
"
org.apache.camel.component.cxf.util.NullConduitSelector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import org.apache.cxf.endpoint.ConduitSelector;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
public class NullConduitSelector implements ConduitSelector {
    private Endpoint endpoint;
    private NullConduit nullConduit;
    public NullConduitSelector() {
        nullConduit = new NullConduit();
    }
    public void complete(Exchange exchange) {
        //do nothing here
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void prepare(Message message) {
        //do nothing here
    }
    public Conduit selectConduit(Message message) {
        return nullConduit;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
}
"
org.apache.camel.component.cxf.util.NullConduit,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
public class NullConduit implements Conduit {
    public void close() {
    }
    public void close(Message message) throws IOException {
        OutputStream outputStream = message.getContent(OutputStream.class);
        if (outputStream != null) {
            outputStream.close();
        }
    }
    public Destination getBackChannel() {
        return null;
    }
    public EndpointReferenceType getTarget() {
        return null;
    }
    public void prepare(Message message) throws IOException {
        CachedOutputStream outputStream = new CachedOutputStream();
        message.setContent(OutputStream.class, outputStream);
    }
    public void setMessageObserver(MessageObserver observer) {
    }
}
"
org.apache.camel.builder.script.Ruby,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of <a href=""http://ruby-lang.org/"">Ruby</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""jruby"")
public @interface Ruby {
    String value();
}"
org.apache.camel.component.cxf.feature.AbstractDataFormatFeature,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.feature;
import java.util.List;
import java.util.logging.Logger;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.feature.AbstractFeature;
import org.apache.cxf.interceptor.Interceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.phase.PhaseInterceptor;
/**
 * The abstract class for the data format feature
 */
public abstract class AbstractDataFormatFeature extends AbstractFeature {
    protected abstract Logger getLogger();
    protected void resetServiceInvokerInterceptor(Server server) {
        List<Interceptor> serviceInterceptor = server.getEndpoint().getService().getInInterceptors();
        removeInterceptorWhichIsInThePhases(serviceInterceptor, new String[]{Phase.INVOKE});
        serviceInterceptor.add(new MessageInvokerInterceptor());
    }
    protected void removeInterceptorWhichIsInThePhases(List<Interceptor> interceptors, String[] phaseNames) {
        for (Interceptor i : interceptors) {
            if (i instanceof PhaseInterceptor) {
                PhaseInterceptor p = (PhaseInterceptor)i;
                for (String phaseName : phaseNames) {
                    if (p.getPhase().equals(phaseName)) {
                        getLogger().info(""removing the interceptor "" + p);
                        interceptors.remove(p);
                        break;
                    }
                }
            }
        }
    }
    protected void removeInterceptorWhichIsOutThePhases(List<Interceptor> interceptors, String[] phaseNames) {
        for (Interceptor i : interceptors) {
            boolean outside = false;
            if (i instanceof PhaseInterceptor) {
                PhaseInterceptor p = (PhaseInterceptor)i;
                for (String phaseName : phaseNames) {
                    if (p.getPhase().equals(phaseName)) {
                        outside = true;
                        break;
                    }
                }
                if (!outside) {
                    getLogger().info(""removing the interceptor "" + p);
                    interceptors.remove(p);
                }
            }
        }
    }
}
"
org.apache.camel.bam.model.ActivityState,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Date;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import org.apache.camel.bam.processor.ProcessContext;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The default state for a specific activity within a process
 *
 * @version $Revision$
 */
@Entity
public class ActivityState extends TemporalEntity {
    private static final transient Log LOG = LogFactory.getLog(ActivityState.class);
    private ProcessInstance processInstance;
    private Integer receivedMessageCount = 0;
    private ActivityDefinition activityDefinition;
    private Date timeExpected;
    @Temporal(TemporalType.TIME)
    private Date timeOverdue;
    private Integer escalationLevel = 0;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""ActivityState["" + getId() + "" on "" + getProcessInstance() + "" "" + getActivityDefinition() + ""]"";
    }
    public synchronized void processExchange(ActivityRules activityRules, ProcessContext context) throws Exception {
        int messageCount = 0;
        Integer count = getReceivedMessageCount();
        if (count != null) {
            messageCount = count.intValue();
        }
        setReceivedMessageCount(++messageCount);
        if (messageCount == 1) {
            onFirstMessage(context);
        }
        int expectedMessages = activityRules.getExpectedMessages();
        if (messageCount == expectedMessages) {
            onExpectedMessage(context);
        } else if (messageCount > expectedMessages) {
            onExcessMessage(context);
        }
    }
    /**
     * Returns true if this state is for the given activity
     */
    public boolean isActivity(ActivityRules activityRules) {
        return ObjectHelper.equal(getActivityDefinition(), activityRules.getActivityDefinition());
    }
    // Properties
    // -----------------------------------------------------------------------
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
        processInstance.getActivityStates().add(this);
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    public ActivityDefinition getActivityDefinition() {
        return activityDefinition;
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public Integer getEscalationLevel() {
        return escalationLevel;
    }
    public void setEscalationLevel(Integer escalationLevel) {
        this.escalationLevel = escalationLevel;
    }
    public Integer getReceivedMessageCount() {
        return receivedMessageCount;
    }
    public void setReceivedMessageCount(Integer receivedMessageCount) {
        this.receivedMessageCount = receivedMessageCount;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeExpected() {
        return timeExpected;
    }
    public void setTimeExpected(Date timeExpected) {
        this.timeExpected = timeExpected;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeOverdue() {
        return timeOverdue;
    }
    public void setTimeOverdue(Date timeOverdue) {
        this.timeOverdue = timeOverdue;
    }
    public void setTimeCompleted(Date timeCompleted) {
        super.setTimeCompleted(timeCompleted);
        if (timeCompleted != null) {
            setEscalationLevel(-1);
        }
    }
    @Transient
    public String getCorrelationKey() {
        ProcessInstance pi = getProcessInstance();
        if (pi == null) {
            return null;
        }
        return pi.getCorrelationKey();
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    /**
     * Called when the first message is reached
     */
    protected void onFirstMessage(ProcessContext context) {
        if (!isStarted()) {
            setTimeStarted(currentTime());
            context.onStarted(this);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Activity first message: "" + this);
            }
        }
    }
    /**
     * Called when the expected number of messages are is reached
     */
    protected void onExpectedMessage(ProcessContext context) {
        if (!isCompleted()) {
            setTimeCompleted(currentTime());
            // must also clear overdue otherwise we will get failures
            setTimeOverdue(null);
            context.onCompleted(this);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Activity complete: "" + this);
            }
        }
    }
    /**
     * Called when an excess message (after the expected number of messages) are
     * received
     */
    protected void onExcessMessage(ProcessContext context) {
        // TODO
    }
    protected Date currentTime() {
        return new Date();
    }
}
"
org.apache.camel.component.uface.swing.SwingComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.uface.swing;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.component.uface.UFaceComponent;
import org.ufacekit.ui.swing.databinding.swing.SwingRealm;
/**
 * @version $Revision$
 */
public class SwingComponent extends UFaceComponent {
    public SwingComponent() {
        SwingRealm.createDefault();
    }
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return super.createEndpoint(uri, remaining, parameters);
    }
}
"
org.apache.camel.component.jms.MessageListenerProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import javax.jms.MessageListener;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
/**
 * Represents a JMS {@link MessageListener} which can be used directly with any
 * JMS template or derived from to create an MDB for processing messages using a
 * {@link Processor}
 * 
 * @version $Revision:520964 $
 */
public class MessageListenerProcessor implements MessageListener {
    private final JmsEndpoint endpoint;
    private final Processor processor;
    public MessageListenerProcessor(JmsEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    public void onMessage(Message message) {
        try {
            Exchange exchange = endpoint.createExchange(message);
            processor.process(exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
}
"
org.apache.camel.component.cxf.util.DataOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.util.logging.Logger;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Source;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.AbstractOutDatabindingInterceptor;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.staxutils.StaxUtils;
public class DataOutInterceptor extends AbstractOutDatabindingInterceptor {
    private static final Logger LOG = LogUtils.getL7dLogger(DataOutInterceptor.class);
    public DataOutInterceptor() {
        super(Phase.MARSHAL);
    }
    public void handleMessage(Message message) throws Fault {
        XMLStreamWriter xmlWriter = getXMLStreamWriter(message);
        try {
            // put the payload source as a document
            Source source = message.getContent(Source.class);
            if (source != null) {
                XMLStreamReader xmlReader = StaxUtils.createXMLStreamReader(source);
                StaxUtils.copy(xmlReader, xmlWriter);
            }
        } catch (XMLStreamException e) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""XMLSTREAM_EXCEPTION"",
                                                                   LOG, e),
                            e);
        }
    }
}
"
org.apache.camel.converter.jaxb.JaxbConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.util.JAXBSource;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.converter.HasAnnotation;
import org.apache.camel.converter.jaxp.XmlConverter;
/**
 * @version $Revision$
 */
public class JaxbConverter {
    private XmlConverter jaxbConverter;
    public XmlConverter getJaxbConverter() {
        if (jaxbConverter == null) {
            jaxbConverter = new XmlConverter();
        }
        return jaxbConverter;
    }
    public void setJaxbConverter(XmlConverter jaxbConverter) {
        this.jaxbConverter = jaxbConverter;
    }
    @Converter
    public static JAXBSource toSource(@HasAnnotation(XmlRootElement.class)Object value) throws JAXBException {
        JAXBContext context = createJaxbContext(value);
        return new JAXBSource(context, value);
    }
    @Converter
    public Document toDocument(
            @HasAnnotation(XmlRootElement.class)Object value) throws JAXBException, ParserConfigurationException {
        JAXBContext context = createJaxbContext(value);
        Marshaller marshaller = context.createMarshaller();
        Document doc = getJaxbConverter().createDocument();
        marshaller.marshal(value, doc);
        return doc;
    }
    @Converter
    public static MessageType toMessageType(Exchange exchange) {
        return toMessageType(exchange.getIn());
    }
    @Converter
    public static MessageType toMessageType(Message in) {
        MessageType answer = new MessageType();
        answer.copyFrom(in);
        return answer;
    }
    protected static JAXBContext createJaxbContext(Object value) throws JAXBException {
        if (value == null) {
            throw new IllegalArgumentException(""Cannot convert from null value to JAXBSource"");
        }
        JAXBContext context = JAXBContext.newInstance(value.getClass());
        return context;
    }
//    public void write(OutputStream out, Object value) throws JAXBException {
//        JAXBContext context = JAXBContext.newInstance(value.getClass());
//        Marshaller marshaller = context.createMarshaller();
//        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
//        marshaller.marshal(value, out);
//    }
}
"
org.apache.camel.component.spring.integration.adapter.config.CamelTargetAdapterParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter;
import org.springframework.beans.factory.parsing.BeanComponentDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.integration.ConfigurationException;
import org.springframework.integration.endpoint.HandlerEndpoint;
import org.springframework.util.StringUtils;
/**
 * Parser for the &lt;camelTarget/&gt; element
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class CamelTargetAdapterParser extends AbstractCamelContextBeanDefinitionParaser {
    protected Class<?> getBeanClass(Element element) {
        return HandlerEndpoint.class;
    }
    protected boolean shouldGenerateId() {
        return false;
    }
    protected boolean shouldGenerateIdAsFallback() {
        return true;
    }
    protected void parseAttributes(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        NamedNodeMap atts = element.getAttributes();
        for (int i = 0; i < atts.getLength(); i++) {
            Attr node = (Attr) atts.item(i);
            String val = node.getValue();
            String name = node.getLocalName();
            if (!name.equals(""requestChannel"") && !name.equals(""replyChannel"")) {
                mapToProperty(bean, name, val);
            }
        }
    }
    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
        BeanDefinitionBuilder adapterDefBuilder = BeanDefinitionBuilder.rootBeanDefinition(CamelTargetAdapter.class);
        String requestChannel = element.getAttribute(""requestChannel"");
        String replyChannel = element.getAttribute(""replyChannel"");
        // Check the requestChannel
        if (!StringUtils.hasText(requestChannel)) {
            throw new ConfigurationException(""The 'requestChannel' attribute is required."");
        }
        // Set the adapter bean's property
        parseAttributes(element, parserContext, adapterDefBuilder);
        parseCamelContext(element, parserContext, adapterDefBuilder);
        String adapterBeanName = parserContext.getReaderContext().generateBeanName(adapterDefBuilder.getBeanDefinition());
        parserContext.registerBeanComponent(new BeanComponentDefinition(adapterDefBuilder.getBeanDefinition(), adapterBeanName));
        builder.addConstructorArgReference(adapterBeanName);
        builder.addPropertyValue(""inputChannelName"", requestChannel);
        if (StringUtils.hasText(replyChannel)) {
            builder.addPropertyValue(""outputChannelName"", replyChannel);
        }
    }
}
"
org.apache.camel.component.mail.security.DummySSLSocketFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail.security;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * DummySSLSocketFactory for testing with SSL - <b>NOT SECURE</b>.
 * <p/>
 * This factory is only to be used for testing purposes.
 */
public class DummySSLSocketFactory extends SSLSocketFactory {
    private static final transient Log LOG = LogFactory.getLog(DummySSLSocketFactory.class);
    private SSLSocketFactory factory;
    public DummySSLSocketFactory() {
        try {
            SSLContext sslContext = SSLContext.getInstance(""TLS"");
            TrustManager[] trustManagers = new TrustManager[] {new DummyTrustManager()};
            sslContext.init(null, trustManagers, new java.security.SecureRandom());
            factory = sslContext.getSocketFactory();
        } catch (Exception e) {
            throw new RuntimeCamelException(""Error creating DummySSLSocketFactory: "" + e.getMessage(), e);
        }
    }
    /**
     * Must provide this getDefault operation for JavaMail to be able to use this factory.
     */
    public static SocketFactory getDefault() {
        LOG.warn(""Camel is using DummySSLSocketFactory as SSLSocketFactory (only to be used for testing purpose)"");
        return new DummySSLSocketFactory();
    }
    public String[] getDefaultCipherSuites() {
        return factory.getDefaultCipherSuites();
    }
    public String[] getSupportedCipherSuites() {
        return factory.getSupportedCipherSuites();
    }
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return factory.createSocket(socket, host, port, autoClose);
    }
    public Socket createSocket(String host, int port) throws IOException {
        return factory.createSocket(host, port);
    }
    public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
        throws IOException {
        return factory.createSocket(host, port, localAddress, localPort);
    }
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return factory.createSocket(host, port);
    }
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)
        throws IOException {
        return factory.createSocket(address, port, localAddress, localPort);
    }
    public Socket createSocket() throws IOException {
        // must have this createSocket method
        return factory.createSocket();
    }
}
"
org.apache.camel.component.jms.JmsMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.File;
import java.util.Enumeration;
import java.util.Map;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Topic;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultMessage;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a {@link org.apache.camel.Message} for working with JMS
 *
 * @version $Revision:520964 $
 */
public class JmsMessage extends DefaultMessage {
    private static final transient Log LOG = LogFactory.getLog(JmsMessage.class);
    private Message jmsMessage;
    private JmsBinding binding;
    public JmsMessage() {
    }
    public JmsMessage(Message jmsMessage) {
        setJmsMessage(jmsMessage);
    }
    public JmsMessage(Message jmsMessage, JmsBinding binding) {
        this(jmsMessage);
        setBinding(binding);
    }
    @Override
    public String toString() {
        if (jmsMessage != null) {
            return ""JmsMessage: "" + jmsMessage;
        } else {
            return ""JmsMessage: "" + getBody();
        }
    }
    @Override
    public void copyFrom(org.apache.camel.Message that) {
        // for performance lets not copy the messageID if we are a JMS message
        boolean copyMessageId = true;
        if (that instanceof JmsMessage) {
            JmsMessage thatMessage = (JmsMessage) that;
            this.jmsMessage = thatMessage.jmsMessage;
            if (this.jmsMessage != null) {
                copyMessageId = false;
            }
        }
        if (!copyMessageId) {
            setMessageId(that.getMessageId());
        }
        setBody(that.getBody());
        getHeaders().putAll(that.getHeaders());
    }
    /**
     * Returns the underlying JMS message
     *
     * @return the underlying JMS message
     */
    public Message getJmsMessage() {
        return jmsMessage;
    }
    public JmsBinding getBinding() {
        if (binding == null) {
            Exchange exchange = getExchange();
            if (exchange instanceof JmsExchange) {
                JmsExchange jmsExchange = (JmsExchange) exchange;
                return jmsExchange.getBinding();
            } else {
                return new JmsBinding();
            }
        }
        return binding;
    }
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public void setJmsMessage(Message jmsMessage) {
        try {
            setMessageId(jmsMessage.getJMSMessageID());
        } catch (JMSException e) {
            LOG.warn(""Unable to retrieve JMSMessageID from JMS Message"", e);
        }
        this.jmsMessage = jmsMessage;
    }
    public Object getHeader(String name) {
        Object answer = null;
        // we will exclude using JMS-prefixed headers here to avoid strangeness with some JMS providers
        // e.g. ActiveMQ returns the String not the Destination type for ""JMSReplyTo""!
        if (jmsMessage != null && !name.startsWith(""JMS"")) {
            try {
                answer = jmsMessage.getObjectProperty(name);
            } catch (JMSException e) {
                throw new MessagePropertyAccessException(name, e);
            }
        }
        if (answer == null) {
            answer = super.getHeader(name);
        }
        return answer;
    }
    @Override
    public JmsMessage newInstance() {
        return new JmsMessage();
    }
    /**
     * Returns true if a new JMS message instance should be created to send to the next component
     */
    public boolean shouldCreateNewMessage() {
        return super.hasPopulatedHeaders();
    }
    @Override
    protected Object createBody() {
        if (jmsMessage != null) {
            return getBinding().extractBodyFromJms(getExchange(), jmsMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (jmsMessage != null) {
            // lets populate the standard JMS message headers
            try {
                map.put(""JMSCorrelationID"", jmsMessage.getJMSCorrelationID());
                map.put(""JMSDeliveryMode"", jmsMessage.getJMSDeliveryMode());
                map.put(""JMSDestination"", jmsMessage.getJMSDestination());
                map.put(""JMSExpiration"", jmsMessage.getJMSExpiration());
                map.put(""JMSMessageID"", jmsMessage.getJMSMessageID());
                map.put(""JMSPriority"", jmsMessage.getJMSPriority());
                map.put(""JMSRedelivered"", jmsMessage.getJMSRedelivered());
                map.put(""JMSReplyTo"", jmsMessage.getJMSReplyTo());
                map.put(""JMSTimestamp"", jmsMessage.getJMSTimestamp());
                map.put(""JMSType"", jmsMessage.getJMSType());
                // TODO this works around a bug in the ActiveMQ property handling
                map.put(""JMSXGroupID"", jmsMessage.getStringProperty(""JMSXGroupID""));
            } catch (JMSException e) {
                throw new MessageJMSPropertyAccessException(e);
            }
            Enumeration names;
            try {
                names = jmsMessage.getPropertyNames();
            } catch (JMSException e) {
                throw new MessagePropertyNamesAccessException(e);
            }
            while (names.hasMoreElements()) {
                String name = names.nextElement().toString();
                try {
                    Object value = jmsMessage.getObjectProperty(name);
                    // must decode back from safe JMS header name to original header name
                    // when storing on this Camel JmsMessage object.
                    String key = JmsBinding.decodeFromSafeJmsHeaderName(name);
                    map.put(key, value);
                } catch (JMSException e) {
                    throw new MessagePropertyAccessException(name, e);
                }
            }
        }
    }
    @Override
    protected String createMessageId() {
        try {
            String id = getDestinationAsString(jmsMessage.getJMSDestination()) + jmsMessage.getJMSMessageID();
            return getSanitizedString(id);
        } catch (JMSException e) {
            LOG.error(""Failed to get message id from message "" + jmsMessage, e);
            return super.createMessageId();
        }
    }
    private String getDestinationAsString(Destination destination) throws JMSException {
        String result;
        if (destination == null) {
            result = ""null destination!"" + File.separator;
        } else if (destination instanceof Topic) {
            result = ""topic"" + File.separator + ((Topic) destination).getTopicName() + File.separator;
        } else {
            result = ""queue"" + File.separator + ((Queue) destination).getQueueName() + File.separator;
        }
        return result;
    }
    private String getSanitizedString(Object value) {
        return value != null ? value.toString().replaceAll(""[^a-zA-Z0-9\\.\\_\\-]"", ""_"") : """";
    }
}
"
org.apache.camel.component.spring.integration.SpringIntegrationHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration;
public final class SpringIntegrationHelper {
    private SpringIntegrationHelper() {
        // Helper class
    }
    public static void checkSpringBeanInstance(Object bean, String name) {
        if (bean == null) {
            throw new IllegalArgumentException(""Can't find the bean: "" + name + "" from the Spring context"");
        }
    }
}
"
org.apache.camel.component.http.helper.LoadingByteArrayOutputStream,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http.helper;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
/**
 * Subclass of ByteArrayOutputStream that allows creation of a
 * ByteArrayInputStream directly without creating a copy of the byte[].
 *
 * Also, on ""toByteArray()"" it truncates it's buffer to the current size
 * and returns the new buffer directly.  Multiple calls to toByteArray()
 * will return the exact same byte[] unless a write is called in between.
 *
 * Note: once the InputStream is created, the output stream should
 * no longer be used.  In particular, make sure not to call reset()
 * and then write as that may overwrite the data that the InputStream
 * is using.
 */
public class LoadingByteArrayOutputStream extends ByteArrayOutputStream {
    public LoadingByteArrayOutputStream() {
        super(1024);
    }
    public LoadingByteArrayOutputStream(int i) {
        super(i);
    }
    public ByteArrayInputStream createInputStream() {
        return new ByteArrayInputStream(buf, 0, count);
    }
    public byte[] toByteArray() {
        if (count != buf.length) {
            buf = super.toByteArray();
        }
        return buf;
    }
}"
org.apache.camel.converter.jaxb.PropertyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision$
 */
@XmlRootElement(name = ""property"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class PropertyType {
    @XmlAttribute
    private String key;
    @XmlAnyElement(lax = true)
    private Object value;
    public String getKey() {
        return key;
    }
    public void setKey(String key) {
        this.key = key;
    }
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
}"
org.apache.camel.component.jms.DefaultQueueBrowseStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.QueueBrowser;
import javax.jms.Session;
import org.apache.camel.Exchange;
import org.springframework.jms.core.BrowserCallback;
import org.springframework.jms.core.JmsOperations;
/**
 * A default implementation of queue browsing using the Spring 2.5.x {@link BrowserCallback}
 * @version $Revision$
 */
public class DefaultQueueBrowseStrategy implements QueueBrowseStrategy {
    public List<Exchange> browse(JmsOperations template, String queue, final JmsQueueEndpoint endpoint) {
        return  (List<Exchange>) template.browse(queue, new BrowserCallback() {
            public Object doInJms(Session session, QueueBrowser browser) throws JMSException {
                // TODO not the best implementation in the world as we have to browse
                // the entire queue, which could be massive
                List<Exchange> answer = new ArrayList<Exchange>();
                Enumeration iter = browser.getEnumeration();
                while (iter.hasMoreElements()) {
                    Message message = (Message) iter.nextElement();
                    JmsExchange exchange = endpoint.createExchange(message);
                    answer.add(exchange);
                }
                return answer;
            }
        });
    }
}
"
org.apache.camel.spring.remoting.CamelServiceExporter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.util.CamelContextHelper;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.remoting.support.RemoteExporter;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A {@link FactoryBean} to create a proxy to a service exposing a given {@link #getServiceInterface()}
 *
 * @author chirino
 */
public class CamelServiceExporter extends RemoteExporter implements InitializingBean, DisposableBean, ApplicationContextAware, CamelContextAware {
    private String uri;
    private CamelContext camelContext;
    private Consumer consumer;
    private String serviceRef;
    private ApplicationContext applicationContext;
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public String getServiceRef() {
        return serviceRef;
    }
    public void setServiceRef(String serviceRef) {
        this.serviceRef = serviceRef;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void afterPropertiesSet() throws Exception {
        // lets bind the URI to a pojo
        notNull(uri, ""uri"");
        notNull(camelContext, ""camelContext"");
        if (serviceRef != null && getService() == null && applicationContext != null) {
            setService(applicationContext.getBean(serviceRef));
        }
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);
        Object proxy = getProxyForService();
        consumer = endpoint.createConsumer(new BeanProcessor(proxy, camelContext));
        consumer.start();
    }
    public void destroy() throws Exception {
        if (consumer != null) {
            consumer.stop();
        }
    }
}
"
org.apache.camel.component.jms.JmsIOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.util.Enumeration;
import javax.jms.BytesMessage;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.MessageEOFException;
import javax.jms.ObjectMessage;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import org.apache.camel.Converter;
import org.apache.camel.converter.NIOConverter;
/**
 * Some simple payload conversions to I/O <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * 
 * @version $Revision$
 */
@Converter
public final class JmsIOConverter {
    private JmsIOConverter() {        
    }
    /**
     * @param message
     * @return a ByteBuffer
     * @throws Exception
     */
    @Converter
    public static ByteBuffer toByteBuffer(final Message message) throws Exception {
        if (message instanceof TextMessage) {
            final String text = ((TextMessage)message).getText();
            return NIOConverter.toByteBuffer(text);
        }
        if (message instanceof BytesMessage) {
            final BytesMessage bmsg = (BytesMessage)message;
            final int len = (int)bmsg.getBodyLength();
            final byte[] data = new byte[len];
            bmsg.readBytes(data, len);
            return NIOConverter.toByteBuffer(data);
        }
        if (message instanceof StreamMessage) {
            final StreamMessage msg = (StreamMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            try {
                while (true) {
                    final Object obj = msg.readObject();
                    writeData(dataOut, obj);
                }
            } catch (MessageEOFException e) {
                // we have no other way of knowing the end of the message
            }
            dataOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof MapMessage) {
            final MapMessage msg = (MapMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            for (final Enumeration en = msg.getMapNames(); en.hasMoreElements();) {
                final Object obj = msg.getObject(en.nextElement().toString());
                writeData(dataOut, obj);
            }
            dataOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof ObjectMessage) {
            ObjectMessage objMessage = (ObjectMessage)message;
            Object object = objMessage.getObject();
            ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            ObjectOutputStream objectOut = new ObjectOutputStream(bytesOut);
            objectOut.writeObject(object);
            objectOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        return null;
    }
    private static void writeData(DataOutputStream dataOut, Object data) throws Exception {
        if (data instanceof byte[]) {
            dataOut.write((byte[])data);
        } else if (data instanceof String) {
            dataOut.writeUTF(data.toString());
        } else if (data instanceof Double) {
            dataOut.writeDouble(((Double)data).doubleValue());
        } else if (data instanceof Float) {
            dataOut.writeFloat(((Float)data).floatValue());
        } else if (data instanceof Long) {
            dataOut.writeLong(((Long)data).longValue());
        } else if (data instanceof Integer) {
            dataOut.writeInt(((Integer)data).intValue());
        } else if (data instanceof Short) {
            dataOut.writeShort(((Short)data).shortValue());
        } else if (data instanceof Character) {
            dataOut.writeChar(((Character)data).charValue());
        } else if (data instanceof Byte) {
            dataOut.writeByte(((Byte)data).byteValue());
        } else if (data instanceof Boolean) {
            dataOut.writeBoolean(((Boolean)data).booleanValue());
        }
    }
}
"
org.apache.camel.component.jhc.AsyncHttpRequestHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jhc;
import java.io.IOException;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.protocol.HttpContext;
import org.apache.http.protocol.HttpRequestHandler;
public interface AsyncHttpRequestHandler extends HttpRequestHandler {
    void handle(HttpRequest request, HttpContext context, AsyncResponseHandler handler) throws HttpException,
        IOException;
}
"
org.apache.camel.component.xquery.XQueryComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xquery;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
/**
 * An <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery Component</a>
 * for performing transforming messages
 *
 * @version $Revision$
 */
public class XQueryComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Resource resource = resolveMandatoryResource(remaining);
        if (log.isDebugEnabled()) {
            log.debug(this + "" using schema resource: "" + resource);
        }
        XQueryBuilder xslt = XQueryBuilder.xquery(resource.getURL());
        configureXslt(xslt, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, xslt);
    }
    protected void configureXslt(XQueryBuilder xQueryBuilder, String uri, String remaining, Map parameters) throws Exception {
        setProperties(xQueryBuilder, parameters);
    }
}
"
org.apache.camel.component.cxf.CxfComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Component</a>
 * @version $Revision$
 */
public class CxfComponent extends DefaultComponent<CxfExchange> {
    public CxfComponent() {
    }
    public CxfComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<CxfExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        // Now we need to add the address, endpoint name, WSDL url or the SEI to build up an endpoint
        CxfEndpoint result = new CxfEndpoint(uri, remaining, this);
        setProperties(result, parameters);
        // We can check the endpoint integration here
        return result;
    }
}
"
org.apache.camel.component.jetty.JettyHttpComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jetty;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.component.http.CamelServlet;
import org.apache.camel.component.http.HttpComponent;
import org.apache.camel.component.http.HttpConsumer;
import org.apache.camel.component.http.HttpEndpoint;
import org.apache.camel.component.http.HttpExchange;
import org.mortbay.jetty.Connector;
import org.mortbay.jetty.Server;
import org.mortbay.jetty.client.HttpClient;
import org.mortbay.jetty.nio.SelectChannelConnector;
import org.mortbay.jetty.security.SslSocketConnector;
import org.mortbay.jetty.servlet.Context;
import org.mortbay.jetty.servlet.HashSessionIdManager;
import org.mortbay.jetty.servlet.HashSessionManager;
import org.mortbay.jetty.servlet.ServletHolder;
import org.mortbay.jetty.servlet.SessionHandler;
/**
 * An HttpComponent which starts an embedded Jetty for to handle consuming from
 * the http endpoints.
 *
 * @version $Revision$
 */
public class JettyHttpComponent extends HttpComponent {
    class ConnectorRef {
        Connector connector;
        int refCount;
        public ConnectorRef(Connector connector) {
            this.connector = connector;
            increment();
        }
        public int increment() {
            return ++refCount;
        }
        public int decrement() {
            return --refCount;
        }
    }
    private CamelServlet camelServlet;
    private Server server;
    private final HashMap<String, ConnectorRef> connectors = new HashMap<String, ConnectorRef>();
    private HttpClient httpClient;
    private String sslKeyPassword;
    private String sslPassword;
    private String sslKeystore;
    private SslSocketConnector sslSocketConnector;
    @Override
    protected Endpoint<HttpExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        URI httpURL = uri.startsWith(""jetty:"") ? new URI(remaining) : new URI(uri);
        JettyHttpEndpoint result =
            new JettyHttpEndpoint(this, uri, httpURL, getHttpConnectionManager());
        setProperties(result, parameters);
        return result;
    }
    /**
     * Connects the URL specified on the endpoint to the specified processor.
     *
     * @throws Exception
     */
    @Override
    public void connect(HttpConsumer consumer) throws Exception {
        // Make sure that there is a connector for the requested endpoint.
        JettyHttpEndpoint endpoint = (JettyHttpEndpoint)consumer.getEndpoint();
        String connectorKey = endpoint.getProtocol() + "":"" + endpoint.getPort();
        synchronized (connectors) {
            ConnectorRef connectorRef = connectors.get(connectorKey);
            if (connectorRef == null) {
                Connector connector;
                if (""https"".equals(endpoint.getProtocol())) {
                    connector = getSslSocketConnector();
                } else {
                    connector = new SelectChannelConnector();
                }
                connector.setPort(endpoint.getPort());
                getServer().addConnector(connector);
                // check the session support
                if (endpoint.isSessionSupport()) {
                    enableSessionSupport();
                }
                connector.start();
                connectorRef = new ConnectorRef(connector);
                connectors.put(connectorKey, connectorRef);
            } else {
                // ref track the connector
                connectorRef.increment();
                // check the session support
                if (endpoint.isSessionSupport()) {
                    enableSessionSupport();
                }
            }
        }
        camelServlet.connect(consumer);
    }
    private void enableSessionSupport() throws Exception {
        Context context = (Context)getServer().getChildHandlerByClass(Context.class);
        if (context.getSessionHandler() == null) {
            SessionHandler sessionHandler = new SessionHandler();
            context.setSessionHandler(sessionHandler);
            if (context.isStarted()) {
                // restart the context
                context.stop();
                context.start();
            }
        }
    }
    /**
     * Disconnects the URL specified on the endpoint from the specified
     * processor.
     *
     * @throws Exception
     */
    @Override
    public void disconnect(HttpConsumer consumer) throws Exception {
        camelServlet.disconnect(consumer);
        // If the connector is not needed anymore.. then stop it.
        HttpEndpoint endpoint = (HttpEndpoint)consumer.getEndpoint();
        String connectorKey = endpoint.getProtocol() + "":"" + endpoint.getPort();
        synchronized (connectors) {
            ConnectorRef connectorRef = connectors.get(connectorKey);
            if (connectorRef != null) {
                if (connectorRef.decrement() == 0) {
                    getServer().removeConnector(connectorRef.connector);
                    connectorRef.connector.stop();
                    connectors.remove(connectorKey);
                }
            }
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public Server getServer() throws Exception {
        if (server == null) {
            server = createServer();
        }
        return server;
    }
    public void setServer(Server server) {
        this.server = server;
    }
    public String getSslKeyPassword() {
        return sslKeyPassword;
    }
    public void setSslKeyPassword(String sslKeyPassword) {
        this.sslKeyPassword = sslKeyPassword;
    }
    public String getSslPassword() {
        return sslPassword;
    }
    public void setSslPassword(String sslPassword) {
        this.sslPassword = sslPassword;
    }
    public void setKeystore(String sslKeystore) {
        this.sslKeystore = sslKeystore;
    }
    public String getKeystore() {
        return sslKeystore;
    }
    public synchronized SslSocketConnector getSslSocketConnector() {
        if (sslSocketConnector == null) {
            sslSocketConnector = new SslSocketConnector();
            // with default null values, jetty ssl system properties
            // and console will be read by jetty implementation
            sslSocketConnector.setPassword(sslPassword);
            sslSocketConnector.setKeyPassword(sslKeyPassword);
            if (sslKeystore != null) {
                sslSocketConnector.setKeystore(sslKeystore);
            }
        }
        return sslSocketConnector;
    }
    public void setSslSocketConnector(SslSocketConnector connector) {
        sslSocketConnector = connector;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected Server createServer() throws Exception {
        camelServlet = new CamelContinuationServlet();
        Server server = new Server();
        Context context = new Context(Context.NO_SECURITY | Context.NO_SESSIONS);
        context.setContextPath(""/"");
        ServletHolder holder = new ServletHolder();
        holder.setServlet(camelServlet);
        context.addServlet(holder, ""/*"");
        server.setHandler(context);
        server.start();
        return server;
    }
    @Override
    protected void doStop() throws Exception {
        for (ConnectorRef connectorRef : connectors.values()) {
            connectorRef.connector.stop();
        }
        connectors.clear();
        if (server != null) {
            server.stop();
        }
        httpClient.stop();
        super.doStop();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (httpClient == null) {
            httpClient = createHttpClient();
        }
        httpClient.start();
    }
    protected HttpClient createHttpClient() throws Exception {
        HttpClient httpClient = new HttpClient();
        httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
        httpClient.setMaxConnectionsPerAddress(2);
        return httpClient;
    }
    public HttpClient getHttpClient() {
        return httpClient;
    }
    public void setHttpClient(HttpClient httpClient) {
        this.httpClient = httpClient;
    }
}
"
org.apache.camel.bam.model.TemporalEntity,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Date;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
/**
 * @version $Revision$
 */
public abstract class TemporalEntity extends EntitySupport {
    private Date timeStarted;
    private Date timeCompleted;
    @Transient
    public boolean isStarted() {
        return timeStarted != null;
    }
    @Transient
    public boolean isCompleted() {
        return timeCompleted != null;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeStarted() {
        return timeStarted;
    }
    public void setTimeStarted(Date timeStarted) {
        this.timeStarted = timeStarted;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeCompleted() {
        return timeCompleted;
    }
    public void setTimeCompleted(Date timeCompleted) {
        this.timeCompleted = timeCompleted;
    }
}
"
org.apache.camel.language.groovy.CamelGroovyMethods,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import groovy.lang.Closure;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.FilterType;
import org.apache.camel.model.ProcessorType;
/**
 * @version $Revision$
 */
public final class CamelGroovyMethods {
    private CamelGroovyMethods() {
        // Utility Class
    }
    public static FilterType filter(ProcessorType self, Closure filter) {
        return self.filter(toExpression(filter));
    }
    public static ChoiceType when(ChoiceType self, Closure filter) {
        return self.when(toExpression(filter));
    }
    public static ExpressionSupport toExpression(final Closure filter) {
        return new ExpressionSupport<Exchange>() {
            protected String assertionFailureMessage(Exchange exchange) {
                return filter.toString();
            }
            public Object evaluate(Exchange exchange) {
                return filter.call(exchange);
            }
            @Override
            public String toString() {
                return ""Groovy["" + filter + ""]"";
            }
        };
    }
}
"
org.apache.camel.component.file.remote.RemoteFileComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultComponent;
public class RemoteFileComponent extends DefaultComponent<RemoteFileExchange> {
    private RemoteFileConfiguration configuration;
    public RemoteFileComponent() {
        this.configuration = new RemoteFileConfiguration();
    }
    public RemoteFileComponent(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
    public RemoteFileComponent(CamelContext context) {
        super(context);
        this.configuration = new RemoteFileConfiguration();
    }
    public String toString() {
        return ""RemoteFileComponent"";
    }
    public static RemoteFileComponent remoteFileComponent() {
        return new RemoteFileComponent();
    }
    protected RemoteFileEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        RemoteFileConfiguration config = getConfiguration().copy();
        config.configure(new URI(uri));
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        final RemoteFileEndpoint endpoint;
        if (""ftp"".equals(config.getProtocol())) {
            endpoint = new FtpEndpoint(uri, this, config);
        } else if (""sftp"".equals(config.getProtocol())) {
            endpoint = new SftpEndpoint(uri, this, config);
        } else {
            throw new RuntimeCamelException(""Unsupported protocol: "" + config.getProtocol());
        }
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public RemoteFileConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
}
"
org.apache.camel.component.file.remote.SftpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.UserInfo;
import org.apache.camel.Processor;
public class SftpEndpoint extends RemoteFileEndpoint<RemoteFileExchange> {
    public SftpEndpoint(String uri, RemoteFileComponent remoteFileComponent, RemoteFileConfiguration configuration) {
        super(uri, remoteFileComponent, configuration);
    }
    public SftpEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public SftpProducer createProducer() throws Exception {
        return new SftpProducer(this, createSession());
    }
    public SftpConsumer createConsumer(Processor processor) throws Exception {
        final SftpConsumer consumer = new SftpConsumer(this, processor, createSession());
        configureConsumer(consumer);
        return consumer;
    }
    protected Session createSession() throws JSchException {
        final JSch jsch = new JSch();
        final Session session = jsch.getSession(getConfiguration().getUsername(), getConfiguration().getHost());
        // TODO there's got to be a better way to deal with accepting new hosts...
        session.setUserInfo(new UserInfo() {
            public String getPassphrase() {
                return null;
            }
            public String getPassword() {
                return getConfiguration().getPassword();
            }
            public boolean promptPassword(String string) {
                return true;
            }
            public boolean promptPassphrase(String string) {
                return true;
            }
            public boolean promptYesNo(String string) {
                return true;
            }
            public void showMessage(String string) {
            }
        });
        return session;
    }
    public ChannelSftp createChannelSftp(Session session) throws JSchException {
        final ChannelSftp channel = (ChannelSftp) session.openChannel(""sftp"");
        return channel;
    }
}
"
org.apache.camel.component.cxf.spring.CxfEndpointBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.spring;
import org.apache.cxf.frontend.AbstractWSDLBasedEndpointFactory;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
/**
 *
 */
public class CxfEndpointBean extends AbstractWSDLBasedEndpointFactory {
    public CxfEndpointBean() {
        setServiceFactory(new ReflectionServiceFactoryBean());
    }
}
"
org.apache.camel.component.http.CamelServlet,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @version $Revision$
 */
public class CamelServlet extends HttpServlet {
    private ConcurrentHashMap<String, HttpConsumer> consumers = new ConcurrentHashMap<String, HttpConsumer>();
    public CamelServlet() {
    }
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            // Is there a consumer registered for the request.
            HttpConsumer consumer = resolve(request);
            if (consumer == null) {
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            // Have the camel process the HTTP exchange.
            HttpExchange exchange = new HttpExchange(consumer.getEndpoint(), request, response);
            consumer.getProcessor().process(exchange);
            // HC: The getBinding() is interesting because it illustrates the
            // impedance miss-match between
            // HTTP's stream oriented protocol, and Camels more message oriented
            // protocol exchanges.
            // now lets output to the response
            consumer.getBinding().writeResponse(exchange, response);
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }
    protected HttpConsumer resolve(HttpServletRequest request) {
        String path = request.getPathInfo();
        return consumers.get(path);
    }
    public void connect(HttpConsumer consumer) {
        consumers.put(consumer.getPath(), consumer);
    }
    public void disconnect(HttpConsumer consumer) {
        consumers.remove(consumer.getPath());
    }
}
"
org.apache.camel.spring.SpringRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spring.spi.SpringTransactionPolicy;
import org.apache.camel.spring.spi.TransactionErrorHandlerBuilder;
import org.apache.camel.spring.spi.TransactionInterceptor;
import org.springframework.context.ApplicationContext;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * An extension of the {@link RouteBuilder} to provide some additional helper
 * methods
 *
 * @version $Revision$
 */
public abstract class SpringRouteBuilder extends RouteBuilder {
    private ApplicationContext applicationContext;
    public TransactionInterceptor transactionInterceptor() {
        return new TransactionInterceptor(bean(TransactionTemplate.class));
    }
    /**
     * Looks up the bean with the given name in the application context and
     * returns it, or throws an exception if the bean is not present or is not
     * of the given type
     *
     * @param type the type of the bean
     * @param beanName the name of the bean in the application context
     * @return the bean
     */
    public <T> T bean(Class<T> type, String beanName) {
        ApplicationContext context = getApplicationContext();
        return (T)context.getBean(beanName, type);
    }
    /**
     * Looks up the bean with the given type in the application context and
     * returns it, or throws an exception if the bean is not present or there
     * are multiple possible beans to choose from for the given type
     *
     * @param type the type of the bean
     * @return the bean
     */
    public <T> T bean(Class<T> type) {
        ApplicationContext context = getApplicationContext();
        String[] names = context.getBeanNamesForType(type, true, true);
        if (names != null) {
            int count = names.length;
            if (count == 1) {
                // lets instantiate the single bean
                return (T)context.getBean(names[0]);
            } else if (count > 1) {
                throw new IllegalArgumentException(""Too many beans in the application context of type: "" + type + "". Found: "" + count);
            }
        }
        throw new IllegalArgumentException(""No bean available in the application context of type: "" + type);
    }
    /**
     * Returns the application context which has been configured via the
     * {@link #setApplicationContext(ApplicationContext)} method or from the
     * underlying {@link SpringCamelContext}
     */
    public ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            CamelContext camelContext = getContext();
            if (camelContext instanceof SpringCamelContext) {
                SpringCamelContext springCamelContext = (SpringCamelContext)camelContext;
                return springCamelContext.getApplicationContext();
            } else {
                throw new IllegalArgumentException(""This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured"");
            }
        }
        return applicationContext;
    }
    /**
     * Sets the application context to use to lookup beans
     */
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    /**
     * Creates a transaction error handler.
     *
     * @param policy   using this transaction policy (eg: required, supports, ...)
     * @return the created error handler
     */
    public TransactionErrorHandlerBuilder transactionErrorHandler(SpringTransactionPolicy policy) {
        TransactionErrorHandlerBuilder answer = new TransactionErrorHandlerBuilder();
        answer.setTransactionTemplate(policy.getTemplate());
        return answer;
    }
}
"
org.apache.camel.component.xmpp.XmppEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Consumer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.AccountManager;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketFilter;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Presence;
/**
 * A XMPP Endpoint
 *
 * @version $Revision:520964 $
 */
public class XmppEndpoint extends DefaultEndpoint<XmppExchange> {
    private static final transient Log LOG = LogFactory.getLog(XmppEndpoint.class);
    private XmppBinding binding;
    private XMPPConnection connection;
    private String host;
    private int port;
    private String user;
    private String password;
    private String resource = ""Camel"";
    private boolean login = true;
    private PacketFilter filter;
    private boolean createAccount;
    private String room;
    private String participant;
    private String nickname;
    public XmppEndpoint(String uri, XmppComponent component) {
        super(uri, component);
    }
    public XmppEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public Producer<XmppExchange> createProducer() throws Exception {
        if (room != null) {
            return createGroupChatProducer(room);
        } else {
            if (participant == null) {
                throw new IllegalArgumentException(""No room or participant configured on this endpoint: "" + this);
            }
            return createPrivateChatProducer(participant);
        }
    }
    public Producer<XmppExchange> createGroupChatProducer(String room) throws Exception {
        return new XmppGroupChatProducer(this, room);
    }
    public Producer<XmppExchange> createPrivateChatProducer(String participant) throws Exception {
        return new XmppPrivateChatProducer(this, participant);
    }
    public Consumer<XmppExchange> createConsumer(Processor processor) throws Exception {
        return new XmppConsumer(this, processor);
    }
    @Override
    public XmppExchange createExchange(ExchangePattern pattern) {
        return new XmppExchange(getCamelContext(), pattern, getBinding());
    }
    public XmppExchange createExchange(Message message) {
        return new XmppExchange(getCamelContext(), getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public XmppBinding getBinding() {
        if (binding == null) {
            binding = new XmppBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from an XMPP
     * message
     */
    public void setBinding(XmppBinding binding) {
        this.binding = binding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getUser() {
        return user;
    }
    public void setUser(String user) {
        this.user = user;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getResource() {
        return resource;
    }
    public void setResource(String resource) {
        this.resource = resource;
    }
    public boolean isLogin() {
        return login;
    }
    public void setLogin(boolean login) {
        this.login = login;
    }
    public PacketFilter getFilter() {
        return filter;
    }
    public void setFilter(PacketFilter filter) {
        this.filter = filter;
    }
    public boolean isCreateAccount() {
        return createAccount;
    }
    public void setCreateAccount(boolean createAccount) {
        this.createAccount = createAccount;
    }
    public String getRoom() {
        return room;
    }
    public void setRoom(String room) {
        this.room = room;
    }
    public String getParticipant() {
        return participant;
    }
    public void setParticipant(String participant) {
        this.participant = participant;
    }
    public String getNickname() {
        return nickname;
    }
    public void setNickname(String nickname) {
        this.nickname = nickname;
    }
    public XMPPConnection getConnection() throws XMPPException {
        if (connection == null) {
            connection = createConnection();
        }
        return connection;
    }
    public void setConnection(XMPPConnection connection) {
        this.connection = connection;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected XMPPConnection createConnection() throws XMPPException {
        XMPPConnection connection;
        if (port > 0) {
            connection = new XMPPConnection(host, port);
        } else {
            connection = new XMPPConnection(host);
        }
        if (login && !connection.isAuthenticated()) {
            if (user != null) {
                LOG.info(""Logging in to XMPP as user: "" + user + "" on connection: "" + connection);
                if (password == null) {
                    LOG.warn(""No password configured for user: "" + user);
                }
                if (createAccount) {
                    AccountManager accountManager = new AccountManager(connection);
                    accountManager.createAccount(user, password);
                }
                if (resource != null) {
                    connection.login(user, password, resource);
                } else {
                    connection.login(user, password);
                }
            } else {
                LOG.info(""Logging in anonymously to XMPP on connection: "" + connection);
                connection.loginAnonymously();
            }
            // presence is not needed to be sent after login
        }
        return connection;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.component.mail.MailProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.internet.MimeMessage;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;
/**
 * A Producer to send messages using JavaMail.
 *  
 * @version $Revision$
 */
public class MailProducer extends DefaultProducer<MailExchange> {
    private static final transient Log LOG = LogFactory.getLog(MailProducer.class);
    private final MailEndpoint endpoint;
    private final JavaMailSender sender;
    public MailProducer(MailEndpoint endpoint, JavaMailSender sender) {
        super(endpoint);
        this.endpoint = endpoint;
        this.sender = sender;
    }
    public void process(final Exchange exchange) {
        sender.send(new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws Exception {
                endpoint.getBinding().populateMailMessage(endpoint, mimeMessage, exchange);
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Sending MimeMessage: "" + MailUtils.dumpMessage(mimeMessage));
                }
            }
        });
    }
}
"
org.apache.camel.component.jcr.JcrEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import java.net.URI;
import java.net.URISyntaxException;
import javax.jcr.Credentials;
import javax.jcr.Repository;
import javax.jcr.SimpleCredentials;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
/**
 * A JCR endpoint
 */
public class JcrEndpoint extends DefaultEndpoint<DefaultExchange> {
    private Credentials credentials;
    private Repository repository;
    private String base;
    @SuppressWarnings(""unchecked"")
    protected JcrEndpoint(String endpointUri, JcrComponent component) {
        super(endpointUri, component);
        try {
            URI uri = new URI(endpointUri);
            if (uri.getUserInfo() != null && uri.getAuthority() != null) {
                this.credentials = new SimpleCredentials(uri.getUserInfo(), uri.getAuthority().toCharArray());
            }
            this.repository = (Repository) component.getCamelContext().getRegistry().lookup(uri.getHost());
            if (repository == null) {
                throw new RuntimeCamelException(""No JCR repository defined under '"" + uri.getHost() + ""'"");
            }
            this.base = uri.getPath().replaceAll(""^/"", """");
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException(""Invalid URI: "" + endpointUri, e);
        }
    }
    public JcrEndpoint(String endpointUri, String base, Credentials credentials, Repository repository) {
        super(endpointUri);
        this.base = base;
        this.credentials = credentials;
        this.repository = repository;
    }
    /**
     * Currently unsupported
     * @throws RuntimeCamelException
     */
    public Consumer<DefaultExchange> createConsumer(Processor processor) throws Exception {
        throw new RuntimeCamelException(""No consumer endpoint support for JCR available"");
    }
    /**
     * Creates a new {@link Producer} 
     */
    public Producer<DefaultExchange> createProducer() throws Exception {
        return new JcrProducer(this);
    }
    /**
     * {@inheritDoc}
     */
    public boolean isSingleton() {
        return false;
    }
    /**
     * Get the {@link Repository}
     * 
     * @return the repository
     */
    protected Repository getRepository() {
        return repository;
    }
    /**
     * Get the {@link Credentials} for establishing the JCR repository connection
     * 
     * @return the credentials
     */
    protected Credentials getCredentials() {
        return credentials;
    }
    /**
     * Get the base node when accessing the reposititory
     * 
     * @return the base node
     */
    protected String getBase() {
        return base;
    }
}
"
org.apache.camel.component.mail.MailBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.util.Iterator;
import java.util.Map;
import javax.activation.DataHandler;
import javax.mail.Address;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Part;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.converter.ObjectConverter;
/**
 * A Strategy used to convert between a Camel {@link Exchange} and {@link Message} to and
 * from a Mail {@link MimeMessage}
 *
 * @version $Revision$
 */
public class MailBinding {
    public void populateMailMessage(MailEndpoint endpoint, MimeMessage mimeMessage, Exchange exchange)
        throws MessagingException {
        appendHeadersFromCamel(mimeMessage, exchange, exchange.getIn());
        // set the recipients (receivers) of the mail
        Map<Message.RecipientType, String> recipients = endpoint.getConfiguration().getRecipients();
        if (recipients.containsKey(Message.RecipientType.TO)) {
            mimeMessage.setRecipients(Message.RecipientType.TO, recipients.get(Message.RecipientType.TO));
        }
        if (recipients.containsKey(Message.RecipientType.CC)) {
            mimeMessage.setRecipients(Message.RecipientType.CC, recipients.get(Message.RecipientType.CC));
        }
        if (recipients.containsKey(Message.RecipientType.BCC)) {
            mimeMessage.setRecipients(Message.RecipientType.BCC, recipients.get(Message.RecipientType.BCC));
        }
        // must have at least one recipients otherwise we do not know where to send the mail
        if (mimeMessage.getAllRecipients() == null) {
            throw new IllegalArgumentException(""The mail message does not have any recipients set."");
        }
        if (empty(mimeMessage.getFrom())) {
            // lets default the address to the endpoint destination
            String from = endpoint.getConfiguration().getFrom();
            mimeMessage.setFrom(new InternetAddress(from));
        }
        if (exchange.getIn().hasAttachments()) {
            appendAttachmentsFromCamel(mimeMessage, exchange, exchange.getIn());
        } else {
            mimeMessage.setText(exchange.getIn().getBody(String.class));
        }
    }
    /**
     * Extracts the body from the Mail message
     */
    public Object extractBodyFromMail(MailExchange exchange, Message message) {
        try {
            return message.getContent();
        } catch (Exception e) {
            throw new RuntimeCamelException(""Failed to extract body due to: "" + e.getMessage()
                + "". Exchange: "" + exchange + "". Message: "" + message, e);
        }
    }
    /**
     * Appends the Mail headers from the Camel {@link MailMessage}
     */
    protected void appendHeadersFromCamel(MimeMessage mimeMessage, Exchange exchange,
                                          org.apache.camel.Message camelMessage)
        throws MessagingException {
        for (Map.Entry<String, Object> entry : camelMessage.getHeaders().entrySet()) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            if (headerValue != null) {
                if (shouldOutputHeader(camelMessage, headerName, headerValue)) {
                    // Mail messages can repeat the same header...
                    if (ObjectConverter.isCollection(headerValue)) {
                        Iterator iter = ObjectConverter.iterator(headerValue);
                        while (iter.hasNext()) {
                            Object value = iter.next();
                            mimeMessage.addHeader(headerName, asString(exchange, value));
                        }
                    } else {
                        mimeMessage.setHeader(headerName, asString(exchange, headerValue));
                    }
                }
            }
        }
    }
    /**
     * Appends the Mail attachments from the Camel {@link MailMessage}
     */
    protected void appendAttachmentsFromCamel(MimeMessage mimeMessage, Exchange exchange,
                                              org.apache.camel.Message camelMessage)
        throws MessagingException {
        // Create a Multipart
        MimeMultipart multipart = new MimeMultipart();
        // fill the body with text
        multipart.setSubType(""mixed"");
        MimeBodyPart textBodyPart = new MimeBodyPart();
        textBodyPart.setContent(exchange.getIn().getBody(String.class), ""text/plain"");
        multipart.addBodyPart(textBodyPart);
        for (Map.Entry<String, DataHandler> entry : camelMessage.getAttachments().entrySet()) {
            String attachmentFilename = entry.getKey();
            DataHandler handler = entry.getValue();
            if (handler != null) {
                if (shouldOutputAttachment(camelMessage, attachmentFilename, handler)) {
                    // Create another body part
                    BodyPart messageBodyPart = new MimeBodyPart();
                    // Set the data handler to the attachment
                    messageBodyPart.setDataHandler(handler);
                    // Set the filename
                    messageBodyPart.setFileName(attachmentFilename);
                    // Set Disposition
                    messageBodyPart.setDisposition(Part.ATTACHMENT);
                    // Add part to multipart
                    multipart.addBodyPart(messageBodyPart);
                }
            }
        }
        // Put parts in message
        mimeMessage.setContent(multipart);
    }
    /**
     * Strategy to allow filtering of headers which are put on the Mail message
     */
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName, Object headerValue) {
        return true;
    }
    /**
     * Strategy to allow filtering of attachments which are put on the Mail message
     */
    protected boolean shouldOutputAttachment(org.apache.camel.Message camelMessage, String attachmentFilename, DataHandler handler) {
        return true;
    }
    private static boolean empty(Address[] addresses) {
        return addresses == null || addresses.length == 0;
    }
    private static String asString(Exchange exchange, Object value) {
        return exchange.getContext().getTypeConverter().convertTo(String.class, value);
    }
}
"
org.apache.camel.component.cxf.interceptors.SoapMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
//import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.model.SoapBindingInfo;
import org.apache.cxf.common.logging.LogUtils;
//import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
public class SoapMessageInInterceptor extends AbstractMessageInInterceptor<SoapMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(SoapMessageInInterceptor.class);
    public SoapMessageInInterceptor() {
        super(Phase.READ);
    }
    protected Logger getLogger() {
        return LOG;
    }
    protected boolean isFaultMessage(SoapMessage message) {
        //Fault Processing is Handled in SOAP Binding in the ReadHeadersInterceptor.
        return false;
    }
    protected BindingOperationInfo getBindingOperation(SoapMessage message, Document doc) {
        Exchange ex = message.getExchange();
        SoapBindingInfo soapBinding = (SoapBindingInfo)ex.get(BindingInfo.class);
        Element payloadEl = (Element)doc.getChildNodes().item(0);
        QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
        // handling xml normal inbound message
        boolean client = isRequestor(message);
        List<BindingOperationInfo> boiList = new ArrayList<BindingOperationInfo>();
        for (BindingOperationInfo boi : soapBinding.getOperations()) {
            String style = soapBinding.getStyle(boi.getOperationInfo());
            QName rootName = null;
            if (""rpc"".equals(style)) {
                rootName = boi.getOperationInfo().getName();
            } else {
                BindingMessageInfo bmi = client ?  boi.getOutput() : boi.getInput();
                if (bmi != null) {
                    Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
                    if (bodyParts.size() == 1) {
                        MessagePartInfo p = bodyParts.iterator().next();
                        rootName = p.getConcreteName();
                    }
                }
            }
            if (startQName.equals(rootName)) {
                boiList.add(boi);
            }
        }
        if (boiList.size() > 1
            && LOG.isLoggable(Level.INFO)) {
            LOG.info(""Mulitple matching BindingOperationIno found in Binding."");
        }
        return boiList.size() != 1 ? null : boiList.get(0);
    }
    protected List<Element> getPartList(SoapMessage inMessage, Element rootNode, BindingMessageInfo bmi) {
        List<Element> partList = new ArrayList<Element>();
        Exchange ex = inMessage.getExchange();
        SoapBindingInfo soapBinding = (SoapBindingInfo)ex.get(BindingInfo.class);
        String style = soapBinding.getStyle(bmi.getBindingOperation().getOperationInfo());
        if (""rpc"".equals(style)) {
            //Remove the operation element.
            rootNode = (Element)DOMUtils.getChild(rootNode, Node.ELEMENT_NODE);
        }
        partList.add(rootNode);
        return partList;
    }
    protected Element getHeader(SoapMessage inMessage) {
        // need to find out the soap header information
        Element element = null;
        return element;
        // return inMessage.getHeaders(Element.class);
    }
}
"
org.apache.camel.component.cxf.util.NullDestination,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.io.IOException;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
public class NullDestination implements Destination {
    MessageObserver messageObserver;
    public NullDestination() {
        // do nothing here
    }
    public EndpointReferenceType getAddress() {
        return null;
    }
    public Conduit getBackChannel(Message inMessage, Message partialResponse, EndpointReferenceType address) throws IOException {
        return null;
    }
    public MessageObserver getMessageObserver() {
        return messageObserver;
    }
    public void shutdown() {
        messageObserver = null;
    }
    public void setMessageObserver(MessageObserver observer) {
        messageObserver = observer;
    }
}
"
org.apache.camel.component.mina.MinaExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.apache.mina.common.IoSession;
/**
 * A {@link Exchange} for Apache MINA.
 * 
 * @version $Revision$
 */
public class MinaExchange extends DefaultExchange {
    private IoSession session;
    public MinaExchange(CamelContext camelContext, ExchangePattern pattern, IoSession session) {
        super(camelContext, pattern);
        this.session = session;
    }
    /**
     * The associated Mina session, is <b>only</b> available for {@link MinaConsumer}.
     * 
     * @return the Mina session.
     */
    public IoSession getSession() {
        return session;
    }
}
"
org.apache.camel.component.event.EventEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.TopicLoadBalancer;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Endpoint</a>
 * for working with Spring ApplicationEvents
 *
 * @version $Revision$
 */
public class EventEndpoint extends DefaultEndpoint<Exchange> implements ApplicationContextAware {
    private LoadBalancer loadBalancer;
    private ApplicationContext applicationContext;
    public EventEndpoint(String endpointUri, EventComponent component) {
        super(endpointUri, component);
        this.applicationContext = component.getApplicationContext();
    }
    public EventEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                ApplicationEvent event = toApplicationEvent(exchange);
                getApplicationContext().publishEvent(event);
            }
        };
    }
    public EventConsumer createConsumer(Processor processor) throws Exception {
        return new EventConsumer(this, processor);
    }
    public void onApplicationEvent(ApplicationEvent event) {
        Exchange exchange = createExchange();
        exchange.getIn().setBody(event);
        try {
            getLoadBalancer().process(exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    public LoadBalancer getLoadBalancer() {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer();
        }
        return loadBalancer;
    }
    public void setLoadBalancer(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public synchronized void consumerStarted(EventConsumer consumer) {
        getLoadBalancer().addProcessor(consumer.getProcessor());
    }
    public synchronized void consumerStopped(EventConsumer consumer) {
        getLoadBalancer().removeProcessor(consumer.getProcessor());
    }
    protected LoadBalancer createLoadBalancer() {
        return new TopicLoadBalancer();
    }
    protected ApplicationEvent toApplicationEvent(Exchange exchange) {
        ApplicationEvent event = exchange.getIn().getBody(ApplicationEvent.class);
        if (event == null) {
            event = new CamelEvent(this, exchange);
        }
        return event;
    }
}
"
org.apache.camel.spring.Main,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.RouteType;
import org.apache.camel.processor.interceptor.Debugger;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.view.RouteDotGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
/**
 * A command line tool for booting up a CamelContext using an optional Spring
 * ApplicationContext
 *
 * @version $Revision$
 */
public class Main extends ServiceSupport {
    private static final Log LOG = LogFactory.getLog(Main.class);
    private String applicationContextUri = ""META-INF/spring/*.xml"";
    private String fileApplicationContextUri;
    private AbstractApplicationContext applicationContext;
    private List<Option> options = new ArrayList<Option>();
    private CountDownLatch latch = new CountDownLatch(1);
    private AtomicBoolean completed = new AtomicBoolean(false);
    private long duration = -1;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    private String dotOutputDir;
    private boolean aggregateDot;
    private boolean debug;
    private boolean trace;
    private List<RouteBuilder> routeBuilders = new ArrayList<RouteBuilder>();
    private List<SpringCamelContext> camelContexts = new ArrayList<SpringCamelContext>();
    private AbstractApplicationContext parentApplicationContext;
    private String parentApplicationContextUri;
    private ProducerTemplate camelTemplate;
    public Main() {
        addOption(new Option(""h"", ""help"", ""Displays the help screen"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                showOptions();
                completed();
            }
        });
        addOption(new ParameterOption(""a"", ""applicationContext"",
                ""Sets the classpath based spring ApplicationContext"", ""applicationContext"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setApplicationContextUri(parameter);
            }
        });
        addOption(new ParameterOption(""fa"", ""fileApplicationContext"",
                ""Sets the filesystem based spring ApplicationContext"", ""fileApplicationContext"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setFileApplicationContextUri(parameter);
            }
        });
        addOption(new ParameterOption(""o"", ""outdir"",
                ""Sets the DOT output directory where the visual representations of the routes are generated"",
                ""dot"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setDotOutputDir(parameter);
            }
        });
        addOption(new ParameterOption(""ad"", ""aggregate-dot"",
                ""Aggregates all routes (in addition to individual route generation) into one context to create one monolithic DOT file for visual representations the entire system."",
                ""aggregate-dot"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setAggregateDot(""true"".equals(parameter));
            }
        });
        addOption(new ParameterOption(""d"", ""duration"",
                ""Sets the time duration that the applicaiton will run for, by default in milliseconds. You can use '10s' for 10 seconds etc"",
                ""duration"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                String value = parameter.toUpperCase();
                if (value.endsWith(""S"")) {
                    value = value.substring(0, value.length() - 1);
                    setTimeUnit(TimeUnit.SECONDS);
                }
                setDuration(Integer.parseInt(value));
            }
        });
        addOption(new Option(""x"", ""debug"", ""Enables the debugger"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                enableDebug();
            }
        });
        addOption(new Option(""t"", ""trace"", ""Enables tracing"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                enableTrace();
            }
        });
    }
    public static void main(String... args) {
        new Main().run(args);
    }
    /**
     * Parses the command line arguments then runs the program
     */
    public void run(String[] args) {
        parseArguments(args);
        run();
    }
    /**
     * Runs this process with the given arguments
     */
    public void run() {
        if (!completed.get()) {
            try {
                start();
                waitUntilCompleted();
                stop();
            } catch (Exception e) {
                LOG.error(""Failed: "" + e, e);
            }
        }
    }
    /**
     * Marks this process as being completed
     */
    public void completed() {
        completed.set(true);
        latch.countDown();
    }
    public void addRouteBuilder(RouteBuilder routeBuilder) {
        getRouteBuilders().add(routeBuilder);
    }
    /**
     * Displays the command line options
     */
    public void showOptions() {
        System.out.println(""Apache Camel Runner takes the following options"");
        System.out.println();
        for (Option option : options) {
            System.out.println(""  "" + option.getAbbreviation() + "" or "" + option.getFullName() + "" = ""
                    + option.getDescription());
        }
    }
    /**
     * Parses the commandl ine arguments
     */
    public void parseArguments(String[] arguments) {
        LinkedList<String> args = new LinkedList<String>(Arrays.asList(arguments));
        boolean valid = true;
        while (!args.isEmpty()) {
            String arg = args.removeFirst();
            boolean handled = false;
            for (Option option : options) {
                if (option.processOption(arg, args)) {
                    handled = true;
                    break;
                }
            }
            if (!handled) {
                System.out.println(""Unknown option: "" + arg);
                System.out.println();
                valid = false;
                break;
            }
        }
        if (!valid) {
            showOptions();
            completed();
        }
    }
    public void addOption(Option option) {
        options.add(option);
    }
    public abstract class Option {
        private String abbreviation;
        private String fullName;
        private String description;
        protected Option(String abbreviation, String fullName, String description) {
            this.abbreviation = ""-"" + abbreviation;
            this.fullName = ""-"" + fullName;
            this.description = description;
        }
        public boolean processOption(String arg, LinkedList<String> remainingArgs) {
            if (arg.equalsIgnoreCase(abbreviation) || fullName.startsWith(arg)) {
                doProcess(arg, remainingArgs);
                return true;
            }
            return false;
        }
        public String getAbbreviation() {
            return abbreviation;
        }
        public String getDescription() {
            return description;
        }
        public String getFullName() {
            return fullName;
        }
        protected abstract void doProcess(String arg, LinkedList<String> remainingArgs);
    }
    public abstract class ParameterOption extends Option {
        private String parameterName;
        protected ParameterOption(String abbreviation, String fullName, String description,
                String parameterName) {
            super(abbreviation, fullName, description);
            this.parameterName = parameterName;
        }
        protected void doProcess(String arg, LinkedList<String> remainingArgs) {
            if (remainingArgs.isEmpty()) {
                System.err.println(""Expected fileName for "");
                showOptions();
                completed();
            } else {
                String parameter = remainingArgs.removeFirst();
                doProcess(arg, parameter, remainingArgs);
            }
        }
        protected abstract void doProcess(String arg, String parameter, LinkedList<String> remainingArgs);
    }
    // Properties
    // -------------------------------------------------------------------------
    public AbstractApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(AbstractApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String getApplicationContextUri() {
        return applicationContextUri;
    }
    public void setApplicationContextUri(String applicationContextUri) {
        this.applicationContextUri = applicationContextUri;
    }
    public String getFileApplicationContextUri() {
        return fileApplicationContextUri;
    }
    public void setFileApplicationContextUri(String fileApplicationContextUri) {
        this.fileApplicationContextUri = fileApplicationContextUri;
    }
    public AbstractApplicationContext getParentApplicationContext() {
        if (parentApplicationContext == null) {
            if (parentApplicationContextUri != null) {
                parentApplicationContext = new ClassPathXmlApplicationContext(parentApplicationContextUri);
                parentApplicationContext.start();
            }
        }
        return parentApplicationContext;
    }
    public void setParentApplicationContext(AbstractApplicationContext parentApplicationContext) {
        this.parentApplicationContext = parentApplicationContext;
    }
    public String getParentApplicationContextUri() {
        return parentApplicationContextUri;
    }
    public void setParentApplicationContextUri(String parentApplicationContextUri) {
        this.parentApplicationContextUri = parentApplicationContextUri;
    }
    public List<SpringCamelContext> getCamelContexts() {
        return camelContexts;
    }
    public long getDuration() {
        return duration;
    }
    /**
     * Sets the duration to run the application for in milliseconds until it
     * should be terminated. Defaults to -1. Any value <= 0 will run forever.
     *
     * @param duration
     */
    public void setDuration(long duration) {
        this.duration = duration;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    /**
     * Sets the time unit duration
     */
    public void setTimeUnit(TimeUnit timeUnit) {
        this.timeUnit = timeUnit;
    }
    public String getDotOutputDir() {
        return dotOutputDir;
    }
    /**
     * Sets the output directory of the generated DOT Files to show the visual
     * representation of the routes. A null value disables the dot file
     * generation
     */
    public void setDotOutputDir(String dotOutputDir) {
        this.dotOutputDir = dotOutputDir;
    }
    public List<RouteBuilder> getRouteBuilders() {
        return routeBuilders;
    }
    public void setRouteBuilders(List<RouteBuilder> routeBuilders) {
        this.routeBuilders = routeBuilders;
    }
    public void setAggregateDot(boolean aggregateDot) {
        this.aggregateDot = aggregateDot;
    }
    public boolean isAggregateDot() {
        return aggregateDot;
    }
    public boolean isDebug() {
        return debug;
    }
    public void enableDebug() {
        this.debug = true;
        setParentApplicationContextUri(""/META-INF/services/org/apache/camel/spring/debug.xml"");
    }
    public boolean isTrace() {
        return trace;
    }
    public void enableTrace() {
        this.trace = true;
        setParentApplicationContextUri(""/META-INF/services/org/apache/camel/spring/trace.xml"");
    }
    /**
     * Returns the currently active debugger if one is enabled
     *
     * @return the current debugger or null if none is active
     * @see #enableDebug()
     */
    public Debugger getDebugger() {
        for (SpringCamelContext camelContext : camelContexts) {
            Debugger debugger = Debugger.getDebugger(camelContext);
            if (debugger != null) {
                return debugger;
            }
        }
        return null;
    }
    public List<RouteType> getRouteDefinitions() {
        List<RouteType> answer = new ArrayList<RouteType>();
        for (SpringCamelContext camelContext : camelContexts) {
            answer.addAll(camelContext.getRouteDefinitions());
        }
        return answer;
    }
    /**
     * Returns a {@link ProducerTemplate} from the Spring {@link ApplicationContext} instances
     * or lazily creates a new one dynamically
     *
     * @return
     */
    public ProducerTemplate getCamelTemplate() {
        if (camelTemplate == null) {
            camelTemplate = findOrCreateCamelTemplate();
        }
        return camelTemplate;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected ProducerTemplate findOrCreateCamelTemplate() {
        String[] names = getApplicationContext().getBeanNamesForType(ProducerTemplate.class);
        if (names != null && names.length > 0) {
            return (ProducerTemplate) getApplicationContext().getBean(names[0], ProducerTemplate.class);
        }
        for (SpringCamelContext camelContext : camelContexts) {
            return camelContext.createProducerTemplate();
        }
        throw new IllegalArgumentException(""No CamelContexts are available so cannot create a ProducerTemplate!"");
    }
    protected void doStart() throws Exception {
        LOG.info(""Apache Camel "" + getVersion() + "" starting"");
        if (applicationContext == null) {
            applicationContext = createDefaultApplicationContext();
        }
        applicationContext.start();
        postProcessContext();
    }
    protected AbstractApplicationContext createDefaultApplicationContext() {
        // file based
        if (getFileApplicationContextUri() != null) {
            String[] args = getFileApplicationContextUri().split("";"");
            ApplicationContext parentContext = getParentApplicationContext();
            if (parentContext != null) {
                return new FileSystemXmlApplicationContext(args, parentContext);
            } else {
                return new FileSystemXmlApplicationContext(args);
            }
        }
        // default to classpath based
        String[] args = getApplicationContextUri().split("";"");
        ApplicationContext parentContext = getParentApplicationContext();
        if (parentContext != null) {
            return new ClassPathXmlApplicationContext(args, parentContext);
        } else {
            return new ClassPathXmlApplicationContext(args);
        }
    }
    protected void doStop() throws Exception {
        LOG.info(""Apache Camel terminating"");
        if (applicationContext != null) {
            applicationContext.close();
        }
    }
    protected void waitUntilCompleted() {
        while (!completed.get()) {
            try {
                if (duration > 0) {
                    TimeUnit unit = getTimeUnit();
                    LOG.info(""Waiting for: "" + duration + "" "" + unit);
                    latch.await(duration, unit);
                    completed.set(true);
                } else {
                    latch.await();
                }
            } catch (InterruptedException e) {
                LOG.debug(""Caught: "" + e);
            }
        }
    }
    protected void postProcessContext() throws Exception {
        Map<String, SpringCamelContext> map = applicationContext.getBeansOfType(SpringCamelContext.class);
        Set<Map.Entry<String, SpringCamelContext>> entries = map.entrySet();
        int size = entries.size();
        for (Map.Entry<String, SpringCamelContext> entry : entries) {
            String name = entry.getKey();
            SpringCamelContext camelContext = entry.getValue();
            camelContexts.add(camelContext);
            generateDot(name, camelContext, size);
            postProcesCamelContext(camelContext);
        }
        if (isAggregateDot()) {
            generateDot(""aggregate"", aggregateSpringCamelContext(applicationContext), 1);
        }
    }
    protected void generateDot(String name, SpringCamelContext camelContext, int size) throws IOException {
        String outputDir = dotOutputDir;
        if (ObjectHelper.isNotNullAndNonEmpty(outputDir)) {
            if (size > 1) {
                outputDir += ""/"" + name;
            }
            RouteDotGenerator generator = new RouteDotGenerator(outputDir);
            LOG.info(""Generating DOT file for routes: "" + outputDir + "" for: "" + camelContext + "" with name: "" + name);
            generator.drawRoutes(camelContext);
        }
    }
    /**
     * Used for aggregate dot generation
     *
     * @param applicationContext
     * @return
     * @throws Exception
     */
    private static SpringCamelContext aggregateSpringCamelContext(ApplicationContext applicationContext) throws Exception {
        SpringCamelContext aggregateCamelContext = new SpringCamelContext() {
            /**
             *  Don't actually start this, it is merely fabricated for dot generation.
             * @see org.apache.camel.impl.DefaultCamelContext#shouldStartRoutes()
             */
            protected boolean shouldStartRoutes() {
                return false;
            }
        };
        // look up all configured camel contexts
        String[] names = applicationContext.getBeanNamesForType(SpringCamelContext.class);
        for (String name : names) {
            SpringCamelContext next = (SpringCamelContext) applicationContext.getBean(name, SpringCamelContext.class);
            //            aggregateCamelContext.addRoutes( next.getRoutes() );
            aggregateCamelContext.addRouteDefinitions(next.getRouteDefinitions());
        }
        // Don't actually start this, it is merely fabricated for dot generation.
        //        answer.setApplicationContext( applicationContext );
        //        answer.afterPropertiesSet();
        return aggregateCamelContext;
    }
    protected void postProcesCamelContext(CamelContext camelContext) throws Exception {
        for (RouteBuilder routeBuilder : routeBuilders) {
            camelContext.addRoutes(routeBuilder);
        }
    }
    protected String getVersion() {
        Package aPackage = Package.getPackage(""org.apache.camel"");
        if (aPackage != null) {
            String version = aPackage.getImplementationVersion();
            if (version == null) {
                version = aPackage.getSpecificationVersion();
                if (version == null) {
                    version = """";
                }
            }
            return version;
        }
        return """";
    }
}
"
org.apache.camel.component.irc.IrcBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
public class IrcBinding {
    public Object extractBodyFromIrc(IrcExchange exchange, IrcMessage message) {
        String type = message.getMessageType();
        String text = message.getMessage();
        if (text != null) {
            return text;
        } else {
            return type;
        }
    }
}
"
org.apache.camel.bam.processor.ProcessContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.ProcessRules;
/**
 * @version $Revision$
 */
public class ProcessContext {
    private Exchange exchange;
    private ProcessRules processRules;
    private ActivityRules activityRules;
    private ProcessInstance processInstance;
    private ActivityState activityState;
    public ProcessContext(Exchange exchange, ActivityRules activityRules, ActivityState activityState) {
        this.exchange = exchange;
        this.activityRules = activityRules;
        this.activityState = activityState;
        this.processRules = activityRules.getProcessRules();
        this.processInstance = activityState.getProcessInstance();
    }
    public ActivityRules getActivity() {
        return activityRules;
    }
    public void setActivity(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public ActivityState getActivityState() {
        return activityState;
    }
    public void setActivityState(ActivityState activityState) {
        this.activityState = activityState;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    public ProcessRules getProcessDefinition() {
        return processRules;
    }
    public void setProcessDefinition(ProcessRules processRules) {
        this.processRules = processRules;
    }
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
    }
    public ActivityState getActivityState(ActivityRules activityRules) {
        return getProcessInstance().getActivityState(activityRules);
    }
    /**
     * Called when the activity is started which may end up creating some timers
     * for dependent actions
     */
    public void onStarted(ActivityState activityState) {
        /** TODO */
    }
    /**
     * Called when the activity is completed which may end up creating some timers
     * for dependent actions
     */
    public void onCompleted(ActivityState activityState) {
        /** TODO */
    }
}
"
org.apache.camel.language.groovy.GroovyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import java.util.AbstractMap;
import java.util.Collections;
import java.util.Set;
import groovy.lang.Binding;
import groovy.lang.Script;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.util.ExchangeHelper;
/**
 * @version $Revision$
 */
public class GroovyExpression extends ExpressionSupport<Exchange> {
    private Class<Script> scriptType;
    private String text;
    public GroovyExpression(Class<Script> scriptType, String text) {
        this.scriptType = scriptType;
        this.text = text;
    }
    @Override
    public String toString() {
        return ""groovy: "" + text;
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return ""groovy: "" + text;
    }
    public Object evaluate(Exchange exchange) {
        Script script = ExchangeHelper.newInstance(exchange, scriptType);
        // lets configure the script
        configure(exchange, script);
        return script.run();
    }
    private void configure(Exchange exchange, Script script) {
        final Binding binding = script.getBinding();
        ExchangeHelper.populateVariableMap(exchange, new AbstractMap<String, Object>() {
            @Override
            public Object put(String key, Object value) {
                binding.setProperty(key, value);
                return null;
            }
            public Set entrySet() {
                return Collections.EMPTY_SET;
            }
        });
    }
}
"
org.apache.camel.component.mina.MinaPayloadHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.Exchange;
/**
 * Helper to get and set the correct payload when transfering data using camel-mina.
 * Always use this helper instead of direct access on the exchange object.
 * <p/>
 * This helper ensures that we can also transfer exchange objects over the wire using the
 * <tt>exchangePayload=true</tt> option.
 *
 * @see org.apache.camel.component.mina.MinaPayloadHolder
 * @version $Revision$
 */
public final class MinaPayloadHelper {
    private MinaPayloadHelper() {
        //Utility Class
    }
    public static Object getIn(MinaEndpoint endpoint, Exchange exchange) {
        if (endpoint.isTransferExchange()) {
            // we should transfer the entire exchange over the wire (includes in/out)
            return MinaPayloadHolder.marshal(exchange);
        } else {
            // normal transfer using the body only
            return exchange.getIn().getBody();
        }
    }
    public static Object getOut(MinaEndpoint endpoint, Exchange exchange) {
        if (endpoint.isTransferExchange()) {
            // we should transfer the entire exchange over the wire (includes in/out)
            return MinaPayloadHolder.marshal(exchange);
        } else {
            // normal transfer using the body only
            return exchange.getOut().getBody();
        }
    }
    public static void setIn(Exchange exchange, Object payload) {
        if (payload instanceof MinaPayloadHolder) {
            MinaPayloadHolder.unmarshal(exchange, (MinaPayloadHolder) payload);
        } else {
            // normal transfer using the body only
            exchange.getIn().setBody(payload);
        }
    }
    public static void setOut(Exchange exchange, Object payload) {
        if (payload instanceof MinaPayloadHolder) {
            MinaPayloadHolder.unmarshal(exchange, (MinaPayloadHolder) payload);
        } else {
            // normal transfer using the body only
            exchange.getOut().setBody(payload);
        }
    }
}
"
org.apache.camel.component.jpa.DeleteHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
/**
 * A strategy for deleting entity beans which have been processed; either by a real delete or by an update of some
 * application specific properties so that the entity bean will not be found in future polling queries.
 *
 * @version $Revision$
 */
public interface DeleteHandler<T> {
    /**
     * Deletes the entity bean after it has been processed either by actually
     * deleting the object or updating it in a way so that future queries do not return this object again.
     *
     * @param entityManager
     * @param entityBean    the entity bean that has been processed and should be deleted
     */
    void deleteObject(EntityManager entityManager, Object entityBean);
}
"
org.apache.camel.component.jms.MessagePropertyNamesAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyNamesAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessagePropertyNamesAccessException(JMSException e) {
        super(""Failed to access the JMS message property names: "" + e, e);
    }
}
"
org.apache.camel.component.cxf.invoker.CxfClientFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import javax.xml.ws.soap.SOAPBinding;
import org.apache.cxf.BusException;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.EndpointException;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.jaxws.binding.soap.JaxWsSoapBindingConfiguration;
import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.factory.ServiceConstructionException;
public class CxfClientFactoryBean extends ClientFactoryBean {
    private boolean isJSR181Enabled;
    public CxfClientFactoryBean() {
        super();        
    }
    public void setJSR181Enabled(boolean enabled) {
        if (enabled) {
            setServiceFactory(new JaxWsServiceFactoryBean());            
        } else {
            setServiceFactory(new ReflectionServiceFactoryBean());
        }
        isJSR181Enabled = enabled;
    }
    @Override
    public void setBindingId(String bind) {
        super.setBindingId(bind);
        if (isJSR181Enabled) {
            if (SOAPBinding.SOAP11HTTP_BINDING.equals(bind)
                || SOAPBinding.SOAP12HTTP_BINDING.equals(bind)) {
                setBindingConfig(new JaxWsSoapBindingConfiguration((JaxWsServiceFactoryBean)getServiceFactory()));
            } else if (SOAPBinding.SOAP11HTTP_MTOM_BINDING.equals(bind)
                || SOAPBinding.SOAP12HTTP_MTOM_BINDING.equals(bind)) {
                setBindingConfig(new JaxWsSoapBindingConfiguration((JaxWsServiceFactoryBean)getServiceFactory()));
                ((JaxWsSoapBindingConfiguration)getBindingConfig()).setMtomEnabled(true);
            }
        }    
    }
    protected void createClient(Endpoint ep) {
        CxfClient client = new CxfClient(getBus(), ep);
        setClient(client);
    }
}
"
org.apache.camel.component.cxf.util.Dummy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
// Dummy class for setting service class
public class Dummy {
}
"
org.apache.camel.component.xmpp.XmppGroupChatProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smackx.muc.MultiUserChat;
/**
 * @version $Revision$
 */
public class XmppGroupChatProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(XmppGroupChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String room;
    private MultiUserChat chat;
    public XmppGroupChatProducer(XmppEndpoint endpoint, String room) {
        super(endpoint);
        this.endpoint = endpoint;
        this.room = room;
        if (room == null) {
            throw new IllegalArgumentException(""No room property specified"");
        }
    }
    public void process(Exchange exchange) {
        // TODO it would be nice if we could reuse the message from the exchange
        Message message = chat.createMessage();
        message.setTo(room);
        message.setFrom(endpoint.getUser());
        endpoint.getBinding().populateXmppMessage(message, exchange);
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> message: "" + message.getBody());
        }
        try {
            chat.sendMessage(message);
        } catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (chat == null) {
            chat = new MultiUserChat(endpoint.getConnection(), room);
            String nickname = this.endpoint.getNickname();
            chat.join(nickname != null ? nickname : this.endpoint.getUser());
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (chat != null) {
            chat.leave();
            chat = null;
        }
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public MultiUserChat getChat() {
        return chat;
    }
    public void setChat(MultiUserChat chat) {
        this.chat = chat;
    }
    public String getRoom() {
        return room;
    }
}
"
org.apache.camel.spring.spi.ApplicationContextRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.spi.Registry;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.context.ApplicationContext;
/**
 * A {@link Registry} implementation which looks up the objects in the Spring
 * {@link ApplicationContext}
 * 
 * @version $Revision$
 */
public class ApplicationContextRegistry implements Registry {
    private ApplicationContext applicationContext;
    public ApplicationContextRegistry(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public <T> T lookup(String name, Class<T> type) {
        try {
            Object value = applicationContext.getBean(name, type);
            return type.cast(value);
        } catch (NoSuchBeanDefinitionException e) {
            return null;
        }
    }
    public Object lookup(String name) {
        try {
            return applicationContext.getBean(name);
        } catch (NoSuchBeanDefinitionException e) {
            return null;
        }
    }
}
"
org.apache.camel.component.file.remote.RemoteFileProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.Message;
import org.apache.camel.component.file.FileComponent;
import org.apache.camel.impl.DefaultProducer;
public abstract class RemoteFileProducer<T extends RemoteFileExchange> extends DefaultProducer<T> {
    protected RemoteFileProducer(RemoteFileEndpoint<T> endpoint) {
        super(endpoint);
    }
    protected String createFileName(Message message, RemoteFileConfiguration fileConfig) {
        String answer;
        String endpointFileName = fileConfig.getFile();
        String headerFileName = message.getHeader(FileComponent.HEADER_FILE_NAME, String.class);
        if (fileConfig.isDirectory()) {
            // If the path isn't empty, we need to add a trailing / if it isn't already there
            String baseDir = """";
            if (endpointFileName.length() > 0) {
                baseDir = endpointFileName + (endpointFileName.endsWith(""/"") ? """" : ""/"");
            }
            String fileName = (headerFileName != null) ? headerFileName : message.getMessageId();
            answer = baseDir + fileName;
        } else {
            answer = endpointFileName;
        }
        return answer;
    }
    protected abstract void connectIfNecessary() throws Exception;
    protected abstract void disconnect() throws Exception;
}
"
org.apache.camel.component.xmpp.XmppComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class XmppComponent extends DefaultComponent<XmppExchange> {
    public XmppComponent() {
    }
    public XmppComponent(CamelContext context) {
        super(context);
    }
    /**
     * Static builder method
     */
    public static XmppComponent xmppComponent() {
        return new XmppComponent();
    }
    @Override
    protected Endpoint<XmppExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        XmppEndpoint endpoint = new XmppEndpoint(uri, this);
        URI u = new URI(uri);
        endpoint.setHost(u.getHost());
        endpoint.setPort(u.getPort());
        if (u.getUserInfo() != null) {
            endpoint.setUser(u.getUserInfo());
        }
        String remainingPath = u.getPath();
        if (remainingPath != null) {
            if (remainingPath.startsWith(""/"")) {
                remainingPath = remainingPath.substring(1);
            }
            // assume its a participant
            if (remainingPath.length() > 0) {
                endpoint.setParticipant(remainingPath);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.component.atom.AtomEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.util.Date;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultPollingEndpoint;
import org.apache.camel.util.ObjectHelper;
/**
 * An <a href=""http://activemq.apache.org/camel/atom.html"">Atom Endpoint</a>.
 *
 * @version $Revision$
 */
public class AtomEndpoint extends DefaultPollingEndpoint<Exchange> {
    /**
     * Header key for the {@link org.apache.abdera.model.Feed} object is stored on the in message on the exchange.
     */
    public static final String HEADER_ATOM_FEED = ""org.apache.camel.component.atom.feed"";
    private String atomUri;
    private boolean splitEntries = true;
    private Date lastUpdate;
    private boolean filter = true;
    public AtomEndpoint(String endpointUri, AtomComponent component, String atomUri) {
        super(endpointUri, component);
        this.atomUri = atomUri;
        ObjectHelper.notNull(atomUri, ""atomUri property"");
    }
    public AtomEndpoint(String endpointUri, String atomUri) {
        this(endpointUri);
        this.atomUri = atomUri;
        ObjectHelper.notNull(atomUri, ""atomUri property"");
    }
    public AtomEndpoint(String endpointUri) {
        super(endpointUri);
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer<Exchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""AtomProducer is not implemented"");
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        AtomConsumerSupport answer;
        if (isSplitEntries()) {
            answer = new AtomEntryPollingConsumer(this, processor, filter, lastUpdate);
        } else {
            answer = new AtomPollingConsumer(this, processor);
        }
        // ScheduledPollConsumer default delay is 500 millis and that is too often for polling a feed,
        // so we override with a new default value. End user can override this value by providing a consumer.delay parameter
        answer.setDelay(AtomConsumerSupport.DEFAULT_CONSUMER_DELAY);
        configureConsumer(answer);
        return answer;
    }
    /**
     * Creates an Exchange with the entries as the in body.
     *
     * @param feed   the atom feed
     * @return the created exchange
     */
    public Exchange createExchange(Feed feed) {
        Exchange exchange = createExchange();
        exchange.getIn().setBody(feed.getEntries());
        exchange.getIn().setHeader(HEADER_ATOM_FEED, feed);
        return exchange;
    }
    /**
     * Creates an Exchange with the given entry as the in body.
     *
     * @param feed   the atom feed
     * @param entry  the entry as the in body
     * @return the created exchange
     */
    public Exchange createExchange(Feed feed, Entry entry) {
        Exchange exchange = createExchange();
        exchange.getIn().setBody(entry);
        exchange.getIn().setHeader(HEADER_ATOM_FEED, feed);
        return exchange;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getAtomUri() {
        return atomUri;
    }
    public void setAtomUri(String atomUri) {
        this.atomUri = atomUri;
    }
    public boolean isSplitEntries() {
        return splitEntries;
    }
    /**
     * Sets whether or not entries should be sent individually or whether the entire
     * feed should be sent as a single message
     */
    public void setSplitEntries(boolean splitEntries) {
        this.splitEntries = splitEntries;
    }
    public Date getLastUpdate() {
        return lastUpdate;
    }
    /**
     * Sets the timestamp to be used for filtering entries from the atom feeds.
     * This options is only in conjunction with the splitEntries.
     */
    public void setLastUpdate(Date lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
    public boolean isFilter() {
        return filter;
    }
    /**
     * Sets wether to use filtering or not of the entries.
     */
    public void setFilter(boolean filter) {
        this.filter = filter;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
}
"
org.apache.camel.component.cxf.interceptors.XMLMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.apache.cxf.binding.xml.XMLConstants;
import org.apache.cxf.binding.xml.XMLFault;
import org.apache.cxf.bindings.xformat.XMLBindingMessageFormat;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
import org.apache.cxf.staxutils.StaxUtils;
public class XMLMessageInInterceptor extends AbstractMessageInInterceptor<XMLMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(XMLMessageInInterceptor.class);
    public XMLMessageInInterceptor() {
        super(Phase.READ);        
    }
    protected Logger getLogger() {
        return LOG;
    }
    protected boolean isFaultMessage(XMLMessage message) {
        XMLStreamReader xsr = message.getContent(XMLStreamReader.class);
        boolean isFault = false;
        try {
            if (StaxUtils.skipToStartOfElement(xsr)) {
                QName startQName = xsr.getName();
                isFault = XMLConstants.NS_XML_FORMAT.equals(startQName.getNamespaceURI())
                          && XMLFault.XML_FAULT_ROOT.equals(startQName.getLocalPart());
            }
        } catch (XMLStreamException xse) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""STAX_READ_EXC"", LOG));
        }
        return isFault;
    }
    protected BindingOperationInfo getBindingOperation(XMLMessage message, Document doc) {
        Exchange ex = message.getExchange();
        BindingInfo binding = ex.get(BindingInfo.class);
        if (binding == null) {
            Endpoint ep = ex.get(Endpoint.class);
            binding = ep.getEndpointInfo().getBinding();
        }
        //TODO if binding is null throw exception.
        Element payloadEl = (Element)doc.getChildNodes().item(0);
        QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
        // handling xml normal inbound message
        boolean client = isRequestor(message);
        List<BindingOperationInfo> boiList = new ArrayList<BindingOperationInfo>();
        for (BindingOperationInfo boi : binding.getOperations()) {
            BindingMessageInfo bmi = client ?  boi.getOutput() : boi.getInput();
            QName rootName = null;
            if (bmi != null) {
                XMLBindingMessageFormat msgFormat =
                    bmi.getExtensor(XMLBindingMessageFormat.class);
                if (msgFormat != null) {
                    rootName = msgFormat.getRootNode();
                } else {
                    Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
                    if (bodyParts.size() == 1) {
                        MessagePartInfo p = bodyParts.iterator().next();
                        rootName = p.getConcreteName();
                    }
                }
            }
            if (startQName.equals(rootName)) {
                boiList.add(boi);
            }
        }
        BindingOperationInfo match = null;
        if (boiList.size() > 1) {
            if (LOG.isLoggable(Level.INFO)) {
                LOG.info(""Mulitple matching BindingOperationIno found in Binding."");
            }
        } else if (!boiList.isEmpty()) {
            match = boiList.get(0);
        }
        return match; 
    }
    protected List<Element> getPartList(XMLMessage inMessage, Element rootNode, BindingMessageInfo bmi) {
        List<Element> partList = new ArrayList<Element>();
        XMLBindingMessageFormat msgFormat =
            bmi.getExtensor(XMLBindingMessageFormat.class);
        if (msgFormat != null) {
            NodeList nodeList = rootNode.getChildNodes();
            for (int idx = 0; idx < nodeList.getLength(); idx++) {
                partList.add((Element)nodeList.item(idx));
            }
        } else {
            partList.add(rootNode);
        }
        return partList;
    }
    protected Element getHeader(XMLMessage inMessage) {
        return null;
    }
}
"
org.apache.camel.component.atom.AtomConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.atom;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.apache.camel.Converter;
/**
 * Date converters.
 */
@Converter
public final class AtomConverter {
    public static final String DATE_PATTERN_NO_TIMEZONE = ""yyyy-MM-dd'T'HH:mm:ss"";
    private AtomConverter() {
        //Helper class
    }
    @Converter
    public static Date toDate(String text) throws ParseException {
        DateFormat sdf = new SimpleDateFormat(DATE_PATTERN_NO_TIMEZONE);
        return sdf.parse(text);
    }
}
"
org.apache.camel.component.jms.JmsPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import org.apache.camel.impl.PollingConsumerSupport;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
/**
 * @version $Revision$
 */
public class JmsPollingConsumer extends PollingConsumerSupport<JmsExchange> {
    private JmsOperations template;
    public JmsPollingConsumer(JmsEndpoint endpoint, JmsOperations template) {
        super(endpoint);
        this.template = template;
    }
    @Override
    public JmsEndpoint getEndpoint() {
        return (JmsEndpoint)super.getEndpoint();
    }
    public JmsExchange receiveNoWait() {
        return receive(0);
    }
    public JmsExchange receive() {
        return receive(-1);
    }
    public JmsExchange receive(long timeout) {
        setReceiveTimeout(timeout);
        Message message = template.receive();
        if (message != null) {
            return getEndpoint().createExchange(message);
        }
        return null;
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
    protected void setReceiveTimeout(long timeout) {
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate)template;
            jmsTemplate.setReceiveTimeout(timeout);
        } else if (template instanceof JmsTemplate102) {
            JmsTemplate102 jmsTemplate102 = (JmsTemplate102)template;
            jmsTemplate102.setReceiveTimeout(timeout);
        } else {
            throw new IllegalArgumentException(""Cannot set the receiveTimeout property on unknown JmsOperations type: "" + template);
        }
    }
}
"
org.apache.camel.component.xmpp.XmppMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.jivesoftware.smack.packet.Message;
/**
 * Represents a {@link org.apache.camel.Message} for working with XMPP
 * 
 * @version $Revision:520964 $
 */
public class XmppMessage extends DefaultMessage {
    private Message xmppMessage;
    public XmppMessage() {
        this(new Message());
    }
    public XmppMessage(Message jmsMessage) {
        this.xmppMessage = jmsMessage;
    }
    @Override
    public String toString() {
        if (xmppMessage != null) {
            return ""XmppMessage: "" + xmppMessage;
        } else {
            return ""XmppMessage: "" + getBody();
        }
    }
    @Override
    public XmppExchange getExchange() {
        return (XmppExchange)super.getExchange();
    }
    /**
     * Returns the underlying XMPP message
     * 
     * @return the underlying XMPP message
     */
    public Message getXmppMessage() {
        return xmppMessage;
    }
    public void setXmppMessage(Message xmppMessage) {
        this.xmppMessage = xmppMessage;
    }
    public Object getHeader(String name) {
        return xmppMessage.getProperty(name);
    }
    @Override
    public void setHeader(String name, Object value) {
        if (value == null) {
            xmppMessage.deleteProperty(name);
        } else {
            xmppMessage.setProperty(name, value);
        }
    }
    @Override
    public Map<String, Object> getHeaders() {
        Map<String, Object> answer = new HashMap<String, Object>();
        Iterator iter = xmppMessage.getPropertyNames();
        while (iter.hasNext()) {
            String name = (String)iter.next();
            answer.put(name, xmppMessage.getProperty(name));
        }
        return answer;
    }
    @Override
    public XmppMessage newInstance() {
        return new XmppMessage();
    }
    @Override
    protected Object createBody() {
        if (xmppMessage != null) {
            return getExchange().getBinding().extractBodyFromXmpp(getExchange(), xmppMessage);
        }
        return null;
    }
}
"
org.apache.camel.component.quartz.QuartzConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision$
 */
public class QuartzConsumer extends DefaultConsumer<QuartzExchange> {
    public QuartzConsumer(QuartzEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
    }
    @Override
    public QuartzEndpoint getEndpoint() {
        return (QuartzEndpoint) super.getEndpoint();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getEndpoint().consumerStarted(this);
    }
    @Override
    protected void doStop() throws Exception {
        getEndpoint().consumerStopped(this);
        super.doStop();
    }
}
"
org.apache.camel.component.ibatis.IBatisProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.util.Iterator;
import org.apache.camel.Exchange;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultProducer;
/**
 * @version $Revision$
 */
public class IBatisProducer extends DefaultProducer {
    private final IBatisEndpoint endpoint;
    public IBatisProducer(IBatisEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    @Override
    public IBatisEndpoint getEndpoint() {
        return (IBatisEndpoint) super.getEndpoint();
    }
    public void process(Exchange exchange) throws Exception {
        Object body = exchange.getIn().getBody();
        if (body == null) {
            // must be a poll so lets do a query
            endpoint.query(exchange.getOut(true));
        } else {
            String operation = getOperationName(exchange);
            // lets handle arrays or collections of objects
            Iterator iter = ObjectConverter.iterator(body);
            while (iter.hasNext()) {
                endpoint.getSqlClient().insert(operation, iter.next());
            }
        }
    }
    /**
     * Returns the iBatis insert operation name
     */
    protected String getOperationName(Exchange exchange) {
        return endpoint.getEntityName();
    }
}
"
org.apache.camel.component.http.HttpConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.BufferedReader;
import java.io.IOException;
import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import org.apache.camel.Converter;
/**
 * Some converter methods making it easy to convert the body of a message to servlet types or to switch between
 * the underlying {@link ServletInputStream} or {@link BufferedReader} payloads etc.
 *
 * @version $Revision$
 */
@Converter
public class HttpConverter {
    @Converter
    public HttpServletRequest toServletRequest(HttpMessage message) {
        if (message == null) {
            return null;
        }
        return message.getRequest();
    }
    @Converter
    public ServletInputStream toServletInputStream(HttpMessage message) throws IOException {
        HttpServletRequest request = toServletRequest(message);
        if (request != null) {
            return request.getInputStream();
        }
        return null;
    }
    @Converter
    public BufferedReader toReader(HttpMessage message) throws IOException {
        HttpServletRequest request = toServletRequest(message);
        if (request != null) {
            return request.getReader();
        }
        return null;
    }
}
"
org.apache.camel.component.event.EventComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ConfigurableApplicationContext;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Component</a>
 * for working with Spring ApplicationEvents
 * 
 * @version $Revision$
 */
public class EventComponent extends DefaultComponent<Exchange> implements ApplicationContextAware {
    private ApplicationContext applicationContext;
    public EventComponent() {
    }
    public EventComponent(ApplicationContext applicationContext) {
        setApplicationContext(applicationContext);
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public ConfigurableApplicationContext getConfigurableApplicationContext() {
        ApplicationContext applicationContext = getApplicationContext();
        if (applicationContext instanceof ConfigurableApplicationContext) {
            return (ConfigurableApplicationContext)applicationContext;
        } else {
            throw new IllegalArgumentException(""Not created with a ConfigurableApplicationContext! Was: "" + applicationContext);
        }
    }
    protected EventEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        EventEndpoint answer = new EventEndpoint(uri, this);
        // getConfigurableApplicationContext().addApplicationListener(answer);
        return answer;
    }
}
"
org.apache.camel.component.jpa.QueryFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
import javax.persistence.Query;
/**
 * A Strategy to create a query to search for objects in a database
 *
 * @version $Revision$
 */
public interface QueryFactory {
    /**
     * Creates a new query to find objects to be processed
     *
     * @param entityManager
     * @return the query configured with any parameters etc
     */
    Query createQuery(EntityManager entityManager);
}
"
org.apache.camel.osgi.CamelContextFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.osgi;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.spring.SpringCamelContext;
import org.osgi.framework.BundleContext;
import org.springframework.osgi.context.BundleContextAware;
@XmlRootElement(name = ""camelContext"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelContextFactoryBean extends org.apache.camel.spring.CamelContextFactoryBean implements BundleContextAware {
    @XmlTransient
    private BundleContext bundleContext;
    public BundleContext getBundleContext() {
        return bundleContext;
    }
    public void setBundleContext(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }
    protected SpringCamelContext createContext() {
        SpringCamelContext context = super.createContext();
        context.setComponentResolver(new OsgiComponentResolver(bundleContext));
        return context;
    }
}
"
org.apache.camel.component.stream.StreamConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.stream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultMessage;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Consumer that can read from streams
 */
public class StreamConsumer extends DefaultConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(StreamConsumer.class);
    private static final String TYPES = ""in,file,url"";
    private static final String INVALID_URI = ""Invalid uri, valid form: 'stream:{"" + TYPES + ""}'"";
    private static final List<String> TYPES_LIST = Arrays.asList(TYPES.split("",""));
    private InputStream inputStream = System.in;
    private StreamEndpoint endpoint;
    private String uri;
    public StreamConsumer(StreamEndpoint endpoint, Processor processor, String uri) throws Exception {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.uri = uri;
        validateUri(uri);
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (""in"".equals(uri)) {
            inputStream = System.in;
        } else if (""file"".equals(uri)) {
            inputStream = resolveStreamFromFile();
        } else if (""url"".equals(uri)) {
            inputStream = resolveStreamFromUrl();
        }
        readFromStream();
    }
    @Override
    public void doStop() throws Exception {
        // important: do not close the stream as it will close the standard system.in etc.
        super.doStop();
    }
    private void readFromStream() throws Exception {
        Charset charset = endpoint.getCharset();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, charset));
        String line;
        while ((line = br.readLine()) != null) {
            consumeLine(line);
        }
        // important: do not close the reader as it will close the standard system.in etc.
    }
    private void consumeLine(Object line) throws Exception {
        Exchange exchange = endpoint.createExchange();
        Message msg = new DefaultMessage();
        msg.setBody(line);
        exchange.setIn(msg);
        getProcessor().process(exchange);
    }
    private InputStream resolveStreamFromUrl() throws IOException {
        String u = endpoint.getUrl();
        URL url = new URL(u);
        URLConnection c = url.openConnection();
        return c.getInputStream();
    }
    private InputStream resolveStreamFromFile() throws IOException {
        String fileName = endpoint.getFile() != null ? endpoint.getFile().trim() : ""_file"";
        File f = new File(fileName);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""About to read from file: "" + f);
        }
        f.createNewFile();
        return new FileInputStream(f);
    }
    private void validateUri(String uri) throws IllegalArgumentException {
        String[] s = uri.split("":"");
        if (s.length < 2) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        String[] t = s[1].split(""\\?"");
        if (t.length < 1) {
            throw new IllegalArgumentException(INVALID_URI);
        }
        this.uri = t[0].trim();
        if (!TYPES_LIST.contains(this.uri)) {
            throw new IllegalArgumentException(INVALID_URI);
        }
    }
}
"
org.apache.camel.spring.CamelContextFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultLifecycleStrategy;
import org.apache.camel.management.DefaultInstrumentationAgent;
import org.apache.camel.management.InstrumentationLifecycleStrategy;
import org.apache.camel.model.IdentifiedType;
import org.apache.camel.model.RouteBuilderRef;
import org.apache.camel.model.RouteContainer;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.processor.interceptor.Debugger;
import org.apache.camel.processor.interceptor.Tracer;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.Registry;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
/**
 * A Spring {@link FactoryBean} to create and initialize a
 * {@link SpringCamelContext} and install routes either explicitly configured in
 * Spring XML or found by searching the classpath for Java classes which extend
 * {@link RouteBuilder} using the nested {@link #setPackages(String[])}.
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""camelContext"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelContextFactoryBean extends IdentifiedType implements RouteContainer, FactoryBean, InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener {
    private static final Log LOG = LogFactory.getLog(CamelContextFactoryBean.class);
    @XmlAttribute(required = false)
    private Boolean useJmx = Boolean.TRUE;
    @XmlAttribute(required = false)
    private Boolean autowireRouteBuilders = Boolean.TRUE;
    @XmlAttribute(required = false)
    private Boolean trace;
    @XmlAttribute(required = false)
    private String errorHandlerRef;
    @XmlElement(name = ""package"", required = false)
    private String[] packages = {};
    @XmlElement(name = ""jmxAgent"", type = CamelJMXAgentType.class, required = false)
    private CamelJMXAgentType camelJMXAgent;
    @XmlElements({
        @XmlElement(name = ""beanPostProcessor"", type = CamelBeanPostProcessor.class, required = false),
        @XmlElement(name = ""template"", type = CamelTemplateFactoryBean.class, required = false),
        @XmlElement(name = ""proxy"", type = CamelProxyFactoryType.class, required = false),
        @XmlElement(name = ""export"", type = CamelServiceExporterType.class, required = false)})
    private List beans;
    @XmlElement(name = ""routeBuilderRef"", required = false)
    private List<RouteBuilderRef> builderRefs = new ArrayList<RouteBuilderRef>();
    @XmlElement(name = ""endpoint"", required = false)
    private List<EndpointFactoryBean> endpoints;
    @XmlElementRef
    private List<DataFormatType> dataFormats;
    @XmlElement(name = ""route"", required = false)
    private List<RouteType> routes = new ArrayList<RouteType>();
    @XmlTransient
    private SpringCamelContext context;
    @XmlTransient
    private RouteBuilder routeBuilder;
    @XmlTransient
    private List<RouteBuilder> additionalBuilders = new ArrayList<RouteBuilder>();
    @XmlTransient
    private ApplicationContext applicationContext;
    @XmlTransient
    private ClassLoader contextClassLoaderOnStart;
    @XmlTransient
    private BeanPostProcessor beanPostProcessor;
    public CamelContextFactoryBean() {
        // Lets keep track of the class loader for when we actually do start things up
        contextClassLoaderOnStart = Thread.currentThread().getContextClassLoader();
    }
    public Object getObject() throws Exception {
        return getContext();
    }
    public Class getObjectType() {
        return SpringCamelContext.class;
    }
    public boolean isSingleton() {
        return true;
    }
    public void afterPropertiesSet() throws Exception {
        // lets see if we can find a debugger to add
        // TODO there should be a neater way to do this!
        Debugger debugger = getBeanForType(Debugger.class);
        if (debugger != null) {
            getContext().addInterceptStrategy(debugger);
        }
        Tracer tracer = getBeanForType(Tracer.class);
        if (tracer != null) {
            getContext().addInterceptStrategy(tracer);
        }
        // set the lifecycle strategy if defined
        LifecycleStrategy lifecycleStrategy = getBeanForType(LifecycleStrategy.class);
        if (lifecycleStrategy != null) {
            getContext().setLifecycleStrategy(lifecycleStrategy);
        }
        // set the strategy if defined
        Registry registry = getBeanForType(Registry.class);
        if (registry != null) {
            getContext().setRegistry(registry);
        }
        // Set the application context and camelContext for the beanPostProcessor
        if (beanPostProcessor != null) {
            if (beanPostProcessor instanceof ApplicationContextAware) {
                ((ApplicationContextAware)beanPostProcessor).setApplicationContext(applicationContext);
            }
            if (beanPostProcessor instanceof CamelBeanPostProcessor) {
                ((CamelBeanPostProcessor)beanPostProcessor).setCamelContext(getContext());
            }
        }
        // lets force any lazy creation
        getContext().addRouteDefinitions(routes);
        if (!isJmxEnabled()
                || (camelJMXAgent != null && camelJMXAgent.isDisabled() != null && camelJMXAgent.isDisabled())) {
            LOG.debug(""JMXAgent disabled"");
            getContext().setLifecycleStrategy(new DefaultLifecycleStrategy());
        } else if (camelJMXAgent != null) {
            LOG.debug(""JMXAgent enabled"");
            if (lifecycleStrategy != null) {
                LOG.warn(""lifecycleStrategy will be overriden by InstrumentationLifecycleStrategy"");
            }
            DefaultInstrumentationAgent agent = new DefaultInstrumentationAgent();
            agent.setConnectorPort(camelJMXAgent.getConnectorPort());
            agent.setCreateConnector(camelJMXAgent.isCreateConnector());
            agent.setMBeanObjectDomainName(camelJMXAgent.getMbeanObjectDomainName());
            agent.setMBeanServerDefaultDomain(camelJMXAgent.getMbeanServerDefaultDomain());
            agent.setRegistryPort(camelJMXAgent.getRegistryPort());
            agent.setServiceUrlPath(camelJMXAgent.getServiceUrlPath());
            agent.setUsePlatformMBeanServer(camelJMXAgent.isUsePlatformMBeanServer());
            getContext().setLifecycleStrategy(new InstrumentationLifecycleStrategy(agent));
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found JAXB created routes: "" + getRoutes());
        }
        findRouteBuiders();
        installRoutes();
    }
    private <T> T getBeanForType(Class<T> clazz) {
        T bean = null;
        String[] names = getApplicationContext().getBeanNamesForType(clazz, true, true);
        if (names.length == 1) {
            bean = (T) getApplicationContext().getBean(names[0], clazz);
        }
        if (bean == null) {
            ApplicationContext parentContext = getApplicationContext().getParent();
            if (parentContext != null) {
                names = parentContext.getBeanNamesForType(clazz, true, true);
                if (names.length == 1) {
                    bean = (T) parentContext.getBean(names[0], clazz);
                }
            }
        }
        return bean;
    }
    public void destroy() throws Exception {
        getContext().stop();
    }
    public void onApplicationEvent(ApplicationEvent event) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Publishing event: "" + event);
        }
        if (event instanceof ContextRefreshedEvent) {
            // now lets start the CamelContext so that all its possible
            // dependencies are initailized
            try {
                LOG.debug(""Starting the context now!"");
                getContext().start();
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
        }
        /*
         * if (context != null) { context.onApplicationEvent(event); }
         */
    }
    // Properties
    // -------------------------------------------------------------------------
    public SpringCamelContext getContext() throws Exception {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(SpringCamelContext context) {
        this.context = context;
    }
    public List<RouteType> getRoutes() {
        return routes;
    }
    public void setRoutes(List<RouteType> routes) {
        this.routes = routes;
    }
    public RouteBuilder getRouteBuilder() {
        return routeBuilder;
    }
    /**
     * Set a single {@link RouteBuilder} to be used to create the default routes
     * on startup
     */
    public void setRouteBuilder(RouteBuilder routeBuilder) {
        this.routeBuilder = routeBuilder;
    }
    /**
     * Set a collection of {@link RouteBuilder} instances to be used to create
     * the default routes on startup
     */
    public void setRouteBuilders(RouteBuilder[] builders) {
        for (RouteBuilder builder : builders) {
            additionalBuilders.add(builder);
        }
    }
    public ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            throw new IllegalArgumentException(""No applicationContext has been injected!"");
        }
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String[] getPackages() {
        return packages;
    }
    /**
     * Sets the package names to be recursively searched for Java classes which
     * extend {@link RouteBuilder} to be auto-wired up to the
     * {@link SpringCamelContext} as a route. Note that classes are excluded if
     * they are specifically configured in the spring.xml
     *
     * @param packages the package names which are recursively searched
     */
    public void setPackages(String[] packages) {
        this.packages = packages;
    }
    public void setBeanPostProcessor(BeanPostProcessor postProcessor) {
        this.beanPostProcessor = postProcessor;
    }
    public BeanPostProcessor getBeanPostProcessor() {
        return beanPostProcessor;
    }
    /**
     * This method merely retrieves the value of the ""useJmx"" attribute and does
     * not consider the ""disabled"" flag in jmxAgent element.  The useJmx
     * attribute will be removed in 2.0.  Please the jmxAgent element instead.
     *
     * @deprecated Please the jmxAgent element instead. Will be removed in Camel 2.0.
     */
    public boolean isJmxEnabled() {
        return useJmx.booleanValue();
    }
    public Boolean getUseJmx() {
        return useJmx;
    }
    /**
     * @deprecated Please the jmxAgent element instead. Will be removed in Camel 2.0.
     */
    public void setUseJmx(Boolean useJmx) {
        this.useJmx = useJmx;
    }
    public void setCamelJMXAgent(CamelJMXAgentType agent) {
        camelJMXAgent = agent;
    }
    public Boolean getTrace() {
        return trace;
    }
    public void setTrace(Boolean trace) {
        this.trace = trace;
    }
    public CamelJMXAgentType getCamelJMXAgent() {
        return camelJMXAgent;
    }
    public List<RouteBuilderRef> getBuilderRefs() {
        return builderRefs;
    }
    public void setBuilderRefs(List<RouteBuilderRef> builderRefs) {
        this.builderRefs = builderRefs;
    }
    /**
     * If enabled this will force all {@link RouteBuilder} classes configured in the Spring
     * {@link ApplicationContext} to be registered automatically with this CamelContext.
     */
    public void setAutowireRouteBuilders(Boolean autowireRouteBuilders) {
        this.autowireRouteBuilders = autowireRouteBuilders;
    }
    public String getErrorHandlerRef() {
        return errorHandlerRef;
    }
    /**
     * Sets the name of the error handler object used to default the error handling strategy
     *
     * @param errorHandlerRef the Spring bean ref of the error handler
     */
    public void setErrorHandlerRef(String errorHandlerRef) {
        this.errorHandlerRef = errorHandlerRef;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Create the context
     */
    protected SpringCamelContext createContext() {
        SpringCamelContext ctx = new SpringCamelContext(getApplicationContext());
        ctx.setName(getId());
        if (trace != null) {
            ctx.setTrace(trace);
        }
        if (errorHandlerRef != null) {
            ErrorHandlerBuilder errorHandlerBuilder = (ErrorHandlerBuilder) getApplicationContext().getBean(errorHandlerRef, ErrorHandlerBuilder.class);
            if (errorHandlerBuilder == null) {
                throw new IllegalArgumentException(""Could not find bean: "" + errorHandlerRef);
            }
            ctx.setErrorHandlerBuilder(errorHandlerBuilder);
        }
        return ctx;
    }
    /**
     * Strategy to install all available routes into the context
     */
    protected void installRoutes() throws Exception {
        if (autowireRouteBuilders != null && autowireRouteBuilders.booleanValue()) {
            Map builders = getApplicationContext().getBeansOfType(RouteBuilder.class, true, true);
            if (builders != null) {
                for (Object builder : builders.values()) {
                    getContext().addRoutes((RouteBuilder) builder);
                }
            }
        }
        for (RouteBuilder routeBuilder : additionalBuilders) {
            getContext().addRoutes(routeBuilder);
        }
        if (routeBuilder != null) {
            getContext().addRoutes(routeBuilder);
        }
        // lets add route builders added from references
        if (builderRefs != null) {
            for (RouteBuilderRef builderRef : builderRefs) {
                RouteBuilder builder = builderRef.createRouteBuilder(getContext());
                getContext().addRoutes(builder);
            }
        }
    }
    /**
     * Strategy method to try find {@link RouteBuilder} instances on the
     * classpath
     */
    protected void findRouteBuiders() throws Exception, InstantiationException {
        if (packages != null && packages.length > 0) {
            RouteBuilderFinder finder = new RouteBuilderFinder(getContext(), packages, contextClassLoaderOnStart, getBeanPostProcessor());
            finder.appendBuilders(additionalBuilders);
        }
    }
}
"
org.apache.camel.bam.processor.JpaBamProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import java.lang.reflect.Method;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A base class for JPA based BAM which can use any entity to store the process
 * instance information which allows derived classes to specialise the process
 * instance entity.
 *
 * @version $Revision$
 */
public class JpaBamProcessorSupport<T> extends BamProcessorSupport<T> {
    private static final transient Log LOG = LogFactory.getLog(JpaBamProcessorSupport.class);
    private static final Lock LOCK = new ReentrantLock(); // lock used for concurrency issues
    private ActivityRules activityRules;
    private JpaTemplate template;
    private String findByKeyQuery;
    private String keyPropertyName = ""correlationKey"";
    private boolean correlationKeyIsPrimary = true;
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template,
                                  Expression<Exchange> correlationKeyExpression, ActivityRules activityRules,
                                  Class<T> entitytype) {
        super(transactionTemplate, correlationKeyExpression, entitytype);
        this.activityRules = activityRules;
        this.template = template;
    }
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template,
                                  Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, correlationKeyExpression);
        this.activityRules = activityRules;
        this.template = template;
    }
    public String getFindByKeyQuery() {
        if (findByKeyQuery == null) {
            findByKeyQuery = createFindByKeyQuery();
        }
        return findByKeyQuery;
    }
    public void setFindByKeyQuery(String findByKeyQuery) {
        this.findByKeyQuery = findByKeyQuery;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public void setActivityRules(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public String getKeyPropertyName() {
        return keyPropertyName;
    }
    public void setKeyPropertyName(String keyPropertyName) {
        this.keyPropertyName = keyPropertyName;
    }
    public JpaTemplate getTemplate() {
        return template;
    }
    public void setTemplate(JpaTemplate template) {
        this.template = template;
    }
    public boolean isCorrelationKeyIsPrimary() {
        return correlationKeyIsPrimary;
    }
    public void setCorrelationKeyIsPrimary(boolean correlationKeyIsPrimary) {
        this.correlationKeyIsPrimary = correlationKeyIsPrimary;
    }
    // Implementatiom methods
    // -----------------------------------------------------------------------
    protected T loadEntity(Exchange exchange, Object key) throws Exception {
        LOCK.lock();
        try {
            T entity = findEntityByCorrelationKey(key);
            if (entity == null) {
                entity = createEntity(exchange, key);
                setKeyProperty(entity, key);
                ProcessDefinition definition = ProcessDefinition
                    .getRefreshedProcessDefinition(template, getActivityRules().getProcessRules()
                        .getProcessDefinition());
                setProcessDefinitionProperty(entity, definition);
                template.persist(entity);
                // Now we must flush to avoid concurrent updates clashing trying to
                // insert the same row
                LOG.debug(""About to flush on entity: "" + entity + "" with key: "" + key);
                template.flush();
            }
            return entity;
        } finally {
            LOCK.unlock();
        }
    }
    protected T findEntityByCorrelationKey(Object key) {
        if (isCorrelationKeyIsPrimary()) {
            return template.find(getEntityType(), key);
        } else {
            List<T> list = template.find(getFindByKeyQuery(), key);
            if (list.isEmpty()) {
                return null;
            } else {
                return list.get(0);
            }
        }
    }
    protected Class getKeyType() {
        try {
            Method getter = IntrospectionSupport.getPropertyGetter(getEntityType(), getKeyPropertyName());
            return getter.getReturnType();
        } catch (NoSuchMethodException e) {
            LOG.warn(""no such getter for: "" + getKeyPropertyName() + "" on "" + getEntityType() + "". Reason: ""
                     + e, e);
            return null;
        }
    }
    /**
     * Sets the key property on the new entity
     */
    protected void setKeyProperty(T entity, Object key) throws Exception {
        IntrospectionSupport.setProperty(entity, getKeyPropertyName(), key);
    }
    protected void setProcessDefinitionProperty(T entity, ProcessDefinition processDefinition)
        throws Exception {
        IntrospectionSupport.setProperty(entity, ""processDefinition"", processDefinition);
    }
    /**
     * Create a new instance of the entity for the given key
     */
    protected T createEntity(Exchange exchange, Object key) {
        return (T)exchange.getContext().getInjector().newInstance(getEntityType());
    }
    protected void processEntity(Exchange exchange, T entity) throws Exception {
        if (entity instanceof Processor) {
            Processor processor = (Processor)entity;
            processor.process(exchange);
        } else {
            // TODO add other extension points - eg. passing in Activity
            throw new IllegalArgumentException(""No processor defined for this route"");
        }
    }
    protected String createFindByKeyQuery() {
        return ""select x from "" + getEntityType().getName() + "" x where x."" + getKeyPropertyName() + "" = ?1"";
    }
}
"
org.apache.camel.component.jpa.DefaultTransactionStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import org.apache.camel.impl.ServiceSupport;
import org.springframework.orm.jpa.JpaCallback;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * @version $Revision$
 */
public class DefaultTransactionStrategy extends ServiceSupport implements TransactionStrategy {
    private EntityManagerFactory entityManagerFactory;
    private EntityManager entityManager;
    public DefaultTransactionStrategy(EntityManagerFactory entityManagerFactory) {
        notNull(entityManagerFactory, ""entityManagerFactory"");
        this.entityManagerFactory = entityManagerFactory;
    }
    public DefaultTransactionStrategy(EntityManager entityManager) {
        notNull(entityManager, ""entityManager"");
        this.entityManager = entityManager;
    }
    public Object execute(JpaCallback callback) {
        EntityManager em = getEntityManager();
        EntityTransaction transaction = em.getTransaction();
        transaction.begin();
        try {
            Object answer = callback.doInJpa(em);
            transaction.commit();
            return answer;
        } catch (RuntimeException e) {
            if (transaction != null) {
                transaction.rollback();
            }
            throw e;
        }
    }
    public EntityManager getEntityManager() {
        if (entityManager == null) {
            entityManager = entityManagerFactory.createEntityManager();
        }
        return entityManager;
    }
    protected void doStart() throws Exception {
        // force lazy construction
        getEntityManager();
    }
    protected void doStop() throws Exception {
        if (entityManager != null) {
            entityManager.close();
        }
    }
}
"
org.apache.camel.component.xmpp.XmppPrivateChatProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.Chat;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
/**
 * @version $Revision$
 */
public class XmppPrivateChatProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(XmppPrivateChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String participant;
    private Chat chat;
    public XmppPrivateChatProducer(XmppEndpoint endpoint, String participant) {
        super(endpoint);
        this.endpoint = endpoint;
        this.participant = participant;
        if (participant == null) {
            throw new IllegalArgumentException(""No participant property specified"");
        }
    }
    public void process(Exchange exchange) {
        // TODO it would be nice if we could reuse the message from the exchange
        Message message = chat.createMessage();
        message.setTo(participant);
        message.setThread(exchange.getExchangeId());
        endpoint.getBinding().populateXmppMessage(message, exchange);
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> message: "" + message.getBody());
        }
        try {
            chat.sendMessage(message);
        } catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (chat == null) {
            chat = endpoint.getConnection().createChat(getParticipant());
        }
    }
    @Override
    protected void doStop() throws Exception {
        chat = null;
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public Chat getChat() {
        return chat;
    }
    public void setChat(Chat chat) {
        this.chat = chat;
    }
    public String getParticipant() {
        return participant;
    }
}
"
org.apache.camel.spring.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The classes for working with Camel and Spring along with the primary factory beans.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.spring;
"
org.apache.camel.component.jcr.JcrProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jcr;
import javax.jcr.LoginException;
import javax.jcr.Node;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Value;
import org.apache.camel.Exchange;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
public class JcrProducer extends DefaultProducer<DefaultExchange> {
    public JcrProducer(JcrEndpoint jcrEndpoint) throws LoginException,
            RepositoryException {
        super(jcrEndpoint);
    }
    public void process(Exchange exchange) throws Exception {
        Session session = openSession();
        try {
            Node base = getBaseNode(session);
            Node node = base.addNode(getNodeName(exchange));
            TypeConverter converter = exchange.getContext().getTypeConverter();
            for (String key : exchange.getProperties().keySet()) {
                Value value = converter.convertTo(Value.class, exchange
                        .getProperty(key));
                node.setProperty(key, value);
            }
            node.addMixin(""mix:referenceable"");
            session.save();
            exchange.getOut().setBody(node.getUUID());
        } finally {
            if (session != null && session.isLive()) {
                session.logout();
            }
        }
    }
    private String getNodeName(Exchange exchange) {
        if (exchange.getProperty(JcrComponent.NODE_NAME) != null) {
            return exchange.getProperty(JcrComponent.NODE_NAME).toString();
        }
        return exchange.getExchangeId();
    }
    private Node getBaseNode(Session session) throws Exception {
        Node baseNode = session.getRootNode();
        for (String node : getJcrEndpoint().getBase().split(""/"")) {
            baseNode = baseNode.addNode(node);
        }
        return baseNode;
    }
    protected Session openSession() throws LoginException, RepositoryException {
        return getJcrEndpoint().getRepository().login(getJcrEndpoint().getCredentials());
    }
    private JcrEndpoint getJcrEndpoint() {
        JcrEndpoint endpoint = (JcrEndpoint) getEndpoint();
        return endpoint;
    }
}
"
org.apache.camel.component.cxf.interceptors.SoapMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.wsdl.Definition;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.SoapVersion;
import org.apache.cxf.binding.soap.model.SoapBindingInfo;
import org.apache.cxf.binding.soap.model.SoapHeaderInfo;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.MessagePartInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.wsdl11.WSDLServiceBuilder;
public class SoapMessageOutInterceptor extends AbstractMessageOutInterceptor<SoapMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(SoapMessageInInterceptor.class);
    public SoapMessageOutInterceptor() {
        super(Phase.PREPARE_SEND);
        addAfter(DOMOutInterceptor.class.getName());
    }
    protected Logger getLogger() {
        return LOG;
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(SoapMessage message) throws Fault {
        // header is not store as the element
        Element header = message.get(Element.class);
        List<Element> payload = message.get(List.class);
        Exchange exchange = message.getExchange();
        BindingMessageInfo bmi = exchange.get(BindingMessageInfo.class);
        //Headers -represent as -Element,Body -represent as StaxStream.
        //Check if BindingOperationInfo contains header
        List<SoapHeaderInfo> bindingHdr = bmi.getExtensors(SoapHeaderInfo.class);
        if (bindingHdr != null && !bindingHdr.isEmpty()) {
            if (LOG.isLoggable(Level.INFO)) {
                LOG.info(""SoapMessageOutInterceptor BindingOperation header processing."");
            }
            List<Element> headerList = new ArrayList<Element>();
            List<Element> newPayload = new ArrayList<Element>(payload);
            //Look for headers in Payload.
            for (SoapHeaderInfo shi : bindingHdr) {
                List<Element> tmpList = new ArrayList<Element>();
                MessagePartInfo mpi = shi.getPart();
                QName hdrName = mpi.getConcreteName();
                for (Element el : payload) {
                    QName elName = new QName(el.getNamespaceURI(), el.getLocalName());
                    if (elName.equals(hdrName)) {
                        newPayload.remove(el);
                        tmpList.add(el);
                    }
                }
                if (tmpList.size() > 1) {
                    throw new Fault(new org.apache.cxf.common.i18n.Message(
                                    ""MULTIPLE_HDR_PARTS"", LOG, hdrName));
                }
                headerList.addAll(tmpList);
            }
            if (LOG.isLoggable(Level.INFO)) {
                LOG.info(""DOMOutInterceptor Copy Payload parts to SOAPHeaders"");
            }
            if (headerList.size() != 0) {
                SoapVersion version = ((SoapMessage)message).getVersion();
                header = createElement(version.getHeader(), headerList);
            }
            payload = newPayload;
        }
        //Set SOAP Header Element.
        //Child Elements Could be binding specified parts or user specified headers.
        //REVISTED the soap headers
        //message.setHeaders(Element.class, header);
        //TODO Moving Parts from Header to Payload.
        //For e.g Payload ROuting from SOAP11 <-> SOAP12
        //So write payload and header to outbound message
        if (LOG.isLoggable(Level.INFO)) {
            LOG.info(""SoapMessageOutInterceptor binding operation style processing."");
        }
        SoapBindingInfo soapBinding = (SoapBindingInfo)exchange.get(BindingInfo.class);
        String style = soapBinding.getStyle(bmi.getBindingOperation().getOperationInfo());
        if (""rpc"".equals(style)) {
            //Add the Operation Node or Operation+""Response"" node
            //Remove the operation element.
            OperationInfo oi = bmi.getBindingOperation().getOperationInfo();
            Endpoint ep = exchange.get(Endpoint.class);
            Definition def =
                ep.getService().getServiceInfos().get(0).getProperty(WSDLServiceBuilder.WSDL_DEFINITION,
                                                             Definition.class);
            String prefix = def.getPrefix(oi.getName().getNamespaceURI());
            if ("""".equals(prefix)) {
                prefix = ""tns"";
            }
            QName opName = null;
            boolean isClient = isRequestor(message);
            if (isClient) {
                opName = new QName(oi.getName().getNamespaceURI(),
                                   oi.getName().getLocalPart(),
                                   prefix);
            } else {
                opName = new QName(oi.getName().getNamespaceURI(),
                                   oi.getName().getLocalPart() + ""Response"",
                                   prefix);
            }
            Element opEl = createElement(opName, payload);
            payload = new ArrayList<Element>();
            payload.add(opEl);
        }
        message.put(List.class, payload);
    }
}
"
org.apache.camel.language.juel.EL,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.apache.camel.language.LanguageAnnotation;
/**
 * An annotation for injection of EL (JSP & JSF) expressions into method parameters, fields or properties
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""el"")
public @interface EL {
    String value();
}"
org.apache.camel.component.jetty.JettyHttpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jetty;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.concurrent.CountDownLatch;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Producer;
import org.apache.camel.component.http.HttpBinding;
import org.apache.camel.component.http.HttpEndpoint;
import org.apache.camel.component.http.HttpExchange;
import org.apache.camel.impl.DefaultProducer;
import org.mortbay.io.Buffer;
import org.mortbay.jetty.HttpFields;
import org.mortbay.jetty.HttpFields.Field;
import org.mortbay.jetty.HttpMethods;
import org.mortbay.jetty.HttpURI;
import org.mortbay.jetty.client.HttpClient;
import org.mortbay.jetty.client.HttpExchange.ContentExchange;
public class JettyHttpProducer extends DefaultProducer<HttpExchange> implements Producer<HttpExchange>, AsyncProcessor {
    private final class CamelContentExchange extends ContentExchange {
        private final AsyncCallback callback;
        private final Exchange exchange;
        private HttpFields responseFields;
        private CamelContentExchange(Exchange exchange, AsyncCallback callback) {
            this.exchange = exchange;
            this.callback = callback;
            responseFields = new HttpFields();
        }
        protected void onResponseComplete() throws IOException {
            super.onRequestComplete();
            try {
                Message out = exchange.getOut(true);
                out.setBody(getResponseContent());
                for (Iterator i = responseFields.getFields(); i.hasNext();) {
                    Field field = (Field)i.next();
                    out.setHeader(field.getName(), field.getValue());
                }
            } catch (Throwable e) {
                exchange.setException(e);
            }
            callback.done(false);
        }
        public HttpFields getResponseFields() {
            return responseFields;
        }
        protected void onResponsetHeader(Buffer name, Buffer value) throws IOException {
            responseFields.add(name, value);
        }
    }
    private HttpClient httpClient;
    private String address;
    public JettyHttpProducer(HttpEndpoint endpoint) {
        super(endpoint);
        httpClient = ((JettyHttpComponent)endpoint.getComponent()).getHttpClient();
        address = endpoint.getHttpUri().toString();
        // A workaround where the Jetty client does not like to see
        // urls like http://google.com but does like http://google.com/
        HttpURI uri = new HttpURI(address);
        if (uri.getCompletePath() == null) {
            address += ""/"";
        }
    }
    public void process(Exchange exchange) throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                latch.countDown();
            }
        });
        latch.await();
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        ContentExchange jettyExchange = new CamelContentExchange(exchange, callback);
        jettyExchange.setURL(address);
        // If a in body can be converted to an InputStream or a Buffer
        // then do a POST otherwise, do a GET
        Message in = exchange.getIn();
        InputStream is = in.getBody(InputStream.class);
        if (is != null) {
            jettyExchange.setMethod(HttpMethods.POST);
            jettyExchange.setRequestContentSource(is);
        } else {
            Buffer buffer = in.getBody(Buffer.class);
            if (buffer != null) {
                jettyExchange.setMethod(HttpMethods.POST);
                jettyExchange.setRequestContent(buffer);
            } else {
                jettyExchange.setMethod(HttpMethods.GET);
            }
        }
        HttpBinding binding = ((HttpEndpoint)getEndpoint()).getBinding();
        for (String name : in.getHeaders().keySet()) {
            String value = in.getHeader(name, String.class);
            if (""Content-Type"".equals(name)) {
                jettyExchange.setRequestContentType(value);
            } else if (binding.shouldHeaderBePropagated(name, value)) {
                jettyExchange.addRequestHeader(name, value);
            }
        }
        try {
            httpClient.send(jettyExchange);
        } catch (IOException e) {
            exchange.setException(e);
            return true;
        }
        return false;
    }
}
"
org.apache.camel.language.groovy.GroovyLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.groovy;
import groovy.lang.GroovyClassLoader;
import groovy.lang.Script;
import org.apache.camel.spi.Language;
/**
 * @version $Revision$
 */
public class GroovyLanguage implements Language  {
    public static GroovyExpression groovy(String expression) {
        return new GroovyLanguage().createExpression(expression);
    }
    public GroovyExpression createPredicate(String expression) {
        return createExpression(expression);
    }
    public GroovyExpression createExpression(String expression) {
        Class<Script> scriptType = parseExpression(expression);
        return new GroovyExpression(scriptType, expression);
    }
    protected Class<Script> parseExpression(String expression) {
        return new GroovyClassLoader().parseClass(expression);
    }
}
"
org.apache.camel.component.jpa.JpaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Map;
import javax.persistence.EntityManagerFactory;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.ObjectHelper;
/**
 * A JPA Component
 *
 * @version $Revision$
 */
public class JpaComponent extends DefaultComponent<Exchange> {
    private EntityManagerFactory entityManagerFactory;
    public Component resolveComponent(CamelContext container, String uri) throws Exception {
        return null;
    }
    // Properties
    //-------------------------------------------------------------------------
    public EntityManagerFactory getEntityManagerFactory() {
        return entityManagerFactory;
    }
    public void setEntityManagerFactory(EntityManagerFactory entityManagerFactory) {
        this.entityManagerFactory = entityManagerFactory;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String path, Map options) throws Exception {
        JpaEndpoint endpoint = new JpaEndpoint(uri, this);
        // lets interpret the next string as a class
        if (path != null) {
            Class<?> type = ObjectHelper.loadClass(path);
            if (type != null) {
                endpoint.setEntityType(type);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.component.cxf.CxfSoapEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import javax.wsdl.Definition;
import javax.wsdl.factory.WSDLFactory;
import javax.wsdl.xml.WSDLReader;
import javax.xml.namespace.QName;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.helpers.DOMUtils;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;
/**
 * A CXF based SOAP endpoint which wraps an existing
 * endpoint with SOAP processing.
 */
public class CxfSoapEndpoint implements Endpoint {
    private final Endpoint endpoint;
    private Resource wsdl;
    private String serviceClass;
    private org.w3c.dom.Document description;
    private Definition definition;
    private QName serviceName;
    private QName endpointName;
    private Bus bus;
    public CxfSoapEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    protected Endpoint getInnerEndpoint() {
        return endpoint;
    }
    public boolean isSingleton() {
        return endpoint.isSingleton();
    }
    public String getEndpointUri() {
        return endpoint.getEndpointUri();
    }
    public Exchange createExchange() {
        return endpoint.createExchange();
    }
    public Exchange createExchange(ExchangePattern pattern) {
        return endpoint.createExchange(pattern);
    }
    public Exchange createExchange(Exchange exchange) {
        return endpoint.createExchange(exchange);
    }
    public CamelContext getCamelContext() {
        return endpoint.getCamelContext();
    }
    public Producer createProducer() throws Exception {
        return new CxfSoapProducer(this);
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        return new CxfSoapConsumer(this, processor);
    }
    public PollingConsumer createPollingConsumer() throws Exception {
        throw new UnsupportedOperationException();
    }
    public void configureProperties(Map options) {
    }
    public Resource getWsdl() {
        return wsdl;
    }
    public void setWsdl(Resource wsdl) {
        this.wsdl = wsdl;
    }
    public void setServiceClass(String serviceClass) {
        this.serviceClass = serviceClass;
    }
    public String getServiceClass() {
        return serviceClass;
    }
    public void setServiceName(String serviceName) {
        this.serviceName = QName.valueOf(serviceName);
    }
    public void setEndpointName(String endpointName) {
        this.endpointName = QName.valueOf(endpointName);
    }
    public QName getEndpointName() {
        return endpointName;
    }
    public void init() throws Exception {
        Assert.notNull(wsdl, ""soap.wsdl parameter must be set on the uri"");
        if (serviceName == null) {
            description = DOMUtils.readXml(wsdl.getInputStream());
            WSDLFactory wsdlFactory = WSDLFactory.newInstance();
            WSDLReader reader = wsdlFactory.newWSDLReader();
            reader.setFeature(""javax.wsdl.verbose"", false);
            definition = reader.readWSDL(wsdl.getURL().toString(), description);
            serviceName = (QName) definition.getServices().keySet().iterator().next();
        }
    }
    protected Bus getBus() {
        if (bus == null) {
            bus = BusFactory.newInstance().createBus();
        }
        return bus;
    }
    public Definition getDefinition() {
        return definition;
    }
    public QName getServiceName() {
        return serviceName;
    }
    public void setCamelContext(CamelContext context) {
        endpoint.setCamelContext(context);
    }
    @Deprecated
    public CamelContext getContext() {
        return getCamelContext();
    }
    @Deprecated
    public void setContext(CamelContext context) {
        setCamelContext(context);
    }
}
"
org.apache.camel.component.jms.requestor.FutureHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms.requestor;
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import javax.jms.JMSException;
import javax.jms.Message;
/**
 * A {@link FutureTask} which implements {@link ReplyHandler}
 * so that it can be used as a handler for a correlation ID
 *
 * @version $Revision$
 */
public class FutureHandler extends FutureTask<Message> implements ReplyHandler {
    private static final Callable<Message> EMPTY_CALLABLE = new Callable<Message>() {
        public Message call() throws Exception {
            return null;
        }
    };
    public FutureHandler() {
        super(EMPTY_CALLABLE);
    }
    public synchronized void set(Message result) {
        super.set(result);
    }
    public boolean handle(Message message) throws JMSException {
        set(message);
        return true;
    }
}
"
org.apache.camel.component.jms.QueueBrowseStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.util.List;
import org.apache.camel.Exchange;
import org.springframework.jms.core.JmsOperations;
/**
 * @version $Revision$
 */
public interface QueueBrowseStrategy {
    List<Exchange> browse(JmsOperations template, String queue, JmsQueueEndpoint endpoint);
}
"
org.apache.camel.component.cxf.invoker.InvokingContextFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import org.apache.camel.component.cxf.DataFormat;
public final class InvokingContextFactory {
    private InvokingContextFactory() {
        // not constructed
    }
    /**
     * Static method that creates a routing context object from a given data format
     * @param dataFormat
     * @return routing context
     */
    public static InvokingContext createContext(DataFormat dataFormat) {
        if (dataFormat == DataFormat.MESSAGE) {
            return new RawMessageInvokingContext();
        }
        if (dataFormat == DataFormat.PAYLOAD) {
            return new PayloadInvokingContext();
        }
        //Default is DataFormat.MESSAGE, we do not set the POJO context
        return new RawMessageInvokingContext();
    }
}
"
org.apache.camel.component.spring.integration.adapter.config.AbstractCamelContextBeanDefinitionParaser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.spring.integration.adapter.config;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.camel.util.ObjectHelper;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.StringUtils;
/**
 * This BeanDefinition paraser help to inject the camel context into the beans
 *
 * @author Willem Jiang
 *
 * @version $Revision$
 */
public class AbstractCamelContextBeanDefinitionParaser extends AbstractSingleBeanDefinitionParser {
    private static final String DEFAULT_CAMEL_CONTEXT_NAME = ""camelContext"";
    private String getContextId(String contextId) {
        if (ObjectHelper.isNullOrBlank(contextId)) {
            //Set the contextId default value here
            return DEFAULT_CAMEL_CONTEXT_NAME;
        } else {
            return contextId;
        }
    }
    protected void mapToProperty(BeanDefinitionBuilder bean, String propertyName, String val) {
        if (ID_ATTRIBUTE.equals(propertyName)) {
            return;
        }
        if (StringUtils.hasText(val)) {
            if (val.startsWith(""#"")) {
                bean.addPropertyReference(propertyName, val.substring(1));
            } else {
                bean.addPropertyValue(propertyName, val);
            }
        }
    }
    protected void wireCamelContext(BeanDefinitionBuilder bean, String camelContextId) {
        bean.addPropertyReference(""camelContext"", camelContextId);
    }
    protected void parseAttributes(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        NamedNodeMap atts = element.getAttributes();
        for (int i = 0; i < atts.getLength(); i++) {
            Attr node = (Attr) atts.item(i);
            String val = node.getValue();
            String name = node.getLocalName();
            if (name.equals(""requestChannel"") || name.equals(""replyChannel"")) {
                bean.addPropertyReference(name, val);
            } else {
                mapToProperty(bean, name, val);
            }
        }
    }
    protected void parseCamelContext(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        NodeList children = element.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType() == Node.ELEMENT_NODE) {
                String name = n.getLocalName();
                if (""camelContext"".equals(name)) {
                    // Parser the camel context
                    BeanDefinition bd = ctx.getDelegate().parseCustomElement((Element)n);
                    // Get the inner camel context id
                    String contextId = (String)bd.getPropertyValues().getPropertyValue(""id"").getValue();
                    wireCamelContext(bean, getContextId(contextId));
                } else if (""camelContextRef"".equals(name)) {
                    String contextId = n.getTextContent();
                    wireCamelContext(bean, getContextId(contextId));
                }
            }
        }
    }
    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        parseAttributes(element, ctx, bean);
        parseCamelContext(element, ctx, bean);
    }
}
"
org.apache.camel.component.irc.IrcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
import org.schwering.irc.lib.IRCEventListener;
public class IrcProducer extends DefaultProducer<IrcExchange> {
    public static final String[] COMMANDS = new String[] {""AWAY"", ""INVITE"", ""ISON"", ""JOIN"", ""KICK"", ""LIST"", ""NAMES"", ""PRIVMSG"", ""MODE"", ""NICK"", ""NOTICE"", ""PART"", ""PONG"", ""QUIT"", ""TOPIC"", ""WHO"",
                                                          ""WHOIS"", ""WHOWAS"", ""USERHOST""};
    private static final transient Log LOG = LogFactory.getLog(IrcProducer.class);
    private IRCConnection connection;
    private IrcEndpoint endpoint;
    private IRCEventListener ircErrorLogger;
    public IrcProducer(IrcEndpoint endpoint, IRCConnection connection) {
        super(endpoint);
        this.endpoint = endpoint;
        this.connection = connection;
    }
    public void process(Exchange exchange) throws Exception {
        try {
            final String msg = exchange.getIn().getBody(String.class);
            if (isMessageACommand(msg)) {
                connection.send(msg);
            } else {
                final String target = endpoint.getConfiguration().getTarget();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""sending to: "" + target + "" message: "" + msg);
                }
                connection.doPrivmsg(target, msg);
            }
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        ircErrorLogger = createIrcErrorLogger();
        connection.addIRCEventListener(ircErrorLogger);
        final String target = endpoint.getConfiguration().getTarget();
        LOG.debug(""joining: "" + target);
        connection.doJoin(target);
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (connection != null) {
            connection.removeIRCEventListener(ircErrorLogger);
        }
    }
    protected boolean isMessageACommand(String msg) {
        for (String command : COMMANDS) {
            if (msg.startsWith(command)) {
                return true;
            }
        }
        return false;
    }
    protected IRCEventListener createIrcErrorLogger() {
        return new IrcErrorLogger(LOG);
    }
}
"
org.apache.camel.component.cxf.MessageInvoker,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.cxf.message.Exchange;
/**
 * The interface to provide a CXF message invoke method
 */
public interface MessageInvoker {
    /**
     * This method is called when the incoming message is to be passed into the
     * camel processor. The return value is the response from the processor
     *
     * @param exchange the CXF exchange which holds the in and out message
     */
    void invoke(Exchange exchange);
}
"
org.apache.camel.component.cxf.util.NullDestinationFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.io.IOException;
import java.util.List;
import java.util.Set;
import org.apache.cxf.binding.AbstractBindingFactory;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.DestinationFactory;
public class NullDestinationFactory implements DestinationFactory {
    public Destination getDestination(EndpointInfo ei) throws IOException {
        // setup the endpoint information
        ei.setAddress(""local://"" + ei.getService().getName().toString() + ""/"" + ei.getName().getLocalPart());
        // working as the dispatch mode, the binding factory will not add interceptor
        ei.getBinding().setProperty(AbstractBindingFactory.DATABINDING_DISABLED, Boolean.TRUE);
        // do nothing here , just creating a null destination to store the observer
        return new NullDestination();
    }
    public List<String> getTransportIds() {
        return null;
    }
    public Set<String> getUriPrefixes() {
        return null;
    }
}
"
org.apache.camel.component.jpa.JpaProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jpa;
import java.util.Iterator;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.DefaultProducer;
import org.springframework.orm.jpa.JpaCallback;
/**
 * @version $Revision$
 */
public class JpaProducer extends DefaultProducer<Exchange> {
    private final TransactionStrategy template;
    private final JpaEndpoint endpoint;
    private final Expression<Exchange> expression;
    public JpaProducer(JpaEndpoint endpoint, Expression<Exchange> expression) {
        super(endpoint);
        this.endpoint = endpoint;
        this.expression = expression;
        this.template = endpoint.createTransactionStrategy();
    }
    public void process(Exchange exchange) {
        final Object values = expression.evaluate(exchange);
        if (values != null) {
            template.execute(new JpaCallback() {
                public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                    Iterator iter = ObjectConverter.iterator(values);
                    while (iter.hasNext()) {
                        Object value = iter.next();
                        entityManager.persist(value);
                    }
                    if (endpoint.isFlushOnSend()) {
                        entityManager.flush();
                    }
                    return null;
                }
            });
        }
        exchange.setProperty(""CamelJpaValue"", values);
    }
}
"
org.apache.camel.component.mail.MailConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import javax.mail.Authenticator;
import javax.mail.Message;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import org.apache.camel.component.mail.security.DummySSLSocketFactory;
import org.springframework.mail.javamail.JavaMailSenderImpl;
/**
 * Represents the configuration data for communicating over email
 *
 * @version $Revision$
 */
public class MailConfiguration {
    public static final String DEFAULT_FOLDER_NAME = ""INBOX"";
    public static final String DEFAULT_FROM = ""camel@localhost"";
    public static final long DEFAULT_CONNECTION_TIMEOUT = 30000L;
    private Properties javaMailProperties;
    private String protocol;
    private String host;
    private int port = -1;
    private String username;
    private String password;
    private Session session;
    private String defaultEncoding;
    private String from = DEFAULT_FROM;
    private String folderName = DEFAULT_FOLDER_NAME;
    private boolean deleteProcessedMessages = true;
    private boolean ignoreUriScheme;
    private boolean processOnlyUnseenMessages;
    private Map<Message.RecipientType, String> recipients = new HashMap<Message.RecipientType, String>();
    private int fetchSize = -1;
    private boolean debugMode;
    private long connectionTimeout = DEFAULT_CONNECTION_TIMEOUT;
    private boolean dummyTrustManager;
    public MailConfiguration() {
    }
    public void configure(URI uri) {
        String value = uri.getHost();
        if (value != null) {
            setHost(value);
        }
        if (!isIgnoreUriScheme()) {
            String scheme = uri.getScheme();
            if (scheme != null) {
                setProtocol(scheme);
            }
        }
        String userInfo = uri.getUserInfo();
        if (userInfo != null) {
            setUsername(userInfo);
            // set default destination to userInfo@host for backwards compatibility
            // can be overridden by URI parameters
            String address = userInfo + ""@"" + host;
            recipients.put(Message.RecipientType.TO, address);
        }
        int port = uri.getPort();
        if (port >= 0) {
            setPort(port);
        } else {
            // resolve default port if no port number was provided
            setPort(MailUtils.getDefaultPortForProtocol(uri.getScheme()));
        }
    }
    protected JavaMailSenderImpl createJavaMailSender() {
        JavaMailSenderImpl answer = new JavaMailSenderImpl();
        // sets the debug mode of the underlying mail framework
        answer.getSession().setDebug(debugMode);
        if (javaMailProperties != null) {
            answer.setJavaMailProperties(javaMailProperties);
        } else {
            // set default properties if none provided
            answer.setJavaMailProperties(createJavaMailProperties());
        }
        if (defaultEncoding != null) {
            answer.setDefaultEncoding(defaultEncoding);
        }
        if (host != null) {
            answer.setHost(host);
        }
        if (port >= 0) {
            answer.setPort(port);
        }
        if (password != null) {
            answer.setPassword(password);
        }
        if (protocol != null) {
            answer.setProtocol(protocol);
        }
        if (session != null) {
            answer.setSession(session);
        } else {
            // use our authenticator that does no live user interaction but returns the already configured username and password
            Session session = Session.getDefaultInstance(answer.getJavaMailProperties(), getAuthenticator());
            answer.setSession(session);
        }
        if (username != null) {
            answer.setUsername(username);
        }
        return answer;
    }
    private Properties createJavaMailProperties() {
        // clone the system properties and set the java mail properties
        Properties properties = (Properties)System.getProperties().clone();
        properties.put(""mail."" + protocol + "".connectiontimeout"", connectionTimeout);
        properties.put(""mail."" + protocol + "".timeout"", connectionTimeout);
        properties.put(""mail."" + protocol + "".host"", host);
        properties.put(""mail."" + protocol + "".port"", """" + port);
        properties.put(""mail."" + protocol + "".user"", username);
        properties.put(""mail."" + protocol + "".rsetbeforequit"", ""true"");
        properties.put(""mail."" + protocol + "".auth"", ""true"");
        properties.put(""mail.transport.protocol"", protocol);
        properties.put(""mail.store.protocol"", protocol);
        properties.put(""mail.host"", host);
        properties.put(""mail.user"", username);
        if (debugMode) {
            // add more debug for the SSL communication as well
            properties.put(""javax.net.debug"", ""all"");
        }
        if (dummyTrustManager && isSecureProtocol()) {
            // set the custom SSL properties
            properties.put(""mail."" + protocol + "".socketFactory.class"", DummySSLSocketFactory.class.getName());
            properties.put(""mail."" + protocol + "".socketFactory.fallback"", ""false"");
            properties.put(""mail."" + protocol + "".socketFactory.port"", """" + port);
        }
        return properties;
    }
   /**
     * Is the used protocol to be secure or not
     */
    public boolean isSecureProtocol() {
        return this.protocol.equalsIgnoreCase(""smtps"") || this.protocol.equalsIgnoreCase(""pop3s"")
               || this.protocol.equalsIgnoreCase(""imaps"");
    }
    /**
     * Returns an authenticator object for use in sessions
     */
    public Authenticator getAuthenticator() {
        return new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(getUsername(), getPassword());
            }
        };
    }
    public String getMailStoreLogInformation() {
        String ssl = """";
        if (isSecureProtocol()) {
            ssl = ""(SSL enabled"" + (dummyTrustManager ? "" using DummyTrustManager)"" : "")"");
        }
        return protocol + ""//"" + host + "":"" + port + ssl + "", folder="" + folderName;
    }
    // Properties
    // -------------------------------------------------------------------------
    public String getDefaultEncoding() {
        return defaultEncoding;
    }
    public void setDefaultEncoding(String defaultEncoding) {
        this.defaultEncoding = defaultEncoding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public Properties getJavaMailProperties() {
        return javaMailProperties;
    }
    public void setJavaMailProperties(Properties javaMailProperties) {
        this.javaMailProperties = javaMailProperties;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getProtocol() {
        return protocol;
    }
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }
    public Session getSession() {
        return session;
    }
    public void setSession(Session session) {
        this.session = session;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
        if (!recipients.containsKey(Message.RecipientType.TO)) {
            // set default destination to username@host for backwards compatibility
            // can be overridden by URI parameters
            String address = username + ""@"" + host;
            recipients.put(Message.RecipientType.TO, address);
        }
    }
    /**
     * Gets the destination (recipient <tt>To</tt> email address).
     *
     * @deprecated use {@link #getRecipients()}
     */
    public String getDestination() {
        // for backwards compatibility
        return recipients.get(Message.RecipientType.TO);
    }
    /**
     * Sets the destination (recipient <tt>To</tt> email address).
     *
     * @deprecated use {@link #setTo(String)}
     */
    public void setDestination(String destination) {
        // for backwards compatibility
        recipients.put(Message.RecipientType.TO, destination);
    }
    public String getFrom() {
        return from;
    }
    public void setFrom(String from) {
        this.from = from;
    }
    public boolean isDeleteProcessedMessages() {
        return deleteProcessedMessages;
    }
    public void setDeleteProcessedMessages(boolean deleteProcessedMessages) {
        this.deleteProcessedMessages = deleteProcessedMessages;
    }
    public String getFolderName() {
        return folderName;
    }
    public void setFolderName(String folderName) {
        this.folderName = folderName;
    }
    public boolean isIgnoreUriScheme() {
        return ignoreUriScheme;
    }
    public void setIgnoreUriScheme(boolean ignoreUriScheme) {
        this.ignoreUriScheme = ignoreUriScheme;
    }
    public boolean isProcessOnlyUnseenMessages() {
        return processOnlyUnseenMessages;
    }
    public void setProcessOnlyUnseenMessages(boolean processOnlyUnseenMessages) {
        this.processOnlyUnseenMessages = processOnlyUnseenMessages;
    }
    /**
     * Sets the <tt>To</tt> email address. Separate multiple email addresses with comma.
     */
    public void setTo(String address) {
        recipients.put(Message.RecipientType.TO, address);
    }
    /**
     * Sets the <tt>CC</tt> email address. Separate multiple email addresses with comma.
     */
    public void setCC(String address) {
        recipients.put(Message.RecipientType.CC, address);
    }
    /**
     * Sets the <tt>BCC</tt> email address. Separate multiple email addresses with comma.
     */
    public void setBCC(String address) {
        recipients.put(Message.RecipientType.BCC, address);
    }
    public Map<Message.RecipientType, String> getRecipients() {
        return recipients;
    }
    public int getFetchSize() {
        return fetchSize;
    }
    public void setFetchSize(int fetchSize) {
        this.fetchSize = fetchSize;
    }
    public boolean isDebugMode() {
        return debugMode;
    }
    public void setDebugMode(boolean debugMode) {
        this.debugMode = debugMode;
    }
    public long getConnectionTimeout() {
        return connectionTimeout;
    }
    public void setConnectionTimeout(long connectionTimeout) {
        this.connectionTimeout = connectionTimeout;
    }
    public boolean isDummyTrustManager() {
        return dummyTrustManager;
    }
    public void setDummyTrustManager(boolean dummyTrustManager) {
        this.dummyTrustManager = dummyTrustManager;
    }
}
"
