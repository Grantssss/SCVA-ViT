metric_name,file
org.apache.camel.Body,"package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface Body {}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Body.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.CamelContext,"package org.apache.camel;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
public interface CamelContext extends Service {
  void addComponent(String paramString, Component paramComponent);
  Component getComponent(String paramString);
  <T extends Component> T getComponent(String paramString, Class<T> paramClass);
  Component removeComponent(String paramString);
  Component getOrCreateComponent(String paramString, Callable<Component> paramCallable);
  Endpoint getEndpoint(String paramString);
  <T extends Endpoint> T getEndpoint(String paramString, Class<T> paramClass);
  Collection<Endpoint> getSingletonEndpoints();
  Endpoint addSingletonEndpoint(String paramString, Endpoint paramEndpoint) throws Exception;
  Endpoint removeSingletonEndpoint(String paramString) throws Exception;
  List<Route> getRoutes();
  void setRoutes(List<Route> paramList);
  void addRoutes(Collection<Route> paramCollection) throws Exception;
  void addRoutes(RouteBuilder paramRouteBuilder) throws Exception;
  ExchangeConverter getExchangeConverter();
  TypeConverter getTypeConverter();
  Injector getInjector();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\CamelContext.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.CamelException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CamelException
/*    */   extends Exception
/*    */ {
/*    */   public CamelException() {}
/*    */   
/* 31 */   public CamelException(String message) { super(message); }
/*    */ 
/*    */ 
/*    */   
/* 35 */   public CamelException(String message, Throwable cause) { super(message, cause); }
/*    */ 
/*    */ 
/*    */   
/* 39 */   public CamelException(Throwable cause) { super(cause); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\CamelException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.CamelTemplate,"/*     */ package org.apache.camel;
/*     */ 
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import org.apache.camel.impl.ServiceSupport;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ import org.apache.camel.util.ProducerCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class CamelTemplate<E extends Exchange>
/*     */   extends ServiceSupport
/*     */ {
/*     */   private CamelContext context;
/*  36 */   private ProducerCache<E> producerCache = new ProducerCache();
/*     */   private boolean useEndpointCache = true;
/*  38 */   private Map<String, Endpoint<E>> endpointCache = new HashMap<String, Endpoint<E>>();
/*     */   
/*     */   private Endpoint<E> defaultEndpoint;
/*     */ 
/*     */   
/*  43 */   public CamelTemplate(CamelContext context) { this.context = context; }
/*     */ 
/*     */   
/*     */   public CamelTemplate(CamelContext context, Endpoint<E> defaultEndpoint) {
/*  47 */     this(context);
/*  48 */     this.defaultEndpoint = defaultEndpoint;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public E send(String endpointUri, E exchange) {
/*  58 */     Endpoint<E> endpoint = resolveMandatoryEndpoint(endpointUri);
/*  59 */     send(endpoint, exchange);
/*  60 */     return exchange;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public E send(String endpointUri, Processor processor) {
/*  70 */     Endpoint<E> endpoint = resolveMandatoryEndpoint(endpointUri);
/*  71 */     return send(endpoint, processor);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public E send(Endpoint<E> endpoint, E exchange) {
/*  81 */     E convertedExchange = endpoint.toExchangeType((Exchange)exchange);
/*  82 */     this.producerCache.send(endpoint, (Exchange)convertedExchange);
/*  83 */     return exchange;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  93 */   public E send(Endpoint<E> endpoint, Processor processor) { return (E)this.producerCache.send(endpoint, processor); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object sendBody(Endpoint<E> endpoint, final Object body) {
/* 104 */     E result = send(endpoint, new Processor() {
/*     */           public void process(Exchange exchange) {
/* 106 */             Message in = exchange.getIn();
/* 107 */             in.setBody(body);
/*     */           }
/*     */         });
/* 110 */     return extractResultBody(result);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object sendBody(String endpointUri, final Object body) {
/* 121 */     E result = send(endpointUri, new Processor() {
/*     */           public void process(Exchange exchange) {
/* 123 */             Message in = exchange.getIn();
/* 124 */             in.setBody(body);
/*     */           }
/*     */         });
/* 127 */     return extractResultBody(result);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object sendBody(String endpointUri, final Object body, final String header, final Object headerValue) {
/* 140 */     E result = send(endpointUri, new Processor() {
/*     */           public void process(Exchange exchange) {
/* 142 */             Message in = exchange.getIn();
/* 143 */             in.setHeader(header, headerValue);
/* 144 */             in.setBody(body);
/*     */           }
/*     */         });
/* 147 */     return extractResultBody(result);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object sendBody(String endpointUri, final Object body, final Map<String, Object> headers) {
/* 158 */     E result = send(endpointUri, new Processor() {
/*     */           public void process(Exchange exchange) {
/* 160 */             Message in = exchange.getIn();
/* 161 */             for (Map.Entry<String, Object> header : (Iterable<Map.Entry<String, Object>>)headers.entrySet()) {
/* 162 */               in.setHeader(header.getKey(), header.getValue());
/*     */             }
/* 164 */             in.setBody(body);
/*     */           }
/*     */         });
/* 167 */     return extractResultBody(result);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 180 */   public Object sendBody(Object body) { return sendBody(getMandatoryDefaultEndpoint(), body); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 189 */   public E send(E exchange) { return send(getMandatoryDefaultEndpoint(), exchange); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 199 */   public E send(Processor processor) { return send(getMandatoryDefaultEndpoint(), processor); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 206 */   public Producer<E> getProducer(Endpoint<E> endpoint) { return this.producerCache.getProducer(endpoint); }
/*     */ 
/*     */ 
/*     */   
/* 210 */   public CamelContext getContext() { return this.context; }
/*     */ 
/*     */ 
/*     */   
/* 214 */   public Endpoint<E> getDefaultEndpoint() { return this.defaultEndpoint; }
/*     */ 
/*     */ 
/*     */   
/* 218 */   public void setDefaultEndpoint(Endpoint<E> defaultEndpoint) { this.defaultEndpoint = defaultEndpoint; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 225 */   public void setDefaultEndpointUri(String endpointUri) { setDefaultEndpoint(getContext().getEndpoint(endpointUri)); }
/*     */ 
/*     */ 
/*     */   
/* 229 */   public boolean isUseEndpointCache() { return this.useEndpointCache; }
/*     */ 
/*     */ 
/*     */   
/* 233 */   public void setUseEndpointCache(boolean useEndpointCache) { this.useEndpointCache = useEndpointCache; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Endpoint resolveMandatoryEndpoint(String endpointUri) {
/* 240 */     Endpoint<E> endpoint = null;
/*     */     
/* 242 */     if (isUseEndpointCache()) {
/* 243 */       synchronized (this.endpointCache) {
/* 244 */         endpoint = this.endpointCache.get(endpointUri);
/* 245 */         if (endpoint == null) {
/* 246 */           endpoint = this.context.getEndpoint(endpointUri);
/* 247 */           if (endpoint != null) {
/* 248 */             this.endpointCache.put(endpointUri, endpoint);
/*     */           }
/*     */         } 
/*     */       } 
/*     */     } else {
/*     */       
/* 254 */       endpoint = this.context.getEndpoint(endpointUri);
/*     */     } 
/* 256 */     if (endpoint == null) {
/* 257 */       throw new NoSuchEndpointException(endpointUri);
/*     */     }
/* 259 */     return endpoint;
/*     */   }
/*     */   
/*     */   protected Endpoint<E> getMandatoryDefaultEndpoint() {
/* 263 */     Endpoint<E> answer = getDefaultEndpoint();
/* 264 */     ObjectHelper.notNull(answer, ""defaultEndpoint"");
/* 265 */     return answer;
/*     */   }
/*     */ 
/*     */   
/* 269 */   protected void doStart() throws Exception { this.producerCache.start(); }
/*     */ 
/*     */ 
/*     */   
/* 273 */   protected void doStop() throws Exception { this.producerCache.stop(); }
/*     */ 
/*     */ 
/*     */   
/* 277 */   protected Object extractResultBody(E result) { return (result != null) ? result.getOut().getBody() : null; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\CamelTemplate.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Component,"package org.apache.camel;
public interface Component<E extends Exchange> {
  CamelContext getCamelContext();
  void setCamelContext(CamelContext paramCamelContext);
  Endpoint<E> createEndpoint(String paramString) throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Component.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Consumer,"package org.apache.camel;
public interface Consumer<E extends Exchange> extends Service {}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Consumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Converter,"package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Converter {}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Converter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Endpoint,"package org.apache.camel;
public interface Endpoint<E extends Exchange> {
  boolean isSingleton();
  String getEndpointUri();
  E createExchange();
  E createExchange(Exchange paramExchange);
  E toExchangeType(Exchange paramExchange);
  CamelContext getContext();
  Producer<E> createProducer() throws Exception;
  Consumer<E> createConsumer(Processor paramProcessor) throws Exception;
  PollingConsumer<E> createPollingConsumer() throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Endpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.EndpointInject,"package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface EndpointInject {
  String uri() default """";
  String name() default """";
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\EndpointInject.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Exchange,"package org.apache.camel;
import java.util.Map;
public interface Exchange {
  String getExchangeId();
  void setExchangeId(String paramString);
  Object getProperty(String paramString);
  <T> T getProperty(String paramString, Class<T> paramClass);
  void setProperty(String paramString, Object paramObject);
  Map<String, Object> getProperties();
  Message getIn();
  Message getOut();
  Message getOut(boolean paramBoolean);
  Message getFault();
  Throwable getException();
  void setException(Throwable paramThrowable);
  CamelContext getContext();
  Exchange copy();
  void copyFrom(Exchange paramExchange);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Exchange.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.ExpectedBodyTypeException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ExpectedBodyTypeException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private final Exchange exchange;
/*    */   private final Class expectedBodyType;
/*    */   
/*    */   public ExpectedBodyTypeException(Exchange exchange, Class expectedBodyType) {
/* 30 */     super(""Could not extract IN message body as type: "" + expectedBodyType + "" body is: "" + exchange.getIn().getBody());
/* 31 */     this.exchange = exchange;
/* 32 */     this.expectedBodyType = expectedBodyType;
/*    */   }
/*    */ 
/*    */   
/* 36 */   public Exchange getExchange() { return this.exchange; }
/*    */ 
/*    */ 
/*    */   
/* 40 */   public Class getExpectedBodyType() { return this.expectedBodyType; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\ExpectedBodyTypeException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Expression,"package org.apache.camel;
public interface Expression<E extends Exchange> {
  Object evaluate(E paramE);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Expression.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.FailedToCreateProducerException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FailedToCreateProducerException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private final Endpoint endpoint;
/*    */   
/*    */   public FailedToCreateProducerException(Endpoint endpoint, Throwable cause) {
/* 27 */     super(""Failed to create Producer for endpoint: "" + endpoint + "". Reason: "" + cause, cause);
/* 28 */     this.endpoint = endpoint;
/*    */   }
/*    */ 
/*    */   
/* 32 */   public Endpoint getEndpoint() { return this.endpoint; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\FailedToCreateProducerException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Header,"package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface Header {
  String name();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Header.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.InvalidHeaderTypeException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class InvalidHeaderTypeException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private static final long serialVersionUID = -8417806626073055262L;
/*    */   private Object headerValue;
/*    */   
/*    */   public InvalidHeaderTypeException(Throwable cause, Object headerValue) {
/* 28 */     super(cause.getMessage() + "" headerValue is: "" + headerValue + "" of type: "" + typeName(headerValue), cause);
/*    */     
/* 30 */     this.headerValue = headerValue;
/*    */   }
/*    */   
/*    */   public InvalidHeaderTypeException(String message, Object headerValue) {
/* 34 */     super(message);
/* 35 */     this.headerValue = headerValue;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 43 */   public Object getHeaderValue() { return this.headerValue; }
/*    */ 
/*    */ 
/*    */   
/* 47 */   protected static String typeName(Object headerValue) { return (headerValue != null) ? headerValue.getClass().getName() : ""null""; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\InvalidHeaderTypeException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Message,"package org.apache.camel;
import java.util.Map;
public interface Message {
  String getMessageId();
  void setMessageId(String paramString);
  Exchange getExchange();
  Object getHeader(String paramString);
  <T> T getHeader(String paramString, Class<T> paramClass);
  void setHeader(String paramString, Object paramObject);
  Map<String, Object> getHeaders();
  void setHeaders(Map<String, Object> paramMap);
  Object getBody();
  <T> T getBody(Class<T> paramClass);
  void setBody(Object paramObject);
  <T> void setBody(Object paramObject, Class<T> paramClass);
  Message copy();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Message.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.MessageDriven,"package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface MessageDriven {
  String uri() default """";
  String name() default """";
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\MessageDriven.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.NoSuchEndpointException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoSuchEndpointException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private static final long serialVersionUID = -8721487431101572630L;
/*    */   private final String uri;
/*    */   
/*    */   public NoSuchEndpointException(String uri) {
/* 33 */     super(""No endpoint could be found for: "" + uri);
/* 34 */     this.uri = uri;
/*    */   }
/*    */ 
/*    */   
/* 38 */   public String getUri() { return this.uri; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\NoSuchEndpointException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.NoTypeConversionAvailableException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoTypeConversionAvailableException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private final Object value;
/*    */   private final Class type;
/*    */   
/*    */   public NoTypeConversionAvailableException(Object value, Class type) {
/* 30 */     super(""No converter available to convert value: "" + value + "" to the required type: "" + type.getName());
/* 31 */     this.value = value;
/* 32 */     this.type = type;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   public Object getValue() { return this.value; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 50 */   public Class getType() { return this.type; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\NoTypeConversionAvailableException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.PollingConsumer,"package org.apache.camel;
public interface PollingConsumer<E extends Exchange> extends Consumer<E> {
  E receive();
  E receiveNoWait();
  E receive(long paramLong);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\PollingConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Predicate,"package org.apache.camel;
public interface Predicate<E> {
  boolean matches(E paramE);
  void assertMatches(String paramString, E paramE) throws AssertionError;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Predicate.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Processor,"package org.apache.camel;
public interface Processor {
  void process(Exchange paramExchange) throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Processor.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Producer,"package org.apache.camel;
public interface Producer<E extends Exchange> extends Processor, Service {
  Endpoint<E> getEndpoint();
  E createExchange();
  E createExchange(E paramE);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Producer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Property,"package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface Property {
  String name();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Property.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.ResolveEndpointFailedException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ResolveEndpointFailedException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private final String uri;
/*    */   
/*    */   public ResolveEndpointFailedException(String uri, Throwable cause) {
/* 29 */     super(""Failed to resolve endpoint: "" + uri + "" due to: "" + cause, cause);
/* 30 */     this.uri = uri;
/*    */   }
/*    */ 
/*    */   
/* 34 */   public String getUri() { return this.uri; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\ResolveEndpointFailedException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Route,"/*    */ package org.apache.camel;
/*    */ 
/*    */ import java.util.ArrayList;
/*    */ import java.util.HashMap;
/*    */ import java.util.List;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Route<E extends Exchange>
/*    */ {
/* 33 */   private final Map<String, Object> properties = new HashMap<String, Object>(16);
/*    */   private Endpoint<E> endpoint;
/* 35 */   private List<Service> services = new ArrayList<Service>();
/*    */ 
/*    */   
/* 38 */   public Route(Endpoint<E> endpoint) { this.endpoint = endpoint; }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Endpoint<E> getEndpoint() { return this.endpoint; }
/*    */ 
/*    */ 
/*    */   
/* 46 */   public void setEndpoint(Endpoint<E> endpoint) { this.endpoint = endpoint; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 56 */   public Map<String, Object> getProperties() { return this.properties; }
/*    */ 
/*    */   
/*    */   public List<Service> getServicesForRoute() throws Exception {
/* 60 */     List<Service> servicesForRoute = new ArrayList<Service>(getServices());
/* 61 */     addServices(servicesForRoute);
/* 62 */     return servicesForRoute;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 69 */   public List<Service> getServices() throws Exception { return this.services; }
/*    */ 
/*    */ 
/*    */   
/* 73 */   public void setServices(List<Service> services) { this.services = services; }
/*    */   
/*    */   protected abstract void addServices(List<Service> paramList) throws Exception;
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Route.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.RuntimeCamelException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RuntimeCamelException
/*    */   extends RuntimeException
/*    */ {
/*    */   private static final long serialVersionUID = 8046489554418284257L;
/*    */   
/*    */   public RuntimeCamelException() {}
/*    */   
/* 29 */   public RuntimeCamelException(String message) { super(message); }
/*    */ 
/*    */ 
/*    */   
/* 33 */   public RuntimeCamelException(String message, Throwable cause) { super(message, cause); }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public RuntimeCamelException(Throwable cause) { super(cause); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\RuntimeCamelException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.RuntimeExpressionException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RuntimeExpressionException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private static final long serialVersionUID = -8417806626073055262L;
/*    */   
/* 30 */   public RuntimeExpressionException(String message) { super(message); }
/*    */ 
/*    */ 
/*    */   
/* 34 */   public RuntimeExpressionException(String message, Throwable cause) { super(message, cause); }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public RuntimeExpressionException(Throwable cause) { super(cause); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\RuntimeExpressionException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.RuntimeTransformException,"/*    */ package org.apache.camel;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RuntimeTransformException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private static final long serialVersionUID = -8417806626073055262L;
/*    */   
/* 30 */   public RuntimeTransformException(String message) { super(message); }
/*    */ 
/*    */ 
/*    */   
/* 34 */   public RuntimeTransformException(String message, Throwable cause) { super(message, cause); }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public RuntimeTransformException(Throwable cause) { super(cause); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\RuntimeTransformException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.Service,"package org.apache.camel;
public interface Service {
  void start() throws Exception;
  void stop() throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\Service.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.TypeConverter,"package org.apache.camel;
public interface TypeConverter {
  <T> T convertTo(Class<T> paramClass, Object paramObject);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\TypeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.Builder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Expression;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Builder
/*    */ {
/*    */   public static <E extends org.apache.camel.Exchange> ValueBuilder<E> constant(Object value) {
/* 37 */     Expression<E> expression = ExpressionBuilder.constantExpression(value);
/* 38 */     return new ValueBuilder<E>(expression);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static <E extends org.apache.camel.Exchange> ValueBuilder<E> header(@FluentArg(""name"") String name) {
/* 45 */     Expression<E> expression = ExpressionBuilder.headerExpression(name);
/* 46 */     return new ValueBuilder<E>(expression);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static <E extends org.apache.camel.Exchange> ValueBuilder<E> body() {
/* 53 */     Expression<E> expression = ExpressionBuilder.bodyExpression();
/* 54 */     return new ValueBuilder<E>(expression);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static <E extends org.apache.camel.Exchange, T> ValueBuilder<E> bodyAs(Class<T> type) {
/* 61 */     Expression<E> expression = ExpressionBuilder.bodyExpression(type);
/* 62 */     return new ValueBuilder<E>(expression);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static <E extends org.apache.camel.Exchange> ValueBuilder<E> outBody() {
/* 69 */     Expression<E> expression = ExpressionBuilder.bodyExpression();
/* 70 */     return new ValueBuilder<E>(expression);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static <E extends org.apache.camel.Exchange, T> ValueBuilder<E> outBody(Class<T> type) {
/* 77 */     Expression<E> expression = ExpressionBuilder.bodyExpression(type);
/* 78 */     return new ValueBuilder<E>(expression);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 86 */   public static <E extends org.apache.camel.Exchange> ValueBuilder<E> systemProperty(String name) { return systemProperty(name, null); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 93 */   public static <E extends org.apache.camel.Exchange> ValueBuilder<E> systemProperty(String name, String defaultValue) { return new ValueBuilder<E>(ExpressionBuilder.systemProperty(name, defaultValue)); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\Builder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.BuilderSupport,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import org.apache.camel.CamelContext;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.processor.LoggingLevel;
/*     */ import org.apache.camel.processor.SendProcessor;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class BuilderSupport
/*     */ {
/*     */   private CamelContext context;
/*     */   private ErrorHandlerBuilder errorHandlerBuilder;
/*     */   private boolean inheritErrorHandler = true;
/*     */   
/*  41 */   protected BuilderSupport(CamelContext context) { this.context = context; }
/*     */ 
/*     */   
/*     */   protected BuilderSupport(BuilderSupport parent) {
/*  45 */     this.context = parent.getContext();
/*  46 */     this.inheritErrorHandler = parent.inheritErrorHandler;
/*  47 */     if (this.inheritErrorHandler && parent.errorHandlerBuilder != null) {
/*  48 */       this.errorHandlerBuilder = parent.errorHandlerBuilder.copy();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  60 */   public ValueBuilder header(@FluentArg(""name"") String name) { return Builder.header(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  68 */   public ValueBuilder body() { return Builder.body(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  76 */   public <T> ValueBuilder bodyAs(@FluentArg(""class"") Class<T> type) { return Builder.bodyAs(type); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  84 */   public ValueBuilder outBody() { return Builder.outBody(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  92 */   public <T> ValueBuilder outBody(@FluentArg(""class"") Class<T> type) { return Builder.outBody(type); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 100 */   public ValueBuilder systemProperty(@FluentArg(""name"") String name) { return Builder.systemProperty(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 109 */   public ValueBuilder systemProperty(@FluentArg(""name"") String name, @FluentArg(""defaultValue"") String defaultValue) { return Builder.systemProperty(name, defaultValue); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 117 */   public Endpoint endpoint(@FluentArg(""uri"") String uri) { return getContext().getEndpoint(uri); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public List<Endpoint> endpoints(@FluentArg(""uris"") String... uris) {
/* 125 */     List<Endpoint> endpoints = new ArrayList<Endpoint>();
/* 126 */     for (String uri : uris) {
/* 127 */       endpoints.add(endpoint(uri));
/*     */     }
/* 129 */     return endpoints;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public List<Endpoint> endpoints(@FluentArg(""endpoints"") Endpoint... endpoints) {
/* 137 */     List<Endpoint> answer = new ArrayList<Endpoint>();
/* 138 */     for (Endpoint endpoint : endpoints) {
/* 139 */       answer.add(endpoint);
/*     */     }
/* 141 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 149 */   public NoErrorHandlerBuilder noErrorHandler() { return new NoErrorHandlerBuilder<Exchange>(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 157 */   public LoggingErrorHandlerBuilder loggingErrorHandler() { return new LoggingErrorHandlerBuilder(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 165 */   public LoggingErrorHandlerBuilder loggingErrorHandler(@FluentArg(""log"") String log) { return loggingErrorHandler(LogFactory.getLog(log)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 173 */   public LoggingErrorHandlerBuilder loggingErrorHandler(@FluentArg(""log"") Log log) { return new LoggingErrorHandlerBuilder(log); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 182 */   public LoggingErrorHandlerBuilder loggingErrorHandler(@FluentArg(""log"") Log log, @FluentArg(""level"") LoggingLevel level) { return new LoggingErrorHandlerBuilder(log, level); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 187 */   public DeadLetterChannelBuilder deadLetterChannel() { return new DeadLetterChannelBuilder(); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 192 */   public DeadLetterChannelBuilder deadLetterChannel(@FluentArg(""uri"") String deadLetterUri) { return deadLetterChannel(endpoint(deadLetterUri)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 197 */   public DeadLetterChannelBuilder deadLetterChannel(@FluentArg(""ref"") Endpoint deadLetterEndpoint) { return new DeadLetterChannelBuilder((Processor)new SendProcessor(deadLetterEndpoint)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 203 */   public CamelContext getContext() { return this.context; }
/*     */ 
/*     */ 
/*     */   
/* 207 */   public void setContext(CamelContext context) { this.context = context; }
/*     */ 
/*     */   
/*     */   public ErrorHandlerBuilder getErrorHandlerBuilder() {
/* 211 */     if (this.errorHandlerBuilder == null) {
/* 212 */       this.errorHandlerBuilder = createErrorHandlerBuilder();
/*     */     }
/* 214 */     return this.errorHandlerBuilder;
/*     */   }
/*     */   
/*     */   protected ErrorHandlerBuilder createErrorHandlerBuilder() {
/* 218 */     if (isInheritErrorHandler()) {
/* 219 */       return new DeadLetterChannelBuilder();
/*     */     }
/*     */     
/* 222 */     return new NoErrorHandlerBuilder<Exchange>();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 230 */   public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) { this.errorHandlerBuilder = errorHandlerBuilder; }
/*     */ 
/*     */ 
/*     */   
/* 234 */   public boolean isInheritErrorHandler() { return this.inheritErrorHandler; }
/*     */ 
/*     */ 
/*     */   
/* 238 */   public void setInheritErrorHandler(boolean inheritErrorHandler) { this.inheritErrorHandler = inheritErrorHandler; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\BuilderSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ChoiceBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import java.util.ArrayList;
/*    */ import java.util.List;
/*    */ import org.apache.camel.Predicate;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.ChoiceProcessor;
/*    */ import org.apache.camel.processor.FilterProcessor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ChoiceBuilder
/*    */   extends FromBuilder
/*    */ {
/*    */   private final FromBuilder parent;
/* 33 */   private List<WhenBuilder> predicateBuilders = new ArrayList<WhenBuilder>();
/*    */   private FromBuilder otherwise;
/*    */   
/*    */   public ChoiceBuilder(FromBuilder parent) {
/* 37 */     super(parent);
/* 38 */     this.parent = parent;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   @Fluent(nestedActions = true)
/*    */   public WhenBuilder when(@FluentArg(value = ""predicate"", element = true) Predicate predicate) {
/* 50 */     WhenBuilder answer = new WhenBuilder(this, predicate);
/* 51 */     this.predicateBuilders.add(answer);
/* 52 */     return answer;
/*    */   }
/*    */   
/*    */   @Fluent(nestedActions = true)
/*    */   public FromBuilder otherwise() {
/* 57 */     this.otherwise = new FromBuilder(this.parent);
/* 58 */     return this.otherwise;
/*    */   }
/*    */ 
/*    */   
/* 62 */   public List<WhenBuilder> getPredicateBuilders() { return this.predicateBuilders; }
/*    */ 
/*    */ 
/*    */   
/* 66 */   public FromBuilder getOtherwise() { return this.otherwise; }
/*    */ 
/*    */ 
/*    */   
/*    */   public Processor createProcessor() throws Exception {
/* 71 */     List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
/* 72 */     for (WhenBuilder predicateBuilder : this.predicateBuilders) {
/* 73 */       filters.add(predicateBuilder.createProcessor());
/*    */     }
/* 75 */     Processor otherwiseProcessor = null;
/* 76 */     if (this.otherwise != null) {
/* 77 */       otherwiseProcessor = this.otherwise.createProcessor();
/*    */     }
/* 79 */     return (Processor)new ChoiceProcessor(filters, otherwiseProcessor);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ChoiceBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ConstantProcessorBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ConstantProcessorBuilder
/*    */   implements ProcessorFactory
/*    */ {
/*    */   private Processor processor;
/*    */   
/* 30 */   public ConstantProcessorBuilder(Processor processor) { this.processor = processor; }
/*    */ 
/*    */ 
/*    */   
/* 34 */   public Processor createProcessor() { return this.processor; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ConstantProcessorBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.DeadLetterChannelBuilder,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.processor.DeadLetterChannel;
/*     */ import org.apache.camel.processor.Logger;
/*     */ import org.apache.camel.processor.LoggingLevel;
/*     */ import org.apache.camel.processor.RecipientList;
/*     */ import org.apache.camel.processor.RedeliveryPolicy;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DeadLetterChannelBuilder
/*     */   implements ErrorHandlerBuilder
/*     */ {
/*  37 */   private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
/*     */   private ProcessorFactory deadLetterFactory;
/*     */   private Processor defaultDeadLetterEndpoint;
/*     */   private Expression defaultDeadLetterEndpointExpression;
/*  41 */   private String defaultDeadLetterEndpointUri = ""log:org.apache.camel.DeadLetterChannel:error"";
/*  42 */   private Logger logger = DeadLetterChannel.createDefaultLogger();
/*     */ 
/*     */   
/*     */   public DeadLetterChannelBuilder() {}
/*     */ 
/*     */   
/*  48 */   public DeadLetterChannelBuilder(Processor processor) { this(new ConstantProcessorBuilder(processor)); }
/*     */ 
/*     */ 
/*     */   
/*  52 */   public DeadLetterChannelBuilder(ProcessorFactory deadLetterFactory) { this.deadLetterFactory = deadLetterFactory; }
/*     */ 
/*     */   
/*     */   public ErrorHandlerBuilder copy() {
/*  56 */     DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder(this.deadLetterFactory);
/*  57 */     answer.setRedeliveryPolicy(getRedeliveryPolicy().copy());
/*  58 */     return answer;
/*     */   }
/*     */   
/*     */   public Processor createErrorHandler(Processor processor) throws Exception {
/*  62 */     Processor deadLetter = getDeadLetterFactory().createProcessor();
/*  63 */     return (Processor)new DeadLetterChannel(processor, deadLetter, getRedeliveryPolicy(), getLogger());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public DeadLetterChannelBuilder backOffMultiplier(double backOffMultiplier) {
/*  69 */     getRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
/*  70 */     return this;
/*     */   }
/*     */   
/*     */   public DeadLetterChannelBuilder collisionAvoidancePercent(short collisionAvoidancePercent) {
/*  74 */     getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
/*  75 */     return this;
/*     */   }
/*     */   
/*     */   public DeadLetterChannelBuilder initialRedeliveryDelay(long initialRedeliveryDelay) {
/*  79 */     getRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
/*  80 */     return this;
/*     */   }
/*     */   
/*     */   public DeadLetterChannelBuilder maximumRedeliveries(int maximumRedeliveries) {
/*  84 */     getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
/*  85 */     return this;
/*     */   }
/*     */   
/*     */   public DeadLetterChannelBuilder useCollisionAvoidance() {
/*  89 */     getRedeliveryPolicy().useCollisionAvoidance();
/*  90 */     return this;
/*     */   }
/*     */   
/*     */   public DeadLetterChannelBuilder useExponentialBackOff() {
/*  94 */     getRedeliveryPolicy().useExponentialBackOff();
/*  95 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DeadLetterChannelBuilder logger(Logger logger) {
/* 102 */     setLogger(logger);
/* 103 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DeadLetterChannelBuilder loggingLevel(LoggingLevel level) {
/* 110 */     getLogger().setLevel(level);
/* 111 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DeadLetterChannelBuilder log(Log log) {
/* 118 */     getLogger().setLog(log);
/* 119 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public DeadLetterChannelBuilder log(String log) { return log(LogFactory.getLog(log)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 133 */   public DeadLetterChannelBuilder log(Class log) { return log(LogFactory.getLog(log)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 139 */   public RedeliveryPolicy getRedeliveryPolicy() { return this.redeliveryPolicy; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 146 */   public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) { this.redeliveryPolicy = redeliveryPolicy; }
/*     */ 
/*     */   
/*     */   public ProcessorFactory getDeadLetterFactory() {
/* 150 */     if (this.deadLetterFactory == null) {
/* 151 */       this.deadLetterFactory = new ProcessorFactory() {
/*     */           public Processor createProcessor() {
/* 153 */             return DeadLetterChannelBuilder.this.getDefaultDeadLetterEndpoint();
/*     */           }
/*     */         };
/*     */     }
/* 157 */     return this.deadLetterFactory;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 164 */   public void setDeadLetterFactory(ProcessorFactory deadLetterFactory) { this.deadLetterFactory = deadLetterFactory; }
/*     */ 
/*     */   
/*     */   public Processor getDefaultDeadLetterEndpoint() {
/* 168 */     if (this.defaultDeadLetterEndpoint == null) {
/* 169 */       this.defaultDeadLetterEndpoint = (Processor)new RecipientList(getDefaultDeadLetterEndpointExpression());
/*     */     }
/* 171 */     return this.defaultDeadLetterEndpoint;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 178 */   public void setDefaultDeadLetterEndpoint(Processor defaultDeadLetterEndpoint) { this.defaultDeadLetterEndpoint = defaultDeadLetterEndpoint; }
/*     */ 
/*     */   
/*     */   public Expression getDefaultDeadLetterEndpointExpression() {
/* 182 */     if (this.defaultDeadLetterEndpointExpression == null) {
/* 183 */       this.defaultDeadLetterEndpointExpression = ExpressionBuilder.constantExpression(getDefaultDeadLetterEndpointUri());
/*     */     }
/* 185 */     return this.defaultDeadLetterEndpointExpression;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 193 */   public void setDefaultDeadLetterEndpointExpression(Expression defaultDeadLetterEndpointExpression) { this.defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression; }
/*     */ 
/*     */ 
/*     */   
/* 197 */   public String getDefaultDeadLetterEndpointUri() { return this.defaultDeadLetterEndpointUri; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 207 */   public void setDefaultDeadLetterEndpointUri(String defaultDeadLetterEndpointUri) { this.defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri; }
/*     */ 
/*     */ 
/*     */   
/* 211 */   public Logger getLogger() { return this.logger; }
/*     */ 
/*     */ 
/*     */   
/* 215 */   public void setLogger(Logger logger) { this.logger = logger; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\DeadLetterChannelBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ErrorHandlerBuilder,"package org.apache.camel.builder;
import org.apache.camel.Processor;
public interface ErrorHandlerBuilder<E extends org.apache.camel.Exchange> {
  ErrorHandlerBuilder<E> copy();
  Processor createErrorHandler(Processor paramProcessor) throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ErrorHandlerBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ExpressionBuilder,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.Arrays;
/*     */ import java.util.List;
/*     */ import java.util.StringTokenizer;
/*     */ import java.util.regex.Pattern;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ExpressionBuilder
/*     */ {
/*     */   public static <E extends Exchange> Expression<E> headerExpression(final String headerName) {
/*  41 */     return new Expression<E>() {
/*     */         public Object evaluate(E exchange) {
/*  43 */           Object header = exchange.getIn().getHeader(headerName);
/*  44 */           if (header == null)
/*     */           {
/*  46 */             header = exchange.getProperty(headerName);
/*     */           }
/*  48 */           return header;
/*     */         }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*  54 */         public String toString() { return ""header("" + headerName + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> propertyExpression(final String propertyName) {
/*  66 */     return new Expression<E>()
/*     */       {
/*  68 */         public Object evaluate(E exchange) { return exchange.getProperty(propertyName); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*  73 */         public String toString() { return ""property("" + propertyName + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> constantExpression(final Object value) {
/*  85 */     return new Expression<E>()
/*     */       {
/*  87 */         public Object evaluate(E exchange) { return value; }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*  92 */         public String toString() { return """" + value; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> bodyExpression() {
/* 101 */     return new Expression<E>()
/*     */       {
/* 103 */         public Object evaluate(E exchange) { return exchange.getIn().getBody(); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 108 */         public String toString() { return ""body""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange, T> Expression<E> bodyExpression(final Class<T> type) {
/* 118 */     return new Expression<E>()
/*     */       {
/* 120 */         public Object evaluate(E exchange) { return exchange.getIn().getBody(type); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 125 */         public String toString() { return ""bodyAs["" + type.getName() + ""]""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> outBodyExpression() {
/* 134 */     return new Expression<E>()
/*     */       {
/* 136 */         public Object evaluate(E exchange) { return exchange.getOut().getBody(); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 141 */         public String toString() { return ""outBody""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> exchangeExpression() {
/* 150 */     return new Expression<E>()
/*     */       {
/* 152 */         public Object evaluate(E exchange) { return exchange; }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 157 */         public String toString() { return ""exchange""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> inMessageExpression() {
/* 166 */     return new Expression<E>()
/*     */       {
/* 168 */         public Object evaluate(E exchange) { return exchange.getIn(); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 173 */         public String toString() { return ""inMessage""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> convertTo(final Expression expression, final Class type) {
/* 182 */     return new Expression<E>() {
/*     */         public Object evaluate(E exchange) {
/* 184 */           Object value = expression.evaluate((Exchange)exchange);
/* 185 */           return exchange.getContext().getTypeConverter().convertTo(type, value);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 190 */         public String toString() { return ""convertTo("" + expression + "", "" + type + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> tokenizeExpression(final Expression<E> expression, final String token) {
/* 199 */     return new Expression<E>() {
/*     */         public Object evaluate(E exchange) {
/* 201 */           String text = ExpressionBuilder.evaluateStringExpression(expression, (Exchange)exchange);
/* 202 */           if (text == null) {
/* 203 */             return null;
/*     */           }
/* 205 */           StringTokenizer iter = new StringTokenizer(text, token);
/* 206 */           List<String> answer = new ArrayList<String>();
/* 207 */           while (iter.hasMoreTokens()) {
/* 208 */             answer.add(iter.nextToken());
/*     */           }
/* 210 */           return answer;
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 215 */         public String toString() { return ""tokenize("" + expression + "", "" + token + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> regexTokenize(final Expression<E> expression, String regexTokenizer) {
/* 224 */     final Pattern pattern = Pattern.compile(regexTokenizer);
/* 225 */     return new Expression<E>() {
/*     */         public Object evaluate(E exchange) {
/* 227 */           String text = ExpressionBuilder.evaluateStringExpression(expression, (Exchange)exchange);
/* 228 */           if (text == null) {
/* 229 */             return null;
/*     */           }
/* 231 */           return Arrays.asList(pattern.split(text));
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 236 */         public String toString() { return ""regexTokenize("" + expression + "", "" + pattern.pattern() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression, String regex, final String replacement) {
/* 245 */     final Pattern pattern = Pattern.compile(regex);
/* 246 */     return new Expression<E>() {
/*     */         public Object evaluate(E exchange) {
/* 248 */           String text = ExpressionBuilder.evaluateStringExpression(expression, (Exchange)exchange);
/* 249 */           if (text == null) {
/* 250 */             return null;
/*     */           }
/* 252 */           return pattern.matcher(text).replaceAll(replacement);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 257 */         public String toString() { return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression, String regex, final Expression<E> replacementExpression) {
/* 266 */     final Pattern pattern = Pattern.compile(regex);
/* 267 */     return new Expression<E>() {
/*     */         public Object evaluate(E exchange) {
/* 269 */           String text = ExpressionBuilder.evaluateStringExpression(expression, (Exchange)exchange);
/* 270 */           String replacement = ExpressionBuilder.evaluateStringExpression(replacementExpression, (Exchange)exchange);
/* 271 */           if (text == null || replacement == null) {
/* 272 */             return null;
/*     */           }
/* 274 */           return pattern.matcher(text).replaceAll(replacement);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 279 */         public String toString() { return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> append(final Expression<E> left, final Expression<E> right) {
/* 289 */     return new Expression<E>()
/*     */       {
/* 291 */         public Object evaluate(E exchange) { return ExpressionBuilder.evaluateStringExpression(left, (Exchange)exchange) + ExpressionBuilder.evaluateStringExpression(right, (Exchange)exchange); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 296 */         public String toString() { return ""append("" + left + "", "" + right + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> String evaluateStringExpression(Expression<E> expression, E exchange) {
/* 309 */     Object value = expression.evaluate((Exchange)exchange);
/* 310 */     return (String)exchange.getContext().getTypeConverter().convertTo(String.class, value);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 317 */   public static <E extends Exchange> Expression<E> systemProperty(String name) { return systemProperty(name, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Expression<E> systemProperty(final String name, final String defaultValue) {
/* 324 */     return new Expression<E>()
/*     */       {
/* 326 */         public Object evaluate(E exchange) { return System.getProperty(name, defaultValue); }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ExpressionBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.FilterBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Predicate;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.FilterProcessor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FilterBuilder
/*    */   extends FromBuilder
/*    */ {
/*    */   private Predicate predicate;
/*    */   
/*    */   public FilterBuilder(FromBuilder builder, Predicate predicate) {
/* 31 */     super(builder);
/* 32 */     this.predicate = predicate;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FilterBuilder and(Predicate<Exchange> predicate) {
/* 39 */     this.predicate = PredicateBuilder.and(this.predicate, predicate);
/* 40 */     return this;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FilterBuilder or(Predicate<Exchange> predicate) {
/* 47 */     this.predicate = PredicateBuilder.or(this.predicate, predicate);
/* 48 */     return this;
/*    */   }
/*    */ 
/*    */   
/* 52 */   public Predicate getPredicate() { return this.predicate; }
/*    */ 
/*    */ 
/*    */   
/*    */   public FilterProcessor createProcessor() throws Exception {
/* 57 */     Processor childProcessor = super.createProcessor();
/* 58 */     return new FilterProcessor(this.predicate, childProcessor);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\FilterBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.Fluent,"package org.apache.camel.builder;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Fluent {
  String value() default """";
  boolean nestedActions() default false;
  boolean callOnElementEnd() default false;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\Fluent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.FluentArg,"package org.apache.camel.builder;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface FluentArg {
  String value();
  boolean attribute() default true;
  boolean element() default false;
  boolean reference() default false;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\FluentArg.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.FromBuilder,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Collections;
/*     */ import java.util.List;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Predicate;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Route;
/*     */ import org.apache.camel.impl.EventDrivenConsumerRoute;
/*     */ import org.apache.camel.processor.CompositeProcessor;
/*     */ import org.apache.camel.processor.DelegateProcessor;
/*     */ import org.apache.camel.processor.idempotent.MessageIdRepository;
/*     */ import org.apache.camel.spi.Policy;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FromBuilder
/*     */   extends BuilderSupport
/*     */   implements ProcessorFactory
/*     */ {
/*     */   public static final String DEFAULT_TRACE_CATEGORY = ""org.apache.camel.TRACE"";
/*     */   private RouteBuilder builder;
/*     */   private Endpoint from;
/*  49 */   private List<Processor> processors = new ArrayList<Processor>();
/*  50 */   private List<ProcessorFactory> processFactories = new ArrayList<ProcessorFactory>();
/*     */   private FromBuilder routeBuilder;
/*     */   
/*     */   public FromBuilder(RouteBuilder builder, Endpoint from) {
/*  54 */     super(builder);
/*  55 */     this.builder = builder;
/*  56 */     this.from = from;
/*     */   }
/*     */   
/*     */   public FromBuilder(FromBuilder parent) {
/*  60 */     super(parent);
/*  61 */     this.builder = parent.getBuilder();
/*  62 */     this.from = parent.getFrom();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  70 */   public ProcessorFactory to(@FluentArg(""uri"") String uri) { return to(endpoint(uri)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ProcessorFactory to(@FluentArg(""ref"") Endpoint endpoint) {
/*  78 */     ToBuilder<Exchange> answer = new ToBuilder<Exchange>(this, endpoint);
/*  79 */     addProcessBuilder(answer);
/*  80 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  88 */   public ProcessorFactory to(String... uris) { return to(endpoints(uris)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  98 */   public ProcessorFactory to(@FluentArg(value = ""endpoint"", attribute = false, element = true) Endpoint... endpoints) { return to(endpoints(endpoints)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 107 */   public ProcessorFactory to(@FluentArg(value = ""endpoint"", attribute = false, element = true) Collection<Endpoint> endpoints) { return addProcessBuilder(new MulticastBuilder(this, endpoints)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 116 */   public ProcessorFactory pipeline(@FluentArg(""uris"") String... uris) { return pipeline(endpoints(uris)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 125 */   public ProcessorFactory pipeline(@FluentArg(""endpoints"") Endpoint... endpoints) { return pipeline(endpoints(endpoints)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 134 */   public ProcessorFactory pipeline(@FluentArg(""endpoints"") Collection<Endpoint> endpoints) { return addProcessBuilder(new PipelineBuilder(this, endpoints)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 144 */   public IdempotentConsumerBuilder idempotentConsumer(@FluentArg(""messageIdExpression"") Expression messageIdExpression, @FluentArg(""MessageIdRepository"") MessageIdRepository messageIdRepository) { return (IdempotentConsumerBuilder)addProcessBuilder(new IdempotentConsumerBuilder(this, messageIdExpression, messageIdRepository)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FilterBuilder filter(@FluentArg(value = ""predicate"", element = true) Predicate predicate) {
/* 157 */     FilterBuilder answer = new FilterBuilder(this, predicate);
/* 158 */     addProcessBuilder(answer);
/* 159 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent(nestedActions = true)
/*     */   public ChoiceBuilder choice() {
/* 169 */     ChoiceBuilder answer = new ChoiceBuilder(this);
/* 170 */     addProcessBuilder(answer);
/* 171 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public RecipientListBuilder recipientList(@FluentArg(value = ""recipients"", element = true) Expression receipients) {
/* 183 */     RecipientListBuilder<Exchange> answer = new RecipientListBuilder<Exchange>(this, receipients);
/* 184 */     addProcessBuilder(answer);
/* 185 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public SplitterBuilder splitter(@FluentArg(value = ""recipients"", element = true) Expression receipients) {
/* 197 */     SplitterBuilder answer = new SplitterBuilder(this, receipients);
/* 198 */     addProcessBuilder(answer);
/* 199 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 211 */   public ResequencerBuilder resequencer(Expression<Exchange> expression) { return resequencer(Collections.singletonList(expression)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ResequencerBuilder resequencer(@FluentArg(""expressions"") List<Expression<Exchange>> expressions) {
/* 224 */     ResequencerBuilder answer = new ResequencerBuilder(this, expressions);
/* 225 */     setRouteBuilder(answer);
/* 226 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ResequencerBuilder resequencer(Expression<Exchange>... expressions) {
/* 239 */     List<Expression<Exchange>> list = new ArrayList<Expression<Exchange>>();
/* 240 */     for (Expression<Exchange> expression : expressions) {
/* 241 */       list.add(expression);
/*     */     }
/* 243 */     return resequencer(list);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder errorHandler(@FluentArg(""handler"") ErrorHandlerBuilder errorHandlerBuilder) {
/* 254 */     setErrorHandlerBuilder(errorHandlerBuilder);
/* 255 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder inheritErrorHandler(@FluentArg(""condition"") boolean condition) {
/* 266 */     setInheritErrorHandler(condition);
/* 267 */     return this;
/*     */   }
/*     */   
/*     */   @Fluent(nestedActions = true)
/*     */   public InterceptorBuilder intercept() {
/* 272 */     InterceptorBuilder answer = new InterceptorBuilder(this);
/* 273 */     addProcessBuilder(answer);
/* 274 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 285 */   public FromBuilder trace() { return trace(""org.apache.camel.TRACE""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder trace(@FluentArg(""category"") String category) {
/* 297 */     final Log log = LogFactory.getLog(category);
/* 298 */     return intercept(new DelegateProcessor()
/*     */         {
/*     */           public void process(Exchange exchange) throws Exception {
/* 301 */             log.trace(exchange);
/* 302 */             processNext(exchange);
/*     */           }
/*     */         });
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder intercept(@FluentArg(""interceptor"") DelegateProcessor interceptor) {
/* 309 */     InterceptorBuilder answer = new InterceptorBuilder(this);
/* 310 */     answer.add(interceptor);
/* 311 */     addProcessBuilder(answer);
/* 312 */     return answer.target();
/*     */   }
/*     */   
/*     */   @Fluent(nestedActions = true)
/*     */   public PolicyBuilder policies() {
/* 317 */     PolicyBuilder answer = new PolicyBuilder(this);
/* 318 */     addProcessBuilder(answer);
/* 319 */     return answer;
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder policy(@FluentArg(""policy"") Policy policy) {
/* 324 */     PolicyBuilder answer = new PolicyBuilder(this);
/* 325 */     answer.add(policy);
/* 326 */     addProcessBuilder(answer);
/* 327 */     return answer.target();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder process(@FluentArg(""ref"") Processor processor) {
/* 338 */     addProcessorBuilder(processor);
/* 339 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder setBody(Expression expression) {
/* 347 */     addProcessorBuilder(ProcessorBuilder.setBody(expression));
/* 348 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder setOutBody(Expression expression) {
/* 356 */     addProcessorBuilder(ProcessorBuilder.setOutBody(expression));
/* 357 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder setHeader(String name, Expression expression) {
/* 365 */     addProcessorBuilder(ProcessorBuilder.setHeader(name, expression));
/* 366 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder setOutHeader(String name, Expression expression) {
/* 374 */     addProcessorBuilder(ProcessorBuilder.setOutHeader(name, expression));
/* 375 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder setProperty(String name, Expression expression) {
/* 383 */     addProcessorBuilder(ProcessorBuilder.setProperty(name, expression));
/* 384 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder convertBodyTo(Class type) {
/* 392 */     addProcessorBuilder(ProcessorBuilder.setBody(Builder.body().convertTo(type)));
/* 393 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder convertOutBodyTo(Class type) {
/* 401 */     addProcessorBuilder(ProcessorBuilder.setOutBody(Builder.outBody().convertTo(type)));
/* 402 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 408 */   public RouteBuilder getBuilder() { return this.builder; }
/*     */ 
/*     */ 
/*     */   
/* 412 */   public Endpoint getFrom() { return this.from; }
/*     */ 
/*     */ 
/*     */   
/* 416 */   public List<Processor> getProcessors() { return this.processors; }
/*     */ 
/*     */   
/*     */   public ProcessorFactory addProcessBuilder(ProcessorFactory processFactory) {
/* 420 */     this.processFactories.add(processFactory);
/* 421 */     return processFactory;
/*     */   }
/*     */ 
/*     */   
/* 425 */   protected void addProcessorBuilder(Processor processor) { addProcessBuilder(new ConstantProcessorBuilder(processor)); }
/*     */ 
/*     */ 
/*     */   
/* 429 */   public void addProcessor(Processor processor) { this.processors.add(processor); }
/*     */ 
/*     */   
/*     */   public Route createRoute() throws Exception {
/* 433 */     if (this.routeBuilder != null) {
/* 434 */       return this.routeBuilder.createRoute();
/*     */     }
/* 436 */     Processor processor = createProcessor();
/* 437 */     if (processor == null) {
/* 438 */       throw new IllegalArgumentException(""No processor created for: "" + this);
/*     */     }
/* 440 */     return (Route)new EventDrivenConsumerRoute(getFrom(), processor);
/*     */   }
/*     */   
/*     */   public Processor createProcessor() throws Exception {
/* 444 */     List<Processor> answer = new ArrayList<Processor>();
/*     */     
/* 446 */     for (ProcessorFactory processFactory : this.processFactories) {
/* 447 */       Processor processor = makeProcessor(processFactory);
/* 448 */       if (processor == null) {
/* 449 */         throw new IllegalArgumentException(""No processor created for processBuilder: "" + processFactory);
/*     */       }
/* 451 */       answer.add(processor);
/*     */     } 
/* 453 */     if (answer.size() == 0) {
/* 454 */       return null;
/*     */     }
/* 456 */     Object object = null;
/* 457 */     if (answer.size() == 1) {
/* 458 */       object = answer.get(0);
/*     */     } else {
/*     */       
/* 461 */       object = new CompositeProcessor(answer);
/*     */     } 
/* 463 */     return (Processor)object;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Processor makeProcessor(ProcessorFactory processFactory) throws Exception {
/* 470 */     Processor processor = processFactory.createProcessor();
/* 471 */     processor = wrapProcessor(processor);
/* 472 */     return wrapInErrorHandler(processor);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 481 */   protected Processor wrapInErrorHandler(Processor processor) throws Exception { return getErrorHandlerBuilder().createErrorHandler(processor); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 492 */   protected Processor wrapProcessor(Processor processor) { return processor; }
/*     */ 
/*     */ 
/*     */   
/* 496 */   protected FromBuilder getRouteBuilder() { return this.routeBuilder; }
/*     */ 
/*     */ 
/*     */   
/* 500 */   protected void setRouteBuilder(FromBuilder routeBuilder) { this.routeBuilder = routeBuilder; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\FromBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.IdempotentConsumerBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.idempotent.IdempotentConsumer;
/*    */ import org.apache.camel.processor.idempotent.MessageIdRepository;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class IdempotentConsumerBuilder
/*    */   extends FromBuilder
/*    */   implements ProcessorFactory
/*    */ {
/*    */   private final Expression messageIdExpression;
/*    */   private final MessageIdRepository messageIdRegistry;
/*    */   
/*    */   public IdempotentConsumerBuilder(FromBuilder fromBuilder, Expression messageIdExpression, MessageIdRepository messageIdRegistry) {
/* 36 */     super(fromBuilder);
/* 37 */     this.messageIdRegistry = messageIdRegistry;
/* 38 */     this.messageIdExpression = messageIdExpression;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   public MessageIdRepository getMessageIdRegistry() { return this.messageIdRegistry; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 52 */   protected Processor wrapInErrorHandler(Processor processor) throws Exception { return processor; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 57 */   protected Processor wrapProcessor(Processor processor) { return (Processor)new IdempotentConsumer(this.messageIdExpression, this.messageIdRegistry, processor); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\IdempotentConsumerBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.InterceptorBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import java.util.ArrayList;
/*    */ import java.util.List;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.RuntimeCamelException;
/*    */ import org.apache.camel.processor.DelegateProcessor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class InterceptorBuilder
/*    */   implements ProcessorFactory
/*    */ {
/* 32 */   private final List<DelegateProcessor> intercepts = new ArrayList<DelegateProcessor>();
/*    */   
/*    */   private final FromBuilder parent;
/*    */   private FromBuilder target;
/*    */   
/* 37 */   public InterceptorBuilder(FromBuilder parent) { this.parent = parent; }
/*    */ 
/*    */   
/*    */   @Fluent(""interceptor"")
/*    */   public InterceptorBuilder add(@FluentArg(""ref"") DelegateProcessor interceptor) {
/* 42 */     this.intercepts.add(interceptor);
/* 43 */     return this;
/*    */   }
/*    */   
/*    */   @Fluent(callOnElementEnd = true)
/*    */   public FromBuilder target() {
/* 48 */     this.target = new FromBuilder(this.parent);
/* 49 */     return this.target;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public Processor createProcessor() throws Exception {
/* 55 */     if (this.target == null) {
/* 56 */       throw new RuntimeCamelException(""target provided."");
/*    */     }
/*    */     
/* 59 */     DelegateProcessor first = null;
/* 60 */     DelegateProcessor last = null;
/* 61 */     for (DelegateProcessor p : this.intercepts) {
/* 62 */       if (first == null) {
/* 63 */         first = p;
/*    */       }
/* 65 */       if (last != null) {
/* 66 */         last.setNext((Processor)p);
/*    */       }
/* 68 */       last = p;
/*    */     } 
/*    */     
/* 71 */     Processor p = this.target.createProcessor();
/* 72 */     if (last != null) {
/* 73 */       last.setNext(p);
/*    */     }
/* 75 */     return (first == null) ? p : (Processor)first;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\InterceptorBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.LoggingErrorHandlerBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.Logger;
/*    */ import org.apache.camel.processor.LoggingErrorHandler;
/*    */ import org.apache.camel.processor.LoggingLevel;
/*    */ import org.apache.commons.logging.Log;
/*    */ import org.apache.commons.logging.LogFactory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LoggingErrorHandlerBuilder
/*    */   implements ErrorHandlerBuilder
/*    */ {
/* 34 */   private Log log = LogFactory.getLog(Logger.class);
/* 35 */   private LoggingLevel level = LoggingLevel.INFO;
/*    */ 
/*    */   
/*    */   public LoggingErrorHandlerBuilder() {}
/*    */ 
/*    */   
/* 41 */   public LoggingErrorHandlerBuilder(Log log) { this.log = log; }
/*    */ 
/*    */   
/*    */   public LoggingErrorHandlerBuilder(Log log, LoggingLevel level) {
/* 45 */     this.log = log;
/* 46 */     this.level = level;
/*    */   }
/*    */   
/*    */   public ErrorHandlerBuilder copy() {
/* 50 */     LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder();
/* 51 */     answer.setLog(getLog());
/* 52 */     answer.setLevel(getLevel());
/* 53 */     return answer;
/*    */   }
/*    */ 
/*    */   
/* 57 */   public Processor createErrorHandler(Processor processor) { return (Processor)new LoggingErrorHandler(processor, this.log, this.level); }
/*    */ 
/*    */ 
/*    */   
/* 61 */   public LoggingLevel getLevel() { return this.level; }
/*    */ 
/*    */ 
/*    */   
/* 65 */   public void setLevel(LoggingLevel level) { this.level = level; }
/*    */ 
/*    */ 
/*    */   
/* 69 */   public Log getLog() { return this.log; }
/*    */ 
/*    */ 
/*    */   
/* 73 */   public void setLog(Log log) { this.log = log; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\LoggingErrorHandlerBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.MulticastBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import java.util.Collection;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.MulticastProcessor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class MulticastBuilder
/*    */   extends FromBuilder
/*    */ {
/*    */   private final Collection<Endpoint> endpoints;
/*    */   
/*    */   public MulticastBuilder(FromBuilder parent, Collection<Endpoint> endpoints) {
/* 36 */     super(parent);
/* 37 */     this.endpoints = endpoints;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Processor createProcessor() throws Exception { return (Processor)new MulticastProcessor(this.endpoints); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\MulticastBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.NoErrorHandlerBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoErrorHandlerBuilder<E extends Exchange>
/*    */   implements ErrorHandlerBuilder<E>
/*    */ {
/* 34 */   public ErrorHandlerBuilder<E> copy() { return this; }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public Processor createErrorHandler(Processor processor) { return processor; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\NoErrorHandlerBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.PipelineBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import java.util.Collection;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.Pipeline;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PipelineBuilder
/*    */   extends FromBuilder
/*    */ {
/*    */   private final Collection<Endpoint> endpoints;
/*    */   
/*    */   public PipelineBuilder(FromBuilder parent, Collection<Endpoint> endpoints) {
/* 36 */     super(parent);
/* 37 */     this.endpoints = endpoints;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Processor createProcessor() throws Exception { return (Processor)new Pipeline(this.endpoints); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\PipelineBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.PolicyBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import java.util.ArrayList;
/*    */ import java.util.Collections;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.RuntimeCamelException;
/*    */ import org.apache.camel.spi.Policy;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PolicyBuilder
/*    */   implements ProcessorFactory
/*    */ {
/* 32 */   private final ArrayList<Policy> policies = new ArrayList<Policy>();
/*    */   
/*    */   private final FromBuilder parent;
/*    */   private FromBuilder target;
/*    */   
/* 37 */   public PolicyBuilder(FromBuilder parent) { this.parent = parent; }
/*    */ 
/*    */   
/*    */   @Fluent(""policy"")
/*    */   public PolicyBuilder add(@FluentArg(""ref"") Policy interceptor) {
/* 42 */     this.policies.add(interceptor);
/* 43 */     return this;
/*    */   }
/*    */   
/*    */   @Fluent(callOnElementEnd = true)
/*    */   public FromBuilder target() {
/* 48 */     this.target = new FromBuilder(this.parent);
/* 49 */     return this.target;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public Processor createProcessor() throws Exception {
/* 55 */     if (this.target == null) {
/* 56 */       throw new RuntimeCamelException(""target not provided."");
/*    */     }
/* 58 */     Processor last = this.target.createProcessor();
/* 59 */     Collections.reverse(this.policies);
/* 60 */     for (Policy p : this.policies) {
/* 61 */       last = p.wrap(last);
/*    */     }
/*    */     
/* 64 */     return last;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\PolicyBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.PredicateBuilder,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import java.util.regex.Matcher;
/*     */ import java.util.regex.Pattern;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Predicate;
/*     */ import org.apache.camel.impl.BinaryPredicateSupport;
/*     */ import org.apache.camel.impl.PredicateSupport;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class PredicateBuilder
/*     */ {
/*     */   public static <E extends Exchange> Predicate<E> and(final Predicate<E> left, final Predicate<E> right) {
/*  41 */     ObjectHelper.notNull(left, ""left"");
/*  42 */     ObjectHelper.notNull(right, ""right"");
/*  43 */     return (Predicate<E>)new PredicateSupport<E>()
/*     */       {
/*  45 */         public boolean matches(E exchange) { return (left.matches(exchange) && right.matches(exchange)); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*  50 */         public String toString() { return ""("" + left + "") and ("" + right + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> or(final Predicate<E> left, final Predicate<E> right) {
/*  59 */     ObjectHelper.notNull(left, ""left"");
/*  60 */     ObjectHelper.notNull(right, ""right"");
/*  61 */     return (Predicate<E>)new PredicateSupport<E>()
/*     */       {
/*  63 */         public boolean matches(E exchange) { return (left.matches(exchange) || right.matches(exchange)); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*  68 */         public String toString() { return ""("" + left + "") or ("" + right + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> isEqualTo(Expression<E> left, Expression<E> right) {
/*  74 */     return (Predicate<E>)new BinaryPredicateSupport<E>(left, right)
/*     */       {
/*     */         protected boolean matches(E exchange, Object leftValue, Object rightValue) {
/*  77 */           return ObjectHelper.equals(leftValue, rightValue);
/*     */         }
/*     */ 
/*     */         
/*  81 */         protected String getOperationText() { return ""==""; }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> isNotEqualTo(Expression<E> left, Expression<E> right) {
/*  87 */     return (Predicate<E>)new BinaryPredicateSupport<E>(left, right)
/*     */       {
/*     */         protected boolean matches(E exchange, Object leftValue, Object rightValue) {
/*  90 */           return !ObjectHelper.equals(leftValue, rightValue);
/*     */         }
/*     */ 
/*     */         
/*  94 */         protected String getOperationText() { return ""==""; }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> isLessThan(Expression<E> left, Expression<E> right) {
/* 100 */     return (Predicate<E>)new BinaryPredicateSupport<E>(left, right)
/*     */       {
/*     */         protected boolean matches(E exchange, Object leftValue, Object rightValue) {
/* 103 */           return (ObjectHelper.compare(leftValue, rightValue) < 0);
/*     */         }
/*     */ 
/*     */         
/* 107 */         protected String getOperationText() { return ""<""; }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> isLessThanOrEqualTo(Expression<E> left, Expression<E> right) {
/* 113 */     return (Predicate<E>)new BinaryPredicateSupport<E>(left, right)
/*     */       {
/*     */         protected boolean matches(E exchange, Object leftValue, Object rightValue) {
/* 116 */           return (ObjectHelper.compare(leftValue, rightValue) <= 0);
/*     */         }
/*     */ 
/*     */         
/* 120 */         protected String getOperationText() { return ""<=""; }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> isGreaterThan(Expression<E> left, Expression<E> right) {
/* 126 */     return (Predicate<E>)new BinaryPredicateSupport<E>(left, right)
/*     */       {
/*     */         protected boolean matches(E exchange, Object leftValue, Object rightValue) {
/* 129 */           return (ObjectHelper.compare(leftValue, rightValue) > 0);
/*     */         }
/*     */ 
/*     */         
/* 133 */         protected String getOperationText() { return "">""; }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> isGreaterThanOrEqualTo(Expression<E> left, Expression<E> right) {
/* 139 */     return (Predicate<E>)new BinaryPredicateSupport<E>(left, right)
/*     */       {
/*     */         protected boolean matches(E exchange, Object leftValue, Object rightValue) {
/* 142 */           return (ObjectHelper.compare(leftValue, rightValue) < 0);
/*     */         }
/*     */ 
/*     */         
/* 146 */         protected String getOperationText() { return "">=""; }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> contains(Expression<E> left, Expression<E> right) {
/* 152 */     return (Predicate<E>)new BinaryPredicateSupport<E>(left, right)
/*     */       {
/*     */         protected boolean matches(E exchange, Object leftValue, Object rightValue) {
/* 155 */           return ObjectHelper.contains(leftValue, rightValue);
/*     */         }
/*     */ 
/*     */         
/* 159 */         protected String getOperationText() { return ""contains""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 165 */   public static <E extends Exchange> Predicate<E> isNull(Expression<E> expression) { return isEqualTo(expression, ExpressionBuilder.constantExpression(null)); }
/*     */ 
/*     */ 
/*     */   
/* 169 */   public static <E extends Exchange> Predicate<E> isNotNull(Expression<E> expression) { return isNotEqualTo(expression, ExpressionBuilder.constantExpression(null)); }
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> isInstanceOf(final Expression<E> expression, final Class type) {
/* 173 */     ObjectHelper.notNull(expression, ""expression"");
/* 174 */     ObjectHelper.notNull(type, ""type"");
/*     */     
/* 176 */     return (Predicate<E>)new PredicateSupport<E>() {
/*     */         public boolean matches(E exchange) {
/* 178 */           Object value = expression.evaluate((Exchange)exchange);
/* 179 */           return type.isInstance(value);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 184 */         public String toString() { return expression + "" instanceof "" + type.getName(); }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 189 */         protected String assertionFailureMessage(E exchange) { return super.assertionFailureMessage((Exchange)exchange) + "" for <"" + expression.evaluate((Exchange)exchange) + "">""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 203 */   public static <E extends Exchange> Predicate<E> regex(Expression<E> expression, String regex) { return regex(expression, Pattern.compile(regex)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression, final Pattern pattern) {
/* 214 */     ObjectHelper.notNull(expression, ""expression"");
/* 215 */     ObjectHelper.notNull(pattern, ""pattern"");
/*     */     
/* 217 */     return (Predicate<E>)new PredicateSupport<E>() {
/*     */         public boolean matches(E exchange) {
/* 219 */           Object value = expression.evaluate((Exchange)exchange);
/* 220 */           if (value != null) {
/* 221 */             Matcher matcher = pattern.matcher(value.toString());
/* 222 */             return matcher.matches();
/*     */           } 
/* 224 */           return false;
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 229 */         public String toString() { return expression + "".matches("" + pattern + "")""; }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 234 */         protected String assertionFailureMessage(E exchange) { return super.assertionFailureMessage((Exchange)exchange) + "" for <"" + expression.evaluate((Exchange)exchange) + "">""; }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\PredicateBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.PredicateFactory,"package org.apache.camel.builder;
import org.apache.camel.Predicate;
public interface PredicateFactory<E extends org.apache.camel.Exchange> {
  Predicate<E> createPredicate();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\PredicateFactory.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ProcessorBuilder,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Processor;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ProcessorBuilder
/*     */ {
/*     */   public static Processor setBody(final Expression expression) {
/*  35 */     return new Processor() {
/*     */         public void process(Exchange exchange) {
/*  37 */           Object newBody = expression.evaluate(exchange);
/*  38 */           exchange.getIn().setBody(newBody);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/*  43 */         public String toString() { return ""setBody("" + expression + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Processor setOutBody(final Expression expression) {
/*  52 */     return new Processor() {
/*     */         public void process(Exchange exchange) {
/*  54 */           Object newBody = expression.evaluate(exchange);
/*  55 */           exchange.getOut().setBody(newBody);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/*  60 */         public String toString() { return ""setOutBody("" + expression + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Processor setHeader(final String name, final Expression expression) {
/*  69 */     return new Processor() {
/*     */         public void process(Exchange exchange) {
/*  71 */           Object value = expression.evaluate(exchange);
/*  72 */           exchange.getIn().setHeader(name, value);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/*  77 */         public String toString() { return ""setHeader("" + name + "", "" + expression + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Processor setOutHeader(final String name, final Expression expression) {
/*  86 */     return new Processor() {
/*     */         public void process(Exchange exchange) {
/*  88 */           Object value = expression.evaluate(exchange);
/*  89 */           exchange.getOut().setHeader(name, value);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/*  94 */         public String toString() { return ""setOutHeader("" + name + "", "" + expression + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Processor setProperty(final String name, final Expression expression) {
/* 103 */     return new Processor() {
/*     */         public void process(Exchange exchange) {
/* 105 */           Object value = expression.evaluate(exchange);
/* 106 */           exchange.setProperty(name, value);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 111 */         public String toString() { return ""setProperty("" + name + "", "" + expression + "")""; }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ProcessorBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ProcessorFactory,"package org.apache.camel.builder;
import org.apache.camel.Processor;
public interface ProcessorFactory {
  Processor createProcessor() throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ProcessorFactory.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.RecipientListBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.RecipientList;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RecipientListBuilder<E extends Exchange>
/*    */   extends BuilderSupport
/*    */   implements ProcessorFactory
/*    */ {
/*    */   private final Expression expression;
/*    */   
/*    */   public RecipientListBuilder(FromBuilder parent, Expression expression) {
/* 35 */     super(parent);
/* 36 */     this.expression = expression;
/*    */   }
/*    */ 
/*    */   
/* 40 */   public Processor createProcessor() { return (Processor)new RecipientList(this.expression); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\RecipientListBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ResequencerBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import java.util.List;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Route;
/*    */ import org.apache.camel.Service;
/*    */ import org.apache.camel.processor.Resequencer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ResequencerBuilder
/*    */   extends FromBuilder
/*    */ {
/*    */   private final List<Expression<Exchange>> expressions;
/* 34 */   private long batchTimeout = 1000L;
/* 35 */   private int batchSize = 100;
/*    */   
/*    */   public ResequencerBuilder(FromBuilder builder, List<Expression<Exchange>> expressions) {
/* 38 */     super(builder);
/* 39 */     this.expressions = expressions;
/*    */   }
/*    */ 
/*    */   
/*    */   public Route createRoute() throws Exception {
/* 44 */     final Processor processor = createProcessor();
/* 45 */     final Resequencer resequencer = new Resequencer(getFrom(), processor, this.expressions);
/*    */     
/* 47 */     return new Route<Exchange>(getFrom())
/*    */       {
/* 49 */         protected void addServices(List<Service> list) throws Exception { list.add(resequencer); }
/*    */ 
/*    */ 
/*    */ 
/*    */         
/* 54 */         public String toString() { return ""ResequencerRoute["" + getEndpoint() + "" -> "" + processor + ""]""; }
/*    */       };
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public ResequencerBuilder batchSize(int batchSize) {
/* 62 */     setBatchSize(batchSize);
/* 63 */     return this;
/*    */   }
/*    */   
/*    */   public ResequencerBuilder batchTimeout(int batchTimeout) {
/* 67 */     setBatchTimeout(batchTimeout);
/* 68 */     return this;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 74 */   public int getBatchSize() { return this.batchSize; }
/*    */ 
/*    */ 
/*    */   
/* 78 */   public void setBatchSize(int batchSize) { this.batchSize = batchSize; }
/*    */ 
/*    */ 
/*    */   
/* 82 */   public long getBatchTimeout() { return this.batchTimeout; }
/*    */ 
/*    */ 
/*    */   
/* 86 */   public void setBatchTimeout(long batchTimeout) { this.batchTimeout = batchTimeout; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ResequencerBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.RouteBuilder,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import java.util.concurrent.atomic.AtomicBoolean;
/*     */ import org.apache.camel.CamelContext;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Route;
/*     */ import org.apache.camel.impl.DefaultCamelContext;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class RouteBuilder
/*     */   extends BuilderSupport
/*     */ {
/*  37 */   private List<FromBuilder> fromBuilders = new ArrayList<FromBuilder>();
/*  38 */   private AtomicBoolean initalized = new AtomicBoolean(false);
/*  39 */   private List<Route> routes = new ArrayList<Route>();
/*     */ 
/*     */   
/*  42 */   protected RouteBuilder() { this(null); }
/*     */ 
/*     */ 
/*     */   
/*  46 */   protected RouteBuilder(CamelContext context) { super(context); }
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void configure() throws Exception;
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder from(@FluentArg(""uri"") String uri) {
/*  56 */     if (uri == null) {
/*  57 */       throw new IllegalArgumentException(""uri parameter cannot be null"");
/*     */     }
/*  59 */     Endpoint endpoint = endpoint(uri);
/*  60 */     if (endpoint == null) {
/*  61 */       throw new IllegalArgumentException(""uri '"" + uri + ""' could not be resolved."");
/*     */     }
/*  63 */     return from(endpoint);
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public FromBuilder from(@FluentArg(""ref"") Endpoint endpoint) {
/*  68 */     FromBuilder answer = new FromBuilder(this, endpoint);
/*  69 */     addFromBuilder(answer);
/*  70 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
/*  80 */     setErrorHandlerBuilder(errorHandlerBuilder);
/*  81 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RouteBuilder inheritErrorHandler(boolean value) {
/*  91 */     setInheritErrorHandler(value);
/*  92 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public CamelContext getContext() {
/*  98 */     CamelContext context = super.getContext();
/*  99 */     if (context == null) {
/* 100 */       context = createContainer();
/* 101 */       setContext(context);
/*     */     } 
/* 103 */     return context;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public List<Route> getRouteList() throws Exception {
/* 110 */     checkInitialized();
/* 111 */     return this.routes;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public List<FromBuilder> getFromBuilders() throws Exception {
/* 118 */     checkInitialized();
/* 119 */     return this.fromBuilders;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 125 */   public void addFromBuilder(FromBuilder answer) { this.fromBuilders.add(answer); }
/*     */ 
/*     */   
/*     */   protected void checkInitialized() throws Exception {
/* 129 */     if (this.initalized.compareAndSet(false, true)) {
/* 130 */       configure();
/* 131 */       populateRoutes(this.routes);
/*     */     } 
/*     */   }
/*     */   
/*     */   protected void populateRoutes(List<Route> routes) throws Exception {
/* 136 */     for (FromBuilder builder : this.fromBuilders) {
/* 137 */       Route route = builder.createRoute();
/* 138 */       routes.add(route);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 146 */   protected CamelContext createContainer() { return (CamelContext)new DefaultCamelContext(); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\RouteBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.SplitterBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.Splitter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SplitterBuilder
/*    */   extends FromBuilder
/*    */ {
/*    */   private final Expression expression;
/*    */   
/*    */   public SplitterBuilder(FromBuilder parent, Expression expression) {
/* 35 */     super(parent);
/* 36 */     this.expression = expression;
/*    */   }
/*    */ 
/*    */   
/*    */   public Processor createProcessor() throws Exception {
/* 41 */     Processor destination = super.createProcessor();
/* 42 */     return (Processor)new Splitter(destination, this.expression);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\SplitterBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ToBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.processor.SendProcessor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ToBuilder<E extends Exchange>
/*    */   extends FromBuilder
/*    */ {
/*    */   private Endpoint destination;
/*    */   
/*    */   public ToBuilder(FromBuilder parent, Endpoint endpoint) {
/* 32 */     super(parent);
/* 33 */     this.destination = endpoint;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public Processor createProcessor() { return (Processor)new SendProcessor(this.destination); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ToBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.UndefinedDestinationException,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.RuntimeCamelException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class UndefinedDestinationException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private static final long serialVersionUID = -5980888207885995222L;
/*    */   
/* 29 */   public UndefinedDestinationException() { super(""No destination defined for this routing rule""); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\UndefinedDestinationException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.ValueBuilder,"/*     */ package org.apache.camel.builder;
/*     */ 
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Predicate;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ValueBuilder<E extends Exchange>
/*     */   implements Expression<E>
/*     */ {
/*     */   private Expression<E> expression;
/*     */   
/*  32 */   public ValueBuilder(Expression<E> expression) { this.expression = expression; }
/*     */ 
/*     */ 
/*     */   
/*  36 */   public Object evaluate(E exchange) { return this.expression.evaluate((Exchange)exchange); }
/*     */ 
/*     */ 
/*     */   
/*  40 */   public Expression<E> getExpression() { return this.expression; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  45 */   public String toString() { return this.expression.toString(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public Predicate<E> isNotEqualTo(@FluentArg(""value"") Object value) {
/*  53 */     Expression<E> right = asExpression(value);
/*  54 */     return onNewPredicate(PredicateBuilder.isNotEqualTo(this.expression, right));
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public Predicate<E> isEqualTo(@FluentArg(""value"") Object value) {
/*  59 */     Expression<E> right = asExpression(value);
/*  60 */     return onNewPredicate(PredicateBuilder.isEqualTo(this.expression, right));
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public Predicate<E> isLessThan(@FluentArg(""value"") Object value) {
/*  65 */     Expression<E> right = asExpression(value);
/*  66 */     return onNewPredicate(PredicateBuilder.isLessThan(this.expression, right));
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public Predicate<E> isLessThanOrEqualTo(@FluentArg(""value"") Object value) {
/*  71 */     Expression<E> right = asExpression(value);
/*  72 */     return onNewPredicate(PredicateBuilder.isLessThanOrEqualTo(this.expression, right));
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public Predicate<E> isGreaterThan(@FluentArg(""value"") Object value) {
/*  77 */     Expression<E> right = asExpression(value);
/*  78 */     return onNewPredicate(PredicateBuilder.isGreaterThan(this.expression, right));
/*     */   }
/*     */   
/*     */   @Fluent
/*     */   public Predicate<E> isGreaterThanOrEqualTo(@FluentArg(""value"") Object value) {
/*  83 */     Expression<E> right = asExpression(value);
/*  84 */     return onNewPredicate(PredicateBuilder.isGreaterThanOrEqualTo(this.expression, right));
/*     */   }
/*     */ 
/*     */   
/*     */   @Fluent
/*  89 */   public Predicate<E> isInstanceOf(@FluentArg(""class"") Class type) { return onNewPredicate(PredicateBuilder.isInstanceOf(this.expression, type)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  94 */   public Predicate<E> matchesRegex(@FluentArg(""regex"") String regex) { return onNewPredicate(PredicateBuilder.regex(this.expression, regex)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*  99 */   public Predicate<E> isNull() { return onNewPredicate(PredicateBuilder.isNull(this.expression)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 104 */   public Predicate<E> isNotNull() { return onNewPredicate(PredicateBuilder.isNotNull(this.expression)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public Predicate<E> contains(@FluentArg(""value"") Object value) {
/* 116 */     Expression<E> right = asExpression(value);
/* 117 */     return onNewPredicate(PredicateBuilder.contains(this.expression, right));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 129 */   public Predicate<E> regex(String regex) { return onNewPredicate(PredicateBuilder.regex(this.expression, regex)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 138 */   public ValueBuilder<E> tokenize() { return tokenize(""\n""); }
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ValueBuilder<E> tokenize(@FluentArg(""token"") String token) {
/* 143 */     Expression<E> newExp = ExpressionBuilder.tokenizeExpression(this.expression, token);
/* 144 */     return new ValueBuilder(newExp);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ValueBuilder<E> regexTokenize(@FluentArg(""regex"") String regex) {
/* 152 */     Expression<E> newExp = ExpressionBuilder.regexTokenize(this.expression, regex);
/* 153 */     return new ValueBuilder(newExp);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ValueBuilder<E> regexReplaceAll(@FluentArg(""regex"") String regex, @FluentArg(""replacement"") String replacement) {
/* 161 */     Expression<E> newExp = ExpressionBuilder.regexReplaceAll(this.expression, regex, replacement);
/* 162 */     return new ValueBuilder(newExp);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ValueBuilder<E> regexReplaceAll(@FluentArg(""regex"") String regex, @FluentArg(""replacement"") Expression<E> replacement) {
/* 170 */     Expression<E> newExp = ExpressionBuilder.regexReplaceAll(this.expression, regex, replacement);
/* 171 */     return new ValueBuilder(newExp);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ValueBuilder<E> convertTo(@FluentArg(""type"") Class type) {
/* 183 */     Expression<E> newExp = ExpressionBuilder.convertTo(this.expression, type);
/* 184 */     return new ValueBuilder(newExp);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 194 */   public ValueBuilder<E> convertToString() { return convertTo(String.class); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/* 204 */   public ValueBuilder<E> append(@FluentArg(""value"") Object value) { return new ValueBuilder(ExpressionBuilder.append(this.expression, asExpression(value))); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 216 */   protected Predicate<E> onNewPredicate(Predicate<E> predicate) { return predicate; }
/*     */ 
/*     */   
/*     */   protected Expression<E> asExpression(Object value) {
/* 220 */     if (value instanceof Expression) {
/* 221 */       return (Expression<E>)value;
/*     */     }
/*     */     
/* 224 */     return ExpressionBuilder.constantExpression(value);
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\ValueBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.WhenBuilder,"/*    */ package org.apache.camel.builder;
/*    */ 
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Predicate;
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class WhenBuilder
/*    */   extends FilterBuilder
/*    */ {
/*    */   private final ChoiceBuilder parent;
/*    */   
/*    */   public WhenBuilder(ChoiceBuilder parent, Predicate predicate) {
/* 31 */     super(parent, predicate);
/* 32 */     this.parent = parent;
/*    */   }
/*    */ 
/*    */   
/*    */   @Fluent
/*    */   public ChoiceBuilder to(@FluentArg(""ref"") Endpoint endpoint) {
/* 38 */     super.to(endpoint);
/* 39 */     return this.parent;
/*    */   }
/*    */ 
/*    */   
/*    */   @Fluent
/*    */   public ChoiceBuilder to(@FluentArg(""uri"") String uri) {
/* 45 */     super.to(uri);
/* 46 */     return this.parent;
/*    */   }
/*    */ 
/*    */   
/*    */   @Fluent
/*    */   public ChoiceBuilder process(@FluentArg(""ref"") Processor processor) {
/* 52 */     super.process(processor);
/* 53 */     return this.parent;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\WhenBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.DefaultNamespaceContext,"/*     */ package org.apache.camel.builder.xml;
/*     */ 
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import javax.xml.namespace.NamespaceContext;
/*     */ import javax.xml.xpath.XPathFactory;
/*     */ import org.w3c.dom.Attr;
/*     */ import org.w3c.dom.Element;
/*     */ import org.w3c.dom.NamedNodeMap;
/*     */ import org.w3c.dom.Node;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DefaultNamespaceContext
/*     */   implements NamespaceContext
/*     */ {
/*     */   private final Map map;
/*     */   private final NamespaceContext parent;
/*     */   
/*  45 */   public DefaultNamespaceContext() { this(XPathFactory.newInstance()); }
/*     */ 
/*     */   
/*     */   public DefaultNamespaceContext(XPathFactory factory) {
/*  49 */     this.parent = factory.newXPath().getNamespaceContext();
/*  50 */     this.map = new HashMap<Object, Object>();
/*     */   }
/*     */   
/*     */   public DefaultNamespaceContext(NamespaceContext parent, Map map) {
/*  54 */     this.parent = parent;
/*  55 */     this.map = map;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DefaultNamespaceContext add(String prefix, String uri) {
/*  62 */     this.map.put(prefix, uri);
/*  63 */     return this;
/*     */   }
/*     */   
/*     */   public String getNamespaceURI(String prefix) {
/*  67 */     String answer = (String)this.map.get(prefix);
/*  68 */     if (answer == null && this.parent != null) {
/*  69 */       return this.parent.getNamespaceURI(prefix);
/*     */     }
/*  71 */     return answer;
/*     */   }
/*     */   
/*     */   public String getPrefix(String namespaceURI) {
/*  75 */     for (Iterator<Map.Entry> iter = this.map.entrySet().iterator(); iter.hasNext(); ) {
/*  76 */       Map.Entry entry = iter.next();
/*  77 */       if (namespaceURI.equals(entry.getValue())) {
/*  78 */         return (String)entry.getKey();
/*     */       }
/*     */     } 
/*  81 */     if (this.parent != null) {
/*  82 */       return this.parent.getPrefix(namespaceURI);
/*     */     }
/*  84 */     return null;
/*     */   }
/*     */   
/*     */   public Iterator getPrefixes(String namespaceURI) {
/*  88 */     Set set = new HashSet();
/*  89 */     for (Iterator<Map.Entry> iter = this.map.entrySet().iterator(); iter.hasNext(); ) {
/*  90 */       Map.Entry entry = iter.next();
/*  91 */       if (namespaceURI.equals(entry.getValue())) {
/*  92 */         set.add(entry.getKey());
/*     */       }
/*     */     } 
/*  95 */     if (this.parent != null) {
/*  96 */       Iterator iter = this.parent.getPrefixes(namespaceURI);
/*  97 */       while (iter.hasNext()) {
/*  98 */         set.add(iter.next());
/*     */       }
/*     */     } 
/* 101 */     return set.iterator();
/*     */   }
/*     */ 
/*     */   
/*     */   public void setNamespacesFromDom(Element element) {
/* 106 */     Node parentNode = element.getParentNode();
/* 107 */     if (parentNode instanceof Element) {
/* 108 */       setNamespacesFromDom((Element)parentNode);
/*     */     }
/* 110 */     NamedNodeMap attributes = element.getAttributes();
/* 111 */     for (int i = 0, size = attributes.getLength(); i < size; i++) {
/* 112 */       Attr node = (Attr)attributes.item(i);
/* 113 */       String name = node.getName();
/* 114 */       if (name.startsWith(""xmlns:"")) {
/* 115 */         String prefix = name.substring(""xmlns:"".length());
/* 116 */         String uri = node.getValue();
/* 117 */         add(prefix, uri);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\DefaultNamespaceContext.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.DomResultHandler,"/*    */ package org.apache.camel.builder.xml;
/*    */ 
/*    */ import javax.xml.transform.Result;
/*    */ import javax.xml.transform.dom.DOMResult;
/*    */ import org.apache.camel.Message;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DomResultHandler
/*    */   implements ResultHandler
/*    */ {
/* 31 */   private DOMResult result = new DOMResult();
/*    */ 
/*    */   
/* 34 */   public Result getResult() { return this.result; }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public void setBody(Message in) { in.setBody(this.result.getNode()); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\DomResultHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.InvalidXPathExpression,"/*    */ package org.apache.camel.builder.xml;
/*    */ 
/*    */ import javax.xml.xpath.XPathException;
/*    */ import org.apache.camel.RuntimeExpressionException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class InvalidXPathExpression
/*    */   extends RuntimeExpressionException
/*    */ {
/*    */   private final String xpath;
/*    */   
/*    */   public InvalidXPathExpression(String xpath, XPathException e) {
/* 33 */     super(""Invalid xpath: "" + xpath + "". Reason: "" + e, e);
/* 34 */     this.xpath = xpath;
/*    */   }
/*    */ 
/*    */   
/* 38 */   public String getXpath() { return this.xpath; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\InvalidXPathExpression.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.MessageVariableResolver,"/*    */ package org.apache.camel.builder.xml;
/*    */ 
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ import javax.xml.namespace.QName;
/*    */ import javax.xml.xpath.XPathVariableResolver;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Message;
/*    */ import org.apache.commons.logging.Log;
/*    */ import org.apache.commons.logging.LogFactory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class MessageVariableResolver
/*    */   implements XPathVariableResolver
/*    */ {
/*    */   public static final String SYSTEM_PROPERTIES_NAMESPACE = ""http://camel.apache.org/xml/variables/system-properties"";
/*    */   public static final String ENVIRONMENT_VARIABLES = ""http://camel.apache.org/xml/variables/environment-variables"";
/*    */   public static final String EXCHANGE_PROPERTY = ""http://camel.apache.org/xml/variables/exchange-property"";
/*    */   public static final String IN_HEADER = ""http://camel.apache.org/xml/variables/in-header"";
/*    */   public static final String OUT_HEADER = ""http://camel.apache.org/xml/variables/out-header"";
/* 43 */   private static final transient Log log = LogFactory.getLog(MessageVariableResolver.class);
/*    */   
/*    */   private Exchange exchange;
/* 46 */   private Map<String, Object> variables = new HashMap<String, Object>();
/*    */ 
/*    */   
/* 49 */   public Exchange getExchange() { return this.exchange; }
/*    */ 
/*    */ 
/*    */   
/* 53 */   public void setExchange(Exchange exchange) { this.exchange = exchange; }
/*    */ 
/*    */   
/*    */   public Object resolveVariable(QName name) {
/* 57 */     String uri = name.getNamespaceURI();
/* 58 */     String localPart = name.getLocalPart();
/* 59 */     Object answer = null;
/*    */     
/* 61 */     if (uri == null || uri.length() == 0) {
/* 62 */       answer = this.variables.get(localPart);
/* 63 */       if (answer == null) {
/* 64 */         Message message = this.exchange.getIn();
/* 65 */         if (message != null) {
/* 66 */           answer = message.getHeader(localPart);
/*    */         }
/* 68 */         if (answer == null) {
/* 69 */           answer = this.exchange.getProperty(localPart);
/*    */         }
/*    */       }
/*    */     
/* 73 */     } else if (uri.equals(""http://camel.apache.org/xml/variables/system-properties"")) {
/*    */       try {
/* 75 */         answer = System.getProperty(localPart);
/*    */       }
/* 77 */       catch (Exception e) {
/* 78 */         log.debug(""Security exception evaluating system property: "" + localPart + "". Reason: "" + e, e);
/*    */       }
/*    */     
/* 81 */     } else if (uri.equals(""http://camel.apache.org/xml/variables/environment-variables"")) {
/* 82 */       answer = System.getenv().get(localPart);
/*    */     }
/* 84 */     else if (uri.equals(""http://camel.apache.org/xml/variables/exchange-property"")) {
/* 85 */       answer = this.exchange.getProperty(localPart);
/*    */     }
/* 87 */     else if (uri.equals(""http://camel.apache.org/xml/variables/in-header"")) {
/* 88 */       answer = this.exchange.getIn().getHeader(localPart);
/*    */     }
/* 90 */     else if (uri.equals(""http://camel.apache.org/xml/variables/out-header"")) {
/* 91 */       answer = this.exchange.getOut().getHeader(localPart);
/*    */     } 
/*    */ 
/*    */     
/* 95 */     return answer;
/*    */   }
/*    */ 
/*    */   
/* 99 */   public void addVariable(String localPart, Object value) { this.variables.put(localPart, value); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\MessageVariableResolver.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.NamespaceBuilder,"/*    */ package org.apache.camel.builder.xml;
/*    */ 
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ import java.util.Set;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NamespaceBuilder
/*    */ {
/* 30 */   private Map<String, String> namespaces = new HashMap<String, String>();
/*    */ 
/*    */   
/* 33 */   public static NamespaceBuilder namespaceContext() { return new NamespaceBuilder(); }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public static NamespaceBuilder namespaceContext(String prefix, String uri) { return (new NamespaceBuilder()).namespace(prefix, uri); }
/*    */ 
/*    */   
/*    */   public NamespaceBuilder namespace(String prefix, String uri) {
/* 41 */     this.namespaces.put(prefix, uri);
/* 42 */     return this;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public XPathBuilder xpath(String xpath) {
/* 52 */     XPathBuilder answer = XPathBuilder.xpath(xpath);
/* 53 */     Set<Map.Entry<String, String>> entries = this.namespaces.entrySet();
/* 54 */     for (Map.Entry<String, String> entry : entries) {
/* 55 */       answer.namespace(entry.getKey(), entry.getValue());
/*    */     }
/* 57 */     return answer;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\NamespaceBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.ResultHandler,"package org.apache.camel.builder.xml;
import javax.xml.transform.Result;
import org.apache.camel.Message;
public interface ResultHandler {
  Result getResult();
  void setBody(Message paramMessage);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\ResultHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.StreamResultHandler,"/*    */ package org.apache.camel.builder.xml;
/*    */ 
/*    */ import java.io.ByteArrayOutputStream;
/*    */ import javax.xml.transform.Result;
/*    */ import javax.xml.transform.stream.StreamResult;
/*    */ import org.apache.camel.Message;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StreamResultHandler
/*    */   implements ResultHandler
/*    */ {
/* 32 */   ByteArrayOutputStream buffer = new ByteArrayOutputStream();
/* 33 */   StreamResult result = new StreamResult(this.buffer);
/*    */ 
/*    */   
/* 36 */   public Result getResult() { return this.result; }
/*    */ 
/*    */ 
/*    */   
/* 40 */   public void setBody(Message in) { in.setBody(this.buffer.toByteArray()); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\StreamResultHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.StringResultHandler,"/*    */ package org.apache.camel.builder.xml;
/*    */ 
/*    */ import java.io.StringWriter;
/*    */ import javax.xml.transform.Result;
/*    */ import javax.xml.transform.stream.StreamResult;
/*    */ import org.apache.camel.Message;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StringResultHandler
/*    */   implements ResultHandler
/*    */ {
/* 32 */   StringWriter buffer = new StringWriter();
/* 33 */   StreamResult result = new StreamResult(this.buffer);
/*    */ 
/*    */   
/* 36 */   public Result getResult() { return this.result; }
/*    */ 
/*    */ 
/*    */   
/* 40 */   public void setBody(Message in) { in.setBody(this.buffer.toString()); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\StringResultHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.XPathBuilder,"/*     */ package org.apache.camel.builder.xml;
/*     */ 
/*     */ import java.io.StringReader;
/*     */ import javax.xml.namespace.QName;
/*     */ import javax.xml.xpath.XPath;
/*     */ import javax.xml.xpath.XPathConstants;
/*     */ import javax.xml.xpath.XPathExpression;
/*     */ import javax.xml.xpath.XPathExpressionException;
/*     */ import javax.xml.xpath.XPathFactory;
/*     */ import javax.xml.xpath.XPathFactoryConfigurationException;
/*     */ import javax.xml.xpath.XPathFunctionResolver;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Message;
/*     */ import org.apache.camel.Predicate;
/*     */ import org.apache.camel.RuntimeExpressionException;
/*     */ import org.apache.camel.converter.ObjectConverter;
/*     */ import org.w3c.dom.Document;
/*     */ import org.w3c.dom.Element;
/*     */ import org.xml.sax.InputSource;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class XPathBuilder<E extends Exchange>
/*     */   implements Expression<E>, Predicate<E>
/*     */ {
/*     */   private final String text;
/*     */   private XPathFactory xpathFactory;
/*  48 */   private Class documentType = Document.class;
/*  49 */   private QName resultType = null;
/*  50 */   private String objectModelUri = null;
/*     */   private DefaultNamespaceContext namespaceContext;
/*     */   private XPathFunctionResolver functionResolver;
/*     */   private XPathExpression expression;
/*  54 */   private MessageVariableResolver variableResolver = new MessageVariableResolver();
/*     */ 
/*     */   
/*  57 */   public static XPathBuilder xpath(String text) { return new XPathBuilder<Exchange>(text); }
/*     */ 
/*     */ 
/*     */   
/*  61 */   public XPathBuilder(String text) { this.text = text; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  66 */   public String toString() { return ""XPath: "" + this.text; }
/*     */ 
/*     */   
/*     */   public boolean matches(E exchange) {
/*  70 */     Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
/*  71 */     return ObjectConverter.toBoolean(booleanResult).booleanValue();
/*     */   }
/*     */   
/*     */   public void assertMatches(String text, E exchange) throws AssertionError {
/*  75 */     Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
/*  76 */     if (!ObjectConverter.toBoolean(booleanResult).booleanValue()) {
/*  77 */       throw new AssertionError(this + "" failed on "" + exchange + "" as returned <"" + booleanResult + "">"");
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*  82 */   public Object evaluate(E exchange) { return evaluateAs(exchange, this.resultType); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> booleanResult() {
/*  95 */     this.resultType = XPathConstants.BOOLEAN;
/*  96 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> nodeResult() {
/* 105 */     this.resultType = XPathConstants.NODE;
/* 106 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> nodeSetResult() {
/* 115 */     this.resultType = XPathConstants.NODESET;
/* 116 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> numberResult() {
/* 125 */     this.resultType = XPathConstants.NUMBER;
/* 126 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> stringResult() {
/* 135 */     this.resultType = XPathConstants.STRING;
/* 136 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> objectModel(String uri) {
/* 145 */     this.objectModelUri = uri;
/* 146 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> functionResolver(XPathFunctionResolver functionResolver) {
/* 155 */     this.functionResolver = functionResolver;
/* 156 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> namespace(String prefix, String uri) {
/* 167 */     getNamespaceContext().add(prefix, uri);
/* 168 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathBuilder<E> variable(String name, Object value) {
/* 175 */     this.variableResolver.addVariable(name, value);
/* 176 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XPathFactory getXPathFactory() throws XPathFactoryConfigurationException {
/* 183 */     if (this.xpathFactory == null) {
/* 184 */       if (this.objectModelUri != null) {
/* 185 */         this.xpathFactory = XPathFactory.newInstance(this.objectModelUri);
/*     */       }
/* 187 */       this.xpathFactory = XPathFactory.newInstance();
/*     */     } 
/* 189 */     return this.xpathFactory;
/*     */   }
/*     */ 
/*     */   
/* 193 */   public void setXPathFactory(XPathFactory xpathFactory) { this.xpathFactory = xpathFactory; }
/*     */ 
/*     */ 
/*     */   
/* 197 */   public Class getDocumentType() { return this.documentType; }
/*     */ 
/*     */ 
/*     */   
/* 201 */   public void setDocumentType(Class documentType) { this.documentType = documentType; }
/*     */ 
/*     */ 
/*     */   
/* 205 */   public String getText() { return this.text; }
/*     */ 
/*     */ 
/*     */   
/* 209 */   public QName getResultType() { return this.resultType; }
/*     */ 
/*     */   
/*     */   public DefaultNamespaceContext getNamespaceContext() {
/* 213 */     if (this.namespaceContext == null) {
/*     */       try {
/* 215 */         this.namespaceContext = new DefaultNamespaceContext(getXPathFactory());
/*     */       }
/* 217 */       catch (XPathFactoryConfigurationException e) {
/* 218 */         throw new RuntimeExpressionException(e);
/*     */       } 
/*     */     }
/* 221 */     return this.namespaceContext;
/*     */   }
/*     */ 
/*     */   
/* 225 */   public void setNamespaceContext(DefaultNamespaceContext namespaceContext) { this.namespaceContext = namespaceContext; }
/*     */ 
/*     */ 
/*     */   
/* 229 */   public XPathFunctionResolver getFunctionResolver() { return this.functionResolver; }
/*     */ 
/*     */ 
/*     */   
/* 233 */   public void setFunctionResolver(XPathFunctionResolver functionResolver) { this.functionResolver = functionResolver; }
/*     */ 
/*     */   
/*     */   public XPathExpression getExpression() throws XPathFactoryConfigurationException, XPathExpressionException {
/* 237 */     if (this.expression == null) {
/* 238 */       this.expression = createXPathExpression();
/*     */     }
/* 240 */     return this.expression;
/*     */   }
/*     */ 
/*     */   
/* 244 */   public void setNamespacesFromDom(Element node) { getNamespaceContext().setNamespacesFromDom(node); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected synchronized Object evaluateAs(E exchange, QName resultType) {
/* 255 */     this.variableResolver.setExchange((Exchange)exchange);
/*     */     try {
/* 257 */       Object document = getDocument(exchange);
/* 258 */       if (resultType != null) {
/* 259 */         if (document instanceof InputSource) {
/* 260 */           InputSource inputSource = (InputSource)document;
/* 261 */           return getExpression().evaluate(inputSource, resultType);
/*     */         } 
/*     */         
/* 264 */         return getExpression().evaluate(document, resultType);
/*     */       } 
/*     */ 
/*     */       
/* 268 */       if (document instanceof InputSource) {
/* 269 */         InputSource inputSource = (InputSource)document;
/* 270 */         return getExpression().evaluate(inputSource);
/*     */       } 
/*     */       
/* 273 */       return getExpression().evaluate(document);
/*     */ 
/*     */     
/*     */     }
/* 277 */     catch (XPathExpressionException e) {
/* 278 */       throw new InvalidXPathExpression(getText(), e);
/*     */     }
/* 280 */     catch (XPathFactoryConfigurationException e) {
/* 281 */       throw new InvalidXPathExpression(getText(), e);
/*     */     } 
/*     */   }
/*     */   
/*     */   protected XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {
/* 286 */     XPath xPath = getXPathFactory().newXPath();
/*     */ 
/*     */     
/* 289 */     this.xpathFactory = null;
/*     */     
/* 291 */     xPath.setNamespaceContext(getNamespaceContext());
/* 292 */     xPath.setXPathVariableResolver(this.variableResolver);
/* 293 */     if (this.functionResolver != null) {
/* 294 */       xPath.setXPathFunctionResolver(this.functionResolver);
/*     */     }
/* 296 */     return xPath.compile(this.text);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Object getDocument(E exchange) {
/* 303 */     Message in = exchange.getIn();
/* 304 */     Class type = getDocumentType();
/* 305 */     Object answer = null;
/* 306 */     if (type != null) {
/* 307 */       answer = in.getBody(type);
/*     */     }
/* 309 */     if (answer == null) {
/* 310 */       answer = in.getBody();
/*     */     }
/*     */ 
/*     */     
/* 314 */     if (answer instanceof String) {
/* 315 */       answer = new InputSource(new StringReader(answer.toString()));
/*     */     }
/* 317 */     return answer;
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\XPathBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.builder.xml.XsltBuilder,"/*     */ package org.apache.camel.builder.xml;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.net.URL;
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import javax.xml.parsers.ParserConfigurationException;
/*     */ import javax.xml.transform.Result;
/*     */ import javax.xml.transform.Source;
/*     */ import javax.xml.transform.Transformer;
/*     */ import javax.xml.transform.TransformerConfigurationException;
/*     */ import javax.xml.transform.stream.StreamSource;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.ExpectedBodyTypeException;
/*     */ import org.apache.camel.Message;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.RuntimeTransformException;
/*     */ import org.apache.camel.converter.jaxp.XmlConverter;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class XsltBuilder
/*     */   implements Processor
/*     */ {
/*  49 */   private Map<String, Object> parameters = new HashMap<String, Object>();
/*  50 */   private XmlConverter converter = new XmlConverter();
/*     */   private Transformer transformer;
/*  52 */   private ResultHandler resultHandler = new StringResultHandler();
/*     */   
/*     */   private boolean failOnNullBody = true;
/*     */ 
/*     */   
/*     */   public XsltBuilder() {}
/*     */   
/*  59 */   public XsltBuilder(Transformer transformer) { this.transformer = transformer; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   public String toString() { return ""XSLT["" + this.transformer + ""]""; }
/*     */ 
/*     */   
/*     */   public synchronized void process(Exchange exchange) throws Exception {
/*  68 */     Transformer transformer = getTransformer();
/*  69 */     if (transformer == null) {
/*  70 */       throw new IllegalArgumentException(""No transformer configured!"");
/*     */     }
/*  72 */     configureTransformer(transformer, exchange);
/*  73 */     Source source = getSource(exchange);
/*  74 */     Result result = this.resultHandler.getResult();
/*  75 */     transformer.transform(source, result);
/*  76 */     this.resultHandler.setBody(exchange.getIn());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public static XsltBuilder xslt(Transformer transformer) { return new XsltBuilder(transformer); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static XsltBuilder xslt(Source xslt) throws TransformerConfigurationException {
/*  93 */     ObjectHelper.notNull(xslt, ""xslt"");
/*  94 */     XsltBuilder answer = new XsltBuilder();
/*  95 */     answer.setTransformerSource(xslt);
/*  96 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static XsltBuilder xslt(File xslt) throws TransformerConfigurationException {
/* 103 */     ObjectHelper.notNull(xslt, ""xslt"");
/* 104 */     return xslt(new StreamSource(xslt));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static XsltBuilder xslt(URL xslt) throws TransformerConfigurationException, IOException {
/* 111 */     ObjectHelper.notNull(xslt, ""xslt"");
/* 112 */     return xslt(xslt.openStream());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static XsltBuilder xslt(InputStream xslt) throws TransformerConfigurationException, IOException {
/* 119 */     ObjectHelper.notNull(xslt, ""xslt"");
/* 120 */     return xslt(new StreamSource(xslt));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XsltBuilder outputBytes() {
/* 127 */     setResultHandler(new StreamResultHandler());
/* 128 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XsltBuilder outputString() {
/* 135 */     setResultHandler(new StringResultHandler());
/* 136 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public XsltBuilder outputDOM() {
/* 143 */     setResultHandler(new DomResultHandler());
/* 144 */     return this;
/*     */   }
/*     */   
/*     */   public XsltBuilder parameter(String name, Object value) {
/* 148 */     this.parameters.put(name, value);
/* 149 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 156 */   public Map<String, Object> getParameters() { return this.parameters; }
/*     */ 
/*     */ 
/*     */   
/* 160 */   public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }
/*     */ 
/*     */ 
/*     */   
/* 164 */   public Transformer getTransformer() { return this.transformer; }
/*     */ 
/*     */ 
/*     */   
/* 168 */   public void setTransformer(Transformer transformer) { this.transformer = transformer; }
/*     */ 
/*     */ 
/*     */   
/* 172 */   public boolean isFailOnNullBody() { return this.failOnNullBody; }
/*     */ 
/*     */ 
/*     */   
/* 176 */   public void setFailOnNullBody(boolean failOnNullBody) { this.failOnNullBody = failOnNullBody; }
/*     */ 
/*     */ 
/*     */   
/* 180 */   public ResultHandler getResultHandler() { return this.resultHandler; }
/*     */ 
/*     */ 
/*     */   
/* 184 */   public void setResultHandler(ResultHandler resultHandler) { this.resultHandler = resultHandler; }
/*     */ 
/*     */ 
/*     */   
/* 188 */   public void setTransformerSource(Source source) throws TransformerConfigurationException { setTransformer(this.converter.getTransformerFactory().newTransformer(source)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Source getSource(Exchange exchange) {
/* 198 */     Message in = exchange.getIn();
/* 199 */     Source source = (Source)in.getBody(Source.class);
/* 200 */     if (source == null) {
/* 201 */       if (isFailOnNullBody()) {
/* 202 */         throw new ExpectedBodyTypeException(exchange, Source.class);
/*     */       }
/*     */       
/*     */       try {
/* 206 */         source = this.converter.toSource(this.converter.createDocument());
/*     */       }
/* 208 */       catch (ParserConfigurationException e) {
/* 209 */         throw new RuntimeTransformException(e);
/*     */       } 
/*     */     } 
/*     */     
/* 213 */     return source;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void configureTransformer(Transformer transformer, Exchange exchange) {
/* 220 */     transformer.clearParameters();
/*     */     
/* 222 */     addParameters(transformer, exchange.getProperties());
/* 223 */     addParameters(transformer, exchange.getIn().getHeaders());
/* 224 */     addParameters(transformer, getParameters());
/*     */     
/* 226 */     transformer.setParameter(""exchange"", exchange);
/* 227 */     transformer.setParameter(""in"", exchange.getIn());
/* 228 */     transformer.setParameter(""out"", exchange.getOut());
/*     */   }
/*     */   
/*     */   protected void addParameters(Transformer transformer, Map<String, Object> map) {
/* 232 */     Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
/* 233 */     for (Map.Entry<String, Object> entry : propertyEntries)
/* 234 */       transformer.setParameter(entry.getKey(), entry.getValue()); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\builder\xml\XsltBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.direct.DirectComponent,"/*    */ package org.apache.camel.component.direct;
/*    */ 
/*    */ import java.net.URI;
/*    */ import java.util.Map;
/*    */ import java.util.concurrent.ScheduledExecutorService;
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Component;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.util.IntrospectionSupport;
/*    */ import org.apache.camel.util.ObjectHelper;
/*    */ import org.apache.camel.util.URISupport;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DirectComponent<E extends Exchange>
/*    */   implements Component<E>
/*    */ {
/*    */   private CamelContext context;
/*    */   
/* 43 */   public CamelContext getCamelContext() { return this.context; }
/*    */ 
/*    */ 
/*    */   
/* 47 */   public ScheduledExecutorService getExecutorService() { return null; }
/*    */ 
/*    */ 
/*    */   
/*    */   public Endpoint<E> createEndpoint(String uri) throws Exception {
/* 52 */     ObjectHelper.notNull(getCamelContext(), ""camelContext"");
/* 53 */     URI u = new URI(uri);
/* 54 */     Map parameters = URISupport.parseParamters(u);
/*    */     
/* 56 */     DirectEndpoint<E> directEndpoint = new DirectEndpoint<E>(uri, this);
/* 57 */     if (parameters != null) {
/* 58 */       IntrospectionSupport.setProperties(directEndpoint, parameters);
/*    */     }
/* 60 */     return (Endpoint<E>)directEndpoint;
/*    */   }
/*    */ 
/*    */   
/* 64 */   public void setCamelContext(CamelContext context) { this.context = context; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\direct\DirectComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.direct.DirectEndpoint,"/*     */ package org.apache.camel.component.direct;
/*     */ 
/*     */ import java.util.concurrent.CopyOnWriteArrayList;
/*     */ import org.apache.camel.Consumer;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.impl.DefaultConsumer;
/*     */ import org.apache.camel.impl.DefaultEndpoint;
/*     */ import org.apache.camel.impl.DefaultExchange;
/*     */ import org.apache.camel.impl.DefaultProducer;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DirectEndpoint<E extends Exchange>
/*     */   extends DefaultEndpoint<E>
/*     */ {
/*  41 */   private static final Log log = LogFactory.getLog(DirectEndpoint.class);
/*     */   
/*  43 */   private final CopyOnWriteArrayList<DefaultConsumer<E>> consumers = new CopyOnWriteArrayList<DefaultConsumer<E>>();
/*     */   
/*     */   boolean allowMultipleConsumers = true;
/*     */ 
/*     */   
/*  48 */   public DirectEndpoint(String uri, DirectComponent<E> component) { super(uri, component); }
/*     */ 
/*     */   
/*     */   public Producer createProducer() throws Exception {
/*  52 */     return (Producer)new DefaultProducer((Endpoint)this)
/*     */       {
/*  54 */         public void process(Exchange exchange) throws Exception { DirectEndpoint.this.process(exchange); }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/*     */   protected void process(Exchange exchange) throws Exception {
/*  60 */     if (this.consumers.isEmpty()) {
/*  61 */       log.warn(""No consumers available on "" + this + "" for "" + exchange);
/*     */     } else {
/*     */       
/*  64 */       for (DefaultConsumer<E> consumer : this.consumers) {
/*  65 */         consumer.getProcessor().process(exchange);
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   public Consumer<E> createConsumer(Processor processor) throws Exception {
/*  71 */     return (Consumer<E>)new DefaultConsumer<E>((Endpoint)this, processor)
/*     */       {
/*     */         public void start() throws Exception {
/*  74 */           if (!DirectEndpoint.this.allowMultipleConsumers && !DirectEndpoint.this.consumers.isEmpty()) {
/*  75 */             throw new IllegalStateException(""Endpoint "" + DirectEndpoint.this.getEndpointUri() + "" only allows 1 active consumer but you attempted to start a 2nd consumer."");
/*     */           }
/*  77 */           DirectEndpoint.this.consumers.add(this);
/*  78 */           super.start();
/*     */         }
/*     */ 
/*     */         
/*     */         public void stop() throws Exception {
/*  83 */           super.stop();
/*  84 */           DirectEndpoint.this.consumers.remove(this);
/*     */         }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  92 */   public E createExchange() { return (E)new DefaultExchange(getContext()); }
/*     */ 
/*     */ 
/*     */   
/*  96 */   public boolean isAllowMultipleConsumers() { return this.allowMultipleConsumers; }
/*     */ 
/*     */   
/*  99 */   public void setAllowMultipleConsumers(boolean allowMutlipleConsumers) { this.allowMultipleConsumers = allowMutlipleConsumers; }
/*     */ 
/*     */ 
/*     */   
/* 103 */   public boolean isSingleton() { return true; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\direct\DirectEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.file.FileComponent,"/*    */ package org.apache.camel.component.file;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.util.Map;
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.impl.DefaultComponent;
/*    */ import org.apache.camel.util.IntrospectionSupport;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FileComponent
/*    */   extends DefaultComponent<FileExchange>
/*    */ {
/*    */   public FileComponent() {}
/*    */   
/* 38 */   public FileComponent(CamelContext context) { super(context); }
/*    */ 
/*    */   
/*    */   protected Endpoint<FileExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
/* 42 */     File file = new File(remaining);
/* 43 */     FileEndpoint result = new FileEndpoint(file, remaining, this);
/* 44 */     IntrospectionSupport.setProperties(result, parameters);
/* 45 */     return (Endpoint<FileExchange>)result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\file\FileComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.file.FileConsumer,"/*     */ package org.apache.camel.component.file;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.nio.channels.FileChannel;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.impl.DefaultEndpoint;
/*     */ import org.apache.camel.impl.ScheduledPollConsumer;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FileConsumer
/*     */   extends ScheduledPollConsumer<FileExchange>
/*     */ {
/*  34 */   private static final transient Log log = LogFactory.getLog(FileConsumer.class);
/*     */   private final FileEndpoint endpoint;
/*     */   private boolean recursive = true;
/*     */   private boolean attemptFileLock = false;
/*  38 */   private String regexPattern = """";
/*  39 */   private long lastPollTime = 0L;
/*     */   
/*     */   public FileConsumer(FileEndpoint endpoint, Processor processor) {
/*  42 */     super((DefaultEndpoint)endpoint, processor);
/*  43 */     this.endpoint = endpoint;
/*     */   }
/*     */   
/*     */   protected void poll() throws Exception {
/*  47 */     pollFileOrDirectory(this.endpoint.getFile(), isRecursive());
/*  48 */     this.lastPollTime = System.currentTimeMillis();
/*     */   }
/*     */   
/*     */   protected void pollFileOrDirectory(File fileOrDirectory, boolean processDir) {
/*  52 */     if (!fileOrDirectory.isDirectory()) {
/*  53 */       pollFile(fileOrDirectory);
/*     */     }
/*  55 */     else if (processDir) {
/*  56 */       log.debug(""Polling directory "" + fileOrDirectory);
/*  57 */       File[] files = fileOrDirectory.listFiles();
/*  58 */       for (int i = 0; i < files.length; i++) {
/*  59 */         pollFileOrDirectory(files[i], isRecursive());
/*     */       }
/*     */     } else {
/*     */       
/*  63 */       log.debug(""Skipping directory "" + fileOrDirectory);
/*     */     } 
/*     */   }
/*     */   
/*     */   protected void pollFile(File file) {
/*  68 */     if (file.exists() && file.lastModified() > this.lastPollTime && 
/*  69 */       isValidFile(file)) {
/*  70 */       processFile(file);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   protected void processFile(File file) {
/*     */     try {
/*  77 */       getProcessor().process((Exchange)this.endpoint.createExchange(file));
/*  78 */     } catch (Throwable e) {
/*  79 */       handleException(e);
/*     */     } 
/*     */   }
/*     */   
/*     */   protected boolean isValidFile(File file) {
/*  84 */     boolean result = false;
/*  85 */     if (file != null && file.exists() && 
/*  86 */       isMatched(file)) {
/*  87 */       if (isAttemptFileLock()) {
/*  88 */         FileChannel fc = null;
/*     */         try {
/*  90 */           fc = (new RandomAccessFile(file, ""rw"")).getChannel();
/*  91 */           fc.lock();
/*  92 */           result = true;
/*     */         }
/*  94 */         catch (Throwable e) {
/*  95 */           log.debug(""Failed to get the lock on file: "" + file, e);
/*     */         } finally {
/*     */           
/*  98 */           if (fc != null) {
/*     */             try {
/* 100 */               fc.close();
/*     */             }
/* 102 */             catch (IOException e) {}
/*     */           }
/*     */         }
/*     */       
/*     */       } else {
/*     */         
/* 108 */         result = true;
/*     */       } 
/*     */     }
/*     */     
/* 112 */     return result;
/*     */   }
/*     */   
/*     */   protected boolean isMatched(File file) {
/* 116 */     boolean result = true;
/* 117 */     if (this.regexPattern != null && this.regexPattern.length() > 0) {
/* 118 */       result = file.getName().matches(getRegexPattern());
/*     */     }
/* 120 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 127 */   public boolean isRecursive() { return this.recursive; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 134 */   public void setRecursive(boolean recursive) { this.recursive = recursive; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 141 */   public boolean isAttemptFileLock() { return this.attemptFileLock; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 148 */   public void setAttemptFileLock(boolean attemptFileLock) { this.attemptFileLock = attemptFileLock; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public String getRegexPattern() { return this.regexPattern; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 162 */   public void setRegexPattern(String regexPattern) { this.regexPattern = regexPattern; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\file\FileConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.file.FileEndpoint,"/*     */ package org.apache.camel.component.file;
/*     */ 
/*     */ import java.io.File;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Consumer;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.impl.ScheduledPollEndpoint;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FileEndpoint
/*     */   extends ScheduledPollEndpoint<FileExchange>
/*     */ {
/*     */   private File file;
/*     */   private boolean autoCreate = true;
/*     */   
/*     */   protected FileEndpoint(File file, String endpointUri, FileComponent component) {
/*  37 */     super(endpointUri, (Component)component);
/*  38 */     this.file = file;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  47 */   public Producer<FileExchange> createProducer() throws Exception { return (Producer<FileExchange>)new FileProducer(this); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Consumer<FileExchange> createConsumer(Processor file) throws Exception {
/*  58 */     FileConsumer fileConsumer = new FileConsumer(this, file);
/*  59 */     configureConsumer((Consumer)fileConsumer);
/*  60 */     return (Consumer<FileExchange>)fileConsumer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  69 */   public FileExchange createExchange(File file) { return new FileExchange(getContext(), file); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   public FileExchange createExchange() { return createExchange(getFile()); }
/*     */ 
/*     */   
/*     */   public File getFile() {
/*  81 */     if (this.autoCreate && !this.file.exists()) {
/*  82 */       this.file.mkdirs();
/*     */     }
/*  84 */     return this.file;
/*     */   }
/*     */ 
/*     */   
/*  88 */   public boolean isSingleton() { return true; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   public boolean isAutoCreate() { return this.autoCreate; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 104 */   public void setAutoCreate(boolean autoCreate) { this.autoCreate = autoCreate; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\file\FileEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.file.FileExchange,"/*    */ package org.apache.camel.component.file;
/*    */ 
/*    */ import java.io.File;
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Message;
/*    */ import org.apache.camel.impl.DefaultExchange;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FileExchange
/*    */   extends DefaultExchange
/*    */ {
/*    */   private File file;
/*    */   
/*    */   public FileExchange(CamelContext camelContext, File file) {
/* 39 */     super(camelContext);
/* 40 */     setIn((Message)new FileMessage(file));
/* 41 */     this.file = file;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public File getFile() { return this.file; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 55 */   public void setFile(File file) { this.file = file; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\file\FileExchange.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.file.FileMessage,"/*    */ package org.apache.camel.component.file;
/*    */ 
/*    */ import java.io.File;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Message;
/*    */ import org.apache.camel.impl.DefaultMessage;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FileMessage
/*    */   extends DefaultMessage
/*    */ {
/*    */   private File file;
/*    */   
/* 33 */   public FileMessage() { this(new File(""."")); }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public FileMessage(File file) { this.file = file; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 42 */   public String toString() { return ""FileMessage: "" + this.file; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 47 */   public FileExchange getExchange() { return (FileExchange)super.getExchange(); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 52 */   public File getFile() { return this.file; }
/*    */ 
/*    */ 
/*    */   
/* 56 */   public void setFile(File file) { this.file = file; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 63 */   public FileMessage newInstance() { return new FileMessage(); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\file\FileMessage.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.file.FileProducer,"/*    */ package org.apache.camel.component.file;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.RandomAccessFile;
/*    */ import java.nio.ByteBuffer;
/*    */ import java.nio.channels.FileChannel;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.impl.DefaultProducer;
/*    */ import org.apache.commons.logging.Log;
/*    */ import org.apache.commons.logging.LogFactory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FileProducer
/*    */   extends DefaultProducer
/*    */ {
/* 33 */   private static final transient Log log = LogFactory.getLog(FileProducer.class);
/*    */   private final FileEndpoint endpoint;
/*    */   
/*    */   public FileProducer(FileEndpoint endpoint) {
/* 37 */     super((Endpoint)endpoint);
/* 38 */     this.endpoint = endpoint;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 46 */   public void process(Exchange exchange) { process((FileExchange)this.endpoint.toExchangeType(exchange)); }
/*    */ 
/*    */   
/*    */   public void process(FileExchange exchange) {
/* 50 */     String fileName = exchange.getIn().getMessageId();
/* 51 */     ByteBuffer payload = (ByteBuffer)exchange.getIn().getBody(ByteBuffer.class);
/* 52 */     payload.flip();
/* 53 */     File file = null;
/* 54 */     if (this.endpoint.getFile() != null && this.endpoint.getFile().isDirectory()) {
/*    */       
/* 56 */       file = new File(this.endpoint.getFile(), fileName);
/*    */     } else {
/*    */       
/* 59 */       file = new File(fileName);
/*    */     } 
/* 61 */     buildDirectory(file);
/*    */     try {
/* 63 */       FileChannel fc = (new RandomAccessFile(file, ""rw"")).getChannel();
/* 64 */       fc.position(fc.size());
/* 65 */       fc.write(payload);
/* 66 */       fc.close();
/* 67 */     } catch (Throwable e) {
/* 68 */       log.error(""Failed to write to File: "" + file, e);
/*    */     } 
/*    */   }
/*    */   
/*    */   private void buildDirectory(File file) {
/* 73 */     String dirName = file.getAbsolutePath();
/* 74 */     int index = dirName.lastIndexOf(File.separatorChar);
/* 75 */     if (index > 0) {
/* 76 */       dirName = dirName.substring(0, index);
/* 77 */       File dir = new File(dirName);
/* 78 */       dir.mkdirs();
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\file\FileProducer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.jmx.JMXComponent,"/*    */ package org.apache.camel.component.jmx;
/*    */ 
/*    */ import java.util.Map;
/*    */ import javax.management.MBeanServer;
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.impl.DefaultComponent;
/*    */ import org.apache.camel.util.IntrospectionSupport;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class JMXComponent
/*    */   extends DefaultComponent<JMXExchange>
/*    */ {
/*    */   private MBeanServer mbeanServer;
/*    */   
/*    */   public JMXComponent() {}
/*    */   
/* 39 */   public JMXComponent(CamelContext context) { super(context); }
/*    */ 
/*    */ 
/*    */   
/*    */   protected Endpoint<JMXExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
/* 44 */     JMXEndpoint result = new JMXEndpoint(remaining, this);
/* 45 */     IntrospectionSupport.setProperties(result, parameters);
/* 46 */     result.setMbeanServer(getMbeanServer());
/* 47 */     return (Endpoint<JMXExchange>)result;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 52 */   public MBeanServer getMbeanServer() { return this.mbeanServer; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 57 */   public void setMbeanServer(MBeanServer mbeanServer) { this.mbeanServer = mbeanServer; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\jmx\JMXComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.jmx.JMXConsumer,"/*    */ package org.apache.camel.component.jmx;
/*    */ 
/*    */ import javax.management.Notification;
/*    */ import javax.management.NotificationListener;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.DefaultConsumer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class JMXConsumer
/*    */   extends DefaultConsumer
/*    */   implements NotificationListener
/*    */ {
/*    */   JMXEndpoint jmxEndpoint;
/*    */   
/*    */   public JMXConsumer(JMXEndpoint endpoint, Processor processor) {
/* 35 */     super((Endpoint)endpoint, processor);
/* 36 */     this.jmxEndpoint = endpoint;
/*    */   }
/*    */   
/*    */   public void handleNotification(Notification notification, Object handback) {
/*    */     try {
/* 41 */       getProcessor().process((Exchange)this.jmxEndpoint.createExchange(notification));
/* 42 */     } catch (Throwable e) {
/* 43 */       handleException(e);
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\jmx\JMXConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.jmx.JMXEndpoint,"/*     */ package org.apache.camel.component.jmx;
/*     */ 
/*     */ import javax.management.MBeanServer;
/*     */ import javax.management.Notification;
/*     */ import javax.management.ObjectName;
/*     */ import javax.management.monitor.CounterMonitor;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Consumer;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.impl.DefaultEndpoint;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class JMXEndpoint
/*     */   extends DefaultEndpoint<JMXExchange>
/*     */ {
/*  38 */   private static final Log log = LogFactory.getLog(JMXEndpoint.class);
/*     */   private String name;
/*     */   private ObjectName ourName;
/*     */   private String observedObjectName;
/*     */   private String attributeName;
/*  43 */   private long granularityPeriod = 5000L;
/*     */   private Number threshold;
/*     */   private Number offset;
/*     */   private MBeanServer mbeanServer;
/*  47 */   private CounterMonitor counterMonitor = new CounterMonitor();
/*     */   
/*     */   protected JMXEndpoint(String endpointUri, JMXComponent component) {
/*  50 */     super(endpointUri, (Component)component);
/*  51 */     this.observedObjectName = endpointUri;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public Producer<JMXExchange> createProducer() throws Exception { throw new RuntimeException(""Not supported""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Consumer<JMXExchange> createConsumer(Processor proc) throws Exception {
/*  71 */     ObjectName observedName = new ObjectName(this.observedObjectName);
/*  72 */     if (this.name == null) {
/*  73 */       String type = observedName.getKeyProperty(""type"");
/*  74 */       type = (type != null) ? type : ""UNKNOWN"";
/*  75 */       this.name = this.mbeanServer.getDefaultDomain() + "":type=CounterMonitor_"" + type;
/*     */     } 
/*  77 */     JMXConsumer result = new JMXConsumer(this, proc);
/*  78 */     this.ourName = new ObjectName(this.name);
/*  79 */     this.counterMonitor.setNotify(true);
/*  80 */     this.counterMonitor.addObservedObject(observedName);
/*  81 */     this.counterMonitor.setObservedAttribute(this.attributeName);
/*  82 */     this.counterMonitor.setGranularityPeriod(this.granularityPeriod);
/*  83 */     this.counterMonitor.setDifferenceMode(false);
/*  84 */     this.counterMonitor.setInitThreshold(this.threshold);
/*  85 */     this.counterMonitor.setOffset(this.offset);
/*  86 */     this.mbeanServer.registerMBean(this.counterMonitor, this.ourName);
/*  87 */     this.mbeanServer.addNotificationListener(this.ourName, result, null, new Object());
/*  88 */     return (Consumer<JMXExchange>)result;
/*     */   }
/*     */ 
/*     */   
/*  92 */   public boolean isSingleton() { return true; }
/*     */ 
/*     */ 
/*     */   
/*  96 */   public JMXExchange createExchange(Notification notification) { return new JMXExchange(getContext(), notification); }
/*     */ 
/*     */ 
/*     */   
/* 100 */   public JMXExchange createExchange() { return new JMXExchange(getContext(), null); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 105 */   public String getAttributeName() { return this.attributeName; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 110 */   public void setAttributeName(String attributeName) { this.attributeName = attributeName; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public long getGranularityPeriod() { return this.granularityPeriod; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 120 */   public void setGranularityPeriod(long granularityPeriod) { this.granularityPeriod = granularityPeriod; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 125 */   public String getName() { return this.name; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 130 */   public void setName(String name) { this.name = name; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 135 */   public Number getOffset() { return this.offset; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 140 */   public void setOffset(Number offset) { this.offset = offset; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public Number getThreshold() { return this.threshold; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 150 */   public void setThreshold(Number threshold) { this.threshold = threshold; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public MBeanServer getMbeanServer() { return this.mbeanServer; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public void setMbeanServer(MBeanServer mbeanServer) { this.mbeanServer = mbeanServer; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\jmx\JMXEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.jmx.JMXExchange,"/*    */ package org.apache.camel.component.jmx;
/*    */ 
/*    */ import javax.management.Notification;
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Message;
/*    */ import org.apache.camel.impl.DefaultExchange;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class JMXExchange
/*    */   extends DefaultExchange
/*    */ {
/*    */   public JMXExchange(CamelContext camelContext, Notification notification) {
/* 38 */     super(camelContext);
/* 39 */     setIn((Message)new JMXMessage(notification));
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\jmx\JMXExchange.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.jmx.JMXMessage,"/*    */ package org.apache.camel.component.jmx;
/*    */ 
/*    */ import javax.management.Notification;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Message;
/*    */ import org.apache.camel.impl.DefaultMessage;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class JMXMessage
/*    */   extends DefaultMessage
/*    */ {
/*    */   private Notification notification;
/*    */   
/* 34 */   public JMXMessage() { this(null); }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public JMXMessage(Notification notification) { this.notification = notification; }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public String toString() { return ""JMXMessage: "" + this.notification; }
/*    */ 
/*    */ 
/*    */   
/* 46 */   public JMXExchange getExchange() { return (JMXExchange)super.getExchange(); }
/*    */ 
/*    */ 
/*    */   
/* 50 */   public JMXMessage newInstance() { return new JMXMessage(); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 55 */   public Notification getNotification() { return this.notification; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\jmx\JMXMessage.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.mock.AssertionClause,"/*     */ package org.apache.camel.component.mock;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Predicate;
/*     */ import org.apache.camel.builder.ExpressionBuilder;
/*     */ import org.apache.camel.builder.Fluent;
/*     */ import org.apache.camel.builder.FluentArg;
/*     */ import org.apache.camel.builder.ValueBuilder;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class AssertionClause<E extends Exchange>
/*     */   implements Runnable
/*     */ {
/*  39 */   private List<Predicate<E>> predicates = new ArrayList<Predicate<E>>();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public AssertionClause<E> predicate(Predicate<E> predicate) {
/*  48 */     addPredicate(predicate);
/*  49 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public ValueBuilder<E> header(@FluentArg(""name"") String name) {
/*  57 */     Expression<E> expression = ExpressionBuilder.headerExpression(name);
/*  58 */     return new PredicateValueBuilder(expression);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public PredicateValueBuilder body() {
/*  66 */     Expression<E> expression = ExpressionBuilder.bodyExpression();
/*  67 */     return new PredicateValueBuilder(expression);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public <T> PredicateValueBuilder bodyAs(@FluentArg(""class"") Class<T> type) {
/*  75 */     Expression<E> expression = ExpressionBuilder.bodyExpression(type);
/*  76 */     return new PredicateValueBuilder(expression);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public PredicateValueBuilder outBody() {
/*  84 */     Expression<E> expression = ExpressionBuilder.bodyExpression();
/*  85 */     return new PredicateValueBuilder(expression);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Fluent
/*     */   public <T> PredicateValueBuilder outBody(@FluentArg(""class"") Class<T> type) {
/*  93 */     Expression<E> expression = ExpressionBuilder.bodyExpression(type);
/*  94 */     return new PredicateValueBuilder(expression);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void applyAssertionOn(MockEndpoint endpoint, int index, E exchange) {
/* 101 */     for (Predicate<E> predicate : this.predicates) {
/* 102 */       predicate.assertMatches(endpoint.getEndpointUri() + "" "", exchange);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 107 */   protected void addPredicate(Predicate<E> predicate) { this.predicates.add(predicate); }
/*     */ 
/*     */   
/*     */   public class PredicateValueBuilder
/*     */     extends ValueBuilder<E>
/*     */   {
/* 113 */     public PredicateValueBuilder(Expression<E> expression) { super(expression); }
/*     */ 
/*     */     
/*     */     protected Predicate<E> onNewPredicate(Predicate<E> predicate) {
/* 117 */       AssertionClause.this.addPredicate(predicate);
/* 118 */       return predicate;
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\mock\AssertionClause.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.mock.MockComponent,"/*    */ package org.apache.camel.component.mock;
/*    */ 
/*    */ import java.util.Map;
/*    */ import org.apache.camel.Component;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.impl.DefaultComponent;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class MockComponent
/*    */   extends DefaultComponent<Exchange>
/*    */ {
/* 35 */   protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception { return (Endpoint<Exchange>)new MockEndpoint(uri, (Component)this); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\mock\MockComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.mock.MockEndpoint,"/*     */ package org.apache.camel.component.mock;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.HashMap;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import java.util.concurrent.CountDownLatch;
/*     */ import java.util.concurrent.TimeUnit;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Consumer;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Message;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.impl.DefaultEndpoint;
/*     */ import org.apache.camel.impl.DefaultExchange;
/*     */ import org.apache.camel.impl.DefaultProducer;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MockEndpoint
/*     */   extends DefaultEndpoint<Exchange>
/*     */ {
/*  47 */   private static final transient Log log = LogFactory.getLog(MockEndpoint.class);
/*  48 */   private int expectedCount = -1;
/*  49 */   private Map<Integer, Processor> processors = new HashMap<Integer, Processor>();
/*  50 */   private List<Exchange> receivedExchanges = new ArrayList<Exchange>();
/*  51 */   private List<Throwable> failures = new ArrayList<Throwable>();
/*  52 */   private List<Runnable> tests = new ArrayList<Runnable>();
/*     */   private CountDownLatch latch;
/*  54 */   private long sleepForEmptyTest = 0L;
/*  55 */   private int expectedMinimumCount = -1;
/*     */   
/*     */   public static void assertWait(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
/*  58 */     long start = System.currentTimeMillis();
/*  59 */     long left = unit.toMillis(timeout);
/*  60 */     long end = start + left;
/*  61 */     for (MockEndpoint endpoint : endpoints) {
/*  62 */       if (!endpoint.await(left, TimeUnit.MILLISECONDS))
/*  63 */         throw new AssertionError(""Timeout waiting for endpoints to receive enough messages. "" + endpoint.getEndpointUri() + "" timed out.""); 
/*  64 */       left = end - System.currentTimeMillis();
/*  65 */       if (left <= 0L)
/*  66 */         left = 0L; 
/*     */     } 
/*     */   }
/*     */   
/*     */   public static void assertIsSatisfied(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
/*  71 */     assertWait(timeout, unit, endpoints);
/*  72 */     for (MockEndpoint endpoint : endpoints) {
/*  73 */       endpoint.assertIsSatisfied();
/*     */     }
/*     */   }
/*     */   
/*     */   public static void assertIsSatisfied(MockEndpoint... endpoints) throws InterruptedException {
/*  78 */     for (MockEndpoint endpoint : endpoints) {
/*  79 */       endpoint.assertIsSatisfied();
/*     */     }
/*     */   }
/*     */   
/*     */   public static void expectsMessageCount(int count, MockEndpoint... endpoints) throws InterruptedException {
/*  84 */     for (MockEndpoint endpoint : endpoints) {
/*  85 */       expectsMessageCount(count, new MockEndpoint[0]);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*  90 */   public MockEndpoint(String endpointUri, Component component) { super(endpointUri, component); }
/*     */ 
/*     */ 
/*     */   
/*  94 */   public Exchange createExchange() { return (Exchange)new DefaultExchange(getContext()); }
/*     */ 
/*     */ 
/*     */   
/*  98 */   public Consumer<Exchange> createConsumer(Processor processor) throws Exception { throw new UnsupportedOperationException(""You cannot consume from this endpoint""); }
/*     */ 
/*     */   
/*     */   public Producer<Exchange> createProducer() throws Exception {
/* 102 */     return (Producer<Exchange>)new DefaultProducer<Exchange>((Endpoint)this)
/*     */       {
/* 104 */         public void process(Exchange exchange) { MockEndpoint.this.onExchange(exchange); }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 116 */   public void assertIsSatisfied() throws InterruptedException { assertIsSatisfied(this.sleepForEmptyTest); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void assertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {
/* 123 */     if (this.latch != null) {
/*     */       
/* 125 */       this.latch.await(10L, TimeUnit.SECONDS);
/*     */     }
/* 127 */     else if (this.expectedCount == 0) {
/*     */       
/* 129 */       if (timeoutForEmptyEndpoints > 0L) {
/* 130 */         Thread.sleep(timeoutForEmptyEndpoints);
/*     */       }
/*     */     } 
/*     */     
/* 134 */     if (this.expectedCount >= 0) {
/* 135 */       int receivedCounter = getReceivedCounter();
/* 136 */       assertEquals(""Received message count"", Integer.valueOf(this.expectedCount), Integer.valueOf(receivedCounter));
/*     */     } 
/*     */     
/* 139 */     if (this.expectedMinimumCount >= 0) {
/* 140 */       int receivedCounter = getReceivedCounter();
/* 141 */       assertTrue(""Received message count "" + receivedCounter + "", expected at least "" + this.expectedCount, (this.expectedCount <= receivedCounter));
/*     */     } 
/*     */ 
/*     */     
/* 145 */     for (Runnable test : this.tests) {
/* 146 */       test.run();
/*     */     }
/*     */     
/* 149 */     for (Throwable failure : this.failures) {
/* 150 */       if (failure != null) {
/* 151 */         log.error(""Caught on "" + getEndpointUri() + "" Exception: "" + failure, failure);
/* 152 */         fail(""Failed due to caught exception: "" + failure);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void expectedMessageCount(int expectedCount) {
/* 163 */     this.expectedCount = expectedCount;
/* 164 */     if (expectedCount <= 0) {
/* 165 */       this.latch = null;
/*     */     } else {
/*     */       
/* 168 */       this.latch = new CountDownLatch(expectedCount);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void expectedMinimumMessageCount(int expectedCount) {
/* 178 */     this.expectedMinimumCount = expectedCount;
/* 179 */     if (expectedCount <= 0) {
/* 180 */       this.latch = null;
/*     */     } else {
/*     */       
/* 183 */       this.latch = new CountDownLatch(this.expectedMinimumCount);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void expectedBodiesReceived(final List bodies) {
/* 191 */     expectedMessageCount(bodies.size());
/*     */     
/* 193 */     expects(new Runnable() {
/*     */           public void run() {
/* 195 */             int counter = 0;
/* 196 */             for (Object expectedBody : bodies) {
/* 197 */               Exchange exchange = MockEndpoint.this.getReceivedExchanges().get(counter++);
/* 198 */               MockEndpoint.this.assertTrue(""No exchange received for counter: "" + counter, (exchange != null));
/*     */               
/* 200 */               Message in = exchange.getIn();
/*     */               
/* 202 */               Object actualBody = (expectedBody != null) ? in.getBody(expectedBody.getClass()) : in.getBody();
/*     */ 
/*     */               
/* 205 */               MockEndpoint.this.assertEquals(""Body of message: "" + counter, expectedBody, actualBody);
/*     */               
/* 207 */               log.debug(MockEndpoint.this.getEndpointUri() + "" >>>> message: "" + counter + "" with body: "" + actualBody);
/*     */             } 
/*     */           }
/*     */         });
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void expectedBodiesReceived(Object... bodies) {
/* 217 */     List<Object> bodyList = new ArrayList();
/* 218 */     for (Object body : bodies) {
/* 219 */       bodyList.add(body);
/*     */     }
/* 221 */     expectedBodiesReceived(bodyList);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 229 */   public void expects(Runnable runnable) { this.tests.add(runnable); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public AssertionClause message(final int messageIndex) {
/* 239 */     AssertionClause<Exchange> clause = new AssertionClause<Exchange>() {
/*     */         public void run() {
/* 241 */           applyAssertionOn(MockEndpoint.this, messageIndex, (E)MockEndpoint.this.assertExchangeReceived(messageIndex));
/*     */         }
/*     */       };
/* 244 */     expects(clause);
/* 245 */     return clause;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public AssertionClause allMessages() {
/* 254 */     AssertionClause<Exchange> clause = new AssertionClause<Exchange>() {
/*     */         public void run() {
/* 256 */           List<Exchange> list = MockEndpoint.this.getReceivedExchanges();
/* 257 */           int index = 0;
/* 258 */           for (Exchange exchange : list) {
/* 259 */             applyAssertionOn(MockEndpoint.this, index++, (E)exchange);
/*     */           }
/*     */         }
/*     */       };
/* 263 */     expects(clause);
/* 264 */     return clause;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Exchange assertExchangeReceived(int index) {
/* 271 */     int count = getReceivedCounter();
/* 272 */     assertTrue(""Not enough messages received. Was: "" + count, (count > index));
/* 273 */     return getReceivedExchanges().get(index);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 279 */   public List<Throwable> getFailures() { return this.failures; }
/*     */ 
/*     */ 
/*     */   
/* 283 */   public int getReceivedCounter() { return getReceivedExchanges().size(); }
/*     */ 
/*     */ 
/*     */   
/* 287 */   public List<Exchange> getReceivedExchanges() { return this.receivedExchanges; }
/*     */ 
/*     */ 
/*     */   
/* 291 */   public int getExpectedCount() { return this.expectedCount; }
/*     */ 
/*     */ 
/*     */   
/* 295 */   public long getSleepForEmptyTest() { return this.sleepForEmptyTest; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 305 */   public void setSleepForEmptyTest(long sleepForEmptyTest) { this.sleepForEmptyTest = sleepForEmptyTest; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected synchronized void onExchange(Exchange exchange) {
/*     */     try {
/* 312 */       log.debug(getEndpointUri() + "" >>>> "" + exchange);
/*     */       
/* 314 */       this.receivedExchanges.add(exchange);
/*     */       
/* 316 */       Processor processor = this.processors.get(Integer.valueOf(getReceivedCounter()));
/* 317 */       if (processor != null) {
/* 318 */         processor.process(exchange);
/*     */       }
/*     */       
/* 321 */       if (this.latch != null) {
/* 322 */         this.latch.countDown();
/*     */       }
/*     */     }
/* 325 */     catch (Exception e) {
/* 326 */       this.failures.add(e);
/*     */     } 
/*     */   }
/*     */   
/*     */   protected void assertEquals(String message, Object expectedValue, Object actualValue) {
/* 331 */     if (!ObjectHelper.equals(expectedValue, actualValue)) {
/* 332 */       fail(message + "". Expected: <"" + expectedValue + ""> but was: <"" + actualValue + "">"");
/*     */     }
/*     */   }
/*     */   
/*     */   protected void assertTrue(String message, boolean predicate) {
/* 337 */     if (!predicate) {
/* 338 */       fail(message);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 343 */   protected void fail(Object message) { throw new AssertionError(getEndpointUri() + "" "" + message); }
/*     */ 
/*     */ 
/*     */   
/* 347 */   public int getExpectedMinimumCount() { return this.expectedMinimumCount; }
/*     */ 
/*     */   
/*     */   public void await() throws InterruptedException {
/* 351 */     if (this.latch != null) {
/* 352 */       this.latch.await();
/*     */     }
/*     */   }
/*     */   
/*     */   public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
/* 357 */     if (this.latch != null) {
/* 358 */       return this.latch.await(timeout, unit);
/*     */     }
/* 360 */     return true;
/*     */   }
/*     */ 
/*     */   
/* 364 */   public boolean isSingleton() { return true; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\mock\MockEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.NoPojoAvailableException,"/*    */ package org.apache.camel.component.pojo;
/*    */ 
/*    */ import org.apache.camel.CamelException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoPojoAvailableException
/*    */   extends CamelException
/*    */ {
/*    */   private final PojoEndpoint endpoint;
/*    */   
/*    */   public NoPojoAvailableException(PojoEndpoint endpoint) {
/* 29 */     super(""No POJO available for endpoint: "" + endpoint);
/* 30 */     this.endpoint = endpoint;
/*    */   }
/*    */ 
/*    */   
/* 34 */   public PojoEndpoint getEndpoint() { return this.endpoint; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\NoPojoAvailableException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.PojoComponent,"/*     */ package org.apache.camel.component.pojo;
/*     */ 
/*     */ import java.lang.reflect.InvocationHandler;
/*     */ import java.lang.reflect.InvocationTargetException;
/*     */ import java.lang.reflect.Method;
/*     */ import java.lang.reflect.Proxy;
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.impl.DefaultComponent;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class PojoComponent
/*     */   extends DefaultComponent<PojoExchange>
/*     */ {
/*  38 */   protected final HashMap<String, Object> services = new HashMap<String, Object>();
/*     */ 
/*     */   
/*  41 */   public void addService(String uri, Object pojo) { this.services.put(uri, pojo); }
/*     */ 
/*     */ 
/*     */   
/*  45 */   public void removeService(String uri) { this.services.remove(uri); }
/*     */ 
/*     */ 
/*     */   
/*  49 */   public Object getService(String uri) { return this.services.get(uri); }
/*     */ 
/*     */ 
/*     */   
/*     */   protected Endpoint<PojoExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
/*  54 */     Object pojo = getService(remaining);
/*  55 */     return (Endpoint<PojoExchange>)new PojoEndpoint(uri, (Component)this, pojo);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Object createProxy(final Endpoint endpoint, ClassLoader cl, Class[] interfaces) throws Exception {
/*  63 */     final Producer producer = endpoint.createProducer();
/*  64 */     return Proxy.newProxyInstance(cl, interfaces, new InvocationHandler() {
/*     */           public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
/*  66 */             PojoInvocation invocation = new PojoInvocation(proxy, method, args);
/*  67 */             PojoExchange exchange = new PojoExchange(endpoint.getContext());
/*  68 */             exchange.setInvocation(invocation);
/*  69 */             producer.process((Exchange)exchange);
/*  70 */             Throwable fault = exchange.getException();
/*  71 */             if (fault != null) {
/*  72 */               throw new InvocationTargetException(fault);
/*     */             }
/*  74 */             return exchange.getOut().getBody();
/*     */           }
/*     */         });
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Object createProxy(Endpoint endpoint, Class[] interfaces) throws Exception {
/*  84 */     if (interfaces.length < 1) {
/*  85 */       throw new IllegalArgumentException(""You must provide at least 1 interface class."");
/*     */     }
/*  87 */     return createProxy(endpoint, interfaces[0].getClassLoader(), interfaces);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public static <T> T createProxy(Endpoint endpoint, ClassLoader cl, Class<T> interfaceClass) throws Exception { return (T)createProxy(endpoint, cl, new Class[] { interfaceClass }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 104 */   public static <T> T createProxy(Endpoint endpoint, Class<T> interfaceClass) throws Exception { return (T)createProxy(endpoint, new Class[] { interfaceClass }); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\PojoComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.PojoEndpoint,"/*    */ package org.apache.camel.component.pojo;
/*    */ 
/*    */ import java.lang.reflect.InvocationTargetException;
/*    */ import org.apache.camel.Component;
/*    */ import org.apache.camel.Consumer;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Producer;
/*    */ import org.apache.camel.impl.DefaultEndpoint;
/*    */ import org.apache.camel.impl.DefaultProducer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PojoEndpoint
/*    */   extends DefaultEndpoint<PojoExchange>
/*    */ {
/*    */   private Object pojo;
/*    */   
/*    */   public PojoEndpoint(String uri, Component component, Object pojo) {
/* 41 */     super(uri, component);
/* 42 */     this.pojo = pojo;
/*    */   }
/*    */   
/*    */   public Producer<PojoExchange> createProducer() throws Exception {
/* 46 */     final Object pojo = getPojo();
/* 47 */     if (pojo == null) {
/* 48 */       throw new NoPojoAvailableException(this);
/*    */     }
/*    */     
/* 51 */     return (Producer<PojoExchange>)new DefaultProducer((Endpoint)this) {
/*    */         public void process(Exchange exchange) {
/* 53 */           PojoExchange pojoExchange = (PojoExchange)PojoEndpoint.this.toExchangeType(exchange);
/* 54 */           PojoEndpoint.invoke(pojo, pojoExchange);
/* 55 */           exchange.copyFrom((Exchange)pojoExchange);
/*    */         }
/*    */       };
/*    */   }
/*    */ 
/*    */   
/* 61 */   public Consumer<PojoExchange> createConsumer(Processor processor) throws Exception { throw new Exception(""You cannot consume from pojo endpoints.""); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static void invoke(Object pojo, PojoExchange exchange) {
/* 70 */     PojoInvocation invocation = exchange.getInvocation();
/*    */     try {
/* 72 */       Object response = invocation.getMethod().invoke(pojo, invocation.getArgs());
/* 73 */       exchange.getOut().setBody(response);
/*    */     }
/* 75 */     catch (InvocationTargetException e) {
/* 76 */       exchange.setException(e.getCause());
/*    */     }
/* 78 */     catch (RuntimeException e) {
/* 79 */       throw e;
/*    */     }
/* 81 */     catch (Throwable e) {
/* 82 */       throw new RuntimeException(e);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 87 */   public PojoExchange createExchange() { return new PojoExchange(getContext()); }
/*    */ 
/*    */ 
/*    */   
/* 91 */   public boolean isSingleton() { return true; }
/*    */ 
/*    */ 
/*    */   
/* 95 */   public Object getPojo() { return this.pojo; }
/*    */ 
/*    */ 
/*    */   
/* 99 */   public void setPojo(Object pojo) { this.pojo = pojo; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\PojoEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.PojoExchange,"/*    */ package org.apache.camel.component.pojo;
/*    */ 
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.impl.DefaultExchange;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PojoExchange
/*    */   extends DefaultExchange
/*    */ {
/* 29 */   public PojoExchange(CamelContext context) { super(context); }
/*    */ 
/*    */ 
/*    */   
/* 33 */   public PojoInvocation getInvocation() { return (PojoInvocation)getIn().getBody(PojoInvocation.class); }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public void setInvocation(PojoInvocation invocation) { getIn().setBody(invocation); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Exchange newInstance() { return (Exchange)new PojoExchange(getContext()); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\PojoExchange.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.PojoInvocation,"/*    */ package org.apache.camel.component.pojo;
/*    */ 
/*    */ import java.lang.reflect.Method;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PojoInvocation
/*    */ {
/*    */   private final Object proxy;
/*    */   private final Method method;
/*    */   private final Object[] args;
/*    */   
/*    */   public PojoInvocation(Object proxy, Method method, Object[] args) {
/* 28 */     this.proxy = proxy;
/* 29 */     this.method = method;
/* 30 */     this.args = args;
/*    */   }
/*    */ 
/*    */   
/* 34 */   public Object[] getArgs() { return this.args; }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public Method getMethod() { return this.method; }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Object getProxy() { return this.proxy; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\PojoInvocation.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.timer.TimerComponent,"/*    */ package org.apache.camel.component.pojo.timer;
/*    */ 
/*    */ import java.util.ArrayList;
/*    */ import java.util.Map;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.component.pojo.PojoExchange;
/*    */ import org.apache.camel.impl.DefaultComponent;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TimerComponent
/*    */   extends DefaultComponent<PojoExchange>
/*    */ {
/* 33 */   protected final ArrayList<TimerConsumer> timers = new ArrayList<TimerConsumer>();
/*    */ 
/*    */   
/* 36 */   boolean addConsumer(TimerConsumer consumer) { return this.timers.add(consumer); }
/*    */ 
/*    */ 
/*    */   
/* 40 */   boolean removeConsumer(TimerConsumer consumer) { return this.timers.remove(consumer); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 45 */   protected Endpoint<PojoExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception { return (Endpoint<PojoExchange>)new TimerEndpoint(uri, this, remaining); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\timer\TimerComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.timer.TimerConsumer,"/*     */ package org.apache.camel.component.pojo.timer;
/*     */ 
/*     */ import java.lang.reflect.InvocationHandler;
/*     */ import java.lang.reflect.InvocationTargetException;
/*     */ import java.lang.reflect.Method;
/*     */ import java.lang.reflect.Proxy;
/*     */ import java.util.Timer;
/*     */ import java.util.TimerTask;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.component.pojo.PojoExchange;
/*     */ import org.apache.camel.component.pojo.PojoInvocation;
/*     */ import org.apache.camel.impl.DefaultConsumer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TimerConsumer
/*     */   extends DefaultConsumer<PojoExchange>
/*     */   implements InvocationHandler
/*     */ {
/*     */   private final TimerEndpoint endpoint;
/*     */   private Timer timer;
/*     */   
/*     */   public TimerConsumer(TimerEndpoint endpoint, Processor processor) {
/*  42 */     super((Endpoint)endpoint, processor);
/*  43 */     this.endpoint = endpoint;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doStart() throws Exception {
/*  48 */     TimerComponent component = this.endpoint.getComponent();
/*  49 */     component.addConsumer(this);
/*  50 */     this.timer = createTimerAndTask();
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doStop() throws Exception {
/*  55 */     if (this.timer != null) {
/*  56 */       this.timer.cancel();
/*     */     }
/*  58 */     TimerComponent component = this.endpoint.getComponent();
/*  59 */     component.removeConsumer(this);
/*     */   }
/*     */ 
/*     */   
/*     */   private Timer createTimerAndTask() {
/*  64 */     final Runnable proxy = createProxy();
/*  65 */     TimerTask task = new TimerTask() {
/*     */         public void run() {
/*  67 */           proxy.run();
/*     */         }
/*     */       };
/*     */     
/*  71 */     Timer result = new Timer(this.endpoint.getTimerName(), this.endpoint.isDaemon());
/*  72 */     if (this.endpoint.isFixedRate()) {
/*  73 */       if (this.endpoint.getTime() != null) {
/*  74 */         result.scheduleAtFixedRate(task, this.endpoint.getTime(), this.endpoint.getPeriod());
/*     */       } else {
/*  76 */         result.scheduleAtFixedRate(task, this.endpoint.getDelay(), this.endpoint.getPeriod());
/*     */       }
/*     */     
/*  79 */     } else if (this.endpoint.getTime() != null) {
/*  80 */       if (this.endpoint.getPeriod() >= 0L) {
/*  81 */         result.schedule(task, this.endpoint.getTime(), this.endpoint.getPeriod());
/*     */       } else {
/*  83 */         result.schedule(task, this.endpoint.getTime());
/*     */       }
/*     */     
/*  86 */     } else if (this.endpoint.getPeriod() >= 0L) {
/*  87 */       result.schedule(task, this.endpoint.getDelay(), this.endpoint.getPeriod());
/*     */     } else {
/*  89 */       result.schedule(task, this.endpoint.getDelay());
/*     */     } 
/*     */ 
/*     */     
/*  93 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 100 */   public Runnable createProxy() { return (Runnable)Proxy.newProxyInstance(Runnable.class.getClassLoader(), new Class[] { Runnable.class }, this); }
/*     */ 
/*     */   
/*     */   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
/* 104 */     if (!isStarted()) {
/* 105 */       throw new IllegalStateException(""The endpoint is not active: "" + getEndpoint().getEndpointUri());
/*     */     }
/* 107 */     PojoInvocation invocation = new PojoInvocation(proxy, method, args);
/* 108 */     PojoExchange exchange = (PojoExchange)getEndpoint().createExchange();
/* 109 */     exchange.setInvocation(invocation);
/* 110 */     getProcessor().process((Exchange)exchange);
/* 111 */     Throwable fault = exchange.getException();
/* 112 */     if (fault != null) {
/* 113 */       throw new InvocationTargetException(fault);
/*     */     }
/* 115 */     return exchange.getOut().getBody();
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\timer\TimerConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.pojo.timer.TimerEndpoint,"/*     */ package org.apache.camel.component.pojo.timer;
/*     */ 
/*     */ import java.net.URI;
/*     */ import java.net.URISyntaxException;
/*     */ import java.util.Date;
/*     */ import java.util.Map;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Consumer;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.RuntimeCamelException;
/*     */ import org.apache.camel.component.pojo.PojoExchange;
/*     */ import org.apache.camel.impl.DefaultEndpoint;
/*     */ import org.apache.camel.util.IntrospectionSupport;
/*     */ import org.apache.camel.util.URISupport;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TimerEndpoint
/*     */   extends DefaultEndpoint<PojoExchange>
/*     */ {
/*     */   private final TimerComponent component;
/*     */   private final String timerName;
/*     */   private Date time;
/*  43 */   private long period = -1L;
/*  44 */   private long delay = -1L;
/*     */   
/*     */   private boolean fixedRate;
/*     */   private boolean daemon = true;
/*     */   
/*     */   public TimerEndpoint(String fullURI, TimerComponent component, String timerPartURI) throws URISyntaxException {
/*  50 */     super(fullURI, (Component)component);
/*  51 */     this.component = component;
/*     */ 
/*     */     
/*  54 */     URI u = new URI(timerPartURI);
/*  55 */     Map options = URISupport.parseParamters(u);
/*  56 */     IntrospectionSupport.setProperties(this, options);
/*  57 */     this.timerName = u.getPath();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  62 */   public Producer<PojoExchange> createProducer() throws Exception { throw new RuntimeCamelException(""Cannot produce to a TimerEndpoint: "" + getEndpointUri()); }
/*     */ 
/*     */ 
/*     */   
/*  66 */   public Consumer<PojoExchange> createConsumer(Processor processor) throws Exception { return (Consumer<PojoExchange>)new TimerConsumer(this, processor); }
/*     */ 
/*     */ 
/*     */   
/*  70 */   public PojoExchange createExchange() { return new PojoExchange(getContext()); }
/*     */ 
/*     */ 
/*     */   
/*  74 */   public TimerComponent getComponent() { return this.component; }
/*     */ 
/*     */ 
/*     */   
/*  78 */   public String getTimerName() { return this.timerName; }
/*     */ 
/*     */ 
/*     */   
/*  82 */   public boolean isDaemon() { return this.daemon; }
/*     */ 
/*     */ 
/*     */   
/*  86 */   public void setDaemon(boolean daemon) { this.daemon = daemon; }
/*     */ 
/*     */ 
/*     */   
/*  90 */   public long getDelay() { return this.delay; }
/*     */ 
/*     */ 
/*     */   
/*  94 */   public void setDelay(long delay) { this.delay = delay; }
/*     */ 
/*     */ 
/*     */   
/*  98 */   public boolean isFixedRate() { return this.fixedRate; }
/*     */ 
/*     */ 
/*     */   
/* 102 */   public void setFixedRate(boolean fixedRate) { this.fixedRate = fixedRate; }
/*     */ 
/*     */ 
/*     */   
/* 106 */   public long getPeriod() { return this.period; }
/*     */ 
/*     */ 
/*     */   
/* 110 */   public void setPeriod(long period) { this.period = period; }
/*     */ 
/*     */ 
/*     */   
/* 114 */   public Date getTime() { return this.time; }
/*     */ 
/*     */ 
/*     */   
/* 118 */   public void setTime(Date time) { this.time = time; }
/*     */ 
/*     */ 
/*     */   
/* 122 */   public boolean isSingleton() { return true; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\pojo\timer\TimerEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.processor.ProcessorEndpoint,"/*    */ package org.apache.camel.component.processor;
/*    */ 
/*    */ import org.apache.camel.Component;
/*    */ import org.apache.camel.Consumer;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Producer;
/*    */ import org.apache.camel.impl.DefaultEndpoint;
/*    */ import org.apache.camel.impl.DefaultExchange;
/*    */ import org.apache.camel.impl.DefaultProducer;
/*    */ import org.apache.camel.processor.loadbalancer.LoadBalancer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ProcessorEndpoint
/*    */   extends DefaultEndpoint<Exchange>
/*    */ {
/*    */   private final Processor processor;
/*    */   private final LoadBalancer loadBalancer;
/*    */   
/*    */   protected ProcessorEndpoint(String endpointUri, Component component, Processor processor, LoadBalancer loadBalancer) {
/* 41 */     super(endpointUri, component);
/* 42 */     this.processor = processor;
/* 43 */     this.loadBalancer = loadBalancer;
/*    */   }
/*    */ 
/*    */   
/* 47 */   public Exchange createExchange() { return (Exchange)new DefaultExchange(getContext()); }
/*    */ 
/*    */   
/*    */   public Producer<Exchange> createProducer() throws Exception {
/* 51 */     return (Producer<Exchange>)new DefaultProducer<Exchange>((Endpoint)this)
/*    */       {
/* 53 */         public void process(Exchange exchange) throws Exception { ProcessorEndpoint.this.onExchange(exchange); }
/*    */       };
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 59 */   public Consumer<Exchange> createConsumer(Processor processor) throws Exception { return (Consumer<Exchange>)new ProcessorEndpointConsumer(this, processor); }
/*    */ 
/*    */ 
/*    */   
/* 63 */   public Processor getProcessor() { return this.processor; }
/*    */ 
/*    */ 
/*    */   
/* 67 */   public LoadBalancer getLoadBalancer() { return this.loadBalancer; }
/*    */ 
/*    */   
/*    */   protected void onExchange(Exchange exchange) throws Exception {
/* 71 */     this.processor.process(exchange);
/*    */ 
/*    */     
/* 74 */     this.loadBalancer.process(exchange);
/*    */   }
/*    */ 
/*    */   
/* 78 */   public boolean isSingleton() { return true; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\processor\ProcessorEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.processor.ProcessorEndpointConsumer,"/*    */ package org.apache.camel.component.processor;
/*    */ 
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.DefaultConsumer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ProcessorEndpointConsumer
/*    */   extends DefaultConsumer<Exchange>
/*    */ {
/*    */   private final ProcessorEndpoint endpoint;
/*    */   
/*    */   public ProcessorEndpointConsumer(ProcessorEndpoint endpoint, Processor processor) {
/* 31 */     super((Endpoint)endpoint, processor);
/* 32 */     this.endpoint = endpoint;
/*    */   }
/*    */ 
/*    */   
/*    */   protected void doStart() throws Exception {
/* 37 */     super.doStart();
/* 38 */     this.endpoint.getLoadBalancer().addProcessor(getProcessor());
/*    */   }
/*    */ 
/*    */   
/*    */   protected void doStop() throws Exception {
/* 43 */     this.endpoint.getLoadBalancer().removeProcessor(getProcessor());
/* 44 */     super.doStop();
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\processor\ProcessorEndpointConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.queue.QueueComponent,"/*    */ package org.apache.camel.component.queue;
/*    */ 
/*    */ import java.util.Map;
/*    */ import java.util.concurrent.BlockingQueue;
/*    */ import java.util.concurrent.LinkedBlockingQueue;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.impl.DefaultComponent;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueueComponent<E extends Exchange>
/*    */   extends DefaultComponent<E>
/*    */ {
/* 40 */   public BlockingQueue<E> createQueue() { return new LinkedBlockingQueue(); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 45 */   protected Endpoint<E> createEndpoint(String uri, String remaining, Map parameters) throws Exception { return (Endpoint<E>)new QueueEndpoint<E>(uri, this); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\queue\QueueComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.queue.QueueEndpoint,"/*    */ package org.apache.camel.component.queue;
/*    */ 
/*    */ import java.util.concurrent.BlockingQueue;
/*    */ import org.apache.camel.Component;
/*    */ import org.apache.camel.Consumer;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Producer;
/*    */ import org.apache.camel.impl.DefaultEndpoint;
/*    */ import org.apache.camel.impl.DefaultExchange;
/*    */ import org.apache.camel.impl.DefaultProducer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueueEndpoint<E extends Exchange>
/*    */   extends DefaultEndpoint<E>
/*    */ {
/*    */   private BlockingQueue<E> queue;
/*    */   
/*    */   public QueueEndpoint(String uri, QueueComponent<E> component) {
/* 40 */     super(uri, (Component)component);
/* 41 */     this.queue = component.createQueue();
/*    */   }
/*    */   
/*    */   public Producer<E> createProducer() throws Exception {
/* 45 */     return (Producer<E>)new DefaultProducer((Endpoint)this)
/*    */       {
/* 47 */         public void process(Exchange exchange) { QueueEndpoint.this.queue.add(QueueEndpoint.this.toExchangeType(exchange)); }
/*    */       };
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 53 */   public Consumer<E> createConsumer(Processor processor) throws Exception { return new QueueEndpointConsumer<E>(this, processor); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public E createExchange() { return (E)new DefaultExchange(getContext()); }
/*    */ 
/*    */ 
/*    */   
/* 63 */   public BlockingQueue<E> getQueue() { return this.queue; }
/*    */ 
/*    */ 
/*    */   
/* 67 */   public boolean isSingleton() { return true; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\queue\QueueEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.queue.QueueEndpointConsumer,"/*    */ package org.apache.camel.component.queue;
/*    */ 
/*    */ import java.util.concurrent.TimeUnit;
/*    */ import org.apache.camel.Consumer;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueueEndpointConsumer<E extends Exchange>
/*    */   extends ServiceSupport
/*    */   implements Consumer<E>, Runnable
/*    */ {
/*    */   private QueueEndpoint<E> endpoint;
/*    */   private Processor processor;
/*    */   private Thread thread;
/*    */   
/*    */   public QueueEndpointConsumer(QueueEndpoint<E> endpoint, Processor processor) {
/* 36 */     this.endpoint = endpoint;
/* 37 */     this.processor = processor;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public String toString() { return ""QueueEndpointConsumer: "" + this.endpoint.getEndpointUri(); }
/*    */ 
/*    */   
/*    */   public void run() {
/* 46 */     while (!isStopping()) {
/*    */       Exchange exchange1;
/*    */       try {
/* 49 */         exchange1 = this.endpoint.getQueue().poll(1000L, TimeUnit.MILLISECONDS);
/*    */       }
/* 51 */       catch (InterruptedException e) {
/*    */         break;
/*    */       } 
/* 54 */       if (exchange1 != null && !isStopping()) {
/*    */         try {
/* 56 */           this.processor.process(exchange1);
/*    */         }
/* 58 */         catch (Throwable e) {
/* 59 */           e.printStackTrace();
/*    */         } 
/*    */       }
/*    */     } 
/*    */   }
/*    */   
/*    */   protected void doStart() throws Exception {
/* 66 */     this.thread = new Thread(this, this.endpoint.getEndpointUri());
/* 67 */     this.thread.setDaemon(true);
/* 68 */     this.thread.start();
/*    */   }
/*    */ 
/*    */   
/* 72 */   protected void doStop() throws Exception { this.thread.join(); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\component\queue\QueueEndpointConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.CollectionConverter,"/*    */ package org.apache.camel.converter;
/*    */ 
/*    */ import java.util.Arrays;
/*    */ import java.util.Collection;
/*    */ import java.util.HashSet;
/*    */ import java.util.List;
/*    */ import java.util.Map;
/*    */ import java.util.Set;
/*    */ import org.apache.camel.Converter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ @Converter
/*    */ public class CollectionConverter
/*    */ {
/*    */   @Converter
/*    */   public static Object[] toArray(Collection value) {
/* 42 */     if (value == null) {
/* 43 */       return null;
/*    */     }
/* 45 */     return value.toArray();
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   @Converter
/* 53 */   public static List toList(Object[] array) { return Arrays.asList(array); }
/*    */ 
/*    */   
/*    */   @Converter
/*    */   public static Set toSet(Object[] array) {
/* 58 */     Set<Object> answer = new HashSet();
/* 59 */     for (Object element : array) {
/* 60 */       answer.add(element);
/*    */     }
/* 62 */     return answer;
/*    */   }
/*    */ 
/*    */   
/*    */   @Converter
/* 67 */   public static Set toSet(Collection<?> collection) { return new HashSet(collection); }
/*    */ 
/*    */ 
/*    */   
/*    */   @Converter
/* 72 */   public static Set toSet(Map map) { return map.entrySet(); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\CollectionConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.HasAnnotation,"package org.apache.camel.converter;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface HasAnnotation {
  Class value();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\HasAnnotation.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.IOConverter,"/*     */ package org.apache.camel.converter;
/*     */ 
/*     */ import java.io.BufferedInputStream;
/*     */ import java.io.BufferedOutputStream;
/*     */ import java.io.BufferedReader;
/*     */ import java.io.BufferedWriter;
/*     */ import java.io.ByteArrayInputStream;
/*     */ import java.io.File;
/*     */ import java.io.FileInputStream;
/*     */ import java.io.FileNotFoundException;
/*     */ import java.io.FileOutputStream;
/*     */ import java.io.FileReader;
/*     */ import java.io.FileWriter;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.io.InputStreamReader;
/*     */ import java.io.OutputStream;
/*     */ import java.io.OutputStreamWriter;
/*     */ import java.io.Reader;
/*     */ import java.io.StringReader;
/*     */ import java.io.Writer;
/*     */ import org.apache.camel.Converter;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ @Converter
/*     */ public class IOConverter
/*     */ {
/*  35 */   private static final transient Log log = LogFactory.getLog(IOConverter.class);
/*     */ 
/*     */   
/*     */   @Converter
/*  39 */   public static InputStream toInputStream(File file) throws FileNotFoundException { return new BufferedInputStream(new FileInputStream(file)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  44 */   public static BufferedReader toReader(File file) throws FileNotFoundException { return new BufferedReader(new FileReader(file)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  49 */   public static OutputStream toOutputStream(File file) throws FileNotFoundException { return new BufferedOutputStream(new FileOutputStream(file)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  54 */   public static BufferedWriter toWriter(File file) throws IOException { return new BufferedWriter(new FileWriter(file)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  59 */   public static Reader toReader(InputStream in) throws FileNotFoundException { return new InputStreamReader(in); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  64 */   public static Writer toWriter(OutputStream out) throws FileNotFoundException { return new OutputStreamWriter(out); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  71 */   public static StringReader toReader(String text) { return new StringReader(text); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  76 */   public static InputStream toInputStream(String text) { return toInputStream(text.getBytes()); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  82 */   public static byte[] toByteArray(String text) { return text.getBytes(); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*  87 */   public static String toString(byte[] data) { return new String(data); }
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public static String toString(Reader reader) throws IOException {
/*  92 */     if (reader instanceof BufferedReader) {
/*  93 */       return toString((BufferedReader)reader);
/*     */     }
/*     */     
/*  96 */     return toString(new BufferedReader(reader));
/*     */   }
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public static String toString(BufferedReader reader) throws IOException {
/* 102 */     if (reader == null) {
/* 103 */       return null;
/*     */     }
/*     */     try {
/* 106 */       StringBuilder builder = new StringBuilder();
/* 107 */       boolean first = true;
/*     */       while (true) {
/* 109 */         String line = reader.readLine();
/* 110 */         if (line == null) {
/* 111 */           return builder.toString();
/*     */         }
/* 113 */         if (first) {
/* 114 */           first = false;
/*     */         } else {
/*     */           
/* 117 */           builder.append(""\n"");
/*     */         } 
/* 119 */         builder.append(line);
/*     */       } 
/*     */     } finally {
/*     */       
/*     */       try {
/* 124 */         reader.close();
/*     */       }
/* 126 */       catch (IOException e) {
/* 127 */         log.warn(""Failed to close stream: "" + e, e);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   @Converter
/* 134 */   public static String toString(InputStream in) throws IOException { return toString(toReader(in)); }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/* 139 */   public static InputStream toInputStream(byte[] data) { return new ByteArrayInputStream(data); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\IOConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.NIOConverter,"/*    */ package org.apache.camel.converter;
/*    */ 
/*    */ import java.nio.ByteBuffer;
/*    */ import org.apache.camel.Converter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ @Converter
/*    */ public class NIOConverter
/*    */ {
/*    */   @Converter
/* 36 */   public static byte[] toByteArray(ByteBuffer buffer) { return buffer.array(); }
/*    */ 
/*    */ 
/*    */   
/*    */   @Converter
/* 41 */   public static ByteBuffer toByteBuffer(byte[] data) { return ByteBuffer.wrap(data); }
/*    */ 
/*    */   
/*    */   @Converter
/*    */   public static ByteBuffer toByteBuffer(String value) {
/* 46 */     ByteBuffer buf = ByteBuffer.allocate(value.length());
/* 47 */     byte[] bytes = value.getBytes();
/* 48 */     buf.put(bytes);
/* 49 */     return buf;
/*    */   }
/*    */   @Converter
/*    */   public static ByteBuffer toByteBuffer(Short value) {
/* 53 */     ByteBuffer buf = ByteBuffer.allocate(2);
/* 54 */     buf.putShort(value.shortValue());
/* 55 */     return buf;
/*    */   }
/*    */   @Converter
/*    */   public static ByteBuffer toByteBuffer(Integer value) {
/* 59 */     ByteBuffer buf = ByteBuffer.allocate(4);
/* 60 */     buf.putInt(value.intValue());
/* 61 */     return buf;
/*    */   }
/*    */   @Converter
/*    */   public static ByteBuffer toByteBuffer(Long value) {
/* 65 */     ByteBuffer buf = ByteBuffer.allocate(8);
/* 66 */     buf.putLong(value.longValue());
/* 67 */     return buf;
/*    */   }
/*    */   @Converter
/*    */   public static ByteBuffer toByteBuffer(Float value) {
/* 71 */     ByteBuffer buf = ByteBuffer.allocate(4);
/* 72 */     buf.putFloat(value.floatValue());
/* 73 */     return buf;
/*    */   }
/*    */   @Converter
/*    */   public static ByteBuffer toByteBuffer(Double value) {
/* 77 */     ByteBuffer buf = ByteBuffer.allocate(8);
/* 78 */     buf.putDouble(value.doubleValue());
/* 79 */     return buf;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\NIOConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.ObjectConverter,"/*    */ package org.apache.camel.converter;
/*    */ 
/*    */ import java.util.Arrays;
/*    */ import java.util.Collection;
/*    */ import java.util.Collections;
/*    */ import java.util.Iterator;
/*    */ import org.apache.camel.Converter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ @Converter
/*    */ public class ObjectConverter
/*    */ {
/* 37 */   public static boolean isCollection(Object value) { return (value instanceof Collection || (value != null && value.getClass().isArray())); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   @Converter
/*    */   public static Iterator iterator(Object value) {
/* 46 */     if (value == null) {
/* 47 */       return Collections.EMPTY_LIST.iterator();
/*    */     }
/* 49 */     if (value instanceof Collection) {
/* 50 */       Collection collection = (Collection)value;
/* 51 */       return collection.iterator();
/*    */     } 
/* 53 */     if (value.getClass().isArray())
/*    */     {
/* 55 */       return Arrays.asList(new Object[] { value }).iterator();
/*    */     }
/*    */     
/* 58 */     return Collections.singletonList(value).iterator();
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   @Converter
/*    */   public static boolean toBool(Object value) {
/* 68 */     Boolean answer = toBoolean(value);
/* 69 */     if (answer != null) {
/* 70 */       return answer.booleanValue();
/*    */     }
/* 72 */     return false;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   @Converter
/*    */   public static Boolean toBoolean(Object value) {
/* 81 */     if (value instanceof Boolean) {
/* 82 */       return (Boolean)value;
/*    */     }
/* 84 */     if (value instanceof String) {
/* 85 */       return ""true"".equalsIgnoreCase(value.toString()) ? Boolean.TRUE : Boolean.FALSE;
/*    */     }
/* 87 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\ObjectConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.jaxp.BytesSource,"/*    */ package org.apache.camel.converter.jaxp;
/*    */ 
/*    */ import java.io.ByteArrayInputStream;
/*    */ import java.io.InputStream;
/*    */ import java.io.InputStreamReader;
/*    */ import java.io.Reader;
/*    */ import javax.xml.transform.stream.StreamSource;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class BytesSource
/*    */   extends StreamSource
/*    */ {
/*    */   private byte[] data;
/*    */   
/* 37 */   public BytesSource(byte[] data) { this.data = data; }
/*    */ 
/*    */   
/*    */   public BytesSource(byte[] data, String systemId) {
/* 41 */     this.data = data;
/* 42 */     setSystemId(systemId);
/*    */   }
/*    */ 
/*    */   
/* 46 */   public InputStream getInputStream() { return new ByteArrayInputStream(this.data); }
/*    */ 
/*    */ 
/*    */   
/* 50 */   public Reader getReader() { return new InputStreamReader(getInputStream()); }
/*    */ 
/*    */ 
/*    */   
/* 54 */   public byte[] getData() { return this.data; }
/*    */ 
/*    */ 
/*    */   
/* 58 */   public String toString() { return ""BytesSource["" + new String(this.data) + ""]""; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\jaxp\BytesSource.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.jaxp.StringSource,"/*    */ package org.apache.camel.converter.jaxp;
/*    */ 
/*    */ import java.io.ByteArrayInputStream;
/*    */ import java.io.InputStream;
/*    */ import java.io.Reader;
/*    */ import java.io.Serializable;
/*    */ import java.io.StringReader;
/*    */ import java.io.UnsupportedEncodingException;
/*    */ import javax.xml.transform.stream.StreamSource;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StringSource
/*    */   extends StreamSource
/*    */   implements Serializable
/*    */ {
/*    */   private final String text;
/* 38 */   private String encoding = ""UTF-8"";
/*    */   
/*    */   public StringSource(String text) {
/* 41 */     if (text == null) {
/* 42 */       throw new NullPointerException(""text can not be null"");
/*    */     }
/* 44 */     this.text = text;
/*    */   }
/*    */   
/*    */   public StringSource(String text, String systemId) {
/* 48 */     this(text);
/* 49 */     setSystemId(systemId);
/*    */   }
/*    */   
/*    */   public StringSource(String text, String systemId, String encoding) {
/* 53 */     this.text = text;
/* 54 */     this.encoding = encoding;
/* 55 */     setSystemId(systemId);
/*    */   }
/*    */   
/*    */   public InputStream getInputStream() {
/*    */     try {
/* 60 */       return new ByteArrayInputStream(this.text.getBytes(this.encoding));
/* 61 */     } catch (UnsupportedEncodingException e) {
/* 62 */       throw new RuntimeException(e);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 67 */   public Reader getReader() { return new StringReader(this.text); }
/*    */ 
/*    */ 
/*    */   
/* 71 */   public String toString() { return ""StringSource["" + this.text + ""]""; }
/*    */ 
/*    */ 
/*    */   
/* 75 */   public String getText() { return this.text; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\jaxp\StringSource.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.converter.jaxp.XmlConverter,"/*     */ package org.apache.camel.converter.jaxp;
/*     */ 
/*     */ import java.io.ByteArrayInputStream;
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.io.InputStreamReader;
/*     */ import java.io.Reader;
/*     */ import java.io.StringReader;
/*     */ import java.io.StringWriter;
/*     */ import java.lang.reflect.Constructor;
/*     */ import javax.xml.parsers.DocumentBuilder;
/*     */ import javax.xml.parsers.DocumentBuilderFactory;
/*     */ import javax.xml.parsers.ParserConfigurationException;
/*     */ import javax.xml.transform.Result;
/*     */ import javax.xml.transform.Source;
/*     */ import javax.xml.transform.Transformer;
/*     */ import javax.xml.transform.TransformerConfigurationException;
/*     */ import javax.xml.transform.TransformerException;
/*     */ import javax.xml.transform.TransformerFactory;
/*     */ import javax.xml.transform.dom.DOMResult;
/*     */ import javax.xml.transform.dom.DOMSource;
/*     */ import javax.xml.transform.sax.SAXSource;
/*     */ import javax.xml.transform.stream.StreamResult;
/*     */ import javax.xml.transform.stream.StreamSource;
/*     */ import org.apache.camel.Converter;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ import org.w3c.dom.Document;
/*     */ import org.w3c.dom.Element;
/*     */ import org.w3c.dom.Node;
/*     */ import org.xml.sax.InputSource;
/*     */ import org.xml.sax.SAXException;
/*     */ import org.xml.sax.XMLReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ @Converter
/*     */ public class XmlConverter
/*     */ {
/*     */   public static final String DEFAULT_CHARSET_PROPERTY = ""org.apache.camel.default.charset"";
/*  65 */   public static String defaultCharset = ObjectHelper.getSystemProperty(""org.apache.camel.default.charset"", ""UTF-8"");
/*     */ 
/*     */ 
/*     */   
/*     */   private DocumentBuilderFactory documentBuilderFactory;
/*     */ 
/*     */   
/*     */   private TransformerFactory transformerFactory;
/*     */ 
/*     */   
/*     */   private static final Class dom2SaxClass;
/*     */ 
/*     */ 
/*     */   
/*     */   static  {
/*  80 */     Class<?> cl = null;
/*     */     try {
/*  82 */       cl = Class.forName(""org.apache.xalan.xsltc.trax.DOM2SAX"");
/*  83 */     } catch (Throwable t) {}
/*  84 */     dom2SaxClass = cl;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public XmlConverter() {}
/*     */ 
/*     */   
/*  92 */   public XmlConverter(DocumentBuilderFactory documentBuilderFactory) { this.documentBuilderFactory = documentBuilderFactory; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void toResult(Source source, Result result) throws TransformerException {
/* 100 */     if (source == null) {
/*     */       return;
/*     */     }
/* 103 */     Transformer transformer = createTransfomer();
/* 104 */     if (transformer == null) {
/* 105 */       throw new TransformerException(""Could not create a transformer - JAXP is misconfigured!"");
/*     */     }
/* 107 */     transformer.setOutputProperty(""encoding"", defaultCharset);
/* 108 */     transformer.transform(source, result);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/* 116 */   public BytesSource toSource(byte[] data) { return new BytesSource(data); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/* 125 */   public StringSource toSource(String data) { return new StringSource(data); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/* 133 */   public DOMSource toSource(Document document) { return new DOMSource(document); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public String toString(Source source) throws TransformerException {
/* 141 */     if (source == null)
/* 142 */       return null; 
/* 143 */     if (source instanceof StringSource)
/* 144 */       return ((StringSource)source).getText(); 
/* 145 */     if (source instanceof BytesSource) {
/* 146 */       return new String(((BytesSource)source).getData());
/*     */     }
/* 148 */     StringWriter buffer = new StringWriter();
/* 149 */     toResult(source, new StreamResult(buffer));
/* 150 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/* 159 */   public String toString(Node node) throws TransformerException { return toString(new DOMSource(node)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
/* 168 */     if (source instanceof DOMSource) {
/* 169 */       return (DOMSource)source;
/*     */     }
/* 171 */     if (source instanceof SAXSource) {
/* 172 */       return toDOMSourceFromSAX((SAXSource)source);
/*     */     }
/* 174 */     if (source instanceof StreamSource) {
/* 175 */       return toDOMSourceFromStream((StreamSource)source);
/*     */     }
/*     */     
/* 178 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {
/* 188 */     if (source instanceof SAXSource) {
/* 189 */       return (SAXSource)source;
/*     */     }
/* 191 */     if (source instanceof DOMSource) {
/* 192 */       return toSAXSourceFromDOM((DOMSource)source);
/*     */     }
/* 194 */     if (source instanceof StreamSource) {
/* 195 */       return toSAXSourceFromStream((StreamSource)source);
/*     */     }
/*     */     
/* 198 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public StreamSource toStreamSource(Source source) throws TransformerException {
/* 204 */     if (source instanceof StreamSource)
/* 205 */       return (StreamSource)source; 
/* 206 */     if (source instanceof DOMSource)
/* 207 */       return toStreamSourceFromDOM((DOMSource)source); 
/* 208 */     if (source instanceof SAXSource) {
/* 209 */       return toStreamSourceFromSAX((SAXSource)source);
/*     */     }
/* 211 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {
/* 217 */     InputSource inputSource = source.getInputSource();
/* 218 */     if (inputSource != null) {
/* 219 */       if (inputSource.getCharacterStream() != null) {
/* 220 */         return new StreamSource(inputSource.getCharacterStream());
/*     */       }
/* 222 */       if (inputSource.getByteStream() != null) {
/* 223 */         return new StreamSource(inputSource.getByteStream());
/*     */       }
/*     */     } 
/* 226 */     String result = toString(source);
/* 227 */     return new StringSource(result);
/*     */   }
/*     */   
/*     */   @Converter
/*     */   public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {
/* 232 */     String result = toString(source);
/* 233 */     return new StringSource(result);
/*     */   }
/*     */   
/*     */   @Converter
/*     */   public SAXSource toSAXSourceFromStream(StreamSource source) {
/*     */     InputSource inputSource;
/* 239 */     if (source.getReader() != null) {
/* 240 */       inputSource = new InputSource(source.getReader());
/*     */     } else {
/* 242 */       inputSource = new InputSource(source.getInputStream());
/*     */     } 
/* 244 */     inputSource.setSystemId(source.getSystemId());
/* 245 */     inputSource.setPublicId(source.getPublicId());
/* 246 */     return new SAXSource(inputSource);
/*     */   }
/*     */   
/*     */   @Converter
/*     */   public Reader toReaderFromSource(Source src) throws TransformerException {
/* 251 */     StreamSource stSrc = toStreamSource(src);
/* 252 */     Reader r = stSrc.getReader();
/* 253 */     if (r == null) {
/* 254 */       r = new InputStreamReader(stSrc.getInputStream());
/*     */     }
/* 256 */     return r;
/*     */   }
/*     */   
/*     */   @Converter
/*     */   public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {
/* 261 */     DocumentBuilder builder = createDocumentBuilder();
/* 262 */     String systemId = source.getSystemId();
/* 263 */     Document document = null;
/* 264 */     Reader reader = source.getReader();
/* 265 */     if (reader != null) {
/* 266 */       document = builder.parse(new InputSource(reader));
/*     */     } else {
/* 268 */       InputStream inputStream = source.getInputStream();
/* 269 */       if (inputStream != null) {
/* 270 */         InputSource inputsource = new InputSource(inputStream);
/* 271 */         inputsource.setSystemId(systemId);
/* 272 */         document = builder.parse(inputsource);
/*     */       } else {
/*     */         
/* 275 */         throw new IOException(""No input stream or reader available"");
/*     */       } 
/*     */     } 
/* 278 */     return new DOMSource(document, systemId);
/*     */   }
/*     */   
/*     */   @Converter
/*     */   public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {
/* 283 */     if (dom2SaxClass != null) {
/*     */       try {
/* 285 */         Constructor<XMLReader> cns = dom2SaxClass.getConstructor(new Class[] { Node.class });
/* 286 */         XMLReader converter = cns.newInstance(new Object[] { source.getNode() });
/* 287 */         return new SAXSource(converter, new InputSource());
/* 288 */       } catch (Exception e) {
/* 289 */         throw new TransformerException(e);
/*     */       } 
/*     */     }
/* 292 */     String str = toString(source);
/* 293 */     StringReader reader = new StringReader(str);
/* 294 */     return new SAXSource(new InputSource(reader));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/* 300 */   public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException { return new DOMSource(toDOMNodeFromSAX(source)); }
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
/* 305 */     DOMResult result = new DOMResult();
/* 306 */     toResult(source, result);
/* 307 */     return result.getNode();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
/* 318 */     DOMSource domSrc = toDOMSource(source);
/* 319 */     return (domSrc != null) ? domSrc.getNode() : null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
/* 334 */     Node node = toDOMNode(source);
/* 335 */     return toDOMElement(node);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Element toDOMElement(Node node) throws TransformerException {
/* 350 */     if (node instanceof Document) {
/* 351 */       return ((Document)node).getDocumentElement();
/*     */     }
/* 353 */     if (node instanceof Element) {
/* 354 */       return (Element)node;
/*     */     }
/*     */     
/* 357 */     throw new TransformerException(""Unable to convert DOM node to an Element"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {
/* 369 */     DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
/* 370 */     return documentBuilder.parse(new ByteArrayInputStream(data));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {
/* 381 */     DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
/* 382 */     return documentBuilder.parse(in);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {
/* 393 */     DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
/* 394 */     return documentBuilder.parse(in);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/* 405 */   public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException { return toDOMDocument(text.getBytes()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {
/* 416 */     DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
/* 417 */     return documentBuilder.parse(file);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
/* 433 */     Node node = toDOMNode(source);
/* 434 */     return toDOMDocument(node);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   @Converter
/*     */   public Document toDOMDocument(Node node) throws ParserConfigurationException, TransformerException {
/* 452 */     if (node instanceof Document) {
/* 453 */       return (Document)node;
/*     */     }
/* 455 */     if (node instanceof Element) {
/* 456 */       Element elem = (Element)node;
/*     */       
/* 458 */       if (elem.getOwnerDocument().getDocumentElement() == elem) {
/* 459 */         return elem.getOwnerDocument();
/*     */       }
/*     */       
/* 462 */       Document doc = createDocument();
/* 463 */       doc.appendChild(doc.importNode(node, true));
/* 464 */       return doc;
/*     */     } 
/*     */ 
/*     */     
/* 468 */     throw new TransformerException(""Unable to convert DOM node to a Document"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DocumentBuilderFactory getDocumentBuilderFactory() {
/* 475 */     if (this.documentBuilderFactory == null) {
/* 476 */       this.documentBuilderFactory = createDocumentBuilderFactory();
/*     */     }
/* 478 */     return this.documentBuilderFactory;
/*     */   }
/*     */ 
/*     */   
/* 482 */   public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) { this.documentBuilderFactory = documentBuilderFactory; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DocumentBuilderFactory createDocumentBuilderFactory() {
/* 489 */     DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
/* 490 */     factory.setNamespaceAware(true);
/* 491 */     factory.setIgnoringElementContentWhitespace(true);
/* 492 */     factory.setIgnoringComments(true);
/* 493 */     return factory;
/*     */   }
/*     */ 
/*     */   
/*     */   public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {
/* 498 */     DocumentBuilderFactory factory = getDocumentBuilderFactory();
/* 499 */     return factory.newDocumentBuilder();
/*     */   }
/*     */   
/*     */   public Document createDocument() throws ParserConfigurationException {
/* 503 */     DocumentBuilder builder = createDocumentBuilder();
/* 504 */     return builder.newDocument();
/*     */   }
/*     */   
/*     */   public TransformerFactory getTransformerFactory() {
/* 508 */     if (this.transformerFactory == null) {
/* 509 */       this.transformerFactory = createTransformerFactory();
/*     */     }
/* 511 */     return this.transformerFactory;
/*     */   }
/*     */ 
/*     */   
/* 515 */   public void setTransformerFactory(TransformerFactory transformerFactory) { this.transformerFactory = transformerFactory; }
/*     */ 
/*     */   
/*     */   public Transformer createTransfomer() throws TransformerConfigurationException {
/* 519 */     TransformerFactory factory = getTransformerFactory();
/* 520 */     return factory.newTransformer();
/*     */   }
/*     */   
/*     */   public TransformerFactory createTransformerFactory() {
/* 524 */     TransformerFactory answer = TransformerFactory.newInstance();
/* 525 */     return answer;
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\converter\jaxp\XmlConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.BinaryPredicateSupport,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Predicate;
/*    */ import org.apache.camel.util.ObjectHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class BinaryPredicateSupport<E extends Exchange>
/*    */   implements Predicate<E>
/*    */ {
/*    */   private final Expression<E> left;
/*    */   private final Expression<E> right;
/*    */   
/*    */   protected BinaryPredicateSupport(Expression<E> left, Expression<E> right) {
/* 37 */     ObjectHelper.notNull(left, ""left"");
/* 38 */     ObjectHelper.notNull(right, ""right"");
/*    */     
/* 40 */     this.left = left;
/* 41 */     this.right = right;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 46 */   public String toString() { return this.left + "" "" + getOperationText() + "" "" + this.right; }
/*    */ 
/*    */   
/*    */   public boolean matches(E exchange) {
/* 50 */     Object leftValue = this.left.evaluate((Exchange)exchange);
/* 51 */     Object rightValue = this.right.evaluate((Exchange)exchange);
/* 52 */     return matches(exchange, leftValue, rightValue);
/*    */   }
/*    */   
/*    */   public void assertMatches(String text, E exchange) {
/* 56 */     Object leftValue = this.left.evaluate((Exchange)exchange);
/* 57 */     Object rightValue = this.right.evaluate((Exchange)exchange);
/* 58 */     if (!matches(exchange, leftValue, rightValue)) {
/* 59 */       throw new AssertionError(assertionFailureMessage(exchange, leftValue, rightValue));
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 68 */   protected String assertionFailureMessage(E exchange, Object leftValue, Object rightValue) { return this + "" failed on "" + exchange + "" with left value <"" + leftValue + ""> right value <"" + rightValue + "">""; }
/*    */   
/*    */   protected abstract boolean matches(E paramE, Object paramObject1, Object paramObject2);
/*    */   
/*    */   protected abstract String getOperationText();
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\BinaryPredicateSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.CachingInjector,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.impl.converter.TypeConverterRegistry;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CachingInjector<T>
/*    */ {
/*    */   private final TypeConverterRegistry repository;
/*    */   private final Class<T> type;
/*    */   private T instance;
/*    */   
/*    */   public CachingInjector(TypeConverterRegistry repository, Class<T> type) {
/* 32 */     this.repository = repository;
/* 33 */     this.type = type;
/*    */   }
/*    */   
/*    */   public synchronized T newInstance() {
/* 37 */     if (this.instance == null) {
/* 38 */       this.instance = createInstance(this.type);
/*    */     }
/* 40 */     return this.instance;
/*    */   }
/*    */ 
/*    */   
/* 44 */   protected T createInstance(Class<T> type) { return (T)this.repository.getInjector().newInstance(type); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\CachingInjector.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultCamelContext,"/*     */ package org.apache.camel.impl;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import java.util.concurrent.Callable;
/*     */ import org.apache.camel.CamelContext;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.ResolveEndpointFailedException;
/*     */ import org.apache.camel.Route;
/*     */ import org.apache.camel.RuntimeCamelException;
/*     */ import org.apache.camel.Service;
/*     */ import org.apache.camel.TypeConverter;
/*     */ import org.apache.camel.builder.RouteBuilder;
/*     */ import org.apache.camel.impl.converter.DefaultTypeConverter;
/*     */ import org.apache.camel.spi.ComponentResolver;
/*     */ import org.apache.camel.spi.ExchangeConverter;
/*     */ import org.apache.camel.spi.Injector;
/*     */ import org.apache.camel.util.FactoryFinder;
/*     */ import org.apache.camel.util.NoFactoryAvailableException;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ import org.apache.camel.util.ServiceHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DefaultCamelContext
/*     */   extends ServiceSupport
/*     */   implements CamelContext, Service
/*     */ {
/*  55 */   private Map<String, Endpoint> endpoints = new HashMap<String, Endpoint>();
/*  56 */   private Map<String, Component> components = new HashMap<String, Component>();
/*     */   private List<Route> routes;
/*  58 */   private List<Service> servicesToClose = new ArrayList<Service>();
/*     */   
/*     */   private TypeConverter typeConverter;
/*     */   
/*     */   private ExchangeConverter exchangeConverter;
/*     */   
/*     */   private Injector injector;
/*     */   private ComponentResolver componentResolver;
/*     */   private boolean autoCreateComponents = true;
/*     */   
/*     */   public void addComponent(String componentName, Component component) {
/*  69 */     if (component == null) {
/*  70 */       throw new IllegalArgumentException(""Component cannot be null"");
/*     */     }
/*  72 */     synchronized (this.components) {
/*  73 */       if (this.components.containsKey(componentName)) {
/*  74 */         throw new IllegalArgumentException(""Component previously added: "" + componentName);
/*     */       }
/*  76 */       component.setCamelContext(this);
/*  77 */       this.components.put(componentName, component);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Component getComponent(String name) {
/*  84 */     synchronized (this.components) {
/*  85 */       Component component = this.components.get(name);
/*  86 */       if (component == null && this.autoCreateComponents) {
/*     */         try {
/*  88 */           component = getComponentResolver().resolveComponent(name, this);
/*  89 */           if (component != null) {
/*  90 */             addComponent(name, component);
/*  91 */             if (isStarted())
/*     */             {
/*     */               
/*  94 */               ServiceHelper.startServices(new Object[] { component });
/*     */             }
/*     */           }
/*     */         
/*  98 */         } catch (Exception e) {
/*  99 */           throw new RuntimeCamelException(""Could not auto create component: "" + name, e);
/*     */         } 
/*     */       }
/* 102 */       return component;
/*     */     } 
/*     */   }
/*     */   
/*     */   public <T extends Component> T getComponent(String name, Class<T> componentType) {
/* 107 */     Component component = getComponent(name);
/* 108 */     if (componentType.isInstance(component)) {
/* 109 */       return componentType.cast(component);
/*     */     }
/*     */     
/* 112 */     throw new IllegalArgumentException(""The component is not of type: "" + componentType + "" but is: "" + component);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Component removeComponent(String componentName) {
/* 123 */     synchronized (this.components) {
/* 124 */       return this.components.remove(componentName);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Component getOrCreateComponent(String componentName, Callable<Component> factory) {
/* 137 */     synchronized (this.components) {
/* 138 */       Component component = this.components.get(componentName);
/* 139 */       if (component == null) {
/*     */         try {
/* 141 */           component = factory.call();
/* 142 */           if (component == null) {
/* 143 */             throw new RuntimeCamelException(""Factory failed to create the "" + componentName + "" component, it returned null."");
/*     */           }
/* 145 */           this.components.put(componentName, component);
/* 146 */           component.setCamelContext(this);
/*     */         }
/* 148 */         catch (Exception e) {
/* 149 */           throw new RuntimeCamelException(""Factory failed to create the "" + componentName + "" component"", e);
/*     */         } 
/*     */       }
/* 152 */       return component;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection<Endpoint> getSingletonEndpoints() {
/* 160 */     synchronized (this.endpoints) {
/* 161 */       return new ArrayList<Endpoint>(this.endpoints.values());
/*     */     } 
/*     */   }
/*     */   
/*     */   public Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception {
/*     */     Endpoint oldEndpoint;
/* 167 */     synchronized (this.endpoints) {
/* 168 */       ServiceHelper.startServices(new Object[] { endpoint });
/* 169 */       oldEndpoint = this.endpoints.remove(uri);
/* 170 */       this.endpoints.put(uri, endpoint);
/* 171 */       ServiceHelper.stopServices(new Object[] { oldEndpoint });
/*     */     } 
/* 173 */     return oldEndpoint;
/*     */   }
/*     */   
/*     */   public Endpoint removeSingletonEndpoint(String uri) throws Exception {
/*     */     Endpoint oldEndpoint;
/* 178 */     synchronized (this.endpoints) {
/* 179 */       oldEndpoint = this.endpoints.remove(uri);
/* 180 */       ServiceHelper.stopServices(new Object[] { oldEndpoint });
/*     */     } 
/* 182 */     return oldEndpoint;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Endpoint getEndpoint(String uri) {
/*     */     Endpoint answer;
/* 190 */     synchronized (this.endpoints) {
/* 191 */       answer = this.endpoints.get(uri);
/* 192 */       if (answer == null) {
/*     */         
/*     */         try {
/*     */           
/* 196 */           String[] splitURI = ObjectHelper.splitOnCharacter(uri, "":"", 2);
/* 197 */           if (splitURI[1] == null) {
/* 198 */             throw new IllegalArgumentException(""Invalid URI, it did not contain a scheme: "" + uri);
/*     */           }
/* 200 */           String scheme = splitURI[0];
/* 201 */           Component component = getComponent(scheme);
/*     */ 
/*     */           
/* 204 */           if (component != null)
/*     */           {
/*     */             
/* 207 */             answer = component.createEndpoint(uri);
/*     */ 
/*     */             
/* 210 */             if (answer != null && answer.isSingleton() && 
/* 211 */               answer != null) {
/* 212 */               ServiceHelper.startServices(new Object[] { answer });
/* 213 */               this.endpoints.put(uri, answer);
/*     */             }
/*     */           
/*     */           }
/*     */         
/* 218 */         } catch (Exception e) {
/* 219 */           throw new ResolveEndpointFailedException(uri, e);
/*     */         } 
/*     */       }
/*     */     } 
/* 223 */     return answer;
/*     */   }
/*     */   
/*     */   public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {
/* 227 */     Endpoint endpoint = getEndpoint(name);
/* 228 */     if (endpointType.isInstance(endpoint)) {
/* 229 */       return endpointType.cast(endpoint);
/*     */     }
/*     */     
/* 232 */     throw new IllegalArgumentException(""The endpoint is not of type: "" + endpointType + "" but is: "" + endpoint);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 239 */   public List<Route> getRoutes() { return this.routes; }
/*     */ 
/*     */ 
/*     */   
/* 243 */   public void setRoutes(List<Route> routes) { this.routes = routes; }
/*     */ 
/*     */   
/*     */   public void addRoutes(Collection<Route> routes) throws Exception {
/* 247 */     if (this.routes == null) {
/* 248 */       this.routes = new ArrayList<Route>(routes);
/*     */     } else {
/*     */       
/* 251 */       this.routes.addAll(routes);
/*     */     } 
/* 253 */     if (isStarted()) {
/* 254 */       startRoutes(routes);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public void addRoutes(RouteBuilder builder) throws Exception {
/* 260 */     builder.setContext(this);
/* 261 */     addRoutes(builder.getRouteList());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public ExchangeConverter getExchangeConverter() {
/* 267 */     if (this.exchangeConverter == null) {
/* 268 */       this.exchangeConverter = createExchangeConverter();
/*     */     }
/* 270 */     return this.exchangeConverter;
/*     */   }
/*     */ 
/*     */   
/* 274 */   public void setExchangeConverter(ExchangeConverter exchangeConverter) { this.exchangeConverter = exchangeConverter; }
/*     */ 
/*     */   
/*     */   public TypeConverter getTypeConverter() {
/* 278 */     if (this.typeConverter == null) {
/* 279 */       this.typeConverter = createTypeConverter();
/*     */     }
/* 281 */     return this.typeConverter;
/*     */   }
/*     */ 
/*     */   
/* 285 */   public void setTypeConverter(TypeConverter typeConverter) { this.typeConverter = typeConverter; }
/*     */ 
/*     */   
/*     */   public Injector getInjector() {
/* 289 */     if (this.injector == null) {
/* 290 */       this.injector = createInjector();
/*     */     }
/* 292 */     return this.injector;
/*     */   }
/*     */ 
/*     */   
/* 296 */   public void setInjector(Injector injector) { this.injector = injector; }
/*     */ 
/*     */   
/*     */   public ComponentResolver getComponentResolver() {
/* 300 */     if (this.componentResolver == null) {
/* 301 */       this.componentResolver = createComponentResolver();
/*     */     }
/* 303 */     return this.componentResolver;
/*     */   }
/*     */ 
/*     */   
/* 307 */   public void setComponentResolver(ComponentResolver componentResolver) { this.componentResolver = componentResolver; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void doStart() throws Exception {
/* 314 */     if (this.components != null) {
/* 315 */       for (Component component : this.components.values()) {
/* 316 */         ServiceHelper.startServices(new Object[] { component });
/*     */       } 
/*     */     }
/* 319 */     startRoutes(this.routes);
/*     */   }
/*     */   
/*     */   protected void doStop() throws Exception {
/* 323 */     ServiceHelper.stopServices(this.servicesToClose);
/* 324 */     if (this.components != null) {
/* 325 */       for (Component component : this.components.values()) {
/* 326 */         ServiceHelper.stopServices(new Object[] { component });
/*     */       } 
/*     */     }
/*     */   }
/*     */   
/*     */   protected void startRoutes(Collection<Route> routeList) throws Exception {
/* 332 */     if (routeList != null) {
/* 333 */       for (Route<Exchange> route : routeList) {
/* 334 */         List<Service> services = route.getServicesForRoute();
/* 335 */         this.servicesToClose.addAll(services);
/* 336 */         ServiceHelper.startServices(services);
/*     */       } 
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 345 */   protected ExchangeConverter createExchangeConverter() { return new DefaultExchangeConverter(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 352 */   protected TypeConverter createTypeConverter() { return (TypeConverter)new DefaultTypeConverter(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Injector createInjector() {
/* 359 */     FactoryFinder finder = new FactoryFinder();
/*     */     try {
/* 361 */       return (Injector)finder.newInstance(""Injector"");
/*     */     }
/* 363 */     catch (NoFactoryAvailableException e) {
/*     */       
/* 365 */       return new ReflectionInjector();
/*     */     }
/* 367 */     catch (IllegalAccessException e) {
/* 368 */       throw new RuntimeCamelException(e);
/*     */     }
/* 370 */     catch (InstantiationException e) {
/* 371 */       throw new RuntimeCamelException(e);
/*     */     }
/* 373 */     catch (IOException e) {
/* 374 */       throw new RuntimeCamelException(e);
/*     */     }
/* 376 */     catch (ClassNotFoundException e) {
/* 377 */       throw new RuntimeCamelException(e);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 385 */   protected ComponentResolver createComponentResolver() { return new DefaultComponentResolver<Exchange>(); }
/*     */ 
/*     */ 
/*     */   
/* 389 */   public boolean isAutoCreateComponents() { return this.autoCreateComponents; }
/*     */ 
/*     */ 
/*     */   
/* 393 */   public void setAutoCreateComponents(boolean autoCreateComponents) { this.autoCreateComponents = autoCreateComponents; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultCamelContext.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultComponent,"/*     */ package org.apache.camel.impl;
/*     */ 
/*     */ import java.net.URI;
/*     */ import java.util.Map;
/*     */ import java.util.concurrent.ScheduledExecutorService;
/*     */ import java.util.concurrent.ScheduledThreadPoolExecutor;
/*     */ import java.util.concurrent.ThreadFactory;
/*     */ import org.apache.camel.CamelContext;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.util.IntrospectionSupport;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ import org.apache.camel.util.URISupport;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class DefaultComponent<E extends Exchange>
/*     */   extends ServiceSupport
/*     */   implements Component<E>
/*     */ {
/*  39 */   private int defaultThreadPoolSize = 5;
/*     */   
/*     */   private CamelContext camelContext;
/*     */   
/*     */   private ScheduledExecutorService executorService;
/*     */   
/*     */   public DefaultComponent() {}
/*     */   
/*  47 */   public DefaultComponent(CamelContext context) { this.camelContext = context; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Endpoint<E> createEndpoint(String uri) throws Exception {
/*  52 */     ObjectHelper.notNull(getCamelContext(), ""camelContext"");
/*  53 */     URI u = new URI(uri);
/*  54 */     String path = u.getHost();
/*  55 */     if (path == null) {
/*  56 */       path = u.getSchemeSpecificPart();
/*     */     }
/*  58 */     Map parameters = URISupport.parseParamters(u);
/*     */     
/*  60 */     Endpoint<E> endpoint = createEndpoint(uri, path, parameters);
/*  61 */     if (endpoint == null) {
/*  62 */       return null;
/*     */     }
/*  64 */     if (parameters != null) {
/*  65 */       if (endpoint instanceof ScheduledPollEndpoint) {
/*  66 */         ScheduledPollEndpoint scheduledPollEndpoint = (ScheduledPollEndpoint)endpoint;
/*  67 */         scheduledPollEndpoint.configureProperties(parameters);
/*     */       } 
/*  69 */       IntrospectionSupport.setProperties(endpoint, parameters);
/*     */     } 
/*  71 */     return endpoint;
/*     */   }
/*     */ 
/*     */   
/*  75 */   public CamelContext getCamelContext() { return this.camelContext; }
/*     */ 
/*     */ 
/*     */   
/*  79 */   public void setCamelContext(CamelContext context) { this.camelContext = context; }
/*     */ 
/*     */   
/*     */   public ScheduledExecutorService getExecutorService() {
/*  83 */     if (this.executorService == null) {
/*  84 */       this.executorService = createExecutorService();
/*     */     }
/*  86 */     return this.executorService;
/*     */   }
/*     */ 
/*     */   
/*  90 */   public void setExecutorService(ScheduledExecutorService executorService) { this.executorService = executorService; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected ScheduledExecutorService createExecutorService() {
/*  97 */     return new ScheduledThreadPoolExecutor(this.defaultThreadPoolSize, new ThreadFactory() {
/*     */           int counter;
/*     */           
/*     */           public synchronized Thread newThread(Runnable runnable) {
/* 101 */             Thread thread = new Thread(runnable);
/* 102 */             thread.setName(""Thread"" + ++this.counter + "" "" + DefaultComponent.this.toString());
/* 103 */             return thread;
/*     */           }
/*     */         });
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doStart() throws Exception {}
/*     */   
/*     */   protected void doStop() throws Exception {
/* 112 */     if (this.executorService != null)
/* 113 */       this.executorService.shutdown(); 
/*     */   }
/*     */   
/*     */   protected abstract Endpoint<E> createEndpoint(String paramString1, String paramString2, Map paramMap) throws Exception;
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultComponent.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultComponentResolver,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Component;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.spi.ComponentResolver;
/*    */ import org.apache.camel.util.FactoryFinder;
/*    */ import org.apache.camel.util.NoFactoryAvailableException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DefaultComponentResolver<E extends Exchange>
/*    */   implements ComponentResolver<E>
/*    */ {
/* 36 */   protected static final FactoryFinder componentFactory = new FactoryFinder(""META-INF/services/org/apache/camel/component/"");
/*    */   
/*    */   public Component<E> resolveComponent(String name, CamelContext context) {
/*    */     Class<?> type;
/*    */     try {
/* 41 */       type = componentFactory.findClass(name);
/*    */     }
/* 43 */     catch (NoFactoryAvailableException e) {
/* 44 */       return null;
/*    */     }
/* 46 */     catch (Throwable e) {
/* 47 */       throw new IllegalArgumentException(""Invalid URI, no EndpointResolver registered for scheme : "" + name, e);
/*    */     } 
/* 49 */     if (type == null) {
/* 50 */       return null;
/*    */     }
/* 52 */     if (Component.class.isAssignableFrom(type)) {
/* 53 */       return (Component<E>)context.getInjector().newInstance(type);
/*    */     }
/*    */     
/* 56 */     throw new IllegalArgumentException(""Type is not a Component implementation. Found: "" + type.getName());
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultComponentResolver.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultConsumer,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.Consumer;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.spi.ExceptionHandler;
/*    */ import org.apache.camel.util.ServiceHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DefaultConsumer<E extends Exchange>
/*    */   extends ServiceSupport
/*    */   implements Consumer<E>
/*    */ {
/*    */   private Endpoint<E> endpoint;
/*    */   private Processor processor;
/*    */   private ExceptionHandler exceptionHandler;
/*    */   
/*    */   public DefaultConsumer(Endpoint<E> endpoint, Processor processor) {
/* 36 */     this.endpoint = endpoint;
/* 37 */     this.processor = processor;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public String toString() { return ""Consumer on "" + this.endpoint; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 47 */   public Endpoint<E> getEndpoint() { return this.endpoint; }
/*    */ 
/*    */ 
/*    */   
/* 51 */   public Processor getProcessor() { return this.processor; }
/*    */ 
/*    */   
/*    */   public ExceptionHandler getExceptionHandler() {
/* 55 */     if (this.exceptionHandler == null) {
/* 56 */       this.exceptionHandler = new LoggingExceptionHandler(getClass());
/*    */     }
/* 58 */     return this.exceptionHandler;
/*    */   }
/*    */ 
/*    */   
/* 62 */   public void setExceptionHandler(ExceptionHandler exceptionHandler) { this.exceptionHandler = exceptionHandler; }
/*    */ 
/*    */ 
/*    */   
/* 66 */   protected void doStop() throws Exception { ServiceHelper.stopServices(new Object[] { this.processor }); }
/*    */ 
/*    */ 
/*    */   
/* 70 */   protected void doStart() throws Exception { ServiceHelper.startServices(new Object[] { this.processor }); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 79 */   protected void handleException(Throwable t) { getExceptionHandler().handleException(t); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultEndpoint,"/*     */ package org.apache.camel.impl;
/*     */ 
/*     */ import java.lang.reflect.ParameterizedType;
/*     */ import java.lang.reflect.Type;
/*     */ import java.util.concurrent.ScheduledExecutorService;
/*     */ import java.util.concurrent.ScheduledThreadPoolExecutor;
/*     */ import org.apache.camel.CamelContext;
/*     */ import org.apache.camel.Component;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.PollingConsumer;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class DefaultEndpoint<E extends Exchange>
/*     */   implements Endpoint<E>
/*     */ {
/*     */   private String endpointUri;
/*     */   private final Component component;
/*     */   private CamelContext context;
/*     */   private ScheduledExecutorService executorService;
/*     */   
/*     */   protected DefaultEndpoint(String endpointUri, Component component) {
/*  43 */     this.endpointUri = endpointUri;
/*  44 */     this.component = component;
/*  45 */     this.context = component.getCamelContext();
/*     */   }
/*     */ 
/*     */   
/*  49 */   public int hashCode() { return this.endpointUri.hashCode() * 37 + 1; }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object object) {
/*  54 */     if (object instanceof DefaultEndpoint) {
/*  55 */       DefaultEndpoint that = (DefaultEndpoint)object;
/*  56 */       return ObjectHelper.equals(this.endpointUri, that.endpointUri);
/*     */     } 
/*  58 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  63 */   public String toString() { return ""Endpoint["" + this.endpointUri + ""]""; }
/*     */ 
/*     */ 
/*     */   
/*  67 */   public String getEndpointUri() { return this.endpointUri; }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public CamelContext getContext() { return this.context; }
/*     */ 
/*     */ 
/*     */   
/*  75 */   public Component getComponent() { return this.component; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized ScheduledExecutorService getExecutorService() {
/*  82 */     if (this.executorService == null) {
/*  83 */       Component c = getComponent();
/*  84 */       if (c != null && c instanceof DefaultComponent) {
/*  85 */         DefaultComponent dc = (DefaultComponent)c;
/*  86 */         this.executorService = dc.getExecutorService();
/*     */       } 
/*  88 */       if (this.executorService == null) {
/*  89 */         this.executorService = createExecutorService();
/*     */       }
/*     */     } 
/*  92 */     return this.executorService;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  99 */   public synchronized void setExecutorService(ScheduledExecutorService executorService) { this.executorService = executorService; }
/*     */ 
/*     */ 
/*     */   
/* 103 */   public PollingConsumer<E> createPollingConsumer() throws Exception { return new DefaultPollingConsumer<E>(this); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public E convertTo(Class<E> type, Exchange exchange) {
/* 111 */     if (type.isInstance(exchange)) {
/* 112 */       return type.cast(exchange);
/*     */     }
/* 114 */     return (E)getContext().getExchangeConverter().convertTo(type, exchange);
/*     */   }
/*     */   
/*     */   public E createExchange(Exchange exchange) {
/* 118 */     Class<E> exchangeType = getExchangeType();
/* 119 */     if (exchangeType != null && 
/* 120 */       exchangeType.isInstance(exchange)) {
/* 121 */       return exchangeType.cast(exchange);
/*     */     }
/*     */     
/* 124 */     Exchange exchange1 = createExchange();
/* 125 */     exchange1.copyFrom(exchange);
/* 126 */     return (E)exchange1;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 131 */   public E toExchangeType(Exchange exchange) { return createExchange(exchange); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Class<E> getExchangeType() {
/* 138 */     Type type = getClass().getGenericSuperclass();
/* 139 */     if (type instanceof ParameterizedType) {
/* 140 */       ParameterizedType parameterizedType = (ParameterizedType)type;
/* 141 */       Type[] arguments = parameterizedType.getActualTypeArguments();
/* 142 */       if (arguments.length > 0) {
/* 143 */         Type argumentType = arguments[0];
/* 144 */         if (argumentType instanceof Class) {
/* 145 */           return (Class<E>)argumentType;
/*     */         }
/*     */       } 
/*     */     } 
/* 149 */     return null;
/*     */   }
/*     */ 
/*     */   
/* 153 */   protected ScheduledThreadPoolExecutor createExecutorService() { return new ScheduledThreadPoolExecutor(10); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultExchange,"/*     */ package org.apache.camel.impl;
/*     */ 
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import org.apache.camel.CamelContext;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Message;
/*     */ import org.apache.camel.util.UuidGenerator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DefaultExchange
/*     */   implements Exchange
/*     */ {
/*  33 */   private static final UuidGenerator defaultIdGenerator = new UuidGenerator();
/*     */   protected final CamelContext context;
/*     */   private Map<String, Object> headers;
/*     */   private Message in;
/*     */   private Message out;
/*     */   private Message fault;
/*     */   private Throwable exception;
/*  40 */   private String exchangeId = defaultIdGenerator.generateId();
/*     */ 
/*     */   
/*  43 */   public DefaultExchange(CamelContext context) { this.context = context; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  48 */   public String toString() { return ""Exchange["" + this.in + ""]""; }
/*     */ 
/*     */   
/*     */   public Exchange copy() {
/*  52 */     Exchange exchange = newInstance();
/*  53 */     exchange.copyFrom(this);
/*  54 */     return exchange;
/*     */   }
/*     */   
/*     */   public void copyFrom(Exchange exchange) {
/*  58 */     if (exchange == this) {
/*     */       return;
/*     */     }
/*  61 */     setHeaders(safeCopy(exchange.getProperties()));
/*  62 */     setIn(safeCopy(exchange.getIn()));
/*  63 */     setOut(safeCopy(exchange.getOut()));
/*  64 */     setFault(safeCopy(exchange.getFault()));
/*  65 */     setException(exchange.getException());
/*     */   }
/*     */   
/*     */   private static Map<String, Object> safeCopy(Map<String, Object> properties) {
/*  69 */     if (properties == null)
/*  70 */       return null; 
/*  71 */     return new HashMap<String, Object>(properties);
/*     */   }
/*     */   
/*     */   private static Message safeCopy(Message message) {
/*  75 */     if (message == null)
/*  76 */       return null; 
/*  77 */     return message.copy();
/*     */   }
/*     */ 
/*     */   
/*  81 */   public Exchange newInstance() { return new DefaultExchange(this.context); }
/*     */ 
/*     */ 
/*     */   
/*  85 */   public CamelContext getContext() { return this.context; }
/*     */ 
/*     */   
/*     */   public Object getProperty(String name) {
/*  89 */     if (this.headers != null) {
/*  90 */       return this.headers.get(name);
/*     */     }
/*  92 */     return null;
/*     */   }
/*     */   
/*     */   public <T> T getProperty(String name, Class<T> type) {
/*  96 */     Object value = getProperty(name);
/*  97 */     return (T)getContext().getTypeConverter().convertTo(type, value);
/*     */   }
/*     */ 
/*     */   
/* 101 */   public void setProperty(String name, Object value) { getProperties().put(name, value); }
/*     */ 
/*     */   
/*     */   public Map<String, Object> getProperties() {
/* 105 */     if (this.headers == null) {
/* 106 */       this.headers = new HashMap<String, Object>();
/*     */     }
/* 108 */     return this.headers;
/*     */   }
/*     */ 
/*     */   
/* 112 */   public void setHeaders(Map<String, Object> headers) { this.headers = headers; }
/*     */ 
/*     */   
/*     */   public Message getIn() {
/* 116 */     if (this.in == null) {
/* 117 */       this.in = createInMessage();
/* 118 */       configureMessage(this.in);
/*     */     } 
/* 120 */     return this.in;
/*     */   }
/*     */   
/*     */   public void setIn(Message in) {
/* 124 */     this.in = in;
/* 125 */     configureMessage(in);
/*     */   }
/*     */ 
/*     */   
/* 129 */   public Message getOut() { return getOut(true); }
/*     */ 
/*     */   
/*     */   public Message getOut(boolean lazyCreate) {
/* 133 */     if (this.out == null && lazyCreate) {
/* 134 */       this.out = createOutMessage();
/* 135 */       configureMessage(this.out);
/*     */     } 
/* 137 */     return this.out;
/*     */   }
/*     */   
/*     */   public void setOut(Message out) {
/* 141 */     this.out = out;
/* 142 */     configureMessage(out);
/*     */   }
/*     */ 
/*     */   
/* 146 */   public Throwable getException() { return this.exception; }
/*     */ 
/*     */ 
/*     */   
/* 150 */   public void setException(Throwable exception) { this.exception = exception; }
/*     */ 
/*     */ 
/*     */   
/* 154 */   public Message getFault() { return this.fault; }
/*     */ 
/*     */   
/*     */   public void setFault(Message fault) {
/* 158 */     this.fault = fault;
/* 159 */     configureMessage(fault);
/*     */   }
/*     */ 
/*     */   
/* 163 */   public String getExchangeId() { return this.exchangeId; }
/*     */ 
/*     */ 
/*     */   
/* 167 */   public void setExchangeId(String id) { this.exchangeId = id; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 174 */   protected Message createInMessage() { return new DefaultMessage(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 181 */   protected Message createOutMessage() { return new DefaultMessage(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void configureMessage(Message message) {
/* 188 */     if (message instanceof MessageSupport) {
/* 189 */       MessageSupport messageSupport = (MessageSupport)message;
/* 190 */       messageSupport.setExchange(this);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultExchange.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultExchangeConverter,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.spi.ExchangeConverter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DefaultExchangeConverter
/*    */   implements ExchangeConverter
/*    */ {
/* 29 */   public <T> T convertTo(Class<T> type, Exchange exchange) { return null; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultExchangeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultMessage,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ import org.apache.camel.Message;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DefaultMessage
/*    */   extends MessageSupport
/*    */ {
/*    */   private Map<String, Object> headers;
/*    */   
/* 35 */   public String toString() { return ""Message: "" + getBody(); }
/*    */ 
/*    */ 
/*    */   
/* 39 */   public Object getHeader(String name) { return getHeaders().get(name); }
/*    */ 
/*    */   
/*    */   public <T> T getHeader(String name, Class<T> type) {
/* 43 */     Object value = getHeader(name);
/* 44 */     return (T)getExchange().getContext().getTypeConverter().convertTo(type, value);
/*    */   }
/*    */   
/*    */   public void setHeader(String name, Object value) {
/* 48 */     if (this.headers == null) {
/* 49 */       this.headers = createHeaders();
/*    */     }
/* 51 */     this.headers.put(name, value);
/*    */   }
/*    */   
/*    */   public Map<String, Object> getHeaders() {
/* 55 */     if (this.headers == null) {
/* 56 */       this.headers = createHeaders();
/*    */     }
/* 58 */     return this.headers;
/*    */   }
/*    */ 
/*    */   
/* 62 */   public void setHeaders(Map<String, Object> headers) { this.headers = headers; }
/*    */ 
/*    */ 
/*    */   
/* 66 */   public DefaultMessage newInstance() { return new DefaultMessage(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected Map<String, Object> createHeaders() {
/* 76 */     HashMap<String, Object> map = new HashMap<String, Object>();
/* 77 */     populateInitialHeaders(map);
/* 78 */     return map;
/*    */   }
/*    */   
/*    */   protected void populateInitialHeaders(Map<String, Object> map) {}
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultMessage.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultPollingConsumer,"/*     */ package org.apache.camel.impl;
/*     */ 
/*     */ import java.util.concurrent.ArrayBlockingQueue;
/*     */ import java.util.concurrent.BlockingQueue;
/*     */ import java.util.concurrent.TimeUnit;
/*     */ import org.apache.camel.Consumer;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.processor.Logger;
/*     */ import org.apache.camel.spi.ExceptionHandler;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DefaultPollingConsumer<E extends Exchange>
/*     */   extends PollingConsumerSupport<E>
/*     */   implements Processor
/*     */ {
/*  41 */   private static final transient Log log = LogFactory.getLog(DefaultPollingConsumer.class);
/*     */   private BlockingQueue<E> queue;
/*  43 */   private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler(new Logger(log));
/*     */   
/*     */   private Consumer<E> consumer;
/*     */   
/*  47 */   public DefaultPollingConsumer(Endpoint<E> endpoint) { this(endpoint, new ArrayBlockingQueue(1000)); }
/*     */ 
/*     */   
/*     */   public DefaultPollingConsumer(Endpoint<E> endpoint, BlockingQueue<E> queue) {
/*  51 */     super(endpoint);
/*  52 */     this.queue = queue;
/*     */   }
/*     */ 
/*     */   
/*  56 */   public E receiveNoWait() { return receive(0L); }
/*     */ 
/*     */   
/*     */   public E receive() {
/*  60 */     while (!isStopping() && !isStopped()) {
/*     */       try {
/*  62 */         return this.queue.take();
/*     */       }
/*  64 */       catch (InterruptedException e) {
/*  65 */         handleInteruptedException(e);
/*     */       } 
/*     */     } 
/*  68 */     return null;
/*     */   }
/*     */   
/*     */   public E receive(long timeout) {
/*     */     try {
/*  73 */       return this.queue.poll(timeout, TimeUnit.MILLISECONDS);
/*     */     }
/*  75 */     catch (InterruptedException e) {
/*  76 */       handleInteruptedException(e);
/*  77 */       return null;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*  82 */   public void process(Exchange exchange) throws Exception { this.queue.offer((E)exchange); }
/*     */ 
/*     */ 
/*     */   
/*  86 */   public ExceptionHandler getInteruptedExceptionHandler() { return this.interuptedExceptionHandler; }
/*     */ 
/*     */ 
/*     */   
/*  90 */   public void setInteruptedExceptionHandler(ExceptionHandler interuptedExceptionHandler) { this.interuptedExceptionHandler = interuptedExceptionHandler; }
/*     */ 
/*     */ 
/*     */   
/*  94 */   protected void handleInteruptedException(InterruptedException e) { getInteruptedExceptionHandler().handleException(e); }
/*     */ 
/*     */ 
/*     */   
/*     */   protected void doStart() throws Exception {
/*  99 */     this.consumer = getEndpoint().createConsumer(this);
/* 100 */     this.consumer.start();
/*     */   }
/*     */   
/*     */   protected void doStop() throws Exception {
/* 104 */     if (this.consumer != null)
/*     */       try {
/* 106 */         this.consumer.stop();
/*     */       } finally {
/*     */         
/* 109 */         this.consumer = null;
/*     */       }  
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultPollingConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.DefaultProducer,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Producer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class DefaultProducer<E extends Exchange>
/*    */   extends ServiceSupport
/*    */   implements Producer<E>
/*    */ {
/*    */   private Endpoint<E> endpoint;
/*    */   
/* 33 */   public DefaultProducer(Endpoint<E> endpoint) { this.endpoint = endpoint; }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public Endpoint<E> getEndpoint() { return this.endpoint; }
/*    */ 
/*    */ 
/*    */   
/* 41 */   public E createExchange() { return (E)this.endpoint.createExchange(); }
/*    */ 
/*    */ 
/*    */   
/* 45 */   public E createExchange(E exchange) { return (E)this.endpoint.createExchange((Exchange)exchange); }
/*    */   
/*    */   protected void doStart() throws Exception {}
/*    */   
/*    */   protected void doStop() throws Exception {}
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\DefaultProducer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.EventDrivenConsumerRoute,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import java.util.List;
/*    */ import org.apache.camel.Consumer;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Route;
/*    */ import org.apache.camel.Service;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class EventDrivenConsumerRoute<E extends Exchange>
/*    */   extends Route<E>
/*    */ {
/*    */   private Processor processor;
/*    */   
/*    */   public EventDrivenConsumerRoute(Endpoint endpoint, Processor processor) {
/* 39 */     super(endpoint);
/* 40 */     this.processor = processor;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 45 */   public String toString() { return ""EventDrivenConsumerRoute["" + getEndpoint() + "" -> "" + this.processor + ""]""; }
/*    */ 
/*    */ 
/*    */   
/* 49 */   public Processor getProcessor() { return this.processor; }
/*    */ 
/*    */ 
/*    */   
/* 53 */   public void setProcessor(Processor processor) { this.processor = processor; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected void addServices(List<Service> services) throws Exception {
/* 61 */     Processor processor = getProcessor();
/* 62 */     if (processor instanceof Service) {
/* 63 */       Service service = (Service)processor;
/* 64 */       services.add(service);
/*    */     } 
/* 66 */     Endpoint<E> endpoint = getEndpoint();
/* 67 */     Consumer<E> consumer = endpoint.createConsumer(processor);
/* 68 */     if (consumer != null)
/* 69 */       services.add(consumer); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\EventDrivenConsumerRoute.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.LoggingExceptionHandler,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.processor.Logger;
/*    */ import org.apache.camel.processor.LoggingLevel;
/*    */ import org.apache.camel.spi.ExceptionHandler;
/*    */ import org.apache.commons.logging.LogFactory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LoggingExceptionHandler
/*    */   implements ExceptionHandler
/*    */ {
/*    */   private final Logger logger;
/*    */   
/* 36 */   public LoggingExceptionHandler(Class ownerType) { this(new Logger(LogFactory.getLog(ownerType), LoggingLevel.ERROR)); }
/*    */ 
/*    */ 
/*    */   
/* 40 */   public LoggingExceptionHandler(Logger logger) { this.logger = logger; }
/*    */ 
/*    */ 
/*    */   
/* 44 */   public void handleException(Throwable exception) { this.logger.log(exception.getMessage(), exception); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\LoggingExceptionHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.MessageSupport,"/*     */ package org.apache.camel.impl;
/*     */ 
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Message;
/*     */ import org.apache.camel.util.UuidGenerator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class MessageSupport
/*     */   implements Message
/*     */ {
/*  34 */   private static final UuidGenerator defaultIdGenerator = new UuidGenerator();
/*     */   private Exchange exchange;
/*     */   private Object body;
/*  37 */   private String messageId = defaultIdGenerator.generateId();
/*     */ 
/*     */   
/*     */   public Object getBody() {
/*  41 */     if (this.body == null) {
/*  42 */       this.body = createBody();
/*     */     }
/*  44 */     return this.body;
/*     */   }
/*     */ 
/*     */   
/*     */   public <T> T getBody(Class<T> type) {
/*  49 */     Exchange e = getExchange();
/*  50 */     if (e != null) {
/*  51 */       return (T)e.getContext().getTypeConverter().convertTo(type, getBody());
/*     */     }
/*  53 */     return (T)getBody();
/*     */   }
/*     */ 
/*     */   
/*  57 */   public void setBody(Object body) { this.body = body; }
/*     */ 
/*     */   
/*     */   public <T> void setBody(Object body, Class<T> type) {
/*  61 */     Exchange e = getExchange();
/*  62 */     if (e != null) {
/*  63 */       T value = (T)e.getContext().getTypeConverter().convertTo(type, body);
/*  64 */       if (value != null) {
/*  65 */         body = value;
/*     */       }
/*     */     } 
/*  68 */     setBody(body);
/*     */   }
/*     */   
/*     */   public Message copy() {
/*  72 */     Message answer = newInstance();
/*  73 */     answer.setMessageId(getMessageId());
/*  74 */     answer.setBody(getBody());
/*  75 */     answer.getHeaders().putAll(getHeaders());
/*  76 */     return answer;
/*     */   }
/*     */ 
/*     */   
/*  80 */   public Exchange getExchange() { return this.exchange; }
/*     */ 
/*     */ 
/*     */   
/*  84 */   public void setExchange(Exchange exchange) { this.exchange = exchange; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract Message newInstance();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   protected Object createBody() { return null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public String getMessageId() { return this.messageId; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 117 */   public void setMessageId(String messageId) { this.messageId = messageId; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\MessageSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.NoPolicy,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.spi.Policy;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoPolicy<E>
/*    */   implements Policy<E>
/*    */ {
/* 31 */   public Processor wrap(Processor processor) { return processor; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\NoPolicy.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.NoRouteBuilder,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.builder.RouteBuilder;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoRouteBuilder
/*    */   extends RouteBuilder
/*    */ {
/* 28 */   private static final NoRouteBuilder instance = new NoRouteBuilder();
/*    */ 
/*    */   
/* 31 */   public static NoRouteBuilder getInstance() { return instance; }
/*    */   
/*    */   public void configure() throws Exception {}
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\NoRouteBuilder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.PollingConsumerRoute,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import java.util.List;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.PollingConsumer;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Route;
/*    */ import org.apache.camel.Service;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PollingConsumerRoute<E extends Exchange>
/*    */   extends Route<E>
/*    */ {
/*    */   private Processor processor;
/*    */   
/*    */   public PollingConsumerRoute(Endpoint endpoint, Processor processor) {
/* 40 */     super(endpoint);
/* 41 */     this.processor = processor;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 46 */   public String toString() { return ""PollingConsumerRoute["" + getEndpoint() + "" -> "" + this.processor + ""]""; }
/*    */ 
/*    */ 
/*    */   
/* 50 */   public Processor getProcessor() { return this.processor; }
/*    */ 
/*    */ 
/*    */   
/* 54 */   public void setProcessor(Processor processor) { this.processor = processor; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected void addServices(List<Service> services) throws Exception {
/* 62 */     Processor processor = getProcessor();
/* 63 */     if (processor instanceof Service) {
/* 64 */       Service service = (Service)processor;
/* 65 */       services.add(service);
/*    */     } 
/* 67 */     Endpoint<E> endpoint = getEndpoint();
/* 68 */     PollingConsumer<E> consumer = endpoint.createPollingConsumer();
/* 69 */     if (consumer != null)
/* 70 */       services.add(consumer); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\PollingConsumerRoute.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.PollingConsumerSupport,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.PollingConsumer;
/*    */ import org.apache.camel.spi.ExceptionHandler;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class PollingConsumerSupport<E extends Exchange>
/*    */   extends ServiceSupport
/*    */   implements PollingConsumer<E>
/*    */ {
/*    */   private final Endpoint<E> endpoint;
/*    */   private ExceptionHandler exceptionHandler;
/*    */   
/* 35 */   public PollingConsumerSupport(Endpoint<E> endpoint) { this.endpoint = endpoint; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 40 */   public String toString() { return ""PullConsumer on "" + this.endpoint; }
/*    */ 
/*    */ 
/*    */   
/* 44 */   public Endpoint<E> getEndpoint() { return this.endpoint; }
/*    */ 
/*    */   
/*    */   public ExceptionHandler getExceptionHandler() {
/* 48 */     if (this.exceptionHandler == null) {
/* 49 */       this.exceptionHandler = new LoggingExceptionHandler(getClass());
/*    */     }
/* 51 */     return this.exceptionHandler;
/*    */   }
/*    */ 
/*    */   
/* 55 */   public void setExceptionHandler(ExceptionHandler exceptionHandler) { this.exceptionHandler = exceptionHandler; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 64 */   protected void handleException(Throwable t) { getExceptionHandler().handleException(t); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\PollingConsumerSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.PredicateSupport,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Predicate;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class PredicateSupport<E extends Exchange>
/*    */   implements Predicate<E>
/*    */ {
/*    */   public void assertMatches(String text, E exchange) {
/* 31 */     if (!matches(exchange)) {
/* 32 */       throw new AssertionError(assertionFailureMessage(exchange));
/*    */     }
/*    */   }
/*    */ 
/*    */   
/* 37 */   protected String assertionFailureMessage(E exchange) { return this + "" failed on "" + exchange; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\PredicateSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.ReflectionInjector,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import org.apache.camel.RuntimeCamelException;
/*    */ import org.apache.camel.spi.Injector;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ReflectionInjector<T>
/*    */   implements Injector<T>
/*    */ {
/*    */   public T newInstance(Class<T> type) {
/*    */     try {
/* 33 */       return type.newInstance();
/*    */     }
/* 35 */     catch (InstantiationException e) {
/* 36 */       throw new RuntimeCamelException(e.getCause());
/*    */     }
/* 38 */     catch (IllegalAccessException e) {
/* 39 */       throw new RuntimeCamelException(e);
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\ReflectionInjector.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.ScheduledPollConsumer,"/*     */ package org.apache.camel.impl;
/*     */ 
/*     */ import java.util.concurrent.ScheduledExecutorService;
/*     */ import java.util.concurrent.ScheduledFuture;
/*     */ import java.util.concurrent.TimeUnit;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class ScheduledPollConsumer<E extends Exchange>
/*     */   extends DefaultConsumer<E>
/*     */   implements Runnable
/*     */ {
/*  36 */   private static final transient Log log = LogFactory.getLog(ScheduledPollConsumer.class);
/*     */   
/*     */   private final ScheduledExecutorService executor;
/*  39 */   private long initialDelay = 1000L;
/*  40 */   private long delay = 500L;
/*  41 */   private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
/*     */   
/*     */   private boolean useFixedDelay;
/*     */   private ScheduledFuture<?> future;
/*     */   
/*  46 */   public ScheduledPollConsumer(DefaultEndpoint<E> endpoint, Processor processor) { this(endpoint, processor, endpoint.getExecutorService()); }
/*     */ 
/*     */   
/*     */   public ScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
/*  50 */     super(endpoint, processor);
/*  51 */     this.executor = executor;
/*  52 */     if (executor == null) {
/*  53 */       throw new IllegalArgumentException(""A non null ScheduledExecutorService must be provided."");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void run() {
/*  61 */     log.debug(""Starting to poll"");
/*     */     try {
/*  63 */       poll();
/*     */     }
/*  65 */     catch (Exception e) {
/*  66 */       log.warn(""Caught: "" + e, e);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  73 */   public long getInitialDelay() { return this.initialDelay; }
/*     */ 
/*     */ 
/*     */   
/*  77 */   public void setInitialDelay(long initialDelay) { this.initialDelay = initialDelay; }
/*     */ 
/*     */ 
/*     */   
/*  81 */   public long getDelay() { return this.delay; }
/*     */ 
/*     */ 
/*     */   
/*  85 */   public void setDelay(long delay) { this.delay = delay; }
/*     */ 
/*     */ 
/*     */   
/*  89 */   public TimeUnit getTimeUnit() { return this.timeUnit; }
/*     */ 
/*     */ 
/*     */   
/*  93 */   public void setTimeUnit(TimeUnit timeUnit) { this.timeUnit = timeUnit; }
/*     */ 
/*     */ 
/*     */   
/*  97 */   public boolean isUseFixedDelay() { return this.useFixedDelay; }
/*     */ 
/*     */ 
/*     */   
/* 101 */   public void setUseFixedDelay(boolean useFixedDelay) { this.useFixedDelay = useFixedDelay; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void poll() throws Exception;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void doStart() throws Exception {
/* 116 */     super.doStart();
/* 117 */     if (isUseFixedDelay()) {
/* 118 */       this.future = this.executor.scheduleWithFixedDelay(this, getInitialDelay(), getDelay(), getTimeUnit());
/*     */     } else {
/*     */       
/* 121 */       this.future = this.executor.scheduleAtFixedRate(this, getInitialDelay(), getDelay(), getTimeUnit());
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doStop() throws Exception {
/* 127 */     if (this.future != null) {
/* 128 */       this.future.cancel(false);
/*     */     }
/* 130 */     super.doStop();
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\ScheduledPollConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.ScheduledPollEndpoint,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import java.util.Map;
/*    */ import org.apache.camel.Component;
/*    */ import org.apache.camel.Consumer;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.util.IntrospectionSupport;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class ScheduledPollEndpoint<E extends Exchange>
/*    */   extends DefaultEndpoint<E>
/*    */ {
/*    */   private Map consumerProperties;
/*    */   
/* 37 */   protected ScheduledPollEndpoint(String endpointUri, Component component) { super(endpointUri, component); }
/*    */ 
/*    */ 
/*    */   
/* 41 */   public Map getConsumerProperties() { return this.consumerProperties; }
/*    */ 
/*    */ 
/*    */   
/* 45 */   public void setConsumerProperties(Map consumerProperties) { this.consumerProperties = consumerProperties; }
/*    */ 
/*    */   
/*    */   protected void configureConsumer(Consumer<E> consumer) {
/* 49 */     if (this.consumerProperties != null) {
/* 50 */       IntrospectionSupport.setProperties(consumer, this.consumerProperties);
/*    */     }
/*    */   }
/*    */   
/*    */   public void configureProperties(Map options) {
/* 55 */     Map consumerProperties = IntrospectionSupport.extractProperties(options, ""consumer."");
/* 56 */     if (consumerProperties != null)
/* 57 */       setConsumerProperties(consumerProperties); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\ScheduledPollEndpoint.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.ServiceSupport,"/*    */ package org.apache.camel.impl;
/*    */ 
/*    */ import java.util.concurrent.atomic.AtomicBoolean;
/*    */ import org.apache.camel.Service;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class ServiceSupport
/*    */   implements Service
/*    */ {
/* 31 */   private AtomicBoolean started = new AtomicBoolean(false);
/* 32 */   private AtomicBoolean stopping = new AtomicBoolean(false);
/* 33 */   private AtomicBoolean stopped = new AtomicBoolean(false);
/*    */   
/*    */   public void start() throws Exception {
/* 36 */     if (this.started.compareAndSet(false, true)) {
/* 37 */       doStart();
/*    */     }
/*    */   }
/*    */   
/*    */   public void stop() throws Exception {
/* 42 */     if (this.stopped.compareAndSet(false, true)) {
/* 43 */       this.stopping.set(true);
/*    */       try {
/* 45 */         doStop();
/*    */       } finally {
/*    */         
/* 48 */         this.stopped.set(true);
/* 49 */         this.started.set(false);
/* 50 */         this.stopping.set(false);
/*    */       } 
/*    */     } 
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public boolean isStarted() { return this.started.get(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 66 */   public boolean isStopping() { return this.stopping.get(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 74 */   public boolean isStopped() { return this.stopped.get(); }
/*    */   
/*    */   protected abstract void doStart() throws Exception;
/*    */   
/*    */   protected abstract void doStop() throws Exception;
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\ServiceSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.AnnotationTypeConverterLoader,"/*     */ package org.apache.camel.impl.converter;
/*     */ 
/*     */ import java.io.BufferedReader;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStreamReader;
/*     */ import java.lang.reflect.Method;
/*     */ import java.lang.reflect.Modifier;
/*     */ import java.net.URL;
/*     */ import java.util.Enumeration;
/*     */ import java.util.HashSet;
/*     */ import java.util.Set;
/*     */ import java.util.StringTokenizer;
/*     */ import org.apache.camel.Converter;
/*     */ import org.apache.camel.impl.CachingInjector;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ import org.apache.camel.util.ResolverUtil;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class AnnotationTypeConverterLoader
/*     */   implements TypeConverterLoader
/*     */ {
/*     */   public static final String META_INF_SERVICES = ""META-INF/services/org/apache/camel/TypeConverter"";
/*  46 */   private static final transient Log log = LogFactory.getLog(AnnotationTypeConverterLoader.class);
/*  47 */   private ResolverUtil resolver = new ResolverUtil();
/*  48 */   private Set<Class> visitedClasses = (Set)new HashSet<Class<?>>();
/*     */   
/*     */   public void load(TypeConverterRegistry registry) throws Exception {
/*  51 */     String[] packageNames = findPackageNames();
/*  52 */     this.resolver.findAnnotated(Converter.class, packageNames);
/*  53 */     Set<Class<?>> classes = this.resolver.getClasses();
/*  54 */     for (Class<?> type : classes) {
/*  55 */       if (log.isDebugEnabled()) {
/*  56 */         log.debug(""Loading converter class: "" + ObjectHelper.name(type));
/*     */       }
/*  58 */       loadConverterMethods(registry, type);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected String[] findPackageNames() throws IOException {
/*  70 */     Set<String> packages = new HashSet<String>();
/*  71 */     findPackages(packages, Thread.currentThread().getContextClassLoader());
/*  72 */     findPackages(packages, getClass().getClassLoader());
/*  73 */     return packages.toArray(new String[packages.size()]);
/*     */   }
/*     */   
/*     */   protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {
/*  77 */     Enumeration<URL> resources = classLoader.getResources(""META-INF/services/org/apache/camel/TypeConverter"");
/*  78 */     while (resources.hasMoreElements()) {
/*  79 */       URL url = resources.nextElement();
/*  80 */       if (url != null) {
/*  81 */         BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
/*     */         try {
/*     */           while (true) {
/*  84 */             String line = reader.readLine();
/*  85 */             if (line == null) {
/*     */               break;
/*     */             }
/*  88 */             line = line.trim();
/*  89 */             if (line.startsWith(""#"") || line.length() == 0) {
/*     */               continue;
/*     */             }
/*  92 */             tokenize(packages, line);
/*     */           } 
/*     */         } finally {
/*     */           
/*     */           try {
/*  97 */             reader.close();
/*     */           }
/*  99 */           catch (IOException e) {
/* 100 */             log.warn(""Caught exception closing stream: "" + e, e);
/*     */           } 
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void tokenize(Set<String> packages, String line) {
/* 111 */     StringTokenizer iter = new StringTokenizer(line, "","");
/* 112 */     while (iter.hasMoreTokens()) {
/* 113 */       String name = iter.nextToken().trim();
/* 114 */       if (name.length() > 0) {
/* 115 */         packages.add(name);
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void loadConverterMethods(TypeConverterRegistry registry, Class type) {
/* 124 */     if (this.visitedClasses.contains(type)) {
/*     */       return;
/*     */     }
/* 127 */     this.visitedClasses.add(type);
/* 128 */     Method[] methods = type.getDeclaredMethods();
/* 129 */     CachingInjector injector = null;
/*     */     
/* 131 */     for (Method method : methods) {
/* 132 */       Converter annotation = method.getAnnotation(Converter.class);
/* 133 */       if (annotation != null) {
/* 134 */         Class<?>[] parameterTypes = method.getParameterTypes();
/* 135 */         if (parameterTypes == null || parameterTypes.length != 1) {
/* 136 */           log.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method + "" as a converter method should have one parameter"");
/*     */         }
/*     */         else {
/*     */           
/* 140 */           int modifiers = method.getModifiers();
/* 141 */           if (Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)) {
/* 142 */             log.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method + "" as a converter method is not a public and concrete method"");
/*     */           }
/*     */           else {
/*     */             
/* 146 */             Class<?> toType = method.getReturnType();
/* 147 */             if (toType.equals(Void.class)) {
/* 148 */               log.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method + "" as a converter method returns a void method"");
/*     */             }
/*     */             else {
/*     */               
/* 152 */               Class<?> fromType = parameterTypes[0];
/* 153 */               if (Modifier.isStatic(modifiers)) {
/* 154 */                 registry.addTypeConverter(toType, fromType, new StaticMethodTypeConverter(method));
/*     */               } else {
/*     */                 
/* 157 */                 if (injector == null) {
/* 158 */                   injector = new CachingInjector(registry, type);
/*     */                 }
/* 160 */                 registry.addTypeConverter(toType, fromType, new InstanceMethodTypeConverter(injector, method));
/*     */               } 
/*     */             } 
/*     */           } 
/*     */         } 
/*     */       } 
/*     */     } 
/* 167 */     Class superclass = type.getSuperclass();
/* 168 */     if (superclass != null && !superclass.equals(Object.class))
/* 169 */       loadConverterMethods(registry, superclass); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\AnnotationTypeConverterLoader.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.ArrayTypeConverter,"/*    */ package org.apache.camel.impl.converter;
/*    */ 
/*    */ import java.lang.reflect.Array;
/*    */ import java.util.ArrayList;
/*    */ import java.util.Arrays;
/*    */ import java.util.Collection;
/*    */ import java.util.List;
/*    */ import org.apache.camel.TypeConverter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ArrayTypeConverter
/*    */   implements TypeConverter
/*    */ {
/*    */   public <T> T convertTo(Class<T> type, Object value) {
/* 35 */     if (type.isArray()) {
/* 36 */       if (value instanceof Collection) {
/* 37 */         Collection collection = (Collection)value;
/* 38 */         Object array = Array.newInstance(type.getComponentType(), collection.size());
/* 39 */         if (array instanceof Object[]) {
/* 40 */           collection.toArray((Object[])array);
/*    */         } else {
/*    */           
/* 43 */           int index = 0;
/* 44 */           for (Object element : collection) {
/* 45 */             Array.set(array, index++, element);
/*    */           }
/*    */         } 
/* 48 */         return (T)array;
/*    */       } 
/* 50 */       if (value != null && value.getClass().isArray()) {
/* 51 */         int size = Array.getLength(value);
/* 52 */         Object answer = Array.newInstance(type.getComponentType(), size);
/* 53 */         for (int i = 0; i < size; i++) {
/* 54 */           Array.set(answer, i, Array.get(value, i));
/*    */         }
/* 56 */         return (T)answer;
/*    */       }
/*    */     
/* 59 */     } else if (Collection.class.isAssignableFrom(type) && 
/* 60 */       value != null) {
/* 61 */       if (value instanceof Object[]) {
/* 62 */         return (T)Arrays.asList((Object[])value);
/*    */       }
/* 64 */       if (value.getClass().isArray()) {
/* 65 */         int size = Array.getLength(value);
/* 66 */         List<Object> answer = new ArrayList(size);
/* 67 */         for (int i = 0; i < size; i++) {
/* 68 */           answer.add(Array.get(value, i));
/*    */         }
/* 70 */         return (T)answer;
/*    */       } 
/*    */     } 
/*    */     
/* 74 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\ArrayTypeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.DefaultTypeConverter,"/*     */ package org.apache.camel.impl.converter;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.HashMap;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import org.apache.camel.RuntimeCamelException;
/*     */ import org.apache.camel.TypeConverter;
/*     */ import org.apache.camel.impl.ReflectionInjector;
/*     */ import org.apache.camel.spi.Injector;
/*     */ import org.apache.camel.util.ObjectHelper;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DefaultTypeConverter
/*     */   implements TypeConverter, TypeConverterRegistry
/*     */ {
/*  38 */   private static final transient Log log = LogFactory.getLog(DefaultTypeConverter.class);
/*  39 */   private Map<TypeMapping, TypeConverter> typeMappings = new HashMap<TypeMapping, TypeConverter>();
/*     */   private Injector injector;
/*  41 */   private List<TypeConverterLoader> typeConverterLoaders = new ArrayList<TypeConverterLoader>();
/*  42 */   private List<TypeConverter> fallbackConverters = new ArrayList<TypeConverter>();
/*     */   private boolean loaded;
/*     */   
/*     */   public DefaultTypeConverter() {
/*  46 */     this.typeConverterLoaders.add(new AnnotationTypeConverterLoader());
/*  47 */     this.fallbackConverters.add(new PropertyEditorTypeConverter());
/*  48 */     this.fallbackConverters.add(new ToStringTypeConverter());
/*  49 */     this.fallbackConverters.add(new ArrayTypeConverter());
/*     */   }
/*     */   
/*     */   public DefaultTypeConverter(Injector injector) {
/*  53 */     this();
/*  54 */     this.injector = injector;
/*     */   }
/*     */   
/*     */   public <T> T convertTo(Class<T> toType, Object value) {
/*  58 */     if (toType.isInstance(value)) {
/*  59 */       return toType.cast(value);
/*     */     }
/*  61 */     checkLoaded();
/*  62 */     TypeConverter converter = getOrFindTypeConverter(toType, value);
/*  63 */     if (converter != null) {
/*  64 */       return (T)converter.convertTo(toType, value);
/*     */     }
/*     */     
/*  67 */     for (TypeConverter fallback : this.fallbackConverters) {
/*  68 */       T rc = (T)fallback.convertTo(toType, value);
/*  69 */       if (rc != null) {
/*  70 */         return rc;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/*  75 */     if (boolean.class.isAssignableFrom(toType)) {
/*  76 */       return (T)Boolean.FALSE;
/*     */     }
/*  78 */     return null;
/*     */   }
/*     */   
/*     */   public void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter) {
/*  82 */     TypeMapping key = new TypeMapping(toType, fromType);
/*  83 */     synchronized (this.typeMappings) {
/*  84 */       TypeConverter converter = this.typeMappings.get(key);
/*  85 */       if (converter != null) {
/*  86 */         log.warn(""Overriding type converter from: "" + converter + "" to: "" + typeConverter);
/*     */       }
/*  88 */       this.typeMappings.put(key, typeConverter);
/*     */     } 
/*     */   }
/*     */   
/*     */   public TypeConverter getTypeConverter(Class toType, Class fromType) {
/*  93 */     TypeMapping key = new TypeMapping(toType, fromType);
/*  94 */     synchronized (this.typeMappings) {
/*  95 */       return this.typeMappings.get(key);
/*     */     } 
/*     */   }
/*     */   
/*     */   public Injector getInjector() {
/* 100 */     if (this.injector == null) {
/* 101 */       this.injector = (Injector)new ReflectionInjector();
/*     */     }
/* 103 */     return this.injector;
/*     */   }
/*     */ 
/*     */   
/* 107 */   public void setInjector(Injector injector) { this.injector = injector; }
/*     */   
/*     */   protected <T> TypeConverter getOrFindTypeConverter(Class toType, Object value) {
/*     */     TypeConverter converter;
/* 111 */     Class<?> fromType = null;
/* 112 */     if (value != null) {
/* 113 */       fromType = value.getClass();
/*     */     }
/* 115 */     TypeMapping key = new TypeMapping(toType, fromType);
/*     */     
/* 117 */     synchronized (this.typeMappings) {
/* 118 */       converter = this.typeMappings.get(key);
/* 119 */       if (converter == null) {
/* 120 */         converter = findTypeConverter(toType, fromType, value);
/* 121 */         if (converter != null) {
/* 122 */           this.typeMappings.put(key, converter);
/*     */         }
/*     */       } 
/*     */     } 
/* 126 */     return converter;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected TypeConverter findTypeConverter(Class toType, Class fromType, Object value) {
/* 134 */     if (fromType != null) {
/* 135 */       Class<Object[]> fromSuperClass = fromType.getSuperclass();
/* 136 */       if (fromSuperClass != null && !fromSuperClass.equals(Object.class)) {
/*     */         
/* 138 */         TypeConverter converter = getTypeConverter(toType, fromSuperClass);
/* 139 */         if (converter == null) {
/* 140 */           converter = findTypeConverter(toType, fromSuperClass, value);
/*     */         }
/* 142 */         if (converter != null) {
/* 143 */           return converter;
/*     */         }
/*     */       } 
/* 146 */       for (Class<?> type : fromType.getInterfaces()) {
/* 147 */         TypeConverter converter = getTypeConverter(toType, type);
/* 148 */         if (converter != null) {
/* 149 */           return converter;
/*     */         }
/*     */       } 
/*     */ 
/*     */       
/* 154 */       if (fromType.isArray() && !fromType.getComponentType().isPrimitive())
/*     */       {
/* 156 */         if (!fromType.equals(Object[].class)) {
/* 157 */           fromSuperClass = Object[].class;
/*     */           
/* 159 */           TypeConverter converter = getTypeConverter(toType, fromSuperClass);
/* 160 */           if (converter == null) {
/* 161 */             converter = findTypeConverter(toType, fromSuperClass, value);
/*     */           }
/* 163 */           if (converter != null) {
/* 164 */             return converter;
/*     */           }
/*     */         } 
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 171 */     if (fromType != null) {
/* 172 */       Set<Map.Entry<TypeMapping, TypeConverter>> entries = this.typeMappings.entrySet();
/* 173 */       for (Map.Entry<TypeMapping, TypeConverter> entry : entries) {
/* 174 */         TypeMapping key = entry.getKey();
/* 175 */         Class<?> aToType = key.getToType();
/* 176 */         if (toType.isAssignableFrom(aToType) && 
/* 177 */           fromType.isAssignableFrom(key.getFromType())) {
/* 178 */           return entry.getValue();
/*     */         }
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 185 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected synchronized void checkLoaded() {
/* 192 */     if (!this.loaded) {
/* 193 */       this.loaded = true;
/* 194 */       for (TypeConverterLoader typeConverterLoader : this.typeConverterLoaders) {
/*     */         try {
/* 196 */           typeConverterLoader.load(this);
/*     */         }
/* 198 */         catch (Exception e) {
/* 199 */           throw new RuntimeCamelException(e);
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   protected static class TypeMapping
/*     */   {
/*     */     Class toType;
/*     */     
/*     */     Class fromType;
/*     */     
/*     */     public TypeMapping(Class toType, Class fromType) {
/* 213 */       this.toType = toType;
/* 214 */       this.fromType = fromType;
/*     */     }
/*     */ 
/*     */     
/* 218 */     public Class getFromType() { return this.fromType; }
/*     */ 
/*     */ 
/*     */     
/* 222 */     public Class getToType() { return this.toType; }
/*     */ 
/*     */ 
/*     */     
/*     */     public boolean equals(Object object) {
/* 227 */       if (object instanceof TypeMapping) {
/* 228 */         TypeMapping that = (TypeMapping)object;
/* 229 */         return (ObjectHelper.equals(this.fromType, that.fromType) && ObjectHelper.equals(this.toType, that.toType));
/*     */       } 
/* 231 */       return false;
/*     */     }
/*     */ 
/*     */     
/*     */     public int hashCode() {
/* 236 */       int answer = this.toType.hashCode();
/* 237 */       if (this.fromType != null) {
/* 238 */         answer *= 37 + this.fromType.hashCode();
/*     */       }
/* 240 */       return answer;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 245 */     public String toString() { return ""["" + this.fromType + ""=>"" + this.toType + ""]""; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\DefaultTypeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.InstanceMethodTypeConverter,"/*    */ package org.apache.camel.impl.converter;
/*    */ 
/*    */ import java.lang.reflect.Method;
/*    */ import org.apache.camel.RuntimeCamelException;
/*    */ import org.apache.camel.TypeConverter;
/*    */ import org.apache.camel.impl.CachingInjector;
/*    */ import org.apache.camel.util.ObjectHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class InstanceMethodTypeConverter
/*    */   implements TypeConverter
/*    */ {
/*    */   private final CachingInjector injector;
/*    */   private final Method method;
/*    */   
/*    */   public InstanceMethodTypeConverter(CachingInjector injector, Method method) {
/* 39 */     this.injector = injector;
/* 40 */     this.method = method;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 45 */   public String toString() { return ""InstanceMethodTypeConverter: "" + this.method; }
/*    */ 
/*    */   
/*    */   public synchronized <T> T convertTo(Class<T> type, Object value) {
/* 49 */     Object instance = this.injector.newInstance();
/* 50 */     if (instance == null) {
/* 51 */       throw new RuntimeCamelException(""Could not instantiate aninstance of: "" + type.getName());
/*    */     }
/* 53 */     return (T)ObjectHelper.invokeMethod(this.method, instance, new Object[] { value });
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\InstanceMethodTypeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.PropertyEditorTypeConverter,"/*    */ package org.apache.camel.impl.converter;
/*    */ 
/*    */ import java.beans.PropertyEditor;
/*    */ import java.beans.PropertyEditorManager;
/*    */ import org.apache.camel.TypeConverter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PropertyEditorTypeConverter
/*    */   implements TypeConverter
/*    */ {
/*    */   public <T> T convertTo(Class<T> toType, Object value) {
/* 36 */     if (value == null) {
/* 37 */       return null;
/*    */     }
/* 39 */     if (value.getClass() == String.class) {
/*    */ 
/*    */       
/* 42 */       if (toType == String.class) {
/* 43 */         return toType.cast(value);
/*    */       }
/*    */       
/* 46 */       PropertyEditor editor = PropertyEditorManager.findEditor(toType);
/* 47 */       if (editor != null) {
/* 48 */         editor.setAsText(value.toString());
/* 49 */         return toType.cast(editor.getValue());
/*    */       }
/*    */     
/* 52 */     } else if (toType == String.class) {
/*    */       
/* 54 */       PropertyEditor editor = PropertyEditorManager.findEditor(value.getClass());
/* 55 */       if (editor != null) {
/* 56 */         editor.setValue(value);
/* 57 */         return toType.cast(editor.getAsText());
/*    */       } 
/*    */     } 
/*    */     
/* 61 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\PropertyEditorTypeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.StaticMethodTypeConverter,"/*    */ package org.apache.camel.impl.converter;
/*    */ 
/*    */ import java.lang.reflect.Method;
/*    */ import org.apache.camel.TypeConverter;
/*    */ import org.apache.camel.util.ObjectHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StaticMethodTypeConverter
/*    */   implements TypeConverter
/*    */ {
/*    */   private final Method method;
/*    */   
/* 38 */   public StaticMethodTypeConverter(Method method) { this.method = method; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 43 */   public String toString() { return ""StaticMethodTypeConverter: "" + this.method; }
/*    */ 
/*    */ 
/*    */   
/* 47 */   public <T> T convertTo(Class<T> type, Object value) { return (T)ObjectHelper.invokeMethod(this.method, null, new Object[] { value }); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\StaticMethodTypeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.ToStringTypeConverter,"/*    */ package org.apache.camel.impl.converter;
/*    */ 
/*    */ import org.apache.camel.TypeConverter;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ToStringTypeConverter
/*    */   implements TypeConverter
/*    */ {
/*    */   public <T> T convertTo(Class<T> toType, Object value) {
/* 31 */     if (value != null && 
/* 32 */       toType.equals(String.class)) {
/* 33 */       return (T)value.toString();
/*    */     }
/*    */     
/* 36 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\ToStringTypeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.TypeConverterLoader,"package org.apache.camel.impl.converter;
public interface TypeConverterLoader {
  void load(TypeConverterRegistry paramTypeConverterRegistry) throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\TypeConverterLoader.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.impl.converter.TypeConverterRegistry,"package org.apache.camel.impl.converter;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;
public interface TypeConverterRegistry {
  void addTypeConverter(Class paramClass1, Class paramClass2, TypeConverter paramTypeConverter);
  Injector getInjector();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\impl\converter\TypeConverterRegistry.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.ChoiceProcessor,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import java.util.ArrayList;
/*    */ import java.util.List;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Predicate;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ import org.apache.camel.util.ServiceHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ChoiceProcessor
/*    */   extends ServiceSupport
/*    */   implements Processor
/*    */ {
/* 36 */   private List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
/*    */   private Processor otherwise;
/*    */   
/*    */   public ChoiceProcessor(List<FilterProcessor> filters, Processor otherwise) {
/* 40 */     this.filters = filters;
/* 41 */     this.otherwise = otherwise;
/*    */   }
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 45 */     for (FilterProcessor filterProcessor : this.filters) {
/* 46 */       Predicate<Exchange> predicate = filterProcessor.getPredicate();
/* 47 */       if (predicate != null && predicate.matches(exchange)) {
/* 48 */         filterProcessor.getProcessor().process(exchange);
/*    */         return;
/*    */       } 
/*    */     } 
/* 52 */     if (this.otherwise != null) {
/* 53 */       this.otherwise.process(exchange);
/*    */     }
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString() {
/* 59 */     StringBuilder builder = new StringBuilder(""choice{"");
/* 60 */     boolean first = true;
/* 61 */     for (FilterProcessor processor : this.filters) {
/* 62 */       if (first) {
/* 63 */         first = false;
/*    */       } else {
/*    */         
/* 66 */         builder.append("", "");
/*    */       } 
/* 68 */       builder.append(""when "");
/* 69 */       builder.append(processor.getPredicate().toString());
/* 70 */       builder.append("": "");
/* 71 */       builder.append(processor.getProcessor());
/*    */     } 
/* 73 */     if (this.otherwise != null) {
/* 74 */       builder.append("", otherwise: "");
/* 75 */       builder.append(this.otherwise);
/*    */     } 
/* 77 */     builder.append(""}"");
/* 78 */     return builder.toString();
/*    */   }
/*    */ 
/*    */   
/* 82 */   public List<FilterProcessor> getFilters() { return this.filters; }
/*    */ 
/*    */ 
/*    */   
/* 86 */   public Processor getOtherwise() { return this.otherwise; }
/*    */ 
/*    */ 
/*    */   
/*    */   protected void doStart() throws Exception {
/* 91 */     ServiceHelper.startServices(this.filters);
/* 92 */     ServiceHelper.startServices(new Object[] { this.otherwise });
/*    */   }
/*    */   
/*    */   protected void doStop() throws Exception {
/* 96 */     ServiceHelper.stopServices(new Object[] { this.otherwise });
/* 97 */     ServiceHelper.stopServices(this.filters);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\ChoiceProcessor.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.CompositeProcessor,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import java.util.Collection;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ import org.apache.camel.util.ServiceHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CompositeProcessor
/*    */   extends ServiceSupport
/*    */   implements Processor
/*    */ {
/*    */   private final Collection<Processor> processors;
/*    */   
/* 36 */   public CompositeProcessor(Collection<Processor> processors) { this.processors = processors; }
/*    */ 
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 40 */     for (Processor processor : this.processors) {
/* 41 */       processor.process(exchange);
/*    */     }
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString() {
/* 47 */     StringBuilder builder = new StringBuilder(""[ "");
/* 48 */     boolean first = true;
/* 49 */     for (Processor processor : this.processors) {
/* 50 */       if (first) {
/* 51 */         first = false;
/*    */       } else {
/*    */         
/* 54 */         builder.append("", "");
/*    */       } 
/* 56 */       builder.append(processor.toString());
/*    */     } 
/* 58 */     builder.append("" ]"");
/* 59 */     return builder.toString();
/*    */   }
/*    */ 
/*    */   
/* 63 */   public Collection<Processor> getProcessors() { return this.processors; }
/*    */ 
/*    */ 
/*    */   
/* 67 */   protected void doStart() throws Exception { ServiceHelper.startServices(this.processors); }
/*    */ 
/*    */ 
/*    */   
/* 71 */   protected void doStop() throws Exception { ServiceHelper.stopServices(this.processors); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\CompositeProcessor.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.DeadLetterChannel,"/*     */ package org.apache.camel.processor;
/*     */ 
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Message;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.impl.ServiceSupport;
/*     */ import org.apache.camel.util.ServiceHelper;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DeadLetterChannel
/*     */   extends ServiceSupport
/*     */   implements ErrorHandler
/*     */ {
/*     */   public static final String REDELIVERY_COUNTER = ""org.apache.camel.RedeliveryCounter"";
/*     */   public static final String REDELIVERED = ""org.apache.camel.Redelivered"";
/*  39 */   private static final transient Log log = LogFactory.getLog(DeadLetterChannel.class);
/*     */   
/*     */   private Processor output;
/*     */   private Processor deadLetter;
/*     */   private RedeliveryPolicy redeliveryPolicy;
/*     */   private Logger logger;
/*     */   
/*  46 */   public static <E extends Exchange> Logger createDefaultLogger() { return new Logger(log, LoggingLevel.ERROR); }
/*     */ 
/*     */ 
/*     */   
/*  50 */   public DeadLetterChannel(Processor output, Processor deadLetter) { this(output, deadLetter, new RedeliveryPolicy(), createDefaultLogger()); }
/*     */ 
/*     */   
/*     */   public DeadLetterChannel(Processor output, Processor deadLetter, RedeliveryPolicy redeliveryPolicy, Logger logger) {
/*  54 */     this.deadLetter = deadLetter;
/*  55 */     this.output = output;
/*  56 */     this.redeliveryPolicy = redeliveryPolicy;
/*  57 */     this.logger = logger;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  62 */   public String toString() { return ""DeadLetterChannel["" + this.output + "", "" + this.deadLetter + "", "" + this.redeliveryPolicy + ""]""; }
/*     */ 
/*     */   
/*     */   public void process(Exchange exchange) throws Exception {
/*  66 */     int redeliveryCounter = 0;
/*  67 */     long redeliveryDelay = 0L;
/*     */     
/*     */     while (true) {
/*  70 */       if (redeliveryCounter > 0) {
/*     */         
/*  72 */         redeliveryDelay = this.redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
/*  73 */         sleep(redeliveryDelay);
/*     */       } 
/*     */       
/*     */       try {
/*  77 */         this.output.process(exchange);
/*     */         
/*     */         return;
/*  80 */       } catch (RuntimeException e) {
/*  81 */         this.logger.log(""On delivery attempt: "" + redeliveryCounter + "" caught: "" + e, e);
/*     */         
/*  83 */         redeliveryCounter = incrementRedeliveryCounter(exchange);
/*     */         
/*  85 */         if (!this.redeliveryPolicy.shouldRedeliver(redeliveryCounter))
/*     */           break; 
/*     */       } 
/*  88 */     }  this.deadLetter.process(exchange);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   public Processor getOutput() { return this.output; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 105 */   public Processor getDeadLetter() { return this.deadLetter; }
/*     */ 
/*     */ 
/*     */   
/* 109 */   public RedeliveryPolicy getRedeliveryPolicy() { return this.redeliveryPolicy; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 116 */   public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) { this.redeliveryPolicy = redeliveryPolicy; }
/*     */ 
/*     */ 
/*     */   
/* 120 */   public Logger getLogger() { return this.logger; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 127 */   public void setLogger(Logger logger) { this.logger = logger; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected int incrementRedeliveryCounter(Exchange exchange) {
/* 137 */     Message in = exchange.getIn();
/* 138 */     Integer counter = (Integer)in.getHeader(""org.apache.camel.RedeliveryCounter"", Integer.class);
/* 139 */     int next = 1;
/* 140 */     if (counter != null) {
/* 141 */       next = counter.intValue() + 1;
/*     */     }
/* 143 */     in.setHeader(""org.apache.camel.RedeliveryCounter"", Integer.valueOf(next));
/* 144 */     in.setHeader(""org.apache.camel.Redelivered"", Boolean.valueOf(true));
/* 145 */     return next;
/*     */   }
/*     */   
/*     */   protected void sleep(long redeliveryDelay) {
/* 149 */     if (redeliveryDelay > 0L) {
/* 150 */       if (log.isDebugEnabled()) {
/* 151 */         log.debug(""Sleeping for: "" + redeliveryDelay + "" until attempting redelivery"");
/*     */       }
/*     */       try {
/* 154 */         Thread.sleep(redeliveryDelay);
/*     */       }
/* 156 */       catch (InterruptedException e) {
/* 157 */         if (log.isDebugEnabled()) {
/* 158 */           log.debug(""Thread interupted: "" + e, e);
/*     */         }
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 165 */   protected void doStart() throws Exception { ServiceHelper.startServices(new Object[] { this.output, this.deadLetter }); }
/*     */ 
/*     */ 
/*     */   
/* 169 */   protected void doStop() throws Exception { ServiceHelper.stopServices(new Object[] { this.deadLetter, this.output }); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\DeadLetterChannel.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.DelegateProcessor,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ import org.apache.camel.util.ServiceHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DelegateProcessor
/*    */   extends ServiceSupport
/*    */   implements Processor
/*    */ {
/*    */   protected Processor next;
/*    */   
/*    */   public DelegateProcessor() {}
/*    */   
/* 39 */   public DelegateProcessor(Processor next) { this.next = next; }
/*    */ 
/*    */ 
/*    */   
/* 43 */   public void process(Exchange exchange) throws Exception { processNext(exchange); }
/*    */ 
/*    */   
/*    */   protected void processNext(Exchange exchange) throws Exception {
/* 47 */     if (this.next != null) {
/* 48 */       this.next.process(exchange);
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 54 */   public String toString() { return ""delegate("" + this.next + "")""; }
/*    */ 
/*    */ 
/*    */   
/* 58 */   public Processor getNext() { return this.next; }
/*    */ 
/*    */ 
/*    */   
/* 62 */   public void setNext(Processor next) { this.next = next; }
/*    */ 
/*    */ 
/*    */   
/* 66 */   protected void doStart() throws Exception { ServiceHelper.startServices(new Object[] { this.next }); }
/*    */ 
/*    */ 
/*    */   
/* 70 */   protected void doStop() throws Exception { ServiceHelper.stopServices(new Object[] { this.next }); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\DelegateProcessor.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.ErrorHandler,"package org.apache.camel.processor;
import org.apache.camel.Processor;
public interface ErrorHandler extends Processor {}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\ErrorHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.FilterProcessor,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Predicate;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ import org.apache.camel.util.ServiceHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FilterProcessor
/*    */   extends ServiceSupport
/*    */   implements Processor
/*    */ {
/*    */   private Predicate<Exchange> predicate;
/*    */   private Processor processor;
/*    */   
/*    */   public FilterProcessor(Predicate<Exchange> predicate, Processor processor) {
/* 34 */     this.predicate = predicate;
/* 35 */     this.processor = processor;
/*    */   }
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 39 */     if (this.predicate.matches(exchange)) {
/* 40 */       this.processor.process(exchange);
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 46 */   public String toString() { return ""filter ("" + this.predicate + "") "" + this.processor; }
/*    */ 
/*    */ 
/*    */   
/* 50 */   public Predicate<Exchange> getPredicate() { return this.predicate; }
/*    */ 
/*    */ 
/*    */   
/* 54 */   public Processor getProcessor() { return this.processor; }
/*    */ 
/*    */ 
/*    */   
/* 58 */   protected void doStart() throws Exception { ServiceHelper.startServices(new Object[] { this.processor }); }
/*    */ 
/*    */ 
/*    */   
/* 62 */   protected void doStop() throws Exception { ServiceHelper.stopServices(new Object[] { this.processor }); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\FilterProcessor.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.Logger,"/*     */ package org.apache.camel.processor;
/*     */ 
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Logger
/*     */   implements Processor
/*     */ {
/*     */   private Log log;
/*     */   private LoggingLevel level;
/*     */   
/*  36 */   public Logger() { this(LogFactory.getLog(Logger.class)); }
/*     */ 
/*     */ 
/*     */   
/*  40 */   public Logger(Log log) { this(log, LoggingLevel.INFO); }
/*     */ 
/*     */   
/*     */   public Logger(Log log, LoggingLevel level) {
/*  44 */     this.log = log;
/*  45 */     this.level = level;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  50 */   public String toString() { return ""Logger["" + this.log + ""]""; }
/*     */ 
/*     */   
/*     */   public void process(Exchange exchange) {
/*  54 */     switch (this.level) {
/*     */       case DEBUG:
/*  56 */         if (this.log.isDebugEnabled()) {
/*  57 */           this.log.debug(logMessage(exchange));
/*     */         }
/*     */         return;
/*     */       case ERROR:
/*  61 */         if (this.log.isErrorEnabled()) {
/*  62 */           this.log.error(logMessage(exchange));
/*     */         }
/*     */         return;
/*     */       case FATAL:
/*  66 */         if (this.log.isFatalEnabled()) {
/*  67 */           this.log.fatal(logMessage(exchange));
/*     */         }
/*     */         return;
/*     */       case INFO:
/*  71 */         if (this.log.isInfoEnabled()) {
/*  72 */           this.log.debug(logMessage(exchange));
/*     */         }
/*     */         return;
/*     */       case TRACE:
/*  76 */         if (this.log.isTraceEnabled()) {
/*  77 */           this.log.trace(logMessage(exchange));
/*     */         }
/*     */         return;
/*     */       case WARN:
/*  81 */         if (this.log.isWarnEnabled()) {
/*  82 */           this.log.warn(logMessage(exchange));
/*     */         }
/*     */         return;
/*     */     } 
/*  86 */     this.log.error(""Unknown level: "" + this.level + "" when trying to log exchange: "" + logMessage(exchange));
/*     */   }
/*     */ 
/*     */   
/*     */   public void log(String message) {
/*  91 */     switch (this.level) {
/*     */       case DEBUG:
/*  93 */         if (this.log.isDebugEnabled()) {
/*  94 */           this.log.debug(message);
/*     */         }
/*     */         return;
/*     */       case ERROR:
/*  98 */         if (this.log.isErrorEnabled()) {
/*  99 */           this.log.error(message);
/*     */         }
/*     */         return;
/*     */       case FATAL:
/* 103 */         if (this.log.isFatalEnabled()) {
/* 104 */           this.log.fatal(message);
/*     */         }
/*     */         return;
/*     */       case INFO:
/* 108 */         if (this.log.isInfoEnabled()) {
/* 109 */           this.log.debug(message);
/*     */         }
/*     */         return;
/*     */       case TRACE:
/* 113 */         if (this.log.isTraceEnabled()) {
/* 114 */           this.log.trace(message);
/*     */         }
/*     */         return;
/*     */       case WARN:
/* 118 */         if (this.log.isWarnEnabled()) {
/* 119 */           this.log.warn(message);
/*     */         }
/*     */         return;
/*     */     } 
/* 123 */     this.log.error(""Unknown level: "" + this.level + "" when trying to log exchange: "" + message);
/*     */   }
/*     */ 
/*     */   
/*     */   public void log(String message, Throwable exception) {
/* 128 */     switch (this.level) {
/*     */       case DEBUG:
/* 130 */         if (this.log.isDebugEnabled()) {
/* 131 */           this.log.debug(message, exception);
/*     */         }
/*     */         return;
/*     */       case ERROR:
/* 135 */         if (this.log.isErrorEnabled()) {
/* 136 */           this.log.error(message, exception);
/*     */         }
/*     */         return;
/*     */       case FATAL:
/* 140 */         if (this.log.isFatalEnabled()) {
/* 141 */           this.log.fatal(message, exception);
/*     */         }
/*     */         return;
/*     */       case INFO:
/* 145 */         if (this.log.isInfoEnabled()) {
/* 146 */           this.log.debug(message, exception);
/*     */         }
/*     */         return;
/*     */       case TRACE:
/* 150 */         if (this.log.isTraceEnabled()) {
/* 151 */           this.log.trace(message, exception);
/*     */         }
/*     */         return;
/*     */       case WARN:
/* 155 */         if (this.log.isWarnEnabled()) {
/* 156 */           this.log.warn(message, exception);
/*     */         }
/*     */         return;
/*     */     } 
/* 160 */     this.log.error(""Unknown level: "" + this.level + "" when trying to log exchange: "" + message, exception);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 165 */   protected Object logMessage(Exchange exchange) { return exchange; }
/*     */ 
/*     */ 
/*     */   
/* 169 */   public Log getLog() { return this.log; }
/*     */ 
/*     */ 
/*     */   
/* 173 */   public void setLog(Log log) { this.log = log; }
/*     */ 
/*     */ 
/*     */   
/* 177 */   public LoggingLevel getLevel() { return this.level; }
/*     */ 
/*     */ 
/*     */   
/* 181 */   public void setLevel(LoggingLevel level) { this.level = level; }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\Logger.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.LoggingErrorHandler,"/*     */ package org.apache.camel.processor;
/*     */ 
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.impl.ServiceSupport;
/*     */ import org.apache.camel.util.ServiceHelper;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class LoggingErrorHandler
/*     */   extends ServiceSupport
/*     */   implements ErrorHandler
/*     */ {
/*     */   private Processor output;
/*     */   private Log log;
/*     */   private LoggingLevel level;
/*     */   
/*  38 */   public LoggingErrorHandler(Processor output) { this(output, LogFactory.getLog(LoggingErrorHandler.class), LoggingLevel.INFO); }
/*     */ 
/*     */   
/*     */   public LoggingErrorHandler(Processor output, Log log, LoggingLevel level) {
/*  42 */     this.output = output;
/*  43 */     this.log = log;
/*  44 */     this.level = level;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  49 */   public String toString() { return ""LoggingErrorHandler["" + this.output + ""]""; }
/*     */ 
/*     */   
/*     */   public void process(Exchange exchange) throws Exception {
/*     */     try {
/*  54 */       this.output.process(exchange);
/*     */     }
/*  56 */     catch (RuntimeException e) {
/*  57 */       logError(exchange, e);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public Processor getOutput() { return this.output; }
/*     */ 
/*     */ 
/*     */   
/*  72 */   public LoggingLevel getLevel() { return this.level; }
/*     */ 
/*     */ 
/*     */   
/*  76 */   public void setLevel(LoggingLevel level) { this.level = level; }
/*     */ 
/*     */ 
/*     */   
/*  80 */   public Log getLog() { return this.log; }
/*     */ 
/*     */ 
/*     */   
/*  84 */   public void setLog(Log log) { this.log = log; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void logError(Exchange exchange, RuntimeException e) {
/*  90 */     switch (this.level) {
/*     */       case DEBUG:
/*  92 */         if (this.log.isDebugEnabled()) {
/*  93 */           this.log.debug(logMessage(exchange, e), e);
/*     */         }
/*     */         return;
/*     */       case ERROR:
/*  97 */         if (this.log.isErrorEnabled()) {
/*  98 */           this.log.error(logMessage(exchange, e), e);
/*     */         }
/*     */         return;
/*     */       case FATAL:
/* 102 */         if (this.log.isFatalEnabled()) {
/* 103 */           this.log.fatal(logMessage(exchange, e), e);
/*     */         }
/*     */         return;
/*     */       case INFO:
/* 107 */         if (this.log.isInfoEnabled()) {
/* 108 */           this.log.debug(logMessage(exchange, e), e);
/*     */         }
/*     */         return;
/*     */       case TRACE:
/* 112 */         if (this.log.isTraceEnabled()) {
/* 113 */           this.log.trace(logMessage(exchange, e), e);
/*     */         }
/*     */         return;
/*     */       case WARN:
/* 117 */         if (this.log.isWarnEnabled()) {
/* 118 */           this.log.warn(logMessage(exchange, e), e);
/*     */         }
/*     */         return;
/*     */     } 
/* 122 */     this.log.error(""Unknown level: "" + this.level + "" when trying to log exchange: "" + logMessage(exchange, e), e);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 127 */   protected Object logMessage(Exchange exchange, RuntimeException e) { return e + "" while processing exchange: "" + exchange; }
/*     */ 
/*     */ 
/*     */   
/* 131 */   protected void doStart() throws Exception { ServiceHelper.startServices(new Object[] { this.output }); }
/*     */ 
/*     */ 
/*     */   
/* 135 */   protected void doStop() throws Exception { ServiceHelper.stopServices(new Object[] { this.output }); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\LoggingErrorHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.LoggingLevel,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public enum LoggingLevel
/*    */ {
/* 26 */   DEBUG, ERROR, FATAL, INFO, TRACE, WARN;
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\LoggingLevel.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.MulticastProcessor,"/*     */ package org.apache.camel.processor;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.impl.ServiceSupport;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MulticastProcessor
/*     */   extends ServiceSupport
/*     */   implements Processor
/*     */ {
/*     */   private Collection<Producer> producers;
/*     */   
/*     */   public static <E extends Exchange> Collection<Producer> toProducers(Collection<Endpoint> endpoints) throws Exception {
/*  42 */     Collection<Producer> answer = new ArrayList<Producer>();
/*  43 */     for (Endpoint endpoint : endpoints) {
/*  44 */       answer.add(endpoint.createProducer());
/*     */     }
/*  46 */     return answer;
/*     */   }
/*     */ 
/*     */   
/*  50 */   public MulticastProcessor(Collection<Endpoint> endpoints) throws Exception { this.producers = toProducers(endpoints); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public String toString() { return ""Multicast"" + getEndpoints(); }
/*     */ 
/*     */   
/*     */   public void process(Exchange exchange) throws Exception {
/*  59 */     for (Producer producer : this.producers) {
/*  60 */       Exchange copy = copyExchangeStrategy(producer, exchange);
/*  61 */       producer.process(copy);
/*     */     } 
/*     */   }
/*     */   
/*     */   protected void doStop() throws Exception {
/*  66 */     for (Producer producer : this.producers) {
/*  67 */       producer.stop();
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doStart() throws Exception {
/*  72 */     for (Producer producer : this.producers) {
/*  73 */       producer.start();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  81 */   public Collection<Producer> getProducers() { return this.producers; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection<Endpoint> getEndpoints() {
/*  88 */     Collection<Endpoint> answer = new ArrayList<Endpoint>();
/*  89 */     for (Producer producer : this.producers) {
/*  90 */       answer.add(producer.getEndpoint());
/*     */     }
/*  92 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   protected Exchange copyExchangeStrategy(Producer producer, Exchange exchange) { return producer.createExchange(exchange); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\MulticastProcessor.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.Pipeline,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import java.util.Collection;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Producer;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Pipeline
/*    */   extends MulticastProcessor
/*    */   implements Processor
/*    */ {
/* 35 */   public Pipeline(Collection<Endpoint> endpoints) throws Exception { super(endpoints); }
/*    */ 
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 39 */     Exchange nextExchange = exchange;
/* 40 */     boolean first = true;
/* 41 */     for (Producer producer : getProducers()) {
/* 42 */       if (first) {
/* 43 */         first = false;
/*    */       } else {
/*    */         
/* 46 */         nextExchange = createNextExchange(producer, nextExchange);
/*    */       } 
/* 48 */       producer.process(nextExchange);
/*    */     } 
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected Exchange createNextExchange(Producer producer, Exchange previousExchange) {
/* 60 */     Exchange answer = producer.createExchange(previousExchange);
/*    */ 
/*    */     
/* 63 */     Object output = previousExchange.getOut().getBody();
/* 64 */     if (output != null) {
/* 65 */       answer.getIn().setBody(output);
/*    */     }
/* 67 */     return answer;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 78 */   protected Exchange copyExchangeStrategy(Exchange exchange) { return exchange.copy(); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 83 */   public String toString() { return ""Pipeline"" + getEndpoints(); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\Pipeline.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.RecipientList,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import java.util.Iterator;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.converter.ObjectConverter;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ import org.apache.camel.util.ExchangeHelper;
/*    */ import org.apache.camel.util.ObjectHelper;
/*    */ import org.apache.camel.util.ProducerCache;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RecipientList
/*    */   extends ServiceSupport
/*    */   implements Processor
/*    */ {
/*    */   private final Expression<Exchange> expression;
/* 40 */   private ProducerCache<Exchange> producerCache = new ProducerCache();
/*    */   
/*    */   public RecipientList(Expression<Exchange> expression) {
/* 43 */     ObjectHelper.notNull(expression, ""expression"");
/* 44 */     this.expression = expression;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 49 */   public String toString() { return ""RecipientList["" + this.expression + ""]""; }
/*    */ 
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 53 */     Object receipientList = this.expression.evaluate(exchange);
/* 54 */     Iterator iter = ObjectConverter.iterator(receipientList);
/* 55 */     while (iter.hasNext()) {
/* 56 */       Object recipient = iter.next();
/* 57 */       Endpoint<Exchange> endpoint = resolveEndpoint(exchange, recipient);
/* 58 */       this.producerCache.getProducer(endpoint).process(exchange);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 63 */   protected Endpoint<Exchange> resolveEndpoint(Exchange exchange, Object recipient) { return ExchangeHelper.resolveEndpoint(exchange, recipient); }
/*    */ 
/*    */ 
/*    */   
/* 67 */   protected void doStop() throws Exception { this.producerCache.stop(); }
/*    */   
/*    */   protected void doStart() throws Exception {}
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\RecipientList.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.RedeliveryPolicy,"/*     */ package org.apache.camel.processor;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.Random;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RedeliveryPolicy
/*     */   implements Cloneable, Serializable
/*     */ {
/*     */   protected static transient Random randomNumberGenerator;
/*  33 */   protected int maximumRedeliveries = 6;
/*  34 */   protected long initialRedeliveryDelay = 1000L;
/*  35 */   protected double backOffMultiplier = 2.0D;
/*     */   
/*     */   protected boolean useExponentialBackOff = false;
/*  38 */   protected double collisionAvoidanceFactor = 0.15D;
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean useCollisionAvoidance = false;
/*     */ 
/*     */ 
/*     */   
/*  46 */   public String toString() { return ""RedeliveryPolicy[maximumRedeliveries="" + this.maximumRedeliveries + ""]""; }
/*     */ 
/*     */   
/*     */   public RedeliveryPolicy copy() {
/*     */     try {
/*  51 */       return (RedeliveryPolicy)clone();
/*     */     }
/*  53 */     catch (CloneNotSupportedException e) {
/*  54 */       throw new RuntimeException(""Could not clone: "" + e, e);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  62 */   public boolean shouldRedeliver(int redeliveryCounter) { return (redeliveryCounter < getMaximumRedeliveries()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RedeliveryPolicy maximumRedeliveries(int maximumRedeliveries) {
/*  72 */     setMaximumRedeliveries(maximumRedeliveries);
/*  73 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RedeliveryPolicy initialRedeliveryDelay(long initialRedeliveryDelay) {
/*  80 */     setInitialRedeliveryDelay(initialRedeliveryDelay);
/*  81 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RedeliveryPolicy useCollisionAvoidance() {
/*  88 */     setUseCollisionAvoidance(true);
/*  89 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RedeliveryPolicy useExponentialBackOff() {
/*  96 */     setUseExponentialBackOff(true);
/*  97 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RedeliveryPolicy backOffMultiplier(double backOffMultiplier) {
/* 104 */     useExponentialBackOff();
/* 105 */     setBackOffMultiplier(backOffMultiplier);
/* 106 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RedeliveryPolicy collisionAvoidancePercent(short collisionAvoidancePercent) {
/* 113 */     useCollisionAvoidance();
/* 114 */     setCollisionAvoidancePercent(collisionAvoidancePercent);
/* 115 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 121 */   public double getBackOffMultiplier() { return this.backOffMultiplier; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 128 */   public void setBackOffMultiplier(double backOffMultiplier) { this.backOffMultiplier = backOffMultiplier; }
/*     */ 
/*     */ 
/*     */   
/* 132 */   public short getCollisionAvoidancePercent() { return (short)(int)Math.round(this.collisionAvoidanceFactor * 100.0D); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 139 */   public void setCollisionAvoidancePercent(short collisionAvoidancePercent) { this.collisionAvoidanceFactor = collisionAvoidancePercent * 0.01D; }
/*     */ 
/*     */ 
/*     */   
/* 143 */   public double getCollisionAvoidanceFactor() { return this.collisionAvoidanceFactor; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 150 */   public void setCollisionAvoidanceFactor(double collisionAvoidanceFactor) { this.collisionAvoidanceFactor = collisionAvoidanceFactor; }
/*     */ 
/*     */ 
/*     */   
/* 154 */   public long getInitialRedeliveryDelay() { return this.initialRedeliveryDelay; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 161 */   public void setInitialRedeliveryDelay(long initialRedeliveryDelay) { this.initialRedeliveryDelay = initialRedeliveryDelay; }
/*     */ 
/*     */ 
/*     */   
/* 165 */   public int getMaximumRedeliveries() { return this.maximumRedeliveries; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 172 */   public void setMaximumRedeliveries(int maximumRedeliveries) { this.maximumRedeliveries = maximumRedeliveries; }
/*     */ 
/*     */ 
/*     */   
/*     */   public long getRedeliveryDelay(long previousDelay) {
/*     */     long redeliveryDelay;
/* 178 */     if (previousDelay == 0L) {
/* 179 */       redeliveryDelay = this.initialRedeliveryDelay;
/*     */     }
/* 181 */     else if (this.useExponentialBackOff && this.backOffMultiplier > 1.0D) {
/* 182 */       redeliveryDelay = Math.round(this.backOffMultiplier * previousDelay);
/*     */     } else {
/*     */       
/* 185 */       redeliveryDelay = previousDelay;
/*     */     } 
/*     */     
/* 188 */     if (this.useCollisionAvoidance) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 194 */       Random random = getRandomNumberGenerator();
/* 195 */       double variance = (random.nextBoolean() ? this.collisionAvoidanceFactor : -this.collisionAvoidanceFactor) * random.nextDouble();
/* 196 */       redeliveryDelay = (long)(redeliveryDelay + redeliveryDelay * variance);
/*     */     } 
/*     */     
/* 199 */     return redeliveryDelay;
/*     */   }
/*     */ 
/*     */   
/* 203 */   public boolean isUseCollisionAvoidance() { return this.useCollisionAvoidance; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 210 */   public void setUseCollisionAvoidance(boolean useCollisionAvoidance) { this.useCollisionAvoidance = useCollisionAvoidance; }
/*     */ 
/*     */ 
/*     */   
/* 214 */   public boolean isUseExponentialBackOff() { return this.useExponentialBackOff; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 221 */   public void setUseExponentialBackOff(boolean useExponentialBackOff) { this.useExponentialBackOff = useExponentialBackOff; }
/*     */ 
/*     */   
/*     */   protected static synchronized Random getRandomNumberGenerator() {
/* 225 */     if (randomNumberGenerator == null) {
/* 226 */       randomNumberGenerator = new Random();
/*     */     }
/* 228 */     return randomNumberGenerator;
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\RedeliveryPolicy.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.Resequencer,"/*     */ package org.apache.camel.processor;
/*     */ 
/*     */ import java.util.Comparator;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import java.util.TreeSet;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.PollingConsumer;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.impl.LoggingExceptionHandler;
/*     */ import org.apache.camel.impl.ServiceSupport;
/*     */ import org.apache.camel.spi.ExceptionHandler;
/*     */ import org.apache.camel.util.ExpressionComparator;
/*     */ import org.apache.camel.util.ExpressionListComparator;
/*     */ import org.apache.camel.util.ServiceHelper;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Resequencer
/*     */   extends ServiceSupport
/*     */   implements Runnable
/*     */ {
/*  46 */   private static final transient Log log = LogFactory.getLog(Resequencer.class);
/*     */   private Endpoint endpoint;
/*     */   private Processor processor;
/*     */   private Set<Exchange> set;
/*  50 */   private long batchTimeout = 1000L;
/*  51 */   private int batchSize = 100;
/*     */   
/*     */   private PollingConsumer consumer;
/*     */   private ExceptionHandler exceptionHandler;
/*     */   
/*  56 */   public Resequencer(Endpoint endpoint, Processor processor, Expression<Exchange> expression) { this(endpoint, processor, createSet(expression)); }
/*     */ 
/*     */ 
/*     */   
/*  60 */   public Resequencer(Endpoint endpoint, Processor processor, List<Expression<Exchange>> expressions) { this(endpoint, processor, createSet(expressions)); }
/*     */ 
/*     */   
/*     */   public Resequencer(Endpoint endpoint, Processor processor, Set<Exchange> set) {
/*  64 */     this.endpoint = endpoint;
/*  65 */     this.processor = processor;
/*  66 */     this.set = set;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public String toString() { return ""Resequencer[to: "" + this.processor + ""]""; }
/*     */ 
/*     */   
/*     */   public void run() {
/*  75 */     log.debug(""Starting thread for "" + this);
/*  76 */     while (!isStopped() && !isStopping()) {
/*     */       try {
/*  78 */         processBatch();
/*     */       }
/*  80 */       catch (Exception e) {
/*  81 */         getExceptionHandler().handleException(e);
/*     */       } 
/*     */     } 
/*  84 */     this.set.clear();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public ExceptionHandler getExceptionHandler() {
/*  90 */     if (this.exceptionHandler == null) {
/*  91 */       this.exceptionHandler = (ExceptionHandler)new LoggingExceptionHandler(getClass());
/*     */     }
/*  93 */     return this.exceptionHandler;
/*     */   }
/*     */ 
/*     */   
/*  97 */   public void setExceptionHandler(ExceptionHandler exceptionHandler) { this.exceptionHandler = exceptionHandler; }
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int getBatchSize() { return this.batchSize; }
/*     */ 
/*     */ 
/*     */   
/* 105 */   public void setBatchSize(int batchSize) { this.batchSize = batchSize; }
/*     */ 
/*     */ 
/*     */   
/* 109 */   public long getBatchTimeout() { return this.batchTimeout; }
/*     */ 
/*     */ 
/*     */   
/* 113 */   public void setBatchTimeout(long batchTimeout) { this.batchTimeout = batchTimeout; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected synchronized void processBatch() throws Exception {
/* 124 */     long start = System.currentTimeMillis();
/* 125 */     long end = start + this.batchTimeout;
/* 126 */     for (int i = 0; i < this.batchSize; i++) {
/* 127 */       long timeout = end - System.currentTimeMillis();
/*     */       
/* 129 */       Exchange exchange = this.consumer.receive(timeout);
/* 130 */       if (exchange == null) {
/*     */         break;
/*     */       }
/* 133 */       this.set.add(exchange);
/*     */     } 
/*     */     
/* 136 */     if (log.isDebugEnabled()) {
/* 137 */       log.debug(""Finsihed batch size: "" + this.batchSize + "" timeout: "" + this.batchTimeout + "" so sending set: "" + this.set);
/*     */     }
/*     */ 
/*     */     
/* 141 */     Iterator<Exchange> iter = this.set.iterator();
/* 142 */     while (iter.hasNext()) {
/* 143 */       Exchange exchange = iter.next();
/* 144 */       iter.remove();
/* 145 */       this.processor.process(exchange);
/*     */     } 
/*     */   }
/*     */   
/*     */   protected void doStart() throws Exception {
/* 150 */     this.consumer = this.endpoint.createPollingConsumer();
/*     */     
/* 152 */     ServiceHelper.startServices(new Object[] { this.processor, this.consumer });
/*     */     
/* 154 */     Thread thread = new Thread(this, this + "" Polling Thread"");
/* 155 */     thread.start();
/*     */   }
/*     */   
/*     */   protected void doStop() throws Exception {
/* 159 */     ServiceHelper.stopServices(new Object[] { this.consumer, this.processor });
/* 160 */     this.consumer = null;
/*     */   }
/*     */ 
/*     */   
/* 164 */   protected static Set<Exchange> createSet(Expression<Exchange> expression) { return createSet((Comparator<? super Exchange>)new ExpressionComparator(expression)); }
/*     */ 
/*     */   
/*     */   protected static Set<Exchange> createSet(List<Expression<Exchange>> expressions) {
/* 168 */     if (expressions.size() == 1) {
/* 169 */       return createSet(expressions.get(0));
/*     */     }
/* 171 */     return createSet((Comparator<? super Exchange>)new ExpressionListComparator(expressions));
/*     */   }
/*     */ 
/*     */   
/* 175 */   protected static Set<Exchange> createSet(Comparator<? super Exchange> comparator) { return new TreeSet<Exchange>(comparator); }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\Resequencer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.SendProcessor,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Producer;
/*    */ import org.apache.camel.Service;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SendProcessor
/*    */   extends ServiceSupport
/*    */   implements Processor, Service
/*    */ {
/*    */   private Endpoint destination;
/*    */   private Producer producer;
/*    */   
/* 35 */   public SendProcessor(Endpoint destination) { this.destination = destination; }
/*    */ 
/*    */   
/*    */   protected void doStop() throws Exception {
/* 39 */     if (this.producer != null) {
/*    */       try {
/* 41 */         this.producer.stop();
/*    */       } finally {
/*    */         
/* 44 */         this.producer = null;
/*    */       } 
/*    */     }
/*    */   }
/*    */ 
/*    */   
/* 50 */   protected void doStart() throws Exception { this.producer = this.destination.createProducer(); }
/*    */ 
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 54 */     if (this.producer == null) {
/* 55 */       throw new IllegalStateException(""No producer, this processor has not been started!"");
/*    */     }
/* 57 */     this.producer.process(exchange);
/*    */   }
/*    */ 
/*    */   
/* 61 */   public Endpoint getDestination() { return this.destination; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 66 */   public String toString() { return ""sendTo("" + this.destination + "")""; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\SendProcessor.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.Splitter,"/*    */ package org.apache.camel.processor;
/*    */ 
/*    */ import java.util.Iterator;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.converter.ObjectConverter;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ import org.apache.camel.util.ObjectHelper;
/*    */ import org.apache.camel.util.ServiceHelper;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Splitter
/*    */   extends ServiceSupport
/*    */   implements Processor
/*    */ {
/*    */   private final Processor processor;
/*    */   private final Expression expression;
/*    */   
/*    */   public Splitter(Processor destination, Expression expression) {
/* 41 */     this.processor = destination;
/* 42 */     this.expression = expression;
/* 43 */     ObjectHelper.notNull(destination, ""destination"");
/* 44 */     ObjectHelper.notNull(expression, ""expression"");
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 49 */   public String toString() { return ""Splitter[on: "" + this.expression + "" to: "" + this.processor + ""]""; }
/*    */ 
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 53 */     Object value = this.expression.evaluate(exchange);
/* 54 */     Iterator iter = ObjectConverter.iterator(value);
/* 55 */     while (iter.hasNext()) {
/* 56 */       Object part = iter.next();
/* 57 */       Exchange newExchange = exchange.copy();
/* 58 */       newExchange.getIn().setBody(part);
/* 59 */       this.processor.process(newExchange);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 64 */   protected void doStart() throws Exception { ServiceHelper.startServices(new Object[] { this.processor }); }
/*    */ 
/*    */ 
/*    */   
/* 68 */   protected void doStop() throws Exception { ServiceHelper.stopServices(new Object[] { this.processor }); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\Splitter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.idempotent.IdempotentConsumer,"/*    */ package org.apache.camel.processor.idempotent;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.impl.ServiceSupport;
/*    */ import org.apache.camel.util.ExpressionHelper;
/*    */ import org.apache.camel.util.ServiceHelper;
/*    */ import org.apache.commons.logging.Log;
/*    */ import org.apache.commons.logging.LogFactory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class IdempotentConsumer
/*    */   extends ServiceSupport
/*    */   implements Processor
/*    */ {
/* 36 */   private static final transient Log log = LogFactory.getLog(IdempotentConsumer.class);
/*    */   private Expression<Exchange> messageIdExpression;
/*    */   private Processor nextProcessor;
/*    */   private MessageIdRepository messageIdRepository;
/*    */   
/*    */   public IdempotentConsumer(Expression<Exchange> messageIdExpression, MessageIdRepository messageIdRepository, Processor nextProcessor) {
/* 42 */     this.messageIdExpression = messageIdExpression;
/* 43 */     this.messageIdRepository = messageIdRepository;
/* 44 */     this.nextProcessor = nextProcessor;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 49 */   public String toString() { return ""IdempotentConsumer[expression="" + this.messageIdExpression + "", repository="" + this.messageIdRepository + "", processor="" + this.nextProcessor + ""]""; }
/*    */ 
/*    */   
/*    */   public void process(Exchange exchange) throws Exception {
/* 53 */     String messageId = ExpressionHelper.evaluateAsString(this.messageIdExpression, exchange);
/* 54 */     if (messageId == null) {
/* 55 */       throw new NoMessageIdException(exchange, this.messageIdExpression);
/*    */     }
/* 57 */     if (!this.messageIdRepository.contains(messageId)) {
/* 58 */       this.nextProcessor.process(exchange);
/*    */     } else {
/*    */       
/* 61 */       onDuplicateMessage(exchange, messageId);
/*    */     } 
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 68 */   public Expression<Exchange> getMessageIdExpression() { return this.messageIdExpression; }
/*    */ 
/*    */ 
/*    */   
/* 72 */   public MessageIdRepository getMessageIdRepository() { return this.messageIdRepository; }
/*    */ 
/*    */ 
/*    */   
/* 76 */   public Processor getNextProcessor() { return this.nextProcessor; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 84 */   protected void doStart() throws Exception { ServiceHelper.startServices(new Object[] { this.nextProcessor }); }
/*    */ 
/*    */ 
/*    */   
/* 88 */   protected void doStop() throws Exception { ServiceHelper.stopServices(new Object[] { this.nextProcessor }); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected void onDuplicateMessage(Exchange exchange, String messageId) {
/* 98 */     if (log.isDebugEnabled())
/* 99 */       log.debug(""Ignoring duplicate message with id: "" + messageId + "" for exchange: "" + exchange); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\idempotent\IdempotentConsumer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.idempotent.MemoryMessageIdRepository,"/*    */ package org.apache.camel.processor.idempotent;
/*    */ 
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ import org.apache.camel.util.LRUCache;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class MemoryMessageIdRepository
/*    */   implements MessageIdRepository
/*    */ {
/*    */   private Map cache;
/*    */   
/* 42 */   public static MessageIdRepository memoryMessageIdRepository() { return memoryMessageIdRepository(new HashMap<Object, Object>()); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 50 */   public static MessageIdRepository memoryMessageIdRepository(int cacheSize) { return memoryMessageIdRepository((Map)new LRUCache(cacheSize)); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public static MessageIdRepository memoryMessageIdRepository(Map cache) { return new MemoryMessageIdRepository(cache); }
/*    */ 
/*    */ 
/*    */   
/* 63 */   public MemoryMessageIdRepository(Map set) { this.cache = set; }
/*    */ 
/*    */   
/*    */   public boolean contains(String messageId) {
/* 67 */     synchronized (this.cache) {
/* 68 */       if (this.cache.containsKey(messageId)) {
/* 69 */         return true;
/*    */       }
/*    */       
/* 72 */       this.cache.put(messageId, messageId);
/* 73 */       return false;
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\idempotent\MemoryMessageIdRepository.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.idempotent.MessageIdRepository,"package org.apache.camel.processor.idempotent;
public interface MessageIdRepository {
  boolean contains(String paramString);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\idempotent\MessageIdRepository.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.idempotent.NoMessageIdException,"/*    */ package org.apache.camel.processor.idempotent;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ import org.apache.camel.RuntimeCamelException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoMessageIdException
/*    */   extends RuntimeCamelException
/*    */ {
/*    */   private final Exchange exchange;
/*    */   private final Expression expression;
/*    */   
/*    */   public NoMessageIdException(Exchange exchange, Expression expression) {
/* 35 */     super(""No message ID could be found using expression: "" + expression + "" on message exchange: "" + exchange);
/* 36 */     this.exchange = exchange;
/* 37 */     this.expression = expression;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   public Exchange getExchange() { return this.exchange; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 51 */   public Expression getExpression() { return this.expression; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\idempotent\NoMessageIdException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.loadbalancer.LoadBalancer,"package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Processor;
public interface LoadBalancer extends Processor {
  void addProcessor(Processor paramProcessor);
  void removeProcessor(Processor paramProcessor);
  List<Processor> getProcessors();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\loadbalancer\LoadBalancer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.loadbalancer.LoadBalancerSupport,"/*    */ package org.apache.camel.processor.loadbalancer;
/*    */ 
/*    */ import java.util.List;
/*    */ import java.util.concurrent.CopyOnWriteArrayList;
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class LoadBalancerSupport
/*    */   implements LoadBalancer
/*    */ {
/* 32 */   private List<Processor> processors = new CopyOnWriteArrayList<Processor>();
/*    */ 
/*    */   
/* 35 */   public void addProcessor(Processor processor) { this.processors.add(processor); }
/*    */ 
/*    */ 
/*    */   
/* 39 */   public void removeProcessor(Processor processor) { this.processors.remove(processor); }
/*    */ 
/*    */ 
/*    */   
/* 43 */   public List<Processor> getProcessors() { return this.processors; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\loadbalancer\LoadBalancerSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.loadbalancer.QueueLoadBalancer,"/*    */ package org.apache.camel.processor.loadbalancer;
/*    */ 
/*    */ import java.util.List;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class QueueLoadBalancer
/*    */   extends LoadBalancerSupport
/*    */ {
/*    */   public void process(Exchange exchange) throws Exception {
/* 34 */     List<Processor> list = getProcessors();
/* 35 */     if (list.isEmpty()) {
/* 36 */       throw new IllegalStateException(""No processors available to process "" + exchange);
/*    */     }
/* 38 */     Processor processor = chooseProcessor(list, exchange);
/* 39 */     if (processor == null) {
/* 40 */       throw new IllegalStateException(""No processors could be chosen to process "" + exchange);
/*    */     }
/*    */     
/* 43 */     processor.process(exchange);
/*    */   }
/*    */   
/*    */   protected abstract Processor chooseProcessor(List<Processor> paramList, Exchange paramExchange);
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\loadbalancer\QueueLoadBalancer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.loadbalancer.RandomLoadBalancer,"/*    */ package org.apache.camel.processor.loadbalancer;
/*    */ 
/*    */ import java.util.List;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RandomLoadBalancer
/*    */   extends QueueLoadBalancer
/*    */ {
/*    */   protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
/* 33 */     int index, size = processors.size();
/*    */     do {
/* 35 */       index = (int)Math.round(Math.random() * size);
/* 36 */     } while (index >= size);
/* 37 */     return processors.get(index);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\loadbalancer\RandomLoadBalancer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer,"/*    */ package org.apache.camel.processor.loadbalancer;
/*    */ 
/*    */ import java.util.List;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RoundRobinLoadBalancer
/*    */   extends QueueLoadBalancer
/*    */ {
/* 31 */   private int counter = -1;
/*    */   
/*    */   protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
/* 34 */     int size = processors.size();
/* 35 */     if (++this.counter >= size) {
/* 36 */       this.counter = 0;
/*    */     }
/* 38 */     return processors.get(this.counter);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\loadbalancer\RoundRobinLoadBalancer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.loadbalancer.StickyLoadBalancer,"/*     */ package org.apache.camel.processor.loadbalancer;
/*     */ 
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.Expression;
/*     */ import org.apache.camel.Processor;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class StickyLoadBalancer
/*     */   extends QueueLoadBalancer
/*     */ {
/*     */   private Expression<Exchange> correlationExpression;
/*     */   private QueueLoadBalancer loadBalancer;
/*  40 */   private int numberOfHashGroups = 65536;
/*  41 */   private Map<Object, Processor> stickyMap = new HashMap<Object, Processor>();
/*     */ 
/*     */   
/*  44 */   public StickyLoadBalancer(Expression<Exchange> correlationExpression) { this(correlationExpression, new RoundRobinLoadBalancer()); }
/*     */ 
/*     */   
/*     */   public StickyLoadBalancer(Expression<Exchange> correlationExpression, QueueLoadBalancer loadBalancer) {
/*  48 */     this.correlationExpression = correlationExpression;
/*  49 */     this.loadBalancer = loadBalancer;
/*     */   }
/*     */   protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
/*     */     Processor processor;
/*  53 */     Object value = this.correlationExpression.evaluate(exchange);
/*  54 */     Object key = getStickyKey(value);
/*     */ 
/*     */     
/*  57 */     synchronized (this.stickyMap) {
/*  58 */       processor = this.stickyMap.get(key);
/*  59 */       if (processor == null) {
/*  60 */         processor = this.loadBalancer.chooseProcessor(processors, exchange);
/*  61 */         this.stickyMap.put(key, processor);
/*     */       } 
/*     */     } 
/*  64 */     return processor;
/*     */   }
/*     */ 
/*     */   
/*     */   public void removeProcessor(Processor processor) {
/*  69 */     synchronized (this.stickyMap) {
/*  70 */       Iterator<Map.Entry<Object, Processor>> iter = this.stickyMap.entrySet().iterator();
/*  71 */       while (iter.hasNext()) {
/*  72 */         Map.Entry<Object, Processor> entry = iter.next();
/*  73 */         if (processor.equals(entry.getValue())) {
/*  74 */           iter.remove();
/*     */         }
/*     */       } 
/*     */     } 
/*  78 */     super.removeProcessor(processor);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public int getNumberOfHashGroups() { return this.numberOfHashGroups; }
/*     */ 
/*     */ 
/*     */   
/*  89 */   public void setNumberOfHashGroups(int numberOfHashGroups) { this.numberOfHashGroups = numberOfHashGroups; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Object getStickyKey(Object value) {
/* 104 */     int hashCode = 37;
/* 105 */     if (value != null) {
/* 106 */       hashCode = value.hashCode();
/*     */     }
/* 108 */     if (this.numberOfHashGroups > 0) {
/* 109 */       hashCode %= this.numberOfHashGroups;
/*     */     }
/* 111 */     return Integer.valueOf(hashCode);
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\loadbalancer\StickyLoadBalancer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.processor.loadbalancer.TopicLoadBalancer,"/*    */ package org.apache.camel.processor.loadbalancer;
/*    */ 
/*    */ import java.util.List;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Processor;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopicLoadBalancer
/*    */   extends LoadBalancerSupport
/*    */ {
/*    */   public void process(Exchange exchange) throws Exception {
/* 33 */     List<Processor> list = getProcessors();
/* 34 */     for (Processor processor : list) {
/* 35 */       Exchange copy = copyExchangeStrategy(processor, exchange);
/* 36 */       processor.process(copy);
/*    */     } 
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   protected Exchange copyExchangeStrategy(Processor processor, Exchange exchange) { return exchange.copy(); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\processor\loadbalancer\TopicLoadBalancer.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.ComponentResolver,"package org.apache.camel.spi;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
public interface ComponentResolver<E extends org.apache.camel.Exchange> {
  Component<E> resolveComponent(String paramString, CamelContext paramCamelContext) throws Exception;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\ComponentResolver.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.ExceptionHandler,"package org.apache.camel.spi;
public interface ExceptionHandler {
  void handleException(Throwable paramThrowable);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\ExceptionHandler.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.ExchangeConverter,"package org.apache.camel.spi;
import org.apache.camel.Exchange;
public interface ExchangeConverter {
  <T> T convertTo(Class<T> paramClass, Exchange paramExchange);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\ExchangeConverter.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.Injector,"package org.apache.camel.spi;
public interface Injector<T> {
  T newInstance(Class<T> paramClass);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\Injector.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.Marshaller,"package org.apache.camel.spi;
import java.io.IOException;
import java.io.OutputStream;
public interface Marshaller {
  void marshal(Object paramObject, OutputStream paramOutputStream) throws IOException;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\Marshaller.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.Policy,"package org.apache.camel.spi;
import org.apache.camel.Processor;
public interface Policy<E> {
  Processor wrap(Processor paramProcessor);
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\Policy.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.Provider,"package org.apache.camel.spi;
public interface Provider<T> {
  T get();
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\Provider.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.Unmarshaller,"package org.apache.camel.spi;
import java.io.IOException;
import java.io.InputStream;
public interface Unmarshaller {
  Object unmarshal(InputStream paramInputStream) throws IOException;
}
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\Unmarshaller.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.XmlMarshaller,"/*    */ package org.apache.camel.spi;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.OutputStream;
/*    */ import javax.xml.transform.Result;
/*    */ import javax.xml.transform.stream.StreamResult;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class XmlMarshaller
/*    */   implements Marshaller
/*    */ {
/* 36 */   public void marshal(Object object, OutputStream result) throws IOException { marshal(object, new StreamResult(result)); }
/*    */   
/*    */   public abstract void marshal(Object paramObject, Result paramResult);
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\XmlMarshaller.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.spi.XmlUnmarshaller,"/*    */ package org.apache.camel.spi;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.InputStream;
/*    */ import javax.xml.transform.Source;
/*    */ import javax.xml.transform.stream.StreamSource;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class XmlUnmarshaller
/*    */   implements Unmarshaller
/*    */ {
/* 36 */   public Object unmarshal(InputStream stream) throws IOException { return unmarshal(new StreamSource(stream)); }
/*    */   
/*    */   public abstract Object unmarshal(Source paramSource) throws IOException;
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\spi\XmlUnmarshaller.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.CollectionHelper,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import java.util.ArrayList;
/*    */ import java.util.List;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CollectionHelper
/*    */ {
/*    */   public static void appendValue(Map<Object, Object> map, Object key, Object value) {
/* 40 */     Object oldValue = map.get(key);
/* 41 */     if (oldValue != null) {
/*    */       List<Object> list;
/* 43 */       if (oldValue instanceof List) {
/* 44 */         list = (List)oldValue;
/*    */       } else {
/*    */         
/* 47 */         list = new ArrayList();
/* 48 */         list.add(oldValue);
/*    */       } 
/* 50 */       list.add(value);
/*    */     } else {
/*    */       
/* 53 */       map.put(key, value);
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\CollectionHelper.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ExchangeHelper,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.NoSuchEndpointException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ExchangeHelper
/*    */ {
/*    */   public static <E extends org.apache.camel.Exchange> Endpoint<E> resolveEndpoint(E exchange, Object value) throws NoSuchEndpointException {
/*    */     Endpoint<E> endpoint;
/* 44 */     if (value instanceof Endpoint) {
/* 45 */       endpoint = (Endpoint<E>)value;
/*    */     } else {
/*    */       
/* 48 */       String uri = value.toString();
/* 49 */       endpoint = exchange.getContext().getEndpoint(uri);
/* 50 */       if (endpoint == null) {
/* 51 */         throw new NoSuchEndpointException(uri);
/*    */       }
/*    */     } 
/* 54 */     return endpoint;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ExchangeHelper.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ExpressionComparator,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import java.util.Comparator;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ExpressionComparator<E extends Exchange>
/*    */   implements Comparator<E>
/*    */ {
/*    */   private final Expression<E> expression;
/*    */   
/* 35 */   public ExpressionComparator(Expression<E> expression) { this.expression = expression; }
/*    */ 
/*    */   
/*    */   public int compare(E e1, E e2) {
/* 39 */     Object o1 = this.expression.evaluate((Exchange)e1);
/* 40 */     Object o2 = this.expression.evaluate((Exchange)e2);
/* 41 */     return ObjectHelper.compare(o1, o2);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ExpressionComparator.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ExpressionHelper,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ExpressionHelper
/*    */ {
/* 38 */   public static <E extends Exchange> String evaluateAsString(Expression<E> expression, E exchange) { return evaluateAsType(expression, exchange, String.class); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static <T, E extends Exchange> T evaluateAsType(Expression<E> expression, E exchange, Class<T> resultType) {
/* 50 */     Object value = expression.evaluate((Exchange)exchange);
/* 51 */     return (T)exchange.getContext().getTypeConverter().convertTo(resultType, value);
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ExpressionHelper.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ExpressionListComparator,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import java.util.Comparator;
/*    */ import java.util.List;
/*    */ import org.apache.camel.Exchange;
/*    */ import org.apache.camel.Expression;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ExpressionListComparator<E extends Exchange>
/*    */   implements Comparator<E>
/*    */ {
/*    */   private final List<Expression<E>> expressions;
/*    */   
/* 37 */   public ExpressionListComparator(List<Expression<E>> expressions) { this.expressions = expressions; }
/*    */ 
/*    */   
/*    */   public int compare(E e1, E e2) {
/* 41 */     for (Expression<E> expression : this.expressions) {
/* 42 */       Object o1 = expression.evaluate((Exchange)e1);
/* 43 */       Object o2 = expression.evaluate((Exchange)e2);
/* 44 */       int answer = ObjectHelper.compare(o1, o2);
/* 45 */       if (answer != 0) {
/* 46 */         return answer;
/*    */       }
/*    */     } 
/* 49 */     return 0;
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ExpressionListComparator.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.FactoryFinder,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.io.BufferedInputStream;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.util.Properties;
/*     */ import java.util.concurrent.ConcurrentHashMap;
/*     */ import org.apache.camel.spi.Injector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FactoryFinder
/*     */ {
/*     */   private final String path;
/*  30 */   private final ConcurrentHashMap classMap = new ConcurrentHashMap<Object, Object>();
/*     */ 
/*     */   
/*  33 */   public FactoryFinder() { this(""META-INF/services/org/apache/camel/""); }
/*     */ 
/*     */ 
/*     */   
/*  37 */   public FactoryFinder(String path) { this.path = path; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  49 */   public Object newInstance(String key) throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException { return newInstance(key, (String)null); }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object newInstance(String key, String propertyPrefix) throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException {
/*  54 */     Class clazz = findClass(key, propertyPrefix);
/*  55 */     return clazz.newInstance();
/*     */   }
/*     */ 
/*     */   
/*  59 */   public Object newInstance(String key, Injector injector) throws IOException, ClassNotFoundException { return newInstance(key, injector, null); }
/*     */ 
/*     */   
/*     */   public Object newInstance(String key, Injector injector, String propertyPrefix) throws IOException, ClassNotFoundException {
/*  63 */     Class type = findClass(key, propertyPrefix);
/*  64 */     return injector.newInstance(type);
/*     */   }
/*     */ 
/*     */   
/*  68 */   public Class findClass(String key) throws ClassNotFoundException, IOException { return findClass(key, null); }
/*     */ 
/*     */   
/*     */   public Class findClass(String key, String propertyPrefix) throws ClassNotFoundException, IOException {
/*  72 */     if (propertyPrefix == null) {
/*  73 */       propertyPrefix = """";
/*     */     }
/*     */     
/*  76 */     Class<?> clazz = (Class)this.classMap.get(propertyPrefix + key);
/*  77 */     if (clazz == null) {
/*  78 */       clazz = newInstance(doFindFactoryProperies(key), propertyPrefix);
/*  79 */       this.classMap.put(propertyPrefix + key, clazz);
/*     */     } 
/*  81 */     return clazz;
/*     */   }
/*     */ 
/*     */   
/*     */   private Class newInstance(Properties properties, String propertyPrefix) throws ClassNotFoundException, IOException {
/*  86 */     String className = properties.getProperty(propertyPrefix + ""class"");
/*  87 */     if (className == null) {
/*  88 */       throw new IOException(""Expected property is missing: "" + propertyPrefix + ""class"");
/*     */     }
/*  90 */     Class<?> clazz = null;
/*  91 */     ClassLoader loader = Thread.currentThread().getContextClassLoader();
/*  92 */     if (loader != null) {
/*     */       try {
/*  94 */         clazz = loader.loadClass(className);
/*     */       }
/*  96 */       catch (ClassNotFoundException e) {}
/*     */     }
/*     */ 
/*     */     
/* 100 */     if (clazz == null) {
/* 101 */       clazz = FactoryFinder.class.getClassLoader().loadClass(className);
/*     */     }
/* 103 */     return clazz;
/*     */   }
/*     */   
/*     */   private Properties doFindFactoryProperies(String key) throws IOException {
/* 107 */     String uri = this.path + key;
/*     */ 
/*     */     
/* 110 */     ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
/* 111 */     if (classLoader == null) {
/* 112 */       classLoader = getClass().getClassLoader();
/*     */     }
/* 114 */     InputStream in = classLoader.getResourceAsStream(uri);
/* 115 */     if (in == null) {
/* 116 */       in = FactoryFinder.class.getClassLoader().getResourceAsStream(uri);
/* 117 */       if (in == null) {
/* 118 */         throw new NoFactoryAvailableException(uri);
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 123 */     BufferedInputStream reader = null;
/*     */     try {
/* 125 */       reader = new BufferedInputStream(in);
/* 126 */       Properties properties = new Properties();
/* 127 */       properties.load(reader);
/* 128 */       return properties;
/*     */     } finally {
/*     */       
/*     */       try {
/* 132 */         reader.close();
/*     */       }
/* 134 */       catch (Exception e) {}
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\FactoryFinder.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.IntrospectionSupport,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.beans.PropertyEditor;
/*     */ import java.beans.PropertyEditorManager;
/*     */ import java.lang.reflect.Field;
/*     */ import java.lang.reflect.Method;
/*     */ import java.lang.reflect.Modifier;
/*     */ import java.net.URI;
/*     */ import java.net.URISyntaxException;
/*     */ import java.util.Arrays;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedHashMap;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IntrospectionSupport
/*     */ {
/*     */   public static boolean getProperties(Object target, Map<String, String> props, String optionPrefix) {
/*  40 */     boolean rc = false;
/*  41 */     if (target == null)
/*  42 */       throw new IllegalArgumentException(""target was null.""); 
/*  43 */     if (props == null) {
/*  44 */       throw new IllegalArgumentException(""props was null."");
/*     */     }
/*  46 */     if (optionPrefix == null) {
/*  47 */       optionPrefix = """";
/*     */     }
/*  49 */     Class<?> clazz = target.getClass();
/*  50 */     Method[] methods = clazz.getMethods();
/*  51 */     for (int i = 0; i < methods.length; i++) {
/*  52 */       Method method = methods[i];
/*  53 */       String name = method.getName();
/*  54 */       Class<?> type = method.getReturnType();
/*  55 */       Class[] params = method.getParameterTypes();
/*  56 */       if (name.startsWith(""get"") && params.length == 0 && type != null && isSettableType(type)) {
/*     */         
/*     */         try {
/*     */ 
/*     */           
/*  61 */           Object value = method.invoke(target, new Object[0]);
/*  62 */           if (value != null) {
/*     */ 
/*     */             
/*  65 */             String strValue = convertToString(value, type);
/*  66 */             if (strValue != null)
/*     */             
/*     */             { 
/*  69 */               name = name.substring(3, 4).toLowerCase() + name.substring(4);
/*  70 */               props.put(optionPrefix + name, strValue);
/*  71 */               rc = true; } 
/*     */           } 
/*  73 */         } catch (Throwable ignore) {}
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/*  79 */     return rc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public static boolean setProperties(Object target, Map props, String optionPrefix) {
/*  85 */     boolean rc = false;
/*  86 */     if (target == null)
/*  87 */       throw new IllegalArgumentException(""target was null.""); 
/*  88 */     if (props == null) {
/*  89 */       throw new IllegalArgumentException(""props was null."");
/*     */     }
/*  91 */     for (Iterator<String> iter = props.keySet().iterator(); iter.hasNext(); ) {
/*  92 */       String name = iter.next();
/*  93 */       if (name.startsWith(optionPrefix)) {
/*  94 */         Object value = props.get(name);
/*  95 */         name = name.substring(optionPrefix.length());
/*  96 */         if (setProperty(target, name, value)) {
/*  97 */           iter.remove();
/*  98 */           rc = true;
/*     */         } 
/*     */       } 
/*     */     } 
/* 102 */     return rc;
/*     */   }
/*     */   
/*     */   public static Map extractProperties(Map props, String optionPrefix) {
/* 106 */     if (props == null) {
/* 107 */       throw new IllegalArgumentException(""props was null."");
/*     */     }
/* 109 */     HashMap<Object, Object> rc = new HashMap<Object, Object>(props.size());
/*     */     
/* 111 */     for (Iterator<String> iter = props.keySet().iterator(); iter.hasNext(); ) {
/* 112 */       String name = iter.next();
/* 113 */       if (name.startsWith(optionPrefix)) {
/* 114 */         Object value = props.get(name);
/* 115 */         name = name.substring(optionPrefix.length());
/* 116 */         rc.put(name, value);
/* 117 */         iter.remove();
/*     */       } 
/*     */     } 
/*     */     
/* 121 */     return rc;
/*     */   }
/*     */   
/*     */   public static boolean setProperties(Object target, Map props) {
/* 125 */     boolean rc = false;
/*     */     
/* 127 */     if (target == null)
/* 128 */       throw new IllegalArgumentException(""target was null.""); 
/* 129 */     if (props == null) {
/* 130 */       throw new IllegalArgumentException(""props was null."");
/*     */     }
/* 132 */     for (Iterator<Map.Entry> iter = props.entrySet().iterator(); iter.hasNext(); ) {
/* 133 */       Map.Entry entry = iter.next();
/* 134 */       if (setProperty(target, (String)entry.getKey(), entry.getValue())) {
/* 135 */         iter.remove();
/* 136 */         rc = true;
/*     */       } 
/*     */     } 
/*     */     
/* 140 */     return rc;
/*     */   }
/*     */   
/*     */   public static boolean setProperty(Object target, String name, Object value) {
/*     */     try {
/* 145 */       Class<?> clazz = target.getClass();
/* 146 */       Method setter = findSetterMethod(clazz, name);
/* 147 */       if (setter == null) {
/* 148 */         return false;
/*     */       }
/*     */       
/* 151 */       if (value == null || value.getClass() == setter.getParameterTypes()[0]) {
/* 152 */         setter.invoke(target, new Object[] { value });
/*     */       } else {
/*     */         
/* 155 */         setter.invoke(target, new Object[] { convert(value, setter.getParameterTypes()[0]) });
/*     */       } 
/* 157 */       return true;
/* 158 */     } catch (Throwable ignore) {
/* 159 */       return false;
/*     */     } 
/*     */   }
/*     */   
/*     */   private static Object convert(Object value, Class<?> type) throws URISyntaxException {
/* 164 */     PropertyEditor editor = PropertyEditorManager.findEditor(type);
/* 165 */     if (editor != null) {
/* 166 */       editor.setAsText(value.toString());
/* 167 */       return editor.getValue();
/*     */     } 
/* 169 */     if (type == URI.class) {
/* 170 */       return new URI(value.toString());
/*     */     }
/* 172 */     return null;
/*     */   }
/*     */   
/*     */   private static String convertToString(Object value, Class<?> type) throws URISyntaxException {
/* 176 */     PropertyEditor editor = PropertyEditorManager.findEditor(type);
/* 177 */     if (editor != null) {
/* 178 */       editor.setValue(value);
/* 179 */       return editor.getAsText();
/*     */     } 
/* 181 */     if (type == URI.class) {
/* 182 */       return ((URI)value).toString();
/*     */     }
/* 184 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   private static Method findSetterMethod(Class clazz, String name) {
/* 189 */     name = ""set"" + name.substring(0, 1).toUpperCase() + name.substring(1);
/* 190 */     Method[] methods = clazz.getMethods();
/* 191 */     for (int i = 0; i < methods.length; i++) {
/* 192 */       Method method = methods[i];
/* 193 */       Class[] params = method.getParameterTypes();
/* 194 */       if (method.getName().equals(name) && params.length == 1 && isSettableType(params[0]))
/*     */       {
/*     */         
/* 197 */         return method;
/*     */       }
/*     */     } 
/* 200 */     return null;
/*     */   }
/*     */   
/*     */   private static boolean isSettableType(Class<URI> clazz) {
/* 204 */     if (PropertyEditorManager.findEditor(clazz) != null)
/* 205 */       return true; 
/* 206 */     if (clazz == URI.class)
/* 207 */       return true; 
/* 208 */     if (clazz == Boolean.class)
/* 209 */       return true; 
/* 210 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 214 */   public static String toString(Object target) { return toString(target, Object.class); }
/*     */ 
/*     */   
/*     */   public static String toString(Object target, Class stopClass) {
/* 218 */     LinkedHashMap<Object, Object> map = new LinkedHashMap<Object, Object>();
/* 219 */     addFields(target, target.getClass(), stopClass, map);
/* 220 */     StringBuffer buffer = new StringBuffer(simpleName(target.getClass()));
/* 221 */     buffer.append("" {"");
/* 222 */     Set<Map.Entry<Object, Object>> entrySet = map.entrySet();
/* 223 */     boolean first = true;
/* 224 */     for (Iterator<Map.Entry<Object, Object>> iter = entrySet.iterator(); iter.hasNext(); ) {
/* 225 */       Map.Entry entry = iter.next();
/* 226 */       if (first) {
/* 227 */         first = false;
/*     */       } else {
/*     */         
/* 230 */         buffer.append("", "");
/*     */       } 
/* 232 */       buffer.append(entry.getKey());
/* 233 */       buffer.append("" = "");
/* 234 */       appendToString(buffer, entry.getValue());
/*     */     } 
/* 236 */     buffer.append(""}"");
/* 237 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 246 */   protected static void appendToString(StringBuffer buffer, Object value) { buffer.append(value); }
/*     */ 
/*     */ 
/*     */   
/*     */   public static String simpleName(Class clazz) {
/* 251 */     String name = clazz.getName();
/* 252 */     int p = name.lastIndexOf(""."");
/* 253 */     if (p >= 0) {
/* 254 */       name = name.substring(p + 1);
/*     */     }
/* 256 */     return name;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private static void addFields(Object target, Class startClass, Class stopClass, LinkedHashMap<String, Object> map) {
/* 262 */     if (startClass != stopClass) {
/* 263 */       addFields(target, startClass.getSuperclass(), stopClass, map);
/*     */     }
/* 265 */     Field[] fields = startClass.getDeclaredFields();
/* 266 */     for (int i = 0; i < fields.length; i++) {
/* 267 */       Field field = fields[i];
/* 268 */       if (!Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers()) && !Modifier.isPrivate(field.getModifiers()))
/*     */         
/*     */         try {
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 275 */           field.setAccessible(true);
/* 276 */           Object o = field.get(target);
/* 277 */           if (o != null && o.getClass().isArray()) {
/*     */             try {
/* 279 */               o = Arrays.asList((Object[])o);
/* 280 */             } catch (Throwable e) {}
/*     */           }
/*     */           
/* 283 */           map.put(field.getName(), o);
/* 284 */         } catch (Throwable e) {
/* 285 */           e.printStackTrace();
/*     */         }  
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\IntrospectionSupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.LRUCache,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import java.util.LinkedHashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LRUCache<K, V>
/*    */   extends LinkedHashMap<K, V>
/*    */ {
/*    */   private static final long serialVersionUID = -342098639681884413L;
/* 30 */   private int maxCacheSize = 10000;
/*    */ 
/*    */   
/* 33 */   public LRUCache(int maximumCacheSize) { this(maximumCacheSize, maximumCacheSize, 0.75F, true); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public LRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
/* 49 */     super(initialCapacity, loadFactor, accessOrder);
/* 50 */     this.maxCacheSize = maximumCacheSize;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 57 */   public int getMaxCacheSize() { return this.maxCacheSize; }
/*    */ 
/*    */ 
/*    */   
/* 61 */   protected boolean removeEldestEntry(Map.Entry entry) { return (size() > this.maxCacheSize); }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\LRUCache.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.NoFactoryAvailableException,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoFactoryAvailableException
/*    */   extends IOException
/*    */ {
/*    */   private final String uri;
/*    */   
/*    */   public NoFactoryAvailableException(String uri) {
/* 31 */     super(""Could not find factory class for resource: "" + uri);
/* 32 */     this.uri = uri;
/*    */   }
/*    */ 
/*    */   
/* 36 */   public String getUri() { return this.uri; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\NoFactoryAvailableException.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ObjectHelper,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.lang.annotation.Annotation;
/*     */ import java.lang.reflect.InvocationTargetException;
/*     */ import java.lang.reflect.Method;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.camel.RuntimeCamelException;
/*     */ import org.apache.camel.converter.ObjectConverter;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ObjectHelper
/*     */ {
/*  36 */   private static final transient Log log = LogFactory.getLog(ObjectHelper.class);
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static boolean equals(Object a, Object b) {
/*  42 */     if (a == b) {
/*  43 */       return true;
/*     */     }
/*  45 */     return (a != null && b != null && a.equals(b));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static int compare(Object a, Object b) {
/*  54 */     if (a == b) {
/*  55 */       return 0;
/*     */     }
/*  57 */     if (a == null) {
/*  58 */       return -1;
/*     */     }
/*  60 */     if (b == null) {
/*  61 */       return 1;
/*     */     }
/*  63 */     if (a instanceof Comparable) {
/*  64 */       Comparable<Object> comparable = (Comparable)a;
/*  65 */       return comparable.compareTo(b);
/*     */     } 
/*     */     
/*  68 */     int answer = a.getClass().getName().compareTo(b.getClass().getName());
/*  69 */     if (answer == 0) {
/*  70 */       answer = a.hashCode() - b.hashCode();
/*     */     }
/*  72 */     return answer;
/*     */   }
/*     */ 
/*     */   
/*     */   public static void notNull(Object value, String name) {
/*  77 */     if (value == null) {
/*  78 */       throw new IllegalArgumentException(""No "" + name + "" specified"");
/*     */     }
/*     */   }
/*     */   
/*     */   public static String[] splitOnCharacter(String value, String needle, int count) {
/*  83 */     String[] rc = new String[count];
/*  84 */     rc[0] = value;
/*  85 */     for (int i = 1; i < count; i++) {
/*  86 */       String v = rc[i - 1];
/*  87 */       int p = v.indexOf(needle);
/*  88 */       if (p < 0) {
/*  89 */         return rc;
/*     */       }
/*  91 */       rc[i - 1] = v.substring(0, p);
/*  92 */       rc[i] = v.substring(p + 1);
/*     */     } 
/*  94 */     return rc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String removeStartingCharacters(String text, char ch) {
/* 105 */     int idx = 0;
/* 106 */     while (text.charAt(idx) == ch) {
/* 107 */       idx++;
/*     */     }
/* 109 */     if (idx > 0) {
/* 110 */       return text.substring(idx);
/*     */     }
/* 112 */     return text;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static boolean contains(Object collectionOrArray, Object value) {
/* 119 */     if (collectionOrArray instanceof Collection) {
/* 120 */       Collection collection = (Collection)collectionOrArray;
/* 121 */       return collection.contains(value);
/*     */     } 
/*     */     
/* 124 */     Iterator iter = ObjectConverter.iterator(value);
/* 125 */     while (iter.hasNext()) {
/* 126 */       if (equals(value, iter.next())) {
/* 127 */         return true;
/*     */       }
/*     */     } 
/* 130 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static boolean matches(List list) {
/* 142 */     if (!list.isEmpty()) {
/* 143 */       Object value = list.get(0);
/* 144 */       if (value instanceof Boolean) {
/* 145 */         Boolean flag = (Boolean)value;
/* 146 */         return flag.booleanValue();
/*     */       } 
/*     */ 
/*     */       
/* 150 */       return true;
/*     */     } 
/*     */     
/* 153 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 157 */   public static boolean isNotNullOrBlank(String text) { return (text != null && text.trim().length() > 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String getSystemProperty(String name, String defaultValue) {
/*     */     try {
/* 169 */       return System.getProperty(name, defaultValue);
/*     */     }
/* 171 */     catch (Exception e) {
/* 172 */       if (log.isDebugEnabled()) {
/* 173 */         log.debug(""Caught security exception accessing system property: "" + name + "". Reason: "" + e, e);
/*     */       }
/* 175 */       return defaultValue;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 183 */   public static String name(Class type) { return (type != null) ? type.getName() : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 190 */   public static String className(Object value) { return name((value != null) ? value.getClass() : null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 201 */   public static Class<?> loadClass(String name) { return loadClass(name, ObjectHelper.class.getClassLoader()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Class<?> loadClass(String name, ClassLoader loader) {
/* 212 */     ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
/* 213 */     if (contextClassLoader != null) {
/*     */       try {
/* 215 */         return contextClassLoader.loadClass(name);
/*     */       }
/* 217 */       catch (ClassNotFoundException e) {
/*     */         try {
/* 219 */           return loader.loadClass(name);
/*     */         }
/* 221 */         catch (ClassNotFoundException e1) {
/* 222 */           log.debug(""Could not find class: "" + name + "". Reason: "" + e);
/*     */         } 
/*     */       } 
/*     */     }
/* 226 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Object invokeMethod(Method method, Object instance, Object... parameters) {
/*     */     try {
/* 240 */       return method.invoke(instance, parameters);
/*     */     }
/* 242 */     catch (IllegalAccessException e) {
/* 243 */       throw new RuntimeCamelException(e);
/*     */     }
/* 245 */     catch (InvocationTargetException e) {
/* 246 */       throw new RuntimeCamelException(e.getCause());
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static List<Method> findMethodsWithAnnotation(Class<?> type, Class<? extends Annotation> annotationType) {
/* 258 */     List<Method> answer = new ArrayList<Method>();
/*     */     do {
/* 260 */       Method[] methods = type.getDeclaredMethods();
/* 261 */       for (Method method : methods) {
/* 262 */         if (method.getAnnotation((Class)annotationType) != null) {
/* 263 */           answer.add(method);
/*     */         }
/*     */       } 
/* 266 */       type = type.getSuperclass();
/*     */     }
/* 268 */     while (type != null);
/* 269 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String asString(Object[] objects) {
/* 279 */     if (objects == null) {
/* 280 */       return ""null"";
/*     */     }
/*     */     
/* 283 */     StringBuffer buffer = new StringBuffer(""{"");
/* 284 */     int counter = 0;
/* 285 */     for (Object object : objects) {
/* 286 */       if (counter++ > 0) {
/* 287 */         buffer.append("", "");
/*     */       }
/* 289 */       String text = (object == null) ? ""null"" : object.toString();
/* 290 */       buffer.append(text);
/*     */     } 
/* 292 */     buffer.append(""}"");
/* 293 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ObjectHelper.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ProducerCache,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import org.apache.camel.Endpoint;
/*     */ import org.apache.camel.Exchange;
/*     */ import org.apache.camel.FailedToCreateProducerException;
/*     */ import org.apache.camel.Processor;
/*     */ import org.apache.camel.Producer;
/*     */ import org.apache.camel.RuntimeCamelException;
/*     */ import org.apache.camel.impl.ServiceSupport;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ProducerCache<E extends Exchange>
/*     */   extends ServiceSupport
/*     */ {
/*  37 */   private static final Log log = LogFactory.getLog(ProducerCache.class);
/*     */   
/*  39 */   private Map<String, Producer<E>> producers = new HashMap<String, Producer<E>>();
/*     */   
/*     */   public synchronized Producer<E> getProducer(Endpoint<E> endpoint) {
/*  42 */     String key = endpoint.getEndpointUri();
/*  43 */     Producer<E> answer = this.producers.get(key);
/*  44 */     if (answer == null) {
/*     */       try {
/*  46 */         answer = endpoint.createProducer();
/*  47 */         answer.start();
/*     */       }
/*  49 */       catch (Exception e) {
/*  50 */         throw new FailedToCreateProducerException(endpoint, e);
/*     */       } 
/*  52 */       this.producers.put(key, answer);
/*     */     } 
/*  54 */     return answer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void send(Endpoint<E> endpoint, E exchange) {
/*     */     try {
/*  65 */       Producer<E> producer = getProducer(endpoint);
/*  66 */       producer.process((Exchange)exchange);
/*     */     }
/*  68 */     catch (Exception e) {
/*  69 */       throw new RuntimeCamelException(e);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public E send(Endpoint<E> endpoint, Processor processor) {
/*     */     try {
/*  81 */       Producer<E> producer = getProducer(endpoint);
/*  82 */       Exchange exchange1 = producer.createExchange();
/*     */ 
/*     */       
/*  85 */       processor.process(exchange1);
/*     */ 
/*     */       
/*  88 */       if (log.isDebugEnabled()) {
/*  89 */         log.debug("">>>> "" + endpoint + "" "" + exchange1);
/*     */       }
/*  91 */       producer.process(exchange1);
/*  92 */       return (E)exchange1;
/*     */     }
/*  94 */     catch (Exception e) {
/*  95 */       throw new RuntimeCamelException(e);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 100 */   protected void doStop() throws Exception { ServiceHelper.stopServices(this.producers.values()); }
/*     */   
/*     */   protected void doStart() throws Exception {}
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ProducerCache.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ResolverUtil,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileInputStream;
/*     */ import java.io.IOException;
/*     */ import java.lang.annotation.Annotation;
/*     */ import java.net.URL;
/*     */ import java.net.URLDecoder;
/*     */ import java.util.Enumeration;
/*     */ import java.util.HashSet;
/*     */ import java.util.Set;
/*     */ import java.util.jar.JarEntry;
/*     */ import java.util.jar.JarInputStream;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ResolverUtil<T>
/*     */ {
/*  68 */   private static final transient Log log = LogFactory.getLog(ResolverUtil.class);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static interface Test
/*     */   {
/*     */     boolean matches(Class param1Class);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static class IsA
/*     */     implements Test
/*     */   {
/*     */     private Class parent;
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  90 */     public IsA(Class parentType) { this.parent = parentType; }
/*     */ 
/*     */ 
/*     */     
/*  94 */     public boolean matches(Class<?> type) { return (type != null && this.parent.isAssignableFrom(type)); }
/*     */ 
/*     */ 
/*     */     
/*  98 */     public String toString() { return ""is assignable to "" + this.parent.getSimpleName(); }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public static class AnnotatedWith
/*     */     implements Test
/*     */   {
/*     */     private Class<? extends Annotation> annotation;
/*     */ 
/*     */ 
/*     */     
/* 110 */     public AnnotatedWith(Class<? extends Annotation> annotation) { this.annotation = annotation; }
/*     */ 
/*     */ 
/*     */     
/* 114 */     public boolean matches(Class type) { return (type != null && type.isAnnotationPresent(this.annotation)); }
/*     */ 
/*     */ 
/*     */     
/* 118 */     public String toString() { return ""annotated with @"" + this.annotation.getSimpleName(); }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 123 */   private Set<Class<? extends T>> matches = new HashSet<Class<? extends T>>();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private ClassLoader classloader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 138 */   public Set<Class<? extends T>> getClasses() { return this.matches; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 148 */   public ClassLoader getClassLoader() { return (this.classloader == null) ? Thread.currentThread().getContextClassLoader() : this.classloader; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 157 */   public void setClassLoader(ClassLoader classloader) { this.classloader = classloader; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void findImplementations(Class parent, String... packageNames) {
/* 169 */     if (packageNames == null)
/*     */       return; 
/* 171 */     Test test = new IsA(parent);
/* 172 */     for (String pkg : packageNames) {
/* 173 */       find(test, pkg);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void findAnnotated(Class<? extends Annotation> annotation, String... packageNames) {
/* 185 */     if (packageNames == null)
/*     */       return; 
/* 187 */     Test test = new AnnotatedWith(annotation);
/* 188 */     for (String pkg : packageNames) {
/* 189 */       find(test, pkg);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void find(Test test, String packageName) {
/*     */     Enumeration<URL> urls;
/* 204 */     packageName = packageName.replace('.', '/');
/* 205 */     ClassLoader loader = getClassLoader();
/*     */ 
/*     */     
/*     */     try {
/* 209 */       urls = loader.getResources(packageName);
/*     */     }
/* 211 */     catch (IOException ioe) {
/* 212 */       log.warn(""Could not read package: "" + packageName, ioe);
/*     */       
/*     */       return;
/*     */     } 
/* 216 */     while (urls.hasMoreElements()) {
/*     */       try {
/* 218 */         String urlPath = ((URL)urls.nextElement()).getFile();
/* 219 */         urlPath = URLDecoder.decode(urlPath, ""UTF-8"");
/*     */ 
/*     */         
/* 222 */         if (urlPath.startsWith(""file:"")) {
/* 223 */           urlPath = urlPath.substring(5);
/*     */         }
/*     */ 
/*     */         
/* 227 */         if (urlPath.indexOf('!') > 0) {
/* 228 */           urlPath = urlPath.substring(0, urlPath.indexOf('!'));
/*     */         }
/*     */         
/* 231 */         log.debug(""Scanning for classes in ["" + urlPath + ""] matching criteria: "" + test);
/* 232 */         File file = new File(urlPath);
/* 233 */         if (file.isDirectory()) {
/* 234 */           loadImplementationsInDirectory(test, packageName, file);
/*     */           continue;
/*     */         } 
/* 237 */         loadImplementationsInJar(test, packageName, file);
/*     */       
/*     */       }
/* 240 */       catch (IOException ioe) {
/* 241 */         log.warn(""could not read entries"", ioe);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void loadImplementationsInDirectory(Test test, String parent, File location) {
/* 260 */     File[] files = location.listFiles();
/* 261 */     StringBuilder builder = null;
/*     */     
/* 263 */     for (File file : files) {
/* 264 */       builder = new StringBuilder(100);
/* 265 */       builder.append(parent).append(""/"").append(file.getName());
/* 266 */       String packageOrClass = (parent == null) ? file.getName() : builder.toString();
/*     */       
/* 268 */       if (file.isDirectory()) {
/* 269 */         loadImplementationsInDirectory(test, packageOrClass, file);
/*     */       }
/* 271 */       else if (file.getName().endsWith("".class"")) {
/* 272 */         addIfMatching(test, packageOrClass);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void loadImplementationsInJar(Test test, String parent, File jarfile) {
/*     */     try {
/* 290 */       JarInputStream jarStream = new JarInputStream(new FileInputStream(jarfile));
/*     */       JarEntry entry;
/* 292 */       while ((entry = jarStream.getNextJarEntry()) != null) {
/* 293 */         String name = entry.getName();
/* 294 */         if (!entry.isDirectory() && name.startsWith(parent) && name.endsWith("".class"")) {
/* 295 */           addIfMatching(test, name);
/*     */         }
/*     */       }
/*     */     
/* 299 */     } catch (IOException ioe) {
/* 300 */       log.error(""Could not search jar file '"" + jarfile + ""' for classes matching criteria: "" + test + ""due to an IOException: "" + ioe.getMessage());
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void addIfMatching(Test test, String fqn) {
/*     */     try {
/* 314 */       String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
/* 315 */       ClassLoader loader = getClassLoader();
/* 316 */       log.trace(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ""]"");
/*     */       
/* 318 */       Class<?> type = loader.loadClass(externalName);
/* 319 */       if (test.matches(type)) {
/* 320 */         this.matches.add(type);
/*     */       }
/*     */     }
/* 323 */     catch (Throwable t) {
/* 324 */       log.warn(""Could not examine class '"" + fqn + ""' due to a "" + t.getClass().getName() + "" with message: "" + t.getMessage());
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ResolverUtil.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.ServiceHelper,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.util.Collection;
/*     */ import org.apache.camel.Service;
/*     */ import org.apache.commons.logging.Log;
/*     */ import org.apache.commons.logging.LogFactory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ServiceHelper
/*     */ {
/*  32 */   private static final transient Log log = LogFactory.getLog(ServiceHelper.class);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void startServices(Object... services) throws Exception {
/*  39 */     for (Object value : services) {
/*  40 */       startService(value);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void startServices(Collection services) throws Exception {
/*  48 */     for (Object value : services) {
/*  49 */       if (value instanceof Service) {
/*  50 */         Service service = (Service)value;
/*  51 */         service.start();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public static void startService(Object value) throws Exception {
/*  57 */     if (value instanceof Service) {
/*  58 */       Service service = (Service)value;
/*  59 */       service.start();
/*     */     }
/*  61 */     else if (value instanceof Collection) {
/*  62 */       startServices((Collection)value);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void stopServices(Object... services) throws Exception {
/*  70 */     Exception firstException = null;
/*  71 */     for (Object value : services) {
/*  72 */       if (value instanceof Service) {
/*  73 */         Service service = (Service)value;
/*     */         try {
/*  75 */           service.stop();
/*     */         }
/*  77 */         catch (Exception e) {
/*  78 */           log.debug(""Caught exception shutting down: "" + e, e);
/*  79 */           if (firstException == null) {
/*  80 */             firstException = e;
/*     */           }
/*     */         } 
/*     */       } 
/*     */     } 
/*  85 */     if (firstException != null) {
/*  86 */       throw firstException;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public static void stopServices(Collection services) throws Exception {
/*  93 */     Exception firstException = null;
/*  94 */     for (Object value : services) {
/*  95 */       if (value instanceof Service) {
/*  96 */         Service service = (Service)value;
/*     */         try {
/*  98 */           service.stop();
/*     */         }
/* 100 */         catch (Exception e) {
/* 101 */           log.debug(""Caught exception shutting down: "" + e, e);
/* 102 */           if (firstException == null) {
/* 103 */             firstException = e;
/*     */           }
/*     */         } 
/*     */       } 
/*     */     } 
/* 108 */     if (firstException != null)
/* 109 */       throw firstException; 
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\ServiceHelper.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.Time,"/*    */ package org.apache.camel.util;
/*    */ 
/*    */ import java.util.Date;
/*    */ import java.util.concurrent.TimeUnit;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Time
/*    */ {
/*    */   private long number;
/* 29 */   private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
/*    */ 
/*    */   
/* 32 */   public static Time millis(long value) { return new Time(value, TimeUnit.MILLISECONDS); }
/*    */ 
/*    */ 
/*    */   
/* 36 */   public static Time micros(long value) { return new Time(value, TimeUnit.MICROSECONDS); }
/*    */ 
/*    */ 
/*    */   
/* 40 */   public static Time nanos(long value) { return new Time(value, TimeUnit.NANOSECONDS); }
/*    */ 
/*    */ 
/*    */   
/* 44 */   public static Time seconds(long value) { return new Time(value, TimeUnit.SECONDS); }
/*    */ 
/*    */ 
/*    */   
/* 48 */   public static Time minutes(long value) { return new Time(minutesAsSeconds(value), TimeUnit.MILLISECONDS); }
/*    */ 
/*    */ 
/*    */   
/* 52 */   public static Time hours(long value) { return new Time(hoursAsSeconds(value), TimeUnit.MILLISECONDS); }
/*    */ 
/*    */ 
/*    */   
/* 56 */   public static Time days(long value) { return new Time(daysAsSeconds(value), TimeUnit.MILLISECONDS); }
/*    */ 
/*    */   
/*    */   public Time(long number, TimeUnit timeUnit) {
/* 60 */     this.number = number;
/* 61 */     this.timeUnit = timeUnit;
/*    */   }
/*    */ 
/*    */   
/* 65 */   public long toMillis() { return this.timeUnit.toMillis(this.number); }
/*    */ 
/*    */ 
/*    */   
/* 69 */   public Date toDate() { return new Date(toMillis()); }
/*    */ 
/*    */ 
/*    */   
/* 73 */   public long getNumber() { return this.number; }
/*    */ 
/*    */ 
/*    */   
/* 77 */   public TimeUnit getTimeUnit() { return this.timeUnit; }
/*    */ 
/*    */ 
/*    */   
/* 81 */   protected static long minutesAsSeconds(long value) { return value * 60L; }
/*    */ 
/*    */ 
/*    */   
/* 85 */   protected static long hoursAsSeconds(long value) { return minutesAsSeconds(value) * 60L; }
/*    */ 
/*    */ 
/*    */   
/* 89 */   protected static long daysAsSeconds(long value) { return hoursAsSeconds(value) * 24L; }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\Time.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.URISupport,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.io.UnsupportedEncodingException;
/*     */ import java.net.URI;
/*     */ import java.net.URISyntaxException;
/*     */ import java.net.URLDecoder;
/*     */ import java.net.URLEncoder;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collections;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class URISupport
/*     */ {
/*     */   public static class CompositeData
/*     */   {
/*     */     String scheme;
/*     */     String path;
/*     */     URI[] components;
/*     */     Map parameters;
/*     */     String fragment;
/*     */     public String host;
/*     */     
/*  44 */     public URI[] getComponents() { return this.components; }
/*     */ 
/*     */ 
/*     */     
/*  48 */     public String getFragment() { return this.fragment; }
/*     */ 
/*     */ 
/*     */     
/*  52 */     public Map getParameters() { return this.parameters; }
/*     */ 
/*     */ 
/*     */     
/*  56 */     public String getScheme() { return this.scheme; }
/*     */ 
/*     */ 
/*     */     
/*  60 */     public String getPath() { return this.path; }
/*     */ 
/*     */ 
/*     */     
/*  64 */     public String getHost() { return this.host; }
/*     */ 
/*     */     
/*     */     public URI toURI() throws URISyntaxException {
/*  68 */       StringBuffer sb = new StringBuffer();
/*  69 */       if (this.scheme != null) {
/*  70 */         sb.append(this.scheme);
/*  71 */         sb.append(':');
/*     */       } 
/*     */       
/*  74 */       if (this.host != null && this.host.length() != 0) {
/*  75 */         sb.append(this.host);
/*     */       } else {
/*     */         
/*  78 */         sb.append('(');
/*  79 */         for (int i = 0; i < this.components.length; i++) {
/*  80 */           if (i != 0) {
/*  81 */             sb.append(',');
/*     */           }
/*  83 */           sb.append(this.components[i].toString());
/*     */         } 
/*  85 */         sb.append(')');
/*     */       } 
/*     */       
/*  88 */       if (this.path != null) {
/*  89 */         sb.append('/');
/*  90 */         sb.append(this.path);
/*     */       } 
/*  92 */       if (!this.parameters.isEmpty()) {
/*  93 */         sb.append(""?"");
/*  94 */         sb.append(URISupport.createQueryString(this.parameters));
/*     */       } 
/*  96 */       if (this.fragment != null) {
/*  97 */         sb.append(""#"");
/*  98 */         sb.append(this.fragment);
/*     */       } 
/* 100 */       return new URI(sb.toString());
/*     */     }
/*     */   }
/*     */   
/*     */   public static Map parseQuery(String uri) throws URISyntaxException {
/*     */     try {
/* 106 */       Map<Object, Object> rc = new HashMap<Object, Object>();
/* 107 */       if (uri != null) {
/* 108 */         String[] parameters = uri.split(""&"");
/* 109 */         for (int i = 0; i < parameters.length; i++) {
/* 110 */           int p = parameters[i].indexOf(""="");
/* 111 */           if (p >= 0) {
/* 112 */             String name = URLDecoder.decode(parameters[i].substring(0, p), ""UTF-8"");
/* 113 */             String value = URLDecoder.decode(parameters[i].substring(p + 1), ""UTF-8"");
/* 114 */             rc.put(name, value);
/*     */           } else {
/*     */             
/* 117 */             rc.put(parameters[i], null);
/*     */           } 
/*     */         } 
/*     */       } 
/* 121 */       return rc;
/*     */     }
/* 123 */     catch (UnsupportedEncodingException e) {
/* 124 */       throw (URISyntaxException)(new URISyntaxException(e.toString(), ""Invalid encoding"")).initCause(e);
/*     */     } 
/*     */   }
/*     */   
/*     */   public static Map parseParamters(URI uri) throws URISyntaxException {
/* 129 */     String query = uri.getQuery();
/* 130 */     if (query == null) {
/* 131 */       String schemeSpecificPart = uri.getSchemeSpecificPart();
/* 132 */       int idx = schemeSpecificPart.lastIndexOf('?');
/* 133 */       if (idx < 0) {
/* 134 */         return Collections.EMPTY_MAP;
/*     */       }
/*     */       
/* 137 */       query = schemeSpecificPart.substring(idx + 1);
/*     */     }
/*     */     else {
/*     */       
/* 141 */       query = stripPrefix(query, ""?"");
/*     */     } 
/* 143 */     return parseQuery(query);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 150 */   public static URI removeQuery(URI uri) throws URISyntaxException { return createURIWithQuery(uri, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 157 */   public static URI createURIWithQuery(URI uri, String query) throws URISyntaxException { return new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(), query, uri.getFragment()); }
/*     */ 
/*     */ 
/*     */   
/*     */   public static CompositeData parseComposite(URI uri) throws URISyntaxException {
/* 162 */     CompositeData rc = new CompositeData();
/* 163 */     rc.scheme = uri.getScheme();
/* 164 */     String ssp = stripPrefix(uri.getSchemeSpecificPart().trim(), ""//"").trim();
/*     */     
/* 166 */     parseComposite(uri, rc, ssp);
/*     */     
/* 168 */     rc.fragment = uri.getFragment();
/* 169 */     return rc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static void parseComposite(URI uri, CompositeData rc, String ssp) throws URISyntaxException {
/*     */     String params, componentString;
/* 182 */     if (!checkParenthesis(ssp)) {
/* 183 */       throw new URISyntaxException(uri.toString(), ""Not a matching number of '(' and ')' parenthesis"");
/*     */     }
/*     */ 
/*     */     
/* 187 */     int intialParen = ssp.indexOf(""("");
/* 188 */     if (intialParen == 0) {
/* 189 */       rc.host = ssp.substring(0, intialParen);
/* 190 */       int p = rc.host.indexOf(""/"");
/* 191 */       if (p >= 0) {
/* 192 */         rc.path = rc.host.substring(p);
/* 193 */         rc.host = rc.host.substring(0, p);
/*     */       } 
/* 195 */       p = ssp.lastIndexOf("")"");
/* 196 */       componentString = ssp.substring(intialParen + 1, p);
/* 197 */       params = ssp.substring(p + 1).trim();
/*     */     } else {
/*     */       
/* 200 */       componentString = ssp;
/* 201 */       params = """";
/*     */     } 
/*     */     
/* 204 */     String[] components = splitComponents(componentString);
/* 205 */     rc.components = new URI[components.length];
/* 206 */     for (int i = 0; i < components.length; i++) {
/* 207 */       rc.components[i] = new URI(components[i].trim());
/*     */     }
/*     */     
/* 210 */     int p = params.indexOf(""?"");
/* 211 */     if (p >= 0) {
/* 212 */       if (p > 0) {
/* 213 */         rc.path = stripPrefix(params.substring(0, p), ""/"");
/*     */       }
/* 215 */       rc.parameters = parseQuery(params.substring(p + 1));
/*     */     } else {
/*     */       
/* 218 */       if (params.length() > 0) {
/* 219 */         rc.path = stripPrefix(params, ""/"");
/*     */       }
/* 221 */       rc.parameters = Collections.EMPTY_MAP;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static String[] splitComponents(String str) {
/* 230 */     ArrayList<String> l = new ArrayList();
/*     */     
/* 232 */     int last = 0;
/* 233 */     int depth = 0;
/* 234 */     char[] chars = str.toCharArray();
/* 235 */     for (int i = 0; i < chars.length; i++) {
/* 236 */       switch (chars[i]) {
/*     */         case '(':
/* 238 */           depth++;
/*     */           break;
/*     */         case ')':
/* 241 */           depth--;
/*     */           break;
/*     */         case ',':
/* 244 */           if (depth == 0) {
/* 245 */             String s = str.substring(last, i);
/* 246 */             l.add(s);
/* 247 */             last = i + 1;
/*     */           } 
/*     */           break;
/*     */       } 
/*     */     } 
/* 252 */     String s = str.substring(last);
/* 253 */     if (s.length() != 0) {
/* 254 */       l.add(s);
/*     */     }
/*     */     
/* 257 */     String[] rc = new String[l.size()];
/* 258 */     l.toArray(rc);
/* 259 */     return rc;
/*     */   }
/*     */   
/*     */   public static String stripPrefix(String value, String prefix) {
/* 263 */     if (value.startsWith(prefix)) {
/* 264 */       return value.substring(prefix.length());
/*     */     }
/* 266 */     return value;
/*     */   }
/*     */ 
/*     */   
/* 270 */   public static URI stripScheme(URI uri) throws URISyntaxException { return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), ""//"")); }
/*     */ 
/*     */   
/*     */   public static String createQueryString(Map options) throws URISyntaxException {
/*     */     try {
/* 275 */       if (options.size() > 0) {
/* 276 */         StringBuffer rc = new StringBuffer();
/* 277 */         boolean first = true;
/* 278 */         for (Iterator<String> iter = options.keySet().iterator(); iter.hasNext(); ) {
/* 279 */           if (first) {
/* 280 */             first = false;
/*     */           } else {
/*     */             
/* 283 */             rc.append(""&"");
/*     */           } 
/*     */           
/* 286 */           String key = iter.next();
/* 287 */           String value = (String)options.get(key);
/* 288 */           rc.append(URLEncoder.encode(key, ""UTF-8""));
/* 289 */           rc.append(""="");
/* 290 */           rc.append(URLEncoder.encode(value, ""UTF-8""));
/*     */         } 
/* 292 */         return rc.toString();
/*     */       } 
/*     */       
/* 295 */       return """";
/*     */     
/*     */     }
/* 298 */     catch (UnsupportedEncodingException e) {
/* 299 */       throw (URISyntaxException)(new URISyntaxException(e.toString(), ""Invalid encoding"")).initCause(e);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static URI createRemainingURI(URI originalURI, Map params) throws URISyntaxException {
/* 309 */     String s = createQueryString(params);
/* 310 */     if (s.length() == 0) {
/* 311 */       s = null;
/*     */     }
/* 313 */     return createURIWithQuery(originalURI, s);
/*     */   }
/*     */ 
/*     */   
/* 317 */   public static URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException { return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr.getPath(), bindAddr.getQuery(), bindAddr.getFragment()); }
/*     */ 
/*     */   
/*     */   public static boolean checkParenthesis(String str) {
/* 321 */     boolean result = true;
/* 322 */     if (str != null) {
/* 323 */       int open = 0;
/* 324 */       int closed = 0;
/*     */       
/* 326 */       int i = 0;
/* 327 */       while ((i = str.indexOf('(', i)) >= 0) {
/* 328 */         i++;
/* 329 */         open++;
/*     */       } 
/* 331 */       i = 0;
/* 332 */       while ((i = str.indexOf(')', i)) >= 0) {
/* 333 */         i++;
/* 334 */         closed++;
/*     */       } 
/* 336 */       result = (open == closed);
/*     */     } 
/* 338 */     return result;
/*     */   }
/*     */   
/*     */   public int indexOfParenthesisMatch(String str) {
/* 342 */     int result = -1;
/*     */     
/* 344 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\URISupport.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.util.UuidGenerator,"/*     */ package org.apache.camel.util;
/*     */ 
/*     */ import java.net.InetAddress;
/*     */ import java.net.ServerSocket;
/*     */ import java.util.logging.Level;
/*     */ import java.util.logging.Logger;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class UuidGenerator
/*     */ {
/*  30 */   private static final Logger log = Logger.getLogger(UuidGenerator.class.getName());
/*     */   private static final String UNIQUE_STUB;
/*     */   private static int instanceCount;
/*     */   private static String hostName;
/*     */   private String seed;
/*     */   private long sequence;
/*     */   
/*     */   static  {
/*  38 */     String stub = """";
/*  39 */     boolean canAccessSystemProps = true;
/*     */     try {
/*  41 */       SecurityManager sm = System.getSecurityManager();
/*  42 */       if (sm != null) {
/*  43 */         sm.checkPropertiesAccess();
/*     */       }
/*  45 */     } catch (SecurityException se) {
/*  46 */       canAccessSystemProps = false;
/*     */     } 
/*     */     
/*  49 */     if (canAccessSystemProps) {
/*     */       try {
/*  51 */         hostName = InetAddress.getLocalHost().getHostName();
/*  52 */         ServerSocket ss = new ServerSocket(0);
/*  53 */         stub = ""/"" + ss.getLocalPort() + ""-"" + System.currentTimeMillis() + ""/"";
/*  54 */         Thread.sleep(100L);
/*  55 */         ss.close();
/*  56 */       } catch (Exception ioe) {
/*  57 */         log.log(Level.WARNING, ""could not generate unique stub"", ioe);
/*     */       } 
/*     */     } else {
/*  60 */       hostName = ""localhost"";
/*  61 */       stub = ""-1-"" + System.currentTimeMillis() + ""-"";
/*     */     } 
/*  63 */     UNIQUE_STUB = stub;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  73 */   public static String getHostName() { return hostName; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public UuidGenerator(String prefix) {
/*  82 */     synchronized (UNIQUE_STUB) {
/*  83 */       this.seed = prefix + UNIQUE_STUB + instanceCount++ + ""-"";
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*  88 */   public UuidGenerator() { this(""ID-"" + hostName); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public synchronized String generateId() { return this.seed + this.sequence++; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String generateSanitizedId() {
/* 105 */     String result = generateId();
/* 106 */     result = result.replace(':', '-');
/* 107 */     result = result.replace('_', '-');
/* 108 */     result = result.replace('.', '-');
/* 109 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\came\\util\UuidGenerator.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.view.RouteDotGenerator,"/*    */ package org.apache.camel.view;
/*    */ 
/*    */ import java.io.FileWriter;
/*    */ import java.io.IOException;
/*    */ import java.io.PrintWriter;
/*    */ import java.util.List;
/*    */ import org.apache.camel.CamelContext;
/*    */ import org.apache.camel.Endpoint;
/*    */ import org.apache.camel.Processor;
/*    */ import org.apache.camel.Route;
/*    */ import org.apache.camel.impl.EventDrivenConsumerRoute;
/*    */ import org.apache.commons.logging.Log;
/*    */ import org.apache.commons.logging.LogFactory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RouteDotGenerator
/*    */ {
/* 40 */   private static final transient Log log = LogFactory.getLog(RouteDotGenerator.class);
/* 41 */   private String file = ""CamelRoutes.dot"";
/*    */ 
/*    */   
/* 44 */   public String getFile() { return this.file; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 51 */   public void setFile(String file) { this.file = file; }
/*    */ 
/*    */   
/*    */   public void drawRoutes(CamelContext context) throws IOException {
/* 55 */     PrintWriter writer = new PrintWriter(new FileWriter(this.file));
/* 56 */     generateFile(writer, context);
/*    */   }
/*    */   
/*    */   protected void generateFile(PrintWriter writer, CamelContext context) {
/* 60 */     writer.println(""digraph \""Camel Routes\"" {"");
/* 61 */     writer.println();
/* 62 */     writer.println(""label=\""Camel Container: "" + context + ""\""];"");
/* 63 */     writer.println();
/* 64 */     writer.println(""node [style = \""rounded,filled\"", fillcolor = yellow, fontname=\""Helvetica-Oblique\""];"");
/* 65 */     writer.println();
/* 66 */     printRoutes(writer, context.getRoutes());
/*    */   }
/*    */   
/*    */   protected void printRoutes(PrintWriter writer, List<Route> routes) {
/* 70 */     for (Route r : routes) {
/* 71 */       Endpoint end = r.getEndpoint();
/* 72 */       writer.print(end.getEndpointUri());
/* 73 */       writer.print("" -> "");
/* 74 */       writer.print(r);
/* 75 */       writer.print("" -> "");
/* 76 */       if (r instanceof EventDrivenConsumerRoute) {
/* 77 */         EventDrivenConsumerRoute consumerRoute = (EventDrivenConsumerRoute)r;
/* 78 */         Processor p = consumerRoute.getProcessor();
/* 79 */         writer.println(p);
/*    */       } 
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\camel-core-1.0.0.jar!\org\apache\camel\view\RouteDotGenerator.class
 * Java compiler version: 5 (49.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.camel.component.quartz.QuartzExchange,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultExchange;
import org.quartz.JobExecutionContext;
/**
 * @version $Revision: 1.1 $
 */
public class QuartzExchange extends DefaultExchange {
    public QuartzExchange(CamelContext context, JobExecutionContext jobExecutionContext) {
        super(context);
        setIn(new QuartzMessage(this, jobExecutionContext));
    }
    @Override
    public QuartzMessage getIn() {
        return (QuartzMessage) super.getIn();
    }
    public JobExecutionContext getJobExecutionContext() {
        return getIn().getJobExecutionContext();
    }
}
"
org.apache.camel.component.mina.MinaComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoConnector;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;
import org.apache.mina.transport.socket.nio.DatagramAcceptor;
import org.apache.mina.transport.socket.nio.DatagramConnector;
import org.apache.mina.transport.socket.nio.DatagramConnectorConfig;
import org.apache.mina.transport.socket.nio.SocketAcceptor;
import org.apache.mina.transport.socket.nio.SocketConnector;
import org.apache.mina.transport.socket.nio.SocketConnectorConfig;
import org.apache.mina.transport.vmpipe.VmPipeAcceptor;
import org.apache.mina.transport.vmpipe.VmPipeAddress;
import org.apache.mina.transport.vmpipe.VmPipeConnector;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;
/**
 * @version $Revision$
 */
public class MinaComponent extends DefaultComponent<MinaExchange> {
    public MinaComponent() {
    }
    public MinaComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<MinaExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        URI u = new URI(remaining);
        String protocol = u.getScheme();
        if (protocol.equals(""tcp"")) {
            return createSocketEndpoint(uri, u);
        }
        else if (protocol.equals(""udp"") || protocol.equals(""mcast"") || protocol.equals(""multicast"")) {
            return createDatagramEndpoint(uri, u);
        }
        else if (protocol.equals(""vm"")) {
            return createVmEndpoint(uri, u);
        }
        else {
            throw new IOException(""Unrecognised MINA protocol: "" + protocol + "" for uri: "" + uri);
        }
    }
    protected MinaEndpoint createVmEndpoint(String uri, URI connectUri) {
        IoAcceptor acceptor = new VmPipeAcceptor();
        SocketAddress address = new VmPipeAddress(connectUri.getPort());
        IoConnector connector = new VmPipeConnector();
        return new MinaEndpoint(uri, this, address, acceptor, connector, null);
    }
    protected MinaEndpoint createSocketEndpoint(String uri, URI connectUri) {
        IoAcceptor acceptor = new SocketAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new SocketConnector();
        // TODO customize the config via URI
        SocketConnectorConfig config = new SocketConnectorConfig();
        config.getFilterChain().addLast(""codec"", new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));
        return new MinaEndpoint(uri, this, address, acceptor, connector, config);
    }
    protected MinaEndpoint createDatagramEndpoint(String uri, URI connectUri) {
        IoAcceptor acceptor = new DatagramAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new DatagramConnector();
        // TODO customize the config via URI
        DatagramConnectorConfig config = new DatagramConnectorConfig();
        config.getFilterChain().addLast(""codec"", new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));
        return new MinaEndpoint(uri, this, address, acceptor, connector, config);
    }
}
"
org.apache.camel.component.xmpp.XmppComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import com.sun.jndi.toolkit.url.Uri;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.URISupport;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;
/**
 * @version $Revision:520964 $
 */
public class XmppComponent extends DefaultComponent<XmppExchange> {
    /**
     * Static builder method
     */
    public static XmppComponent xmppComponent() {
        return new XmppComponent();
    }
    public XmppComponent() {
    }
    public XmppComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<XmppExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        XmppEndpoint endpoint = new XmppEndpoint(uri, this);
        URI u = new URI(uri);
        endpoint.setHost(u.getHost());
        endpoint.setPort(u.getPort());
        if (u.getUserInfo() != null) {
            endpoint.setUser(u.getUserInfo());
        }
        String remainingPath = u.getPath();
        if (remainingPath != null) {
            if (remainingPath.startsWith(""/"")) {
                remainingPath = remainingPath.substring(1);
            }
            // assume its a participant
            if (remainingPath.length() > 0) {
                endpoint.setParticipant(remainingPath);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.spring.xml.CamelBeanDefinitionParser,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;
import java.util.Map;
import org.apache.camel.Expression;
import org.apache.camel.builder.Fluent;
import org.apache.camel.builder.FluentArg;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.ValueBuilder;
import org.springframework.beans.SimpleTypeConverter;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.ChildBeanDefinition;
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
public class CamelBeanDefinitionParser extends AbstractBeanDefinitionParser {
    private final CamelNamespaceHandler namespaceHandler;
    private int counter;
    public CamelBeanDefinitionParser(CamelNamespaceHandler namespaceHandler) {
        this.namespaceHandler = namespaceHandler;
    }
    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
		BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(RouteBuilderFactoryBean.class);
		List childElements = DomUtils.getChildElementsByTagName(element, ""route"");
		ArrayList<BuilderStatement> routes = new ArrayList<BuilderStatement>(childElements.size());
		if (childElements != null && childElements.size() > 0) {
			for (int i = 0; i < childElements.size(); ++i) {
				Element routeElement = (Element) childElements.get(i);
				ArrayList<BuilderAction> actions = new ArrayList<BuilderAction>();
				Class type = parseBuilderElement(parserContext, routeElement, RouteBuilder.class, actions);
				BuilderStatement statement = new BuilderStatement();
				statement.setReturnType(type);
				statement.setActions(actions);
				routes.add(statement);
			}
		}
		factory.addPropertyValue(""routes"", routes);
		return factory.getBeanDefinition();
	}
	/**
	 * Use reflection to figure out what is the valid next element.
	 */
	private Class parseBuilderElement(ParserContext parserContext, Element element, Class<RouteBuilder> builder, ArrayList<BuilderAction> actions) {
		Class currentBuilder = builder;
		NodeList childElements = element.getChildNodes();
		Element previousElement = null;
		for (int i = 0; i < childElements.getLength(); ++i) {
			Node node = childElements.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				currentBuilder = parseAction(parserContext, currentBuilder, actions, (Element) node, previousElement);
				previousElement = (Element) node;
				BuilderAction action = actions.get(actions.size()-1);
				if( action.getMethodInfo().methodAnnotation.nestedActions() ) {
					currentBuilder = parseBuilderElement(parserContext, (Element) node, currentBuilder, actions);
				} else {
					// Make sure the there are no child elements.
					if( hasChildElements(node) ) {
						throw new IllegalArgumentException(""The element ""+node.getLocalName()+"" should not have any child elements."");
					}
				}
			}
		}
		// Add the builder actions that are annotated with @Fluent(callOnElementEnd=true) 
		if( currentBuilder!=null ) {
			Method[] methods = currentBuilder.getMethods();
			for (int i = 0; i < methods.length; i++) {
				Method method = methods[i];
				Fluent annotation = method.getAnnotation(Fluent.class);
				if( annotation!=null && annotation.callOnElementEnd() ) {
					if( method.getParameterTypes().length > 0 ) {
						throw new RuntimeException(""Only methods with no parameters can annotated with @Fluent(callOnElementEnd=true): ""+method); 
					}
					MethodInfo methodInfo = new MethodInfo(method, annotation, new LinkedHashMap<String, Class>(), new LinkedHashMap<String, FluentArg>());
					actions.add(new BuilderAction(methodInfo, new HashMap<String, Object>()));
					currentBuilder = method.getReturnType();
				}
			}
		}
		return currentBuilder;
	}
	private boolean hasChildElements(Node node) {
		NodeList nl = node.getChildNodes();
		for (int j = 0; j < nl.getLength(); ++j) {
			if( nl.item(j).getNodeType() == Node.ELEMENT_NODE ) {
				return true;
			}
		}
		return false;
	}
	private Class parseAction(ParserContext parserContext, Class currentBuilder, ArrayList<BuilderAction> actions, Element element, Element previousElement) {
		String actionName = element.getLocalName();
		// Get a list of method names that match the action.
		ArrayList<MethodInfo> methods = findFluentMethodsWithName(currentBuilder, element.getLocalName());
		if (methods.isEmpty()) {
			throw new IllegalActionException(actionName, previousElement == null ? null : previousElement.getLocalName());
		}
		// Pick the best method out of the list. Sort by argument length. Pick
		// first longest match.
		Collections.sort(methods, new Comparator<MethodInfo>() {
			public int compare(MethodInfo m1, MethodInfo m2) {
				return m1.method.getParameterTypes().length - m2.method.getParameterTypes().length;
			}
		});
		// Build the possible list of arguments from the attributes and child
		// elements
		HashMap<String, Object> attributeArguments = getArugmentsFromAttributes(element);
		HashMap<String, ArrayList<Element>> elementArguments = getArgumentsFromElements(element);
		// Find the first method that we can supply arguments for.
		MethodInfo match = null;
		match = findMethodMatch(methods, attributeArguments.keySet(), elementArguments.keySet());
		if (match == null)
			throw new IllegalActionException(actionName, previousElement == null ? null : previousElement.getLocalName());
        // lets convert any references
        Set<Map.Entry<String, Object>> attributeEntries = attributeArguments.entrySet();
        for (Map.Entry<String, Object> entry : attributeEntries) {
            String name = entry.getKey();
            FluentArg arg = match.parameterAnnotations.get(name);
            if (arg != null && (arg.reference() || name.equals(""ref""))) {
                Object value = entry.getValue();
                if (value instanceof String) {
                    entry.setValue(new RuntimeBeanReference(value.toString()));
                }
            }
        }
        // Move element arguments into the attributeArguments map if needed.
		Set<String> parameterNames = new HashSet<String>(match.parameters.keySet());
		parameterNames.removeAll(attributeArguments.keySet());
		for (String key : parameterNames) {
			ArrayList<Element> elements = elementArguments.get(key);
            if (elements == null) {
                elements = getFirstChildElements(element);
            }
            Class clazz = match.parameters.get(key);
			Object value = convertTo(parserContext, elements, clazz);
			attributeArguments.put(key, value);
			for (Element el : elements) {
				// remove the argument nodes so that they don't get interpreted as
				// actions.
				el.getParentNode().removeChild(el);
			}
		}
		actions.add(new BuilderAction(match, attributeArguments));
		return match.method.getReturnType();
	}
    private ArrayList<Element> getFirstChildElements(Element element) {
        ArrayList<Element> answer = new ArrayList<Element>();
        NodeList list = element.getChildNodes();
        for (int i = 0, size = list.getLength(); i < size; i++) {
            Node node = list.item(i);
            if (node instanceof Element) {
                answer.add((Element) node);
                break;
            }
        }
        return answer;
    }
    private Object convertTo(ParserContext parserContext, ArrayList<Element> elements, Class clazz) {
		if( clazz.isArray() || elements.size() > 1 ) {
            List list = new ArrayList();
			for( int i=0; i < elements.size(); i ++ ) {
				ArrayList<Element> e = new ArrayList<Element>(1);
				e.add(elements.get(i));
				Object value = convertTo(parserContext, e, clazz.getComponentType());
                list.add(value);
			}
			return list;
            /*
            Object array = Array.newInstance(clazz.getComponentType(), elements.size());
			for( int i=0; i < elements.size(); i ++ ) {
				ArrayList<Element> e = new ArrayList<Element>(1);
				e.add(elements.get(i));
				Object value = convertTo(parserContext, e, clazz.getComponentType());
                Array.set(array, i, value);
			}
			return array;
			*/
		} else {
			Element element = elements.get(0);
			String ref = element.getAttribute(""ref"");
			if( StringUtils.hasText(ref) ) {
				return new RuntimeBeanReference(ref);
			}
			// Use a builder to create the value..
			if( hasChildElements(element) ) {
				ArrayList<BuilderAction> actions = new ArrayList<BuilderAction>();
				Class type = parseBuilderElement(parserContext, element, RouteBuilder.class, actions);
				if ( type == ValueBuilder.class && clazz==Expression.class ) {					
					Method method;
					try {
						method = ValueBuilder.class.getMethod(""getExpression"", new Class[]{});
					} catch (Throwable e) {
						throw new RuntimeException(ValueBuilder.class.getName()+"" does not have the getExpression() method."");
					}
					MethodInfo methodInfo = new MethodInfo(method, null, new LinkedHashMap<String, Class>(), new LinkedHashMap<String, FluentArg>());
					actions.add(new BuilderAction(methodInfo, new HashMap<String, Object>()));
					type = Expression.class;
				} 
				BuilderStatement statement = new BuilderStatement();
				statement.setReturnType(type);
				statement.setActions(actions);
				if( !clazz.isAssignableFrom( statement.getReturnType() ) ) {					
					throw new IllegalStateException(""Builder does not produce object of expected type: ""+clazz.getName()+"", it produced: ""+statement.getReturnType());
				}
				return statement;
			} else {
                // if we are on an element which has a custom parser, lets use that.
                String name = element.getLocalName();
                if (namespaceHandler.getParserElementNames().contains(name)) {
                    String id = createBeanId(name);
                    element.setAttribute(""id"", id);
                    namespaceHandler.parse(element, parserContext);
                    return new RuntimeBeanReference(id);
                }
                // Just use the text in the element as the value.
				SimpleTypeConverter converter = new SimpleTypeConverter();
				return converter.convertIfNecessary(element.getTextContent(), clazz);
			}
		}
	}
    protected synchronized String createBeanId(String name) {
        return ""_internal:camel:bean:"" + name + (++counter);
    }
    private MethodInfo findMethodMatch(ArrayList<MethodInfo> methods, Set<String> attributeNames, Set<String> elementNames) {
		for (MethodInfo method : methods) {
			// make sure all the given attribute parameters can be assigned via
			// attributes
			boolean miss = false;
			for (String key : attributeNames) {
				FluentArg arg = method.parameterAnnotations.get(key);
				if (arg == null || !arg.attribute()) {
					miss = true;
					break;
				}
			}
			if (miss)
				continue; // Keep looking...
			Set<String> parameterNames = new HashSet<String>(method.parameters.keySet());
			parameterNames.removeAll(attributeNames);
			// Bingo we found a match.
			if (parameterNames.isEmpty()) {
				return method;
			}
			// We may still be able to match using elements as parameters.
            /*
            for (String key : elementNames) {
				if (parameterNames.isEmpty()) {
					break;
				}
				// We only want to use the first child elements as arguments,
				// once we don't match, we can stop looking.
				FluentArg arg = method.parameterAnnotations.get(key);
				if (arg == null || !arg.element()) {
					break;
				}
				if (!parameterNames.remove(key)) {
					break;
				}
			}
			// All parameters found! We have a match!
			if (parameterNames.isEmpty()) {
				return method;
			}
			*/
            return method;
        }
		return null;
	}
	private LinkedHashMap<String, ArrayList<Element>> getArgumentsFromElements(Element element) {
		LinkedHashMap<String, ArrayList<Element>> elements = new LinkedHashMap<String, ArrayList<Element>>();
		NodeList childNodes = element.getChildNodes();
		String lastTag = null;
		for (int i = 0; i < childNodes.getLength(); i++) {
			Node node = childNodes.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				Element el = (Element) node;
				String tag = el.getLocalName();
				ArrayList<Element> els = elements.get(tag);
				if (els == null) {
					els = new ArrayList<Element>();
					elements.put(el.getLocalName(), els);
					els.add(el);
					lastTag = tag;
				} else {
					// add to array if the elements are consecutive
					if (tag.equals(lastTag)) {
						els.add(el);
						lastTag = tag;
					}
				}
			}
		}
		return elements;
	}
	private HashMap<String, Object> getArugmentsFromAttributes(Element element) {
		HashMap<String, Object> attributes = new HashMap<String, Object>();
		NamedNodeMap childNodes = element.getAttributes();
		for (int i = 0; i < childNodes.getLength(); i++) {
			Node node = childNodes.item(i);
			if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
				Attr attr = (Attr) node;
				String str = attr.getValue();
				Object value = str;
				// If the value starts with # then it's a bean reference
				if (str.startsWith(""#"")) {
					str = str.substring(1);
					// Support using ## to escape the bean reference feature.
					if (!str.startsWith(""#"")) {
						value = new RuntimeBeanReference(str);
					}
				}
				attributes.put(attr.getName(), value);
			}
		}
		return attributes;
	}
	/**
	 * Finds all the methods on the clazz that match the name and which have the
	 * {@see Fluent} annotation and whoes parameters have the {@see FluentArg}
	 * annotation.
	 * 
	 * @param clazz
	 * @param name
	 * @return
	 */
	private ArrayList<MethodInfo> findFluentMethodsWithName(Class clazz, String name) {
		ArrayList<MethodInfo> rc = new ArrayList<MethodInfo>();
		Method[] methods = clazz.getMethods();
		for (int i = 0; i < methods.length; i++) {
			Method method = methods[i];
			if (!method.isAnnotationPresent(Fluent.class)) {
				continue;
			}
			// Use the fluent supplied name for the action, or the method name if not set.
			Fluent fluentAnnotation = method.getAnnotation(Fluent.class);
			if ( StringUtils.hasText(fluentAnnotation.value()) ? 
					name.equals(fluentAnnotation.value()) :
					name.equals(method.getName()) ) {
				LinkedHashMap<String, Class> map = new LinkedHashMap<String, Class>();
				LinkedHashMap<String, FluentArg> amap = new LinkedHashMap<String, FluentArg>();
				Class<?>[] parameters = method.getParameterTypes();
				for (int j = 0; j < parameters.length; j++) {
					Class<?> parameter = parameters[j];
					FluentArg annotation = getParameterAnnotation(FluentArg.class, method, j);
					if (annotation != null) {
						map.put(annotation.value(), parameter);
						amap.put(annotation.value(), annotation);
					} else {
						break;
					}
				}
				// If all the parameters were annotated...
				if (parameters.length == map.size()) {
					rc.add(new MethodInfo(method, fluentAnnotation, map, amap));
				}
			}
		}
		return rc;
	}
	private <T> T getParameterAnnotation(Class<T> annotationClass, Method method, int index) {
		Annotation[] annotations = method.getParameterAnnotations()[index];
		for (int i = 0; i < annotations.length; i++) {
			if (annotationClass.isAssignableFrom(annotations[i].getClass())) {
				return (T) annotations[i];
			}
		}
		return null;
	}
}
"
org.apache.camel.component.cxf.CxfComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.cxf.Bus;
import org.apache.cxf.BusException;
import org.apache.cxf.bus.CXFBusFactory;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.DestinationFactoryManager;
import org.apache.cxf.transport.local.LocalTransportFactory;
import org.xmlsoap.schemas.wsdl.http.AddressType;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Component</a>
 * @version $Revision$
 */
public class CxfComponent extends DefaultComponent<CxfExchange> {
    private LocalTransportFactory localTransportFactory;
    public CxfComponent() {
    }
    public CxfComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<CxfExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        URI u = new URI(remaining);
        // TODO this is a hack!!!
        EndpointInfo endpointInfo = new EndpointInfo(null, ""http://schemas.xmlsoap.org/soap/http"");
        AddressType a = new AddressType();
        a.setLocation(remaining);
        endpointInfo.addExtensor(a);
        return new CxfEndpoint(uri, this, endpointInfo);
    }
    public LocalTransportFactory getLocalTransportFactory() throws BusException {
        if (localTransportFactory == null) {
            localTransportFactory = findLocalTransportFactory();
            if (localTransportFactory == null) {
                localTransportFactory = new LocalTransportFactory();
            }
        }
        return localTransportFactory;
    }
    public void setLocalTransportFactory(LocalTransportFactory localTransportFactory) {
        this.localTransportFactory = localTransportFactory;
    }
    protected LocalTransportFactory findLocalTransportFactory() throws BusException {
        Bus bus = CXFBusFactory.getDefaultBus();
        DestinationFactoryManager dfm = bus.getExtension(DestinationFactoryManager.class);
        return (LocalTransportFactory) dfm.getDestinationFactory(LocalTransportFactory.TRANSPORT_ID);
    }
}
"
org.apache.camel.component.mail.MessageHeaderAccessException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.MessagingException;
/**
 * @version $Revision:520964 $
 */
public class MessageHeaderAccessException extends RuntimeMailException {
    private static final long serialVersionUID = -3996286386119163309L;
    private String propertyName;
    public MessageHeaderAccessException(String propertyName, MessagingException e) {
        super(""Error accessing header: "" + propertyName, e);
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.component.jbi.JbiException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.RuntimeCamelException;
/**
 * @version $Revision$
 */
public class JbiException extends RuntimeCamelException {
    public JbiException(Throwable cause) {
        super(cause);
    }
    public JbiException(String message) {
        super(message);
    }
    public JbiException(String message, Throwable cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.jms.JmsEndpoint,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import org.apache.camel.Processor;
import org.apache.camel.PollingConsumer;
import org.apache.camel.impl.DefaultEndpoint;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 *
  * @version $Revision:520964 $
 */
public class JmsEndpoint extends DefaultEndpoint<JmsExchange> {
    private JmsBinding binding;
    private String destination;
    private final boolean pubSubDomain;
    private String selector;
    private JmsConfiguration configuration;
    public JmsEndpoint(String uri, JmsComponent component, String destination, boolean pubSubDomain, JmsConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
        this.destination = destination;
        this.pubSubDomain = pubSubDomain;
    }
    public JmsProducer createProducer() throws Exception {
        JmsOperations template = createJmsOperations();
        return createProducer(template);
    }
    /**
     * Creates a producer using the given template
     */
    public JmsProducer createProducer(JmsOperations template) throws Exception {
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate) template;
            jmsTemplate.setPubSubDomain(pubSubDomain);
            jmsTemplate.setDefaultDestinationName(destination);
        }
        return new JmsProducer(this, template);
    }
    public JmsConsumer createConsumer(Processor processor) throws Exception {
        AbstractMessageListenerContainer listenerContainer = configuration.createMessageListenerContainer();
        return createConsumer(processor, listenerContainer);
    }
    /**
     * Creates a consumer using the given processor and listener container
     *
     * @param processor the processor to use to process the messages
     * @param listenerContainer the listener container
     * @return a newly created consumer
     * @throws Exception if the consumer cannot be created
     */
    public JmsConsumer createConsumer(Processor processor, AbstractMessageListenerContainer listenerContainer) throws Exception {
        listenerContainer.setDestinationName(destination);
        listenerContainer.setPubSubDomain(pubSubDomain);
        if (selector != null) {
            listenerContainer.setMessageSelector(selector);
        }
        return new JmsConsumer(this, processor, listenerContainer);
    }
    @Override
    public PollingConsumer<JmsExchange> createPollingConsumer() throws Exception {
        JmsOperations template = createJmsOperations();
        return new JmsPollingConsumer(this, template);
    }
    public JmsExchange createExchange() {
        return new JmsExchange(getContext(), getBinding());
    }
    public JmsExchange createExchange(Message message) {
        return new JmsExchange(getContext(), getBinding(), message);
    }
    // Properties
    //-------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS message
     *
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public String getDestination() {
        return destination;
    }
    public JmsConfiguration getConfiguration() {
        return configuration;
    }
    public String getSelector() {
        return selector;
    }
    /**
     * Sets the JMS selector to use
     */
    public void setSelector(String selector) {
        this.selector = selector;
    }
	public boolean isSingleton() {
		return false;
	}
    protected JmsOperations createJmsOperations() {
        return configuration.createJmsOperations(pubSubDomain, destination);
    }
}
"
org.apache.camel.bam.model.ProcessDefinition,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
@Entity
public class ProcessDefinition extends EntitySupport {
    private static final transient Log log = LogFactory.getLog(ProcessDefinition.class);
    private String name;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public static ProcessDefinition getRefreshedProcessDefinition(JpaTemplate template, ProcessDefinition definition) {
        // TODO refresh doesn't tend to work - maybe its a spring thing?
        //template.refresh(definition);
        ObjectHelper.notNull(definition, ""definition"");
        Long id = definition.getId();
        if (id == null) {
            log.warn(""No primary key is available!"");
            return findOrCreateProcessDefinition(template, definition.getName());
        }
        definition = template.find(ProcessDefinition.class, id);
        return definition;
    }
    public static ProcessDefinition findOrCreateProcessDefinition(JpaTemplate template, String processName) {
        List<ProcessDefinition> list = template.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        }
        else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            template.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.component.jms.JmsPollingConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.impl.PollingConsumerSupport;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
import javax.jms.Message;
/**
 * @version $Revision: 1.1 $
 */
public class JmsPollingConsumer extends PollingConsumerSupport<JmsExchange> {
    private JmsOperations template;
    public JmsPollingConsumer(JmsEndpoint endpoint, JmsOperations template) {
        super(endpoint);
        this.template = template;
    }
    @Override
    public JmsEndpoint getEndpoint() {
        return (JmsEndpoint) super.getEndpoint();
    }
    public JmsExchange receiveNoWait() {
        return receive(0);
    }
    public JmsExchange receive() {
        return receive(-1);
    }
    public JmsExchange receive(long timeout) {
        setReceiveTimeout(timeout);
        Message message = template.receive();
        if (message != null) {
            return getEndpoint().createExchange(message);
        }
        return null;
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
    protected void setReceiveTimeout(long timeout) {
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate) template;
            jmsTemplate.setReceiveTimeout(timeout);
        }
        else if (template instanceof JmsTemplate102) {
            JmsTemplate102 jmsTemplate102 = (JmsTemplate102) template;
            jmsTemplate102.setReceiveTimeout(timeout);
        }
        else {
            throw new IllegalArgumentException(""Cannot set the receiveTimeout property on unknown JmsOperations type: "" + template);
        }
    }
}
"
org.apache.camel.component.xmpp.XmppMessage,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.impl.DefaultMessage;
import org.jivesoftware.smack.packet.Message;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
/**
 * Represents a {@link org.apache.camel.Message} for working with XMPP
 *
 * @version $Revision:520964 $
 */
public class XmppMessage extends DefaultMessage {
    private Message xmppMessage;
    public XmppMessage() {
        this(new Message());
    }
    public XmppMessage(Message jmsMessage) {
        this.xmppMessage = jmsMessage;
    }
    @Override
    public String toString() {
        if (xmppMessage != null) {
            return ""XmppMessage: "" + xmppMessage;
        }
        else {
            return ""XmppMessage: "" + getBody();
        }
    }
    @Override
    public XmppExchange getExchange() {
        return (XmppExchange) super.getExchange();
    }
    /**
     * Returns the underlying XMPP message
     *
     * @return the underlying XMPP message
     */
    public Message getXmppMessage() {
        return xmppMessage;
    }
    public void setXmppMessage(Message xmppMessage) {
        this.xmppMessage = xmppMessage;
    }
    public Object getHeader(String name) {
        return xmppMessage.getProperty(name);
    }
    @Override
    public void setHeader(String name, Object value) {
        if (value == null) {
            xmppMessage.deleteProperty(name);
        }
        else {
            xmppMessage.setProperty(name, value);
        }
    }
    @Override
    public Map<String, Object> getHeaders() {
        Map<String, Object> answer = new HashMap<String, Object>();
        Iterator iter = xmppMessage.getPropertyNames();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            answer.put(name, xmppMessage.getProperty(name));
        }
        return answer;
    }
    @Override
    public XmppMessage newInstance() {
        return new XmppMessage();
    }
    @Override
    protected Object createBody() {
        if (xmppMessage != null) {
            return getExchange().getBinding().extractBodyFromXmpp(getExchange(), xmppMessage);
        }
        return null;
    }
}
"
org.apache.camel.bam.model.ProcessInstance,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
/**
 * Represents a single business process
 *
 * @version $Revision: $
 */
@Entity
public class ProcessInstance extends TemporalEntity {
    private static final transient Log log = LogFactory.getLog(ProcessInstance.class);
    private ProcessDefinition processDefinition;
    private Collection<ActivityState> activityStates = new HashSet<ActivityState>();
    private String correlationKey;
    public ProcessInstance() {
        setTimeStarted(new Date());
    }
    public String toString() {
        return getClass().getName() + ""[id: "" + getId() + "", key: "" + getCorrelationKey() + ""]"";
    }
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST})
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    @OneToMany(mappedBy = ""processInstance"", fetch = FetchType.LAZY, cascade = {CascadeType.ALL})
    public Collection<ActivityState> getActivityStates() {
        return activityStates;
    }
    public void setActivityStates(Collection<ActivityState> activityStates) {
        this.activityStates = activityStates;
    }
    public String getCorrelationKey() {
        return correlationKey;
    }
    public void setCorrelationKey(String correlationKey) {
        this.correlationKey = correlationKey;
    }
    // Helper methods
    //-------------------------------------------------------------------------
    /**
     * Returns the activity state for the given activity
     *
     * @param activityRules the activity to find the state for
     * @return the activity state or null if no state could be found for the
     *         given activity
     */
    public ActivityState getActivityState(ActivityRules activityRules) {
        for (ActivityState activityState : getActivityStates()) {
            if (activityState.isActivity(activityRules)) {
                return activityState;
            }
        }
        return null;
    }
    public ActivityState getOrCreateActivityState(ActivityRules activityRules) {
        ActivityState state = getActivityState(activityRules);
        if (state == null) {
            state = createActivityState();
            state.setProcessInstance(this);
            state.setActivityDefinition(activityRules.getActivityDefinition());
            // we don't need to do: getTemplate().persist(state);
        }
        return state;
    }
    protected ActivityState createActivityState() {
        return new ActivityState();
    }
}
"
org.apache.camel.component.mail.MailMessage,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.impl.DefaultMessage;
import org.apache.camel.util.CollectionHelper;
import javax.mail.Header;
import javax.mail.Message;
import javax.mail.MessagingException;
import java.util.Enumeration;
import java.util.Map;
/**
 * Represents a {@link org.apache.camel.Message} for working with Mail
 *
 * @version $Revision:520964 $
 */
public class MailMessage extends DefaultMessage {
    private Message mailMessage;
    public MailMessage() {
    }
    public MailMessage(Message message) {
        this.mailMessage = message;
    }
    @Override
    public String toString() {
        if (mailMessage != null) {
            return ""MailMessage: "" + mailMessage;
        }
        else {
            return ""MailMessage: "" + getBody();
        }
    }
    @Override
    public MailExchange getExchange() {
        return (MailExchange) super.getExchange();
    }
    /**
     * Returns the underlying Mail message
     *
     * @return the underlying Mail message
     */
    public Message getMessage() {
        return mailMessage;
    }
    public void setMessage(Message mailMessage) {
        this.mailMessage = mailMessage;
    }
    public Object getHeader(String name) {
        String[] answer = null;
        if (mailMessage != null) {
            try {
                answer = mailMessage.getHeader(name);
            }
            catch (MessagingException e) {
                throw new MessageHeaderAccessException(name, e);
            }
        }
        if (answer == null) {
            return super.getHeader(name);
        }
        if (answer.length == 1) {
            return answer[0];
        }
        return answer;
    }
    @Override
    public MailMessage newInstance() {
        return new MailMessage();
    }
    @Override
    protected Object createBody() {
        if (mailMessage != null) {
            return getExchange().getBinding().extractBodyFromMail(getExchange(), mailMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (mailMessage != null) {
            Enumeration names;
            try {
                names = mailMessage.getAllHeaders();
            }
            catch (MessagingException e) {
                throw new MessageHeaderNamesAccessException(e);
            }
            try {
                while (names.hasMoreElements()) {
                    Header header = (Header) names.nextElement();
                    String value = header.getValue();
                    String name = header.getName();
                    CollectionHelper.appendValue(map, name, value);
                }
            }
            catch (Throwable e) {
                throw new MessageHeaderNamesAccessException(e);
            }
        }
    }
}
"
org.apache.camel.component.mail.MailExchange,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;
import javax.mail.Message;
/**
 * Represents an {@ilnk Exchange} for working with Mail
 *
 * @version $Revision:520964 $
 */
public class MailExchange extends DefaultExchange {
    private MailBinding binding;
    public MailExchange(CamelContext context, MailBinding binding) {
        super(context);
        this.binding = binding;
    }
    public MailExchange(CamelContext context, MailBinding binding, Message message) {
        this(context, binding);
        setIn(new MailMessage(message));
    }
    @Override
    public MailMessage getIn() {
        return (MailMessage) super.getIn();
    }
    @Override
    public MailMessage getOut() {
        return (MailMessage) super.getOut();
    }
    @Override
    public MailMessage getOut(boolean lazyCreate) {
        return (MailMessage) super.getOut(lazyCreate);
    }
    @Override
    public MailMessage getFault() {
        return (MailMessage) super.getFault();
    }
    public MailBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new MailExchange(getContext(), binding);
    }
    // Expose Email APIs
    //-------------------------------------------------------------------------
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected MailMessage createInMessage() {
        return new MailMessage();
    }
    @Override
    protected MailMessage createOutMessage() {
        return new MailMessage();
    }
}
"
org.apache.camel.bam.model.TemporalEntity,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.Transient;
import java.util.Date;
/**
 * @version $Revision: $
 */
public abstract class TemporalEntity extends EntitySupport {
    private Date timeStarted;
    private Date timeCompleted;
    @Transient
    public boolean isStarted() {
        return timeStarted != null;
    }
    @Transient
    public boolean isCompleted() {
        return timeCompleted != null;
    }
    public Date getTimeStarted() {
        return timeStarted;
    }
    public void setTimeStarted(Date timeStarted) {
        this.timeStarted = timeStarted;
    }
    public Date getTimeCompleted() {
        return timeCompleted;
    }
    public void setTimeCompleted(Date timeCompleted) {
        this.timeCompleted = timeCompleted;
    }
}
"
org.apache.camel.bam.processor.NoCorrelationKeyException,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
/**
 * An exception thrown if no correlation key could be found for a message
 * exchange preventing any particular orchestration or
 * <a href=""http://activemq.apache.org/camel/bam.html"">BAM</a>
 *
 * @version $Revision: $
 */
public class NoCorrelationKeyException extends CamelException {
    private BamProcessorSupport processor;
    private Exchange exchange;
    public NoCorrelationKeyException(BamProcessorSupport processor, Exchange exchange) {
        super(""No correlation key could be found for "" + processor.getCorrelationKeyExpression()
                + "" on "" + exchange);
        this.processor = processor;
        this.exchange = exchange;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public BamProcessorSupport getProcessor() {
        return processor;
    }
}
"
org.apache.camel.spring.xml.StatementRouteBuilder,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.BeanFactory;
import java.util.ArrayList;
/**
 * A {@link RouteBuilder} which is given a list of {@link BuilderStatement} objects
 * to use to create the routes. This is used by the Spring 2 XML parsing code in particular
 * the {@link RouteBuilderFactoryBean}
 *
 * @version $Revision: 1.1 $
*/
public class StatementRouteBuilder extends RouteBuilder  {
    private ArrayList<BuilderStatement> routes;
    private BeanFactory beanFactory;
    @Override
    public void configure() {
        for (BuilderStatement routeFactory : routes) {
            routeFactory.create(beanFactory, this);
        }
    }
    public ArrayList<BuilderStatement> getRoutes() {
        return routes;
    }
    public void setRoutes(ArrayList<BuilderStatement> routes) {
        this.routes = routes;
    }
    public void setBeanFactory(BeanFactory beanFactory) {
        this.beanFactory = beanFactory;
    }
}
"
org.apache.camel.component.cxf.CxfInvokeConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.cxf.endpoint.ServerImpl;
import org.apache.cxf.frontend.ServerFactoryBean;
import org.apache.cxf.message.Message;
/**
 * A consumer of exchanges for a service in CXF
 *
 * @version $Revision$
 */
public class CxfInvokeConsumer extends DefaultConsumer<CxfExchange> {
    protected CxfInvokeEndpoint cxfEndpoint;
    private ServerImpl server;
    public CxfInvokeConsumer(CxfInvokeEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.cxfEndpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        // TODO we need to add custom cxf message observer and wire the
        // incomingCxfMessage method.  Also, custom cxf interceptors are
        // needed in order to object SOAP/XML message.  Currently, the
        // CXF service invoker will invoke the service class.
        if (server != null) {
            // start a cxf service
            ServerFactoryBean svrBean = new ServerFactoryBean();
            svrBean.setAddress(getEndpoint().getEndpointUri());
            svrBean.setServiceClass(Class.forName(cxfEndpoint.getProperty(CxfConstants.IMPL)));
            svrBean.setBus(cxfEndpoint.getBus());
            server = (ServerImpl) svrBean.create();
            server.start();
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (server != null) {
            server.stop();
            server = null;
        }
        super.doStop();
    }
    // TODO this method currently is not being called.
    protected void incomingCxfMessage(Message message) {
        try {
			CxfExchange exchange = cxfEndpoint.createExchange(message);
			getProcessor().process(exchange);
		} catch (Exception e) {
			// TODO: what do do if we are getting processing errors from camel?  Shutdown?
			e.printStackTrace();
		}
    }
}"
org.apache.camel.spring.util.DefaultMethodInvocationStrategy,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.Expression;
import org.apache.camel.Exchange;
import org.apache.camel.Endpoint;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Message;
import org.apache.camel.builder.ExpressionBuilder;
/**
 * Represents the strategy used to figure out how to map a message exchange to a POJO method invocation
 *
 * @version $Revision:$
 */
public class DefaultMethodInvocationStrategy implements MethodInvocationStrategy {
    private Map<Class, Expression> parameterTypeToExpressionMap = new ConcurrentHashMap<Class, Expression>();
    public DefaultMethodInvocationStrategy() {
    }
    public synchronized Expression getDefaultParameterTypeExpression(Class parameterType) {
        return parameterTypeToExpressionMap.get(parameterType);
    }
    /**
     * Adds a default parameter type mapping to an expression
     */
    public synchronized void addParameterMapping(Class parameterType, Expression expression) {
        parameterTypeToExpressionMap.put(parameterType, expression);
    }
    /**
     * Creates an invocation on the given POJO using annotations to decide which method to invoke
     * and to figure out which parameters to use
     */
/*
    public MethodInvocation createInvocation(Object pojo,
                                             BeanInfo beanInfo, 
                                             Exchange messageExchange,
                                             Endpoint pojoEndpoint) throws RuntimeCamelException {
        return beanInfo.createInvocation(pojo, messageExchange);
    }
*/
    public void loadDefaultRegistry() {
        addParameterMapping(Exchange.class, ExpressionBuilder.exchangeExpression());
        addParameterMapping(Message.class, ExpressionBuilder.inMessageExpression());
    }
}
"
org.apache.camel.component.cxf.CxfEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.cxf.BusException;
import org.apache.cxf.message.Message;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.local.LocalTransportFactory;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Endpoint</a>
 *
 * @version $Revision$
 */
public class CxfEndpoint extends DefaultEndpoint<CxfExchange> {
    private CxfBinding binding;
    private final CxfComponent component;
    private final EndpointInfo endpointInfo;
    private boolean inOut = true;
    public CxfEndpoint(String uri, CxfComponent component, EndpointInfo endpointInfo) {
        super(uri, component);
        this.component = component;
        this.endpointInfo = endpointInfo;
    }
    public Producer<CxfExchange> createProducer() throws Exception {
        return new CxfProducer(this, getLocalTransportFactory());
    }
    public Consumer<CxfExchange> createConsumer(Processor processor) throws Exception {
        return new CxfConsumer(this, processor, getLocalTransportFactory());
    }
    public CxfExchange createExchange() {
        return new CxfExchange(getContext(), getBinding());
    }
    public CxfExchange createExchange(Message inMessage) {
        return new CxfExchange(getContext(), getBinding(), inMessage);
    }
    public CxfBinding getBinding() {
        if (binding == null) {
            binding = new CxfBinding();
        }
        return binding;
    }
    public void setBinding(CxfBinding binding) {
        this.binding = binding;
    }
    public boolean isInOut() {
        return inOut;
    }
    public void setInOut(boolean inOut) {
        this.inOut = inOut;
    }
    public LocalTransportFactory getLocalTransportFactory() throws BusException {
        return component.getLocalTransportFactory();
    }
    public EndpointInfo getEndpointInfo() {
        return endpointInfo;
    }
    public CxfComponent getComponent() {
        return component;
    }
	public boolean isSingleton() {
		return true;
	}
}
"
org.apache.camel.component.quartz.QuartzComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.Trigger;
import org.quartz.CronTrigger;
import org.quartz.impl.StdSchedulerFactory;
import java.util.Map;
import java.net.URI;
import com.sun.jndi.toolkit.url.Uri;
/**
 * A <a href=""http://activemq.apache.org/camel/quartz.html"">Quartz Component</a>
 *
 * @version $Revision:520964 $
 */
public class QuartzComponent extends DefaultComponent<QuartzExchange> {
    private static final transient Log log = LogFactory.getLog(QuartzComponent.class);
    private SchedulerFactory factory;
    private Scheduler scheduler;
    private Map<Trigger, JobDetail> triggers;
    public QuartzComponent() {
    }
    public QuartzComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected QuartzEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        QuartzEndpoint answer = new QuartzEndpoint(uri, this, getScheduler());
        // lets split the remaining into a group/name
        URI u = new URI(uri);
        String name;
        String group = ""Camel"";
        String path = u.getPath();
        CronTrigger cronTrigger = null;
        if (path != null && path.length() > 1) {
            if (path.startsWith(""/"")) {
                path = path.substring(1);
            }
            int idx = path.indexOf('/');
            if (idx > 0) {
                cronTrigger = new CronTrigger();
                name = path.substring(0, idx);
                String cronExpression = path.substring(idx + 1);
                // lets allow / instead of spaces and allow $ instead of ?
                cronExpression = cronExpression.replace('/', ' ');
                cronExpression = cronExpression.replace('$', '?');
                log.debug(""Creating cron trigger: "" + cronExpression);
                cronTrigger.setCronExpression(cronExpression);
                answer.setTrigger(cronTrigger);
            }
            else {
                name = path;
            }
            group = u.getHost();
        }
        else {
            name = u.getHost();
        }
/*
        String[] names = ObjectHelper.splitOnCharacter(remaining, ""/"", 2);
        if (names[1] != null) {
            group = names[0];
            name = names[1];
        }
        else {
            name = names[0];
        }
*/
        Trigger trigger = cronTrigger;
        if (trigger == null) {
            trigger = answer.getTrigger();
        }
        trigger.setName(name);
        trigger.setGroup(group);
        Map triggerParameters = IntrospectionSupport.extractProperties(parameters, ""trigger."");
        Map jobParameters = IntrospectionSupport.extractProperties(parameters, ""job."");
        IntrospectionSupport.setProperties(trigger, triggerParameters);
        IntrospectionSupport.setProperties(answer.getJobDetail(), jobParameters);
        return answer;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getScheduler().start();
    }
    @Override
    protected void doStop() throws Exception {
        if (scheduler != null) {
            scheduler.shutdown();
        }
        super.doStop();
    }
    // Properties
    //-------------------------------------------------------------------------
    public SchedulerFactory getFactory() {
        if (factory == null) {
            factory = createSchedulerFactory();
        }
        return factory;
    }
    public void setFactory(SchedulerFactory factory) {
        this.factory = factory;
    }
    public Scheduler getScheduler() throws SchedulerException {
        if (scheduler == null) {
            scheduler = createScheduler();
        }
        return scheduler;
    }
    public void setScheduler(Scheduler scheduler) {
        this.scheduler = scheduler;
    }
    public Map getTriggers() {
        return triggers;
    }
    public void setTriggers(Map triggers) {
        this.triggers = triggers;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected SchedulerFactory createSchedulerFactory() {
        return new StdSchedulerFactory();
    }
    protected Scheduler createScheduler() throws SchedulerException {
        return getFactory().getScheduler();
    }
}"
org.apache.camel.component.jms.JmsComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import static org.apache.camel.util.ObjectHelper.removeStartingCharacters;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.transaction.PlatformTransactionManager;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import javax.jms.Session;
import java.util.Map;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Component</a>
 *
 * @version $Revision:520964 $
 */
public class JmsComponent extends DefaultComponent<JmsExchange> {
    public static final String QUEUE_PREFIX = ""queue:"";
    public static final String TOPIC_PREFIX = ""topic:"";
    private JmsConfiguration configuration;
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent() {
        return new JmsComponent();
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(JmsConfiguration configuration) {
        return new JmsComponent(configuration);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(ConnectionFactory connectionFactory) {
        return jmsComponent(new JmsConfiguration(connectionFactory));
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentClientAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.CLIENT_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentAutoAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.AUTO_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setTransacted(true);
        return jmsComponent(template);
    }
	public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory, PlatformTransactionManager transactionManager) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setTransactionManager(transactionManager);
        template.setTransacted(true);
        return jmsComponent(template);
	}
    public JmsComponent() {
    }
    public JmsComponent(JmsConfiguration configuration) {
        this.configuration = configuration;
    }
    public JmsComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<JmsExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        boolean pubSubDomain = false;
        if (remaining.startsWith(QUEUE_PREFIX)) {
            pubSubDomain = false;
            remaining = removeStartingCharacters(remaining.substring(QUEUE_PREFIX.length()), '/');
        }
        else if (remaining.startsWith(TOPIC_PREFIX)) {
            pubSubDomain = true;
            remaining = removeStartingCharacters(remaining.substring(TOPIC_PREFIX.length()), '/');
        }
        final String subject = convertPathToActualDestination(remaining);
        // lets make sure we copy the configuration as each endpoint can customize its own version
        JmsEndpoint endpoint = new JmsEndpoint(uri, this, subject, pubSubDomain, getConfiguration().copy());
        String selector = (String) parameters.remove(""selector"");
        if (selector != null) {
            endpoint.setSelector(selector);
        }
        IntrospectionSupport.setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public JmsConfiguration getConfiguration() {
        if (configuration == null) {
            configuration = createConfiguration();
        }
        return configuration;
    }
    /**
     * Sets the JMS configuration
     *
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(JmsConfiguration configuration) {
        this.configuration = configuration;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        getConfiguration().setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementMode(consumerAcknowledgementMode);
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementModeName(consumerAcknowledgementMode);
    }
    public void setAutoStartup(boolean autoStartup) {
        getConfiguration().setAutoStartup(autoStartup);
    }
    public void setCacheLevel(int cacheLevel) {
        getConfiguration().setCacheLevel(cacheLevel);
    }
    public void setCacheLevelName(String cacheName) {
        getConfiguration().setCacheLevelName(cacheName);
    }
    public void setClientId(String consumerClientId) {
        getConfiguration().setClientId(consumerClientId);
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        getConfiguration().setConcurrentConsumers(concurrentConsumers);
    }
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        getConfiguration().setConnectionFactory(connectionFactory);
    }
    public void setConsumerType(ConsumerType consumerType) {
        getConfiguration().setConsumerType(consumerType);
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        getConfiguration().setDeliveryPersistent(deliveryPersistent);
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        getConfiguration().setDurableSubscriptionName(durableSubscriptionName);
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        getConfiguration().setExceptionListener(exceptionListener);
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        getConfiguration().setExplicitQosEnabled(explicitQosEnabled);
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        getConfiguration().setExposeListenerSession(exposeListenerSession);
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        getConfiguration().setIdleTaskExecutionLimit(idleTaskExecutionLimit);
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        getConfiguration().setMaxConcurrentConsumers(maxConcurrentConsumers);
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        getConfiguration().setMaxMessagesPerTask(maxMessagesPerTask);
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        getConfiguration().setMessageConverter(messageConverter);
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        getConfiguration().setMessageIdEnabled(messageIdEnabled);
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        getConfiguration().setMessageTimestampEnabled(messageTimestampEnabled);
    }
    public void setPriority(int priority) {
        getConfiguration().setPriority(priority);
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        getConfiguration().setPubSubNoLocal(pubSubNoLocal);
    }
    public void setReceiveTimeout(long receiveTimeout) {
        getConfiguration().setReceiveTimeout(receiveTimeout);
    }
    public void setRecoveryInterval(long recoveryInterval) {
        getConfiguration().setRecoveryInterval(recoveryInterval);
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        getConfiguration().setServerSessionFactory(serverSessionFactory);
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        getConfiguration().setSubscriptionDurable(subscriptionDurable);
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        getConfiguration().setTaskExecutor(taskExecutor);
    }
    public void setTimeToLive(long timeToLive) {
        getConfiguration().setTimeToLive(timeToLive);
    }
    public void setTransacted(boolean consumerTransacted) {
        getConfiguration().setTransacted(consumerTransacted);
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        getConfiguration().setTransactionManager(transactionManager);
    }
    public void setTransactionName(String transactionName) {
        getConfiguration().setTransactionName(transactionName);
    }
    public void setTransactionTimeout(int transactionTimeout) {
        getConfiguration().setTransactionTimeout(transactionTimeout);
    }
    public void setUseVersion102(boolean useVersion102) {
        getConfiguration().setUseVersion102(useVersion102);
    }
    /**
     * A strategy method allowing the URI destination to be translated into the actual JMS destination name
     * (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path) {
        return path;
    }
    /**
     * Factory method to create the default configuration instance
     *
     * @return a newly created configuration object which can then be further customized
     */
    protected JmsConfiguration createConfiguration() {
        return new JmsConfiguration();
    }
}
"
org.apache.camel.spring.remoting.CamelServiceExporter,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.component.pojo.PojoComponent;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.remoting.support.RemoteExporter;
/**
 * Exports a Spring defined service to Camel as a Pojo endpoint.
 *  
 * @author chirino
 */
public class CamelServiceExporter extends RemoteExporter implements InitializingBean, DisposableBean {
	CamelContext camelContext;
	PojoComponent pojoComponent;
	String serviceName;
	public void afterPropertiesSet() throws Exception {
		if( serviceName == null ) {
			throw new IllegalArgumentException(""The serviceName must be configured."");
		}
		if( pojoComponent == null ) {
			if( camelContext == null ) {
				throw new IllegalArgumentException(""A pojoComponent or camelContext must be configured."");
			}
			pojoComponent = (PojoComponent) camelContext.getComponent(""pojo"");
			if( pojoComponent == null ) {
				throw new IllegalArgumentException(""The pojoComponent could not be found."");
			}
		}
		pojoComponent.addService(serviceName, getProxyForService());
	}
	public void destroy() throws Exception {
		if( serviceName!=null ) {
			pojoComponent.removeService(serviceName);
		}
	}
	public PojoComponent getPojoComponent() {
		return pojoComponent;
	}
	public void setPojoComponent(PojoComponent pojoComponent) {
		this.pojoComponent = pojoComponent;
	}
	public CamelContext getCamelContext() {
		return camelContext;
	}
	public void setCamelContext(CamelContext camelContext) {
		this.camelContext = camelContext;
	}
	public String getServiceName() {
		return serviceName;
	}
	public void setServiceName(String serviceName) {
		this.serviceName = serviceName;
	}
}
"
org.apache.camel.bam.processor.JpaBamProcessorSupport,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.IntrospectionSupport;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
import java.util.List;
/**
 * A base class for JPA based BAM which can use any entity to store the process instance information which
 * allows derived classes to specialise the process instance entity.
 *
 * @version $Revision: $
 */
public class JpaBamProcessorSupport<T> extends BamProcessorSupport<T> {
    private ActivityRules activityRules;
    private JpaTemplate template;
    private String findByKeyQuery;
    private String keyPropertyName = ""correlationKey"";
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules, Class<T> entitytype) {
        super(transactionTemplate, correlationKeyExpression, entitytype);
        this.activityRules = activityRules;
        this.template = template;
    }
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, correlationKeyExpression);
        this.activityRules = activityRules;
        this.template = template;
    }
    public String getFindByKeyQuery() {
        if (findByKeyQuery == null) {
            findByKeyQuery = createFindByKeyQuery();
        }
        return findByKeyQuery;
    }
    public void setFindByKeyQuery(String findByKeyQuery) {
        this.findByKeyQuery = findByKeyQuery;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public void setActivityRules(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public String getKeyPropertyName() {
        return keyPropertyName;
    }
    public void setKeyPropertyName(String keyPropertyName) {
        this.keyPropertyName = keyPropertyName;
    }
    public JpaTemplate getTemplate() {
        return template;
    }
    public void setTemplate(JpaTemplate template) {
        this.template = template;
    }
    // Implementatiom methods
    //-----------------------------------------------------------------------
    protected T loadEntity(Exchange exchange, Object key) {
        List<T> list = template.find(getFindByKeyQuery(), key);
        T entity = null;
        if (!list.isEmpty()) {
            entity = list.get(0);
        }
        if (entity == null) {
            entity = createEntity(exchange, key);
            setKeyProperty(entity, key);
            ProcessDefinition definition = ProcessDefinition.getRefreshedProcessDefinition(template, getActivityRules().getProcessRules().getProcessDefinition());
            setProcessDefinitionProperty(entity, definition);
            template.persist(entity);
        }
        return entity;
    }
    /**
     * Sets the key property on the new entity
     */
    protected void setKeyProperty(T entity, Object key) {
        IntrospectionSupport.setProperty(entity, getKeyPropertyName(), key);
    }
    protected void setProcessDefinitionProperty(T entity, ProcessDefinition processDefinition) {
        IntrospectionSupport.setProperty(entity, ""processDefinition"", processDefinition);
    }
    /**
     * Create a new instance of the entity for the given key
     */
    protected T createEntity(Exchange exchange, Object key) {
        return (T) exchange.getContext().getInjector().newInstance(getEntityType());
    }
    protected void processEntity(Exchange exchange, T entity) throws Exception {
        if (entity instanceof Processor) {
            Processor processor = (Processor) entity;
            processor.process(exchange);
        }
        else {
            // TODO add other extension points - eg. passing in Activity
            throw new IllegalArgumentException(""No processor defined for this route"");
        }
    }
    protected String createFindByKeyQuery() {
        return ""select x from "" + getEntityType().getName() + "" x where x."" + getKeyPropertyName() + "" = ?1"";
    }
}
"
org.apache.camel.component.cxf.transport.CamelTransportFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import org.apache.camel.CamelContext;
import org.apache.cxf.Bus;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractTransportFactory;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.DestinationFactory;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
import javax.annotation.Resource;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
/**
 * @version $Revision$
 */
public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator, DestinationFactory {
    private static final Set<String> URI_PREFIXES = new HashSet<String>();
    static {
        URI_PREFIXES.add(""camel://"");
    }
    private Bus bus;
    private CamelContext camelContext;
    @Resource
    public void setBus(Bus b) {
        bus = b;
    }
    public Bus getBus() {
        return bus;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    @Resource
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public Conduit getConduit(EndpointInfo targetInfo) throws IOException {
        return getConduit(targetInfo, null);
    }
    public Conduit getConduit(EndpointInfo endpointInfo, EndpointReferenceType target) throws IOException {
        return new CamelConduit(camelContext, bus, endpointInfo, target);
    }
    public Destination getDestination(EndpointInfo endpointInfo) throws IOException {
        CamelDestination destination = new CamelDestination(camelContext, bus, this, endpointInfo);
        Configurer configurer = bus.getExtension(Configurer.class);
        if (null != configurer) {
            configurer.configureBean(destination);
        }
        return destination;
    }
    public Set<String> getUriPrefixes() {
        return URI_PREFIXES;
    }
}
"
org.apache.camel.spring.SpringCamelContext,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.CamelContext;
import org.apache.camel.spring.spi.SpringComponentResolver;
import org.apache.camel.spring.spi.SpringInjector;
import org.apache.camel.spring.component.BeanComponent;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
/**
 * A Spring aware implementation of {@link CamelContext} which will automatically register itself with Springs lifecycle
 * methods  plus allows spring to be used to customize a any
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a> as well as supporting accessing components
 * and beans via the Spring {@link ApplicationContext}
 *
 * @version $Revision$
 */
public class SpringCamelContext extends DefaultCamelContext implements InitializingBean, DisposableBean, ApplicationContextAware {
    private ApplicationContext applicationContext;
    public SpringCamelContext() {
    }
    public SpringCamelContext(ApplicationContext applicationContext) {
        setApplicationContext(applicationContext);
    }
    public static SpringCamelContext springCamelContext(ApplicationContext applicationContext) throws Exception {
        // lets try and look up a configured camel context in the context
        String[] names = applicationContext.getBeanNamesForType(SpringCamelContext.class);
        if (names.length == 1) {
            return (SpringCamelContext) applicationContext.getBean(names[0], SpringCamelContext.class);
        }
        SpringCamelContext answer = new SpringCamelContext();
        answer.setApplicationContext(applicationContext);
        answer.afterPropertiesSet();
        return answer;
    }
    public static SpringCamelContext springCamelContext(String configLocations) throws Exception {
        return springCamelContext(new ClassPathXmlApplicationContext(configLocations));
    }
    public void afterPropertiesSet() throws Exception {
        // lets force lazy initialisation
        getInjector();
        start();
    }
    public void destroy() throws Exception {
        stop();
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        addComponent(""bean"", new BeanComponent(applicationContext));
    }
    @Override
    protected Injector createInjector() {
        return new SpringInjector((AbstractRefreshableApplicationContext) getApplicationContext());
    }
    @Override
    protected ComponentResolver createComponentResolver() {
        ComponentResolver defaultResolver = super.createComponentResolver();
        return new SpringComponentResolver(getApplicationContext(), defaultResolver);
    }
}
"
org.apache.camel.spring.spi.BeanInjector,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.springframework.context.ApplicationContext;
import org.springframework.beans.factory.wiring.BeanConfigurerSupport;
/**
 * @version $Revision: 1.1 $
 */
public class BeanInjector extends BeanConfigurerSupport {
    public BeanInjector(ApplicationContext applicationContext) throws Exception {
        setBeanFactory(applicationContext);
        afterPropertiesSet();
    }
    public void inject(Object bean) {
        configureBean(bean);
    }
}
"
org.apache.camel.component.mail.MessageHeaderNamesAccessException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
/**
 * @version $Revision:520964 $
 */
public class MessageHeaderNamesAccessException extends RuntimeMailException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessageHeaderNamesAccessException(Throwable e) {
        super(""Failed to acess the Mail message property names"", e);
    }
}
"
org.apache.camel.component.jbi.CamelJbiComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
 * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
 * to You under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.FailedToCreateProducerException;
import org.apache.servicemix.common.DefaultComponent;
import org.apache.servicemix.jbi.util.IntrospectionSupport;
import org.apache.servicemix.jbi.util.URISupport;
import org.apache.servicemix.jbi.resolver.URIResolver;
import javax.jbi.servicedesc.ServiceEndpoint;
import javax.xml.namespace.QName;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
/**
 * Deploys the camel endpoints within JBI
 *
 * @version $Revision: 426415 $
 */
public class CamelJbiComponent extends DefaultComponent implements Component<Exchange> {
    private JbiBinding binding;
    private CamelContext camelContext;
    private ScheduledExecutorService executorService;
    /**
     * @return List of endpoints
     * @see org.apache.servicemix.common.DefaultComponent#getConfiguredEndpoints()
     */
    @Override
    protected List<CamelJbiEndpoint> getConfiguredEndpoints() {
        // TODO need to register to the context for new endpoints...
        List<CamelJbiEndpoint> answer = new ArrayList<CamelJbiEndpoint>();
//        Collection<Endpoint> endpoints = camelContext.getEndpoints();
//        for (Endpoint endpoint : endpoints) {
//          answer.add(createJbiEndpoint(endpoint));
//        }
        return answer;
    }
    /**
     * @return Class[]
     * @see org.apache.servicemix.common.DefaultComponent#getEndpointClasses()
     */
    @Override
    protected Class[] getEndpointClasses() {
        return new Class[]{CamelJbiEndpoint.class};
    }
    /**
     * @return the binding
     */
    public JbiBinding getBinding() {
        if (binding == null) {
            binding = new JbiBinding();
        }
        return binding;
    }
    /**
     * @param binding the binding to set
     */
    public void setBinding(JbiBinding binding) {
        this.binding = binding;
    }
    @Override
    protected String[] getEPRProtocols() {
        return new String[]{""camel""};
    }
    protected org.apache.servicemix.common.Endpoint getResolvedEPR(ServiceEndpoint ep) throws Exception {
        CamelJbiEndpoint endpoint = createEndpoint(ep);
        endpoint.activate();
        return endpoint;
    }
    public CamelJbiEndpoint createEndpoint(ServiceEndpoint ep) throws URISyntaxException {
        URI uri = new URI(ep.getEndpointName());
        Map map = URISupport.parseQuery(uri.getQuery());
        String camelUri = uri.getSchemeSpecificPart();
        Endpoint camelEndpoint = getCamelContext().getEndpoint(camelUri);
        Processor processor = null;
        try {
            processor = camelEndpoint.createProducer();
        }
        catch (Exception e) {
            throw new FailedToCreateProducerException(camelEndpoint, e);
        }
        CamelJbiEndpoint endpoint = new CamelJbiEndpoint(getServiceUnit(), camelEndpoint, getBinding(), processor);
        IntrospectionSupport.setProperties(endpoint, map);
        // TODO
        //endpoint.setRole(MessageExchange.Role.PROVIDER);
        return endpoint;
    }
    // Resolve Camel Endpoints
    //-------------------------------------------------------------------------
    public Endpoint<Exchange> createEndpoint(String uri) {
        if (uri.startsWith(""jbi:"")) {
            uri = uri.substring(""jbi:"".length());
            return new JbiEndpoint(this, uri);
        }
        return null;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            executorService = new ScheduledThreadPoolExecutor(5);
        }
        return executorService;
    }
    /**
     * Returns a JBI endpoint created for the given Camel endpoint
     */
    public CamelJbiEndpoint activateJbiEndpoint(JbiEndpoint camelEndpoint, Processor processor) throws Exception {
        CamelJbiEndpoint jbiEndpoint;
        String endpointUri = camelEndpoint.getEndpointUri();
        if (endpointUri.startsWith(""endpoint:"")) {
            // lets decode ""service:serviceNamespace:serviceName:endpointName
            String uri = endpointUri.substring(""endpoint:"".length());
            String[] parts = new String[0];
            try {
                parts = URIResolver.split3(uri);
            }
            catch (IllegalArgumentException e) {
                throw new IllegalArgumentException(""Expected syntax endpoint:[serviceNamespace]:[serviceName]:[endpointName] but was given: "" + endpointUri + "". Cause: "" + e, e);
            }
            QName service = new QName(parts[0], parts[1]);
            String endpoint = parts[2];
            jbiEndpoint = new CamelJbiEndpoint(getServiceUnit(), service, endpoint, camelEndpoint, getBinding(), processor);
        }
        else {
            jbiEndpoint = new CamelJbiEndpoint(getServiceUnit(), camelEndpoint, getBinding(), processor);
        }
        // the following method will activate the new dynamic JBI endpoint
        addEndpoint(jbiEndpoint);
        return jbiEndpoint;
    }
}
"
org.apache.camel.spring.EndpointFactoryBean,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.springframework.beans.factory.FactoryBean;
/**
 * A {@link FactoryBean} which instantiates {@link Endpoint} objects
 *
 * @version $Revision: 1.1 $
 */
public class EndpointFactoryBean implements FactoryBean {
    private CamelContext context;
    private String uri;
    private Endpoint endpoint;
    private boolean singleton;
    public Object getObject() throws Exception {
        if (endpoint == null) {
            endpoint = createEndpoint();
        }
        return endpoint;
    }
    public Class getObjectType() {
        return Endpoint.class;
    }
    public boolean isSingleton() {
        return singleton;
    }
    public CamelContext getContext() {
        return context;
    }
    /**
     * Sets the context to use to resolve endpoints
     *
     * @param context the context used to resolve endpoints
     */
    public void setContext(CamelContext context) {
        this.context = context;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public void setSingleton(boolean singleton) {
        this.singleton = singleton;
    }
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI to use to resolve the endpoint
     *
     * @param uri the URI used to set the endpoint
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    protected Endpoint createEndpoint() {
        notNull(context, ""context"");
        notNull(uri, ""uri"");
        return context.getEndpoint(uri);
    }
}
"
org.apache.camel.component.cxf.transport.CamelConstants,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
/**
 * @version $Revision$
 */
public class CamelConstants {
    public static final String TEXT_MESSAGE_TYPE = ""text"";
    public static final String BINARY_MESSAGE_TYPE = ""binary"";
    public static final String CAMEL_SERVER_REQUEST_HEADERS = ""org.apache.cxf.camel.server.request.headers"";
    public static final String CAMEL_SERVER_RESPONSE_HEADERS = ""org.apache.cxf.camel.server.response.headers"";
    public static final String CAMEL_REQUEST_MESSAGE = ""org.apache.cxf.camel.request.message"";
    public static final String CAMEL_RESPONSE_MESSAGE = ""org.apache.cxf.camel.reponse.message"";
    public static final String CAMEL_CLIENT_REQUEST_HEADERS = ""org.apache.cxf.camel.template.request.headers"";
    public static final String CAMEL_CLIENT_RESPONSE_HEADERS =
            ""org.apache.cxf.camel.template.response.headers"";
    public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = ""org.apache.cxf.camel.template.timeout"";
    public static final String CAMEL_SERVER_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-server"";
    public static final String CAMEL_CLIENT_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-template"";
    public static final String ENDPOINT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/endpoint-config"";
    public static final String SERVICE_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/service-config"";
    public static final String PORT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/port-config"";
    public static final String CAMEL_CLIENT_CONFIG_ID = ""camel-template"";
    public static final String CAMEL_SERVER_CONFIG_ID = ""camel-server"";
    public static final String CAMEL_REBASED_REPLY_TO = ""org.apache.cxf.camel.server.replyto"";
    public static final String CAMEL_CORRELATION_ID = ""org.apache.cxf.camel.correlationId"";
}
"
org.apache.camel.spring.util.BeanInfo,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.Body;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Header;
import org.apache.camel.Property;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
/**
 * Represents the metadata about a bean type created via a combination of
 * introspection and annotations together with some useful sensible defaults
 *
 * @version $Revision: $
 */
public class BeanInfo {
    private static final transient Log log = LogFactory.getLog(BeanInfo.class);
    private Class type;
    private MethodInvocationStrategy strategy;
    private Map<String, MethodInfo> operations = new ConcurrentHashMap<String, MethodInfo>();
    private MethodInfo defaultExpression;
    public BeanInfo(Class type, MethodInvocationStrategy strategy) {
        this.type = type;
        this.strategy = strategy;
    }
    public Class getType() {
        return type;
    }
    public void introspect() {
        introspect(getType());
        if (operations.size() == 1) {
            Collection<MethodInfo> methodInfos = operations.values();
            for (MethodInfo methodInfo : methodInfos) {
                defaultExpression = methodInfo;
            }
        }
    }
    public MethodInvocation createInvocation(Method method, Object pojo, Exchange messageExchange) throws RuntimeCamelException {
        MethodInfo methodInfo = introspect(type, method);
        return methodInfo.createMethodInvocation(pojo, messageExchange);
    }
    public MethodInvocation createInvocation(Object pojo, Exchange messageExchange) throws RuntimeCamelException {
        MethodInfo methodInfo = null;
        // TODO use some other mechanism?
        String name = messageExchange.getIn().getHeader(""org.apache.camel.MethodName"", String.class);
        if (name != null) {
            methodInfo = operations.get(name);
        }
        if (methodInfo == null) {
            methodInfo = defaultExpression;
        }
        if (methodInfo != null) {
            return methodInfo.createMethodInvocation(pojo, messageExchange);
        }
        return null;
    }
    protected void introspect(Class clazz) {
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            introspect(clazz, method);
        }
        Class superclass = clazz.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            introspect(superclass);
        }
    }
    protected MethodInfo introspect(Class clazz, Method method) {
        Class[] parameterTypes = method.getParameterTypes();
        Annotation[][] parameterAnnotations = method.getParameterAnnotations();
        final Expression[] parameterExpressions = new Expression[parameterTypes.length];
        for (int i = 0; i < parameterTypes.length; i++) {
            Class parameterType = parameterTypes[i];
            Expression expression = createParameterUnmarshalExpression(clazz, method,
                    parameterType, parameterAnnotations[i]);
            if (expression == null) {
                if (log.isDebugEnabled()) {
                    log.debug(""No expression available for method: ""
                            + method.toString() + "" parameter: "" + i + "" so ignoring method"");
                }
                if (parameterTypes.length == 1) {
                	// lets assume its the body
                	expression = ExpressionBuilder.bodyExpression(parameterType);
                }
                else {
                	return null;
                }
            }
            parameterExpressions[i] = expression;
        }
        // now lets add the method to the repository
        String opName = method.getName();
        /*
        TODO allow an annotation to expose the operation name to use
        if (method.getAnnotation(Operation.class) != null) {
            String name = method.getAnnotation(Operation.class).name();
            if (name != null && name.length() > 0) {
                opName = name;
            }
        }
        */
        Expression parametersExpression = createMethodParametersExpression(parameterExpressions);
        MethodInfo methodInfo = new MethodInfo(clazz, method, parametersExpression);
        operations.put(opName, methodInfo);
        return methodInfo;
    }
    protected Expression createMethodParametersExpression(final Expression[] parameterExpressions) {
        return new Expression<Exchange>() {
            public Object evaluate(Exchange exchange) {
                Object[] answer = new Object[parameterExpressions.length];
                for (int i = 0; i < parameterExpressions.length; i++) {
                    Expression parameterExpression = parameterExpressions[i];
                    answer[i] = parameterExpression.evaluate(exchange);
                }
                return answer;
            }
            @Override
            public String toString() {
                return ""parametersExpression"" + Arrays.asList(parameterExpressions);
            }
        };
    }
    /**
     * Creates an expression for the given parameter type if the parameter can be mapped
     * automatically or null if the parameter cannot be mapped due to unsufficient
     * annotations or not fitting with the default type conventions.
     */
    protected Expression createParameterUnmarshalExpression(Class clazz, Method method, Class parameterType, Annotation[] parameterAnnotation) {
        // TODO look for a parameter annotation that converts into an expression
        for (Annotation annotation : parameterAnnotation) {
            Expression answer = createParameterUnmarshalExpressionForAnnotation(
                    clazz, method, parameterType, annotation);
            if (answer != null) {
                return answer;
            }
        }
        return strategy.getDefaultParameterTypeExpression(parameterType);
    }
    protected Expression createParameterUnmarshalExpressionForAnnotation(Class clazz, Method method, Class parameterType, Annotation annotation) {
        if (annotation instanceof Property) {
            Property propertyAnnotation = (Property) annotation;
            return ExpressionBuilder.propertyExpression(propertyAnnotation.name());
        }
        else if (annotation instanceof Header) {
            Header headerAnnotation = (Header) annotation;
            return ExpressionBuilder.headerExpression(headerAnnotation.name());
        }
        else if (annotation instanceof Body) {
            Body content = (Body) annotation;
            return ExpressionBuilder.bodyExpression(parameterType);
            // TODO allow annotations to be used to create expressions?
/*
        } else if (annotation instanceof XPath) {
            XPath xpathAnnotation = (XPath) annotation;
            return new JAXPStringXPathExpression(xpathAnnotation.xpath());
        }
*/
        }
        return null;
    }
}
"
org.apache.camel.component.http.CamelServlet,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @version $Revision$
 */
public class CamelServlet extends HttpServlet {
    private ConcurrentHashMap<String, HttpConsumer> consumers=new ConcurrentHashMap<String, HttpConsumer>();
	public CamelServlet() {
    }
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
        	// Is there a consumer registered for the request.
        	HttpConsumer consumer = resolve(request);
        	if( consumer == null ) {
        		response.sendError(HttpServletResponse.SC_NOT_FOUND);
        		return;
        	}
        	// Have the camel process the HTTP exchange.
			HttpExchange exchange =  new HttpExchange(consumer.getEndpoint(), request, response);			
			consumer.getProcessor().process(exchange);
			// HC: The getBinding() is interesting because it illustrates the impedance miss-match between
			// HTTP's stream oriented protocol, and Camels more message oriented protocol exchanges.
			// now lets output to the response
			consumer.getBinding().writeResponse(exchange);
		} catch (Exception e) {
			throw new ServletException(e);
		}
    }
	protected HttpConsumer resolve(HttpServletRequest request) {
		String path = request.getPathInfo();
		return consumers.get(path);
	}
	public void connect(HttpConsumer consumer) {
		consumers.put(consumer.getPath(), consumer);
	}
	public void disconnect(HttpConsumer consumer) {
		consumers.remove(consumer.getPath());
	}
}
"
org.apache.camel.spring.RouteBuilderFinder,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.ResolverUtil;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**
 * A helper class which will find all {@link RouteBuilder} instances on the classpath
 *
 * @version $Revision$
 */
public class RouteBuilderFinder implements ApplicationContextAware {
    private String[] packages = {};
    private ApplicationContext applicationContext;
    private ResolverUtil resolver = new ResolverUtil();
    public RouteBuilderFinder(ApplicationContext applicationContext, String[] packages) {
        this.applicationContext = applicationContext;
        this.packages = packages;
    }
    public RouteBuilderFinder(CamelContextFactoryBean factoryBean) {
        this.applicationContext = factoryBean.getApplicationContext();
        this.packages = factoryBean.getPackages();
    }
    public String[] getPackages() {
        return packages;
    }
    public void setPackages(String[] packages) {
        this.packages = packages;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    /**
     * Appends all the {@link RouteBuilder} instances that can be found on the classpath
     */
    public void appendBuilders(List<RouteBuilder> list) throws IllegalAccessException, InstantiationException {
        resolver.findImplementations(RouteBuilder.class, packages);
        //resolver.findAnnotated(Endpoint.class, packages);
        Set<Class> classes = resolver.getClasses();
        for (Class aClass : classes) {
            if (shouldIgnoreBean(aClass)) {
                continue;
            }
            if (isValidClass(aClass)) {
                list.add(instantiateBuilder(aClass));
            }
        }
    }
    public void destroy() throws Exception {
    }
    /**
     * Lets ignore beans that are not explicitly configured in the spring.xml
     */
    protected boolean shouldIgnoreBean(Class type) {
        Map beans = applicationContext.getBeansOfType(type, true, true);
        if (beans == null || beans.isEmpty()) {
            return false;
        }
        // TODO apply some filter?
        return true;
    }
    /**
     * Returns true if the object is non-abstract and supports a zero argument constructor
     */
    protected boolean isValidClass(Class type) {
        if (!Modifier.isAbstract(type.getModifiers()) && !type.isInterface()) {
            Constructor[] constructors = type.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                Class[] classes = constructor.getParameterTypes();
                if (classes.length == 0) {
                    return true;
                }
            }
        }
        return false;
    }
    protected RouteBuilder instantiateBuilder(Class type) throws IllegalAccessException, InstantiationException {
        // TODO we could support spring-injection for these types
        return (RouteBuilder) type.newInstance();
    }
}"
org.apache.camel.bam.model.EntitySupport,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
/**
 * A base class for persistent entities
 *
 * @version $Revision: $
 */
public class EntitySupport {
    private Long id;
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String toString() {
        return getClass().getName() + ""["" + id + ""]"";
    }
}
"
org.apache.camel.component.jms.JmsConfiguration,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ObjectHelper;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer102;
import org.springframework.jms.listener.SimpleMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer102;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer102;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.transaction.PlatformTransactionManager;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
/**
 * @version $Revision$
 */
public class JmsConfiguration implements Cloneable {
    protected static final String TRANSACTED = ""TRANSACTED"";
    protected static final String CLIENT_ACKNOWLEDGE = ""CLIENT_ACKNOWLEDGE"";
    protected static final String AUTO_ACKNOWLEDGE = ""AUTO_ACKNOWLEDGE"";
    protected static final String DUPS_OK_ACKNOWLEDGE = ""DUPS_OK_ACKNOWLEDGE"";
    private ConnectionFactory connectionFactory;
    private ConnectionFactory templateConnectionFactory;
    private ConnectionFactory listenerConnectionFactory;
    private int acknowledgementMode = -1;
    private String acknowledgementModeName = AUTO_ACKNOWLEDGE;
    // Used to configure the spring Container
    private ExceptionListener exceptionListener;
    private ConsumerType consumerType = ConsumerType.Default;
    private boolean autoStartup = true;
    private boolean acceptMessagesWhileStopping;
    private String clientId;
    private String durableSubscriptionName;
    private boolean subscriptionDurable;
    private boolean exposeListenerSession = true;
    private TaskExecutor taskExecutor;
    private boolean pubSubNoLocal;
    private int concurrentConsumers = 1;
    private int maxMessagesPerTask = 1;
    private ServerSessionFactory serverSessionFactory;
    private int cacheLevel = -1;
    private String cacheLevelName = ""CACHE_CONSUMER"";
    private long recoveryInterval = -1;
    private long receiveTimeout = -1;
    private int idleTaskExecutionLimit = 1;
    private int maxConcurrentConsumers = 1;
    // JmsTemplate only
    private boolean useVersion102 = false;
    private boolean explicitQosEnabled = false;
    private boolean deliveryPersistent = true;
    private long timeToLive = -1;
    private MessageConverter messageConverter;
    private boolean messageIdEnabled = true;
    private boolean messageTimestampEnabled = true;
    private int priority = -1;
    // Transaction related configuration
    private boolean transacted;
    private PlatformTransactionManager transactionManager;
    private String transactionName;
    private int transactionTimeout = -1;
    public JmsConfiguration() {
    }
    public JmsConfiguration(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    /**
     * Returns a copy of this configuration
     */
    public JmsConfiguration copy() {
        try {
            return (JmsConfiguration) clone();
        }
        catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public JmsOperations createJmsOperations(boolean pubSubDomain, String destination) {
        ConnectionFactory factory = getTemplateConnectionFactory();
        JmsTemplate template = useVersion102
                ? new JmsTemplate102(factory, pubSubDomain)
                : new JmsTemplate(factory);
        template.setPubSubDomain(pubSubDomain);
        template.setDefaultDestinationName(destination);
        template.setExplicitQosEnabled(explicitQosEnabled);
        template.setDeliveryPersistent(deliveryPersistent);
        if (messageConverter != null) {
            template.setMessageConverter(messageConverter);
        }
        template.setMessageIdEnabled(messageIdEnabled);
        template.setMessageTimestampEnabled(messageTimestampEnabled);
        if (priority >= 0) {
            template.setPriority(priority);
        }
        template.setPubSubNoLocal(pubSubNoLocal);
        if (receiveTimeout >= 0) {
            template.setReceiveTimeout(receiveTimeout);
        }
        if (timeToLive >= 0) {
            template.setTimeToLive(timeToLive);
        }
        template.setSessionTransacted(transacted);
        // This is here for completeness, but the template should not get used for receiving messages.
        if (acknowledgementMode >= 0) {
            template.setSessionAcknowledgeMode(acknowledgementMode);
        }
        else if (acknowledgementModeName != null) {
            template.setSessionAcknowledgeModeName(acknowledgementModeName);
        }
        return template;
    }
    public AbstractMessageListenerContainer createMessageListenerContainer() {
        AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation();
        configureMessageListenerContainer(container);
        return container;
    }
    protected void configureMessageListenerContainer(AbstractMessageListenerContainer container) {
        container.setConnectionFactory(getListenerConnectionFactory());
        if (autoStartup) {
            container.setAutoStartup(true);
        }
        if (clientId != null) {
            container.setClientId(clientId);
        }
        container.setSubscriptionDurable(subscriptionDurable);
        if (durableSubscriptionName != null) {
            container.setDurableSubscriptionName(durableSubscriptionName);
        }
        // lets default to durable subscription if the subscriber name and client ID are specified (as there's
        // no reason to specify them if not! :)
        if (durableSubscriptionName != null && clientId != null) {
            container.setSubscriptionDurable(true);
        }
        if (exceptionListener != null) {
            container.setExceptionListener(exceptionListener);
        }
        container.setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
        container.setExposeListenerSession(exposeListenerSession);
        container.setSessionTransacted(transacted);
        if (acknowledgementMode >= 0) {
            container.setSessionAcknowledgeMode(acknowledgementMode);
        }
        else if (acknowledgementModeName != null) {
            container.setSessionAcknowledgeModeName(acknowledgementModeName);
        }
        if (container instanceof DefaultMessageListenerContainer) {
            // this includes DefaultMessageListenerContainer102
            DefaultMessageListenerContainer listenerContainer = (DefaultMessageListenerContainer) container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            if (cacheLevel >= 0) {
                listenerContainer.setCacheLevel(cacheLevel);
            }
            else if (cacheLevelName != null) {
                listenerContainer.setCacheLevelName(cacheLevelName);
            }
            else {
                // Default to CACHE_CONSUMER unless specified.  This works best with most JMS providers.
                listenerContainer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);
            }
            if (idleTaskExecutionLimit >= 0) {
                listenerContainer.setIdleTaskExecutionLimit(idleTaskExecutionLimit);
            }
            if (maxConcurrentConsumers >= 0) {
                listenerContainer.setMaxConcurrentConsumers(maxConcurrentConsumers);
            }
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (receiveTimeout >= 0) {
                listenerContainer.setReceiveTimeout(receiveTimeout);
            }
            if (recoveryInterval >= 0) {
                listenerContainer.setRecoveryInterval(recoveryInterval);
            }
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
            if (transactionManager != null) {
                listenerContainer.setTransactionManager(transactionManager);
            }
            if (transactionName != null) {
                listenerContainer.setTransactionName(transactionName);
            }
            if (transactionTimeout >= 0) {
                listenerContainer.setTransactionTimeout(transactionTimeout);
            }
        }
        else if (container instanceof ServerSessionMessageListenerContainer) {
            // this includes ServerSessionMessageListenerContainer102
            ServerSessionMessageListenerContainer listenerContainer = (ServerSessionMessageListenerContainer) container;
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            if (serverSessionFactory != null) {
                listenerContainer.setServerSessionFactory(serverSessionFactory);
            }
        }
        else if (container instanceof SimpleMessageListenerContainer) {
            // this includes SimpleMessageListenerContainer102
            SimpleMessageListenerContainer listenerContainer = (SimpleMessageListenerContainer) container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public ConnectionFactory getConnectionFactory() {
        if (connectionFactory == null) {
            connectionFactory = createConnectionFactory();
        }
        return connectionFactory;
    }
    /**
     * Sets the default connection factory to be used if a connection factory is not specified
     * for either {@link #setTemplateConnectionFactory(ConnectionFactory)} or
     * {@link #setListenerConnectionFactory(ConnectionFactory)}
     *
     * @param connectionFactory the default connection factory to use
     */
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    public ConnectionFactory getListenerConnectionFactory() {
        if (listenerConnectionFactory == null) {
            listenerConnectionFactory = createListenerConnectionFactory();
        }
        return listenerConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for consuming messages via the {@link #createMessageListenerContainer()}
     *
     * @param listenerConnectionFactory the connection factory to use for consuming messages
     */
    public void setListenerConnectionFactory(ConnectionFactory listenerConnectionFactory) {
        this.listenerConnectionFactory = listenerConnectionFactory;
    }
    public ConnectionFactory getTemplateConnectionFactory() {
        if (templateConnectionFactory == null) {
            templateConnectionFactory = createTemplateConnectionFactory();
        }
        return templateConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for sending messages via the {@link JmsTemplate} via
     * {@link #createJmsOperations(boolean, String)}
     *
     * @param templateConnectionFactory the connection factory for sending messages
     */
    public void setTemplateConnectionFactory(ConnectionFactory templateConnectionFactory) {
        this.templateConnectionFactory = templateConnectionFactory;
    }
    public boolean isUseVersion102() {
        return useVersion102;
    }
    public void setUseVersion102(boolean useVersion102) {
        this.useVersion102 = useVersion102;
    }
    public boolean isAutoStartup() {
        return autoStartup;
    }
    public void setAutoStartup(boolean autoStartup) {
        this.autoStartup = autoStartup;
    }
    public boolean isAcceptMessagesWhileStopping() {
        return acceptMessagesWhileStopping;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;
    }
    public String getClientId() {
        return clientId;
    }
    public void setClientId(String consumerClientId) {
        this.clientId = consumerClientId;
    }
    public String getDurableSubscriptionName() {
        return durableSubscriptionName;
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        this.durableSubscriptionName = durableSubscriptionName;
    }
    public ExceptionListener getExceptionListener() {
        return exceptionListener;
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        this.exceptionListener = exceptionListener;
    }
    public boolean isSubscriptionDurable() {
        return subscriptionDurable;
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        this.subscriptionDurable = subscriptionDurable;
    }
    public String getAcknowledgementModeName() {
        return acknowledgementModeName;
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        this.acknowledgementModeName = consumerAcknowledgementMode;
        this.acknowledgementMode = -1;
    }
    public boolean isExposeListenerSession() {
        return exposeListenerSession;
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        this.exposeListenerSession = exposeListenerSession;
    }
    public TaskExecutor getTaskExecutor() {
        return taskExecutor;
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }
    public boolean isPubSubNoLocal() {
        return pubSubNoLocal;
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        this.pubSubNoLocal = pubSubNoLocal;
    }
    public int getConcurrentConsumers() {
        return concurrentConsumers;
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        this.concurrentConsumers = concurrentConsumers;
    }
    public int getMaxMessagesPerTask() {
        return maxMessagesPerTask;
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        this.maxMessagesPerTask = maxMessagesPerTask;
    }
    public ServerSessionFactory getServerSessionFactory() {
        return serverSessionFactory;
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        this.serverSessionFactory = serverSessionFactory;
    }
    public int getCacheLevel() {
        return cacheLevel;
    }
    public void setCacheLevel(int cacheLevel) {
        this.cacheLevel = cacheLevel;
    }
    public String getCacheLevelName() {
        return cacheLevelName;
    }
    public void setCacheLevelName(String cacheName) {
        this.cacheLevelName = cacheName;
    }
    public long getRecoveryInterval() {
        return recoveryInterval;
    }
    public void setRecoveryInterval(long recoveryInterval) {
        this.recoveryInterval = recoveryInterval;
    }
    public long getReceiveTimeout() {
        return receiveTimeout;
    }
    public void setReceiveTimeout(long receiveTimeout) {
        this.receiveTimeout = receiveTimeout;
    }
    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    public String getTransactionName() {
        return transactionName;
    }
    public void setTransactionName(String transactionName) {
        this.transactionName = transactionName;
    }
    public int getTransactionTimeout() {
        return transactionTimeout;
    }
    public void setTransactionTimeout(int transactionTimeout) {
        this.transactionTimeout = transactionTimeout;
    }
    public int getIdleTaskExecutionLimit() {
        return idleTaskExecutionLimit;
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        this.idleTaskExecutionLimit = idleTaskExecutionLimit;
    }
    public int getMaxConcurrentConsumers() {
        return maxConcurrentConsumers;
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        this.maxConcurrentConsumers = maxConcurrentConsumers;
    }
    public boolean isExplicitQosEnabled() {
        return explicitQosEnabled;
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        this.explicitQosEnabled = explicitQosEnabled;
    }
    public boolean isDeliveryPersistent() {
        return deliveryPersistent;
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        this.deliveryPersistent = deliveryPersistent;
    }
    public long getTimeToLive() {
        return timeToLive;
    }
    public void setTimeToLive(long timeToLive) {
        this.timeToLive = timeToLive;
    }
    public MessageConverter getMessageConverter() {
        return messageConverter;
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        this.messageConverter = messageConverter;
    }
    public boolean isMessageIdEnabled() {
        return messageIdEnabled;
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        this.messageIdEnabled = messageIdEnabled;
    }
    public boolean isMessageTimestampEnabled() {
        return messageTimestampEnabled;
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        this.messageTimestampEnabled = messageTimestampEnabled;
    }
    public int getPriority() {
        return priority;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public ConsumerType getConsumerType() {
        return consumerType;
    }
    public void setConsumerType(ConsumerType consumerType) {
        this.consumerType = consumerType;
    }
    public int getAcknowledgementMode() {
        return acknowledgementMode;
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        this.acknowledgementMode = consumerAcknowledgementMode;
        this.acknowledgementModeName = null;
    }
    public boolean isTransacted() {
        return transacted;
    }
    public void setTransacted(boolean consumerTransacted) {
        this.transacted = consumerTransacted;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected AbstractMessageListenerContainer chooseMessageListenerContainerImplementation() {
        // TODO we could allow a spring container to auto-inject these objects?
        switch (consumerType) {
            case Simple:
                return isUseVersion102() ? new SimpleMessageListenerContainer102() : new SimpleMessageListenerContainer();
            case ServerSessionPool:
                return isUseVersion102() ? new ServerSessionMessageListenerContainer102() : new ServerSessionMessageListenerContainer();
            case Default:
                return isUseVersion102() ? new DefaultMessageListenerContainer102() : new DefaultMessageListenerContainer();
            default:
                throw new IllegalArgumentException(""Unknown consumer type: "" + consumerType);
        }
    }
    /**
     * Factory method which allows derived classes to customize the lazy creation
     */
    protected ConnectionFactory createConnectionFactory() {
        ObjectHelper.notNull(connectionFactory, ""connectionFactory"");
        return null;
    }
    /**
     * Factory method which allows derived classes to customize the lazy creation
     */
    protected ConnectionFactory createListenerConnectionFactory() {
        return getConnectionFactory();
    }
    /**
     * Factory method which allows derived classes to customize the lazy creation
     */
    protected ConnectionFactory createTemplateConnectionFactory() {
        return getConnectionFactory();
    }
}
"
org.apache.camel.spring.xml.CamelNamespaceHandler,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import org.apache.camel.spring.CamelContextFactoryBean;
import org.apache.camel.spring.EndpointFactoryBean;
import org.apache.camel.spring.CamelBeanPostProcessor;
import static org.apache.camel.util.ObjectHelper.isNotNullOrBlank;
import org.apache.camel.builder.xml.XPathBuilder;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.parsing.BeanComponentDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.util.Set;
import java.util.HashSet;
public class CamelNamespaceHandler extends NamespaceHandlerSupport {
    protected CamelBeanDefinitionParser routesParser = new CamelBeanDefinitionParser(this);
    protected BeanDefinitionParser endpointParser = new BeanDefinitionParser(EndpointFactoryBean.class);
    protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser(CamelBeanPostProcessor.class);
    protected Set<String> parserElementNames = new HashSet<String>();
    public void init() {
        registerParser(""routes"", routesParser);
        registerParser(""routeBuilder"", routesParser);
        registerParser(""endpoint"", endpointParser);
        registerParser(""camelContext"", new BeanDefinitionParser(CamelContextFactoryBean.class) {
            @Override
            protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
                super.doParse(element, parserContext, builder);
                String contextId = element.getAttribute(""id"");
                Element routes = element.getOwnerDocument().createElement(""routes"");
                // now lets move all the content there...
                NodeList list = element.getChildNodes();
                for (int size = list.getLength(), i = 0; i < size; i++) {
                    Node child = list.item(i);
                    if (child instanceof Element) {
                        Element childElement = (Element) child;
                        if (child.getLocalName().equals(""beanPostProcessor"")) {
                            String beanPostProcessorId = contextId + "":beanPostProcessor"";
                            childElement.setAttribute(""id"", beanPostProcessorId);
                            BeanDefinition definition = beanPostProcessorParser.parse(childElement, parserContext);
                            definition.getPropertyValues().addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
                        }
                        else {
                            element.removeChild(child);
                            routes.appendChild(child);
                        }
                    }
                }
                String routeId = contextId + "":routes"";
                routes.setAttribute(""id"", routeId);
                BeanDefinition definition = routesParser.parse(routes, parserContext);
                definition.getPropertyValues().addPropertyValue(""context"", new RuntimeBeanReference(contextId));
                parserContext.registerComponent(new BeanComponentDefinition(definition, routeId));
                list = routes.getElementsByTagName(""endpoint"");
                for (int size = list.getLength(), i = 0; i < size; i++) {
                    Element node = (Element) list.item(i);
                    definition = endpointParser.parse(node, parserContext);
                    String id = node.getAttribute(""id"");
                    if (isNotNullOrBlank(id)) {
                        definition.getPropertyValues().addPropertyValue(""context"", new RuntimeBeanReference(contextId));
                        //definition.getPropertyValues().addPropertyValue(""context"", builder.getBeanDefinition());
                        parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                    }
                }
            }
        });
        registerParser(""xpath"", new BeanDefinitionParser(XPathBuilder.class) {
            @Override
            protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
                // lets create a child context
                String xpath = DomUtils.getTextValue(element);
                builder.addConstructorArg(xpath);
                super.doParse(element, parserContext, builder);
                builder.addPropertyValue(""namespacesFromDom"", element);
            }
        });
        // scripting expressions
        registerScriptParser(""script"", null);
        registerScriptParser(""groovy"", ""groovy"");
        registerScriptParser(""ruby"", ""jruby"");
        registerScriptParser(""javaScript"", ""js"");
        registerScriptParser(""python"", ""python"");
        registerScriptParser(""php"", ""php"");
    }
    protected void registerScriptParser(String elementName, String engineName) {
        registerParser(elementName, new ScriptDefinitionParser(engineName));
    }
    protected void registerParser(String name, org.springframework.beans.factory.xml.BeanDefinitionParser parser) {
        parserElementNames.add(name);
        registerBeanDefinitionParser(name, parser);
    }
    public Set<String> getParserElementNames() {
        return parserElementNames;
    }
}
"
org.apache.camel.spring.SpringRouteBuilder,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.context.ApplicationContext;
/**
 * An extension of the {@link RouteBuilder} to provide some additional helper methods
 *
 * @version $Revision: 1.1 $
 */
public abstract class SpringRouteBuilder extends RouteBuilder {
    private ApplicationContext applicationContext;
    /**
     * Looks up the bean with the given name in the application context and returns it, or throws an exception if the
     * bean is not present or is not of the given type
     *
     * @param type     the type of the bean
     * @param beanName the name of the bean in the application context
     * @return the bean
     */
    public <T> T bean(Class<T> type, String beanName) {
        ApplicationContext context = getApplicationContext();
        return (T) context.getBean(beanName, type);
    }
    /**
     * Looks up the bean with the given type in the application context and returns it, or throws an exception if the
     * bean is not present or there are multiple possible beans to choose from for the given type
     *
     * @param type the type of the bean
     * @return the bean
     */
    public <T> T bean(Class<T> type) {
        ApplicationContext context = getApplicationContext();
        String[] names = context.getBeanNamesForType(type, true, true);
        if (names != null) {
            int count = names.length;
            if (count == 1) {
                // lets instantiate the single bean
                return (T) context.getBean(names[0]);
            }
            else if (count > 1) {
                throw new IllegalArgumentException(""Too many beans in the application context of type: "" + type + "". Found: "" + count);
            }
        }
        throw new IllegalArgumentException(""No bean available in the application context of type: "" + type);
    }
    /**
     * Returns the application context which has been configured via the {@link #setApplicationContext(ApplicationContext)}
     * method  or from the underlying {@link SpringCamelContext}
     * 
     * @return
     */
    public ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            CamelContext camelContext = getContext();
            if (camelContext instanceof SpringCamelContext) {
                SpringCamelContext springCamelContext = (SpringCamelContext) camelContext;
                return springCamelContext.getApplicationContext();
            }
            else {
                throw new IllegalArgumentException(""This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured"");
            }
        }
        return applicationContext;
    }
    /**
     * Sets the application context to use to lookup beans
     */
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
}
"
org.apache.camel.component.mina.MinaProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.Producer;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.ConnectFuture;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
import java.net.SocketAddress;
/**
 * A {@link Producer} implementation for MINA
 *
 * @version $Revision$
 */
public class MinaProducer extends DefaultProducer {
    private static final transient Log log = LogFactory.getLog(MinaProducer.class);
    private IoSession session;
    private MinaEndpoint endpoint;
    public MinaProducer(MinaEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) {
        if (session == null) {
            throw new IllegalStateException(""Not started yet!"");
        }
        Object body = exchange.getIn().getBody();
        if (body == null) {
            log.warn(""No payload for exchange: "" + exchange);
        }
        else {
            session.write(body);
        }
    }
    @Override
    protected void doStart() throws Exception {
        SocketAddress address = endpoint.getAddress();
        IoConnector connector = endpoint.getConnector();
        if (log.isDebugEnabled()) {
            log.debug(""Creating connector to address: "" + address + "" using connector: "" + connector);
        }
        IoHandler ioHandler = new IoHandlerAdapter() {
            @Override
            public void messageReceived(IoSession ioSession, Object object) throws Exception {
                super.messageReceived(ioSession, object);    /** TODO */
            }
        };
        ConnectFuture future = connector.connect(address, ioHandler, endpoint.getConfig());
        future.join();
        session = future.getSession();
    }
    @Override
    protected void doStop() throws Exception {
        if (session != null) {
            session.close().join(2000);
        }
    }
}
"
org.apache.camel.spring.xml.BuilderAction,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import org.springframework.beans.SimpleTypeConverter;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class BuilderAction {
    private final MethodInfo methodInfo;
    private final HashMap<String, Object> parameterValues;
    public BuilderAction(MethodInfo methodInfo, HashMap<String, Object> parameterValues) {
        this.methodInfo = methodInfo;
        this.parameterValues = parameterValues;
    }
    public Object invoke(BeanFactory beanFactory, Object rootBuilder, Object contextBuilder) {
        SimpleTypeConverter converter = new SimpleTypeConverter();
        Object args[] = new Object[methodInfo.parameters.size()];
        int pos = 0;
        for (Map.Entry<String, Class> entry : methodInfo.parameters.entrySet()) {
            String paramName = entry.getKey();
            Class paramClass = entry.getValue();
            Object value = parameterValues.get(paramName);
            if (value != null) {
                value = replaceBeanReferences(beanFactory, rootBuilder, value);
                args[pos] = converter.convertIfNecessary(value, paramClass);
            }
        }
        try {
            return methodInfo.method.invoke(contextBuilder, args);
        }
        catch (InvocationTargetException e) {
            throw new IllegalArgumentException(e.getCause());
        }
        catch (RuntimeException e) {
            throw e;
        }
        catch (Throwable e) {
            throw new IllegalArgumentException(e);
        }
    }
    protected Object replaceBeanReferences(BeanFactory beanFactory, Object rootBuilder, Object value) {
        // TODO why not using instanceof??
        if (value.getClass() == RuntimeBeanReference.class) {
            String beanName = ((RuntimeBeanReference) value).getBeanName();
            value = beanFactory.getBean(beanName);
        }
        if (value.getClass() == BuilderStatement.class) {
            BuilderStatement bs = (BuilderStatement) value;
            value = bs.create(beanFactory, rootBuilder);
        }
        if (value instanceof List) {
            List list = (List) value;
            for (int i = 0, size = list.size(); i < size; i++) {
                list.set(i, replaceBeanReferences(beanFactory, rootBuilder, list.get(i)));
            }
        }
        return value;
    }
    public String getName() {
        return methodInfo.getName();
    }
    public MethodInfo getMethodInfo() {
        return methodInfo;
    }
}
"
org.apache.camel.spring.spi.SpringComponentResolver,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.spi.ComponentResolver;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.context.ApplicationContext;
/**
 * An implementation of {@link ComponentResolver} which tries to find a Camel {@link Component}
 * in the Spring {@link ApplicationContext} first; if its not there it defaults to the auto-discovery mechanism.
 *
 * @version $Revision$
 */
public class SpringComponentResolver implements ComponentResolver {
    private final ApplicationContext applicationContext;
    private final ComponentResolver nextResolver;
    public SpringComponentResolver(ApplicationContext applicationContext, ComponentResolver nextResolver) {
        notNull(applicationContext, ""applicationContext"");
        this.applicationContext = applicationContext;
        this.nextResolver = nextResolver;
    }
    public Component resolveComponent(String name, CamelContext context) throws Exception {
        Object bean = null;
        try {
            bean = applicationContext.getBean(name);
        }
        catch (NoSuchBeanDefinitionException e) {
            // ignore its not an error
        }
        if (bean != null) {
            if (bean instanceof Component) {
                return (Component) bean;
            }
            else {
                throw new IllegalArgumentException(""Bean with name: "" + name + "" in spring context is not a Component: "" + bean);
            }
        }
        if (nextResolver == null) {
            return null;
        }
        return nextResolver.resolveComponent(name, context);
    }
}
"
org.apache.camel.component.cxf.CxfConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.transport.local.LocalTransportFactory;
/**
 * A consumer of exchanges for a service in CXF
 *
 * @version $Revision$
 */
public class CxfConsumer extends DefaultConsumer<CxfExchange> {
    private CxfEndpoint endpoint;
    private final LocalTransportFactory transportFactory;
    private Destination destination;
    public CxfConsumer(CxfEndpoint endpoint, Processor processor, LocalTransportFactory transportFactory) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.transportFactory = transportFactory;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        destination = transportFactory.getDestination(endpoint.getEndpointInfo());
        destination.setMessageObserver(new MessageObserver() {
            public void onMessage(Message message) {
                incomingCxfMessage(message);
            }
        });
    }
    @Override
    protected void doStop() throws Exception {
        if (destination != null) {
            destination.shutdown();
        }
        super.doStop();
    }
    protected void incomingCxfMessage(Message message) {
        try {
            CxfExchange exchange = endpoint.createExchange(message);
			getProcessor().process(exchange);
		} catch (Exception e) {			
			// TODO: what do do if we are getting processing errors from camel?  Shutdown?
			e.printStackTrace();
		}
    }
}
"
org.apache.camel.bam.processor.ProcessContext,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.ProcessRules;
/**
 * @version $Revision: 1.1 $
 */
public class ProcessContext {
    private Exchange exchange;
    private ProcessRules processRules;
    private ActivityRules activityRules;
    private ProcessInstance processInstance;
    private ActivityState activityState;
    public ProcessContext(Exchange exchange, ActivityRules activityRules, ActivityState activityState) {
        this.exchange = exchange;
        this.activityRules = activityRules;
        this.activityState = activityState;
        this.processRules = activityRules.getProcessRules();
        this.processInstance = activityState.getProcessInstance();
    }
    public ActivityRules getActivity() {
        return activityRules;
    }
    public void setActivity(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public ActivityState getActivityState() {
        return activityState;
    }
    public void setActivityState(ActivityState activityState) {
        this.activityState = activityState;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    public ProcessRules getProcessDefinition() {
        return processRules;
    }
    public void setProcessDefinition(ProcessRules processRules) {
        this.processRules = processRules;
    }
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
    }
    public ActivityState getActivityState(ActivityRules activityRules) {
        return getProcessInstance().getActivityState(activityRules);
    }
    /**
     * Called when the activity is started which may end up creating some timers
     * for dependent actions
     */
    public void onStarted(ActivityState activityState) {
        /** TODO */
    }
    /**
     * Called when the activity is completed which may end up creating some timers
     * for dependent actions
     */
    public void onCompleted(ActivityState activityState) {
        /** TODO */
    }
}
"
org.apache.camel.component.jms.RuntimeJmsException,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class RuntimeJmsException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeJmsException(String message, JMSException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.jms.JmsExchange,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;
import javax.jms.Message;
/**
 * Represents an {@ilnk Exchange} for working with JMS messages while exposing the inbound and outbound JMS {@link Message}
 * objects via {@link #getInMessage()} and {@link #getOutMessage()} 
 *
 * @version $Revision:520964 $
 */
public class JmsExchange extends DefaultExchange {
    private JmsBinding binding;
    public JmsExchange(CamelContext context, JmsBinding binding) {
        super(context);
        this.binding = binding;
    }
    public JmsExchange(CamelContext context, JmsBinding binding, Message message) {
        this(context, binding);
        setIn(new JmsMessage(message));
    }
    @Override
    public JmsMessage getIn() {
        return (JmsMessage) super.getIn();
    }
    @Override
    public JmsMessage getOut() {
        return (JmsMessage) super.getOut();
    }
    @Override
    public JmsMessage getOut(boolean lazyCreate) {
        return (JmsMessage) super.getOut(lazyCreate);
    }
    @Override
    public JmsMessage getFault() {
        return (JmsMessage) super.getFault();
    }
    public JmsBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new JmsExchange(getContext(), binding);
    }
    // Expose JMS APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying JMS In message
     *
     * @return the JMS In message
     */
    public Message getInMessage() {
        return getIn().getJmsMessage();
    }
    /**
     * Return the underlying JMS Out message
     *
     * @return the JMS out message
     */
    public Message getOutMessage() {
        return getOut().getJmsMessage();
    }
    /**
     * Return the underlying JMS Fault message
     *
     * @return the JMS fault message
     */
    public Message getFaultMessage() {
        return getOut().getJmsMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected JmsMessage createInMessage() {
        return new JmsMessage();
    }
    @Override
    protected JmsMessage createOutMessage() {
        return new JmsMessage();
    }
}
"
org.apache.camel.component.cxf.transport.CamelTransportBase,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.CamelTemplate;
import org.apache.cxf.Bus;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
/**
 * @version $Revision$
 */
public class CamelTransportBase {
    private String replyDestination;
    CamelTemplate<Exchange> template;
    private final CamelContext camelContext;
    Bus bus;
    EndpointInfo endpointInfo;
    public CamelTransportBase(CamelContext camelContext, Bus bus, EndpointInfo endpointInfo, boolean b, String baseBeanNameSuffix) {
        this.camelContext = camelContext;
        this.bus = bus;
        this.endpointInfo = endpointInfo;
        this.template = new CamelTemplate<Exchange>(camelContext);
    }
    public void populateIncomingContext(Exchange exchange, MessageImpl inMessage, String camelServerRequestHeaders) {
    }
    public String getReplyDestination() {
        return replyDestination;
    }
    public void setMessageProperties(Message inMessage, Exchange reply) {
    }
    public void close() {
        if (template != null) {
            try {
                template.stop();
            }
            catch (Exception e) {
                // do nothing?
                // TODO
            }
        }
    }
    /**
     * Populates a Camel exchange with a payload
     *
     * @param payload  the message payload, expected to be either of type
     *                 String or byte[] depending on payload type
     * @param replyTo  the ReplyTo destination if any
     * @param exchange the underlying exchange to marshal to
     */
    protected void marshal(Object payload, String replyTo, Exchange exchange) {
        org.apache.camel.Message message = exchange.getIn();
        message.setBody(payload);
        if (replyTo != null) {
            message.setHeader(CamelConstants.CAMEL_CORRELATION_ID, replyTo);
        }
    }
    /**
     * Unmarshal the payload of an incoming message.
     */
    public byte[] unmarshal(Exchange exchange) {
        return exchange.getIn().getBody(byte[].class);
    }
    /*
    protected CamelMessageHeadersType populateIncomingContext(javax.camel.Message message,
                                                            org.apache.cxf.message.Message inMessage,
                                                     String headerType)  throws CamelException {
        CamelMessageHeadersType headers = null;
        headers = (CamelMessageHeadersType)inMessage.get(headerType);
        if (headers == null) {
            headers = new CamelMessageHeadersType();
            inMessage.put(headerType, headers);
        }
        headers.setCamelCorrelationID(message.getCamelCorrelationID());
        headers.setCamelDeliveryMode(new Integer(message.getCamelDeliveryMode()));
        headers.setCamelExpiration(new Long(message.getCamelExpiration()));
        headers.setCamelMessageID(message.getCamelMessageID());
        headers.setCamelPriority(new Integer(message.getCamelPriority()));
        headers.setCamelRedelivered(Boolean.valueOf(message.getCamelRedelivered()));
        headers.setCamelTimeStamp(new Long(message.getCamelTimestamp()));
        headers.setCamelType(message.getCamelType());
        List<CamelPropertyType> props = headers.getProperty();
        Enumeration enm = message.getPropertyNames();
        while (enm.hasMoreElements()) {
            String name = (String)enm.nextElement();
            String val = message.getStringProperty(name);
            CamelPropertyType prop = new CamelPropertyType();
            prop.setName(name);
            prop.setValue(val);
            props.add(prop);
        }
        return headers;
    }
    protected int getCamelDeliveryMode(CamelMessageHeadersType headers) {
        int deliveryMode = Message.DEFAULT_DELIVERY_MODE;
        if (headers != null && headers.isSetCamelDeliveryMode()) {
            deliveryMode = headers.getCamelDeliveryMode();
        }
        return deliveryMode;
    }
    protected int getCamelPriority(CamelMessageHeadersType headers) {
        int priority = Message.DEFAULT_PRIORITY;
        if (headers != null && headers.isSetCamelPriority()) {
            priority = headers.getCamelPriority();
        }
        return priority;
    }
    protected long getTimeToLive(CamelMessageHeadersType headers) {
        long ttl = -1;
        if (headers != null && headers.isSetTimeToLive()) {
            ttl = headers.getTimeToLive();
        }
        return ttl;
    }
    protected String getCorrelationId(CamelMessageHeadersType headers) {
        String correlationId  = null;
        if (headers != null
            && headers.isSetCamelCorrelationID()) {
            correlationId = headers.getCamelCorrelationID();
        }
        return correlationId;
    }
    protected String getAddrUriFromCamelAddrPolicy() {
        AddressType camelAddressPolicy = transport.getCamelAddress();
        return ""camel:"" + camelAddressPolicy.getJndiConnectionFactoryName()
                        + ""#""
                        + camelAddressPolicy.getJndiDestinationName();
    }
    protected String getReplyTotAddrUriFromCamelAddrPolicy() {
        AddressType camelAddressPolicy = transport.getCamelAddress();
        return ""camel:""
                        + camelAddressPolicy.getJndiConnectionFactoryName()
                        + ""#""
                        + camelAddressPolicy.getJndiReplyDestinationName();
    }
    protected boolean isDestinationStyleQueue() {
        return CamelConstants.CAMEL_QUEUE.equals(
            transport.getCamelAddress().getDestinationStyle().value());
    }
    */
}
"
org.apache.camel.spring.Main,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.impl.ServiceSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
/**
 * A command line tool for booting up a CamelContext using an
 * optional Spring ApplicationContext
 *
 * @version $Revision: $
 */
public class Main extends ServiceSupport {
    private static final Log log = LogFactory.getLog(Main.class);
    private String applicationContextUri = ""META-INF/spring/*.xml"";
    private AbstractApplicationContext applicationContext;
    private List<Option> options = new ArrayList<Option>();
    private CountDownLatch latch = new CountDownLatch(1);
    private AtomicBoolean completed = new AtomicBoolean(false);
    public static void main(String[] args) {
        Main main = new Main();
        main.parseArguments(args);
        main.run();
    }
    public Main() {
        addOption(new Option(""h"", ""help"", ""Displays the help screen"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                showOptions();
                completed();
            }
        });
        addOption(new ParameterOption(""a"", ""applicationContext"", ""Sets the classpath based pring ApplicationContext"", ""applicationContext"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setApplicationContextUri(parameter);
            }
        });
    }
    /**
     * Runs this process with the given arguments
     */
    public void run() {
        if (!completed.get()) {
            try {
                start();
                waitUntilCompleted();
                stop();
            }
            catch (Exception e) {
                log.error(""Failed: "" + e, e);
            }
        }
    }
    /**
     * Marks this process as being completed
     */
    public void completed() {
        completed.set(true);
        latch.countDown();
    }
    /**
     * Displays the command line options
     */
    public void showOptions() {
        System.out.println(""Apache Camel Runner takes the following options"");
        System.out.println();
        for (Option option : options) {
            System.out.println(""  "" + option.getAbbreviation() + "" or "" + option.getFullName()
                    + "" = "" + option.getDescription());
        }
    }
    /**
     * Parses the commandl ine arguments
     */
    public void parseArguments(String[] arguments) {
        LinkedList<String> args = new LinkedList<String>(Arrays.asList(arguments));
        boolean valid = true;
        while (!args.isEmpty()) {
            String arg = args.removeFirst();
            boolean handled = false;
            for (Option option : options) {
                if (option.processOption(arg, args)) {
                    handled = true;
                    break;
                }
            }
            if (!handled) {
                System.out.println(""Unknown option: "" + arg);
                System.out.println();
                valid = false;
                break;
            }
        }
        if (!valid) {
            showOptions();
            completed();
        }
    }
    public void addOption(Option option) {
        options.add(option);
    }
    public abstract class Option {
        private String abbreviation;
        private String fullName;
        private String description;
        protected Option(String abbreviation, String fullName, String description) {
            this.abbreviation = ""-"" + abbreviation;
            this.fullName = ""-"" + fullName;
            this.description = description;
        }
        public boolean processOption(String arg, LinkedList<String> remainingArgs) {
            if (arg.equalsIgnoreCase(abbreviation) || fullName.startsWith(arg)) {
                doProcess(arg, remainingArgs);
                return true;
            }
            return false;
        }
        public String getAbbreviation() {
            return abbreviation;
        }
        public String getDescription() {
            return description;
        }
        public String getFullName() {
            return fullName;
        }
        protected abstract void doProcess(String arg, LinkedList<String> remainingArgs);
    }
    public abstract class ParameterOption extends Option {
        private String parameterName;
        protected ParameterOption(String abbreviation, String fullName, String description, String parameterName) {
            super(abbreviation, fullName, description);
            this.parameterName = parameterName;
        }
        protected void doProcess(String arg, LinkedList<String> remainingArgs) {
            if (remainingArgs.isEmpty()) {
                System.err.println(""Expected fileName for "");
                showOptions();
                completed();
            }
            else {
                String parameter = remainingArgs.removeFirst();
                doProcess(arg, parameter, remainingArgs);
            }
        }
        protected abstract void doProcess(String arg, String parameter, LinkedList<String> remainingArgs);
    }
    // Properties
    //-------------------------------------------------------------------------
    public AbstractApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(AbstractApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String getApplicationContextUri() {
        return applicationContextUri;
    }
    public void setApplicationContextUri(String applicationContextUri) {
        this.applicationContextUri = applicationContextUri;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        log.info(""Apache Camel "" + getVersion() + "" starting"");
        if (applicationContext == null) {
            applicationContext = createDefaultApplicationContext();
        }
        applicationContext.start();
    }
    protected AbstractApplicationContext createDefaultApplicationContext() {
        return new ClassPathXmlApplicationContext(getApplicationContextUri());
    }
    protected void doStop() throws Exception {
        log.info(""Apache Camel terminating"");
        if (applicationContext != null) {
            applicationContext.close();
        }
    }
    protected void waitUntilCompleted() {
        while (!completed.get()) {
            try {
                latch.await();
            }
            catch (InterruptedException e) {
                // ignore
            }
        }
    }
    protected String getVersion() {
        Package aPackage = Package.getPackage(""org.apache.camel"");
        if (aPackage != null) {
            String version = aPackage.getImplementationVersion();
            if (version == null) {
                version = aPackage.getSpecificationVersion();
                if (version == null) {
                    version = """";
                }
            }
            return version;
        }
        return """";
    }
}
"
org.apache.camel.component.jbi.JbiExchange,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;
import javax.jbi.messaging.MessageExchange;
import javax.jbi.messaging.NormalizedMessage;
/**
 * An {@link Exchange} working with JBI which exposes the underlying JBI features such as the
 * JBI {@link #getMessageExchange()}, {@link #getInMessage()} and {@link #getOutMessage()} 
 *
 * @version $Revision$
 */
public class JbiExchange extends DefaultExchange {
    private final JbiBinding binding;
    private MessageExchange messageExchange;
    public JbiExchange(CamelContext context, JbiBinding binding) {
        super(context);
        this.binding = binding;
    }
    public JbiExchange(CamelContext context, JbiBinding binding, MessageExchange messageExchange) {
        super(context);
        this.binding = binding;
        this.messageExchange = messageExchange;
        // TODO we could maybe use the typesafe APIs of different derived APIs from JBI 
        setIn(new JbiMessage(messageExchange.getMessage(""in"")));
        setOut(new JbiMessage(messageExchange.getMessage(""out"")));
        setFault(new JbiMessage(messageExchange.getMessage(""fault"")));
    }
    @Override
    public JbiMessage getIn() {
        return (JbiMessage) super.getIn();
    }
    @Override
    public JbiMessage getOut() {
        return (JbiMessage) super.getOut();
    }
    @Override
    public JbiMessage getOut(boolean lazyCreate) {
        return (JbiMessage) super.getOut(lazyCreate);
    }
    @Override
    public JbiMessage getFault() {
        return (JbiMessage) super.getFault();
    }
    /**
     * @return the Camel <-> JBI binding
     */
    public JbiBinding getBinding() {
        return binding;
    }
    // Expose JBI features
    //-------------------------------------------------------------------------
    /**
     * Returns the underlying JBI message exchange for an inbound exchange
     * or null for outbound messages
     *
     * @return the inbound message exchange
     */
    public MessageExchange getMessageExchange() {
        return messageExchange;
    }
    /**
     * Returns the underlying In {@link NormalizedMessage}
     *
     * @return the In message
     */
    public NormalizedMessage getInMessage() {
        return getIn().getNormalizedMessage();
    }
    /**
     * Returns the underlying Out {@link NormalizedMessage}
     *
     * @return the Out message
     */
    public NormalizedMessage getOutMessage() {
        return getOut().getNormalizedMessage();
    }
    /**
     * Returns the underlying Fault {@link NormalizedMessage}
     *
     * @return the Fault message
     */
    public NormalizedMessage getFaultMessage() {
        return getFault().getNormalizedMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected JbiMessage createInMessage() {
        return new JbiMessage();
    }
    @Override
    protected JbiMessage createOutMessage() {
        return new JbiMessage();
    }
}
"
org.apache.camel.builder.script.ScriptEvaluationException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if the script evaluation fails
 * 
 * @version $Revision$
 */
public class ScriptEvaluationException extends RuntimeCamelException {
    public ScriptEvaluationException(String message) {
        super(message);
    }
    public ScriptEvaluationException(String message, Throwable cause) {
        super(message, cause);
    }
    public ScriptEvaluationException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.component.http.HttpComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/http.html"">HTTP Component</a>
 *
 * @version $Revision$
 */
public class HttpComponent extends DefaultComponent<HttpExchange> {
	private CamelServlet camelServlet;
	/** 
	 * Connects the URL specified on the endpoint to the specified processor.
	 *  
	 * @throws Exception
	 */
	public void connect(HttpConsumer consumer) throws Exception {
		camelServlet.connect(consumer);
	}
	/**
	 * Disconnects the URL specified on the endpoint from the specified processor.
	 * 
	 * @throws Exception
	 */
	public void disconnect(HttpConsumer consumer) throws Exception {
		camelServlet.disconnect(consumer);
	}
	public CamelServlet getCamelServlet() {
		return camelServlet;
	}
	public void setCamelServlet(CamelServlet camelServlet) {
		this.camelServlet = camelServlet;
	}
	@Override
	protected Endpoint<HttpExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
		return new HttpEndpoint(uri, this);
	}
}
"
org.apache.camel.component.mail.JavaMailConnection,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.springframework.mail.MailAuthenticationException;
import org.springframework.mail.MailException;
import org.springframework.mail.MailSendException;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import javax.mail.AuthenticationFailedException;
import javax.mail.MessagingException;
import javax.mail.Transport;
import javax.mail.Folder;
import javax.mail.Store;
/**
 * An extension of Spring's {@link JavaMailSenderImpl} to provide helper methods for listening for new mail
 *
 * @version $Revision: 1.1 $
 */
public class JavaMailConnection extends JavaMailSenderImpl {
    public Folder getFolder(String protocol, String folderName) {
        try {
            Store store = getSession().getStore(protocol);
            store.connect(getHost(), getPort(), getUsername(), getPassword());
            return store.getFolder(folderName);
        }
        catch (MessagingException e) {
            throw new MailSendException(""Mail server connection failed"", e);
        }
    }
}
"
org.apache.camel.bam.TimeExpression,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.TemporalRule;
import org.apache.camel.util.ObjectHelper;
import java.util.Date;
/**
 * @version $Revision: $
 */
public abstract class TimeExpression {
    private ActivityRules activityRules;
    private ActivityBuilder builder;
    private ActivityLifecycle lifecycle;
    public TimeExpression(ActivityBuilder builder, ActivityLifecycle lifecycle) {
        this.lifecycle = lifecycle;
        this.builder = builder;
        this.activityRules = builder.getActivityRules();
    }
    public boolean isActivityLifecycle(ActivityRules activityRules, ActivityLifecycle lifecycle) {
        return ObjectHelper.equals(activityRules, this.activityRules) && ObjectHelper.equals(lifecycle, this.lifecycle);
    }
    /**
     * Creates a new temporal rule on this expression and the other expression
     */
    public TemporalRule after(TimeExpression expression) {
        TemporalRule rule = new TemporalRule(expression, this);
        rule.getSecond().getActivityRules().addRule(rule);
        return rule;
    }
    public Date evaluate(ProcessInstance processInstance) {
        ActivityState state = processInstance.getActivityState(activityRules);
        if (state != null) {
            return evaluate(processInstance, state);
        }
        return null;
    }
    public abstract Date evaluate(ProcessInstance instance, ActivityState state);
    // Properties
    //-------------------------------------------------------------------------
    public ActivityBuilder getBuilder() {
        return builder;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ActivityLifecycle getLifecycle() {
        return lifecycle;
    }
    public ActivityState getActivityState(ProcessInstance instance) {
        return instance.getActivityState(activityRules);
    }
    public ActivityState getOrCreateActivityState(ProcessInstance instance) {
        return instance.getOrCreateActivityState(activityRules);
    }
}
"
org.apache.camel.component.mail.MailConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.mail.Flags;
import javax.mail.Folder;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Transport;
import javax.mail.event.MessageCountEvent;
import javax.mail.event.MessageCountListener;
/**
 * A {@link Consumer} which consumes messages from JavaMail using a {@link Transport} and dispatches them
 * to the {@link Processor}
 *
 * @version $Revision: 523430 $
 */
public class MailConsumer extends ScheduledPollConsumer<MailExchange> implements MessageCountListener {
    private static final transient Log log = LogFactory.getLog(MailConsumer.class);
    private final MailEndpoint endpoint;
    private final Folder folder;
    public MailConsumer(MailEndpoint endpoint, Processor processor, Folder folder) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.folder = folder;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        ensureFolderIsOpen();
        folder.addMessageCountListener(this);
    }
    @Override
    protected void doStop() throws Exception {
        folder.removeMessageCountListener(this);
        folder.close(true);
        super.doStop();
    }
    public void messagesAdded(MessageCountEvent event) {
        Message[] messages = event.getMessages();
        for (Message message : messages) {
            try {
                if (!message.getFlags().contains(Flags.Flag.DELETED)) {
                    processMessage(message);
                    flagMessageDeleted(message);
                }
            }
            catch (MessagingException e) {
                handleException(e);
            }
        }
    }
    public void messagesRemoved(MessageCountEvent event) {
        Message[] messages = event.getMessages();
        for (Message message : messages) {
            if (log.isDebugEnabled()) {
                try {
                    log.debug(""Removing message: "" + message.getSubject());
                }
                catch (MessagingException e) {
                    log.debug(""Ignored: "" + e);
                }
            }
        }
    }
    protected void poll() throws Exception {
        ensureFolderIsOpen();
        int count = folder.getMessageCount();
        if (count > 0) {
            Message[] messages = folder.getMessages();
            MessageCountEvent event = new MessageCountEvent(folder, MessageCountEvent.ADDED, true, messages);
            messagesAdded(event);
        }
        else if (count == -1) {
            throw new MessagingException(""Folder: "" + folder.getFullName() + "" is closed"");
        }
        folder.close(true);
    }
    protected void processMessage(Message message) {
        try {
            MailExchange exchange = endpoint.createExchange(message);
            getProcessor().process(exchange);
        }
        catch (Throwable e) {
            handleException(e);
        }
    }
    protected void ensureFolderIsOpen() throws MessagingException {
        if (!folder.isOpen()) {
            folder.open(Folder.READ_WRITE);
        }
    }
    protected void flagMessageDeleted(Message message) throws MessagingException {
        if (endpoint.getConfiguration().isDeleteProcessedMessages()) {
            message.setFlag(Flags.Flag.DELETED, true);
        }
        else {
            message.setFlag(Flags.Flag.SEEN, true);
        }
    }
}
"
org.apache.camel.spring.util.MethodInvocationStrategy,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import org.apache.camel.Expression;
/**
 * A strategy for invoking a method on a pojo from a message exchange
 *
 * @version $Revision: $
 */
public interface MethodInvocationStrategy {
    /**
     * Creates an invocation on the given POJO using annotations to decide which method to invoke
     * and to figure out which parameters to use
     */
/*    MethodInvocation createInvocation(Object pojo,
                                      BeanInfo beanInfo,
                                      Exchange messageExchange,
                                      Endpoint pojoEndpoint) throws RuntimeCamelException;*/
    Expression getDefaultParameterTypeExpression(Class parameterType);
}
"
org.apache.camel.component.cxf.CxfInvokeComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.cxf.Bus;
import org.apache.cxf.bus.CXFBusFactory;
import java.net.URI;
import java.util.Map;
import java.util.Properties;
/**
 * @version $Revision$
 */
public class CxfInvokeComponent extends DefaultComponent<CxfExchange> {
    private Bus bus;
    public CxfInvokeComponent() {
        bus = CXFBusFactory.getDefaultBus();
    }
    public CxfInvokeComponent(CamelContext context) {
        super(context);
        bus = CXFBusFactory.getDefaultBus();
    }
    @Override
    protected Endpoint<CxfExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new CxfInvokeEndpoint(getAddress(remaining), this, getQueryAsProperties(new URI(remaining)));
    }
    /**
     * Read query parameters from uri
     *
     * @param u
     * @return parameter value pairs as properties
     */
    protected Properties getQueryAsProperties(URI u) {
        Properties retval = new Properties();
        if (u.getQuery() != null) {
            String[] parameters = u.getQuery().split(""&"");
            for (int i = 0; i < parameters.length; i++) {
                String[] s = parameters[i].split(""="");
                retval.put(s[0], s[1]);
            }
        }
        return retval;
    }
    /**
     * Remove query from uri
     *
     * @param uri
     * @return substring before  the ""?"" character
     */
    protected String getAddress(String uri) {
        int index = uri.indexOf(""?"");
        if (-1 != index) {
            return uri.substring(0, index);
        }
        return uri;
    }
    public Bus getBus() {
        return bus;
    }
}"
org.apache.camel.component.rmi.RmiComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.component.pojo.PojoExchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class RmiComponent extends DefaultComponent<PojoExchange> {
	public RmiComponent() {
	}
	public RmiComponent(CamelContext context) {
		super(context);
	}
	@Override
	protected Endpoint<PojoExchange> createEndpoint(String uri,
			String remaining, Map parameters) throws Exception {
		return new RmiEndpoint(uri, this);
	}
}
"
org.apache.camel.component.jbi.JbiBinding,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.Exchange;
import javax.jbi.messaging.MessageExchange;
import javax.jbi.messaging.MessageExchangeFactory;
import javax.jbi.messaging.MessagingException;
import javax.jbi.messaging.NormalizedMessage;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import java.io.StringReader;
import java.util.Map;
import java.util.Set;
/**
 * The binding of how Camel messages get mapped to JBI and back again
 *
 * @version $Revision$
 */
public class JbiBinding {
    /**
     * Extracts the body from the given normalized message
     */
    public Object extractBodyFromJbi(JbiExchange exchange, NormalizedMessage normalizedMessage) {
        // TODO we may wish to turn this into a POJO such as a JAXB/DOM
        return normalizedMessage.getContent();
    }
    public MessageExchange makeJbiMessageExchange(Exchange camelExchange, MessageExchangeFactory exchangeFactory) throws MessagingException {
        MessageExchange jbiExchange = createJbiMessageExchange(camelExchange, exchangeFactory);
        NormalizedMessage normalizedMessage = jbiExchange.getMessage(""in"");
        if (normalizedMessage == null) {
            normalizedMessage = jbiExchange.createMessage();
            jbiExchange.setMessage(normalizedMessage, ""in"");
        }
        normalizedMessage.setContent(getJbiInContent(camelExchange));
        addJbiHeaders(jbiExchange, normalizedMessage, camelExchange);
        return jbiExchange;
    }
    protected MessageExchange createJbiMessageExchange(Exchange camelExchange, MessageExchangeFactory exchangeFactory) throws MessagingException {
        // TODO we should deal with other forms of MEP
        return exchangeFactory.createInOnlyExchange();
    }
    protected Source getJbiInContent(Exchange camelExchange) {
        // TODO this should be more smart
        Object value = camelExchange.getIn().getBody();
        if (value instanceof String) {
            return new StreamSource(new StringReader(value.toString()));
        }
        return camelExchange.getIn().getBody(Source.class);
    }
    protected void addJbiHeaders(MessageExchange jbiExchange, NormalizedMessage normalizedMessage, Exchange camelExchange) {
        Set<Map.Entry<String, Object>> entries = camelExchange.getIn().getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            normalizedMessage.setProperty(entry.getKey(), entry.getValue());
        }
    }
}
"
org.apache.camel.spring.util.MethodInfo,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
/**
 * @version $Revision: $
 */
public class MethodInfo {
    private Class type;
    private Method method;
    private Expression parametersExpression;
    public MethodInfo(Class type, Method method, Expression parametersExpression) {
        this.type = type;
        this.method = method;
        this.parametersExpression = parametersExpression;
    }
    public MethodInvocation createMethodInvocation(final Object pojo, final Exchange messageExchange) {
        final Object[] arguments = (Object[]) parametersExpression.evaluate(messageExchange);
        return new MethodInvocation() {
            public Method getMethod() {
                return method;
            }
            public Object[] getArguments() {
                return arguments;
            }
            public Object proceed() throws Throwable {
                return invoke(method, pojo, arguments, messageExchange);
            }
            public Object getThis() {
                return pojo;
            }
            public AccessibleObject getStaticPart() {
                return method;
            }
        };
    }
    public Class getType() {
        return type;
    }
    public Method getMethod() {
        return method;
    }
    public Expression getParametersExpression() {
        return parametersExpression;
    }
    protected Object invoke(Method mth, Object pojo, Object[] arguments, Exchange exchange) throws IllegalAccessException, InvocationTargetException {
        return mth.invoke(pojo, arguments);
    }
}
"
org.apache.camel.component.mail.RuntimeMailException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
/**
 * @version $Revision:520964 $
 */
public class RuntimeMailException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeMailException(String message, Throwable cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.mail.MailProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.Exchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;
import javax.mail.internet.MimeMessage;
/**
 * @version $Revision: 525547 $
 */
public class MailProducer extends DefaultProducer<MailExchange> {
    private static final transient Log log = LogFactory.getLog(MailProducer.class);
    private final MailEndpoint endpoint;
    private final JavaMailSender sender;
    public MailProducer(MailEndpoint endpoint, JavaMailSender sender) {
        super(endpoint);
        this.endpoint = endpoint;
        this.sender = sender;
    }
    public void process(final Exchange exchange) {
        sender.send(new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws Exception {
                endpoint.getBinding().populateMailMessage(endpoint, mimeMessage, exchange);
            }
        });
    }
}
"
org.apache.camel.component.jbi.JbiMessage,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultMessage;
import javax.jbi.messaging.NormalizedMessage;
import java.util.Iterator;
import java.util.Map;
/**
 * A JBI {@link Message} which provides access to the underlying JBI features such as {@link #getNormalizedMessage()}
 *
 * @version $Revision$
 */
public class JbiMessage extends DefaultMessage {
    private NormalizedMessage normalizedMessage;
    public JbiMessage() {
    }
    public JbiMessage(NormalizedMessage normalizedMessage) {
        this.normalizedMessage = normalizedMessage;
    }
    @Override
    public String toString() {
        if (normalizedMessage != null) {
            return ""JbiMessage: "" + normalizedMessage;
        }
        else {
            return ""JbiMessage: "" + getBody();
        }
    }
    @Override
    public JbiExchange getExchange() {
        return (JbiExchange) super.getExchange();
    }
    /**
     * Returns the underlying JBI message
     *
     * @return the underlying JBI message
     */
    public NormalizedMessage getNormalizedMessage() {
        return normalizedMessage;
    }
    public void setNormalizedMessage(NormalizedMessage normalizedMessage) {
        this.normalizedMessage = normalizedMessage;
    }
    public Object getHeader(String name) {
        Object answer = null;
        if (normalizedMessage != null) {
            answer = normalizedMessage.getProperty(name);
        }
        if (answer == null) {
            answer = super.getHeader(name);
        }
        return answer;
    }
    @Override
    public JbiMessage newInstance() {
        return new JbiMessage();
    }
    @Override
    protected Object createBody() {
        if (normalizedMessage != null) {
            return getExchange().getBinding().extractBodyFromJbi(getExchange(), normalizedMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (normalizedMessage != null) {
            Iterator iter = normalizedMessage.getPropertyNames().iterator();
            while (iter.hasNext()) {
                String name = iter.next().toString();
                Object value = normalizedMessage.getProperty(name);
                map.put(name, value);
            }
        }
    }
}
"
org.apache.camel.component.activemq.ActiveMQConfiguration,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.activemq;
import org.apache.activemq.pool.PooledConnectionFactory;
import org.apache.activemq.spring.ActiveMQConnectionFactory;
import org.apache.camel.component.jms.JmsConfiguration;
import javax.jms.ConnectionFactory;
/**
 * @version $Revision: 1.1 $
 */
public class ActiveMQConfiguration extends JmsConfiguration {
    private String brokerURL = ActiveMQConnectionFactory.DEFAULT_BROKER_URL;
    public ActiveMQConfiguration() {
    }
    public String getBrokerURL() {
        return brokerURL;
    }
    /**
     * Sets the broker URL to use to connect to ActiveMQ using the
     * <a href=""http://activemq.apache.org/configuring-transports.html"">ActiveMQ URI format</a>
     *
     * @param brokerURL the URL of the broker.
     */
    public void setBrokerURL(String brokerURL) {
        this.brokerURL = brokerURL;
    }
    @Override
    public ActiveMQConnectionFactory getListenerConnectionFactory() {
        return (ActiveMQConnectionFactory) super.getListenerConnectionFactory();
    }
    @Override
    public void setListenerConnectionFactory(ConnectionFactory listenerConnectionFactory) {
        if (listenerConnectionFactory instanceof ActiveMQConnectionFactory) {
            super.setListenerConnectionFactory(listenerConnectionFactory);
        }
        else {
            throw new IllegalArgumentException(""ConnectionFactory "" + listenerConnectionFactory
                    + "" is not an instanceof "" + ActiveMQConnectionFactory.class.getName());
        }
    }
    @Override
    protected ConnectionFactory createListenerConnectionFactory() {
        ActiveMQConnectionFactory answer = new ActiveMQConnectionFactory();
        answer.setBrokerURL(getBrokerURL());
        return answer;
    }
    @Override
    protected ConnectionFactory createTemplateConnectionFactory() {
        return new PooledConnectionFactory(getListenerConnectionFactory());
    }
}
"
org.apache.camel.component.mail.MailBinding,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.Exchange;
import org.apache.camel.converter.ObjectConverter;
import javax.mail.Address;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
/**
 * A Strategy used to convert between a Camel {@Exchange} and {@Message} to and from a
 * Mail {@link MimeMessage}
 *
 * @version $Revision: 521240 $
 */
public class MailBinding {
    public void populateMailMessage(MailEndpoint endpoint, MimeMessage mimeMessage, Exchange exchange) {
        try {
            appendHeadersFromCamel(mimeMessage, exchange, exchange.getIn());
            String destination = endpoint.getConfiguration().getDestination();
            if (destination != null) {
                mimeMessage.setRecipients(Message.RecipientType.TO, destination);
            }
            if (empty(mimeMessage.getFrom())) {
                // lets default the address to the endpoint destination
                String from = endpoint.getConfiguration().getFrom();
                mimeMessage.setFrom(new InternetAddress(from));
            }
            mimeMessage.setText(exchange.getIn().getBody(String.class));
        }
        catch (Exception e) {
            throw new RuntimeMailException(""Failed to populate body due to: "" + e + "". Exchange: "" + exchange, e);
        }
    }
    protected boolean empty(Address[] addresses) {
        return addresses == null || addresses.length == 0;
    }
    /**
     * Extracts the body from the Mail message
     *
     * @param exchange
     * @param message
     */
    public Object extractBodyFromMail(MailExchange exchange, Message message) {
        try {
            return message.getContent();
        }
        catch (Exception e) {
            throw new RuntimeMailException(""Failed to extract body due to: "" + e + "". Message: "" + message, e);
        }
    }
    /**
     * Appends the Mail headers from the Camel {@link MailMessage}
     */
    protected void appendHeadersFromCamel(MimeMessage mimeMessage, Exchange exchange, org.apache.camel.Message camelMessage) throws MessagingException {
        Set<Map.Entry<String, Object>> entries = camelMessage.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            if (headerValue != null) {
                if (shouldOutputHeader(camelMessage, headerName, headerValue)) {
                    // Mail messages can repeat the same header...
                    if (ObjectConverter.isCollection(headerValue)) {
                        Iterator iter = ObjectConverter.iterator(headerValue);
                        while (iter.hasNext()) {
                            Object value = iter.next();
                            mimeMessage.addHeader(headerName, asString(exchange, value));
                        }
                    }
                    else {
                        mimeMessage.setHeader(headerName, asString(exchange, headerValue));
                    }
                }
            }
        }
    }
    /**
     * Converts the given object value to a String
     */
    protected String asString(Exchange exchange, Object value) {
        return exchange.getContext().getTypeConverter().convertTo(String.class, value);
    }
    /**
     * Strategy to allow filtering of headers which are put on the Mail message
     */
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName, Object headerValue) {
        return true;
    }
}
"
org.apache.camel.component.xmpp.XmppBinding,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.jivesoftware.smack.packet.Message;
import org.apache.camel.Exchange;
import java.util.Map;
import java.util.Set;
/**
 * A Strategy used to convert between a Camel {@XmppExchange} and {@XmppMessage} to and from a
 * XMPP {@link Message}
 *
 * @version $Revision$
 */
public class XmppBinding {
    /**
     * Populates the given XMPP message from the inbound exchange
     */
    public void populateXmppMessage(Message message, Exchange exchange) {
        message.setBody(exchange.getIn().getBody(String.class));
        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String name = entry.getKey();
            Object value = entry.getValue();
            if (shouldOutputHeader(exchange, name, value)) {
                message.setProperty(name, value);
            }
        }
        String id = exchange.getExchangeId();
        if (id != null) {
            message.setProperty(""exchangeId"", id);
        }
    }
    /**
     * Extracts the body from the XMPP message
     *
     * @param exchange
     * @param message
     */
    public Object extractBodyFromXmpp(XmppExchange exchange, Message message) {
        return message.getBody();
    }
    /**
     * Strategy to allow filtering of headers which are put on the XMPP message
     */
    protected boolean shouldOutputHeader(Exchange exchange, String headerName, Object headerValue) {
        return true;
    }
}
"
org.apache.camel.component.jbi.CamelJbiEndpoint,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
 * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
 * to You under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.servicemix.common.ServiceUnit;
import org.apache.servicemix.common.endpoints.ProviderEndpoint;
import javax.jbi.messaging.MessageExchange;
import javax.jbi.messaging.NormalizedMessage;
import javax.xml.namespace.QName;
/**
 * A JBI endpoint which when invoked will delegate to a Camel endpoint
 *
 * @version $Revision: 426415 $
 */
public class CamelJbiEndpoint extends ProviderEndpoint {
    private static final transient Log log = LogFactory.getLog(CamelJbiEndpoint.class);
    private static final QName SERVICE_NAME = new QName(""http://camel.apache.org/service"", ""CamelEndpointComponent"");
    private Endpoint camelEndpoint;
    private JbiBinding binding;
    private Processor processor;
    public CamelJbiEndpoint(ServiceUnit serviceUnit, QName service, String endpoint, Endpoint camelEndpoint, JbiBinding binding, Processor processor) {
        super(serviceUnit, service, endpoint);
        this.processor = processor;
        this.camelEndpoint = camelEndpoint;
        this.binding = binding;
    }
    public CamelJbiEndpoint(ServiceUnit serviceUnit, Endpoint camelEndpoint, JbiBinding binding, Processor processor) {
        this(serviceUnit, SERVICE_NAME, camelEndpoint.getEndpointUri(), camelEndpoint, binding, processor);
    }
    protected void processInOnly(MessageExchange exchange, NormalizedMessage in) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug(""Received exchange: "" + exchange);
        }
        JbiExchange camelExchange = new JbiExchange(camelEndpoint.getContext(), binding, exchange);
        processor.process(camelExchange);
    }
    protected void processInOut(MessageExchange exchange, NormalizedMessage in, NormalizedMessage out) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug(""Received exchange: "" + exchange);
        }
        /*
         * ToDo
         */
    }
}
"
org.apache.camel.spring.converter.ResourceConverter,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.converter;
import org.apache.camel.Converter;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
/**
 * Some Spring based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public class ResourceConverter {
    @Converter
    public static InputStream toInputStream(Resource resource) throws IOException {
        return resource.getInputStream();
    }
    @Converter
    public static File toFile(Resource resource) throws IOException {
        return resource.getFile();
    }
    @Converter
    public static URL toUrl(Resource resource) throws IOException {
        return resource.getURL();
    }
    @Converter
    public static UrlResource toResource(String uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static UrlResource toResource(URL uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static FileSystemResource toResource(File file) throws IOException {
        return new FileSystemResource(file);
    }
    @Converter
    public static ByteArrayResource toResource(byte[] data) throws IOException {
        return new ByteArrayResource(data);
    }
}
"
org.apache.camel.spring.CamelBeanPostProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.EndpointInject;
import org.apache.camel.Exchange;
import org.apache.camel.MessageDriven;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.CamelTemplate;
import org.apache.camel.spring.util.BeanInfo;
import org.apache.camel.spring.util.DefaultMethodInvocationStrategy;
import org.apache.camel.spring.util.MethodInvocationStrategy;
import org.apache.camel.spring.util.ReflectionUtils;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.isNotNullOrBlank;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
/**
 * A post processor to perform injection of {@link Endpoint} and {@link Producer} instances together with binding
 * methods annotated with {@link @MessageDriven} to a Camel consumer.
 *
 * @version $Revision: 1.1 $
 */
public class CamelBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware {
    private static final transient Log log = LogFactory.getLog(CamelBeanPostProcessor.class);
    private CamelContext camelContext;
    private ApplicationContext applicationContext;
    private MethodInvocationStrategy invocationStrategy = new DefaultMethodInvocationStrategy();
	//private List<Consumer> consumers = new ArrayList<Consumer>();
    public CamelBeanPostProcessor() {
    }
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        injectFields(bean);
        injectMethods(bean);
        return bean;
    }
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    // Properties
    //-------------------------------------------------------------------------
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public MethodInvocationStrategy getInvocationStrategy() {
        return invocationStrategy;
    }
    public void setInvocationStrategy(MethodInvocationStrategy invocationStrategy) {
        this.invocationStrategy = invocationStrategy;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * A strategy method to allow implementations to perform some custom JBI based injection of the POJO
     *
     * @param bean the bean to be injected
     */
    protected void injectFields(final Object bean) {
        ReflectionUtils.doWithFields(bean.getClass(), new ReflectionUtils.FieldCallback() {
            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
                EndpointInject annotation = field.getAnnotation(EndpointInject.class);
                if (annotation != null) {
                    ReflectionUtils.setField(field, bean, getEndpointInjectionValue(annotation, field.getType()));
                }
            }
        });
    }
    protected void injectMethods(final Object bean) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                setterInjection(method, bean);
                consumerInjection(method, bean);
            }
        });
    }
    protected void setterInjection(Method method, Object bean) {
        EndpointInject annoation = method.getAnnotation(EndpointInject.class);
        if (annoation != null) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes != null) {
                if (parameterTypes.length != 1) {
                    log.warn(""Ignoring badly annotated method for injection due to incorrect number of parameters: "" + method);
                }
                else {
                    Object value = getEndpointInjectionValue(annoation, parameterTypes[0]);
                    ObjectHelper.invokeMethod(method, bean, value);
                }
            }
        }
    }
    protected void consumerInjection(final Object bean) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                /*
                TODO support callbacks?
                if (method.getAnnotation(Callback.class) != null) {
                    try {
                        Expression e = ExpressionFactory.createExpression(
                                method.getAnnotation(Callback.class).condition());
                        JexlContext jc = JexlHelper.createContext();
                        jc.getVars().put(""this"", obj);
                        Object r = e.evaluate(jc);
                        if (!(r instanceof Boolean)) {
                            throw new RuntimeException(""Expression did not returned a boolean value but: "" + r);
                        }
                        Boolean oldVal = req.getCallbacks().get(method);
                        Boolean newVal = (Boolean) r;
                        if ((oldVal == null || !oldVal) && newVal) {
                            req.getCallbacks().put(method, newVal);
                            method.invoke(obj, new Object[0]);
                            // TODO: handle return value and sent it as the answer
                        }
                    } catch (Exception e) {
                        throw new RuntimeException(""Unable to invoke callback"", e);
                    }
                }
                */
            }
        });
    }
    protected void consumerInjection(Method method, Object bean) {
        MessageDriven annotation = method.getAnnotation(MessageDriven.class);
        if (annotation != null) {
            log.info(""Creating a consumer for: "" + annotation);
            // lets bind this method to a listener
            Endpoint endpoint = getEndpointInjection(annotation.uri(), annotation.name());
            if (endpoint != null) {
                try {
                    Processor processor = createConsumerProcessor(bean, method, endpoint);
                    log.info(""Created processor: "" + processor);
                    Consumer consumer = endpoint.createConsumer(processor);
                    consumer.start();
                    addConsumer(consumer);
                }
                catch (Exception e) {
                    log.warn(e);
                    throw new RuntimeCamelException(e);
                }
            }
        }
    }
    /**
     * Create a processor which invokes the given method when an incoming message exchange is received
     */
    protected Processor createConsumerProcessor(final Object pojo, final Method method, final Endpoint endpoint) {
        final BeanInfo beanInfo = new BeanInfo(pojo.getClass(), invocationStrategy);
        return new Processor() {
            @Override
			public String toString() {
				return ""Processor on "" + endpoint;
			}
			public void process(Exchange exchange) throws Exception {
				if (log.isDebugEnabled()) {
					log.debug("">>>> invoking method for: "" + exchange);
				}
                MethodInvocation invocation = beanInfo.createInvocation(method, pojo, exchange);
            	if (invocation == null) {
            		throw new IllegalStateException(""No method invocation could be created"");
            	}
                try {
                	invocation.proceed();
                }
                catch (Exception e) {
                    throw e;
                }
                catch (Throwable throwable) {
                    throw new Exception(throwable);
                }
            }
        };
    }
    protected void addConsumer(Consumer consumer) {
        log.debug(""Adding consumer: "" + consumer);
        //consumers.add(consumer);
    }
    /**
     * Creates the value for the injection point for the given annotation
     */
    protected Object getEndpointInjectionValue(EndpointInject annotation, Class<?> type) {
        Endpoint endpoint = getEndpointInjection(annotation.uri(), annotation.name());
        if (endpoint != null) {
            if (type.isInstance(endpoint)) {
                return endpoint;
            }
            else if (type.isAssignableFrom(Producer.class)) {
                try {
                    return endpoint.createProducer();
                }
                catch (Exception e) {
                    throw new RuntimeCamelException(e);
                }
            }
            else if (type.isAssignableFrom(CamelTemplate.class)) {
                return new CamelTemplate(getCamelContext(), endpoint);
            }
        }
        return null;
    }
    protected Endpoint getEndpointInjection(String uri, String name) {
        Endpoint endpoint = null;
        if (isNotNullOrBlank(uri)) {
            endpoint = camelContext.getEndpoint(uri);
        }
        else {
            if (isNotNullOrBlank(name)) {
                endpoint = (Endpoint) applicationContext.getBean(name);
                if (endpoint == null) {
                    throw new NoSuchBeanDefinitionException(name);
                }
            }
            else {
                log.warn(""No uri or name specified on @EndpointInject annotation!"");
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.component.mail.MailEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.springframework.mail.javamail.JavaMailSender;
import javax.mail.Message;
import javax.mail.Folder;
/**
 * @version $Revision:520964 $
 */
public class MailEndpoint extends ScheduledPollEndpoint<MailExchange> {
    private MailBinding binding;
    private MailConfiguration configuration;
    public MailEndpoint(String uri, MailComponent component,  MailConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
    }
    public Producer<MailExchange> createProducer() throws Exception {
        JavaMailSender sender = configuration.createJavaMailConnection(this);
        return createProducer(sender);
    }
    /**
     * Creates a producer using the given sender
     */
    public Producer<MailExchange> createProducer(JavaMailSender sender) throws Exception {
        return new MailProducer(this, sender);
    }
    public Consumer<MailExchange> createConsumer(Processor processor) throws Exception {
        JavaMailConnection connection = configuration.createJavaMailConnection(this);
        String protocol = getConfiguration().getProtocol();
        if (protocol.equals(""smtp"")) {
            protocol = ""pop3"";
        }
        String folderName = getConfiguration().getFolderName();
        Folder folder = connection.getFolder(protocol, folderName);
        if (folder == null) {
            throw new IllegalArgumentException(""No folder for protocol: "" + protocol + "" and name: "" + folderName);
        }
        return createConsumer(processor, folder);
    }
    /**
     * Creates a consumer using the given processor and transport
     *
     * @param processor the processor to use to process the messages
     * @param folder the JavaMail Folder to use for inbound messages
     * @return a newly created consumer
     * @throws Exception if the consumer cannot be created
     */
    public Consumer<MailExchange> createConsumer(Processor processor, Folder folder) throws Exception {
        MailConsumer answer = new MailConsumer(this, processor, folder);
        configureConsumer(answer);
        return answer;
    }
    public MailExchange createExchange() {
        return new MailExchange(getContext(), getBinding());
    }
    public MailExchange createExchange(Message message) {
        return new MailExchange(getContext(), getBinding(), message);
    }
    // Properties
    //-------------------------------------------------------------------------
    public MailBinding getBinding() {
        if (binding == null) {
            binding = new MailBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a Mail message
     *
     * @param binding the binding to use
     */
    public void setBinding(MailBinding binding) {
        this.binding = binding;
    }
	public boolean isSingleton() {
		return false;
	}
    public MailConfiguration getConfiguration() {
        return configuration;
    }
}
"
org.apache.camel.component.jms.JmsBinding,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.Exchange;
import javax.jms.BytesMessage;
import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * A Strategy used to convert between a Camel {@JmsExchange} and {@JmsMessage} to and from a
 * JMS {@link Message}
 *
 * @version $Revision$
 */
public class JmsBinding {
    /**
     * Extracts the body from the JMS message
     *
     * @param exchange
     * @param message
     */
    public Object extractBodyFromJms(JmsExchange exchange, Message message) {
        try {
            if (message instanceof ObjectMessage) {
                ObjectMessage objectMessage = (ObjectMessage) message;
                return objectMessage.getObject();
            }
            else if (message instanceof TextMessage) {
                TextMessage textMessage = (TextMessage) message;
                return textMessage.getText();
            }
            else if (message instanceof MapMessage) {
                return createMapFromMapMessage((MapMessage) message);
            }
            else if (message instanceof BytesMessage || message instanceof StreamMessage) {
                // TODO we need a decoder to be able to process the message
                return message;
            }
            else {
                return null;
            }
        }
        catch (JMSException e) {
            throw new RuntimeJmsException(""Failed to extract body due to: "" + e + "". Message: "" + message, e);
        }
    }
    /**
     * Creates a JMS message from the Camel exchange and message
     *
     * @param session the JMS session used to create the message
     * @return a newly created JMS Message instance containing the
     * @throws JMSException if the message could not be created
     */
    public Message makeJmsMessage(Exchange exchange, Session session) throws JMSException {
        Message answer = createJmsMessage(exchange.getIn().getBody(), session);
        appendJmsProperties(answer, exchange, session);
        return answer;
    }
    /**
     * Appends the JMS headers from the Camel {@link JmsMessage}
     */
    protected void appendJmsProperties(Message jmsMessage, Exchange exchange, Session session) throws JMSException {
        org.apache.camel.Message in = exchange.getIn();
        Set<Map.Entry<String, Object>> entries = in.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            if (shouldOutputHeader(in, headerName, headerValue)) {
                jmsMessage.setObjectProperty(headerName, headerValue);
            }
        }
    }
    protected Message createJmsMessage(Object body, Session session) throws JMSException {
        if (body instanceof String) {
            return session.createTextMessage((String) body);
        }
        else if (body instanceof Serializable) {
            return session.createObjectMessage((Serializable) body);
        }
        else {
            return session.createMessage();
        }
    }
    /**
     * Extracts a {@link Map} from a {@link MapMessage}
     */
    public Map<String, Object> createMapFromMapMessage(MapMessage message) throws JMSException {
        Map<String, Object> answer = new HashMap<String, Object>();
        Enumeration names = message.getPropertyNames();
        while (names.hasMoreElements()) {
            String name = names.nextElement().toString();
            Object value = message.getObject(name);
            answer.put(name, value);
        }
        return answer;
    }
    /**
     * Strategy to allow filtering of headers which are put on the JMS message
     */
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName, Object headerValue) {
        return true;
    }
}
"
org.apache.camel.component.cxf.CxfMessage,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.impl.DefaultMessage;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import java.util.Map;
/**
 * An Apache CXF {@link Message} which provides access to the underlying CXF features
 *
 * @version $Revision$
 */
public class CxfMessage extends DefaultMessage {
    private Message cxfMessage;
    public CxfMessage() {
        this(new MessageImpl());
    }
    public CxfMessage(Message cxfMessage) {
        this.cxfMessage = cxfMessage;
    }
    @Override
    public String toString() {
        if (cxfMessage != null) {
            return ""CxfMessage: "" + cxfMessage;
        }
        else {
            return ""CxfMessage: "" + getBody();
        }
    }
    @Override
    public CxfExchange getExchange() {
        return (CxfExchange) super.getExchange();
    }
    /**
     * Returns the underlying CXF message
     *
     * @return the CXF message
     */
    public Message getMessage() {
        return cxfMessage;
    }
    public void setMessage(Message cxfMessage) {
        this.cxfMessage = cxfMessage;
    }
    public Object getHeader(String name) {
        return cxfMessage.get(name);
    }
    @Override
    public void setHeader(String name, Object value) {
        cxfMessage.put(name, value);
    }
    @Override
    public Map<String, Object> getHeaders() {
        return cxfMessage;
    }
    @Override
    public CxfMessage newInstance() {
        return new CxfMessage();
    }
    @Override
    protected Object createBody() {
        return getExchange().getBinding().extractBodyFromCxf(getExchange(), cxfMessage);
    }
}
"
org.apache.camel.component.cxf.transport.CamelConduit,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import org.apache.camel.CamelContext;
import org.apache.camel.Processor;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.io.AbstractCachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.AttributedURIType;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
/**
 * @version $Revision$
 */
public class CamelConduit extends AbstractConduit implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-conduit-base"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelConduit.class);
    private final CamelTransportBase base;
    private String targetCamelEndpointUri;
/*
    protected ClientConfig clientConfig;
    protected ClientBehaviorPolicyType runtimePolicy;
    protected AddressType address;
    protected SessionPoolType sessionPool;
*/
    public CamelConduit(CamelContext camelContext, Bus bus, EndpointInfo endpointInfo, EndpointReferenceType targetReference) {
        super(targetReference);
        AttributedURIType address = targetReference.getAddress();
        if (address != null) {
            this.targetCamelEndpointUri = address.getValue();
        }
        base = new CamelTransportBase(camelContext, bus, endpointInfo, false, BASE_BEAN_NAME_SUFFIX);
        initConfig();
    }
    // prepare the message for send out , not actually send out the message
    public void prepare(Message message) throws IOException {
        getLogger().log(Level.FINE, ""CamelConduit send message"");
        message.setContent(OutputStream.class,
                new CamelOutputStream(message));
    }
    public void close() {
        getLogger().log(Level.FINE, ""CamelConduit closed "");
        // ensure resources held by session factory are released
        //
        base.close();
    }
    protected Logger getLogger() {
        return LOG;
    }
    public String getBeanName() {
        EndpointInfo info = base.endpointInfo;
        if (info == null) {
            return ""default.camel-conduit"";
        }
        return info.getName() + "".camel-conduit"";
    }
    private void initConfig() {
/*
        this.address = base.endpointInfo.getTraversedExtensor(new AddressType(),
                                                              AddressType.class);
        this.sessionPool = base.endpointInfo.getTraversedExtensor(new SessionPoolType(),
                                                                  SessionPoolType.class);
        this.clientConfig = base.endpointInfo.getTraversedExtensor(new ClientConfig(),
                                                                   ClientConfig.class);
        this.runtimePolicy = base.endpointInfo.getTraversedExtensor(new ClientBehaviorPolicyType(),
                                                                    ClientBehaviorPolicyType.class);
*/
        Configurer configurer = base.bus.getExtension(Configurer.class);
        if (null != configurer) {
            configurer.configureBean(this);
        }
    }
    private class CamelOutputStream extends AbstractCachedOutputStream {
        private Message outMessage;
        private boolean isOneWay;
        public CamelOutputStream(Message m) {
            outMessage = m;
        }
        protected void doFlush() throws IOException {
            //do nothing here
        }
        protected void doClose() throws IOException {
            isOneWay = outMessage.getExchange().isOneWay();
            commitOutputMessage();
            if (!isOneWay) {
                handleResponse();
            }
        }
        protected void onWrite() throws IOException {
        }
        private void commitOutputMessage() {
            base.template.send(targetCamelEndpointUri, new Processor() {
                public void process(org.apache.camel.Exchange reply) {
                    Object request = null;
                    if (isTextPayload()) {
                        request = currentStream.toString();
                    }
                    else {
                        request = ((ByteArrayOutputStream) currentStream).toByteArray();
                    }
                    getLogger().log(Level.FINE, ""Conduit Request is :["" + request + ""]"");
                    String replyTo = base.getReplyDestination();
                    //TODO setting up the responseExpected
                    base.marshal(request, replyTo, reply);
                    base.setMessageProperties(outMessage, reply);
                    String correlationID = null;
                    if (!isOneWay) {
                        // TODO create a correlationID
                        String id = null;
                        if (id != null) {
                            if (correlationID != null) {
                                String error = ""User cannot set CamelCorrelationID when ""
                                        + ""making a request/reply invocation using ""
                                        + ""a static replyTo Queue."";
                            }
                            correlationID = id;
                        }
                    }
                    if (correlationID != null) {
                        reply.getIn().setHeader(CamelConstants.CAMEL_CORRELATION_ID, correlationID);
                    }
                    else {
                        //No message correlation id is set. Whatever comeback will be accepted as responses.
                        // We assume that it will only happen in case of the temp. reply queue.
                    }
                    getLogger().log(Level.FINE, ""template sending request: "", reply.getIn());
                }
            });
        }
        private void handleResponse() throws IOException {
            // REVISIT distinguish decoupled case or oneway call
            Object response = null;
            //TODO if outMessage need to get the response
            Message inMessage = new MessageImpl();
            outMessage.getExchange().setInMessage(inMessage);
            //set the message header back to the incomeMessage
            //inMessage.put(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS,
            //              outMessage.get(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS));
            /*
            Object result1;
            Object result = null;
            javax.camel.Message camelMessage1 = pooledSession.consumer().receive(timeout);
            getLogger().log(Level.FINE, ""template received reply: "" , camelMessage1);
            if (camelMessage1 != null) {
                base.populateIncomingContext(camelMessage1, outMessage, CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS);
                String messageType = camelMessage1 instanceof TextMessage
                            ? CamelConstants.TEXT_MESSAGE_TYPE : CamelConstants.BINARY_MESSAGE_TYPE;
                result = base.unmarshal((org.apache.camel.Exchange) outMessage);
                result1 = result;
            } else {
                String error = ""CamelClientTransport.receive() timed out. No message available."";
                getLogger().log(Level.SEVERE, error);
                //TODO: Review what exception should we throw.
                throw new CamelException(error);
            }
            response = result1;
            //set the message header back to the incomeMessage
            inMessage.put(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS,
                          outMessage.get(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS));
            */
            getLogger().log(Level.FINE, ""The Response Message is : ["" + response + ""]"");
            // setup the inMessage response stream
            byte[] bytes = null;
            if (response instanceof String) {
                String requestString = (String) response;
                bytes = requestString.getBytes();
            }
            else {
                bytes = (byte[]) response;
            }
            inMessage.setContent(InputStream.class, new ByteArrayInputStream(bytes));
            getLogger().log(Level.FINE, ""incoming observer is "" + incomingObserver);
            incomingObserver.onMessage(inMessage);
        }
    }
    private boolean isTextPayload() {
        // TODO use runtime policy
        return true;
    }
    /**
     * Represented decoupled response endpoint.
     */
    protected class DecoupledDestination implements Destination {
        protected MessageObserver decoupledMessageObserver;
        private EndpointReferenceType address;
        DecoupledDestination(EndpointReferenceType ref,
                MessageObserver incomingObserver) {
            address = ref;
            decoupledMessageObserver = incomingObserver;
        }
        public EndpointReferenceType getAddress() {
            return address;
        }
        public Conduit getBackChannel(Message inMessage,
                Message partialResponse,
                EndpointReferenceType addr)
                throws IOException {
            // shouldn't be called on decoupled endpoint
            return null;
        }
        public void shutdown() {
            // TODO Auto-generated method stub
        }
        public synchronized void setMessageObserver(MessageObserver observer) {
            decoupledMessageObserver = observer;
        }
        public synchronized MessageObserver getMessageObserver() {
            return decoupledMessageObserver;
        }
    }
}
"
org.apache.camel.spring.xml.BeanDefinitionParser,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser;
import org.w3c.dom.Element;
/**
 * A base class for a parser for a bean.
 *
 * @version $Revision: 1.1 $
 */
public class BeanDefinitionParser extends AbstractSimpleBeanDefinitionParser {
    private Class type;
    protected BeanDefinitionParser() {
    }
    public BeanDefinitionParser(Class type) {
        this.type = type;
    }
    protected Class getBeanClass(Element element) {
        if (type == null) {
            type = loadType();
        }
        return type;
    }
    protected Class loadType() {
        throw new IllegalArgumentException(""No type specified!"");
    }
    @Override
    protected boolean isEligibleAttribute(String attributeName) {
        return attributeName != null && super.isEligibleAttribute(attributeName) && !attributeName.equals(""xmlns"");
    }
}"
org.apache.camel.bam.ActivityBuilder,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import org.apache.camel.Endpoint;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.builder.ProcessorFactory;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import java.util.Date;
/**
 * @version $Revision: $
 */
public class ActivityBuilder implements ProcessorFactory {
    private ProcessBuilder processBuilder;
    private Endpoint endpoint;
    private ActivityRules activityRules;
    private Expression correlationExpression;
    public ActivityBuilder(ProcessBuilder processBuilder, Endpoint endpoint) {
        this.processBuilder = processBuilder;
        this.endpoint = endpoint;
        this.activityRules = new ActivityRules(processBuilder);
        this.activityRules.setActivityName(endpoint.getEndpointUri());
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public Processor createProcessor() throws Exception {
        return processBuilder.createActivityProcessor(this);
    }
    public Route createRoute() throws Exception {
        Processor processor = createProcessor();
        if (processor == null) {
            throw new IllegalArgumentException(""No processor created for ActivityBuilder: "" + this);
        }
        return new EventDrivenConsumerRoute(getEndpoint(), processor);
    }
    // Builder methods
    //-----------------------------------------------------------------------
    public ActivityBuilder correlate(Expression correlationExpression) {
        this.correlationExpression = correlationExpression;
        return this;
    }
    public ActivityBuilder name(String name) {
        activityRules.setActivityName(name);
        return this;
    }
    /**
     * Create a temporal rule for when this step starts
     */
    public TimeExpression starts() {
        return new TimeExpression(this, ActivityLifecycle.Started) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeStarted();
            }
        };
    }
    /**
     * Create a temporal rule for when this step completes
     */
    public TimeExpression completes() {
        return new TimeExpression(this, ActivityLifecycle.Completed) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeCompleted();
            }
        };
    }
    // Properties
    //-----------------------------------------------------------------------
    public Expression getCorrelationExpression() {
        return correlationExpression;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ProcessBuilder getProcessBuilder() {
        return processBuilder;
    }
}
"
org.apache.camel.component.cxf.CxfConstants,"/**
 /**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
/**
 * Constants used in this module
 *
 * @version $Revision$
 */
public interface CxfConstants {
    String METHOD = ""method"";
    String SEI = ""sei"";
    String IMPL = ""impl"";
}
"
org.apache.camel.component.activemq.ActiveMQComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.activemq;
import org.apache.camel.CamelContext;
import org.apache.camel.component.jms.JmsComponent;
import org.apache.camel.component.jms.JmsConfiguration;
/**
 * The <a href=""http://activemq.apache.org/camel/activemq.html"">ActiveMQ Component</a>
 *
 * @version $Revision: 1.1 $
 */
public class ActiveMQComponent extends JmsComponent {
    /**
     * Creates an <a href=""http://activemq.apache.org/camel/activemq.html"">ActiveMQ Component</a>
     *
     * @return the created component
     */
    public static ActiveMQComponent activeMQComponent() {
        return new ActiveMQComponent();
    }
    /**
     * Creates an <a href=""http://activemq.apache.org/camel/activemq.html"">ActiveMQ Component</a>
     * connecting to the given <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
     *
     * @param brokerURL the URL to connect to
     * @return the created component
     */
    public static ActiveMQComponent activeMQComponent(String brokerURL) {
        ActiveMQComponent answer = new ActiveMQComponent();
        answer.getConfiguration().setBrokerURL(brokerURL);
        return answer;
    }
    public ActiveMQComponent() {
    }
    public ActiveMQComponent(CamelContext context) {
        super(context);
    }
    public ActiveMQComponent(ActiveMQConfiguration configuration) {
        super(configuration);
    }
    @Override
    public ActiveMQConfiguration getConfiguration() {
        return (ActiveMQConfiguration) super.getConfiguration();
    }
    public void setBrokerURL(String brokerURL) {
        getConfiguration().setBrokerURL(brokerURL);
    }
    @Override
    protected JmsConfiguration createConfiguration() {
        return new ActiveMQConfiguration();
    }
}
"
org.apache.camel.spring.util.ReflectionUtils,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
public class ReflectionUtils extends org.springframework.util.ReflectionUtils {
    public static <T extends Annotation> void callLifecycleMethod(final Object bean, final Class<T> annotation) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                if (method.getAnnotation(annotation) != null) {
                    try {
                        method.invoke(bean, (Object[]) null);
                    }
                    catch (IllegalArgumentException ex) {
                        throw new IllegalStateException(""Failure to invoke "" + method + "" on ""
                                + bean.getClass() + "": args=[]"", ex);
                    }
                    catch (IllegalAccessException ex) {
                        throw new UnsupportedOperationException(ex.toString());
                    }
                    catch (InvocationTargetException ex) {
                        throw new UnsupportedOperationException(""PostConstruct method on bean threw exception"",
                                ex.getTargetException());
                    }
                }
            }
        });
    }
    public static void setField(Field f, Object instance, Object value) {
        try {
            boolean oldAccessible = f.isAccessible();
            boolean shouldSetAccessible = !Modifier.isPublic(f.getModifiers()) && !oldAccessible;
            if (shouldSetAccessible) {
                f.setAccessible(true);
            }
            f.set(instance, value);
            if (shouldSetAccessible) {
                f.setAccessible(oldAccessible);
            }
        }
        catch (IllegalArgumentException ex) {
            throw new UnsupportedOperationException(""Cannot inject value of class '""
                    + value.getClass() + ""' into "" + f);
        }
        catch (IllegalAccessException ex) {
            ReflectionUtils.handleReflectionException(ex);
        }
    }
}
"
org.apache.camel.component.mina.MinaEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.CamelContext;
import org.apache.camel.Producer;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoSession;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoServiceConfig;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.net.SocketAddress;
/**
 * @version $Revision$
 */
public class MinaEndpoint extends DefaultEndpoint<MinaExchange> {
    private final IoAcceptor acceptor;
    private final SocketAddress address;
    private final IoConnector connector;
    private final IoServiceConfig config;
    public MinaEndpoint(String endpointUri, MinaComponent component, SocketAddress address, IoAcceptor acceptor, IoConnector connector, IoServiceConfig config) {
        super(endpointUri, component);
        this.config = config;
        this.address = address;
        this.acceptor = acceptor;
        this.connector = connector;
    }
    public Producer<MinaExchange> createProducer() throws Exception {
        return new MinaProducer(this);
    }
    public Consumer<MinaExchange> createConsumer(Processor processor) throws Exception {
        return new MinaConsumer(this, processor);
    }
    public MinaExchange createExchange() {
        return new MinaExchange(getContext());
    }
    public MinaExchange createExchange(IoSession session, Object object) {
        MinaExchange exchange = new MinaExchange(getContext());
        exchange.getIn().setBody(object);
        // TODO store session in exchange?
        return exchange;
    }
    // Properties
    //-------------------------------------------------------------------------
    public IoAcceptor getAcceptor() {
        return acceptor;
    }
    public SocketAddress getAddress() {
        return address;
    }
    public IoConnector getConnector() {
        return connector;
    }
    public IoServiceConfig getConfig() {
        return config;
    }
	public boolean isSingleton() {
		return true;
	}
}
"
org.apache.camel.component.quartz.QuartzConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision: 1.1 $
 */
public class QuartzConsumer extends DefaultConsumer<QuartzExchange> {
    public QuartzConsumer(QuartzEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
    }
    @Override
    public QuartzEndpoint getEndpoint() {
        return (QuartzEndpoint) super.getEndpoint();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getEndpoint().consumerStarted(this);
    }
    @Override
    protected void doStop() throws Exception {
        getEndpoint().consumerStopped(this);
        super.doStop();
    }
}
"
org.apache.camel.bam.rules.ProcessRules,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import java.util.ArrayList;
import java.util.List;
/**
 * @version $Revision: $
 */
public class ProcessRules extends ServiceSupport {
    private ProcessDefinition processDefinition;
    private List<ActivityRules> activities = new ArrayList<ActivityRules>();
    public void processExpired(ActivityState activityState) throws Exception {
        for (ActivityRules activityRules : activities) {
            activityRules.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (ActivityRules activityRules : activities) {
            activityRules.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public List<ActivityRules> getActivities() {
        return activities;
    }
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(activities);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(activities);
    }
}
"
org.apache.camel.component.rmi.RmiEndpoint,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.net.URI;
import java.net.URISyntaxException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.pojo.PojoExchange;
import org.apache.camel.impl.DefaultEndpoint;
/**
 * @version $Revision:520964 $
 */
public class RmiEndpoint extends DefaultEndpoint<PojoExchange> {
	private List<Class> remoteInterfaces;
	private ClassLoader classLoader;
	private URI uri;
	private int port;
	protected RmiEndpoint(String endpointUri, RmiComponent component) throws URISyntaxException {
		super(endpointUri, component);
		this.uri = new URI(endpointUri);
	}
	public boolean isSingleton() {
		return false;
	}
	public PojoExchange createExchange() {
		return new PojoExchange(getContext());
	}
	public Consumer<PojoExchange> createConsumer(Processor processor) throws Exception {
		if( remoteInterfaces == null || remoteInterfaces.size()==0 )
			throw new RuntimeCamelException(""To create an RMI consumer, the RMI endpoint's remoteInterfaces property must be be configured."");
		return new RmiConsumer(this, processor);
	}
	public Producer<PojoExchange> createProducer() throws Exception {
		return new RmiProducer(this);
	}
	public String getName() {
		String path = uri.getPath();
		if( path == null )
			path = uri.getSchemeSpecificPart();
		return path;
	}
	public Registry getRegistry() throws RemoteException {
		if( uri.getHost()!=null ) {
			if( uri.getPort() == -1 ) {
				return LocateRegistry.getRegistry(uri.getHost());
			} else {
				return LocateRegistry.getRegistry(uri.getHost(), uri.getPort());				
			}
		} else {
			return LocateRegistry.getRegistry();
		}
	}
	public List<Class> getRemoteInterfaces() {
		return remoteInterfaces;
	}
	public void setRemoteInterfaces(List<Class> remoteInterfaces) {
		this.remoteInterfaces = remoteInterfaces;
		if( classLoader== null && !remoteInterfaces.isEmpty() ) {
			classLoader = remoteInterfaces.get(0).getClassLoader();
		}
	}
	public void setRemoteInterfaces(Class... remoteInterfaces) {
		setRemoteInterfaces(Arrays.asList(remoteInterfaces));		
	}
	public ClassLoader getClassLoader() {
		return classLoader;
	}
	public void setClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	public int getPort() {
		return port;
	}
	public void setPort(int port) {
		this.port = port;
	}
}
"
org.apache.camel.component.cxf.CxfProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.transport.local.LocalConduit;
import org.apache.cxf.transport.local.LocalTransportFactory;
import java.io.IOException;
import java.util.concurrent.CountDownLatch;
/**
 * Sends messages from Camel into the CXF endpoint
 *
 * @version $Revision$
 */
public class CxfProducer extends DefaultProducer {
    private CxfEndpoint endpoint;
    private final LocalTransportFactory transportFactory;
    private Destination destination;
    private Conduit conduit;
    private ResultFuture future = new ResultFuture();
    public CxfProducer(CxfEndpoint endpoint, LocalTransportFactory transportFactory) {
        super(endpoint);
        this.endpoint = endpoint;
        this.transportFactory = transportFactory;
    }
    public void process(Exchange exchange) {
        CxfExchange cxfExchange = endpoint.toExchangeType(exchange);
        process(cxfExchange);
    }
    public void process(CxfExchange exchange) {
        try {
            CxfBinding binding = endpoint.getBinding();
            MessageImpl m = binding.createCxfMessage(exchange);
            ExchangeImpl e = new ExchangeImpl();
            e.setInMessage(m);
            m.put(LocalConduit.DIRECT_DISPATCH, Boolean.TRUE);
            m.setDestination(destination);
            synchronized (conduit) {
                conduit.prepare(m);
                // now lets wait for the response
                if (endpoint.isInOut()) {
                    Message response = future.getResponse();
                    // TODO - why do we need to ignore the returned message and get the out message from the exchange!
                    response = e.getOutMessage();
                    binding.storeCxfResponse(exchange, response);
                }
            }
        }
        catch (IOException e) {
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        EndpointInfo endpointInfo = endpoint.getEndpointInfo();
        destination = transportFactory.getDestination(endpointInfo);
        // Set up a listener for the response
        conduit = transportFactory.getConduit(endpointInfo);
        conduit.setMessageObserver(future);
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (conduit != null) {
            conduit.close();
        }
    }
    protected class ResultFuture implements MessageObserver {
        Message response;
        CountDownLatch latch = new CountDownLatch(1);
        public Message getResponse() {
            while (response == null) {
                try {
                    latch.await();
                }
                catch (InterruptedException e) {
                    // ignore
                }
            }
            return response;
        }
        public synchronized void onMessage(Message message) {
            try {
                message.remove(LocalConduit.DIRECT_DISPATCH);
                this.response = message;
            }
            finally {
                latch.countDown();
            }
        }
    }
}
"
org.apache.camel.bam.ActivityLifecycle,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
/**
 * @version $Revision: 1.1 $
 */
public enum ActivityLifecycle {
    Started, Completed
}
"
org.apache.camel.bam.processor.BamProcessorSupport,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
/**
 * A base {@link Processor} for working on
 * <a href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which a derived class would do the actual
 * persistence such as the {@link JpaBamProcessor}
 *
 * @version $Revision: $
 */
public abstract class BamProcessorSupport<T> implements Processor {
    private static final transient Log log = LogFactory.getLog(BamProcessorSupport.class);
    private Class<T> entityType;
    private Expression<Exchange> correlationKeyExpression;
    private TransactionTemplate transactionTemplate;
    protected BamProcessorSupport(TransactionTemplate transactionTemplate, Expression<Exchange> correlationKeyExpression) {
        this.transactionTemplate = transactionTemplate;
        this.correlationKeyExpression = correlationKeyExpression;
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    this.entityType = (Class<T>) argumentType;
                }
            }
        }
        if (entityType == null) {
            throw new IllegalArgumentException(""Could not infer the entity type!"");
        }
    }
    protected BamProcessorSupport(TransactionTemplate transactionTemplate, Expression<Exchange> correlationKeyExpression, Class<T> entitytype) {
        this.transactionTemplate = transactionTemplate;
        this.entityType = entitytype;
        this.correlationKeyExpression = correlationKeyExpression;
    }
    public void process(final Exchange exchange) {
        transactionTemplate.execute(new TransactionCallback() {
            public Object doInTransaction(TransactionStatus status) {
                try {
                    Object key = getCorrelationKey(exchange);
                    T entity = loadEntity(exchange, key);
                    if (log.isDebugEnabled()) {
                        log.debug(""Correlation key: "" + key + "" with entity: "" + entity);
                    }
                    processEntity(exchange, entity);
                    return entity;
                }
                catch (Exception e) {
                    throw new RuntimeCamelException(e);
                }
            }
        });
    }
    // Properties
    //-----------------------------------------------------------------------
    public Expression<Exchange> getCorrelationKeyExpression() {
        return correlationKeyExpression;
    }
    public Class<T> getEntityType() {
        return entityType;
    }
    // Implemenation methods
    //-----------------------------------------------------------------------
    protected abstract void processEntity(Exchange exchange, T entity) throws Exception;
    protected abstract T loadEntity(Exchange exchange, Object key);
    protected Object getCorrelationKey(Exchange exchange) throws NoCorrelationKeyException {
        Object value = correlationKeyExpression.evaluate(exchange);
        if (value == null) {
            throw new NoCorrelationKeyException(this, exchange);
        }
        return value;
    }
}
"
org.apache.camel.bam.processor.JpaBamProcessor,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A concrete {@link Processor} for working on
 * <a href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which uses JPA as the persistence and uses the
 * {@link ProcessInstance} entity to store the process information.
 *
 * @version $Revision: $
 */
public class JpaBamProcessor extends JpaBamProcessorSupport<ProcessInstance> {
    private static final transient Log log = LogFactory.getLog(JpaBamProcessor.class);
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules);
    }
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules, Class<ProcessInstance> entitytype) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules, entitytype);
    }
    protected void processEntity(Exchange exchange, ProcessInstance process) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug(""Processing process instance: "" + process);
        }
        // lets force the lazy creation of this activity
        ActivityRules rules = getActivityRules();
        ActivityState state = process.getOrCreateActivityState(rules);
        state.processExchange(rules, new ProcessContext(exchange, rules, state));
        rules.getProcessRules().processExchange(exchange, process);
    }
}
"
org.apache.camel.spring.xml.IllegalActionException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
public class IllegalActionException extends IllegalArgumentException {
	private static final long serialVersionUID = -2166507687211986107L;
	private final String actionName;
	private final String previousAction;
	public IllegalActionException(String actionName, String previousAction) {
		super(""Illegal route."");
		this.actionName = actionName;
		this.previousAction = previousAction;
	}
	@Override
	public String getMessage() {
		String errorContext = previousAction==null ? ""as the starting action."" : ""after action '""+previousAction+""'."";
		return super.getMessage() + ""The action '""+actionName+""' cannot be used ""+errorContext;
	}
}
"
org.apache.camel.spring.xml.ScriptDefinitionParser,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;
/**
 * A parser of the various scripting language expressions
 * @version $Revision: 1.1 $
 */
public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser {
    private final String scriptEngineName;
    public ScriptDefinitionParser(String scriptEngineName) {
        super(""org.apache.camel.builder.script.ScriptBuilder"", ""camel-script"");
        this.scriptEngineName = scriptEngineName;
    }
    @Override
    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
        // lets create a child context
        String engine = scriptEngineName;
        if (engine == null) {
            engine = element.getAttribute(""language"");
        }
        builder.addConstructorArg(engine);
        super.doParse(element, parserContext, builder);
        String scriptText = DomUtils.getTextValue(element).trim();
        if (scriptText.length() > 0) {
            builder.addPropertyValue(""scriptText"", scriptText);
        }
    }
}
"
org.apache.camel.component.xmpp.RuntimeXmppException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.jivesoftware.smack.XMPPException;
/**
 * A runtime exception thrown if sending or receiving from XMPP fails
 *
 * @version $Revision:520964 $
 */
public class RuntimeXmppException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeXmppException(XMPPException cause) {
        super(cause);
    }
    public RuntimeXmppException(String message, XMPPException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.xmpp.XmppGroupChatProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.GroupChat;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
/**
 * @version $Revision$
 */
public class XmppGroupChatProducer extends DefaultProducer {
    private static final transient Log log = LogFactory.getLog(XmppGroupChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String room;
    private GroupChat chat;
    public XmppGroupChatProducer(XmppEndpoint endpoint, String room) {
        super(endpoint);
        this.endpoint = endpoint;
        this.room = room;
        if (room == null) {
            throw new IllegalArgumentException(""No room property specified"");
        }
    }
    public void process(Exchange exchange) {
        // TODO it would be nice if we could reuse the message from the exchange
        Message message = chat.createMessage();
        message.setTo(room);
        message.setFrom(endpoint.getUser());
        endpoint.getBinding().populateXmppMessage(message, exchange);
        if (log.isDebugEnabled()) {
            log.debug("">>>> message: "" + message.getBody());
        }
        try {
            chat.sendMessage(message);
        }
        catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (chat == null) {
            chat = endpoint.getConnection().createGroupChat(room);
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (chat != null) {
            chat.leave();
            chat = null;
        }
        super.doStop();
    }
    // Properties
    //-------------------------------------------------------------------------
    public GroupChat getChat() {
        return chat;
    }
    public void setChat(GroupChat chat) {
        this.chat = chat;
    }
    public String getRoom() {
        return room;
    }
}
"
org.apache.camel.component.jms.JmsIOConverter,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.util.Enumeration;
import javax.jms.BytesMessage;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.MessageEOFException;
import javax.jms.ObjectMessage;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import org.apache.camel.Converter;
import org.apache.camel.converter.NIOConverter;
/**
 * Some simple payload conversions to I/O 
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 533630 $
 */
@Converter
public class JmsIOConverter{
    /**
     * @param message
     * @return a ByteBuffer
     * @throws Exception
     */
    @Converter
    public static ByteBuffer toByteBuffer(final Message message) throws Exception {
        if (message instanceof TextMessage) {
            final String text = ((TextMessage)message).getText();
            return NIOConverter.toByteBuffer(text);
        }
        if (message instanceof BytesMessage) {
            final BytesMessage bmsg = (BytesMessage)message;
            final int len = (int)bmsg.getBodyLength();
            final byte[] data = new byte[len];
            bmsg.readBytes(data,len);
            return NIOConverter.toByteBuffer(data);
        }
        if (message instanceof StreamMessage) {
            final StreamMessage msg = (StreamMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            try {
                while (true) {
                    final Object obj = msg.readObject();
                    writeData(dataOut,obj);
                }
            }catch(MessageEOFException e) {
                //we have no other way of knowing the end of the message
            }
            dataOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof MapMessage) {
            final MapMessage msg = (MapMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            for (final Enumeration en = msg.getMapNames(); en.hasMoreElements();) {
                final Object obj = msg.getObject(en.nextElement().toString());
                writeData(dataOut,obj);
            }
            dataOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof ObjectMessage) {
            ObjectMessage objMessage = (ObjectMessage)message;
            Object object = objMessage.getObject();
            ByteArrayOutputStream bytesOut=new ByteArrayOutputStream();
            ObjectOutputStream objectOut=new ObjectOutputStream(bytesOut);
            objectOut.writeObject(object);
            objectOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        return null;
    }
    private static void writeData(DataOutputStream dataOut, Object data) throws Exception {
        if (data instanceof byte[]) {
            dataOut.write((byte[])data);
        }else if (data instanceof String) {
            dataOut.writeUTF(data.toString());
        }
        else if (data instanceof Double) {
            dataOut.writeDouble(((Double)data).doubleValue());
        }else if (data instanceof Float) {
            dataOut.writeFloat(((Float)data).floatValue());
        }else if (data instanceof Long) {
            dataOut.writeLong(((Long)data).longValue());
        }else if (data instanceof Integer) {
            dataOut.writeInt(((Integer)data).intValue());
        }else if (data instanceof Short) {
            dataOut.writeShort(((Short)data).shortValue());
        }else if (data instanceof Character) {
            dataOut.writeChar(((Character)data).charValue());
        }else if (data instanceof Byte) {
            dataOut.writeByte(((Byte)data).byteValue());
        }else if (data instanceof Boolean) {
            dataOut.writeBoolean(((Boolean)data).booleanValue());
        }
    }
}
"
org.apache.camel.component.rmi.RmiConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.rmi.Remote;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.component.pojo.PojoExchange;
import org.apache.camel.component.pojo.PojoInvocation;
import org.apache.camel.impl.DefaultConsumer;
/**
 * A {@link Consumer} which uses RMI's {@see UnicastRemoteObject} to consume method invocations.
 *
 * @version $Revision: 533758 $
 */
public class RmiConsumer extends DefaultConsumer<PojoExchange> implements InvocationHandler {
	private final RmiEndpoint endpoint;
	private Remote stub;
	private Remote proxy;
	public RmiConsumer(RmiEndpoint endpoint, Processor processor) {
		super(endpoint, processor);
		this.endpoint = endpoint;
	}
	@Override
	protected void doStart() throws Exception {
		Class[] interfaces = new Class[endpoint.getRemoteInterfaces().size()];
		endpoint.getRemoteInterfaces().toArray(interfaces);
		proxy = (Remote) Proxy.newProxyInstance(endpoint.getClassLoader(), interfaces, this);
		stub = UnicastRemoteObject.exportObject(proxy,endpoint.getPort());
        try { 
    		Registry registry = endpoint.getRegistry();
        	String name = endpoint.getName();        	
			registry.bind(name, stub);
		} catch (Exception e) { // Registration might fail.. clean up..
			try { 
				UnicastRemoteObject.unexportObject(stub, true);
			} catch (Throwable e1) {
			}
			stub=null;
			throw e;
		}
        super.doStart();
	}
	@Override
	protected void doStop() throws Exception {
		super.doStop();
		try {
	        Registry registry = endpoint.getRegistry();
	        registry.unbind(endpoint.getName());
		} catch( Throwable e ) { // do our best to unregister
		}
		UnicastRemoteObject.unexportObject(proxy, true);		
	}
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (!isStarted()) {
            throw new IllegalStateException(""The endpoint is not active: "" + getEndpoint().getEndpointUri());
        }
        PojoInvocation invocation = new PojoInvocation(proxy, method, args);
        PojoExchange exchange = getEndpoint().createExchange();
        exchange.setInvocation(invocation);
        getProcessor().process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        return exchange.getOut().getBody();
	}
	public Remote getProxy() {
		return proxy;
	}
	public Remote getStub() {
		return stub;
	}
}
"
org.apache.camel.spring.spi.SpringTransactionPolicy,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Exchange;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.spi.Policy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * Wraps the processor in a Spring transaction
 *
 * @version $Revision: 1.1 $
 */
public class SpringTransactionPolicy<E> implements Policy<E> {
    private static final transient Log log = LogFactory.getLog(SpringTransactionPolicy.class);
    private TransactionTemplate template;
    public SpringTransactionPolicy() {
    }
    public SpringTransactionPolicy(TransactionTemplate template) {
        this.template = template;
    }
    public Processor wrap(Processor processor) {
        final TransactionTemplate transactionTemplate = getTemplate();
        if (transactionTemplate == null) {
            log.warn(""No TransactionTemplate available so transactions will not be enabled!"");
            return processor;
        }
        return new DelegateProcessor(processor) {
            public void process(final Exchange exchange) {
                transactionTemplate.execute(new TransactionCallbackWithoutResult() {
                    protected void doInTransactionWithoutResult(TransactionStatus status) {
                        try {
							processNext(exchange);
						} catch (Exception e) {
							throw new RuntimeCamelException(e);
						}
                    }
                });
            }
            @Override
            public String toString() {
                return ""SpringTransactionPolicy:""+propagationBehaviorToString(transactionTemplate.getPropagationBehavior())+""["" + getNext() + ""]"";
            }
			private String propagationBehaviorToString(int propagationBehavior) {
				switch( propagationBehavior ) {
				case TransactionDefinition.PROPAGATION_MANDATORY:
					return ""PROPAGATION_MANDATORY"";
				case TransactionDefinition.PROPAGATION_NESTED:
					return ""PROPAGATION_NESTED"";
				case TransactionDefinition.PROPAGATION_NEVER:
					return ""PROPAGATION_NEVER"";
				case TransactionDefinition.PROPAGATION_NOT_SUPPORTED:
					return ""PROPAGATION_NOT_SUPPORTED"";
				case TransactionDefinition.PROPAGATION_REQUIRED:
					return ""PROPAGATION_REQUIRED"";
				case TransactionDefinition.PROPAGATION_REQUIRES_NEW:
					return ""PROPAGATION_REQUIRES_NEW"";
				case TransactionDefinition.PROPAGATION_SUPPORTS:
					return ""PROPAGATION_SUPPORTS"";
				}
				return ""UNKOWN"";
			}
        };
    }
    public TransactionTemplate getTemplate() {
        return template;
    }
    public void setTemplate(TransactionTemplate template) {
        this.template = template;
    }
}
"
org.apache.camel.component.jbi.JbiEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
/**
 * Represents an {@link Endpoint} for interacting with JBI
 *
 * @version $Revision$
 */
public class JbiEndpoint extends DefaultEndpoint<Exchange> {
    private Processor toJbiProcessor;
    private final CamelJbiComponent jbiComponent;
    public JbiEndpoint(CamelJbiComponent jbiComponent, String uri) {
        super(uri, jbiComponent);
        this.jbiComponent = jbiComponent;
        toJbiProcessor = new ToJbiProcessor(jbiComponent.getBinding(), jbiComponent.getComponentContext(), uri);
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
		    public void process(Exchange exchange) throws Exception {
		        toJbiProcessor.process(exchange);
		    }
		};
    }
    public Consumer<Exchange> createConsumer(final Processor processor) throws Exception {
        return new DefaultConsumer<Exchange>(this, processor) {
            CamelJbiEndpoint jbiEndpoint;
            @Override
            protected void doStart() throws Exception {
                super.doStart();
                jbiEndpoint = jbiComponent.activateJbiEndpoint(JbiEndpoint.this, processor);
            }
            @Override
            protected void doStop() throws Exception {
/*
                if (jbiEndpoint != null) {
                    jbiEndpoint.deactivate();
                }
*/
                super.doStop();
            }
        };
    }
    public JbiExchange createExchange() {
        return new JbiExchange(getContext(), getBinding());
    }
    public JbiBinding getBinding() {
        return jbiComponent.getBinding();
    }
	public boolean isSingleton() {
		return true;
	}
}
"
org.apache.camel.bam.rules.ActivityRules,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import org.apache.camel.Exchange;
import org.apache.camel.bam.ProcessBuilder;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.ArrayList;
import java.util.List;
/**
 * Represents a activity which is typically a system or could be an endpoint
 *
 * @version $Revision: $
 */
public class ActivityRules extends ServiceSupport {
    private static final transient Log log = LogFactory.getLog(ActivityRules.class);
    private int expectedMessages = 1;
    private ProcessRules processRules;
    private List<TemporalRule> rules = new ArrayList<TemporalRule>();
    private ActivityDefinition activityDefinition;
    private String activityName;
    private final org.apache.camel.bam.ProcessBuilder builder;
    public ActivityRules(ProcessBuilder builder) {
        this.builder = builder;
        this.processRules = builder.getProcessRules();
        processRules.getActivities().add(this);
    }
    public void addRule(TemporalRule rule) {
        rules.add(rule);
    }
    /**
     * Handles overdue activities
     */
    public void processExpired(ActivityState activityState) throws Exception {
        for (TemporalRule rule : rules) {
            rule.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (TemporalRule rule : rules) {
            rule.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public ActivityDefinition getActivityDefinition() {
        if (activityDefinition == null) {
            activityDefinition = builder.findOrCreateActivityDefinition(activityName);
        }
        return activityDefinition;
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public int getExpectedMessages() {
        return expectedMessages;
    }
    public void setExpectedMessages(int expectedMessages) {
        this.expectedMessages = expectedMessages;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public void setActivityName(String activityName) {
        this.activityName = activityName;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(rules);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(rules);
    }
}
"
org.apache.camel.component.cxf.CxfInvokeProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.frontend.ClientFactoryBean;
import java.util.List;
/**
 * Sends messages from Camel into the CXF endpoint
 *
 * @version $Revision$
 */
public class CxfInvokeProducer extends DefaultProducer {
    private CxfInvokeEndpoint endpoint;
    private Client client;
    public CxfInvokeProducer(CxfInvokeEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) {
        CxfExchange cxfExchange = endpoint.toExchangeType(exchange);
        process(cxfExchange);
        exchange.copyFrom(cxfExchange);
    }
    public void process(CxfExchange exchange) {
        List params = exchange.getIn().getBody(List.class);
        Object[] response = null;
        try {
            response = client.invoke(endpoint.getProperty(CxfConstants.METHOD), params.toArray());
        }                                                           
        catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
        CxfBinding binding = endpoint.getBinding();
        binding.storeCxfResponse(exchange, response);
    }
    @Override
    protected void doStart() throws Exception {
        // TODO Add support for sending message inputstream.  Currently, we only handle
        // method invocation with pojo.
        // TODO Add support for endpoints associated with a WSDL
        if (client == null) {
            ClientFactoryBean cfBean = new ClientFactoryBean();
            cfBean.setAddress(getEndpoint().getEndpointUri());
            cfBean.setBus(endpoint.getBus());
            cfBean.setServiceClass(Class.forName(endpoint.getProperty(CxfConstants.SEI)));
            client = cfBean.create();
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (client != null) {
            client.getConduit().close();
            client = null;
        }
        super.doStop();
    }
}
"
org.apache.camel.spring.remoting.CamelProxyFactoryBean,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.component.pojo.PojoComponent;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.remoting.support.UrlBasedRemoteAccessor;
/**
 * Creates a Proxy to Camel Pojo Endpoint.
 *  
 * @author chirino
 */
public class CamelProxyFactoryBean extends UrlBasedRemoteAccessor implements FactoryBean {
	private CamelContext camelContext;
	private Endpoint endpoint;
	private Object serviceProxy;
	@Override
	public void afterPropertiesSet() {
		super.afterPropertiesSet();
		try {
			if( endpoint == null ) {
				if( getServiceUrl() == null || camelContext==null ) {
					throw new IllegalArgumentException(""If endpoint is not specified, the serviceUrl and camelContext must be specified."");
				}
				endpoint = camelContext.getEndpoint(getServiceUrl());
				if( endpoint == null ) {
					throw new IllegalArgumentException(""Could not resolve endpoint: ""+getServiceUrl());
				}
			}
			this.serviceProxy = PojoComponent.createProxy(endpoint, getServiceInterface());
		} catch (Exception e) {
			throw new IllegalArgumentException(e);
		}
	}
	public Object getObject() throws Exception {
		return serviceProxy;
	}
	public Class getObjectType() {
		return getServiceInterface();
	}
	public boolean isSingleton() {
		return true;
	}
	public Endpoint getEndpoint() {
		return endpoint;
	}
	public void setEndpoint(Endpoint endpoint) {
		this.endpoint = endpoint;
	}
	public CamelContext getCamelContext() {
		return camelContext;
	}
	public void setCamelContext(CamelContext camelContext) {
		this.camelContext = camelContext;
	}
}
"
org.apache.camel.spring.component.BeanComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.component;
import org.apache.camel.Endpoint;
import org.apache.camel.component.pojo.PojoEndpoint;
import org.apache.camel.impl.DefaultComponent;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import java.util.Map;
/**
 * An alternative to the <a href=""http://activemq.apache.org/pojo.html"">POJO Component</a>
 * which implements the <a href=""http://activemq.apache.org/bean.html"">Bean Component</a>
 * which will look up the URI in the Spring ApplicationContext and use that to handle message dispatching.
 * 
 * @version $Revision: 1.1 $
 */
public class BeanComponent extends DefaultComponent implements ApplicationContextAware {
    private ApplicationContext applicationContext;
    public BeanComponent() {
    }
    public BeanComponent(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        notNull(applicationContext, ""applicationContext"");
        Object object = applicationContext.getBean(remaining);
        if (object != null) {
            return new PojoEndpoint(uri, this, object);
        }
        return null;
    }
}
"
org.apache.camel.component.quartz.QuartzMessage,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.impl.DefaultMessage;
import org.quartz.JobExecutionContext;
import org.quartz.Trigger;
import java.util.Map;
/**
 * @version $Revision: 1.1 $
 */
public class QuartzMessage extends DefaultMessage {
    private final JobExecutionContext jobExecutionContext;
    public QuartzMessage(QuartzExchange exchange, JobExecutionContext jobExecutionContext) {
        this.jobExecutionContext = jobExecutionContext;
        setExchange(exchange);
        setBody(jobExecutionContext.getJobDetail());
    }
    public JobExecutionContext getJobExecutionContext() {
        return jobExecutionContext;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        super.populateInitialHeaders(map);
        if (jobExecutionContext != null) {
            map.put(""calendar"", jobExecutionContext.getCalendar());
            map.put(""fireTime"", jobExecutionContext.getFireTime());
            map.put(""jobDetail"", jobExecutionContext.getJobDetail());
            map.put(""jobInstance"", jobExecutionContext.getJobInstance());
            map.put(""jobRunTime"", jobExecutionContext.getJobRunTime());
            map.put(""mergedJobDataMap"", jobExecutionContext.getMergedJobDataMap());
            map.put(""nextFireTime"", jobExecutionContext.getNextFireTime());
            map.put(""previousFireTime"", jobExecutionContext.getPreviousFireTime());
            map.put(""refireCount"", jobExecutionContext.getRefireCount());
            map.put(""result"", jobExecutionContext.getResult());
            map.put(""scheduledFireTime"", jobExecutionContext.getScheduledFireTime());
            map.put(""scheduler"", jobExecutionContext.getScheduler());
            Trigger trigger = jobExecutionContext.getTrigger();
            map.put(""trigger"", trigger);
            map.put(""triggerName"", trigger.getName());
            map.put(""triggerGroup"", trigger.getGroup());
        }
    }
}
"
org.apache.camel.component.xmpp.XmppPrivateChatProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.Chat;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
/**
 * @version $Revision$
 */
public class XmppPrivateChatProducer extends DefaultProducer {
    private static final transient Log log = LogFactory.getLog(XmppPrivateChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String participant;
    private Chat chat;
    public XmppPrivateChatProducer(XmppEndpoint endpoint, String participant) {
        super(endpoint);
        this.endpoint = endpoint;
        this.participant = participant;
        if (participant == null) {
            throw new IllegalArgumentException(""No participant property specified"");
        }
    }
    public void process(Exchange exchange) {
        // TODO it would be nice if we could reuse the message from the exchange
        Message message = chat.createMessage();
        message.setTo(participant);
        message.setFrom(endpoint.getUser());
        message.setThread(exchange.getExchangeId());
        message.setType(Message.Type.NORMAL);
        endpoint.getBinding().populateXmppMessage(message, exchange);
        if (log.isDebugEnabled()) {
            log.debug("">>>> message: "" + message.getBody());
        }
        try {
            chat.sendMessage(message);
        }
        catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (chat == null) {
            chat = endpoint.getConnection().createChat(getParticipant());
        }
    }
    @Override
    protected void doStop() throws Exception {
        chat = null;
        super.doStop();
    }
    // Properties
    //-------------------------------------------------------------------------
    public Chat getChat() {
        return chat;
    }
    public void setChat(Chat chat) {
        this.chat = chat;
    }
    public String getParticipant() {
        return participant;
    }
}
"
org.apache.camel.bam.rules.TemporalRule,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.bam.TimeExpression;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.builder.FromBuilder;
import org.apache.camel.builder.ProcessorFactory;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.ServiceSupport;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;
import org.apache.camel.util.Time;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.Date;
/**
 * A temporal rule for use within BAM
 *
 * @version $Revision: $
 */
public class TemporalRule extends ServiceSupport {
    private static final transient Log log = LogFactory.getLog(TemporalRule.class);
    private TimeExpression first;
    private TimeExpression second;
    private long expectedMillis;
    private long overdueMillis;
    private Processor overdueAction;
    private ProcessorFactory overdueProcessorFactory;
    public TemporalRule(TimeExpression first, TimeExpression second) {
        this.first = first;
        this.second = second;
    }
    public TemporalRule expectWithin(Time builder) {
        return expectWithin(builder.toMillis());
    }
    public TemporalRule expectWithin(long millis) {
        expectedMillis = millis;
        return this;
    }
    public FromBuilder errorIfOver(Time builder) {
        return errorIfOver(builder.toMillis());
    }
    public FromBuilder errorIfOver(long millis) {
        overdueMillis = millis;
        FromBuilder builder = new FromBuilder(second.getBuilder().getProcessBuilder(), null);
        overdueProcessorFactory = builder;
        return builder;
    }
    public TimeExpression getFirst() {
        return first;
    }
    public TimeExpression getSecond() {
        return second;
    }
    public Processor getOverdueAction() throws Exception {
        if (overdueAction == null && overdueProcessorFactory != null) {
            overdueAction = overdueProcessorFactory.createProcessor();
        }
        return overdueAction;
    }
    public void processExchange(Exchange exchange, ProcessInstance instance) {
        Date firstTime = first.evaluate(instance);
        if (firstTime == null) {
            // ignore as first event has not accurred yet
            return;
        }
        // TODO now we might need to set the second activity state
        // to 'grey' to indicate it now could happen?
        // lets force the lazy creation of the second state
        ActivityState secondState = second.getOrCreateActivityState(instance);
        if (expectedMillis > 0L) {
            Date expected = secondState.getTimeExpected();
            if (expected == null) {
                expected = add(firstTime, expectedMillis);
                secondState.setTimeExpected(expected);
            }
        }
        if (overdueMillis > 0L) {
            Date overdue = secondState.getTimeOverdue();
            if (overdue == null) {
                overdue = add(firstTime, overdueMillis);
                secondState.setTimeOverdue(overdue);
            }
        }
    }
    public void processExpired(ActivityState activityState) throws Exception {
        Processor processor = getOverdueAction();
        if (processor != null) {
            Date now = new Date();
/*
            TODO this doesn't work and returns null for some strange reason
            ProcessInstance instance = activityState.getProcessInstance();
            ActivityState secondState = second.getActivityState(instance);
            if (secondState == null) {
                log.error(""Could not find the second state! Process is: "" + instance + "" with first state: "" + first.getActivityState(instance) + "" and the state I was called with was: "" + activityState);
            }
*/
            ActivityState secondState = activityState;
            Date overdue = secondState.getTimeOverdue();
            if (now.compareTo(overdue) >= 0) {
                Exchange exchange = createExchange();
                exchange.getIn().setBody(activityState);
                processor.process(exchange);
            }
            else {
                log.warn(""Process has not actually expired; the time is: "" + now + "" but the overdue time is: "" + overdue);
            }
        }
    }
    protected Exchange createExchange() {
        return new DefaultExchange(second.getBuilder().getProcessBuilder().getContext());
    }
    /**
     * Returns the date in the future adding the given number of millis
     *
     * @param date
     * @param millis
     * @return the date in the future
     */
    protected Date add(Date date, long millis) {
        return new Date(date.getTime() + millis);
    }
    protected void doStart() throws Exception {
        startServices(getOverdueAction());
    }
    protected void doStop() throws Exception {
        stopServices(getOverdueAction());
    }
}
"
org.apache.camel.spring.xml.MethodInfo,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import java.lang.reflect.Method;
import java.util.LinkedHashMap;
import org.apache.camel.builder.Fluent;
import org.apache.camel.builder.FluentArg;
public class MethodInfo {
	final Method method;
	final Fluent methodAnnotation;
	final LinkedHashMap<String, Class> parameters;
	final LinkedHashMap<String, FluentArg> parameterAnnotations;
	public MethodInfo(Method method, Fluent fluentAnnotation, LinkedHashMap<String, Class> parameters, LinkedHashMap<String, FluentArg> annotations) {
		this.method=method;
		this.methodAnnotation = fluentAnnotation;
		this.parameters=parameters;
		this.parameterAnnotations = annotations;
	}
	public String getName() {
		return method.getName();
	}
}"
org.apache.camel.component.cxf.CxfBinding,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import java.io.InputStream;
import java.util.Set;
/**
 * The binding of how Camel messages get mapped to Apache CXF and back again
 *
 * @version $Revision$
 */
public class CxfBinding {
    public Object extractBodyFromCxf(CxfExchange exchange, Message message) {
        //  TODO how do we choose a format?
        return getBody(message);
    }
    protected Object getBody(Message message) {
        Set<Class<?>> contentFormats = message.getContentFormats();
        for (Class<?> contentFormat : contentFormats) {
            Object answer = message.getContent(contentFormat);
            if (answer != null) {
                return answer;
            }
        }
        return null;
    }
    public MessageImpl createCxfMessage(CxfExchange exchange) {
        MessageImpl answer = (MessageImpl) exchange.getInMessage();
        // TODO is InputStream the best type to give to CXF?
        CxfMessage in = exchange.getIn();
        Object body = in.getBody(InputStream.class);
        if (body == null) {
            body = in.getBody();
        }
        answer.setContent(InputStream.class, body);
        // no need to process headers as we reuse the CXF message
        /*
        // set the headers
        Set<Map.Entry<String, Object>> entries = in.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            answer.put(entry.getKey(), entry.getValue());
        }
        */
        return answer;
    }
    public void storeCxfResponse(CxfExchange exchange, Message response) {
        // no need to process headers as we use the CXF message
        CxfMessage out = exchange.getOut();
        if (response != null) {
            out.setMessage(response);
            out.setBody(getBody(response));
        }
    }
    public void storeCxfResponse(CxfExchange exchange, Object response) {
        CxfMessage out = exchange.getOut();
        if (response != null) {
            out.setBody(response);
        }
    }
}
"
org.apache.camel.component.jms.JmsProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.MessageCreator;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
/**
 * @version $Revision$
 */
public class JmsProducer extends DefaultProducer {
    private static final transient Log log = LogFactory.getLog(JmsProducer.class);
    private final JmsEndpoint endpoint;
    private final JmsOperations template;
    public JmsProducer(JmsEndpoint endpoint, JmsOperations template) {
        super(endpoint);
        this.endpoint = endpoint;
        this.template = template;
    }
    public void process(final Exchange exchange) {
        template.send(endpoint.getDestination(), new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                Message message = endpoint.getBinding().makeJmsMessage(exchange, session);
                if (log.isDebugEnabled()) {
                    log.debug(endpoint + "" sending JMS message: "" + message);
                }
                return message;
            }
        });
    }
    public JmsOperations getTemplate() {
        return template;
    }
}
"
org.apache.camel.bam.model.ActivityState,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import org.apache.camel.bam.processor.ProcessContext;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.ObjectHelper;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import java.util.Date;
/**
 * The default state for a specific activity within a process
 *
 * @version $Revision: $
 */
@Entity
public class ActivityState extends TemporalEntity {
    private ProcessInstance processInstance;
    private Integer receivedMessageCount = 0;
    private ActivityDefinition activityDefinition;
    private Date timeExpected;
    private Date timeOverdue;
    private Integer escalationLevel = 0;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""ActivityState["" + getId() + "" "" + getActivityDefinition() + ""]"";
    }
    public synchronized void processExchange(ActivityRules activityRules, ProcessContext context) throws Exception {
        int messageCount = 0;
        Integer count = getReceivedMessageCount();
        if (count != null) {
            messageCount = count.intValue();
        }
        setReceivedMessageCount(++messageCount);
        if (messageCount == 1) {
            onFirstMessage(context);
        }
        int expectedMessages = activityRules.getExpectedMessages();
        if (messageCount == expectedMessages) {
            onExpectedMessage(context);
        }
        else if (messageCount > expectedMessages) {
            onExcessMessage(context);
        }
    }
    /**
     * Returns true if this state is for the given activity
     */
    public boolean isActivity(ActivityRules activityRules) {
        return ObjectHelper.equals(getActivityDefinition(), activityRules.getActivityDefinition());
    }
    // Properties
    //-----------------------------------------------------------------------
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST})
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
        processInstance.getActivityStates().add(this);
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST})
    public ActivityDefinition getActivityDefinition() {
        return activityDefinition;
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public Integer getEscalationLevel() {
        return escalationLevel;
    }
    public void setEscalationLevel(Integer escalationLevel) {
        this.escalationLevel = escalationLevel;
    }
    public Integer getReceivedMessageCount() {
        return receivedMessageCount;
    }
    public void setReceivedMessageCount(Integer receivedMessageCount) {
        this.receivedMessageCount = receivedMessageCount;
    }
    public Date getTimeExpected() {
        return timeExpected;
    }
    public void setTimeExpected(Date timeExpected) {
        this.timeExpected = timeExpected;
    }
    public Date getTimeOverdue() {
        return timeOverdue;
    }
    public void setTimeOverdue(Date timeOverdue) {
        this.timeOverdue = timeOverdue;
    }
    public void setTimeCompleted(Date timeCompleted) {
        super.setTimeCompleted(timeCompleted);
        if (timeCompleted != null) {
            setEscalationLevel(-1);
        }
    }
    // Implementation methods
    //-----------------------------------------------------------------------
    /**
     * Called when the first message is reached
     */
    protected void onFirstMessage(ProcessContext context) {
        if (!isStarted()) {
            setTimeStarted(currentTime());
            context.onStarted(this);
        }
    }
    /**
     * Called when the expected number of messages are is reached
     */
    protected void onExpectedMessage(ProcessContext context) {
        if (!isCompleted()) {
            setTimeCompleted(currentTime());
            context.onCompleted(this);
        }
    }
    /**
     * Called when an excess message (after the expected number of messages)
     * are received
     */
    protected void onExcessMessage(ProcessContext context) {
        // TODO
    }
    protected Date currentTime() {
        return new Date();
    }
}"
org.apache.camel.component.cxf.CxfExchange,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultExchange;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
/**
 * An {@link Exchange} for working with Apache CXF which expoes the underlying
 * CXF messages via {@link #getInMessage()} and {@link #getOutMessage()} along with the
 * {@link #getExchange()} 
 *
 * @version $Revision$
 */
public class CxfExchange extends DefaultExchange {
    private final CxfBinding binding;
    private Exchange exchange;
    public CxfExchange(CamelContext context, CxfBinding binding) {
        super(context);
        this.binding = binding;
    }
    public CxfExchange(CamelContext context, CxfBinding binding, Exchange exchange) {
        super(context);
        this.binding = binding;
        this.exchange = exchange;
        setIn(new CxfMessage(exchange.getInMessage()));
        setOut(new CxfMessage(exchange.getOutMessage()));
        setFault(new CxfMessage(exchange.getInFaultMessage()));
    }
    public CxfExchange(CamelContext context, CxfBinding binding, Message inMessage) {
        super(context);
        this.binding = binding;
        this.exchange = inMessage.getExchange();
        setIn(new CxfMessage(inMessage));
        if (exchange != null) {
            setOut(new CxfMessage(exchange.getOutMessage()));
            setFault(new CxfMessage(exchange.getInFaultMessage()));
        }
    }
    @Override
    public CxfMessage getIn() {
        return (CxfMessage) super.getIn();
    }
    @Override
    public CxfMessage getOut() {
        return (CxfMessage) super.getOut();
    }
    @Override
    public CxfMessage getOut(boolean lazyCreate) {
        return (CxfMessage) super.getOut(lazyCreate);
    }
    @Override
    public CxfMessage getFault() {
        return (CxfMessage) super.getFault();
    }
    /**
     * @return the Camel <-> JBI binding
     */
    public CxfBinding getBinding() {
        return binding;
    }
    // Expose CXF APIs directly on the exchange
    //-------------------------------------------------------------------------
    /**
     * Returns the underlying CXF message exchange for an inbound exchange
     * or null for outbound messages
     *
     * @return the inbound message exchange
     */
    public Exchange getExchange() {
        return exchange;
    }
    public Message getInMessage() {
        return getIn().getMessage();
    }
    public Message getOutMessage() {
        return getOut().getMessage();
    }
    public Message getOutFaultMessage() {
        return getExchange().getOutFaultMessage();
    }
    public Message getInFaultMessage() {
        return getExchange().getInFaultMessage();
    }
    public Destination getDestination() {
        return getExchange().getDestination();
    }
    public Conduit getConduit(Message message) {
        return getExchange().getConduit(message);
    }
    @Override
    protected CxfMessage createInMessage() {
        return new CxfMessage();
    }
    @Override
    protected CxfMessage createOutMessage() {
        return new CxfMessage();
    }
}
"
org.apache.camel.spring.spi.SpringInjector,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.spi.Injector;
import org.apache.camel.impl.ReflectionInjector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
/**
 * A Spring implementation of {@link Injector} allowing Spring to be used to dependency inject newly created POJOs
 *
 * @version $Revision$
 */
public class SpringInjector extends ReflectionInjector {
    private static final transient Log log = LogFactory.getLog(SpringInjector.class);
    private final AbstractRefreshableApplicationContext applicationContext;
    private int autowireMode = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;
    private boolean dependencyCheck = false;
    public SpringInjector(AbstractRefreshableApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public Object newInstance(Class type) {
        // TODO support annotations for mandatory injection points?
        return applicationContext.getBeanFactory().createBean(type, autowireMode, dependencyCheck);
    }
    public int getAutowireMode() {
        return autowireMode;
    }
    public void setAutowireMode(int autowireMode) {
        this.autowireMode = autowireMode;
    }
    public boolean isDependencyCheck() {
        return dependencyCheck;
    }
    public void setDependencyCheck(boolean dependencyCheck) {
        this.dependencyCheck = dependencyCheck;
    }
}
"
org.apache.camel.component.jms.MessageListenerProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import javax.jms.Message;
import javax.jms.MessageListener;
/**
 * Represents a JMS {@link MessageListener} which can be used directly with any JMS template
 * or derived from to create an MDB for processing messages using a {@link Processor}
 *
 * @version $Revision:520964 $
 */
public class MessageListenerProcessor implements MessageListener {
    private final JmsEndpoint endpoint;
    private final Processor processor;
    public MessageListenerProcessor(JmsEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    public void onMessage(Message message) {
        try {
			Exchange exchange = endpoint.createExchange(message);
			processor.process(exchange);
		} catch (Exception e) {
			throw new RuntimeCamelException(e);
		}
    }
}
"
org.apache.camel.component.http.HttpExchange,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultExchange;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * Represents a HTTP exchange which exposes the underlying HTTP abtractions via
 * {@link #getRequest()} and {@link #getResponse()} 
 *
 * @version $Revision$
 */
public class HttpExchange extends DefaultExchange {
    private final HttpEndpoint endpoint;
    private HttpServletRequest request;
    private HttpServletResponse response;
    public HttpExchange(HttpEndpoint endpoint) {
        super(endpoint.getContext());
        this.endpoint = endpoint;
    }
    public HttpExchange(HttpEndpoint endpoint, HttpServletRequest request, HttpServletResponse response) {
        this(endpoint);
        this.request = request;
        this.response = response;
        setIn(new HttpMessage(this, request));
    }
    /**
     * Returns the underlying Servlet request for inbound HTTP requests
     *
     * @return the underlying Servlet request for inbound HTTP requests
     */
    public HttpServletRequest getRequest() {
        return request;
    }
    /**
     * Returns the underlying Servlet response for inbound HTTP requests
     *
     * @return the underlying Servlet response for inbound HTTP requests
     */
    public HttpServletResponse getResponse() {
        return response;
    }
    public HttpEndpoint getEndpoint() {
        return endpoint;
    }
}
"
org.apache.camel.component.jms.MessagePropertyAccessException,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -3996286386119163309L;
    private String propertyName;
    public MessagePropertyAccessException(String propertyName, JMSException e) {
        super(""Error accessing header: "" + propertyName, e);
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.component.mina.MinaConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
import java.net.SocketAddress;
/**
 * A @{link Consumer} for MINA
 *
 * @version $Revision$
 */
public class MinaConsumer extends DefaultConsumer<MinaExchange> {
    private static final transient Log log = LogFactory.getLog(MinaConsumer.class);
    private final MinaEndpoint endpoint;
    private final SocketAddress address;
    private final IoAcceptor acceptor;
    public MinaConsumer(final MinaEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
         address = endpoint.getAddress();
         acceptor = endpoint.getAcceptor();
    }
    @Override
    protected void doStart() throws Exception {
        if (log.isDebugEnabled()) {
            log.debug(""Binding to server address: "" + address + "" using acceptor: "" + acceptor);
        }
        IoHandler handler = new IoHandlerAdapter() {
            @Override
            public void messageReceived(IoSession session, Object object) throws Exception {
                getProcessor().process(endpoint.createExchange(session, object));
            }
        };
        acceptor.bind(address, handler, endpoint.getConfig());
    }
    @Override
    protected void doStop() throws Exception {
        acceptor.unbind(address);
        super.doStop();
    }
}
"
org.apache.camel.converter.jaxb.JaxbConverter,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import org.apache.camel.converter.HasAnnotation;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.w3c.dom.Document;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.util.JAXBSource;
import javax.xml.parsers.ParserConfigurationException;
/**
 * @version $Revision$
 */
public class JaxbConverter {
    private XmlConverter jaxbConverter;
    public XmlConverter getJaxbConverter() {
        if (jaxbConverter == null) {
            jaxbConverter = new XmlConverter();
        }
        return jaxbConverter;
    }
    public void setJaxbConverter(XmlConverter jaxbConverter) {
        this.jaxbConverter = jaxbConverter;
    }
    public static JAXBSource toSource(@HasAnnotation(XmlRootElement.class)Object value) throws JAXBException {
        JAXBContext context = createJaxbContext(value);
        return new JAXBSource(context, value);
    }
    public Document toDocument(@HasAnnotation(XmlRootElement.class)Object value) throws JAXBException, ParserConfigurationException {
        JAXBContext context = createJaxbContext(value);
        Marshaller marshaller = context.createMarshaller();
        Document doc = getJaxbConverter().createDocument();
        marshaller.marshal(value, doc);
        return doc;
    }
    protected static JAXBContext createJaxbContext(Object value) throws JAXBException {
        if (value == null) {
            throw new IllegalArgumentException(""Cannot convert from null value to JAXBSource"");
        }
        JAXBContext context = JAXBContext.newInstance(value.getClass());
        return context;
    }
/*
    public void write(OutputStream out, Object value) throws JAXBException {
        JAXBContext context = JAXBContext.newInstance(value.getClass());
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
		marshaller.marshal(value, out);
    }
*/
}
"
org.apache.camel.component.xmpp.XmppEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.AccountManager;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketFilter;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Presence;
/**
 * An XMPP Endpoint
 *
 * @version $Revision:520964 $
 */
public class XmppEndpoint extends DefaultEndpoint<XmppExchange> {
    private static final transient Log log = LogFactory.getLog(XmppEndpoint.class);
    private XmppBinding binding;
    private XMPPConnection connection;
    private String host;
    private int port;
    private String user;
    private String password;
    private String resource = ""Camel"";
    private boolean login = true;
    private PacketFilter filter;
    private boolean createAccount;
    private String room;
    private String participant;
    public XmppEndpoint(String uri, XmppComponent component) {
        super(uri, component);
    }
    public Producer<XmppExchange> createProducer() throws Exception {
        if (room != null) {
            return createGroupChatProducer(room);
        }
        else {
            if (participant == null) {
                throw new IllegalArgumentException(""No room or participant configured on this endpoint: "" + this);
            }
            return createPrivateChatProducer(participant);
        }
    }
    public Producer<XmppExchange> createGroupChatProducer(String room) throws Exception {
        return new XmppGroupChatProducer(this, room);
    }
    public Producer<XmppExchange> createPrivateChatProducer(String participant) throws Exception {
        return new XmppPrivateChatProducer(this, participant);
    }
    public Consumer<XmppExchange> createConsumer(Processor processor) throws Exception {
        return new XmppConsumer(this, processor);
    }
    public XmppExchange createExchange() {
        return new XmppExchange(getContext(), getBinding());
    }
    public XmppExchange createExchange(Message message) {
        return new XmppExchange(getContext(), getBinding(), message);
    }
    // Properties
    //-------------------------------------------------------------------------
    public XmppBinding getBinding() {
        if (binding == null) {
            binding = new XmppBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from an XMPP message
     *
     * @param binding the binding to use
     */
    public void setBinding(XmppBinding binding) {
        this.binding = binding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getUser() {
        return user;
    }
    public void setUser(String user) {
        this.user = user;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getResource() {
        return resource;
    }
    public void setResource(String resource) {
        this.resource = resource;
    }
    public boolean isLogin() {
        return login;
    }
    public void setLogin(boolean login) {
        this.login = login;
    }
    public PacketFilter getFilter() {
        return filter;
    }
    public void setFilter(PacketFilter filter) {
        this.filter = filter;
    }
    public boolean isCreateAccount() {
        return createAccount;
    }
    public void setCreateAccount(boolean createAccount) {
        this.createAccount = createAccount;
    }
    public String getRoom() {
        return room;
    }
    public void setRoom(String room) {
        this.room = room;
    }
    public String getParticipant() {
        return participant;
    }
    public void setParticipant(String participant) {
        this.participant = participant;
    }
    public XMPPConnection getConnection() throws XMPPException {
        if (connection == null) {
            connection = createConnection();
        }
        return connection;
    }
    public void setConnection(XMPPConnection connection) {
        this.connection = connection;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected XMPPConnection createConnection() throws XMPPException {
        XMPPConnection connection;
        if (port > 0) {
            connection = new XMPPConnection(host, port);
        }
        else {
            connection = new XMPPConnection(host);
        }
        if (login && !connection.isAuthenticated()) {
            if (user != null) {
                log.info(""Logging in to XMPP as user: "" + user + "" on connection: "" + connection);
                if (password == null) {
                    log.warn(""No password configured for user: "" + user);
                }
                if (createAccount) {
                    AccountManager accountManager = new AccountManager(connection);
                    accountManager.createAccount(user, password);
                }
                if (resource != null) {
                    connection.login(user, password, resource);
                }
                else {
                    connection.login(user, password);
                }
            }
            else {
                log.info(""Logging in anonymously to XMPP on connection: "" + connection);
                connection.loginAnonymously();
            }
            // now lets send a presence
            connection.sendPacket(new Presence(Presence.Type.AVAILABLE));
        }
        return connection;
    }
	public boolean isSingleton() {
		return true;
	}
}
"
org.apache.camel.component.jms.JmsMessage,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.beans.DesignMode;
import java.io.File;
import java.util.Enumeration;
import java.util.Map;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.TemporaryTopic;
import javax.jms.Topic;
import org.apache.camel.impl.DefaultMessage;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a {@link org.apache.camel.Message} for working with JMS
 *
 * @version $Revision:520964 $
 */
public class JmsMessage extends DefaultMessage {
    private static final transient Log log = LogFactory.getLog(JmsMessage.class);
    private Message jmsMessage;
    public JmsMessage() {
    }
    public JmsMessage(Message jmsMessage) {
        setJmsMessage(jmsMessage);
    }
    @Override
    public String toString() {
        if (jmsMessage != null) {
            return ""JmsMessage: "" + jmsMessage;
        }
        else {
            return ""JmsMessage: "" + getBody();
        }
    }
    /**
     * Returns the underlying JMS message
     *
     * @return the underlying JMS message
     */
    public Message getJmsMessage() {
        return jmsMessage;
    }
    public void setJmsMessage(Message jmsMessage){
        this.jmsMessage=jmsMessage;
        try{
            String id=getDestinationAsString(jmsMessage.getJMSDestination());
            id+=getSanitizedString(jmsMessage.getJMSMessageID());
            setMessageId(id);
        }catch(JMSException e){
            log.error(""Failed to get message id from message ""+jmsMessage,e);
        }
    }
    public Object getHeader(String name) {
        Object answer = null;
        if (jmsMessage != null) {
            try {
                answer = jmsMessage.getObjectProperty(name);
            }
            catch (JMSException e) {
                throw new MessagePropertyAccessException(name, e);
            }
        }
        if (answer == null) {
            answer = super.getHeader(name);
        }
        return answer;
    }
    @Override
    public JmsMessage newInstance() {
        return new JmsMessage();
    }
    @Override
    protected Object createBody() {
        if (jmsMessage != null && getExchange() instanceof JmsExchange) {
            JmsExchange exchange = (JmsExchange)getExchange();
            return (exchange.getBinding().extractBodyFromJms(exchange, jmsMessage));
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (jmsMessage != null) {
            Enumeration names;
            try {
                names = jmsMessage.getPropertyNames();
            }
            catch (JMSException e) {
                throw new MessagePropertyNamesAccessException(e);
            }
            while (names.hasMoreElements()) {
                String name = names.nextElement().toString();
                try {
                    Object value = jmsMessage.getObjectProperty(name);
                    map.put(name, value);
                }
                catch (JMSException e) {
                    throw new MessagePropertyAccessException(name, e);
                }
            }
        }
    }
    private String getDestinationAsString(Destination destination) throws JMSException {
        String result = """";
        if (destination instanceof Topic) {
            result += ""topic"" + File.separator + getSanitizedString(((Topic)destination).getTopicName());
        }else {
            result += ""queue"" + File.separator + getSanitizedString(((Queue)destination).getQueueName());
        }
        result += File.separator;
        return result;
    }
    private String getSanitizedString(Object value) {
        return value != null ? value.toString().replaceAll(""[^a-zA-Z0-9\\.\\_\\-]"", ""_"") : """";
    }
}
"
org.apache.camel.component.mail.MailComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import java.util.Map;
import java.net.URI;
import java.net.URL;
/**
 * @version $Revision:520964 $
 */
public class MailComponent extends DefaultComponent<MailExchange> {
    public static final String QUEUE_PREFIX = ""queue:"";
    public static final String TOPIC_PREFIX = ""topic:"";
    private MailConfiguration configuration;
    /**
     * Static builder method
     */
    public static MailComponent mailComponent() {
        return new MailComponent();
    }
    /**
     * Static builder method
     */
    public static MailComponent mailComponent(MailConfiguration configuration) {
        return new MailComponent(configuration);
    }
    public MailComponent() {
        this.configuration = new MailConfiguration();
    }
    public MailComponent(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    public MailComponent(CamelContext context) {
        super(context);
        this.configuration = new MailConfiguration();
    }
    @Override
    protected Endpoint<MailExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        MailConfiguration config = getConfiguration().copy();
        config.configure(new URI(uri));
        // lets make sure we copy the configuration as each endpoint can customize its own version
        MailEndpoint endpoint = new MailEndpoint(uri, this, config);
        IntrospectionSupport.setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public MailConfiguration getConfiguration() {
        return configuration;
    }
    /**
     * Sets the Mail configuration
     *
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    /**
     * A strategy method allowing the URI destination to be translated into the actual Mail destination name
     * (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path) {
        return path;
    }
}
"
org.apache.camel.component.cxf.CxfInvokeEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Properties;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.cxf.Bus;
import org.apache.cxf.message.Message;
/**
 * The endpoint in the service engine
 *
 * @version $Revision$
 */
public class CxfInvokeEndpoint extends DefaultEndpoint<CxfExchange> {
    private CxfBinding binding;
    private final CxfInvokeComponent component;
    private boolean inOut = true;
    private Properties properties;
    public CxfInvokeEndpoint(String uri, CxfInvokeComponent component, Properties properties) {
        super(uri, component);
        this.component = component;
        this.properties = properties;
    }
    public Producer<CxfExchange> createProducer() throws Exception {
        return new CxfInvokeProducer(this);
    }
    public Consumer<CxfExchange> createConsumer(Processor processor) throws Exception {
        return new CxfInvokeConsumer(this, processor);
    }
    public CxfExchange createExchange() {
        return new CxfExchange(getContext(), getBinding());
    }
    public CxfExchange createExchange(Message inMessage) {
        return new CxfExchange(getContext(), getBinding(), inMessage);
    }
    public CxfBinding getBinding() {
        if (binding == null) {
            binding = new CxfBinding();
        }
        return binding;
    }
    public void setBinding(CxfBinding binding) {
        this.binding = binding;
    }
    public boolean isInOut() {
        return inOut;
    }
    public void setInOut(boolean inOut) {
        this.inOut = inOut;
    }
    public CxfInvokeComponent getComponent() {
        return component;
    }
    public String getProperty(String key) {
        return properties.getProperty(key);
    }
    public Bus getBus() {
        return component.getBus();
    }
	public boolean isSingleton() {
		return true;
	}
}
"
org.apache.camel.spring.xml.LazyLoadingBeanDefinitionParser,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link BeanDefinitionParser} which lazy loads the type on which it creates to allow the schema to be loosly coupled
 * with the camel jars.
 *
 * @version $Revision: 1.1 $
 */
public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser {
    private String className;
    private String moduleName;
    public LazyLoadingBeanDefinitionParser(String className, String moduleName) {
        this.className = className;
        this.moduleName = moduleName;
    }
    @Override
    protected Class loadType() {
        Class<?> answer = ObjectHelper.loadClass(className, getClass().getClassLoader());
        if (answer == null) {
            throw new IllegalArgumentException(""Class: "" + className + "" could not be found. You need to add Camel module: "" + moduleName + "" to your classpath"");
        }
        return answer;
    }
}
"
org.apache.camel.component.mail.MailConfiguration,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.RuntimeCamelException;
import javax.mail.Session;
import java.net.URI;
import java.util.Properties;
/**
 * Represents the configuration data for communicating over email
 *
 * @version $Revision: 532790 $
 */
public class MailConfiguration implements Cloneable {
    private String defaultEncoding;
    private String host;
    private Properties javaMailProperties;
    private String password;
    private String protocol;
    private Session session;
    private String username;
    private int port = -1;
    private String destination;
    private String from = ""camel@localhost"";
    private boolean deleteProcessedMessages = true;
    private String folderName = ""INBOX"";
    public MailConfiguration() {
    }
    /**
     * Returns a copy of this configuration
     */
    public MailConfiguration copy() {
        try {
            return (MailConfiguration) clone();
        }
        catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public void configure(URI uri) {
        String value = uri.getHost();
        if (value != null) {
            setHost(value);
        }
        String scheme = uri.getScheme();
        if (scheme != null) {
            setProtocol(scheme);
        }
        String userInfo = uri.getUserInfo();
        if (userInfo != null) {
            setUsername(userInfo);
        }
        int port = uri.getPort();
        if (port >= 0) {
            setPort(port);
        }
        // we can either be invoked with
        // mailto:address
        // or
        // smtp:user@host:port/name@address
        String fragment = uri.getFragment();
        if (fragment == null || fragment.length() == 0) {
            fragment = userInfo + ""@"" + host;
        }
        else {
            setFolderName(fragment);
        }
        setDestination(fragment);
    }
    public JavaMailConnection createJavaMailConnection(MailEndpoint mailEndpoint) {
        JavaMailConnection answer = new JavaMailConnection();
        if (defaultEncoding != null) {
            answer.setDefaultEncoding(defaultEncoding);
        }
        //answer.setDefaultFileTypeMap(fileTypeMap);
        if (host != null) {
            answer.setHost(host);
        }
        if (javaMailProperties != null) {
            answer.setJavaMailProperties(javaMailProperties);
        }
        if (port >= 0) {
            answer.setPort(port);
        }
        if (password != null) {
            answer.setPassword(password);
        }
        if (protocol != null) {
            answer.setProtocol(protocol);
        }
        if (session != null) {
            answer.setSession(session);
        }
        if (username != null) {
            answer.setUsername(username);
        }
        return answer;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getDefaultEncoding() {
        return defaultEncoding;
    }
    public void setDefaultEncoding(String defaultEncoding) {
        this.defaultEncoding = defaultEncoding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public Properties getJavaMailProperties() {
        return javaMailProperties;
    }
    public void setJavaMailProperties(Properties javaMailProperties) {
        this.javaMailProperties = javaMailProperties;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getProtocol() {
        return protocol;
    }
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }
    public Session getSession() {
        return session;
    }
    public void setSession(Session session) {
        this.session = session;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getDestination() {
        return destination;
    }
    public void setDestination(String destination) {
        this.destination = destination;
    }
    public String getFrom() {
        return from;
    }
    public void setFrom(String from) {
        this.from = from;
    }
    public boolean isDeleteProcessedMessages() {
        return deleteProcessedMessages;
    }
    public void setDeleteProcessedMessages(boolean deleteProcessedMessages) {
        this.deleteProcessedMessages = deleteProcessedMessages;
    }
    public String getFolderName() {
        return folderName;
    }
    public void setFolderName(String folderName) {
        this.folderName = folderName;
    }
}
"
org.apache.camel.component.jbi.ToJbiProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.servicemix.jbi.resolver.URIResolver;
import javax.jbi.component.ComponentContext;
import javax.jbi.messaging.DeliveryChannel;
import javax.jbi.messaging.MessageExchange;
import javax.jbi.messaging.MessageExchangeFactory;
import javax.jbi.messaging.MessagingException;
/**
 * A @{link Processor} which takes a Camel {@link Exchange} and invokes it into JBI using the straight JBI API
 *
 * @version $Revision$
 */
public class ToJbiProcessor implements Processor {
    private JbiBinding binding;
    private ComponentContext componentContext;
    private String destinationUri;
    public ToJbiProcessor(JbiBinding binding, ComponentContext componentContext, String destinationUri) {
        this.binding = binding;
        this.componentContext = componentContext;
        this.destinationUri = destinationUri;
    }
    public void process(Exchange exchange) {
        try {
            DeliveryChannel deliveryChannel = componentContext.getDeliveryChannel();
            MessageExchangeFactory exchangeFactory = deliveryChannel.createExchangeFactory();
            MessageExchange messageExchange = binding.makeJbiMessageExchange(exchange, exchangeFactory);
            URIResolver.configureExchange(messageExchange, componentContext, destinationUri);
            deliveryChannel.sendSync(messageExchange);
        }
        catch (MessagingException e) {
            throw new JbiException(e);
        }
    }
}
"
org.apache.camel.component.http.HttpConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.Processor;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision: 534063 $
 */
public class HttpConsumer extends DefaultConsumer<HttpExchange> {
	private final HttpEndpoint endpoint;
	public HttpConsumer(HttpEndpoint endpoint, Processor processor) {
		super(endpoint, processor);
		this.endpoint = endpoint;
	}
    @Override
    public HttpEndpoint getEndpoint() {
        return (HttpEndpoint) super.getEndpoint();
    }
    public HttpBinding getBinding() {
        return endpoint.getBinding();
    }
    public String getPath() {
        return endpoint.getPath();
    }
    @Override
	protected void doStart() throws Exception {
		super.doStart();
		endpoint.connect(this);		
	}
	@Override
	protected void doStop() throws Exception {
		endpoint.disconnect(this);
		super.doStop();
	}
}
"
org.apache.camel.builder.script.ScriptBuilder,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
/**
 * A builder class for creating {@link Processor}, {@link Expression} and {@link Predicate} objects using
 * the JSR 223 scripting engine.
 *
 * @version $Revision$
 */
public class ScriptBuilder<E extends Exchange> implements Expression<E>, Predicate<E>, Processor {
    private static final transient Log log = LogFactory.getLog(ScriptBuilder.class);
    private String scriptEngineName;
    private Resource scriptResource;
    private String scriptText;
    private ScriptEngine engine;
    private CompiledScript compiledScript;
    public ScriptBuilder(String scriptEngineName) {
        this.scriptEngineName = scriptEngineName;
    }
    public ScriptBuilder(String scriptEngineName, String scriptText) {
        this(scriptEngineName);
        this.scriptText = scriptText;
    }
    public ScriptBuilder(String scriptEngineName, Resource scriptResource) {
        this(scriptEngineName);
        this.scriptResource = scriptResource;
    }
    @Override
    public String toString() {
        return getScriptDescription();
    }
    public Object evaluate(E exchange) {
        return evaluateScript(exchange);
    }
    public boolean matches(E exchange) {
        Object scriptValue = evaluateScript(exchange);
        return matches(exchange, scriptValue);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        Object scriptValue = evaluateScript(exchange);
        if (!matches(exchange, scriptValue)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as script returned <"" + scriptValue + "">"");
        }
    }
    public void process(Exchange exchange) {
        evaluateScript(exchange);
    }
    // Builder API
    //-------------------------------------------------------------------------
    /**
     * Sets the attribute on the context so that it is available to the script as a variable
     * in the {@link ScriptContext#ENGINE_SCOPE}
     *
     * @param name the name of the attribute
     * @param value the attribute value
     * @return this builder
     */
    public ScriptBuilder attribute(String name, Object value) {
        getScriptContext().setAttribute(name, value, ScriptContext.ENGINE_SCOPE);
        return this;
    }
    // Create any scripting language builder recognised by JSR 223
    //-------------------------------------------------------------------------
    /**
     * Creates a script builder for the named language and script contents
     *
     * @param language the language to use for the script
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder script(String language, String scriptText) {
        return new ScriptBuilder(language, scriptText);
    }
    /**
     * Creates a script builder for the named language and script @{link Resource}
     *
     * @param language the language to use for the script
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, Resource scriptResource) {
        return new ScriptBuilder(language, scriptResource);
    }
    /**
     * Creates a script builder for the named language and script @{link File}
     *
     * @param language the language to use for the script
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, File scriptFile) {
        return new ScriptBuilder(language, new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the named language and script @{link URL}
     *
     * @param language the language to use for the script
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, URL scriptURL) {
        return new ScriptBuilder(language, new UrlResource(scriptURL));
    }
    // Groovy
    //-------------------------------------------------------------------------
    /**
     * Creates a script builder for the groovy script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder groovy(String scriptText) {
        return new ScriptBuilder(""groovy"", scriptText);
    }
    /**
     * Creates a script builder for the groovy script @{link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(Resource scriptResource) {
        return new ScriptBuilder(""groovy"", scriptResource);
    }
    /**
     * Creates a script builder for the groovy script @{link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(File scriptFile) {
        return new ScriptBuilder(""groovy"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the groovy script @{link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(URL scriptURL) {
        return new ScriptBuilder(""groovy"", new UrlResource(scriptURL));
    }
    // JavaScript
    //-------------------------------------------------------------------------
    /**
     * Creates a script builder for the JavaScript/ECMAScript script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder javaScript(String scriptText) {
        return new ScriptBuilder(""js"", scriptText);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script @{link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(Resource scriptResource) {
        return new ScriptBuilder(""js"", scriptResource);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script @{link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(File scriptFile) {
        return new ScriptBuilder(""js"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script @{link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(URL scriptURL) {
        return new ScriptBuilder(""js"", new UrlResource(scriptURL));
    }
    // PHP
    //-------------------------------------------------------------------------
    /**
     * Creates a script builder for the PHP script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder php(String scriptText) {
        return new ScriptBuilder(""php"", scriptText);
    }
    /**
     * Creates a script builder for the PHP script @{link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(Resource scriptResource) {
        return new ScriptBuilder(""php"", scriptResource);
    }
    /**
     * Creates a script builder for the PHP script @{link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(File scriptFile) {
        return new ScriptBuilder(""php"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the PHP script @{link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(URL scriptURL) {
        return new ScriptBuilder(""php"", new UrlResource(scriptURL));
    }
    // Python
    //-------------------------------------------------------------------------
    /**
     * Creates a script builder for the Python script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder python(String scriptText) {
        return new ScriptBuilder(""python"", scriptText);
    }
    /**
     * Creates a script builder for the Python script @{link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(Resource scriptResource) {
        return new ScriptBuilder(""python"", scriptResource);
    }
    /**
     * Creates a script builder for the Python script @{link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(File scriptFile) {
        return new ScriptBuilder(""python"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Python script @{link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(URL scriptURL) {
        return new ScriptBuilder(""python"", new UrlResource(scriptURL));
    }
    // Ruby/JRuby
    //-------------------------------------------------------------------------
    /**
     * Creates a script builder for the Ruby/JRuby script contents
     *
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder ruby(String scriptText) {
        return new ScriptBuilder(""jruby"", scriptText);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script @{link Resource}
     *
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(Resource scriptResource) {
        return new ScriptBuilder(""jruby"", scriptResource);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script @{link File}
     *
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(File scriptFile) {
        return new ScriptBuilder(""jruby"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Ruby/JRuby script @{link URL}
     *
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(URL scriptURL) {
        return new ScriptBuilder(""jruby"", new UrlResource(scriptURL));
    }
    // Properties
    //-------------------------------------------------------------------------
    public ScriptEngine getEngine() {
        checkInitialised();
        return engine;
    }
    public CompiledScript getCompiledScript() {
        return compiledScript;
    }
    public String getScriptText() {
        return scriptText;
    }
    public void setScriptText(String scriptText) {
        this.scriptText = scriptText;
    }
    public String getScriptEngineName() {
        return scriptEngineName;
    }
    /**
     * Returns a description of the script
     *
     * @return the script description
     */
    public String getScriptDescription() {
        if (scriptText != null) {
            return scriptEngineName + "": "" + scriptText;
        }
        else if (scriptResource != null) {
            return scriptEngineName + "": "" + scriptResource.getDescription();
        }
        else {
            return scriptEngineName + "": null script"";
        }
    }
    /**
     * Access the script context so that it can be configured such as adding attributes
     */
    public ScriptContext getScriptContext() {
        return getEngine().getContext();
    }
    /**
     * Sets the context to use by the script
     */
    public void setScriptContext(ScriptContext scriptContext) {
        getEngine().setContext(scriptContext);
    }
    public Resource getScriptResource() {
        return scriptResource;
    }
    public void setScriptResource(Resource scriptResource) {
        this.scriptResource = scriptResource;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void checkInitialised() {
        if (scriptText == null && scriptResource == null) {
            throw new IllegalArgumentException(""Neither scriptText or scriptResource are specified"");
        }
        if (engine == null) {
            engine = createScriptEngine();
        }
        if (compiledScript == null) {
            if (engine instanceof Compilable) {
                compileScript((Compilable) engine);
            }
        }
    }
    protected boolean matches(E exchange, Object scriptValue) {
        return ObjectConverter.toBoolean(scriptValue);
    }
    protected ScriptEngine createScriptEngine() {
        ScriptEngineManager manager = new ScriptEngineManager();
        return manager.getEngineByName(scriptEngineName);
    }
    protected void compileScript(Compilable compilable) {
        try {
            if (scriptText != null) {
                compiledScript = compilable.compile(scriptText);
            }
            else if (scriptResource != null) {
                compiledScript = compilable.compile(createScriptReader());
            }
        }
        catch (ScriptException e) {
            if (log.isDebugEnabled()) {
                log.debug(""Script compile failed: "" + e, e);
            }
            throw createScriptCompileException(e);
        }
        catch (IOException e) {
            throw createScriptCompileException(e);
        }
    }
    protected synchronized Object evaluateScript(Exchange exchange) {
        try {
            getScriptContext();
            populateBindings(getEngine(), exchange);
            return runScript();
        }
        catch (ScriptException e) {
            if (log.isDebugEnabled()) {
                log.debug(""Script evaluation failed: "" + e, e);
            }
            throw createScriptEvaluationException(e.getCause());
        }
        catch (IOException e) {
            throw createScriptEvaluationException(e);
        }
    }
    protected Object runScript() throws ScriptException, IOException {
        checkInitialised();
        if (compiledScript != null) {
            return compiledScript.eval();
        }
        else {
            if (scriptText != null) {
                return getEngine().eval(scriptText);
            }
            else {
                return getEngine().eval(createScriptReader());
            }
        }
    }
    protected void populateBindings(ScriptEngine engine, Exchange exchange) {
        ScriptContext context = engine.getContext();
        int scope = ScriptContext.ENGINE_SCOPE;
        context.setAttribute(""context"", exchange.getContext(), scope);
        context.setAttribute(""exchange"", exchange, scope);
        context.setAttribute(""request"", exchange.getIn(), scope);
        context.setAttribute(""response"", exchange.getOut(), scope);
    }
    protected InputStreamReader createScriptReader() throws IOException {
        // TODO consider character sets?
        return new InputStreamReader(scriptResource.getInputStream());
    }
    protected ScriptEvaluationException createScriptCompileException(Exception e) {
        return new ScriptEvaluationException(""Failed to compile: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
    protected ScriptEvaluationException createScriptEvaluationException(Throwable e) {
        return new ScriptEvaluationException(""Failed to evaluate: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
}
"
org.apache.camel.component.http.HttpProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.ByteArrayRequestEntity;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.methods.RequestEntity;
import java.io.InputStream;
/**
 * @version $Revision: 1.1 $
 */
public class HttpProducer extends DefaultProducer<HttpExchange> implements Producer<HttpExchange> {
    private HttpClient httpClient = new HttpClient();
    public HttpProducer(HttpEndpoint endpoint) {
        super(endpoint);
    }
    public void process(Exchange exchange) throws Exception {
        HttpMethod method = createMethod(exchange);
        int responseCode = httpClient.executeMethod(method);
        // lets store the result in the output message.
        InputStream in = method.getResponseBodyAsStream();
        Message out = exchange.getOut(true);
        out.setBody(in);
        // lets set the headers
        Header[] headers = method.getResponseHeaders();
        for (Header header : headers) {
            String name = header.getName();
            String value = header.getValue();
            out.setHeader(name, value);
        }
        out.setHeader(""http.responseCode"", responseCode);
    }
    protected HttpMethod createMethod(Exchange exchange) {
        String uri = getEndpoint().getEndpointUri();
        RequestEntity requestEntity = createRequestEntity(exchange);
        if (requestEntity == null) {
            return new GetMethod(uri);
        }
        // TODO we might be PUT? - have some better way to explicitly choose method
        PostMethod method = new PostMethod(uri);
        method.setRequestEntity(requestEntity);
        return method;
    }
    protected RequestEntity createRequestEntity(Exchange exchange) {
        Message in = exchange.getIn();
        RequestEntity entity = in.getBody(RequestEntity.class);
        if (entity == null) {
            byte[] data = in.getBody(byte[].class);
            String contentType = in.getHeader(""Content-Type"", String.class);
            if (contentType != null) {
                return new ByteArrayRequestEntity(data, contentType);
            }
            else {
                return new ByteArrayRequestEntity(data);
            }
        }
        return entity;
    }
}
"
org.apache.camel.component.jbi.FromJbiProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jbi;
import org.apache.camel.CamelContext;
import org.apache.camel.Processor;
import org.apache.servicemix.MessageExchangeListener;
import javax.jbi.messaging.MessageExchange;
import javax.jbi.messaging.MessagingException;
/**
 * @version $Revision$
 */
public class FromJbiProcessor implements MessageExchangeListener {
    private CamelContext context;
    private JbiBinding binding;
    private Processor processor;
    public FromJbiProcessor(CamelContext context, JbiBinding binding, Processor processor) {
        this.context = context;
        this.binding = binding;
        this.processor = processor;
    }
    public void onMessageExchange(MessageExchange messageExchange) throws MessagingException {
        try {
			JbiExchange exchange = new JbiExchange(context, binding, messageExchange);
			processor.process(exchange);
		} catch (Exception e) {
			throw new MessagingException(e);
		}
    }
}
"
org.apache.camel.bam.ProcessBuilder,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.processor.ActivityMonitorEngine;
import org.apache.camel.bam.processor.JpaBamProcessor;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.builder.RouteBuilder;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
import java.util.ArrayList;
import java.util.List;
/**
 * A builder of a process definition
 *
 * @version $Revision: $
 */
public abstract class ProcessBuilder extends RouteBuilder {
    private static int processCounter;
    private JpaTemplate jpaTemplate;
    private final TransactionTemplate transactionTemplate;
    private final String processName;
    private List<ActivityBuilder> activityBuilders = new ArrayList<ActivityBuilder>();
    private Class entityType = ProcessInstance.class;
    private ProcessRules processRules = new ProcessRules();
    private ProcessDefinition processDefinition;
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate) {
        this(jpaTemplate, transactionTemplate, createProcessName());
    }
    protected static synchronized String createProcessName() {
        return ""Process-"" + (++processCounter);
    }
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate, String processName) {
        this.jpaTemplate = jpaTemplate;
        this.transactionTemplate = transactionTemplate;
        this.processName = processName;
    }
    public ActivityBuilder activity(String endpointUri) {
        return activity(endpoint(endpointUri));
    }
    public ActivityBuilder activity(Endpoint endpoint) {
        ActivityBuilder answer = new ActivityBuilder(this, endpoint);
        activityBuilders.add(answer);
        return answer;
    }
    /**
     * Sets the process entity type used to perform state management
     */
    public ProcessBuilder entityType(Class entityType) {
        this.entityType = entityType;
        return this;
    }
    public Processor createActivityProcessor(ActivityBuilder activityBuilder) {
        notNull(jpaTemplate, ""jpaTemplate"");
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                processRules.setProcessDefinition(getProcessDefinition());
            }
        });
        return new JpaBamProcessor(getTransactionTemplate(), getJpaTemplate(), activityBuilder.getCorrelationExpression(), activityBuilder.getActivityRules(), getEntityType());
    }
    // Properties
    //-----------------------------------------------------------------------
    public List<ActivityBuilder> getActivityBuilders() {
        return activityBuilders;
    }
    public Class getEntityType() {
        return entityType;
    }
    public JpaTemplate getJpaTemplate() {
        return jpaTemplate;
    }
    public void setJpaTemplate(JpaTemplate jpaTemplate) {
        this.jpaTemplate = jpaTemplate;
    }
    public TransactionTemplate getTransactionTemplate() {
        return transactionTemplate;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public String getProcessName() {
        return processName;
    }
    public ProcessDefinition getProcessDefinition() {
        if (processDefinition == null) {
            processDefinition = findOrCreateProcessDefinition();
        }
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void populateRoutes(List<Route> routes) throws Exception {
        boolean first = true;
        for (ActivityBuilder builder : activityBuilders) {
            Route route = builder.createRoute();
            if (first) {
                route.getServices().add(new ActivityMonitorEngine(getJpaTemplate(), getTransactionTemplate(), getProcessRules()));
                first = false;
            }
            routes.add(route);
        }
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    public ActivityDefinition findOrCreateActivityDefinition(String activityName) {
        ProcessDefinition definition = getProcessDefinition();
        List<ActivityDefinition> list = jpaTemplate.find(""select x from "" + ActivityDefinition.class.getName() + "" x where x.processDefinition = ?1 and x.name = ?2"", definition, activityName);
        if (!list.isEmpty()) {
            return list.get(0);
        }
        else {
            ActivityDefinition answer = new ActivityDefinition();
            answer.setName(activityName);
            answer.setProcessDefinition(ProcessDefinition.getRefreshedProcessDefinition(jpaTemplate, definition));
            jpaTemplate.persist(answer);
            return answer;
        }
    }
    protected ProcessDefinition findOrCreateProcessDefinition() {
        List<ProcessDefinition> list = jpaTemplate.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        }
        else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            jpaTemplate.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.component.mina.MinaExchange,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
/**
 * A {@link Exchange} for MINA
 * 
 * @version $Revision$
 */
public class MinaExchange extends DefaultExchange {
    public MinaExchange(CamelContext camelContext) {
        super(camelContext);
    }
}
"
org.apache.camel.component.quartz.CamelJob,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
/**
 * @version $Revision: 1.1 $
 */
public class CamelJob implements Job {
    public void execute(JobExecutionContext context) throws JobExecutionException {
        QuartzEndpoint component = (QuartzEndpoint) context.getJobDetail().getJobDataMap().get(QuartzEndpoint.ENDPOINT_KEY);
        if (component == null) {
            throw new JobExecutionException(""No quartz endpoint available for key: "" + QuartzEndpoint.ENDPOINT_KEY + "". Bad job data map"");
        }
        component.onJobExecute(context);
    }
}"
org.apache.camel.component.xmpp.XmppConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.PacketListener;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.packet.RosterPacket;
import java.util.Iterator;
/**
 * A {@link Consumer} which listens to XMPP packets
 *
 * @version $Revision$
 */
public class XmppConsumer extends DefaultConsumer<XmppExchange> implements PacketListener {
    private static final transient Log log = LogFactory.getLog(XmppConsumer.class);
    private final XmppEndpoint endpoint;
    public XmppConsumer(XmppEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.getConnection().addPacketListener(this, endpoint.getFilter());
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.getConnection().removePacketListener(this);
        super.doStop();
    }
    public void processPacket(Packet packet) {
        if (packet instanceof Message) {
            Message message = (Message) packet;
            if (log.isDebugEnabled()) {
                log.debug(""<<<< message: "" + message.getBody());
            }
            XmppExchange exchange = endpoint.createExchange(message);
            try {
				getProcessor().process(exchange);
			} catch (Exception e) {
				// TODO: what should we do when a processing failure occurs??
				e.printStackTrace();
			}
        }
        else if (packet instanceof RosterPacket) {
            RosterPacket rosterPacket = (RosterPacket) packet;
            if (log.isDebugEnabled()) {
                log.debug(""Roster packet with : "" + rosterPacket.getRosterItemCount() + "" item(s)"");
                Iterator rosterItems = rosterPacket.getRosterItems();
                while (rosterItems.hasNext()) {
                    Object item = rosterItems.next();
                    log.debug(""Roster item: "" + item);
                }
            }
        }
        else {
            if (log.isDebugEnabled()) {
                log.debug(""<<<< ignored packet: "" + packet);
            }
        }
    }
}
"
org.apache.camel.spring.xml.RouteBuilderFactoryBean,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import static org.apache.camel.util.ObjectHelper.notNull;
import java.util.ArrayList;
import org.apache.camel.CamelContext;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
/**
 * A {@link FactoryBean} which creates a RouteBuilder by parsing an XML file. This factory bean
 * must be injected with a context and will then install the rules in the context when the routing rules
 * are created. 
 *
 * @version $Revision: 521369 $
 */
public class RouteBuilderFactoryBean implements FactoryBean, BeanFactoryAware, InitializingBean {
	private ArrayList<BuilderStatement> routes;
	private BeanFactory beanFactory;
    private CamelContext context;
    private StatementRouteBuilder builder = new StatementRouteBuilder();
    public Object getObject() throws Exception {
        return builder;
	}
	public Class getObjectType() {
		return StatementRouteBuilder.class;
	}
	public boolean isSingleton() {
		return true;
	}
	public ArrayList<BuilderStatement> getRoutes() {
		return routes;
	}
	public void setRoutes(ArrayList<BuilderStatement> routes) {
		this.routes = routes;
	}
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		this.beanFactory = beanFactory;
	}
    public CamelContext getContext() {
        return context;
    }
    public void setContext(CamelContext context) {
        this.context = context;
    }
    public void afterPropertiesSet() throws Exception {
        notNull(context, ""context"");
        notNull(routes, ""routes"");
		builder.setBeanFactory(beanFactory);
		builder.setRoutes(routes);
        // now lets install the routes in the context
        context.addRoutes(builder);
    }
}
"
org.apache.camel.component.http.HttpMessage,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import org.apache.camel.impl.DefaultMessage;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import javax.servlet.http.HttpServletRequest;
import java.util.Map;
import java.util.Enumeration;
import java.io.IOException;
/**
 * @version $Revision$
 */
public class HttpMessage extends DefaultMessage {
    private HttpServletRequest request;
    public HttpMessage(HttpExchange exchange, HttpServletRequest request) {
        setExchange(exchange);
        this.request = request;
        // lets force a parse of the body and headers
        getBody();
        getHeaders();
    }
    @Override
    public HttpExchange getExchange() {
        return (HttpExchange) super.getExchange();
    }
    public HttpServletRequest getRequest() {
        return request;
    }
    @Override
    protected Object createBody() {
        try {
            return getExchange().getEndpoint().getBinding().parseBody(this);
        }
        catch (IOException e) {
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        Enumeration names = request.getHeaderNames();
        while (names.hasMoreElements()) {
            String name = (String) names.nextElement();
            Object value = request.getHeader(name);
            map.put(name, value);
        }
    }
}
"
org.apache.camel.component.jms.JmsConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import javax.jms.MessageListener;
/**
 * A {@link Consumer} which uses Spring's {@link AbstractMessageListenerContainer} implementations to consume JMS messages
 *
 * @version $Revision$
 */
public class JmsConsumer extends DefaultConsumer<JmsExchange> {
    private final AbstractMessageListenerContainer listenerContainer;
    public JmsConsumer(JmsEndpoint endpoint, Processor processor, AbstractMessageListenerContainer listenerContainer) {
        super(endpoint, processor);
        this.listenerContainer = listenerContainer;
        MessageListener messageListener = createMessageListener(endpoint, processor);
        this.listenerContainer.setMessageListener(messageListener);
    }
    public AbstractMessageListenerContainer getListenerContainer() {
        return listenerContainer;
    }
    protected MessageListener createMessageListener(JmsEndpoint endpoint, Processor processor) {
        EndpointMessageListener<JmsExchange> messageListener = new EndpointMessageListener<JmsExchange>(endpoint, processor);
        messageListener.setBinding(endpoint.getBinding());
        return messageListener;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        listenerContainer.afterPropertiesSet();
        listenerContainer.start();
    }
    @Override
    protected void doStop() throws Exception {
        listenerContainer.stop();
        listenerContainer.destroy();
        super.doStop();
    }
}
"
org.apache.camel.spring.CamelContextFactoryBean,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import java.util.ArrayList;
import java.util.List;
/**
 * A Spring {@link FactoryBean} to create and initialize a {@link SpringCamelContext}
 * and install routes either explicitly configured in Spring XML or found by searching the classpath for Java classes
 * which extend {@link RouteBuilder} using the nested {@link #setPackages(String[])}.
 *
 * @version $Revision$
 */
public class CamelContextFactoryBean implements FactoryBean, InitializingBean, DisposableBean, ApplicationContextAware {
    private CamelContext context;
    private RouteBuilder routeBuilder;
    private List<RouteBuilder> additionalBuilders = new ArrayList<RouteBuilder>();
    private String[] packages = {};
    private ApplicationContext applicationContext;
    public Object getObject() throws Exception {
        return getContext();
    }
    public Class getObjectType() {
        return SpringCamelContext.class;
    }
    public boolean isSingleton() {
        return true;
    }
    public void afterPropertiesSet() throws Exception {
        // lets force any lazy creation
        getContext();
        findRouteBuiders();
        installRoutes();
        // now lets activate the routes
        getContext().start();
    }
    public void destroy() throws Exception {
        getContext().stop();
    }
    // Properties
    //-------------------------------------------------------------------------
    public CamelContext getContext() throws Exception {
        if (context == null) {
            context = new SpringCamelContext(getApplicationContext());
        }
        return context;
    }
    public void setContext(CamelContext context) {
        this.context = context;
    }
    public RouteBuilder getRouteBuilder() {
        return routeBuilder;
    }
    /**
     * Set a single {@link RouteBuilder} to be used to create the default routes on startup
     */
    public void setRouteBuilder(RouteBuilder routeBuilder) {
        this.routeBuilder = routeBuilder;
    }
    /**
     * Set a collection of {@link RouteBuilder} instances to be used to create the default routes on startup
     */
    public void setRouteBuilders(RouteBuilder[] builders) {
        for (RouteBuilder builder : builders) {
            additionalBuilders.add(builder);
        }
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String[] getPackages() {
        return packages;
    }
    /**
     * Sets the package names to be recursively searched for Java classes which extend {@link RouteBuilder} to be auto-wired up to the
     * {@link SpringCamelContext} as a route. Note that classes are excluded if they are specifically configured in the spring.xml
     *
     * @param packages the package names which are recursively searched
     */
    public void setPackages(String[] packages) {
        this.packages = packages;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * Strategy to install all available routes into the context
     */
    protected void installRoutes() throws Exception {
        for (RouteBuilder routeBuilder : additionalBuilders) {
            getContext().addRoutes(routeBuilder);
        }
        if (routeBuilder != null) {
            getContext().addRoutes(routeBuilder);
        }
    }
    /**
     * Strategy method to try find {@link RouteBuilder} instances on the classpath
     */
    protected void findRouteBuiders() throws IllegalAccessException, InstantiationException {
        if (packages != null && packages.length > 0) {
            RouteBuilderFinder finder = new RouteBuilderFinder(this);
            finder.appendBuilders(additionalBuilders);
        }
    }
}
"
org.apache.camel.component.cxf.transport.CamelDestination,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.io.AbstractCachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.AbstractDestination;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
import org.apache.cxf.wsdl.EndpointReferenceUtils;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
/**
 * @version $Revision$
 */
public class CamelDestination extends AbstractDestination implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-destination-base"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelDestination.class);
    CamelContext camelContext;
    String camelUri;
    final ConduitInitiator conduitInitiator;
    private CamelTransportBase base;
    private Endpoint endpoint;
    public CamelDestination(CamelContext camelContext, Bus bus,
            ConduitInitiator ci,
            EndpointInfo info) throws IOException {
        super(getTargetReference(info, bus), info);
        this.camelContext = camelContext;
        base = new CamelTransportBase(camelContext, bus, endpointInfo, true, BASE_BEAN_NAME_SUFFIX);
        conduitInitiator = ci;
        initConfig();
    }
    protected Logger getLogger() {
        return LOG;
    }
    /**
     * @param inMessage the incoming message
     * @return the inbuilt backchannel
     */
    protected Conduit getInbuiltBackChannel(Message inMessage) {
        return new BackChannelConduit(EndpointReferenceUtils.getAnonymousEndpointReference(),
                inMessage);
    }
    public void activate() {
        getLogger().log(Level.INFO, ""CamelDestination activate().... "");
        try {
            getLogger().log(Level.FINE, ""establishing Camel connection"");
            endpoint = camelContext.getEndpoint(camelUri);
        }
        catch (Exception ex) {
            getLogger().log(Level.SEVERE, ""Camel connect failed with EException : "", ex);
        }
    }
    public void deactivate() {
        base.close();
    }
    public void shutdown() {
        getLogger().log(Level.FINE, ""CamelDestination shutdown()"");
        this.deactivate();
    }
    protected void incoming(Exchange exchange) {
        getLogger().log(Level.FINE, ""server received request: "", exchange);
        byte[] bytes = base.unmarshal(exchange);
        // get the message to be interceptor
        MessageImpl inMessage = new MessageImpl();
        inMessage.setContent(InputStream.class, new ByteArrayInputStream(bytes));
        base.populateIncomingContext(exchange, inMessage, CamelConstants.CAMEL_SERVER_REQUEST_HEADERS);
        //inMessage.put(CamelConstants.CAMEL_SERVER_RESPONSE_HEADERS, new CamelMessageHeadersType());
        inMessage.put(CamelConstants.CAMEL_REQUEST_MESSAGE, exchange);
        inMessage.setDestination(this);
        //handle the incoming message
        incomingObserver.onMessage(inMessage);
    }
    public String getBeanName() {
        return endpointInfo.getName().toString() + "".camel-destination"";
    }
    private void initConfig() {
/*
        this.runtimePolicy = endpointInfo.getTraversedExtensor(new ServerBehaviorPolicyType(),
                                                               ServerBehaviorPolicyType.class);
        this.serverConfig = endpointInfo.getTraversedExtensor(new ServerConfig(), ServerConfig.class);
        this.address = endpointInfo.getTraversedExtensor(new AddressType(), AddressType.class);
        this.sessionPool = endpointInfo.getTraversedExtensor(new SessionPoolType(), SessionPoolType.class);
*/
    }
    protected class ConsumerProcessor implements Processor {
        public void process(Exchange exchange) {
            try {
                incoming(exchange);
            }
            catch (Throwable ex) {
                getLogger().log(Level.WARNING, ""Failed to process incoming message : "", ex);
            }
        }
    }
    // this should deal with the cxf message
    protected class BackChannelConduit extends AbstractConduit {
        protected Message inMessage;
        BackChannelConduit(EndpointReferenceType ref, Message message) {
            super(ref);
            inMessage = message;
        }
        /**
         * Register a message observer for incoming messages.
         *
         * @param observer the observer to notify on receipt of incoming
         */
        public void setMessageObserver(MessageObserver observer) {
            // shouldn't be called for a back channel conduit
        }
        /**
         * Send an outbound message, assumed to contain all the name-value
         * mappings of the corresponding input message (if any).
         *
         * @param message the message to be sent.
         */
        public void prepare(Message message) throws IOException {
            // setup the message to be send back
            message.put(CamelConstants.CAMEL_REQUEST_MESSAGE,
                    inMessage.get(CamelConstants.CAMEL_REQUEST_MESSAGE));
            message.setContent(OutputStream.class,
                    new CamelOutputStream(inMessage));
        }
        protected Logger getLogger() {
            return LOG;
        }
    }
    private class CamelOutputStream extends AbstractCachedOutputStream {
        private Message inMessage;
        private Producer<Exchange> replyTo;
        private Producer<Exchange> sender;
        // setup the ByteArrayStream
        public CamelOutputStream(Message m) {
            super();
            inMessage = m;
        }
        // prepair the message and get the send out message
        private void commitOutputMessage() throws IOException {
            //setup the reply message
            final String replyToUri = getReplyToDestination(inMessage);
            base.template.send(replyToUri, new Processor() {
                public void process(Exchange reply) {
                    base.marshal(currentStream.toString(), replyToUri, reply);
                    setReplyCorrelationID(inMessage, reply);
                    base.setMessageProperties(inMessage, reply);
                    getLogger().log(Level.FINE, ""just server sending reply: "", reply);
                }
            });
        }
        @Override
        protected void doFlush() throws IOException {
            // Do nothing here
        }
        @Override
        protected void doClose() throws IOException {
            commitOutputMessage();
        }
        @Override
        protected void onWrite() throws IOException {
            // Do nothing here
        }
    }
    protected String getReplyToDestination(Message inMessage) {
        if (inMessage.get(CamelConstants.CAMEL_REBASED_REPLY_TO) != null) {
            return (String) inMessage.get(CamelConstants.CAMEL_REBASED_REPLY_TO);
        }
        else {
            return base.getReplyDestination();
        }
    }
    protected void setReplyCorrelationID(Message inMessage, Exchange reply) {
        Object value = inMessage.get(CamelConstants.CAMEL_CORRELATION_ID);
        if (value != null) {
            reply.getIn().setHeader(CamelConstants.CAMEL_CORRELATION_ID, value);
        }
    }
}
"
org.apache.camel.component.xmpp.XmppExchange,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.jivesoftware.smack.packet.Message;
/**
 * Represents an {@ilnk Exchange} for working with XMPP
 *
 * @version $Revision:520964 $
 */
public class XmppExchange extends DefaultExchange {
    private XmppBinding binding;
    public XmppExchange(CamelContext context, XmppBinding binding) {
        super(context);
        this.binding = binding;
    }
    public XmppExchange(CamelContext context, XmppBinding binding, Message message) {
        this(context, binding);
        setIn(new XmppMessage(message));
    }
    @Override
    public XmppMessage getIn() {
        return (XmppMessage) super.getIn();
    }
    @Override
    public XmppMessage getOut() {
        return (XmppMessage) super.getOut();
    }
    @Override
    public XmppMessage getOut(boolean lazyCreate) {
        return (XmppMessage) super.getOut(lazyCreate);
    }
    @Override
    public XmppMessage getFault() {
        return (XmppMessage) super.getFault();
    }
    public XmppBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new XmppExchange(getContext(), binding);
    }
    // Expose the underlying XMPP APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying XMPP In message
     *
     * @return the XMPP In message
     */
    public Message getInMessage() {
        return getIn().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Out message
     *
     * @return the XMPP out message
     */
    public Message getOutMessage() {
        return getOut().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Fault message
     *
     * @return the XMPP fault message
     */
    public Message getFaultMessage() {
        return getOut().getXmppMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected XmppMessage createInMessage() {
        return new XmppMessage();
    }
    @Override
    protected XmppMessage createOutMessage() {
        return new XmppMessage();
    }
}
"
org.apache.camel.component.http.JettyHttpComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.util.HashMap;
import org.mortbay.jetty.Connector;
import org.mortbay.jetty.Server;
import org.mortbay.jetty.nio.SelectChannelConnector;
import org.mortbay.jetty.security.SslSocketConnector;
import org.mortbay.jetty.servlet.Context;
import org.mortbay.jetty.servlet.ServletHolder;
/**
 * An HttpComponent which starts an embedded Jetty for to handle consuming from
 * http endpoints.
 * 
 * @version $Revision: 525142 $
 */
public class JettyHttpComponent extends HttpComponent {
	Server server;
	class ConnectorRef {
		Connector connector;
		int refCount = 0;
		public ConnectorRef(Connector connector) {
			this.connector=connector;
			increment();
		}
		public int increment() {
			return ++refCount;
		}
		public int decrement() {
			return --refCount;
		}
	}
	final HashMap<String, ConnectorRef> connectors = new HashMap<String, ConnectorRef>();
	@Override
	protected void doStart() throws Exception {
		server = createServer();
		super.doStart();
	}
	private Server createServer() throws Exception {
		setCamelServlet(new CamelServlet());
		Server server = new Server();
		Context context = new Context(Context.NO_SECURITY|Context.NO_SESSIONS);
		context.setContextPath(""/"");
		ServletHolder holder = new ServletHolder();
		holder.setServlet(getCamelServlet());
		context.addServlet(holder, ""/*"");		
		server.setHandler(context);
		server.start();
		return server;
	}
	@Override
	protected void doStop() throws Exception {
		for (ConnectorRef connectorRef : connectors.values()) {
			connectorRef.connector.stop();
		}
		connectors.clear();
		server.stop();
		super.doStop();
	}
	@Override
	public void connect(HttpConsumer consumer) throws Exception {
		// Make sure that there is a connector for the requested endpoint.
		HttpEndpoint endpoint = (HttpEndpoint) consumer.getEndpoint();
		String connectorKey = endpoint.getProtocol()+"":""+endpoint.getPort();
		synchronized(connectors) {
			ConnectorRef connectorRef = connectors.get(connectorKey);
			if( connectorRef == null ) {
				Connector connector;
				if( ""https"".equals(endpoint.getProtocol()) ) {
					connector = new SslSocketConnector();
				} else {
					connector = new SelectChannelConnector();
				}
				connector.setPort(endpoint.getPort());
				server.addConnector(connector);
				connector.start();
				connectorRef = new ConnectorRef(connector);
			} else {
				// ref track the connector
				connectorRef.increment();
			}
		}
		super.connect(consumer);
	}
	@Override
	public void disconnect(HttpConsumer consumer) throws Exception {
		super.disconnect(consumer);
		// If the connector is not needed anymore.. then stop it.
		HttpEndpoint endpoint = (HttpEndpoint) consumer.getEndpoint();
		String connectorKey = endpoint.getProtocol()+"":""+endpoint.getPort();
		synchronized(connectors) {
			ConnectorRef connectorRef = connectors.get(connectorKey);
			if( connectorRef != null ) {
				if( connectorRef.decrement() == 0 ) {
					server.removeConnector(connectorRef.connector);
					connectorRef.connector.stop();
					connectors.remove(connectorKey);
				}
			}
		}
	}
}
"
org.apache.camel.bam.model.ActivityDefinition,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
/**
 * @version $Revision: 1.1 $
 */
@Entity
public class ActivityDefinition extends EntitySupport {
    private String name;
    private ProcessDefinition processDefinition;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""Activity["" + getId() + "" name: "" + getName() + ""]"";
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST})
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
}
"
org.apache.camel.component.http.HttpBinding,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
/**
 * @version $Revision$
 */
public class HttpBinding {
    /**
     * Writes the  exchange to the servlet response
     */
    public void writeResponse(HttpExchange exchange) {
        /** TODO */
    }
    /**
     * Parses the body from a HTTP message
     */
    public Object parseBody(HttpMessage httpMessage) throws IOException {
        // lets assume the body is a reader
        HttpServletRequest request = httpMessage.getRequest();
        return request.getReader();
    }
}
"
org.apache.camel.component.http.HttpEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.http;
import java.net.URI;
import java.net.URISyntaxException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
/**
 * Represents a <a href=""http://activemq.apache.org/camel/http.html"">HTTP endpoint</a>
 *
 * @version $Revision$
 */
public class HttpEndpoint extends DefaultEndpoint<HttpExchange> {
    private HttpBinding binding;
	private HttpComponent component;
	private URI httpUri;
    protected HttpEndpoint(String uri, HttpComponent component) throws URISyntaxException {
        super(uri, component);
		this.component = component;
		this.httpUri = new URI(uri);
    }
    public HttpProducer createProducer() throws Exception {
    	return new HttpProducer(this);
    }
    public Consumer<HttpExchange> createConsumer(Processor processor) throws Exception {
        return new HttpConsumer(this, processor);
    }
    public HttpExchange createExchange() {
        return new HttpExchange(this);
    }
    public HttpExchange createExchange(HttpServletRequest request, HttpServletResponse response) {
        return new HttpExchange(this, request, response);
    }
    public HttpBinding getBinding() {
        if (binding == null) {
            binding = new HttpBinding();
        }
        return binding;
    }
    public void setBinding(HttpBinding binding) {
        this.binding = binding;
    }
	public boolean isSingleton() {
		return true;
	}
	public void connect(HttpConsumer consumer) throws Exception {
		component.connect(consumer);
	}
	public void disconnect(HttpConsumer consumer) throws Exception {
		component.disconnect(consumer);
	}
	public String getPath() {
		return httpUri.getPath();
	}
	public int getPort() {
		if( httpUri.getPort() == -1 ) {
			if( ""https"".equals(getProtocol() ) ) {
				return 443;
			} else {
				return 80;
			}
		}
		return httpUri.getPort();
	}
	public String getProtocol() {
		return httpUri.getScheme(); 
	}
}
"
org.apache.camel.component.quartz.QuartzEndpoint,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.JobDetail;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.SimpleTrigger;
import java.util.Date;
import java.util.Map;
import java.util.Set;
/**
 * A <a href=""http://activemq.apache.org/quartz.html"">Quartz Endpoint</a>
 *
 * @version $Revision:520964 $
 */
public class QuartzEndpoint extends DefaultEndpoint<QuartzExchange> {
    public static final String ENDPOINT_KEY = ""org.apache.camel.quartz"";
    private static final transient Log log = LogFactory.getLog(QuartzEndpoint.class);
    private Scheduler scheduler;
    private LoadBalancer loadBalancer;
    private Trigger trigger;
    private JobDetail jobDetail;
    private boolean started;
    public QuartzEndpoint(String endpointUri, QuartzComponent component, Scheduler scheduler) {
        super(endpointUri, component);
        this.scheduler = scheduler;
    }
    public void addTriggers(Map<Trigger, JobDetail> triggerMap) throws SchedulerException {
        if (triggerMap != null) {
            Set<Map.Entry<Trigger, JobDetail>> entries = triggerMap.entrySet();
            for (Map.Entry<Trigger, JobDetail> entry : entries) {
                Trigger key = entry.getKey();
                JobDetail value = entry.getValue();
                ObjectHelper.notNull(key, ""key"");
                ObjectHelper.notNull(value, ""value"");
                addTrigger(key, value);
            }
        }
    }
    public void addTrigger(Trigger trigger, JobDetail detail) throws SchedulerException {
        // lets default the trigger name to the job name
        if (trigger.getName() == null) {
            trigger.setName(detail.getName());
        }
        // lets default the trigger group to the job group
        if (trigger.getGroup() == null) {
            trigger.setGroup(detail.getGroup());
        }
        // default start time to now if not specified
        if (trigger.getStartTime() == null) {
            trigger.setStartTime(new Date());
        }
        detail.getJobDataMap().put(ENDPOINT_KEY, this);
        Class jobClass = detail.getJobClass();
        if (jobClass == null) {
            detail.setJobClass(CamelJob.class);
        }
        if (detail.getName() == null) {
            detail.setName(getEndpointUri());
        }
        getScheduler().scheduleJob(detail, trigger);
    }
    public void removeTrigger(Trigger trigger, JobDetail jobDetail) throws SchedulerException {
        getScheduler().unscheduleJob(trigger.getName(), trigger.getGroup());
    }
    /**
     * This method is invoked when a Quartz job is fired.
     *
     * @param jobExecutionContext the Quartz Job context
     */
    public void onJobExecute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        if (log.isDebugEnabled()) {
            log.debug(""Firing Quartz Job with context: "" + jobExecutionContext);
        }
        QuartzExchange exchange = createExchange(jobExecutionContext);
        try {
            getLoadBalancer().process(exchange);
        }
        catch (JobExecutionException e) {
            throw e;
        }
        catch (Exception e) {
            throw new JobExecutionException(e);
        }
    }
    public QuartzExchange createExchange() {
        return new QuartzExchange(getContext(), null);
    }
    public QuartzExchange createExchange(JobExecutionContext jobExecutionContext) {
        return new QuartzExchange(getContext(), jobExecutionContext);
    }
    public Producer<QuartzExchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""You cannot send messages to this endpoint"");
    }
    public QuartzConsumer createConsumer(Processor processor) throws Exception {
        return new QuartzConsumer(this, processor);
    }
    // Properties
    //-------------------------------------------------------------------------
    @Override
    public QuartzComponent getComponent() {
        return (QuartzComponent) super.getComponent();
    }
    public boolean isSingleton() {
        return true;
    }
    public Scheduler getScheduler() {
        return scheduler;
    }
    public LoadBalancer getLoadBalancer() {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer();
        }
        return loadBalancer;
    }
    public void setLoadBalancer(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    public JobDetail getJobDetail() {
        if (jobDetail == null) {
            jobDetail = createJobDetail();
        }
        return jobDetail;
    }
    public void setJobDetail(JobDetail jobDetail) {
        this.jobDetail = jobDetail;
    }
    public Trigger getTrigger() {
        if (trigger == null) {
            trigger = createTrigger();
        }
        return trigger;
    }
    public void setTrigger(Trigger trigger) {
        this.trigger = trigger;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    public synchronized void consumerStarted(QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().addProcessor(consumer.getProcessor());
        // if we have not yet added our default trigger, then lets do it
        if (!started) {
            addTrigger(getTrigger(), getJobDetail());
            started = true;
        }
    }
    public synchronized void consumerStopped(QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().removeProcessor(consumer.getProcessor());
        if (getLoadBalancer().getProcessors().isEmpty() && started) {
            removeTrigger(getTrigger(), getJobDetail());
            started = false;
        }
    }
    protected LoadBalancer createLoadBalancer() {
        return new RoundRobinLoadBalancer();
    }
    protected JobDetail createJobDetail() {
        return new JobDetail();
    }
    protected Trigger createTrigger() {
        return new SimpleTrigger();
    }
}"
org.apache.camel.spring.xml.BuilderStatement,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.xml;
import java.util.ArrayList;
import org.springframework.beans.factory.BeanFactory;
public class BuilderStatement {
	private ArrayList<BuilderAction> actions;
	private Class returnType;
	public Object create(BeanFactory beanFactory, Object rootBuilder) {
		Object currentBuilder = rootBuilder;
		BuilderAction lastAction=null;
		for (BuilderAction action : actions) {
			// The last action may have left us without a builder to invoke next!
			if( currentBuilder == null ) {
				throw new IllegalArgumentException(""Invalid configuration.  The '""+lastAction.getName()+""' action cannot be followed by the '""+action.getName()+""' action."");
			}
			currentBuilder = action.invoke(beanFactory, rootBuilder, currentBuilder);
			lastAction = action;
		}
		return currentBuilder;
	}
	public ArrayList<BuilderAction> getActions() {
		return actions;
	}
	public void setActions(ArrayList<BuilderAction> actions) {
		this.actions = actions;
	}
	public Class getReturnType() {
		return returnType;
	}
	public void setReturnType(Class returnType) {
		this.returnType = returnType;
	}
}
"
org.apache.camel.component.jms.MessagePropertyNamesAccessException,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyNamesAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessagePropertyNamesAccessException(JMSException e) {
        super(""Failed to acess the JMS message property names"", e);
    }
}
"
org.apache.camel.component.rmi.RmiProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.rmi.AccessException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.registry.Registry;
import org.apache.camel.component.pojo.PojoEndpoint;
import org.apache.camel.component.pojo.PojoExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.Exchange;
/**
 * @version $Revision: 533076 $
 */
public class RmiProducer extends DefaultProducer {
	private final RmiEndpoint endpoint;
	private Remote remote;
	public RmiProducer(RmiEndpoint endpoint) throws AccessException, RemoteException, NotBoundException {
		super(endpoint);
		this.endpoint = endpoint;
	}
	public void process(Exchange exchange) throws AccessException, RemoteException, NotBoundException {
        PojoExchange pojoExchange = endpoint.toExchangeType(exchange);
        PojoEndpoint.invoke(getRemote(), pojoExchange);
        exchange.copyFrom(pojoExchange);
    }
	public Remote getRemote() throws AccessException, RemoteException, NotBoundException {
		if( remote == null ) {
			Registry registry = endpoint.getRegistry();				
			remote = registry.lookup(endpoint.getName());			
		}
		return remote;
	}
}
"
org.apache.camel.bam.processor.ActivityMonitorEngine,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.impl.ServiceSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaCallback;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceException;
import java.util.Date;
import java.util.List;
/**
 * A timer engine to monitor for expired activities and perform whatever actions are required.
 *
 * @version $Revision: $
 */
public class ActivityMonitorEngine extends ServiceSupport implements Runnable {
    private static final Log log = LogFactory.getLog(ActivityMonitorEngine.class);
    private JpaTemplate template;
    private TransactionTemplate transactionTemplate;
    private ProcessRules rules;
    private int escalateLevel = 0;
    private long windowMillis = 1000L;
    private Thread thread;
    private boolean useLocking = false;
    public ActivityMonitorEngine(JpaTemplate template, TransactionTemplate transactionTemplate, ProcessRules rules) {
        this.template = template;
        this.transactionTemplate = transactionTemplate;
        this.rules = rules;
    }
    public boolean isUseLocking() {
        return useLocking;
    }
    public void setUseLocking(boolean useLocking) {
        this.useLocking = useLocking;
    }
    public void run() {
        log.debug(""Starting to poll for timeout events"");
        while (!isStopped()) {
            try {
                long now = System.currentTimeMillis();
                long nextPoll = now + windowMillis;
                final Date timeNow = new Date(now);
                transactionTemplate.execute(new TransactionCallbackWithoutResult() {
                    protected void doInTransactionWithoutResult(TransactionStatus status) {
                        List<ActivityState> list = template.find(""select x from "" + ActivityState.class.getName() + "" x where x.escalationLevel = ?1 and x.timeOverdue < ?2"", escalateLevel, timeNow);
                        for (ActivityState activityState : list) {
                            fireExpiredEvent(activityState);
                        }
                    }
                });
                long timeToSleep = nextPoll - System.currentTimeMillis();
                if (timeToSleep > 0) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Sleeping for "" + timeToSleep + "" millis"");
                    }
                    try {
                        Thread.sleep(timeToSleep);
                    }
                    catch (InterruptedException e) {
                        log.debug(""Caught: "" + e, e);
                    }
                }
            }
            catch (Exception e) {
                log.error(""Caught: "" + e, e);
            }
        }
    }
    protected void fireExpiredEvent(final ActivityState activityState) {
        if (log.isDebugEnabled()) {
            log.debug(""Trying to fire expiration of: "" + activityState);
        }
        template.execute(new JpaCallback() {
            public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                // lets try lock the object first
                if (isUseLocking()) {
                    log.info(""Attempting to lock: "" + activityState);
                    entityManager.lock(activityState, LockModeType.WRITE);
                    log.info(""Grabbed lock: "" + activityState);
                }
                try {
                    rules.processExpired(activityState);
                }
                catch (Exception e) {
                    log.error(""Failed to process expiration of: "" + activityState + "". Reason: "" + e, e);
                }
                activityState.setEscalationLevel(escalateLevel + 1);
                return null;
            }
        });
    }
    protected void doStart() throws Exception {
        rules.start();
        thread = new Thread(this, ""ActivityMonitorEngine"");
        thread.start();
    }
    protected void doStop() throws Exception {
        if (thread != null) {
            thread = null;
        }
        rules.stop();
    }
}
"
org.apache.camel.component.jms.EndpointMessageListener,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import javax.jms.MessageListener;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A JMS {@link MessageListener} which can be used to delegate processing to a Camel endpoint.
 *
 * @version $Revision$
 */
public class EndpointMessageListener<E extends Exchange> implements MessageListener {
    private static final transient Log log = LogFactory.getLog(EndpointMessageListener.class);
    private Endpoint<E> endpoint;
    private Processor processor;
    private JmsBinding binding;
    public EndpointMessageListener(Endpoint<E> endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    public void onMessage(Message message) {
        try {
        	if (log.isDebugEnabled()) {
			    log.debug(endpoint + "" receiving JMS message: "" + message);
			}
			JmsExchange exchange = createExchange(message);
			processor.process((E) exchange);
		} catch (Exception e) {
			throw new RuntimeCamelException(e);
		}
    }
    public JmsExchange createExchange(Message message) {
        return new JmsExchange(endpoint.getContext(), getBinding(), message);
    }
    // Properties
    //-------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS message
     *
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
}
"
org.apache.camel.component.jms.ConsumerType,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
/**
 * @version $Revision$
 */
public enum ConsumerType {
    Simple, Default, ServerSessionPool
}
"
org.apache.camel.builder.sql.SqlBuilder,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.sql;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.util.ObjectHelper;
import org.josql.Query;
import org.josql.QueryExecutionException;
import org.josql.QueryParseException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
/**
 * A builder of SQL {@link org.apache.camel.Expression} and {@link org.apache.camel.Predicate} implementations
 *
 * @version $Revision: $
 */
public class SqlBuilder<E extends Exchange> implements Expression<E>, Predicate<E> {
    private Query query;
    private Map<String,Object> variables = new HashMap<String, Object>();
    public SqlBuilder(Query query) {
        this.query = query;
    }
    public Object evaluate(E exchange) {
        return evaluateQuery(exchange);
    }
    public boolean matches(E exchange) {
        List list = evaluateQuery(exchange);
        return matches(exchange, list);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        List list = evaluateQuery(exchange);
        if (!matches(exchange, list)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as found "" + list);
        }
    }
    // Builder API
    //-----------------------------------------------------------------------
    /**
     * Creates a new builder for the given SQL query string
     *
     * @param sql the SQL query to perform
     * @return a new builder
     * @throws QueryParseException if there is an issue with the SQL
     */
    public static <E extends Exchange> SqlBuilder<E> sql(String sql) throws QueryParseException {
        Query q = new Query();
        q.parse(sql);
        return new SqlBuilder(q);
    }
    /**
     * Adds the variable value to be used by the SQL query
     */
    public SqlBuilder<E> variable(String name, Object value) {
        getVariables().put(name, value);
        return this;
    }
    // Properties
    //-----------------------------------------------------------------------
    public Map<String, Object> getVariables() {
        return variables;
    }
    public void setVariables(Map<String, Object> properties) {
        this.variables = properties;
    }
    // Implementation methods
    //-----------------------------------------------------------------------
    protected boolean matches(E exchange, List list) {
        return ObjectHelper.matches(list);
    }
    protected List evaluateQuery(E exchange) {
        configureQuery(exchange);
        Message in = exchange.getIn();
        List list = in.getBody(List.class);
        if (list == null) {
            list = Collections.singletonList(in.getBody());
        }
        try {
            return query.execute(list).getResults();
        }
        catch (QueryExecutionException e) {
            throw new RuntimeExpressionException(e);
        }
    }
    protected void configureQuery(E exchange) {
        // lets pass in the headers as variables that the SQL can use
        addVariables(exchange.getProperties());
        addVariables(exchange.getIn().getHeaders());
        addVariables(getVariables());
        query.setVariable(""exchange"", exchange);
        query.setVariable(""in"", exchange.getIn());
        query.setVariable(""out"", exchange.getOut());
    }
    protected void addVariables(Map <String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            query.setVariable(entry.getKey(), entry.getValue());
        }
    }
}
"
org.apache.camel.component.mail.MailConverters,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.Converter;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import java.io.IOException;
/**
 * @version $Revision: 1.1 $
 */
@Converter
public class MailConverters {
    /**
     * Converts the given JavaMail message to a String body
     *
     * @param message the message
     * @return the String content
     * @throws MessagingException
     * @throws IOException
     */
    @Converter
    public String toString(Message message) throws MessagingException, IOException {
        Object content = message.getContent();
        if (content instanceof MimeMultipart) {
            MimeMultipart multipart = (MimeMultipart) content;
            if (multipart.getCount() > 0) {
                BodyPart part = multipart.getBodyPart(0);
                content = part.getContent();
            }
        }
        if (content != null) {
            return content.toString();
        }
        return null;
    }
    @Converter
    public static String toString(Multipart multipart) throws MessagingException, IOException {
        for (int i = 0, size = multipart.getCount(); i < size; i++) {
            BodyPart part = multipart.getBodyPart(i);
            if (part.getContentType().startsWith(""text"")) {
                return part.getContent().toString();
            }
        }
        return null;
    }
}
"
