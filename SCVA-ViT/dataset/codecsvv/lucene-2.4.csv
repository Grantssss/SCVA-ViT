metric_name,file
org.apache.lucene.LucenePackage,"/*    */ package org.apache.lucene;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LucenePackage
/*    */ {
/* 27 */   public static Package get() { return LucenePackage.class.getPackage(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\LucenePackage.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Analyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Analyzer
/*    */ {
/*    */   public abstract TokenStream tokenStream(String paramString, Reader paramReader);
/*    */   
/* 44 */   public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException { return tokenStream(fieldName, reader); }
/*    */ 
/*    */   
/* 47 */   private ThreadLocal tokenStreams = new ThreadLocal();
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 53 */   protected Object getPreviousTokenStream() { return this.tokenStreams.get(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 60 */   protected void setPreviousTokenStream(Object obj) { this.tokenStreams.set(obj); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 79 */   public int getPositionIncrementGap(String fieldName) { return 0; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\Analyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.CachingTokenFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Iterator;
/*    */ import java.util.LinkedList;
/*    */ import java.util.List;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CachingTokenFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   private List cache;
/*    */   private Iterator iterator;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/* 40 */   public CachingTokenFilter(TokenStream input) { super(input); }
/*    */ 
/*    */   
/*    */   public Token next(Token reusableToken) throws IOException {
/* 44 */     assert reusableToken != null;
/* 45 */     if (this.cache == null) {
/*    */       
/* 47 */       this.cache = new LinkedList();
/* 48 */       fillCache(reusableToken);
/* 49 */       this.iterator = this.cache.iterator();
/*    */     } 
/*    */     
/* 52 */     if (!this.iterator.hasNext())
/*    */     {
/* 54 */       return null;
/*    */     }
/*    */     
/* 57 */     Token nextToken = this.iterator.next();
/* 58 */     return (Token)nextToken.clone();
/*    */   }
/*    */   
/*    */   public void reset() throws IOException {
/* 62 */     if (this.cache != null) {
/* 63 */       this.iterator = this.cache.iterator();
/*    */     }
/*    */   }
/*    */   
/*    */   private void fillCache(Token reusableToken) throws IOException {
/* 68 */     for (Token nextToken = this.input.next(reusableToken); nextToken != null; nextToken = this.input.next(reusableToken))
/* 69 */       this.cache.add(nextToken.clone()); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\CachingTokenFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.CharArraySet,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.util.AbstractSet;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class CharArraySet
/*     */   extends AbstractSet
/*     */ {
/*     */   private static final int INIT_SIZE = 8;
/*     */   private char[][] entries;
/*     */   private int count;
/*     */   private final boolean ignoreCase;
/*     */   
/*     */   public CharArraySet(int startSize, boolean ignoreCase) {
/*  44 */     this.ignoreCase = ignoreCase;
/*  45 */     int size = 8;
/*  46 */     while (startSize + (startSize >> 2) > size)
/*  47 */       size <<= 1; 
/*  48 */     this.entries = new char[size][];
/*     */   }
/*     */ 
/*     */   
/*     */   public CharArraySet(Collection c, boolean ignoreCase) {
/*  53 */     this(c.size(), ignoreCase);
/*  54 */     addAll(c);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public boolean contains(char[] text, int off, int len) { return (this.entries[getSlot(text, off, len)] != null); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  65 */   public boolean contains(CharSequence cs) { return (this.entries[getSlot(cs)] != null); }
/*     */ 
/*     */   
/*     */   private int getSlot(char[] text, int off, int len) {
/*  69 */     int code = getHashCode(text, off, len);
/*  70 */     int pos = code & this.entries.length - 1;
/*  71 */     char[] text2 = this.entries[pos];
/*  72 */     if (text2 != null && !equals(text, off, len, text2)) {
/*  73 */       int inc = (code >> 8) + code | 0x1;
/*     */       do {
/*  75 */         code += inc;
/*  76 */         pos = code & this.entries.length - 1;
/*  77 */         text2 = this.entries[pos];
/*  78 */       } while (text2 != null && !equals(text, off, len, text2));
/*     */     } 
/*  80 */     return pos;
/*     */   }
/*     */ 
/*     */   
/*     */   private int getSlot(CharSequence text) {
/*  85 */     int code = getHashCode(text);
/*  86 */     int pos = code & this.entries.length - 1;
/*  87 */     char[] text2 = this.entries[pos];
/*  88 */     if (text2 != null && !equals(text, text2)) {
/*  89 */       int inc = (code >> 8) + code | 0x1;
/*     */       do {
/*  91 */         code += inc;
/*  92 */         pos = code & this.entries.length - 1;
/*  93 */         text2 = this.entries[pos];
/*  94 */       } while (text2 != null && !equals(text, text2));
/*     */     } 
/*  96 */     return pos;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 101 */   public boolean add(CharSequence text) { return add(text.toString()); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public boolean add(String text) { return add(text.toCharArray()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean add(char[] text) {
/* 114 */     if (this.ignoreCase)
/* 115 */       for (int i = 0; i < text.length; i++)
/* 116 */         text[i] = Character.toLowerCase(text[i]);  
/* 117 */     int slot = getSlot(text, 0, text.length);
/* 118 */     if (this.entries[slot] != null) return false; 
/* 119 */     this.entries[slot] = text;
/* 120 */     this.count++;
/*     */     
/* 122 */     if (this.count + (this.count >> 2) > this.entries.length) {
/* 123 */       rehash();
/*     */     }
/*     */     
/* 126 */     return true;
/*     */   }
/*     */   
/*     */   private boolean equals(char[] text1, int off, int len, char[] text2) {
/* 130 */     if (len != text2.length)
/* 131 */       return false; 
/* 132 */     if (this.ignoreCase) {
/* 133 */       for (int i = 0; i < len; i++) {
/* 134 */         if (Character.toLowerCase(text1[off + i]) != text2[i])
/* 135 */           return false; 
/*     */       } 
/*     */     } else {
/* 138 */       for (int i = 0; i < len; i++) {
/* 139 */         if (text1[off + i] != text2[i])
/* 140 */           return false; 
/*     */       } 
/*     */     } 
/* 143 */     return true;
/*     */   }
/*     */   
/*     */   private boolean equals(CharSequence text1, char[] text2) {
/* 147 */     int len = text1.length();
/* 148 */     if (len != text2.length)
/* 149 */       return false; 
/* 150 */     if (this.ignoreCase) {
/* 151 */       for (int i = 0; i < len; i++) {
/* 152 */         if (Character.toLowerCase(text1.charAt(i)) != text2[i])
/* 153 */           return false; 
/*     */       } 
/*     */     } else {
/* 156 */       for (int i = 0; i < len; i++) {
/* 157 */         if (text1.charAt(i) != text2[i])
/* 158 */           return false; 
/*     */       } 
/*     */     } 
/* 161 */     return true;
/*     */   }
/*     */   
/*     */   private void rehash() {
/* 165 */     int newSize = 2 * this.entries.length;
/* 166 */     char[][] oldEntries = this.entries;
/* 167 */     this.entries = new char[newSize][];
/*     */     
/* 169 */     for (int i = 0; i < oldEntries.length; i++) {
/* 170 */       char[] text = oldEntries[i];
/* 171 */       if (text != null)
/*     */       {
/* 173 */         this.entries[getSlot(text, 0, text.length)] = text;
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   private int getHashCode(char[] text, int offset, int len) {
/* 179 */     int code = 0;
/* 180 */     int stop = offset + len;
/* 181 */     if (this.ignoreCase) {
/* 182 */       for (int i = offset; i < stop; i++) {
/* 183 */         code = code * 31 + Character.toLowerCase(text[i]);
/*     */       }
/*     */     } else {
/* 186 */       for (int i = offset; i < stop; i++) {
/* 187 */         code = code * 31 + text[i];
/*     */       }
/*     */     } 
/* 190 */     return code;
/*     */   }
/*     */   
/*     */   private int getHashCode(CharSequence text) {
/*     */     int code;
/* 195 */     if (this.ignoreCase) {
/* 196 */       code = 0;
/* 197 */       int len = text.length();
/* 198 */       for (int i = 0; i < len; i++) {
/* 199 */         code = code * 31 + Character.toLowerCase(text.charAt(i));
/*     */       
/*     */       }
/*     */     }
/*     */     else {
/*     */       
/* 205 */       code = 0;
/* 206 */       int len = text.length();
/* 207 */       for (int i = 0; i < len; i++) {
/* 208 */         code = code * 31 + text.charAt(i);
/*     */       }
/*     */     } 
/*     */     
/* 212 */     return code;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 217 */   public int size() { return this.count; }
/*     */ 
/*     */ 
/*     */   
/* 221 */   public boolean isEmpty() { return (this.count == 0); }
/*     */ 
/*     */   
/*     */   public boolean contains(Object o) {
/* 225 */     if (o instanceof char[]) {
/* 226 */       char[] text = (char[])o;
/* 227 */       return contains(text, 0, text.length);
/* 228 */     }  if (o instanceof CharSequence) {
/* 229 */       return contains((CharSequence)o);
/*     */     }
/* 231 */     return false;
/*     */   }
/*     */   
/*     */   public boolean add(Object o) {
/* 235 */     if (o instanceof char[])
/* 236 */       return add((char[])o); 
/* 237 */     if (o instanceof String)
/* 238 */       return add((String)o); 
/* 239 */     if (o instanceof CharSequence) {
/* 240 */       return add((CharSequence)o);
/*     */     }
/* 242 */     return add(o.toString());
/*     */   }
/*     */ 
/*     */   
/*     */   public class CharArraySetIterator
/*     */     implements Iterator
/*     */   {
/* 249 */     int pos = -1; char[] next;
/*     */     private final CharArraySet this$0;
/*     */     
/* 252 */     CharArraySetIterator() { goNext(); }
/*     */ 
/*     */     
/*     */     private void goNext() {
/* 256 */       this.next = null;
/* 257 */       this.pos++;
/* 258 */       for (; this.pos < CharArraySet.this.entries.length && (this.next = CharArraySet.this.entries[this.pos]) == null; this.pos++);
/*     */     }
/*     */ 
/*     */     
/* 262 */     public boolean hasNext() { return (this.next != null); }
/*     */ 
/*     */ 
/*     */     
/*     */     public char[] nextCharArray() {
/* 267 */       char[] ret = this.next;
/* 268 */       goNext();
/* 269 */       return ret;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 275 */     public Object next() { return new String(nextCharArray()); }
/*     */ 
/*     */ 
/*     */     
/* 279 */     public void remove() { throw new UnsupportedOperationException(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 285 */   public Iterator iterator() { return new CharArraySetIterator(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\CharArraySet.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.CharTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class CharTokenizer
/*    */   extends Tokenizer
/*    */ {
/*    */   private int offset;
/*    */   private int bufferIndex;
/*    */   private int dataLen;
/*    */   private static final int MAX_WORD_LEN = 255;
/*    */   private static final int IO_BUFFER_SIZE = 4096;
/*    */   private final char[] ioBuffer;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public CharTokenizer(Reader input) {
/* 26 */     super(input);
/*    */ 
/*    */     
/* 29 */     this.offset = 0; this.bufferIndex = 0; this.dataLen = 0;
/*    */ 
/*    */     
/* 32 */     this.ioBuffer = new char[4096];
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   protected char normalize(char c) { return c; }
/*    */ 
/*    */   
/*    */   public final Token next(Token reusableToken) throws IOException {
/* 48 */     assert reusableToken != null;
/* 49 */     reusableToken.clear();
/* 50 */     int length = 0;
/* 51 */     int start = this.bufferIndex;
/* 52 */     char[] buffer = reusableToken.termBuffer();
/*    */     
/*    */     while (true) {
/* 55 */       if (this.bufferIndex >= this.dataLen) {
/* 56 */         this.offset += this.dataLen;
/* 57 */         this.dataLen = this.input.read(this.ioBuffer);
/* 58 */         if (this.dataLen == -1) {
/* 59 */           if (length > 0) {
/*    */             break;
/*    */           }
/* 62 */           return null;
/*    */         } 
/* 64 */         this.bufferIndex = 0;
/*    */       } 
/*    */       
/* 67 */       char c = this.ioBuffer[this.bufferIndex++];
/*    */       
/* 69 */       if (isTokenChar(c)) {
/*    */         
/* 71 */         if (length == 0) {
/* 72 */           start = this.offset + this.bufferIndex - 1;
/* 73 */         } else if (length == buffer.length) {
/* 74 */           buffer = reusableToken.resizeTermBuffer(1 + length);
/*    */         } 
/* 76 */         buffer[length++] = normalize(c);
/*    */         
/* 78 */         if (length == 255)
/*    */           break;  continue;
/*    */       } 
/* 81 */       if (length > 0) {
/*    */         break;
/*    */       }
/*    */     } 
/* 85 */     reusableToken.setTermLength(length);
/* 86 */     reusableToken.setStartOffset(start);
/* 87 */     reusableToken.setEndOffset(start + length);
/* 88 */     return reusableToken;
/*    */   }
/*    */   
/*    */   public void reset(Reader input) throws IOException {
/* 92 */     super.reset(input);
/* 93 */     this.bufferIndex = 0;
/* 94 */     this.offset = 0;
/* 95 */     this.dataLen = 0;
/*    */   }
/*    */   
/*    */   protected abstract boolean isTokenChar(char paramChar);
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\CharTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.ISOLatin1AccentFilter,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ISOLatin1AccentFilter
/*     */   extends TokenFilter
/*     */ {
/*     */   private char[] output;
/*     */   private int outputPos;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public ISOLatin1AccentFilter(TokenStream input) {
/*  29 */     super(input);
/*     */ 
/*     */     
/*  32 */     this.output = new char[256];
/*     */   }
/*     */   
/*     */   public final Token next(Token reusableToken) throws IOException {
/*  36 */     assert reusableToken != null;
/*  37 */     Token nextToken = this.input.next(reusableToken);
/*  38 */     if (nextToken != null) {
/*  39 */       char[] buffer = nextToken.termBuffer();
/*  40 */       int length = nextToken.termLength();
/*     */ 
/*     */       
/*  43 */       for (int i = 0; i < length; i++) {
/*  44 */         char c = buffer[i];
/*  45 */         if (c >= 'À' && c <= 'ﬆ') {
/*  46 */           removeAccents(buffer, length);
/*  47 */           nextToken.setTermBuffer(this.output, 0, this.outputPos);
/*     */           break;
/*     */         } 
/*     */       } 
/*  51 */       return nextToken;
/*     */     } 
/*  53 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void removeAccents(char[] input, int length) {
/*  62 */     int maxSizeNeeded = 2 * length;
/*     */     
/*  64 */     int size = this.output.length;
/*  65 */     while (size < maxSizeNeeded) {
/*  66 */       size *= 2;
/*     */     }
/*  68 */     if (size != this.output.length) {
/*  69 */       this.output = new char[size];
/*     */     }
/*  71 */     this.outputPos = 0;
/*     */     
/*  73 */     int pos = 0;
/*     */     
/*  75 */     for (int i = 0; i < length; i++, pos++) {
/*  76 */       char c = input[pos];
/*     */ 
/*     */ 
/*     */       
/*  80 */       if (c < 'À' || c > 'ﬆ') {
/*  81 */         this.output[this.outputPos++] = c;
/*     */       } else {
/*  83 */         switch (c) {
/*     */           case 'À':
/*     */           case 'Á':
/*     */           case 'Â':
/*     */           case 'Ã':
/*     */           case 'Ä':
/*     */           case 'Å':
/*  90 */             this.output[this.outputPos++] = 'A';
/*     */             break;
/*     */           case 'Æ':
/*  93 */             this.output[this.outputPos++] = 'A';
/*  94 */             this.output[this.outputPos++] = 'E';
/*     */             break;
/*     */           case 'Ç':
/*  97 */             this.output[this.outputPos++] = 'C';
/*     */             break;
/*     */           case 'È':
/*     */           case 'É':
/*     */           case 'Ê':
/*     */           case 'Ë':
/* 103 */             this.output[this.outputPos++] = 'E';
/*     */             break;
/*     */           case 'Ì':
/*     */           case 'Í':
/*     */           case 'Î':
/*     */           case 'Ï':
/* 109 */             this.output[this.outputPos++] = 'I';
/*     */             break;
/*     */           case 'Ĳ':
/* 112 */             this.output[this.outputPos++] = 'I';
/* 113 */             this.output[this.outputPos++] = 'J';
/*     */             break;
/*     */           case 'Ð':
/* 116 */             this.output[this.outputPos++] = 'D';
/*     */             break;
/*     */           case 'Ñ':
/* 119 */             this.output[this.outputPos++] = 'N';
/*     */             break;
/*     */           case 'Ò':
/*     */           case 'Ó':
/*     */           case 'Ô':
/*     */           case 'Õ':
/*     */           case 'Ö':
/*     */           case 'Ø':
/* 127 */             this.output[this.outputPos++] = 'O';
/*     */             break;
/*     */           case 'Œ':
/* 130 */             this.output[this.outputPos++] = 'O';
/* 131 */             this.output[this.outputPos++] = 'E';
/*     */             break;
/*     */           case 'Þ':
/* 134 */             this.output[this.outputPos++] = 'T';
/* 135 */             this.output[this.outputPos++] = 'H';
/*     */             break;
/*     */           case 'Ù':
/*     */           case 'Ú':
/*     */           case 'Û':
/*     */           case 'Ü':
/* 141 */             this.output[this.outputPos++] = 'U';
/*     */             break;
/*     */           case 'Ý':
/*     */           case 'Ÿ':
/* 145 */             this.output[this.outputPos++] = 'Y';
/*     */             break;
/*     */           case 'à':
/*     */           case 'á':
/*     */           case 'â':
/*     */           case 'ã':
/*     */           case 'ä':
/*     */           case 'å':
/* 153 */             this.output[this.outputPos++] = 'a';
/*     */             break;
/*     */           case 'æ':
/* 156 */             this.output[this.outputPos++] = 'a';
/* 157 */             this.output[this.outputPos++] = 'e';
/*     */             break;
/*     */           case 'ç':
/* 160 */             this.output[this.outputPos++] = 'c';
/*     */             break;
/*     */           case 'è':
/*     */           case 'é':
/*     */           case 'ê':
/*     */           case 'ë':
/* 166 */             this.output[this.outputPos++] = 'e';
/*     */             break;
/*     */           case 'ì':
/*     */           case 'í':
/*     */           case 'î':
/*     */           case 'ï':
/* 172 */             this.output[this.outputPos++] = 'i';
/*     */             break;
/*     */           case 'ĳ':
/* 175 */             this.output[this.outputPos++] = 'i';
/* 176 */             this.output[this.outputPos++] = 'j';
/*     */             break;
/*     */           case 'ð':
/* 179 */             this.output[this.outputPos++] = 'd';
/*     */             break;
/*     */           case 'ñ':
/* 182 */             this.output[this.outputPos++] = 'n';
/*     */             break;
/*     */           case 'ò':
/*     */           case 'ó':
/*     */           case 'ô':
/*     */           case 'õ':
/*     */           case 'ö':
/*     */           case 'ø':
/* 190 */             this.output[this.outputPos++] = 'o';
/*     */             break;
/*     */           case 'œ':
/* 193 */             this.output[this.outputPos++] = 'o';
/* 194 */             this.output[this.outputPos++] = 'e';
/*     */             break;
/*     */           case 'ß':
/* 197 */             this.output[this.outputPos++] = 's';
/* 198 */             this.output[this.outputPos++] = 's';
/*     */             break;
/*     */           case 'þ':
/* 201 */             this.output[this.outputPos++] = 't';
/* 202 */             this.output[this.outputPos++] = 'h';
/*     */             break;
/*     */           case 'ù':
/*     */           case 'ú':
/*     */           case 'û':
/*     */           case 'ü':
/* 208 */             this.output[this.outputPos++] = 'u';
/*     */             break;
/*     */           case 'ý':
/*     */           case 'ÿ':
/* 212 */             this.output[this.outputPos++] = 'y';
/*     */             break;
/*     */           case 'ﬀ':
/* 215 */             this.output[this.outputPos++] = 'f';
/* 216 */             this.output[this.outputPos++] = 'f';
/*     */             break;
/*     */           case 'ﬁ':
/* 219 */             this.output[this.outputPos++] = 'f';
/* 220 */             this.output[this.outputPos++] = 'i';
/*     */             break;
/*     */           case 'ﬂ':
/* 223 */             this.output[this.outputPos++] = 'f';
/* 224 */             this.output[this.outputPos++] = 'l';
/*     */             break;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/*     */           case 'ﬅ':
/* 238 */             this.output[this.outputPos++] = 'f';
/* 239 */             this.output[this.outputPos++] = 't';
/*     */             break;
/*     */           case 'ﬆ':
/* 242 */             this.output[this.outputPos++] = 's';
/* 243 */             this.output[this.outputPos++] = 't';
/*     */             break;
/*     */           default:
/* 246 */             this.output[this.outputPos++] = c;
/*     */             break;
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\ISOLatin1AccentFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.KeywordAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class KeywordAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 30 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new KeywordTokenizer(reader); }
/*    */ 
/*    */   
/*    */   public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
/* 34 */     Tokenizer tokenizer = (Tokenizer)getPreviousTokenStream();
/* 35 */     if (tokenizer == null) {
/* 36 */       tokenizer = new KeywordTokenizer(reader);
/* 37 */       setPreviousTokenStream(tokenizer);
/*    */     } else {
/* 39 */       tokenizer.reset(reader);
/* 40 */     }  return tokenizer;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\KeywordAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.KeywordTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class KeywordTokenizer
/*    */   extends Tokenizer
/*    */ {
/*    */   private static final int DEFAULT_BUFFER_SIZE = 256;
/*    */   private boolean done;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/* 33 */   public KeywordTokenizer(Reader input) { this(input, 256); }
/*    */ 
/*    */   
/*    */   public KeywordTokenizer(Reader input, int bufferSize) {
/* 37 */     super(input);
/* 38 */     this.done = false;
/*    */   }
/*    */   
/*    */   public Token next(Token reusableToken) throws IOException {
/* 42 */     assert reusableToken != null;
/* 43 */     if (!this.done) {
/* 44 */       this.done = true;
/* 45 */       int upto = 0;
/* 46 */       reusableToken.clear();
/* 47 */       char[] buffer = reusableToken.termBuffer();
/*    */       while (true) {
/* 49 */         int length = this.input.read(buffer, upto, buffer.length - upto);
/* 50 */         if (length == -1)
/* 51 */           break;  upto += length;
/* 52 */         if (upto == buffer.length)
/* 53 */           buffer = reusableToken.resizeTermBuffer(1 + buffer.length); 
/*    */       } 
/* 55 */       reusableToken.setTermLength(upto);
/* 56 */       return reusableToken;
/*    */     } 
/* 58 */     return null;
/*    */   }
/*    */   
/*    */   public void reset(Reader input) throws IOException {
/* 62 */     super.reset(input);
/* 63 */     this.done = false;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\KeywordTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LengthFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LengthFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   final int min;
/*    */   final int max;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public LengthFilter(TokenStream in, int min, int max) {
/* 39 */     super(in);
/* 40 */     this.min = min;
/* 41 */     this.max = max;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public final Token next(Token reusableToken) throws IOException {
/* 49 */     assert reusableToken != null;
/*    */     
/* 51 */     for (Token nextToken = this.input.next(reusableToken); nextToken != null; nextToken = this.input.next(reusableToken)) {
/*    */       
/* 53 */       int len = nextToken.termLength();
/* 54 */       if (len >= this.min && len <= this.max) {
/* 55 */         return nextToken;
/*    */       }
/*    */     } 
/*    */ 
/*    */     
/* 60 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\LengthFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LetterTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LetterTokenizer
/*    */   extends CharTokenizer
/*    */ {
/* 32 */   public LetterTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 38 */   protected boolean isTokenChar(char c) { return Character.isLetter(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\LetterTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LowerCaseFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LowerCaseFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   static final boolean $assertionsDisabled;
/*    */   
/* 29 */   public LowerCaseFilter(TokenStream in) { super(in); }
/*    */ 
/*    */   
/*    */   public final Token next(Token reusableToken) throws IOException {
/* 33 */     assert reusableToken != null;
/* 34 */     Token nextToken = this.input.next(reusableToken);
/* 35 */     if (nextToken != null) {
/*    */       
/* 37 */       char[] buffer = nextToken.termBuffer();
/* 38 */       int length = nextToken.termLength();
/* 39 */       for (int i = 0; i < length; i++) {
/* 40 */         buffer[i] = Character.toLowerCase(buffer[i]);
/*    */       }
/* 42 */       return nextToken;
/*    */     } 
/* 44 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\LowerCaseFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LowerCaseTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LowerCaseTokenizer
/*    */   extends LetterTokenizer
/*    */ {
/* 35 */   public LowerCaseTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   protected char normalize(char c) { return Character.toLowerCase(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\LowerCaseTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PerFieldAnalyzerWrapper,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PerFieldAnalyzerWrapper
/*    */   extends Analyzer
/*    */ {
/*    */   private Analyzer defaultAnalyzer;
/* 47 */   private Map analyzerMap = new HashMap();
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 57 */   public PerFieldAnalyzerWrapper(Analyzer defaultAnalyzer) { this.defaultAnalyzer = defaultAnalyzer; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 67 */   public void addAnalyzer(String fieldName, Analyzer analyzer) { this.analyzerMap.put(fieldName, analyzer); }
/*    */ 
/*    */   
/*    */   public TokenStream tokenStream(String fieldName, Reader reader) {
/* 71 */     Analyzer analyzer = (Analyzer)this.analyzerMap.get(fieldName);
/* 72 */     if (analyzer == null) {
/* 73 */       analyzer = this.defaultAnalyzer;
/*    */     }
/*    */     
/* 76 */     return analyzer.tokenStream(fieldName, reader);
/*    */   }
/*    */   
/*    */   public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
/* 80 */     Analyzer analyzer = (Analyzer)this.analyzerMap.get(fieldName);
/* 81 */     if (analyzer == null) {
/* 82 */       analyzer = this.defaultAnalyzer;
/*    */     }
/* 84 */     return analyzer.reusableTokenStream(fieldName, reader);
/*    */   }
/*    */ 
/*    */   
/*    */   public int getPositionIncrementGap(String fieldName) {
/* 89 */     Analyzer analyzer = (Analyzer)this.analyzerMap.get(fieldName);
/* 90 */     if (analyzer == null)
/* 91 */       analyzer = this.defaultAnalyzer; 
/* 92 */     return analyzer.getPositionIncrementGap(fieldName);
/*    */   }
/*    */ 
/*    */   
/* 96 */   public String toString() { return ""PerFieldAnalyzerWrapper("" + this.analyzerMap + "", default="" + this.defaultAnalyzer + "")""; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\PerFieldAnalyzerWrapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PorterStemFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class PorterStemFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   private PorterStemmer stemmer;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public PorterStemFilter(TokenStream in) {
/* 44 */     super(in);
/* 45 */     this.stemmer = new PorterStemmer();
/*    */   }
/*    */   
/*    */   public final Token next(Token reusableToken) throws IOException {
/* 49 */     assert reusableToken != null;
/* 50 */     Token nextToken = this.input.next(reusableToken);
/* 51 */     if (nextToken == null) {
/* 52 */       return null;
/*    */     }
/* 54 */     if (this.stemmer.stem(nextToken.termBuffer(), 0, nextToken.termLength()))
/* 55 */       nextToken.setTermBuffer(this.stemmer.getResultBuffer(), 0, this.stemmer.getResultLength()); 
/* 56 */     return nextToken;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\PorterStemFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PorterStemmer,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.FileInputStream;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class PorterStemmer
/*     */ {
/*     */   private char[] b;
/*     */   private int i;
/*     */   private int j;
/*     */   private int k;
/*     */   private int k0;
/*     */   private boolean dirty = false;
/*     */   private static final int INC = 50;
/*     */   private static final int EXTRA = 1;
/*     */   
/*     */   public PorterStemmer() {
/*  68 */     this.b = new char[50];
/*  69 */     this.i = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   public void reset() { this.i = 0; this.dirty = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(char ch) {
/*  84 */     if (this.b.length <= this.i + 1) {
/*  85 */       char[] new_b = new char[this.b.length + 50];
/*  86 */       System.arraycopy(this.b, 0, new_b, 0, this.b.length);
/*  87 */       this.b = new_b;
/*     */     } 
/*  89 */     this.b[this.i++] = ch;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public String toString() { return new String(this.b, 0, this.i); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 102 */   public int getResultLength() { return this.i; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public char[] getResultBuffer() { return this.b; }
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean cons(int i) {
/* 114 */     switch (this.b[i]) { case 'a': case 'e': case 'i': case 'o':
/*     */       case 'u':
/* 116 */         return false;
/*     */       case 'y':
/* 118 */         return (i == this.k0) ? true : (!cons(i - 1)); }
/*     */     
/* 120 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int m() {
/* 136 */     int n = 0;
/* 137 */     int i = this.k0;
/*     */     while (true) {
/* 139 */       if (i > this.j)
/* 140 */         return n; 
/* 141 */       if (!cons(i))
/*     */         break; 
/* 143 */       i++;
/*     */     } 
/* 145 */     i++;
/*     */     
/*     */     while (true) {
/* 148 */       if (i > this.j)
/* 149 */         return n; 
/* 150 */       if (cons(i)) {
/*     */ 
/*     */ 
/*     */         
/* 154 */         i++;
/* 155 */         n++;
/*     */         while (true) {
/* 157 */           if (i > this.j)
/* 158 */             return n; 
/* 159 */           if (!cons(i))
/*     */             break; 
/* 161 */           i++;
/*     */         } 
/* 163 */         i++;
/*     */         continue;
/*     */       } 
/*     */       i++;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final boolean vowelinstem() {
/* 171 */     for (int i = this.k0; i <= this.j; i++) {
/* 172 */       if (!cons(i))
/* 173 */         return true; 
/* 174 */     }  return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean doublec(int j) {
/* 180 */     if (j < this.k0 + 1)
/* 181 */       return false; 
/* 182 */     if (this.b[j] != this.b[j - 1])
/* 183 */       return false; 
/* 184 */     return cons(j);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean cvc(int i) {
/* 197 */     if (i < this.k0 + 2 || !cons(i) || cons(i - 1) || !cons(i - 2)) {
/* 198 */       return false;
/*     */     }
/* 200 */     int ch = this.b[i];
/* 201 */     if (ch == 119 || ch == 120 || ch == 121) return false;
/*     */     
/* 203 */     return true;
/*     */   }
/*     */   
/*     */   private final boolean ends(String s) {
/* 207 */     int l = s.length();
/* 208 */     int o = this.k - l + 1;
/* 209 */     if (o < this.k0)
/* 210 */       return false; 
/* 211 */     for (int i = 0; i < l; i++) {
/* 212 */       if (this.b[o + i] != s.charAt(i))
/* 213 */         return false; 
/* 214 */     }  this.j = this.k - l;
/* 215 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setto(String s) {
/* 222 */     int l = s.length();
/* 223 */     int o = this.j + 1;
/* 224 */     for (int i = 0; i < l; i++)
/* 225 */       this.b[o + i] = s.charAt(i); 
/* 226 */     this.k = this.j + l;
/* 227 */     this.dirty = true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 232 */   void r(String s) { if (m() > 0) setto(s);
/*     */      }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void step1() {
/* 257 */     if (this.b[this.k] == 's')
/* 258 */       if (ends(""sses"")) { this.k -= 2; }
/* 259 */       else if (ends(""ies"")) { setto(""i""); }
/* 260 */       else if (this.b[this.k - 1] != 's') { this.k--; }
/*     */        
/* 262 */     if (ends(""eed"")) {
/* 263 */       if (m() > 0) {
/* 264 */         this.k--;
/*     */       }
/* 266 */     } else if ((ends(""ed"") || ends(""ing"")) && vowelinstem()) {
/* 267 */       this.k = this.j;
/* 268 */       if (ends(""at"")) { setto(""ate""); }
/* 269 */       else if (ends(""bl"")) { setto(""ble""); }
/* 270 */       else if (ends(""iz"")) { setto(""ize""); }
/* 271 */       else if (doublec(this.k))
/* 272 */       { int ch = this.b[this.k--];
/* 273 */         if (ch == 108 || ch == 115 || ch == 122) {
/* 274 */           this.k++;
/*     */         } }
/* 276 */       else if (m() == 1 && cvc(this.k))
/* 277 */       { setto(""e""); }
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step2() {
/* 284 */     if (ends(""y"") && vowelinstem()) {
/* 285 */       this.b[this.k] = 'i';
/* 286 */       this.dirty = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void step3() {
/* 295 */     if (this.k == this.k0)
/* 296 */       return;  switch (this.b[this.k - 1]) {
/*     */       case 'a':
/* 298 */         if (ends(""ational"")) { r(""ate""); break; }
/* 299 */          if (ends(""tional"")) r(""tion""); 
/*     */         break;
/*     */       case 'c':
/* 302 */         if (ends(""enci"")) { r(""ence""); break; }
/* 303 */          if (ends(""anci"")) r(""ance""); 
/*     */         break;
/*     */       case 'e':
/* 306 */         if (ends(""izer"")) r(""ize""); 
/*     */         break;
/*     */       case 'l':
/* 309 */         if (ends(""bli"")) { r(""ble""); break; }
/* 310 */          if (ends(""alli"")) { r(""al""); break; }
/* 311 */          if (ends(""entli"")) { r(""ent""); break; }
/* 312 */          if (ends(""eli"")) { r(""e""); break; }
/* 313 */          if (ends(""ousli"")) r(""ous""); 
/*     */         break;
/*     */       case 'o':
/* 316 */         if (ends(""ization"")) { r(""ize""); break; }
/* 317 */          if (ends(""ation"")) { r(""ate""); break; }
/* 318 */          if (ends(""ator"")) r(""ate""); 
/*     */         break;
/*     */       case 's':
/* 321 */         if (ends(""alism"")) { r(""al""); break; }
/* 322 */          if (ends(""iveness"")) { r(""ive""); break; }
/* 323 */          if (ends(""fulness"")) { r(""ful""); break; }
/* 324 */          if (ends(""ousness"")) r(""ous""); 
/*     */         break;
/*     */       case 't':
/* 327 */         if (ends(""aliti"")) { r(""al""); break; }
/* 328 */          if (ends(""iviti"")) { r(""ive""); break; }
/* 329 */          if (ends(""biliti"")) r(""ble""); 
/*     */         break;
/*     */       case 'g':
/* 332 */         if (ends(""logi"")) r(""log"");
/*     */         
/*     */         break;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void step4() {
/* 339 */     switch (this.b[this.k]) {
/*     */       case 'e':
/* 341 */         if (ends(""icate"")) { r(""ic""); break; }
/* 342 */          if (ends(""ative"")) { r(""""); break; }
/* 343 */          if (ends(""alize"")) r(""al""); 
/*     */         break;
/*     */       case 'i':
/* 346 */         if (ends(""iciti"")) r(""ic""); 
/*     */         break;
/*     */       case 'l':
/* 349 */         if (ends(""ical"")) { r(""ic""); break; }
/* 350 */          if (ends(""ful"")) r(""""); 
/*     */         break;
/*     */       case 's':
/* 353 */         if (ends(""ness"")) r("""");
/*     */         
/*     */         break;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step5() {
/* 361 */     if (this.k == this.k0)
/* 362 */       return;  switch (this.b[this.k - 1]) {
/*     */       case 'a':
/* 364 */         if (ends(""al""))
/*     */           break;  return;
/*     */       case 'c':
/* 367 */         if (ends(""ance"") || 
/* 368 */           ends(""ence""))
/*     */           break;  return;
/*     */       case 'e':
/* 371 */         if (ends(""er""))
/*     */           break;  return;
/* 373 */       case 'i': if (ends(""ic""))
/*     */           break;  return;
/* 375 */       case 'l': if (ends(""able"") || 
/* 376 */           ends(""ible""))
/*     */           break;  return;
/* 378 */       case 'n': if (ends(""ant"") || 
/* 379 */           ends(""ement"") || 
/* 380 */           ends(""ment""))
/*     */           break; 
/* 382 */         if (ends(""ent""))
/*     */           break;  return;
/*     */       case 'o':
/* 385 */         if (ends(""ion"") && this.j >= 0 && (this.b[this.j] == 's' || this.b[this.j] == 't'))
/*     */           break; 
/* 387 */         if (ends(""ou""))
/*     */           break; 
/*     */         return;
/*     */       case 's':
/* 391 */         if (ends(""ism""))
/*     */           break;  return;
/*     */       case 't':
/* 394 */         if (ends(""ate"") || 
/* 395 */           ends(""iti""))
/*     */           break;  return;
/*     */       case 'u':
/* 398 */         if (ends(""ous""))
/*     */           break;  return;
/*     */       case 'v':
/* 401 */         if (ends(""ive""))
/*     */           break;  return;
/*     */       case 'z':
/* 404 */         if (ends(""ize""))
/*     */           break;  return;
/*     */       default:
/*     */         return;
/*     */     } 
/* 409 */     if (m() > 1) {
/* 410 */       this.k = this.j;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step6() {
/* 416 */     this.j = this.k;
/* 417 */     if (this.b[this.k] == 'e') {
/* 418 */       int a = m();
/* 419 */       if (a > 1 || (a == 1 && !cvc(this.k - 1)))
/* 420 */         this.k--; 
/*     */     } 
/* 422 */     if (this.b[this.k] == 'l' && doublec(this.k) && m() > 1) {
/* 423 */       this.k--;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String stem(String s) {
/* 431 */     if (stem(s.toCharArray(), s.length())) {
/* 432 */       return toString();
/*     */     }
/* 434 */     return s;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 442 */   public boolean stem(char[] word) { return stem(word, word.length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean stem(char[] wordBuffer, int offset, int wordLen) {
/* 451 */     reset();
/* 452 */     if (this.b.length < wordLen) {
/* 453 */       char[] new_b = new char[wordLen + 1];
/* 454 */       this.b = new_b;
/*     */     } 
/* 456 */     System.arraycopy(wordBuffer, offset, this.b, 0, wordLen);
/* 457 */     this.i = wordLen;
/* 458 */     return stem(0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 467 */   public boolean stem(char[] word, int wordLen) { return stem(word, 0, wordLen); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 476 */   public boolean stem() { return stem(0); }
/*     */ 
/*     */   
/*     */   public boolean stem(int i0) {
/* 480 */     this.k = this.i - 1;
/* 481 */     this.k0 = i0;
/* 482 */     if (this.k > this.k0 + 1) {
/* 483 */       step1(); step2(); step3(); step4(); step5(); step6();
/*     */     } 
/*     */ 
/*     */     
/* 487 */     if (this.i != this.k + 1)
/* 488 */       this.dirty = true; 
/* 489 */     this.i = this.k + 1;
/* 490 */     return this.dirty;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) {
/* 498 */     PorterStemmer s = new PorterStemmer();
/*     */     
/* 500 */     for (int i = 0; i < args.length; i++) {
/*     */       try {
/* 502 */         InputStream in = new FileInputStream(args[i]);
/* 503 */         byte[] buffer = new byte[1024];
/*     */ 
/*     */         
/* 506 */         int bufferLen = in.read(buffer);
/* 507 */         int offset = 0;
/* 508 */         s.reset();
/*     */         while (true) {
/*     */           int ch;
/* 511 */           if (offset < bufferLen) {
/* 512 */             ch = buffer[offset++];
/*     */           } else {
/* 514 */             bufferLen = in.read(buffer);
/* 515 */             offset = 0;
/* 516 */             if (bufferLen < 0) {
/* 517 */               ch = -1;
/*     */             } else {
/* 519 */               ch = buffer[offset++];
/*     */             } 
/*     */           } 
/* 522 */           if (Character.isLetter((char)ch)) {
/* 523 */             s.add(Character.toLowerCase((char)ch));
/*     */             continue;
/*     */           } 
/* 526 */           s.stem();
/* 527 */           System.out.print(s.toString());
/* 528 */           s.reset();
/* 529 */           if (ch < 0) {
/*     */             break;
/*     */           }
/* 532 */           System.out.print((char)ch);
/*     */         } 
/*     */ 
/*     */ 
/*     */         
/* 537 */         in.close();
/*     */       }
/* 539 */       catch (IOException e) {
/* 540 */         System.out.println(""error reading "" + args[i]);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\PorterStemmer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.SimpleAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class SimpleAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 27 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new LowerCaseTokenizer(reader); }
/*    */ 
/*    */   
/*    */   public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
/* 31 */     Tokenizer tokenizer = (Tokenizer)getPreviousTokenStream();
/* 32 */     if (tokenizer == null) {
/* 33 */       tokenizer = new LowerCaseTokenizer(reader);
/* 34 */       setPreviousTokenStream(tokenizer);
/*    */     } else {
/* 36 */       tokenizer.reset(reader);
/* 37 */     }  return tokenizer;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\SimpleAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.SinkTokenizer,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SinkTokenizer
/*     */   extends Tokenizer
/*     */ {
/*  33 */   protected List lst = new ArrayList();
/*     */   protected Iterator iter;
/*     */   
/*     */   public SinkTokenizer(List input) {
/*  37 */     this.lst = input;
/*  38 */     if (this.lst == null) this.lst = new ArrayList(); 
/*     */   }
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  42 */   public SinkTokenizer() { this.lst = new ArrayList(); }
/*     */ 
/*     */ 
/*     */   
/*  46 */   public SinkTokenizer(int initCap) { this.lst = new ArrayList(initCap); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  61 */   public List getTokens() { return this.lst; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token next(Token reusableToken) throws IOException {
/*  70 */     assert reusableToken != null;
/*  71 */     if (this.iter == null) this.iter = this.lst.iterator();
/*     */     
/*  73 */     if (this.iter.hasNext()) {
/*  74 */       Token nextToken = this.iter.next();
/*  75 */       return (Token)nextToken.clone();
/*     */     } 
/*  77 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Token t) {
/*  89 */     if (t == null)
/*  90 */       return;  this.lst.add((Token)t.clone());
/*     */   }
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/*  95 */     this.input = null;
/*  96 */     this.lst = null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 105 */   public void reset() throws IOException { this.iter = this.lst.iterator(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\SinkTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.StopAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ import java.util.Set;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class StopAnalyzer
/*    */   extends Analyzer
/*    */ {
/*    */   private Set stopWords;
/* 32 */   public static final String[] ENGLISH_STOP_WORDS = new String[] { ""a"", ""an"", ""and"", ""are"", ""as"", ""at"", ""be"", ""but"", ""by"", ""for"", ""if"", ""in"", ""into"", ""is"", ""it"", ""no"", ""not"", ""of"", ""on"", ""or"", ""such"", ""that"", ""the"", ""their"", ""then"", ""there"", ""these"", ""they"", ""this"", ""to"", ""was"", ""will"", ""with"" };
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 42 */   public StopAnalyzer() { this.stopWords = StopFilter.makeStopSet(ENGLISH_STOP_WORDS); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public StopAnalyzer(Set stopWords) { this.stopWords = stopWords; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 53 */   public StopAnalyzer(String[] stopWords) { this.stopWords = StopFilter.makeStopSet(stopWords); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 60 */   public StopAnalyzer(File stopwordsFile) throws IOException { this.stopWords = WordlistLoader.getWordSet(stopwordsFile); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 67 */   public StopAnalyzer(Reader stopwords) throws IOException { this.stopWords = WordlistLoader.getWordSet(stopwords); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 72 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new StopFilter(new LowerCaseTokenizer(reader), this.stopWords); }
/*    */   private class SavedStreams {
/*    */     Tokenizer source;
/*    */     TokenStream result;
/*    */     private final StopAnalyzer this$0;
/*    */     
/*    */     private SavedStreams() {} }
/*    */   
/*    */   public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
/* 81 */     SavedStreams streams = (SavedStreams)getPreviousTokenStream();
/* 82 */     if (streams == null) {
/* 83 */       streams = new SavedStreams();
/* 84 */       streams.source = new LowerCaseTokenizer(reader);
/* 85 */       streams.result = new StopFilter(streams.source, this.stopWords);
/* 86 */       setPreviousTokenStream(streams);
/*    */     } else {
/* 88 */       streams.source.reset(reader);
/* 89 */     }  return streams.result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\StopAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.StopFilter,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Set;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class StopFilter
/*     */   extends TokenFilter
/*     */ {
/*     */   private static boolean ENABLE_POSITION_INCREMENTS_DEFAULT = false;
/*     */   private final CharArraySet stopWords;
/*  33 */   private boolean enablePositionIncrements = ENABLE_POSITION_INCREMENTS_DEFAULT;
/*     */ 
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */ 
/*     */ 
/*     */   
/*  40 */   public StopFilter(TokenStream input, String[] stopWords) { this(input, stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StopFilter(TokenStream in, String[] stopWords, boolean ignoreCase) {
/*  48 */     super(in);
/*  49 */     this.stopWords = (CharArraySet)makeStopSet(stopWords, ignoreCase);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StopFilter(TokenStream input, Set stopWords, boolean ignoreCase) {
/*  70 */     super(input);
/*  71 */     if (stopWords instanceof CharArraySet) {
/*  72 */       this.stopWords = (CharArraySet)stopWords;
/*     */     } else {
/*  74 */       this.stopWords = new CharArraySet(stopWords.size(), ignoreCase);
/*  75 */       this.stopWords.addAll(stopWords);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public StopFilter(TokenStream in, Set stopWords) { this(in, stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   public static final Set makeStopSet(String[] stopWords) { return makeStopSet(stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final Set makeStopSet(String[] stopWords, boolean ignoreCase) {
/* 108 */     CharArraySet stopSet = new CharArraySet(stopWords.length, ignoreCase);
/* 109 */     stopSet.addAll(Arrays.asList((E[])stopWords));
/* 110 */     return stopSet;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Token next(Token reusableToken) throws IOException {
/* 117 */     assert reusableToken != null;
/*     */     
/* 119 */     int skippedPositions = 0;
/* 120 */     for (Token nextToken = this.input.next(reusableToken); nextToken != null; nextToken = this.input.next(reusableToken)) {
/* 121 */       if (!this.stopWords.contains(nextToken.termBuffer(), 0, nextToken.termLength())) {
/* 122 */         if (this.enablePositionIncrements) {
/* 123 */           nextToken.setPositionIncrement(nextToken.getPositionIncrement() + skippedPositions);
/*     */         }
/* 125 */         return nextToken;
/*     */       } 
/* 127 */       skippedPositions += nextToken.getPositionIncrement();
/*     */     } 
/*     */     
/* 130 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 137 */   public static boolean getEnablePositionIncrementsDefault() { return ENABLE_POSITION_INCREMENTS_DEFAULT; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 152 */   public static void setEnablePositionIncrementsDefault(boolean defaultValue) { ENABLE_POSITION_INCREMENTS_DEFAULT = defaultValue; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 159 */   public boolean getEnablePositionIncrements() { return this.enablePositionIncrements; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 171 */   public void setEnablePositionIncrements(boolean enable) { this.enablePositionIncrements = enable; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\StopFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.TeeTokenFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TeeTokenFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   SinkTokenizer sink;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public TeeTokenFilter(TokenStream input, SinkTokenizer sink) {
/* 61 */     super(input);
/* 62 */     this.sink = sink;
/*    */   }
/*    */   
/*    */   public Token next(Token reusableToken) throws IOException {
/* 66 */     assert reusableToken != null;
/* 67 */     Token nextToken = this.input.next(reusableToken);
/* 68 */     this.sink.add(nextToken);
/* 69 */     return nextToken;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\TeeTokenFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Token,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import org.apache.lucene.index.Payload;
/*     */ import org.apache.lucene.util.ArrayUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Token
/*     */   implements Cloneable
/*     */ {
/*     */   public static final String DEFAULT_TYPE = ""word"";
/* 122 */   private static int MIN_BUFFER_SIZE = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private String termText;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   char[] termBuffer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   int termLength;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   int startOffset;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   int endOffset;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 164 */   String type = ""word"";
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private int flags;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   Payload payload;
/*     */ 
/*     */ 
/*     */   
/* 178 */   int positionIncrement = 1;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(int start, int end) {
/* 189 */     this.startOffset = start;
/* 190 */     this.endOffset = end;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(int start, int end, String typ) {
/* 199 */     this.startOffset = start;
/* 200 */     this.endOffset = end;
/* 201 */     this.type = typ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(int start, int end, int flags) {
/* 212 */     this.startOffset = start;
/* 213 */     this.endOffset = end;
/* 214 */     this.flags = flags;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(String text, int start, int end) {
/* 228 */     this.termText = text;
/* 229 */     this.startOffset = start;
/* 230 */     this.endOffset = end;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(String text, int start, int end, String typ) {
/* 244 */     this.termText = text;
/* 245 */     this.startOffset = start;
/* 246 */     this.endOffset = end;
/* 247 */     this.type = typ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(String text, int start, int end, int flags) {
/* 262 */     this.termText = text;
/* 263 */     this.startOffset = start;
/* 264 */     this.endOffset = end;
/* 265 */     this.flags = flags;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(char[] startTermBuffer, int termBufferOffset, int termBufferLength, int start, int end) {
/* 279 */     setTermBuffer(startTermBuffer, termBufferOffset, termBufferLength);
/* 280 */     this.startOffset = start;
/* 281 */     this.endOffset = end;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setPositionIncrement(int positionIncrement) {
/* 311 */     if (positionIncrement < 0) {
/* 312 */       throw new IllegalArgumentException(""Increment must be zero or greater: "" + positionIncrement);
/*     */     }
/* 314 */     this.positionIncrement = positionIncrement;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 321 */   public int getPositionIncrement() { return this.positionIncrement; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setTermText(String text) {
/* 332 */     this.termText = text;
/* 333 */     this.termBuffer = null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String termText() {
/* 345 */     if (this.termText == null && this.termBuffer != null)
/* 346 */       this.termText = new String(this.termBuffer, 0, this.termLength); 
/* 347 */     return this.termText;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String term() {
/* 360 */     if (this.termText != null)
/* 361 */       return this.termText; 
/* 362 */     initTermBuffer();
/* 363 */     return new String(this.termBuffer, 0, this.termLength);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void setTermBuffer(char[] buffer, int offset, int length) {
/* 373 */     this.termText = null;
/* 374 */     char[] newCharBuffer = growTermBuffer(length);
/* 375 */     if (newCharBuffer != null) {
/* 376 */       this.termBuffer = newCharBuffer;
/*     */     }
/* 378 */     System.arraycopy(buffer, offset, this.termBuffer, 0, length);
/* 379 */     this.termLength = length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void setTermBuffer(String buffer) {
/* 386 */     this.termText = null;
/* 387 */     int length = buffer.length();
/* 388 */     char[] newCharBuffer = growTermBuffer(length);
/* 389 */     if (newCharBuffer != null) {
/* 390 */       this.termBuffer = newCharBuffer;
/*     */     }
/* 392 */     buffer.getChars(0, length, this.termBuffer, 0);
/* 393 */     this.termLength = length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void setTermBuffer(String buffer, int offset, int length) {
/* 403 */     assert offset <= buffer.length();
/* 404 */     assert offset + length <= buffer.length();
/* 405 */     this.termText = null;
/* 406 */     char[] newCharBuffer = growTermBuffer(length);
/* 407 */     if (newCharBuffer != null) {
/* 408 */       this.termBuffer = newCharBuffer;
/*     */     }
/* 410 */     buffer.getChars(offset, offset + length, this.termBuffer, 0);
/* 411 */     this.termLength = length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final char[] termBuffer() {
/* 422 */     initTermBuffer();
/* 423 */     return this.termBuffer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public char[] resizeTermBuffer(int newSize) {
/* 437 */     char[] newCharBuffer = growTermBuffer(newSize);
/* 438 */     if (this.termBuffer == null) {
/*     */ 
/*     */       
/* 441 */       assert newCharBuffer != null;
/* 442 */       if (this.termText != null) {
/* 443 */         this.termText.getChars(0, this.termText.length(), newCharBuffer, 0);
/*     */       }
/* 445 */       this.termBuffer = newCharBuffer;
/* 446 */     } else if (newCharBuffer != null) {
/*     */ 
/*     */       
/* 449 */       System.arraycopy(this.termBuffer, 0, newCharBuffer, 0, this.termBuffer.length);
/* 450 */       this.termBuffer = newCharBuffer;
/*     */     } 
/* 452 */     this.termText = null;
/* 453 */     return this.termBuffer;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private char[] growTermBuffer(int newSize) {
/* 461 */     if (this.termBuffer != null) {
/* 462 */       if (this.termBuffer.length >= newSize)
/*     */       {
/* 464 */         return null;
/*     */       }
/*     */ 
/*     */       
/* 468 */       return new char[ArrayUtil.getNextSize(newSize)];
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 473 */     if (newSize < MIN_BUFFER_SIZE) {
/* 474 */       newSize = MIN_BUFFER_SIZE;
/*     */     }
/*     */ 
/*     */     
/* 478 */     if (this.termText != null) {
/* 479 */       int ttLength = this.termText.length();
/* 480 */       if (newSize < ttLength) {
/* 481 */         newSize = ttLength;
/*     */       }
/*     */     } 
/*     */     
/* 485 */     return new char[newSize];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void initTermBuffer() {
/* 493 */     if (this.termBuffer == null) {
/* 494 */       if (this.termText == null) {
/* 495 */         this.termBuffer = new char[MIN_BUFFER_SIZE];
/* 496 */         this.termLength = 0;
/*     */       } else {
/* 498 */         int length = this.termText.length();
/* 499 */         if (length < MIN_BUFFER_SIZE) length = MIN_BUFFER_SIZE; 
/* 500 */         this.termBuffer = new char[length];
/* 501 */         this.termLength = this.termText.length();
/* 502 */         this.termText.getChars(0, this.termText.length(), this.termBuffer, 0);
/* 503 */         this.termText = null;
/*     */       } 
/* 505 */     } else if (this.termText != null) {
/* 506 */       this.termText = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public final int termLength() {
/* 512 */     initTermBuffer();
/* 513 */     return this.termLength;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void setTermLength(int length) {
/* 524 */     initTermBuffer();
/* 525 */     if (length > this.termBuffer.length)
/* 526 */       throw new IllegalArgumentException(""length "" + length + "" exceeds the size of the termBuffer ("" + this.termBuffer.length + "")""); 
/* 527 */     this.termLength = length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 537 */   public final int startOffset() { return this.startOffset; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 543 */   public void setStartOffset(int offset) { this.startOffset = offset; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 550 */   public final int endOffset() { return this.endOffset; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 556 */   public void setEndOffset(int offset) { this.endOffset = offset; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 561 */   public final String type() { return this.type; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 567 */   public final void setType(String type) { this.type = type; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 581 */   public int getFlags() { return this.flags; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 588 */   public void setFlags(int flags) { this.flags = flags; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 595 */   public Payload getPayload() { return this.payload; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 602 */   public void setPayload(Payload payload) { this.payload = payload; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 606 */     StringBuffer sb = new StringBuffer();
/* 607 */     sb.append('(');
/* 608 */     initTermBuffer();
/* 609 */     if (this.termBuffer == null) {
/* 610 */       sb.append(""null"");
/*     */     } else {
/* 612 */       sb.append(this.termBuffer, 0, this.termLength);
/* 613 */     }  sb.append(',').append(this.startOffset).append(',').append(this.endOffset);
/* 614 */     if (!this.type.equals(""word""))
/* 615 */       sb.append("",type="").append(this.type); 
/* 616 */     if (this.positionIncrement != 1)
/* 617 */       sb.append("",posIncr="").append(this.positionIncrement); 
/* 618 */     sb.append(')');
/* 619 */     return sb.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void clear() {
/* 626 */     this.payload = null;
/*     */     
/* 628 */     this.termLength = 0;
/* 629 */     this.termText = null;
/* 630 */     this.positionIncrement = 1;
/* 631 */     this.flags = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/*     */     try {
/* 638 */       Token t = (Token)super.clone();
/*     */       
/* 640 */       if (this.termBuffer != null) {
/* 641 */         t.termBuffer = (char[])this.termBuffer.clone();
/*     */       }
/* 643 */       if (this.payload != null) {
/* 644 */         t.setPayload((Payload)this.payload.clone());
/*     */       }
/* 646 */       return t;
/* 647 */     } catch (CloneNotSupportedException e) {
/* 648 */       throw new RuntimeException(e);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token clone(char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset) {
/* 658 */     Token t = new Token(newTermBuffer, newTermOffset, newTermLength, newStartOffset, newEndOffset);
/* 659 */     t.positionIncrement = this.positionIncrement;
/* 660 */     t.flags = this.flags;
/* 661 */     t.type = this.type;
/* 662 */     if (this.payload != null)
/* 663 */       t.payload = (Payload)this.payload.clone(); 
/* 664 */     return t;
/*     */   }
/*     */   
/*     */   public boolean equals(Object obj) {
/* 668 */     if (obj == this) {
/* 669 */       return true;
/*     */     }
/* 671 */     if (obj instanceof Token) {
/* 672 */       Token other = (Token)obj;
/*     */       
/* 674 */       initTermBuffer();
/* 675 */       other.initTermBuffer();
/*     */       
/* 677 */       if (this.termLength == other.termLength && this.startOffset == other.startOffset && this.endOffset == other.endOffset && this.flags == other.flags && this.positionIncrement == other.positionIncrement && subEqual(this.type, other.type) && subEqual(this.payload, other.payload)) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 684 */         for (int i = 0; i < this.termLength; i++) {
/* 685 */           if (this.termBuffer[i] != other.termBuffer[i])
/* 686 */             return false; 
/* 687 */         }  return true;
/*     */       } 
/* 689 */       return false;
/*     */     } 
/* 691 */     return false;
/*     */   }
/*     */   
/*     */   private boolean subEqual(Object o1, Object o2) {
/* 695 */     if (o1 == null) {
/* 696 */       return (o2 == null);
/*     */     }
/* 698 */     return o1.equals(o2);
/*     */   }
/*     */   
/*     */   public int hashCode() {
/* 702 */     initTermBuffer();
/* 703 */     int code = this.termLength;
/* 704 */     code = code * 31 + this.startOffset;
/* 705 */     code = code * 31 + this.endOffset;
/* 706 */     code = code * 31 + this.flags;
/* 707 */     code = code * 31 + this.positionIncrement;
/* 708 */     code = code * 31 + this.type.hashCode();
/* 709 */     code = (this.payload == null) ? code : (code * 31 + this.payload.hashCode());
/* 710 */     code = code * 31 + ArrayUtil.hashCode(this.termBuffer, 0, this.termLength);
/* 711 */     return code;
/*     */   }
/*     */ 
/*     */   
/*     */   private void clearNoTermBuffer() {
/* 716 */     this.payload = null;
/* 717 */     this.positionIncrement = 1;
/* 718 */     this.flags = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token reinit(char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset, String newType) {
/* 728 */     clearNoTermBuffer();
/* 729 */     this.payload = null;
/* 730 */     this.positionIncrement = 1;
/* 731 */     setTermBuffer(newTermBuffer, newTermOffset, newTermLength);
/* 732 */     this.startOffset = newStartOffset;
/* 733 */     this.endOffset = newEndOffset;
/* 734 */     this.type = newType;
/* 735 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token reinit(char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset) {
/* 745 */     clearNoTermBuffer();
/* 746 */     setTermBuffer(newTermBuffer, newTermOffset, newTermLength);
/* 747 */     this.startOffset = newStartOffset;
/* 748 */     this.endOffset = newEndOffset;
/* 749 */     this.type = ""word"";
/* 750 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token reinit(String newTerm, int newStartOffset, int newEndOffset, String newType) {
/* 760 */     clearNoTermBuffer();
/* 761 */     setTermBuffer(newTerm);
/* 762 */     this.startOffset = newStartOffset;
/* 763 */     this.endOffset = newEndOffset;
/* 764 */     this.type = newType;
/* 765 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token reinit(String newTerm, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset, String newType) {
/* 775 */     clearNoTermBuffer();
/* 776 */     setTermBuffer(newTerm, newTermOffset, newTermLength);
/* 777 */     this.startOffset = newStartOffset;
/* 778 */     this.endOffset = newEndOffset;
/* 779 */     this.type = newType;
/* 780 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token reinit(String newTerm, int newStartOffset, int newEndOffset) {
/* 790 */     clearNoTermBuffer();
/* 791 */     setTermBuffer(newTerm);
/* 792 */     this.startOffset = newStartOffset;
/* 793 */     this.endOffset = newEndOffset;
/* 794 */     this.type = ""word"";
/* 795 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token reinit(String newTerm, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset) {
/* 805 */     clearNoTermBuffer();
/* 806 */     setTermBuffer(newTerm, newTermOffset, newTermLength);
/* 807 */     this.startOffset = newStartOffset;
/* 808 */     this.endOffset = newEndOffset;
/* 809 */     this.type = ""word"";
/* 810 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void reinit(Token prototype) {
/* 818 */     prototype.initTermBuffer();
/* 819 */     setTermBuffer(prototype.termBuffer, 0, prototype.termLength);
/* 820 */     this.positionIncrement = prototype.positionIncrement;
/* 821 */     this.flags = prototype.flags;
/* 822 */     this.startOffset = prototype.startOffset;
/* 823 */     this.endOffset = prototype.endOffset;
/* 824 */     this.type = prototype.type;
/* 825 */     this.payload = prototype.payload;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void reinit(Token prototype, String newTerm) {
/* 834 */     setTermBuffer(newTerm);
/* 835 */     this.positionIncrement = prototype.positionIncrement;
/* 836 */     this.flags = prototype.flags;
/* 837 */     this.startOffset = prototype.startOffset;
/* 838 */     this.endOffset = prototype.endOffset;
/* 839 */     this.type = prototype.type;
/* 840 */     this.payload = prototype.payload;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void reinit(Token prototype, char[] newTermBuffer, int offset, int length) {
/* 851 */     setTermBuffer(newTermBuffer, offset, length);
/* 852 */     this.positionIncrement = prototype.positionIncrement;
/* 853 */     this.flags = prototype.flags;
/* 854 */     this.startOffset = prototype.startOffset;
/* 855 */     this.endOffset = prototype.endOffset;
/* 856 */     this.type = prototype.type;
/* 857 */     this.payload = prototype.payload;
/*     */   }
/*     */   
/*     */   public Token() {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.TokenFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TokenFilter
/*    */   extends TokenStream
/*    */ {
/*    */   protected TokenStream input;
/*    */   
/* 35 */   protected TokenFilter(TokenStream input) { this.input = input; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 40 */   public void close() throws IOException { this.input.close(); }
/*    */ 
/*    */ 
/*    */   
/*    */   public void reset() throws IOException {
/* 45 */     super.reset();
/* 46 */     this.input.reset();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\TokenFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Tokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Tokenizer
/*    */   extends TokenStream
/*    */ {
/*    */   protected Reader input;
/*    */   
/*    */   protected Tokenizer() {}
/*    */   
/* 44 */   protected Tokenizer(Reader input) { this.input = input; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 49 */   public void close() throws IOException { this.input.close(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 56 */   public void reset(Reader input) throws IOException { this.input = input; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\Tokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.TokenStream,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.Payload;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TokenStream
/*    */ {
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public Token next() throws IOException {
/* 46 */     Token reusableToken = new Token();
/* 47 */     Token nextToken = next(reusableToken);
/*    */     
/* 49 */     if (nextToken != null) {
/* 50 */       Payload p = nextToken.getPayload();
/* 51 */       if (p != null) {
/* 52 */         nextToken.setPayload((Payload)p.clone());
/*    */       }
/*    */     } 
/*    */     
/* 56 */     return nextToken;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Token next(Token reusableToken) throws IOException {
/* 90 */     assert reusableToken != null;
/* 91 */     return next();
/*    */   }
/*    */   
/*    */   public void reset() throws IOException {}
/*    */   
/*    */   public void close() throws IOException {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\TokenStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WhitespaceAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class WhitespaceAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 27 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new WhitespaceTokenizer(reader); }
/*    */ 
/*    */   
/*    */   public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
/* 31 */     Tokenizer tokenizer = (Tokenizer)getPreviousTokenStream();
/* 32 */     if (tokenizer == null) {
/* 33 */       tokenizer = new WhitespaceTokenizer(reader);
/* 34 */       setPreviousTokenStream(tokenizer);
/*    */     } else {
/* 36 */       tokenizer.reset(reader);
/* 37 */     }  return tokenizer;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\WhitespaceAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WhitespaceTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class WhitespaceTokenizer
/*    */   extends CharTokenizer
/*    */ {
/* 28 */   public WhitespaceTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 34 */   protected boolean isTokenChar(char c) { return !Character.isWhitespace(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\WhitespaceTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WordlistLoader,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.BufferedReader;
/*     */ import java.io.File;
/*     */ import java.io.FileReader;
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class WordlistLoader
/*     */ {
/*     */   public static HashSet getWordSet(File wordfile) throws IOException {
/*  46 */     HashSet result = new HashSet();
/*  47 */     FileReader reader = null;
/*     */     try {
/*  49 */       reader = new FileReader(wordfile);
/*  50 */       result = getWordSet(reader);
/*     */     } finally {
/*     */       
/*  53 */       if (reader != null)
/*  54 */         reader.close(); 
/*     */     } 
/*  56 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static HashSet getWordSet(Reader reader) throws IOException {
/*  69 */     HashSet result = new HashSet();
/*  70 */     BufferedReader br = null;
/*     */     try {
/*  72 */       if (reader instanceof BufferedReader) {
/*  73 */         br = (BufferedReader)reader;
/*     */       } else {
/*  75 */         br = new BufferedReader(reader);
/*     */       } 
/*  77 */       String word = null;
/*  78 */       while ((word = br.readLine()) != null) {
/*  79 */         result.add(word.trim());
/*     */       }
/*     */     } finally {
/*     */       
/*  83 */       if (br != null)
/*  84 */         br.close(); 
/*     */     } 
/*  86 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static HashMap getStemDict(File wordstemfile) throws IOException {
/*  98 */     if (wordstemfile == null)
/*  99 */       throw new NullPointerException(""wordstemfile may not be null""); 
/* 100 */     HashMap result = new HashMap();
/* 101 */     BufferedReader br = null;
/* 102 */     FileReader fr = null;
/*     */     try {
/* 104 */       fr = new FileReader(wordstemfile);
/* 105 */       br = new BufferedReader(fr);
/*     */       String line;
/* 107 */       while ((line = br.readLine()) != null) {
/* 108 */         String[] wordstem = line.split(""\t"", 2);
/* 109 */         result.put(wordstem[0], wordstem[1]);
/*     */       } 
/*     */     } finally {
/* 112 */       if (fr != null)
/* 113 */         fr.close(); 
/* 114 */       if (br != null)
/* 115 */         br.close(); 
/*     */     } 
/* 117 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\WordlistLoader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardAnalyzer,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.analysis.LowerCaseFilter;
/*     */ import org.apache.lucene.analysis.StopAnalyzer;
/*     */ import org.apache.lucene.analysis.StopFilter;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.analysis.WordlistLoader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class StandardAnalyzer
/*     */   extends Analyzer
/*     */ {
/*     */   private Set stopSet;
/*  44 */   private boolean replaceInvalidAcronym = defaultReplaceInvalidAcronym; private static boolean defaultReplaceInvalidAcronym;
/*     */   public static final String[] STOP_WORDS;
/*     */   public static final int DEFAULT_MAX_TOKEN_LENGTH = 255;
/*     */   private int maxTokenLength;
/*     */   
/*     */   static  {
/*  50 */     String v = System.getProperty(""org.apache.lucene.analysis.standard.StandardAnalyzer.replaceInvalidAcronym"");
/*  51 */     if (v == null || v.equals(""true"")) {
/*  52 */       defaultReplaceInvalidAcronym = true;
/*     */     } else {
/*  54 */       defaultReplaceInvalidAcronym = false;
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  89 */     STOP_WORDS = StopAnalyzer.ENGLISH_STOP_WORDS;
/*     */   }
/*     */   public static boolean getDefaultReplaceInvalidAcronym() { return defaultReplaceInvalidAcronym; }
/*     */   public static void setDefaultReplaceInvalidAcronym(boolean replaceInvalidAcronym) { defaultReplaceInvalidAcronym = replaceInvalidAcronym; }
/*  93 */   public StandardAnalyzer() { this(STOP_WORDS); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StandardAnalyzer(boolean replaceInvalidAcronym) {
/* 129 */     this(STOP_WORDS);
/* 130 */     this.replaceInvalidAcronym = replaceInvalidAcronym;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StandardAnalyzer(Reader stopwords, boolean replaceInvalidAcronym) throws IOException {
/* 142 */     this(stopwords);
/* 143 */     this.replaceInvalidAcronym = replaceInvalidAcronym;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StandardAnalyzer(File stopwords, boolean replaceInvalidAcronym) throws IOException {
/* 155 */     this(stopwords);
/* 156 */     this.replaceInvalidAcronym = replaceInvalidAcronym;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StandardAnalyzer(String[] stopwords, boolean replaceInvalidAcronym) throws IOException {
/* 169 */     this(stopwords);
/* 170 */     this.replaceInvalidAcronym = replaceInvalidAcronym;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StandardAnalyzer(Set stopwords, boolean replaceInvalidAcronym) throws IOException {
/* 182 */     this(stopwords);
/* 183 */     this.replaceInvalidAcronym = replaceInvalidAcronym;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenStream tokenStream(String fieldName, Reader reader) {
/* 189 */     StandardTokenizer tokenStream = new StandardTokenizer(reader, this.replaceInvalidAcronym);
/* 190 */     tokenStream.setMaxTokenLength(this.maxTokenLength);
/* 191 */     StandardFilter standardFilter = new StandardFilter((TokenStream)tokenStream);
/* 192 */     LowerCaseFilter lowerCaseFilter = new LowerCaseFilter((TokenStream)standardFilter);
/* 193 */     return (TokenStream)new StopFilter((TokenStream)lowerCaseFilter, this.stopSet);
/*     */   }
/*     */   
/*     */   private static final class SavedStreams
/*     */   {
/*     */     StandardTokenizer tokenStream;
/*     */     TokenStream filteredTokenStream;
/*     */     
/*     */     private SavedStreams() {}
/*     */   }
/*     */   
/*     */   public StandardAnalyzer(Set stopWords) {
/* 205 */     this.maxTokenLength = 255; this.stopSet = stopWords; } public StandardAnalyzer(String[] stopWords) { this.maxTokenLength = 255; this.stopSet = StopFilter.makeStopSet(stopWords); } public StandardAnalyzer(File stopwords) throws IOException { this.maxTokenLength = 255; this.stopSet = WordlistLoader.getWordSet(stopwords); } public StandardAnalyzer(Reader stopwords) throws IOException { this.maxTokenLength = 255;
/*     */     this.stopSet = WordlistLoader.getWordSet(stopwords); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 214 */   public void setMaxTokenLength(int length) { this.maxTokenLength = length; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 221 */   public int getMaxTokenLength() { return this.maxTokenLength; }
/*     */ 
/*     */   
/*     */   public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
/* 225 */     SavedStreams streams = (SavedStreams)getPreviousTokenStream();
/* 226 */     if (streams == null) {
/* 227 */       streams = new SavedStreams();
/* 228 */       setPreviousTokenStream(streams);
/* 229 */       streams.tokenStream = new StandardTokenizer(reader);
/* 230 */       streams.filteredTokenStream = (TokenStream)new StandardFilter((TokenStream)streams.tokenStream);
/* 231 */       streams.filteredTokenStream = (TokenStream)new LowerCaseFilter(streams.filteredTokenStream);
/* 232 */       streams.filteredTokenStream = (TokenStream)new StopFilter(streams.filteredTokenStream, this.stopSet);
/*     */     } else {
/* 234 */       streams.tokenStream.reset(reader);
/*     */     } 
/* 236 */     streams.tokenStream.setMaxTokenLength(this.maxTokenLength);
/*     */     
/* 238 */     streams.tokenStream.setReplaceInvalidAcronym(this.replaceInvalidAcronym);
/*     */     
/* 240 */     return streams.filteredTokenStream;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 251 */   public boolean isReplaceInvalidAcronym() { return this.replaceInvalidAcronym; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 262 */   public void setReplaceInvalidAcronym(boolean replaceInvalidAcronym) { this.replaceInvalidAcronym = replaceInvalidAcronym; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\standard\StandardAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardFilter,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.analysis.Token;
/*    */ import org.apache.lucene.analysis.TokenFilter;
/*    */ import org.apache.lucene.analysis.TokenStream;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class StandardFilter
/*    */   extends TokenFilter
/*    */ {
/* 31 */   public StandardFilter(TokenStream in) { super(in); }
/*    */ 
/*    */   
/* 34 */   private static final String APOSTROPHE_TYPE = StandardTokenizerImpl.TOKEN_TYPES[1];
/* 35 */   private static final String ACRONYM_TYPE = StandardTokenizerImpl.TOKEN_TYPES[2];
/*    */ 
/*    */   
/*    */   static final boolean $assertionsDisabled;
/*    */ 
/*    */   
/*    */   public final Token next(Token reusableToken) throws IOException {
/* 42 */     assert reusableToken != null;
/* 43 */     Token nextToken = this.input.next(reusableToken);
/*    */     
/* 45 */     if (nextToken == null) {
/* 46 */       return null;
/*    */     }
/* 48 */     char[] buffer = nextToken.termBuffer();
/* 49 */     int bufferLength = nextToken.termLength();
/* 50 */     String type = nextToken.type();
/*    */     
/* 52 */     if (type == APOSTROPHE_TYPE && bufferLength >= 2 && buffer[bufferLength - 2] == '\'' && (buffer[bufferLength - 1] == 's' || buffer[bufferLength - 1] == 'S')) {
/*    */ 
/*    */ 
/*    */ 
/*    */       
/* 57 */       nextToken.setTermLength(bufferLength - 2);
/* 58 */     } else if (type == ACRONYM_TYPE) {
/* 59 */       int upto = 0;
/* 60 */       for (int i = 0; i < bufferLength; i++) {
/* 61 */         char c = buffer[i];
/* 62 */         if (c != '.')
/* 63 */           buffer[upto++] = c; 
/*    */       } 
/* 65 */       nextToken.setTermLength(upto);
/*    */     } 
/*    */     
/* 68 */     return nextToken;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\standard\StandardFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizer,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.Tokenizer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class StandardTokenizer
/*     */   extends Tokenizer
/*     */ {
/*     */   private final StandardTokenizerImpl scanner;
/*     */   public static final int ALPHANUM = 0;
/*     */   public static final int APOSTROPHE = 1;
/*     */   public static final int ACRONYM = 2;
/*     */   public static final int COMPANY = 3;
/*     */   public static final int EMAIL = 4;
/*     */   public static final int HOST = 5;
/*     */   public static final int NUM = 6;
/*     */   public static final int CJ = 7;
/*     */   public static final int ACRONYM_DEP = 8;
/*  64 */   public static final String[] TOKEN_TYPES = new String[] { ""<ALPHANUM>"", ""<APOSTROPHE>"", ""<ACRONYM>"", ""<COMPANY>"", ""<EMAIL>"", ""<HOST>"", ""<NUM>"", ""<CJ>"", ""<ACRONYM_DEP>"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   public static final String[] tokenImage = TOKEN_TYPES;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean replaceInvalidAcronym = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  90 */   void setInput(Reader reader) { this.input = reader; }
/*     */ 
/*     */   
/*  93 */   private int maxTokenLength = 255;
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */ 
/*     */   
/*  98 */   public void setMaxTokenLength(int length) { this.maxTokenLength = length; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   public int getMaxTokenLength() { return this.maxTokenLength; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StandardTokenizer(Reader input) {
/* 111 */     this.input = input;
/* 112 */     this.scanner = new StandardTokenizerImpl(input);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StandardTokenizer(Reader input, boolean replaceInvalidAcronym) {
/* 125 */     this.replaceInvalidAcronym = replaceInvalidAcronym;
/* 126 */     this.input = input;
/* 127 */     this.scanner = new StandardTokenizerImpl(input);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token next(Token reusableToken) throws IOException {
/* 136 */     assert reusableToken != null;
/* 137 */     int posIncr = 1;
/*     */     
/*     */     while (true) {
/* 140 */       int tokenType = this.scanner.getNextToken();
/*     */       
/* 142 */       if (tokenType == -1) {
/* 143 */         return null;
/*     */       }
/*     */       
/* 146 */       if (this.scanner.yylength() <= this.maxTokenLength) {
/* 147 */         reusableToken.clear();
/* 148 */         reusableToken.setPositionIncrement(posIncr);
/* 149 */         this.scanner.getText(reusableToken);
/* 150 */         int start = this.scanner.yychar();
/* 151 */         reusableToken.setStartOffset(start);
/* 152 */         reusableToken.setEndOffset(start + reusableToken.termLength());
/*     */ 
/*     */ 
/*     */         
/* 156 */         if (tokenType == 8) {
/* 157 */           if (this.replaceInvalidAcronym) {
/* 158 */             reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[5]);
/* 159 */             reusableToken.setTermLength(reusableToken.termLength() - 1);
/*     */           } else {
/* 161 */             reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[2]);
/*     */           } 
/*     */         } else {
/* 164 */           reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);
/*     */         } 
/* 166 */         return reusableToken;
/*     */       } 
/*     */ 
/*     */       
/* 170 */       posIncr++;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void reset() throws IOException {
/* 180 */     super.reset();
/* 181 */     this.scanner.yyreset(this.input);
/*     */   }
/*     */   
/*     */   public void reset(Reader reader) throws IOException {
/* 185 */     this.input = reader;
/* 186 */     reset();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 197 */   public boolean isReplaceInvalidAcronym() { return this.replaceInvalidAcronym; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 208 */   public void setReplaceInvalidAcronym(boolean replaceInvalidAcronym) { this.replaceInvalidAcronym = replaceInvalidAcronym; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizerImpl,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.io.InputStreamReader;
/*     */ import java.io.Reader;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class StandardTokenizerImpl
/*     */ {
/*     */   public static final int YYEOF = -1;
/*     */   private static final int ZZ_BUFFERSIZE = 16384;
/*     */   public static final int YYINITIAL = 0;
/*     */   private static final String ZZ_CMAP_PACKED = ""\t\000\001\000\001\r\001\000\001\000\001\f\022\000\001\000\005\000\001\005\001\003\004\000\001\t\001\007\001\004\001\t\n\002\006\000\001\006\032\n\004\000\001\b\001\000\032\n/\000\001\n\n\000\001\n\004\000\001\n\005\000\027\n\001\000\037\n\001\000Ĩ\n\002\000\022\n\034\000^\n\002\000\t\n\002\000\007\n\016\000\002\n\016\000\005\n\t\000\001\n\000\001\n\013\000\001\n\001\000\003\n\001\000\001\n\001\000\024\n\001\000,\n\001\000\b\n\002\000\032\n\f\000\n\n\0009\n\002\000\002\n\002\000\002\n\003\000&\n\002\000\002\n7\000&\n\002\000\001\n\007\000'\nH\000\033\n\005\000\003\n.\000\032\n\005\000\013\n\025\000\n\002\007\000c\n\001\000\001\n\017\000\002\n\t\000\n\002\003\n\023\000\001\n\001\000\033\nS\000&\nş\0005\n\003\000\001\n\022\000\001\n\007\000\n\n\004\000\n\002\025\000\b\n\002\000\002\n\002\000\026\n\001\000\007\n\001\000\001\n\003\000\004\n\""\000\002\n\001\000\003\n\004\000\n\002\002\n\023\000\006\n\004\000\002\n\002\000\026\n\001\000\007\n\001\000\002\n\001\000\002\n\001\000\002\n\037\000\004\n\001\000\001\n\007\000\n\002\002\000\003\n\020\000\007\n\001\000\001\n\001\000\003\n\001\000\026\n\001\000\007\n\001\000\002\n\001\000\005\n\003\000\001\n\022\000\001\n\017\000\001\n\005\000\n\002\025\000\b\n\002\000\002\n\002\000\026\n\001\000\007\n\001\000\002\n\002\000\004\n\003\000\001\n\036\000\002\n\001\000\003\n\004\000\n\002\025\000\006\n\003\000\003\n\001\000\004\n\003\000\002\n\001\000\001\n\001\000\002\n\003\000\002\n\003\000\003\n\003\000\b\n\001\000\003\n-\000\t\002\025\000\b\n\001\000\003\n\001\000\027\n\001\000\n\n\001\000\005\n&\000\002\n\004\000\n\002\025\000\b\n\001\000\003\n\001\000\027\n\001\000\n\n\001\000\005\n$\000\001\n\001\000\002\n\004\000\n\002\025\000\b\n\001\000\003\n\001\000\027\n\001\000\020\n&\000\002\n\004\000\n\002\025\000\022\n\003\000\030\n\001\000\t\n\001\000\001\n\002\000\007\n9\000\001\0010\n\001\001\002\n\f\001\007\n\t\001\n\002'\000\002\n\001\000\001\n\002\000\002\n\001\000\001\n\002\000\001\n\006\000\004\n\001\000\007\n\001\000\003\n\001\000\001\n\001\000\001\n\002\000\002\n\001\000\004\n\001\000\002\n\t\000\001\n\002\000\005\n\001\000\001\n\t\000\n\002\002\000\002\n\""\000\001\n\037\000\n\002\026\000\b\n\001\000\""\n\035\000\004\nt\000\""\n\001\000\005\n\001\000\002\n\025\000\n\002\006\000\006\nJ\000&\n\n\000'\n\t\000Z\n\005\000D\n\005\000R\n\006\000\007\n\001\000?\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000\001\n\001\000\004\n\002\000'\n\001\000\001\n\001\000\004\n\002\000\037\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000\007\n\001\000\027\n\001\000\037\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000'\n\001\000\023\n\016\000\t\002.\000U\n\f\000ɬ\n\002\000\b\n\n\000\032\n\005\000K\n\0004\n,\000\n\002&\000\n\002\006\000X\n\b\000)\n՗\000\n\004\000Z\n\006\000\026\n\002\000\006\n\002\000&\n\002\000\006\n\002\000\b\n\001\000\001\n\001\000\001\n\001\000\001\n\001\000\037\n\002\0005\n\001\000\007\n\001\000\001\n\003\000\003\n\001\000\007\n\003\000\004\n\002\000\006\n\004\000\r\n\005\000\003\n\001\000\007\n\000\001\n\000\001\n\004\000\001\n\002\000\n\n\001\000\001\n\003\000\005\n\006\000\001\n\001\000\001\n\001\000\001\n\001\000\004\n\001\000\003\n\001\000\007\n໋\000\002\n*\000\005\n\n\000\001\013T\013\b\013\002\013\002\013Z\013\001\013\003\013\006\013(\013\003\013\001\000^\n\021\000\030\n8\000\020\013Ā\000\013\000ᦶ\013\n\013@\000冦\013Z\013ҍ\nݳ\000⮤\n⅜\000Į\013Ò\013\007\n\f\000\005\n\005\000\001\n\001\000\n\n\001\000\r\n\001\000\005\n\001\000\001\n\001\000\002\n\001\000\002\n\001\000l\n!\000ū\n\022\000@\n\002\0006\n(\000\f\nt\000\003\n\001\000\001\n\001\000\n\023\000\n\002\007\000\032\n\006\000\032\n\n\000\001\013:\013\037\n\003\000\006\n\002\000\006\n\002\000\006\n\002\000\003\n#\000"";
/* 118 */   private static final char[] ZZ_CMAP = zzUnpackCMap(""\t\000\001\000\001\r\001\000\001\000\001\f\022\000\001\000\005\000\001\005\001\003\004\000\001\t\001\007\001\004\001\t\n\002\006\000\001\006\032\n\004\000\001\b\001\000\032\n/\000\001\n\n\000\001\n\004\000\001\n\005\000\027\n\001\000\037\n\001\000Ĩ\n\002\000\022\n\034\000^\n\002\000\t\n\002\000\007\n\016\000\002\n\016\000\005\n\t\000\001\n\000\001\n\013\000\001\n\001\000\003\n\001\000\001\n\001\000\024\n\001\000,\n\001\000\b\n\002\000\032\n\f\000\n\n\0009\n\002\000\002\n\002\000\002\n\003\000&\n\002\000\002\n7\000&\n\002\000\001\n\007\000'\nH\000\033\n\005\000\003\n.\000\032\n\005\000\013\n\025\000\n\002\007\000c\n\001\000\001\n\017\000\002\n\t\000\n\002\003\n\023\000\001\n\001\000\033\nS\000&\nş\0005\n\003\000\001\n\022\000\001\n\007\000\n\n\004\000\n\002\025\000\b\n\002\000\002\n\002\000\026\n\001\000\007\n\001\000\001\n\003\000\004\n\""\000\002\n\001\000\003\n\004\000\n\002\002\n\023\000\006\n\004\000\002\n\002\000\026\n\001\000\007\n\001\000\002\n\001\000\002\n\001\000\002\n\037\000\004\n\001\000\001\n\007\000\n\002\002\000\003\n\020\000\007\n\001\000\001\n\001\000\003\n\001\000\026\n\001\000\007\n\001\000\002\n\001\000\005\n\003\000\001\n\022\000\001\n\017\000\001\n\005\000\n\002\025\000\b\n\002\000\002\n\002\000\026\n\001\000\007\n\001\000\002\n\002\000\004\n\003\000\001\n\036\000\002\n\001\000\003\n\004\000\n\002\025\000\006\n\003\000\003\n\001\000\004\n\003\000\002\n\001\000\001\n\001\000\002\n\003\000\002\n\003\000\003\n\003\000\b\n\001\000\003\n-\000\t\002\025\000\b\n\001\000\003\n\001\000\027\n\001\000\n\n\001\000\005\n&\000\002\n\004\000\n\002\025\000\b\n\001\000\003\n\001\000\027\n\001\000\n\n\001\000\005\n$\000\001\n\001\000\002\n\004\000\n\002\025\000\b\n\001\000\003\n\001\000\027\n\001\000\020\n&\000\002\n\004\000\n\002\025\000\022\n\003\000\030\n\001\000\t\n\001\000\001\n\002\000\007\n9\000\001\0010\n\001\001\002\n\f\001\007\n\t\001\n\002'\000\002\n\001\000\001\n\002\000\002\n\001\000\001\n\002\000\001\n\006\000\004\n\001\000\007\n\001\000\003\n\001\000\001\n\001\000\001\n\002\000\002\n\001\000\004\n\001\000\002\n\t\000\001\n\002\000\005\n\001\000\001\n\t\000\n\002\002\000\002\n\""\000\001\n\037\000\n\002\026\000\b\n\001\000\""\n\035\000\004\nt\000\""\n\001\000\005\n\001\000\002\n\025\000\n\002\006\000\006\nJ\000&\n\n\000'\n\t\000Z\n\005\000D\n\005\000R\n\006\000\007\n\001\000?\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000\001\n\001\000\004\n\002\000'\n\001\000\001\n\001\000\004\n\002\000\037\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000\007\n\001\000\027\n\001\000\037\n\001\000\001\n\001\000\004\n\002\000\007\n\001\000'\n\001\000\023\n\016\000\t\002.\000U\n\f\000ɬ\n\002\000\b\n\n\000\032\n\005\000K\n\0004\n,\000\n\002&\000\n\002\006\000X\n\b\000)\n՗\000\n\004\000Z\n\006\000\026\n\002\000\006\n\002\000&\n\002\000\006\n\002\000\b\n\001\000\001\n\001\000\001\n\001\000\001\n\001\000\037\n\002\0005\n\001\000\007\n\001\000\001\n\003\000\003\n\001\000\007\n\003\000\004\n\002\000\006\n\004\000\r\n\005\000\003\n\001\000\007\n\000\001\n\000\001\n\004\000\001\n\002\000\n\n\001\000\001\n\003\000\005\n\006\000\001\n\001\000\001\n\001\000\001\n\001\000\004\n\001\000\003\n\001\000\007\n໋\000\002\n*\000\005\n\n\000\001\013T\013\b\013\002\013\002\013Z\013\001\013\003\013\006\013(\013\003\013\001\000^\n\021\000\030\n8\000\020\013Ā\000\013\000ᦶ\013\n\013@\000冦\013Z\013ҍ\nݳ\000⮤\n⅜\000Į\013Ò\013\007\n\f\000\005\n\005\000\001\n\001\000\n\n\001\000\r\n\001\000\005\n\001\000\001\n\001\000\002\n\001\000\002\n\001\000l\n!\000ū\n\022\000@\n\002\0006\n(\000\f\nt\000\003\n\001\000\001\n\001\000\n\023\000\n\002\007\000\032\n\006\000\032\n\n\000\001\013:\013\037\n\003\000\006\n\002\000\006\n\002\000\006\n\002\000\003\n#\000"");
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 123 */   private static final int[] ZZ_ACTION = zzUnpackAction();
/*     */ 
/*     */ 
/*     */   
/*     */   private static final String ZZ_ACTION_PACKED_0 = ""\001\000\001\001\003\002\001\003\001\001\013\000\001\002\003\004\002\000\001\005\001\000\001\005\003\004\006\005\001\006\001\004\002\007\001\b\001\000\001\b\003\000\002\b\001\t\001\n\001\004"";
/*     */ 
/*     */ 
/*     */   
/*     */   private static int[] zzUnpackAction() {
/* 132 */     int[] result = new int[51];
/* 133 */     int offset = 0;
/* 134 */     offset = zzUnpackAction(""\001\000\001\001\003\002\001\003\001\001\013\000\001\002\003\004\002\000\001\005\001\000\001\005\003\004\006\005\001\006\001\004\002\007\001\b\001\000\001\b\003\000\002\b\001\t\001\n\001\004"", offset, result);
/* 135 */     return result;
/*     */   }
/*     */   
/*     */   private static int zzUnpackAction(String packed, int offset, int[] result) {
/* 139 */     int i = 0;
/* 140 */     int j = offset;
/* 141 */     int l = packed.length();
/* 142 */     label10: while (i < l) {
/* 143 */       int count = packed.charAt(i++);
/* 144 */       int value = packed.charAt(i++); while (true)
/* 145 */       { result[j++] = value; if (--count <= 0)
/*     */           continue label10;  } 
/* 147 */     }  return j;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 154 */   private static final int[] ZZ_ROWMAP = zzUnpackRowMap();
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final String ZZ_ROWMAP_PACKED_0 = ""\000\000\000\016\000\034\000*\0008\000\016\000F\000T\000b\000p\000~\000\000\000¨\000¶\000Ä\000Ò\000à\000î\000ü\000Ċ\000Ę\000Ħ\000Ĵ\000ł\000Ő\000Ş\000Ŭ\000ź\000ƈ\000Ɩ\000Ƥ\000Ʋ\000ǀ\000ǎ\000ǜ\000Ǫ\000Ǹ\000Ò\000Ȇ\000Ȕ\000Ȣ\000Ȱ\000Ⱦ\000Ɍ\000ɚ\000T\000\000ɨ\000ɶ\000ʄ"";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static int[] zzUnpackRowMap() {
/* 166 */     int[] result = new int[51];
/* 167 */     int offset = 0;
/* 168 */     offset = zzUnpackRowMap(""\000\000\000\016\000\034\000*\0008\000\016\000F\000T\000b\000p\000~\000\000\000¨\000¶\000Ä\000Ò\000à\000î\000ü\000Ċ\000Ę\000Ħ\000Ĵ\000ł\000Ő\000Ş\000Ŭ\000ź\000ƈ\000Ɩ\000Ƥ\000Ʋ\000ǀ\000ǎ\000ǜ\000Ǫ\000Ǹ\000Ò\000Ȇ\000Ȕ\000Ȣ\000Ȱ\000Ⱦ\000Ɍ\000ɚ\000T\000\000ɨ\000ɶ\000ʄ"", offset, result);
/* 169 */     return result;
/*     */   }
/*     */   
/*     */   private static int zzUnpackRowMap(String packed, int offset, int[] result) {
/* 173 */     int i = 0;
/* 174 */     int j = offset;
/* 175 */     int l = packed.length();
/* 176 */     while (i < l) {
/* 177 */       int high = packed.charAt(i++) << 16;
/* 178 */       result[j++] = high | packed.charAt(i++);
/*     */     } 
/* 180 */     return j;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 186 */   private static final int[] ZZ_TRANS = zzUnpackTrans();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final String ZZ_TRANS_PACKED_0 = ""\001\002\001\003\001\004\007\002\001\005\001\006\001\007\001\002\017\000\002\003\001\000\001\b\001\000\001\t\002\n\001\013\001\003\004\000\001\003\001\004\001\000\001\f\001\000\001\t\002\r\001\016\001\004\004\000\001\003\001\004\001\017\001\020\001\021\001\022\002\n\001\013\001\023\020\000\001\002\001\000\001\024\001\025\007\000\001\026\004\000\002\027\007\000\001\027\004\000\001\030\001\031\007\000\001\032\005\000\001\033\007\000\001\013\004\000\001\034\001\035\007\000\001\036\004\000\001\037\001 \007\000\001!\004\000\001\""\001#\007\000\001$\r\000\001%\004\000\001\024\001\025\007\000\001&\r\000\001'\004\000\002\027\007\000\001(\004\000\001\003\001\004\001\017\001\b\001\021\001\022\002\n\001\013\001\023\004\000\002\024\001\000\001)\001\000\001\t\002*\001\000\001\024\004\000\001\024\001\025\001\000\001+\001\000\001\t\002,\001-\001\025\004\000\001\024\001\025\001\000\001)\001\000\001\t\002*\001\000\001\026\004\000\002\027\001\000\001.\002\000\001.\002\000\001\027\004\000\002\030\001\000\001*\001\000\001\t\002*\001\000\001\030\004\000\001\030\001\031\001\000\001,\001\000\001\t\002,\001-\001\031\004\000\001\030\001\031\001\000\001*\001\000\001\t\002*\001\000\001\032\005\000\001\033\001\000\001-\002\000\003-\001\033\004\000\002\034\001\000\001/\001\000\001\t\002\n\001\013\001\034\004\000\001\034\001\035\001\000\0010\001\000\001\t\002\r\001\016\001\035\004\000\001\034\001\035\001\000\001/\001\000\001\t\002\n\001\013\001\036\004\000\002\037\001\000\001\n\001\000\001\t\002\n\001\013\001\037\004\000\001\037\001 \001\000\001\r\001\000\001\t\002\r\001\016\001 \004\000\001\037\001 \001\000\001\n\001\000\001\t\002\n\001\013\001!\004\000\002\""\001\000\001\013\002\000\003\013\001\""\004\000\001\""\001#\001\000\001\016\002\000\003\016\001#\004\000\001\""\001#\001\000\001\013\002\000\003\013\001$\006\000\001\017\006\000\001%\004\000\001\024\001\025\001\000\0011\001\000\001\t\002*\001\000\001\026\004\000\002\027\001\000\001.\002\000\001.\002\000\001(\004\000\002\024\007\000\001\024\004\000\002\030\007\000\001\030\004\000\002\034\007\000\001\034\004\000\002\037\007\000\001\037\004\000\002\""\007\000\001\""\004\000\0022\007\000\0012\004\000\002\024\007\000\0013\004\000\0022\001\000\001.\002\000\001.\002\000\0012\004\000\002\024\001\000\0011\001\000\001\t\002*\001\000\001\024\003\000"";
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final int ZZ_UNKNOWN_ERROR = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final int ZZ_NO_MATCH = 1;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final int ZZ_PUSHBACK_2BIG = 2;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static int[] zzUnpackTrans() {
/* 231 */     int[] result = new int[658];
/* 232 */     int offset = 0;
/* 233 */     offset = zzUnpackTrans(""\001\002\001\003\001\004\007\002\001\005\001\006\001\007\001\002\017\000\002\003\001\000\001\b\001\000\001\t\002\n\001\013\001\003\004\000\001\003\001\004\001\000\001\f\001\000\001\t\002\r\001\016\001\004\004\000\001\003\001\004\001\017\001\020\001\021\001\022\002\n\001\013\001\023\020\000\001\002\001\000\001\024\001\025\007\000\001\026\004\000\002\027\007\000\001\027\004\000\001\030\001\031\007\000\001\032\005\000\001\033\007\000\001\013\004\000\001\034\001\035\007\000\001\036\004\000\001\037\001 \007\000\001!\004\000\001\""\001#\007\000\001$\r\000\001%\004\000\001\024\001\025\007\000\001&\r\000\001'\004\000\002\027\007\000\001(\004\000\001\003\001\004\001\017\001\b\001\021\001\022\002\n\001\013\001\023\004\000\002\024\001\000\001)\001\000\001\t\002*\001\000\001\024\004\000\001\024\001\025\001\000\001+\001\000\001\t\002,\001-\001\025\004\000\001\024\001\025\001\000\001)\001\000\001\t\002*\001\000\001\026\004\000\002\027\001\000\001.\002\000\001.\002\000\001\027\004\000\002\030\001\000\001*\001\000\001\t\002*\001\000\001\030\004\000\001\030\001\031\001\000\001,\001\000\001\t\002,\001-\001\031\004\000\001\030\001\031\001\000\001*\001\000\001\t\002*\001\000\001\032\005\000\001\033\001\000\001-\002\000\003-\001\033\004\000\002\034\001\000\001/\001\000\001\t\002\n\001\013\001\034\004\000\001\034\001\035\001\000\0010\001\000\001\t\002\r\001\016\001\035\004\000\001\034\001\035\001\000\001/\001\000\001\t\002\n\001\013\001\036\004\000\002\037\001\000\001\n\001\000\001\t\002\n\001\013\001\037\004\000\001\037\001 \001\000\001\r\001\000\001\t\002\r\001\016\001 \004\000\001\037\001 \001\000\001\n\001\000\001\t\002\n\001\013\001!\004\000\002\""\001\000\001\013\002\000\003\013\001\""\004\000\001\""\001#\001\000\001\016\002\000\003\016\001#\004\000\001\""\001#\001\000\001\013\002\000\003\013\001$\006\000\001\017\006\000\001%\004\000\001\024\001\025\001\000\0011\001\000\001\t\002*\001\000\001\026\004\000\002\027\001\000\001.\002\000\001.\002\000\001(\004\000\002\024\007\000\001\024\004\000\002\030\007\000\001\030\004\000\002\034\007\000\001\034\004\000\002\037\007\000\001\037\004\000\002\""\007\000\001\""\004\000\0022\007\000\0012\004\000\002\024\007\000\0013\004\000\0022\001\000\001.\002\000\001.\002\000\0012\004\000\002\024\001\000\0011\001\000\001\t\002*\001\000\001\024\003\000"", offset, result);
/* 234 */     return result;
/*     */   }
/*     */   
/*     */   private static int zzUnpackTrans(String packed, int offset, int[] result) {
/* 238 */     int i = 0;
/* 239 */     int j = offset;
/* 240 */     int l = packed.length();
/* 241 */     label10: while (i < l) {
/* 242 */       int count = packed.charAt(i++);
/* 243 */       int value = packed.charAt(i++);
/* 244 */       value--; while (true)
/* 245 */       { result[j++] = value; if (--count <= 0)
/*     */           continue label10;  } 
/* 247 */     }  return j;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 257 */   private static final String[] ZZ_ERROR_MSG = new String[] { ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 266 */   private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();
/*     */   
/*     */   private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\001\000\001\t\003\001\001\t\001\001\013\000\004\001\002\000\001\001\001\000\017\001\001\000\001\001\003\000\005\001"";
/*     */   private Reader zzReader;
/*     */   private int zzState;
/*     */   
/*     */   private static int[] zzUnpackAttribute() {
/* 273 */     int[] result = new int[51];
/* 274 */     int offset = 0;
/* 275 */     offset = zzUnpackAttribute(""\001\000\001\t\003\001\001\t\001\001\013\000\004\001\002\000\001\001\001\000\017\001\001\000\001\001\003\000\005\001"", offset, result);
/* 276 */     return result;
/*     */   }
/*     */   
/*     */   private static int zzUnpackAttribute(String packed, int offset, int[] result) {
/* 280 */     int i = 0;
/* 281 */     int j = offset;
/* 282 */     int l = packed.length();
/* 283 */     label10: while (i < l) {
/* 284 */       int count = packed.charAt(i++);
/* 285 */       int value = packed.charAt(i++); while (true)
/* 286 */       { result[j++] = value; if (--count <= 0)
/*     */           continue label10;  } 
/* 288 */     }  return j;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 298 */   private int zzLexicalState = 0;
/*     */ 
/*     */ 
/*     */   
/* 302 */   private char[] zzBuffer = new char[16384];
/*     */ 
/*     */   
/*     */   private int zzMarkedPos;
/*     */ 
/*     */   
/*     */   private int zzPushbackPos;
/*     */ 
/*     */   
/*     */   private int zzCurrentPos;
/*     */ 
/*     */   
/*     */   private int zzStartRead;
/*     */ 
/*     */   
/*     */   private int zzEndRead;
/*     */ 
/*     */   
/*     */   private int yyline;
/*     */ 
/*     */   
/*     */   private int yychar;
/*     */ 
/*     */   
/*     */   private int yycolumn;
/*     */ 
/*     */   
/*     */   private boolean zzAtBOL = true;
/*     */ 
/*     */   
/*     */   private boolean zzAtEOF;
/*     */ 
/*     */   
/*     */   public static final int ALPHANUM = 0;
/*     */ 
/*     */   
/*     */   public static final int APOSTROPHE = 1;
/*     */ 
/*     */   
/*     */   public static final int ACRONYM = 2;
/*     */ 
/*     */   
/*     */   public static final int COMPANY = 3;
/*     */ 
/*     */   
/*     */   public static final int EMAIL = 4;
/*     */   
/*     */   public static final int HOST = 5;
/*     */   
/*     */   public static final int NUM = 6;
/*     */   
/*     */   public static final int CJ = 7;
/*     */   
/*     */   public static final int ACRONYM_DEP = 8;
/*     */   
/* 357 */   public static final String[] TOKEN_TYPES = StandardTokenizer.TOKEN_TYPES;
/*     */ 
/*     */ 
/*     */   
/* 361 */   public final int yychar() { return this.yychar; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 368 */   final void getText(Token t) { t.setTermBuffer(this.zzBuffer, this.zzStartRead, this.zzMarkedPos - this.zzStartRead); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 379 */   StandardTokenizerImpl(Reader in) { this.zzReader = in; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 389 */   StandardTokenizerImpl(InputStream in) { this(new InputStreamReader(in)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static char[] zzUnpackCMap(String packed) {
/* 399 */     char[] map = new char[65536];
/* 400 */     int i = 0;
/* 401 */     int j = 0;
/* 402 */     label10: while (i < 1154) {
/* 403 */       int count = packed.charAt(i++);
/* 404 */       char value = packed.charAt(i++); while (true)
/* 405 */       { map[j++] = value; if (--count <= 0)
/*     */           continue label10;  } 
/* 407 */     }  return map;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean zzRefill() throws IOException {
/* 421 */     if (this.zzStartRead > 0) {
/* 422 */       System.arraycopy(this.zzBuffer, this.zzStartRead, this.zzBuffer, 0, this.zzEndRead - this.zzStartRead);
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 427 */       this.zzEndRead -= this.zzStartRead;
/* 428 */       this.zzCurrentPos -= this.zzStartRead;
/* 429 */       this.zzMarkedPos -= this.zzStartRead;
/* 430 */       this.zzPushbackPos -= this.zzStartRead;
/* 431 */       this.zzStartRead = 0;
/*     */     } 
/*     */ 
/*     */     
/* 435 */     if (this.zzCurrentPos >= this.zzBuffer.length) {
/*     */       
/* 437 */       char[] newBuffer = new char[this.zzCurrentPos * 2];
/* 438 */       System.arraycopy(this.zzBuffer, 0, newBuffer, 0, this.zzBuffer.length);
/* 439 */       this.zzBuffer = newBuffer;
/*     */     } 
/*     */ 
/*     */     
/* 443 */     int numRead = this.zzReader.read(this.zzBuffer, this.zzEndRead, this.zzBuffer.length - this.zzEndRead);
/*     */ 
/*     */     
/* 446 */     if (numRead < 0) {
/* 447 */       return true;
/*     */     }
/*     */     
/* 450 */     this.zzEndRead += numRead;
/* 451 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void yyclose() throws IOException {
/* 460 */     this.zzAtEOF = true;
/* 461 */     this.zzEndRead = this.zzStartRead;
/*     */     
/* 463 */     if (this.zzReader != null) {
/* 464 */       this.zzReader.close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void yyreset(Reader reader) {
/* 479 */     this.zzReader = reader;
/* 480 */     this.zzAtBOL = true;
/* 481 */     this.zzAtEOF = false;
/* 482 */     this.zzEndRead = this.zzStartRead = 0;
/* 483 */     this.zzCurrentPos = this.zzMarkedPos = this.zzPushbackPos = 0;
/* 484 */     this.yyline = this.yychar = this.yycolumn = 0;
/* 485 */     this.zzLexicalState = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 493 */   public final int yystate() { return this.zzLexicalState; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 503 */   public final void yybegin(int newState) { this.zzLexicalState = newState; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 511 */   public final String yytext() { return new String(this.zzBuffer, this.zzStartRead, this.zzMarkedPos - this.zzStartRead); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 527 */   public final char yycharat(int pos) { return this.zzBuffer[this.zzStartRead + pos]; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 535 */   public final int yylength() { return this.zzMarkedPos - this.zzStartRead; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void zzScanError(int errorCode) {
/*     */     String str;
/*     */     try {
/* 556 */       str = ZZ_ERROR_MSG[errorCode];
/*     */     }
/* 558 */     catch (ArrayIndexOutOfBoundsException e) {
/* 559 */       str = ZZ_ERROR_MSG[0];
/*     */     } 
/*     */     
/* 562 */     throw new Error(str);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void yypushback(int number) {
/* 575 */     if (number > yylength()) {
/* 576 */       zzScanError(2);
/*     */     }
/* 578 */     this.zzMarkedPos -= number;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getNextToken() throws IOException {
/* 596 */     int zzEndReadL = this.zzEndRead;
/* 597 */     char[] zzBufferL = this.zzBuffer;
/* 598 */     char[] zzCMapL = ZZ_CMAP;
/*     */     
/* 600 */     int[] zzTransL = ZZ_TRANS;
/* 601 */     int[] zzRowMapL = ZZ_ROWMAP;
/* 602 */     int[] zzAttrL = ZZ_ATTRIBUTE;
/*     */     
/*     */     while (true) {
/* 605 */       int zzInput, zzMarkedPosL = this.zzMarkedPos;
/*     */       
/* 607 */       this.yychar += zzMarkedPosL - this.zzStartRead;
/*     */       
/* 609 */       int zzAction = -1;
/*     */       
/* 611 */       int zzCurrentPosL = this.zzCurrentPos = this.zzStartRead = zzMarkedPosL;
/*     */       
/* 613 */       this.zzState = this.zzLexicalState;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*     */       while (true) {
/* 619 */         if (zzCurrentPosL < zzEndReadL)
/* 620 */         { zzInput = zzBufferL[zzCurrentPosL++]; }
/* 621 */         else { if (this.zzAtEOF) {
/* 622 */             int zzInput = -1;
/*     */             
/*     */             break;
/*     */           } 
/*     */           
/* 627 */           this.zzCurrentPos = zzCurrentPosL;
/* 628 */           this.zzMarkedPos = zzMarkedPosL;
/* 629 */           boolean eof = zzRefill();
/*     */           
/* 631 */           zzCurrentPosL = this.zzCurrentPos;
/* 632 */           zzMarkedPosL = this.zzMarkedPos;
/* 633 */           zzBufferL = this.zzBuffer;
/* 634 */           zzEndReadL = this.zzEndRead;
/* 635 */           if (eof) {
/* 636 */             int zzInput = -1;
/*     */             
/*     */             break;
/*     */           } 
/* 640 */           zzInput = zzBufferL[zzCurrentPosL++]; }
/*     */ 
/*     */         
/* 643 */         int zzNext = zzTransL[zzRowMapL[this.zzState] + zzCMapL[zzInput]];
/* 644 */         if (zzNext == -1)
/* 645 */           break;  this.zzState = zzNext;
/*     */         
/* 647 */         int zzAttributes = zzAttrL[this.zzState];
/* 648 */         if ((zzAttributes & 0x1) == 1) {
/* 649 */           zzAction = this.zzState;
/* 650 */           zzMarkedPosL = zzCurrentPosL;
/* 651 */           if ((zzAttributes & 0x8) == 8) {
/*     */             break;
/*     */           }
/*     */         } 
/*     */       } 
/*     */ 
/*     */       
/* 658 */       this.zzMarkedPos = zzMarkedPosL;
/*     */       
/* 660 */       switch ((zzAction < 0) ? zzAction : ZZ_ACTION[zzAction]) {
/*     */         case 4:
/* 662 */           return 5;
/*     */         case 11:
/*     */           continue;
/*     */         case 9:
/* 666 */           return 2;
/*     */         case 12:
/*     */           continue;
/*     */         case 8:
/* 670 */           return 8;
/*     */         
/*     */         case 13:
/*     */         case 1:
/*     */         case 14:
/*     */           continue;
/*     */         
/*     */         case 5:
/* 678 */           return 6;
/*     */         case 15:
/*     */           continue;
/*     */         case 3:
/* 682 */           return 7;
/*     */         case 16:
/*     */           continue;
/*     */         case 2:
/* 686 */           return 0;
/*     */         case 17:
/*     */           continue;
/*     */         case 7:
/* 690 */           return 3;
/*     */         case 18:
/*     */           continue;
/*     */         case 6:
/* 694 */           return 1;
/*     */         case 19:
/*     */           continue;
/*     */         case 10:
/* 698 */           return 4;
/*     */         case 20:
/*     */           continue;
/*     */       } 
/* 702 */       if (zzInput == -1 && this.zzStartRead == this.zzCurrentPos) {
/* 703 */         this.zzAtEOF = true;
/* 704 */         return -1;
/*     */       } 
/*     */       
/* 707 */       zzScanError(1);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizerImpl.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.AbstractField,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class AbstractField
/*     */   implements Fieldable
/*     */ {
/*  25 */   protected String name = ""body"";
/*     */   protected boolean storeTermVector = false;
/*     */   protected boolean storeOffsetWithTermVector = false;
/*     */   protected boolean storePositionWithTermVector = false;
/*     */   protected boolean omitNorms = false;
/*     */   protected boolean isStored = false;
/*     */   protected boolean isIndexed = true;
/*     */   protected boolean isTokenized = true;
/*     */   protected boolean isBinary = false;
/*     */   protected boolean isCompressed = false;
/*     */   protected boolean lazy = false;
/*     */   protected boolean omitTf = false;
/*  37 */   protected float boost = 1.0F;
/*     */   
/*  39 */   protected Object fieldsData = null;
/*     */   
/*     */   protected int binaryLength;
/*     */   
/*     */   protected int binaryOffset;
/*     */ 
/*     */   
/*     */   protected AbstractField() {}
/*     */   
/*     */   protected AbstractField(String name, Field.Store store, Field.Index index, Field.TermVector termVector) {
/*  49 */     if (name == null)
/*  50 */       throw new NullPointerException(""name cannot be null""); 
/*  51 */     this.name = name.intern();
/*     */     
/*  53 */     if (store == Field.Store.YES) {
/*  54 */       this.isStored = true;
/*  55 */       this.isCompressed = false;
/*     */     }
/*  57 */     else if (store == Field.Store.COMPRESS) {
/*  58 */       this.isStored = true;
/*  59 */       this.isCompressed = true;
/*     */     }
/*  61 */     else if (store == Field.Store.NO) {
/*  62 */       this.isStored = false;
/*  63 */       this.isCompressed = false;
/*     */     } else {
/*     */       
/*  66 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/*  68 */     if (index == Field.Index.NO) {
/*  69 */       this.isIndexed = false;
/*  70 */       this.isTokenized = false;
/*  71 */     } else if (index == Field.Index.ANALYZED) {
/*  72 */       this.isIndexed = true;
/*  73 */       this.isTokenized = true;
/*  74 */     } else if (index == Field.Index.NOT_ANALYZED) {
/*  75 */       this.isIndexed = true;
/*  76 */       this.isTokenized = false;
/*  77 */     } else if (index == Field.Index.NOT_ANALYZED_NO_NORMS) {
/*  78 */       this.isIndexed = true;
/*  79 */       this.isTokenized = false;
/*  80 */       this.omitNorms = true;
/*  81 */     } else if (index == Field.Index.ANALYZED_NO_NORMS) {
/*  82 */       this.isIndexed = true;
/*  83 */       this.isTokenized = true;
/*  84 */       this.omitNorms = true;
/*     */     } else {
/*  86 */       throw new IllegalArgumentException(""unknown index parameter "" + index);
/*     */     } 
/*     */     
/*  89 */     this.isBinary = false;
/*     */     
/*  91 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 111 */   public void setBoost(float boost) { this.boost = boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 132 */   public String name() { return this.name; }
/*     */   
/*     */   protected void setStoreTermVector(Field.TermVector termVector) {
/* 135 */     if (termVector == Field.TermVector.NO) {
/* 136 */       this.storeTermVector = false;
/* 137 */       this.storePositionWithTermVector = false;
/* 138 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 140 */     else if (termVector == Field.TermVector.YES) {
/* 141 */       this.storeTermVector = true;
/* 142 */       this.storePositionWithTermVector = false;
/* 143 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 145 */     else if (termVector == Field.TermVector.WITH_POSITIONS) {
/* 146 */       this.storeTermVector = true;
/* 147 */       this.storePositionWithTermVector = true;
/* 148 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 150 */     else if (termVector == Field.TermVector.WITH_OFFSETS) {
/* 151 */       this.storeTermVector = true;
/* 152 */       this.storePositionWithTermVector = false;
/* 153 */       this.storeOffsetWithTermVector = true;
/*     */     }
/* 155 */     else if (termVector == Field.TermVector.WITH_POSITIONS_OFFSETS) {
/* 156 */       this.storeTermVector = true;
/* 157 */       this.storePositionWithTermVector = true;
/* 158 */       this.storeOffsetWithTermVector = true;
/*     */     } else {
/*     */       
/* 161 */       throw new IllegalArgumentException(""unknown termVector parameter "" + termVector);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 168 */   public final boolean isStored() { return this.isStored; }
/*     */ 
/*     */ 
/*     */   
/* 172 */   public final boolean isIndexed() { return this.isIndexed; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 177 */   public final boolean isTokenized() { return this.isTokenized; }
/*     */ 
/*     */   
/* 180 */   public final boolean isCompressed() { return this.isCompressed; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 190 */   public final boolean isTermVectorStored() { return this.storeTermVector; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 197 */   public boolean isStoreOffsetWithTermVector() { return this.storeOffsetWithTermVector; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 204 */   public boolean isStorePositionWithTermVector() { return this.storePositionWithTermVector; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 209 */   public final boolean isBinary() { return this.isBinary; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 221 */   public byte[] getBinaryValue() { return getBinaryValue(null); }
/*     */ 
/*     */   
/*     */   public byte[] getBinaryValue(byte[] result) {
/* 225 */     if (this.isBinary || this.fieldsData instanceof byte[]) {
/* 226 */       return (byte[])this.fieldsData;
/*     */     }
/* 228 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getBinaryLength() {
/* 237 */     if (this.isBinary) {
/* 238 */       if (!this.isCompressed) {
/* 239 */         return this.binaryLength;
/*     */       }
/* 241 */       return ((byte[])this.fieldsData).length;
/* 242 */     }  if (this.fieldsData instanceof byte[]) {
/* 243 */       return ((byte[])this.fieldsData).length;
/*     */     }
/* 245 */     return 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 254 */   public int getBinaryOffset() { return this.binaryOffset; }
/*     */ 
/*     */ 
/*     */   
/* 258 */   public boolean getOmitNorms() { return this.omitNorms; }
/*     */ 
/*     */   
/* 261 */   public boolean getOmitTf() { return this.omitTf; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 268 */   public void setOmitNorms(boolean omitNorms) { this.omitNorms = omitNorms; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 274 */   public void setOmitTf(boolean omitTf) { this.omitTf = omitTf; }
/*     */ 
/*     */   
/* 277 */   public boolean isLazy() { return this.lazy; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final String toString() {
/* 282 */     StringBuffer result = new StringBuffer();
/* 283 */     if (this.isStored) {
/* 284 */       result.append(""stored"");
/* 285 */       if (this.isCompressed) {
/* 286 */         result.append(""/compressed"");
/*     */       } else {
/* 288 */         result.append(""/uncompressed"");
/*     */       } 
/* 290 */     }  if (this.isIndexed) {
/* 291 */       if (result.length() > 0)
/* 292 */         result.append("",""); 
/* 293 */       result.append(""indexed"");
/*     */     } 
/* 295 */     if (this.isTokenized) {
/* 296 */       if (result.length() > 0)
/* 297 */         result.append("",""); 
/* 298 */       result.append(""tokenized"");
/*     */     } 
/* 300 */     if (this.storeTermVector) {
/* 301 */       if (result.length() > 0)
/* 302 */         result.append("",""); 
/* 303 */       result.append(""termVector"");
/*     */     } 
/* 305 */     if (this.storeOffsetWithTermVector) {
/* 306 */       if (result.length() > 0)
/* 307 */         result.append("",""); 
/* 308 */       result.append(""termVectorOffsets"");
/*     */     } 
/* 310 */     if (this.storePositionWithTermVector) {
/* 311 */       if (result.length() > 0)
/* 312 */         result.append("",""); 
/* 313 */       result.append(""termVectorPosition"");
/*     */     } 
/* 315 */     if (this.isBinary) {
/* 316 */       if (result.length() > 0)
/* 317 */         result.append("",""); 
/* 318 */       result.append(""binary"");
/*     */     } 
/* 320 */     if (this.omitNorms) {
/* 321 */       result.append("",omitNorms"");
/*     */     }
/* 323 */     if (this.omitTf) {
/* 324 */       result.append("",omitTf"");
/*     */     }
/* 326 */     if (this.lazy) {
/* 327 */       result.append("",lazy"");
/*     */     }
/* 329 */     result.append('<');
/* 330 */     result.append(this.name);
/* 331 */     result.append(':');
/*     */     
/* 333 */     if (this.fieldsData != null && !this.lazy) {
/* 334 */       result.append(this.fieldsData);
/*     */     }
/*     */     
/* 337 */     result.append('>');
/* 338 */     return result.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\AbstractField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.DateField,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.util.Date;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DateField
/*     */ {
/*  49 */   private static int DATE_LEN = Long.toString(31536000000000L, 36).length();
/*     */ 
/*     */ 
/*     */   
/*  53 */   public static String MIN_DATE_STRING() { return timeToString(0L); }
/*     */ 
/*     */   
/*     */   public static String MAX_DATE_STRING() {
/*  57 */     char[] buffer = new char[DATE_LEN];
/*  58 */     char c = Character.forDigit(35, 36);
/*  59 */     for (int i = 0; i < DATE_LEN; i++)
/*  60 */       buffer[i] = c; 
/*  61 */     return new String(buffer);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  70 */   public static String dateToString(Date date) { return timeToString(date.getTime()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String timeToString(long time) {
/*  78 */     if (time < 0L) {
/*  79 */       throw new RuntimeException(""time '"" + time + ""' is too early, must be >= 0"");
/*     */     }
/*  81 */     String s = Long.toString(time, 36);
/*     */     
/*  83 */     if (s.length() > DATE_LEN) {
/*  84 */       throw new RuntimeException(""time '"" + time + ""' is too late, length of string "" + ""representation must be <= "" + DATE_LEN);
/*     */     }
/*     */ 
/*     */     
/*  88 */     if (s.length() < DATE_LEN) {
/*  89 */       StringBuffer sb = new StringBuffer(s);
/*  90 */       while (sb.length() < DATE_LEN)
/*  91 */         sb.insert(0, 0); 
/*  92 */       s = sb.toString();
/*     */     } 
/*     */     
/*  95 */     return s;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 100 */   public static long stringToTime(String s) { return Long.parseLong(s, 36); }
/*     */ 
/*     */ 
/*     */   
/* 104 */   public static Date stringToDate(String s) { return new Date(stringToTime(s)); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\DateField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.DateTools,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.text.ParseException;
/*     */ import java.text.SimpleDateFormat;
/*     */ import java.util.Calendar;
/*     */ import java.util.Date;
/*     */ import java.util.TimeZone;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DateTools
/*     */ {
/*  42 */   private static final TimeZone GMT = TimeZone.getTimeZone(""GMT"");
/*     */   
/*  44 */   private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(""yyyy"");
/*  45 */   private static final SimpleDateFormat MONTH_FORMAT = new SimpleDateFormat(""yyyyMM"");
/*  46 */   private static final SimpleDateFormat DAY_FORMAT = new SimpleDateFormat(""yyyyMMdd"");
/*  47 */   private static final SimpleDateFormat HOUR_FORMAT = new SimpleDateFormat(""yyyyMMddHH"");
/*  48 */   private static final SimpleDateFormat MINUTE_FORMAT = new SimpleDateFormat(""yyyyMMddHHmm"");
/*  49 */   private static final SimpleDateFormat SECOND_FORMAT = new SimpleDateFormat(""yyyyMMddHHmmss"");
/*  50 */   private static final SimpleDateFormat MILLISECOND_FORMAT = new SimpleDateFormat(""yyyyMMddHHmmssSSS"");
/*     */ 
/*     */   
/*     */   static  {
/*  54 */     YEAR_FORMAT.setTimeZone(GMT);
/*  55 */     MONTH_FORMAT.setTimeZone(GMT);
/*  56 */     DAY_FORMAT.setTimeZone(GMT);
/*  57 */     HOUR_FORMAT.setTimeZone(GMT);
/*  58 */     MINUTE_FORMAT.setTimeZone(GMT);
/*  59 */     SECOND_FORMAT.setTimeZone(GMT);
/*  60 */     MILLISECOND_FORMAT.setTimeZone(GMT);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public static String dateToString(Date date, Resolution resolution) { return timeToString(date.getTime(), resolution); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String timeToString(long time, Resolution resolution) {
/*     */     String result;
/*  89 */     Calendar cal = Calendar.getInstance(GMT);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  94 */     cal.setTime(new Date(round(time, resolution)));
/*     */ 
/*     */     
/*  97 */     if (resolution == Resolution.YEAR) {
/*  98 */       synchronized (YEAR_FORMAT) {
/*  99 */         result = YEAR_FORMAT.format(cal.getTime());
/*     */       } 
/* 101 */     } else if (resolution == Resolution.MONTH) {
/* 102 */       synchronized (MONTH_FORMAT) {
/* 103 */         result = MONTH_FORMAT.format(cal.getTime());
/*     */       } 
/* 105 */     } else if (resolution == Resolution.DAY) {
/* 106 */       synchronized (DAY_FORMAT) {
/* 107 */         result = DAY_FORMAT.format(cal.getTime());
/*     */       } 
/* 109 */     } else if (resolution == Resolution.HOUR) {
/* 110 */       synchronized (HOUR_FORMAT) {
/* 111 */         result = HOUR_FORMAT.format(cal.getTime());
/*     */       } 
/* 113 */     } else if (resolution == Resolution.MINUTE) {
/* 114 */       synchronized (MINUTE_FORMAT) {
/* 115 */         result = MINUTE_FORMAT.format(cal.getTime());
/*     */       } 
/* 117 */     } else if (resolution == Resolution.SECOND) {
/* 118 */       synchronized (SECOND_FORMAT) {
/* 119 */         result = SECOND_FORMAT.format(cal.getTime());
/*     */       } 
/* 121 */     } else if (resolution == Resolution.MILLISECOND) {
/* 122 */       synchronized (MILLISECOND_FORMAT) {
/* 123 */         result = MILLISECOND_FORMAT.format(cal.getTime());
/*     */       } 
/*     */     } else {
/* 126 */       throw new IllegalArgumentException(""unknown resolution "" + resolution);
/*     */     } 
/* 128 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 142 */   public static long stringToTime(String dateString) throws ParseException { return stringToDate(dateString).getTime(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Date stringToDate(String dateString) throws ParseException {
/*     */     Date date;
/* 157 */     if (dateString.length() == 4) {
/* 158 */       synchronized (YEAR_FORMAT) {
/* 159 */         date = YEAR_FORMAT.parse(dateString);
/*     */       } 
/* 161 */     } else if (dateString.length() == 6) {
/* 162 */       synchronized (MONTH_FORMAT) {
/* 163 */         date = MONTH_FORMAT.parse(dateString);
/*     */       } 
/* 165 */     } else if (dateString.length() == 8) {
/* 166 */       synchronized (DAY_FORMAT) {
/* 167 */         date = DAY_FORMAT.parse(dateString);
/*     */       } 
/* 169 */     } else if (dateString.length() == 10) {
/* 170 */       synchronized (HOUR_FORMAT) {
/* 171 */         date = HOUR_FORMAT.parse(dateString);
/*     */       } 
/* 173 */     } else if (dateString.length() == 12) {
/* 174 */       synchronized (MINUTE_FORMAT) {
/* 175 */         date = MINUTE_FORMAT.parse(dateString);
/*     */       } 
/* 177 */     } else if (dateString.length() == 14) {
/* 178 */       synchronized (SECOND_FORMAT) {
/* 179 */         date = SECOND_FORMAT.parse(dateString);
/*     */       } 
/* 181 */     } else if (dateString.length() == 17) {
/* 182 */       synchronized (MILLISECOND_FORMAT) {
/* 183 */         date = MILLISECOND_FORMAT.parse(dateString);
/*     */       } 
/*     */     } else {
/* 186 */       throw new ParseException(""Input is not valid date string: "" + dateString, 0);
/*     */     } 
/* 188 */     return date;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 201 */   public static Date round(Date date, Resolution resolution) { return new Date(round(date.getTime(), resolution)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long round(long time, Resolution resolution) {
/* 215 */     Calendar cal = Calendar.getInstance(GMT);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 220 */     cal.setTime(new Date(time));
/*     */     
/* 222 */     if (resolution == Resolution.YEAR) {
/* 223 */       cal.set(2, 0);
/* 224 */       cal.set(5, 1);
/* 225 */       cal.set(11, 0);
/* 226 */       cal.set(12, 0);
/* 227 */       cal.set(13, 0);
/* 228 */       cal.set(14, 0);
/* 229 */     } else if (resolution == Resolution.MONTH) {
/* 230 */       cal.set(5, 1);
/* 231 */       cal.set(11, 0);
/* 232 */       cal.set(12, 0);
/* 233 */       cal.set(13, 0);
/* 234 */       cal.set(14, 0);
/* 235 */     } else if (resolution == Resolution.DAY) {
/* 236 */       cal.set(11, 0);
/* 237 */       cal.set(12, 0);
/* 238 */       cal.set(13, 0);
/* 239 */       cal.set(14, 0);
/* 240 */     } else if (resolution == Resolution.HOUR) {
/* 241 */       cal.set(12, 0);
/* 242 */       cal.set(13, 0);
/* 243 */       cal.set(14, 0);
/* 244 */     } else if (resolution == Resolution.MINUTE) {
/* 245 */       cal.set(13, 0);
/* 246 */       cal.set(14, 0);
/* 247 */     } else if (resolution == Resolution.SECOND) {
/* 248 */       cal.set(14, 0);
/* 249 */     } else if (resolution != Resolution.MILLISECOND) {
/*     */ 
/*     */       
/* 252 */       throw new IllegalArgumentException(""unknown resolution "" + resolution);
/*     */     } 
/* 254 */     return cal.getTime().getTime();
/*     */   }
/*     */ 
/*     */   
/*     */   public static class Resolution
/*     */   {
/* 260 */     public static final Resolution YEAR = new Resolution(""year"");
/* 261 */     public static final Resolution MONTH = new Resolution(""month"");
/* 262 */     public static final Resolution DAY = new Resolution(""day"");
/* 263 */     public static final Resolution HOUR = new Resolution(""hour"");
/* 264 */     public static final Resolution MINUTE = new Resolution(""minute"");
/* 265 */     public static final Resolution SECOND = new Resolution(""second"");
/* 266 */     public static final Resolution MILLISECOND = new Resolution(""millisecond"");
/*     */     
/*     */     private String resolution;
/*     */ 
/*     */     
/*     */     private Resolution() {}
/*     */ 
/*     */     
/* 274 */     private Resolution(String resolution) { this.resolution = resolution; }
/*     */ 
/*     */ 
/*     */     
/* 278 */     public String toString() { return this.resolution; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\DateTools.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Document,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Enumeration;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Document
/*     */   implements Serializable
/*     */ {
/*  40 */   List fields = new ArrayList();
/*  41 */   private float boost = 1.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  59 */   public void setBoost(float boost) { this.boost = boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  75 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  89 */   public final void add(Fieldable field) { this.fields.add(field); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void removeField(String name) {
/* 103 */     Iterator it = this.fields.iterator();
/* 104 */     while (it.hasNext()) {
/* 105 */       Fieldable field = it.next();
/* 106 */       if (field.name().equals(name)) {
/* 107 */         it.remove();
/*     */         return;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void removeFields(String name) {
/* 123 */     Iterator it = this.fields.iterator();
/* 124 */     while (it.hasNext()) {
/* 125 */       Fieldable field = it.next();
/* 126 */       if (field.name().equals(name)) {
/* 127 */         it.remove();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Field getField(String name) {
/* 138 */     for (int i = 0; i < this.fields.size(); i++) {
/* 139 */       Field field = this.fields.get(i);
/* 140 */       if (field.name().equals(name))
/* 141 */         return field; 
/*     */     } 
/* 143 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Fieldable getFieldable(String name) {
/* 152 */     for (int i = 0; i < this.fields.size(); i++) {
/* 153 */       Fieldable field = this.fields.get(i);
/* 154 */       if (field.name().equals(name))
/* 155 */         return field; 
/*     */     } 
/* 157 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String get(String name) {
/* 166 */     for (int i = 0; i < this.fields.size(); i++) {
/* 167 */       Fieldable field = this.fields.get(i);
/* 168 */       if (field.name().equals(name) && !field.isBinary())
/* 169 */         return field.stringValue(); 
/*     */     } 
/* 171 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Enumeration fields() {
/* 178 */     return new Enumeration() {
/* 179 */         final Iterator iter = Document.this.fields.iterator();
/*     */         
/* 181 */         public boolean hasMoreElements() { return this.iter.hasNext(); }
/*     */         private final Document this$0;
/*     */         
/* 184 */         public Object nextElement() { return this.iter.next(); }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   public final List getFields() { return this.fields; }
/*     */ 
/*     */   
/* 199 */   private static final Field[] NO_FIELDS = new Field[0];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Field[] getFields(String name) {
/* 211 */     List result = new ArrayList();
/* 212 */     for (int i = 0; i < this.fields.size(); i++) {
/* 213 */       Field field = this.fields.get(i);
/* 214 */       if (field.name().equals(name)) {
/* 215 */         result.add(field);
/*     */       }
/*     */     } 
/*     */     
/* 219 */     if (result.size() == 0) {
/* 220 */       return NO_FIELDS;
/*     */     }
/* 222 */     return result.toArray(new Field[result.size()]);
/*     */   }
/*     */ 
/*     */   
/* 226 */   private static final Fieldable[] NO_FIELDABLES = new Fieldable[0];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Fieldable[] getFieldables(String name) {
/* 237 */     List result = new ArrayList();
/* 238 */     for (int i = 0; i < this.fields.size(); i++) {
/* 239 */       Fieldable field = this.fields.get(i);
/* 240 */       if (field.name().equals(name)) {
/* 241 */         result.add(field);
/*     */       }
/*     */     } 
/*     */     
/* 245 */     if (result.size() == 0) {
/* 246 */       return NO_FIELDABLES;
/*     */     }
/* 248 */     return result.toArray(new Fieldable[result.size()]);
/*     */   }
/*     */ 
/*     */   
/* 252 */   private static final String[] NO_STRINGS = new String[0];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String[] getValues(String name) {
/* 262 */     List result = new ArrayList();
/* 263 */     for (int i = 0; i < this.fields.size(); i++) {
/* 264 */       Fieldable field = this.fields.get(i);
/* 265 */       if (field.name().equals(name) && !field.isBinary()) {
/* 266 */         result.add(field.stringValue());
/*     */       }
/*     */     } 
/* 269 */     if (result.size() == 0) {
/* 270 */       return NO_STRINGS;
/*     */     }
/* 272 */     return result.toArray(new String[result.size()]);
/*     */   }
/*     */   
/* 275 */   private static final byte[][] NO_BYTES = new byte[0][];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final byte[][] getBinaryValues(String name) {
/* 287 */     List result = new ArrayList();
/* 288 */     for (int i = 0; i < this.fields.size(); i++) {
/* 289 */       Fieldable field = this.fields.get(i);
/* 290 */       if (field.name().equals(name) && field.isBinary()) {
/* 291 */         result.add(field.binaryValue());
/*     */       }
/*     */     } 
/* 294 */     if (result.size() == 0) {
/* 295 */       return NO_BYTES;
/*     */     }
/* 297 */     return result.toArray(new byte[result.size()][]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final byte[] getBinaryValue(String name) {
/* 310 */     for (int i = 0; i < this.fields.size(); i++) {
/* 311 */       Fieldable field = this.fields.get(i);
/* 312 */       if (field.name().equals(name) && field.isBinary())
/* 313 */         return field.binaryValue(); 
/*     */     } 
/* 315 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   public final String toString() {
/* 320 */     StringBuffer buffer = new StringBuffer();
/* 321 */     buffer.append(""Document<"");
/* 322 */     for (int i = 0; i < this.fields.size(); i++) {
/* 323 */       Fieldable field = this.fields.get(i);
/* 324 */       buffer.append(field.toString());
/* 325 */       if (i != this.fields.size() - 1)
/* 326 */         buffer.append("" ""); 
/*     */     } 
/* 328 */     buffer.append("">"");
/* 329 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\Document.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Field,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.io.Reader;
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.util.Parameter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Field
/*     */   extends AbstractField
/*     */   implements Fieldable, Serializable
/*     */ {
/*     */   public static final class Store
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  41 */     private Store(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  47 */     public static final Store COMPRESS = new Store(""COMPRESS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  54 */     public static final Store YES = new Store(""YES"");
/*     */ 
/*     */     
/*  57 */     public static final Store NO = new Store(""NO"");
/*     */   }
/*     */   
/*     */   public static final class Index
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  64 */     private Index(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  70 */     public static final Index NO = new Index(""NO"");
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  75 */     public static final Index ANALYZED = new Index(""ANALYZED"");
/*     */ 
/*     */     
/*  78 */     public static final Index TOKENIZED = ANALYZED;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  84 */     public static final Index NOT_ANALYZED = new Index(""NOT_ANALYZED"");
/*     */ 
/*     */     
/*  87 */     public static final Index UN_TOKENIZED = NOT_ANALYZED;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 103 */     public static final Index NOT_ANALYZED_NO_NORMS = new Index(""NOT_ANALYZED_NO_NORMS"");
/*     */ 
/*     */ 
/*     */     
/* 107 */     public static final Index NO_NORMS = NOT_ANALYZED_NO_NORMS;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 114 */     public static final Index ANALYZED_NO_NORMS = new Index(""ANALYZED_NO_NORMS"");
/*     */   }
/*     */   
/*     */   public static final class TermVector
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/* 121 */     private TermVector(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 126 */     public static final TermVector NO = new TermVector(""NO"");
/*     */ 
/*     */ 
/*     */     
/* 130 */     public static final TermVector YES = new TermVector(""YES"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 137 */     public static final TermVector WITH_POSITIONS = new TermVector(""WITH_POSITIONS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 144 */     public static final TermVector WITH_OFFSETS = new TermVector(""WITH_OFFSETS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 153 */     public static final TermVector WITH_POSITIONS_OFFSETS = new TermVector(""WITH_POSITIONS_OFFSETS"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public String stringValue() { return (this.fieldsData instanceof String) ? (String)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 165 */   public Reader readerValue() { return (this.fieldsData instanceof Reader) ? (Reader)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public byte[] binaryValue() {
/* 178 */     if (!this.isBinary)
/* 179 */       return null; 
/* 180 */     byte[] data = (byte[])this.fieldsData;
/* 181 */     if (this.binaryOffset == 0 && data.length == this.binaryLength) {
/* 182 */       return data;
/*     */     }
/* 184 */     byte[] ret = new byte[this.binaryLength];
/* 185 */     System.arraycopy(data, this.binaryOffset, ret, 0, this.binaryLength);
/* 186 */     return ret;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 192 */   public TokenStream tokenStreamValue() { return (this.fieldsData instanceof TokenStream) ? (TokenStream)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 210 */   public void setValue(String value) { this.fieldsData = value; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 215 */   public void setValue(Reader value) { this.fieldsData = value; }
/*     */ 
/*     */ 
/*     */   
/*     */   public void setValue(byte[] value) {
/* 220 */     this.fieldsData = value;
/* 221 */     this.binaryLength = value.length;
/* 222 */     this.binaryOffset = 0;
/*     */   }
/*     */ 
/*     */   
/*     */   public void setValue(byte[] value, int offset, int length) {
/* 227 */     this.fieldsData = value;
/* 228 */     this.binaryLength = length;
/* 229 */     this.binaryOffset = offset;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 235 */   public void setValue(TokenStream value) { this.fieldsData = value; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 251 */   public Field(String name, String value, Store store, Index index) { this(name, value, store, index, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, String value, Store store, Index index, TermVector termVector) {
/* 272 */     if (name == null)
/* 273 */       throw new NullPointerException(""name cannot be null""); 
/* 274 */     if (value == null)
/* 275 */       throw new NullPointerException(""value cannot be null""); 
/* 276 */     if (name.length() == 0 && value.length() == 0)
/* 277 */       throw new IllegalArgumentException(""name and value cannot both be empty""); 
/* 278 */     if (index == Index.NO && store == Store.NO) {
/* 279 */       throw new IllegalArgumentException(""it doesn't make sense to have a field that is neither indexed nor stored"");
/*     */     }
/* 281 */     if (index == Index.NO && termVector != TermVector.NO) {
/* 282 */       throw new IllegalArgumentException(""cannot store term vector information for a field that is not indexed"");
/*     */     }
/*     */     
/* 285 */     this.name = name.intern();
/* 286 */     this.fieldsData = value;
/*     */     
/* 288 */     if (store == Store.YES) {
/* 289 */       this.isStored = true;
/* 290 */       this.isCompressed = false;
/*     */     }
/* 292 */     else if (store == Store.COMPRESS) {
/* 293 */       this.isStored = true;
/* 294 */       this.isCompressed = true;
/*     */     }
/* 296 */     else if (store == Store.NO) {
/* 297 */       this.isStored = false;
/* 298 */       this.isCompressed = false;
/*     */     } else {
/*     */       
/* 301 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/* 303 */     if (index == Index.NO) {
/* 304 */       this.isIndexed = false;
/* 305 */       this.isTokenized = false;
/* 306 */     } else if (index == Index.ANALYZED) {
/* 307 */       this.isIndexed = true;
/* 308 */       this.isTokenized = true;
/* 309 */     } else if (index == Index.NOT_ANALYZED) {
/* 310 */       this.isIndexed = true;
/* 311 */       this.isTokenized = false;
/* 312 */     } else if (index == Index.NOT_ANALYZED_NO_NORMS) {
/* 313 */       this.isIndexed = true;
/* 314 */       this.isTokenized = false;
/* 315 */       this.omitNorms = true;
/* 316 */     } else if (index == Index.ANALYZED_NO_NORMS) {
/* 317 */       this.isIndexed = true;
/* 318 */       this.isTokenized = true;
/* 319 */       this.omitNorms = true;
/*     */     } else {
/* 321 */       throw new IllegalArgumentException(""unknown index parameter "" + index);
/*     */     } 
/*     */     
/* 324 */     this.isBinary = false;
/*     */     
/* 326 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 340 */   public Field(String name, Reader reader) { this(name, reader, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, Reader reader, TermVector termVector) {
/* 355 */     if (name == null)
/* 356 */       throw new NullPointerException(""name cannot be null""); 
/* 357 */     if (reader == null) {
/* 358 */       throw new NullPointerException(""reader cannot be null"");
/*     */     }
/* 360 */     this.name = name.intern();
/* 361 */     this.fieldsData = reader;
/*     */     
/* 363 */     this.isStored = false;
/* 364 */     this.isCompressed = false;
/*     */     
/* 366 */     this.isIndexed = true;
/* 367 */     this.isTokenized = true;
/*     */     
/* 369 */     this.isBinary = false;
/*     */     
/* 371 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 386 */   public Field(String name, TokenStream tokenStream) { this(name, tokenStream, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, TokenStream tokenStream, TermVector termVector) {
/* 402 */     if (name == null)
/* 403 */       throw new NullPointerException(""name cannot be null""); 
/* 404 */     if (tokenStream == null) {
/* 405 */       throw new NullPointerException(""tokenStream cannot be null"");
/*     */     }
/* 407 */     this.name = name.intern();
/* 408 */     this.fieldsData = tokenStream;
/*     */     
/* 410 */     this.isStored = false;
/* 411 */     this.isCompressed = false;
/*     */     
/* 413 */     this.isIndexed = true;
/* 414 */     this.isTokenized = true;
/*     */     
/* 416 */     this.isBinary = false;
/*     */     
/* 418 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 431 */   public Field(String name, byte[] value, Store store) { this(name, value, 0, value.length, store); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, byte[] value, int offset, int length, Store store) {
/* 446 */     if (name == null)
/* 447 */       throw new IllegalArgumentException(""name cannot be null""); 
/* 448 */     if (value == null) {
/* 449 */       throw new IllegalArgumentException(""value cannot be null"");
/*     */     }
/* 451 */     this.name = name.intern();
/* 452 */     this.fieldsData = value;
/*     */     
/* 454 */     if (store == Store.YES) {
/* 455 */       this.isStored = true;
/* 456 */       this.isCompressed = false;
/*     */     }
/* 458 */     else if (store == Store.COMPRESS) {
/* 459 */       this.isStored = true;
/* 460 */       this.isCompressed = true;
/*     */     } else {
/* 462 */       if (store == Store.NO) {
/* 463 */         throw new IllegalArgumentException(""binary values can't be unstored"");
/*     */       }
/* 465 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/* 467 */     this.isIndexed = false;
/* 468 */     this.isTokenized = false;
/*     */     
/* 470 */     this.isBinary = true;
/* 471 */     this.binaryLength = length;
/* 472 */     this.binaryOffset = offset;
/*     */     
/* 474 */     setStoreTermVector(TermVector.NO);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\Field.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Fieldable,"package org.apache.lucene.document;
import java.io.Reader;
import java.io.Serializable;
import org.apache.lucene.analysis.TokenStream;
public interface Fieldable extends Serializable {
  void setBoost(float paramFloat);
  float getBoost();
  String name();
  String stringValue();
  Reader readerValue();
  byte[] binaryValue();
  TokenStream tokenStreamValue();
  boolean isStored();
  boolean isIndexed();
  boolean isTokenized();
  boolean isCompressed();
  boolean isTermVectorStored();
  boolean isStoreOffsetWithTermVector();
  boolean isStorePositionWithTermVector();
  boolean isBinary();
  boolean getOmitNorms();
  void setOmitNorms(boolean paramBoolean);
  void setOmitTf(boolean paramBoolean);
  boolean getOmitTf();
  boolean isLazy();
  int getBinaryOffset();
  int getBinaryLength();
  byte[] getBinaryValue();
  byte[] getBinaryValue(byte[] paramArrayOfbyte);
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\Fieldable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.FieldSelector,"package org.apache.lucene.document;
import java.io.Serializable;
public interface FieldSelector extends Serializable {
  FieldSelectorResult accept(String paramString);
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\FieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.FieldSelectorResult,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class FieldSelectorResult
/*    */   implements Serializable
/*    */ {
/* 33 */   public static final transient FieldSelectorResult LOAD = new FieldSelectorResult(0);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   public static final transient FieldSelectorResult LAZY_LOAD = new FieldSelectorResult(1);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public static final transient FieldSelectorResult NO_LOAD = new FieldSelectorResult(2);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 56 */   public static final transient FieldSelectorResult LOAD_AND_BREAK = new FieldSelectorResult(3);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 63 */   public static final transient FieldSelectorResult LOAD_FOR_MERGE = new FieldSelectorResult(4);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 69 */   public static final transient FieldSelectorResult SIZE = new FieldSelectorResult(5);
/*    */ 
/*    */   
/* 72 */   public static final transient FieldSelectorResult SIZE_AND_BREAK = new FieldSelectorResult(6);
/*    */ 
/*    */   
/*    */   private int id;
/*    */ 
/*    */ 
/*    */   
/* 79 */   private FieldSelectorResult(int id) { this.id = id; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 83 */     if (this == o) return true; 
/* 84 */     if (o == null || getClass() != o.getClass()) return false;
/*    */     
/* 86 */     FieldSelectorResult that = (FieldSelectorResult)o;
/*    */     
/* 88 */     if (this.id != that.id) return false;
/*    */     
/* 90 */     return true;
/*    */   }
/*    */ 
/*    */   
/* 94 */   public int hashCode() { return this.id; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\FieldSelectorResult.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.LoadFirstFieldSelector,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LoadFirstFieldSelector
/*    */   implements FieldSelector
/*    */ {
/* 27 */   public FieldSelectorResult accept(String fieldName) { return FieldSelectorResult.LOAD_AND_BREAK; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\LoadFirstFieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.MapFieldSelector,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ import java.util.HashMap;
/*    */ import java.util.List;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class MapFieldSelector
/*    */   implements FieldSelector
/*    */ {
/*    */   Map fieldSelections;
/*    */   
/* 36 */   public MapFieldSelector(Map fieldSelections) { this.fieldSelections = fieldSelections; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public MapFieldSelector(List fields) {
/* 43 */     this.fieldSelections = new HashMap(fields.size() * 5 / 3);
/* 44 */     for (int i = 0; i < fields.size(); i++) {
/* 45 */       this.fieldSelections.put(fields.get(i), FieldSelectorResult.LOAD);
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public MapFieldSelector(String[] fields) {
/* 52 */     this.fieldSelections = new HashMap(fields.length * 5 / 3);
/* 53 */     for (int i = 0; i < fields.length; i++) {
/* 54 */       this.fieldSelections.put(fields[i], FieldSelectorResult.LOAD);
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldSelectorResult accept(String field) {
/* 62 */     FieldSelectorResult selection = (FieldSelectorResult)this.fieldSelections.get(field);
/* 63 */     return (selection != null) ? selection : FieldSelectorResult.NO_LOAD;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\MapFieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.NumberTools,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class NumberTools
/*     */ {
/*     */   private static final int RADIX = 36;
/*     */   private static final char NEGATIVE_PREFIX = '-';
/*     */   private static final char POSITIVE_PREFIX = '0';
/*     */   public static final String MIN_STRING_VALUE = ""-0000000000000"";
/*     */   public static final String MAX_STRING_VALUE = ""01y2p0ij32e8e7"";
/*  61 */   public static final int STR_SIZE = ""-0000000000000"".length();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String longToString(long l) {
/*  68 */     if (l == Long.MIN_VALUE)
/*     */     {
/*  70 */       return ""-0000000000000"";
/*     */     }
/*     */     
/*  73 */     StringBuffer buf = new StringBuffer(STR_SIZE);
/*     */     
/*  75 */     if (l < 0L) {
/*  76 */       buf.append('-');
/*  77 */       l = Long.MAX_VALUE + l + 1L;
/*     */     } else {
/*  79 */       buf.append('0');
/*     */     } 
/*  81 */     String num = Long.toString(l, 36);
/*     */     
/*  83 */     int padLen = STR_SIZE - num.length() - buf.length();
/*  84 */     while (padLen-- > 0) {
/*  85 */       buf.append('0');
/*     */     }
/*  87 */     buf.append(num);
/*     */     
/*  89 */     return buf.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long stringToLong(String str) {
/* 103 */     if (str == null) {
/* 104 */       throw new NullPointerException(""string cannot be null"");
/*     */     }
/* 106 */     if (str.length() != STR_SIZE) {
/* 107 */       throw new NumberFormatException(""string is the wrong size"");
/*     */     }
/*     */     
/* 110 */     if (str.equals(""-0000000000000"")) {
/* 111 */       return Long.MIN_VALUE;
/*     */     }
/*     */     
/* 114 */     char prefix = str.charAt(0);
/* 115 */     long l = Long.parseLong(str.substring(1), 36);
/*     */     
/* 117 */     if (prefix != '0')
/*     */     {
/* 119 */       if (prefix == '-') {
/* 120 */         l = l - Long.MAX_VALUE - 1L;
/*     */       } else {
/* 122 */         throw new NumberFormatException(""string does not begin with the correct prefix"");
/*     */       } 
/*     */     }
/*     */     
/* 126 */     return l;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\NumberTools.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.SetBasedFieldSelector,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ import java.util.Set;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SetBasedFieldSelector
/*    */   implements FieldSelector
/*    */ {
/*    */   private Set fieldsToLoad;
/*    */   private Set lazyFieldsToLoad;
/*    */   
/*    */   public SetBasedFieldSelector(Set fieldsToLoad, Set lazyFieldsToLoad) {
/* 38 */     this.fieldsToLoad = fieldsToLoad;
/* 39 */     this.lazyFieldsToLoad = lazyFieldsToLoad;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldSelectorResult accept(String fieldName) {
/* 51 */     FieldSelectorResult result = FieldSelectorResult.NO_LOAD;
/* 52 */     if (this.fieldsToLoad.contains(fieldName) == true) {
/* 53 */       result = FieldSelectorResult.LOAD;
/*    */     }
/* 55 */     if (this.lazyFieldsToLoad.contains(fieldName) == true) {
/* 56 */       result = FieldSelectorResult.LAZY_LOAD;
/*    */     }
/* 58 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\document\SetBasedFieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.BufferedDeletes,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class BufferedDeletes
/*     */ {
/*     */   int numTerms;
/*  35 */   HashMap terms = new HashMap();
/*  36 */   HashMap queries = new HashMap();
/*  37 */   List docIDs = new ArrayList();
/*     */ 
/*     */   
/*     */   static final class Num
/*     */   {
/*     */     private int num;
/*     */     
/*  44 */     Num(int num) { this.num = num; }
/*     */ 
/*     */ 
/*     */     
/*  48 */     int getNum() { return this.num; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     void setNum(int num) {
/*  58 */       if (num > this.num) {
/*  59 */         this.num = num;
/*     */       }
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   void update(BufferedDeletes in) {
/*  66 */     this.numTerms += in.numTerms;
/*  67 */     this.terms.putAll(in.terms);
/*  68 */     this.queries.putAll(in.queries);
/*  69 */     this.docIDs.addAll(in.docIDs);
/*  70 */     in.terms.clear();
/*  71 */     in.numTerms = 0;
/*  72 */     in.queries.clear();
/*  73 */     in.docIDs.clear();
/*     */   }
/*     */   
/*     */   void clear() {
/*  77 */     this.terms.clear();
/*  78 */     this.queries.clear();
/*  79 */     this.docIDs.clear();
/*  80 */     this.numTerms = 0;
/*     */   }
/*     */ 
/*     */   
/*  84 */   boolean any() { return (this.terms.size() > 0 || this.docIDs.size() > 0 || this.queries.size() > 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   synchronized void remap(MergeDocIDRemapper mapper, SegmentInfos infos, int[][] docMaps, int[] delCounts, MergePolicy.OneMerge merge, int mergeDocCount) {
/*     */     Object newDeleteQueries;
/*     */     Object newDeleteDocIDs;
/*     */     HashMap newDeleteTerms;
/*  99 */     if (this.terms.size() > 0) {
/* 100 */       newDeleteTerms = new HashMap();
/* 101 */       newDeleteDocIDs = this.terms.entrySet().iterator();
/* 102 */       while (newDeleteDocIDs.hasNext()) {
/* 103 */         newDeleteQueries = newDeleteDocIDs.next();
/* 104 */         Num num = (Num)newDeleteQueries.getValue();
/* 105 */         newDeleteTerms.put(newDeleteQueries.getKey(), new Num(mapper.remap(num.getNum())));
/*     */       } 
/*     */     } else {
/*     */       
/* 109 */       newDeleteTerms = null;
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 114 */     if (this.docIDs.size() > 0) {
/* 115 */       newDeleteDocIDs = new ArrayList(this.docIDs.size());
/* 116 */       newDeleteQueries = this.docIDs.iterator();
/* 117 */       while (newDeleteQueries.hasNext()) {
/* 118 */         Integer num = newDeleteQueries.next();
/* 119 */         newDeleteDocIDs.add(new Integer(mapper.remap(num.intValue())));
/*     */       } 
/*     */     } else {
/* 122 */       newDeleteDocIDs = null;
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 127 */     if (this.queries.size() > 0) {
/* 128 */       newDeleteQueries = new HashMap(this.queries.size());
/* 129 */       Iterator iter = this.queries.entrySet().iterator();
/* 130 */       while (iter.hasNext()) {
/* 131 */         Map.Entry entry = iter.next();
/* 132 */         Integer num = (Integer)entry.getValue();
/* 133 */         newDeleteQueries.put(entry.getKey(), new Integer(mapper.remap(num.intValue())));
/*     */       } 
/*     */     } else {
/*     */       
/* 137 */       newDeleteQueries = null;
/*     */     } 
/* 139 */     if (newDeleteTerms != null)
/* 140 */       this.terms = newDeleteTerms; 
/* 141 */     if (newDeleteDocIDs != null)
/* 142 */       this.docIDs = (List)newDeleteDocIDs; 
/* 143 */     if (newDeleteQueries != null)
/* 144 */       this.queries = (HashMap)newDeleteQueries; 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\BufferedDeletes.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ByteBlockPool,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.util.Arrays;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class ByteBlockPool
/*     */ {
/*     */   static abstract class Allocator
/*     */   {
/*     */     abstract void recycleByteBlocks(byte[][] param1ArrayOfbyte, int param1Int1, int param1Int2);
/*     */     
/*     */     abstract byte[] getByteBlock(boolean param1Boolean);
/*     */   }
/*     */   
/*  45 */   public byte[][] buffers = new byte[10][];
/*     */   
/*  47 */   int bufferUpto = -1;
/*  48 */   public int byteUpto = 32768;
/*     */   
/*     */   public byte[] buffer;
/*  51 */   public int byteOffset = -32768;
/*     */   
/*     */   private final boolean trackAllocations;
/*     */   private final Allocator allocator;
/*     */   
/*     */   public ByteBlockPool(Allocator allocator, boolean trackAllocations) {
/*  57 */     this.allocator = allocator;
/*  58 */     this.trackAllocations = trackAllocations;
/*     */   }
/*     */   
/*     */   public void reset() {
/*  62 */     if (this.bufferUpto != -1) {
/*     */ 
/*     */       
/*  65 */       for (int i = 0; i < this.bufferUpto; i++)
/*     */       {
/*  67 */         Arrays.fill(this.buffers[i], (byte)0);
/*     */       }
/*     */       
/*  70 */       Arrays.fill(this.buffers[this.bufferUpto], 0, this.byteUpto, (byte)0);
/*     */       
/*  72 */       if (this.bufferUpto > 0)
/*     */       {
/*  74 */         this.allocator.recycleByteBlocks(this.buffers, 1, 1 + this.bufferUpto);
/*     */       }
/*     */       
/*  77 */       this.bufferUpto = 0;
/*  78 */       this.byteUpto = 0;
/*  79 */       this.byteOffset = 0;
/*  80 */       this.buffer = this.buffers[0];
/*     */     } 
/*     */   }
/*     */   
/*     */   public void nextBuffer() {
/*  85 */     if (1 + this.bufferUpto == this.buffers.length) {
/*  86 */       byte[][] newBuffers = new byte[(int)(this.buffers.length * 1.5D)][];
/*  87 */       System.arraycopy(this.buffers, 0, newBuffers, 0, this.buffers.length);
/*  88 */       this.buffers = newBuffers;
/*     */     } 
/*  90 */     this.buffer = this.buffers[1 + this.bufferUpto] = this.allocator.getByteBlock(this.trackAllocations);
/*  91 */     this.bufferUpto++;
/*     */     
/*  93 */     this.byteUpto = 0;
/*  94 */     this.byteOffset += 32768;
/*     */   }
/*     */   
/*     */   public int newSlice(int size) {
/*  98 */     if (this.byteUpto > 32768 - size)
/*  99 */       nextBuffer(); 
/* 100 */     int upto = this.byteUpto;
/* 101 */     this.byteUpto += size;
/* 102 */     this.buffer[this.byteUpto - 1] = 16;
/* 103 */     return upto;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 111 */   static final int[] nextLevelArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 };
/* 112 */   static final int[] levelSizeArray = new int[] { 5, 14, 20, 30, 40, 40, 80, 80, 120, 200 };
/* 113 */   static final int FIRST_LEVEL_SIZE = levelSizeArray[0];
/*     */ 
/*     */   
/*     */   public int allocSlice(byte[] slice, int upto) {
/* 117 */     int level = slice[upto] & 0xF;
/* 118 */     int newLevel = nextLevelArray[level];
/* 119 */     int newSize = levelSizeArray[newLevel];
/*     */ 
/*     */     
/* 122 */     if (this.byteUpto > 32768 - newSize) {
/* 123 */       nextBuffer();
/*     */     }
/* 125 */     int newUpto = this.byteUpto;
/* 126 */     int offset = newUpto + this.byteOffset;
/* 127 */     this.byteUpto += newSize;
/*     */ 
/*     */ 
/*     */     
/* 131 */     this.buffer[newUpto] = slice[upto - 3];
/* 132 */     this.buffer[newUpto + 1] = slice[upto - 2];
/* 133 */     this.buffer[newUpto + 2] = slice[upto - 1];
/*     */ 
/*     */     
/* 136 */     slice[upto - 3] = (byte)(offset >>> 24);
/* 137 */     slice[upto - 2] = (byte)(offset >>> 16);
/* 138 */     slice[upto - 1] = (byte)(offset >>> 8);
/* 139 */     slice[upto] = (byte)offset;
/*     */ 
/*     */     
/* 142 */     this.buffer[this.byteUpto - 1] = (byte)(0x10 | newLevel);
/*     */     
/* 144 */     return newUpto + 3;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ByteBlockPool.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ByteSliceReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class ByteSliceReader
/*     */   extends IndexInput
/*     */ {
/*     */   ByteBlockPool pool;
/*     */   int bufferUpto;
/*     */   byte[] buffer;
/*     */   public int upto;
/*     */   int limit;
/*     */   int level;
/*     */   public int bufferOffset;
/*     */   public int endIndex;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public void init(ByteBlockPool pool, int startIndex, int endIndex) {
/*  42 */     assert endIndex - startIndex >= 0;
/*  43 */     assert startIndex >= 0;
/*  44 */     assert endIndex >= 0;
/*     */     
/*  46 */     this.pool = pool;
/*  47 */     this.endIndex = endIndex;
/*     */     
/*  49 */     this.level = 0;
/*  50 */     this.bufferUpto = startIndex / 32768;
/*  51 */     this.bufferOffset = this.bufferUpto * 32768;
/*  52 */     this.buffer = pool.buffers[this.bufferUpto];
/*  53 */     this.upto = startIndex & 0x7FFF;
/*     */     
/*  55 */     int firstSize = ByteBlockPool.levelSizeArray[0];
/*     */     
/*  57 */     if (startIndex + firstSize >= endIndex) {
/*     */       
/*  59 */       this.limit = endIndex & 0x7FFF;
/*     */     } else {
/*  61 */       this.limit = this.upto + firstSize - 4;
/*     */     } 
/*     */   }
/*     */   public boolean eof() {
/*  65 */     assert this.upto + this.bufferOffset <= this.endIndex;
/*  66 */     return (this.upto + this.bufferOffset == this.endIndex);
/*     */   }
/*     */   
/*     */   public byte readByte() {
/*  70 */     assert !eof();
/*  71 */     assert this.upto <= this.limit;
/*  72 */     if (this.upto == this.limit)
/*  73 */       nextSlice(); 
/*  74 */     return this.buffer[this.upto++];
/*     */   }
/*     */   
/*     */   public long writeTo(IndexOutput out) throws IOException {
/*  78 */     long size = 0L;
/*     */     while (true) {
/*  80 */       if (this.limit + this.bufferOffset == this.endIndex) {
/*  81 */         assert this.endIndex - this.bufferOffset >= this.upto;
/*  82 */         out.writeBytes(this.buffer, this.upto, this.limit - this.upto);
/*  83 */         size += (this.limit - this.upto);
/*     */         break;
/*     */       } 
/*  86 */       out.writeBytes(this.buffer, this.upto, this.limit - this.upto);
/*  87 */       size += (this.limit - this.upto);
/*  88 */       nextSlice();
/*     */     } 
/*     */ 
/*     */     
/*  92 */     return size;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void nextSlice() {
/*  98 */     int nextIndex = ((this.buffer[this.limit] & 0xFF) << 24) + ((this.buffer[1 + this.limit] & 0xFF) << 16) + ((this.buffer[2 + this.limit] & 0xFF) << 8) + (this.buffer[3 + this.limit] & 0xFF);
/*     */     
/* 100 */     this.level = ByteBlockPool.nextLevelArray[this.level];
/* 101 */     int newSize = ByteBlockPool.levelSizeArray[this.level];
/*     */     
/* 103 */     this.bufferUpto = nextIndex / 32768;
/* 104 */     this.bufferOffset = this.bufferUpto * 32768;
/*     */     
/* 106 */     this.buffer = this.pool.buffers[this.bufferUpto];
/* 107 */     this.upto = nextIndex & 0x7FFF;
/*     */     
/* 109 */     if (nextIndex + newSize >= this.endIndex) {
/*     */       
/* 111 */       assert this.endIndex - nextIndex > 0;
/* 112 */       this.limit = this.endIndex - this.bufferOffset;
/*     */     }
/*     */     else {
/*     */       
/* 116 */       this.limit = this.upto + newSize - 4;
/*     */     } 
/*     */   }
/*     */   
/*     */   public void readBytes(byte[] b, int offset, int len) {
/* 121 */     while (len > 0) {
/* 122 */       int numLeft = this.limit - this.upto;
/* 123 */       if (numLeft < len) {
/*     */         
/* 125 */         System.arraycopy(this.buffer, this.upto, b, offset, numLeft);
/* 126 */         offset += numLeft;
/* 127 */         len -= numLeft;
/* 128 */         nextSlice();
/*     */         continue;
/*     */       } 
/* 131 */       System.arraycopy(this.buffer, this.upto, b, offset, len);
/* 132 */       this.upto += len;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 138 */   public long getFilePointer() { throw new RuntimeException(""not implemented""); }
/* 139 */   public long length() { throw new RuntimeException(""not implemented""); }
/* 140 */   public void seek(long pos) { throw new RuntimeException(""not implemented""); }
/* 141 */   public void close() { throw new RuntimeException(""not implemented""); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ByteSliceReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ByteSliceWriter,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class ByteSliceWriter
/*    */ {
/*    */   private byte[] slice;
/*    */   private int upto;
/*    */   private final ByteBlockPool pool;
/*    */   int offset0;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/* 36 */   public ByteSliceWriter(ByteBlockPool pool) { this.pool = pool; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void init(int address) {
/* 43 */     this.slice = this.pool.buffers[address >> 15];
/* 44 */     assert this.slice != null;
/* 45 */     this.upto = address & 0x7FFF;
/* 46 */     this.offset0 = address;
/* 47 */     assert this.upto < this.slice.length;
/*    */   }
/*    */ 
/*    */   
/*    */   public void writeByte(byte b) {
/* 52 */     assert this.slice != null;
/* 53 */     if (this.slice[this.upto] != 0) {
/* 54 */       this.upto = this.pool.allocSlice(this.slice, this.upto);
/* 55 */       this.slice = this.pool.buffer;
/* 56 */       this.offset0 = this.pool.byteOffset;
/* 57 */       assert this.slice != null;
/*    */     } 
/* 59 */     this.slice[this.upto++] = b;
/* 60 */     assert this.upto != this.slice.length;
/*    */   }
/*    */   
/*    */   public void writeBytes(byte[] b, int offset, int len) {
/* 64 */     int offsetEnd = offset + len;
/* 65 */     while (offset < offsetEnd) {
/* 66 */       if (this.slice[this.upto] != 0) {
/*    */         
/* 68 */         this.upto = this.pool.allocSlice(this.slice, this.upto);
/* 69 */         this.slice = this.pool.buffer;
/* 70 */         this.offset0 = this.pool.byteOffset;
/*    */       } 
/*    */       
/* 73 */       this.slice[this.upto++] = b[offset++];
/* 74 */       assert this.upto != this.slice.length;
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 79 */   public int getAddress() { return this.upto + (this.offset0 & 0xFFFF8000); }
/*    */ 
/*    */   
/*    */   public void writeVInt(int i) {
/* 83 */     while ((i & 0xFFFFFF80) != 0) {
/* 84 */       writeByte((byte)(i & 0x7F | 0x80));
/* 85 */       i >>>= 7;
/*    */     } 
/* 87 */     writeByte((byte)i);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ByteSliceWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CharBlockPool,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class CharBlockPool
/*    */ {
/* 22 */   public char[][] buffers = new char[10][];
/*    */   
/*    */   int numBuffer;
/* 25 */   int bufferUpto = -1;
/* 26 */   public int charUpto = 16384;
/*    */   
/*    */   public char[] buffer;
/* 29 */   public int charOffset = -16384;
/*    */   
/*    */   private final DocumentsWriter docWriter;
/*    */   
/* 33 */   public CharBlockPool(DocumentsWriter docWriter) { this.docWriter = docWriter; }
/*    */ 
/*    */   
/*    */   public void reset() {
/* 37 */     this.docWriter.recycleCharBlocks(this.buffers, 1 + this.bufferUpto);
/* 38 */     this.bufferUpto = -1;
/* 39 */     this.charUpto = 16384;
/* 40 */     this.charOffset = -16384;
/*    */   }
/*    */   
/*    */   public void nextBuffer() {
/* 44 */     if (1 + this.bufferUpto == this.buffers.length) {
/* 45 */       char[][] newBuffers = new char[(int)(this.buffers.length * 1.5D)][];
/* 46 */       System.arraycopy(this.buffers, 0, newBuffers, 0, this.buffers.length);
/* 47 */       this.buffers = newBuffers;
/*    */     } 
/* 49 */     this.buffer = this.buffers[1 + this.bufferUpto] = this.docWriter.getCharBlock();
/* 50 */     this.bufferUpto++;
/*    */     
/* 52 */     this.charUpto = 0;
/* 53 */     this.charOffset += 16384;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\CharBlockPool.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CheckIndex,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.text.NumberFormat;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.FSDirectory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class CheckIndex
/*     */ {
/*  52 */   public static PrintStream out = null;
/*     */ 
/*     */   
/*     */   private PrintStream infoStream;
/*     */ 
/*     */   
/*     */   private Directory dir;
/*     */ 
/*     */   
/*     */   private static boolean assertsOn;
/*     */ 
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */ 
/*     */ 
/*     */   
/*     */   public static class Status
/*     */   {
/*     */     public boolean clean;
/*     */ 
/*     */     
/*     */     public boolean missingSegments;
/*     */ 
/*     */     
/*     */     public boolean cantOpenSegments;
/*     */ 
/*     */     
/*     */     public boolean missingSegmentVersion;
/*     */ 
/*     */     
/*     */     public String segmentsFileName;
/*     */ 
/*     */     
/*     */     public int numSegments;
/*     */     
/*     */     public String segmentFormat;
/*     */     
/*  89 */     public List segmentsChecked = new ArrayList();
/*     */ 
/*     */     
/*     */     public boolean toolOutOfDate;
/*     */ 
/*     */     
/*  95 */     public List segmentInfos = new ArrayList();
/*     */ 
/*     */     
/*     */     public Directory dir;
/*     */ 
/*     */     
/*     */     SegmentInfos newSegments;
/*     */ 
/*     */     
/*     */     public int totLoseDocCount;
/*     */ 
/*     */     
/*     */     public int numBadSegments;
/*     */ 
/*     */     
/*     */     public boolean partial;
/*     */ 
/*     */ 
/*     */     
/*     */     public static class SegmentInfoStatus
/*     */     {
/*     */       public String name;
/*     */       
/*     */       public int docCount;
/*     */       
/*     */       public boolean compound;
/*     */       
/*     */       public int numFiles;
/*     */       
/*     */       public double sizeMB;
/*     */       
/*     */       public String docStoreSegment;
/*     */       
/*     */       public boolean docStoreCompoundFile;
/*     */       
/*     */       public boolean hasDeletions;
/*     */       
/*     */       public String deletionsFileName;
/*     */       
/*     */       public int numDeleted;
/*     */       
/*     */       public boolean openReaderPassed;
/*     */       
/*     */       int numFields;
/*     */       
/*     */       public boolean hasProx;
/*     */       
/* 142 */       public int docStoreOffset = -1; } } public static class SegmentInfoStatus { public int docStoreOffset = -1;
/*     */ 
/*     */     
/*     */     public String name;
/*     */ 
/*     */     
/*     */     public int docCount;
/*     */ 
/*     */     
/*     */     public boolean compound;
/*     */ 
/*     */     
/*     */     public int numFiles;
/*     */     
/*     */     public double sizeMB;
/*     */     
/*     */     public String docStoreSegment;
/*     */     
/*     */     public boolean docStoreCompoundFile;
/*     */     
/*     */     public boolean hasDeletions;
/*     */     
/*     */     public String deletionsFileName;
/*     */     
/*     */     public int numDeleted;
/*     */     
/*     */     public boolean openReaderPassed;
/*     */     
/*     */     int numFields;
/*     */     
/*     */     public boolean hasProx; }
/*     */ 
/*     */ 
/*     */   
/*     */   public CheckIndex(Directory dir) {
/* 177 */     this.dir = dir;
/* 178 */     this.infoStream = out;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 184 */   public void setInfoStream(PrintStream out) { this.infoStream = out; }
/*     */ 
/*     */   
/*     */   private void msg(String msg) {
/* 188 */     if (this.infoStream != null)
/* 189 */       this.infoStream.println(msg); 
/*     */   }
/*     */   
/*     */   private static class MySegmentTermDocs
/*     */     extends SegmentTermDocs
/*     */   {
/*     */     int delCount;
/*     */     
/* 197 */     MySegmentTermDocs(SegmentReader p) { super(p); }
/*     */ 
/*     */     
/*     */     public void seek(Term term) throws IOException {
/* 201 */       super.seek(term);
/* 202 */       this.delCount = 0;
/*     */     }
/*     */ 
/*     */     
/* 206 */     protected void skippingDoc() throws IOException { this.delCount++; }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 213 */   public static boolean check(Directory dir, boolean doFix) throws IOException { return check(dir, doFix, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static boolean check(Directory dir, boolean doFix, List onlySegments) throws IOException {
/* 219 */     CheckIndex checker = new CheckIndex(dir);
/* 220 */     Status status = checker.checkIndex(onlySegments);
/* 221 */     if (doFix && !status.clean) {
/* 222 */       checker.fixIndex(status);
/*     */     }
/* 224 */     return status.clean;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 237 */   public Status checkIndex() throws IOException { return checkIndex(null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Status checkIndex(List onlySegments) throws IOException {
/* 253 */     NumberFormat nf = NumberFormat.getInstance();
/* 254 */     SegmentInfos sis = new SegmentInfos();
/* 255 */     Status result = new Status();
/* 256 */     result.dir = this.dir;
/*     */     try {
/* 258 */       sis.read(this.dir);
/* 259 */     } catch (Throwable t) {
/* 260 */       msg(""ERROR: could not read any segments file in directory"");
/* 261 */       result.missingSegments = true;
/* 262 */       if (this.infoStream != null)
/* 263 */         t.printStackTrace(this.infoStream); 
/* 264 */       return result;
/*     */     } 
/*     */     
/* 267 */     int numSegments = sis.size();
/* 268 */     String segmentsFileName = sis.getCurrentSegmentFileName();
/* 269 */     IndexInput input = null;
/*     */     try {
/* 271 */       input = this.dir.openInput(segmentsFileName);
/* 272 */     } catch (Throwable t) {
/* 273 */       msg(""ERROR: could not open segments file in directory"");
/* 274 */       if (this.infoStream != null)
/* 275 */         t.printStackTrace(this.infoStream); 
/* 276 */       result.cantOpenSegments = true;
/* 277 */       return result;
/*     */     } 
/* 279 */     int format = 0;
/*     */     try {
/* 281 */       format = input.readInt();
/* 282 */     } catch (Throwable t) {
/* 283 */       msg(""ERROR: could not read segment file version in directory"");
/* 284 */       if (this.infoStream != null)
/* 285 */         t.printStackTrace(this.infoStream); 
/* 286 */       result.missingSegmentVersion = true;
/* 287 */       return result;
/*     */     } finally {
/* 289 */       if (input != null) {
/* 290 */         input.close();
/*     */       }
/*     */     } 
/* 293 */     String sFormat = """";
/* 294 */     boolean skip = false;
/*     */     
/* 296 */     if (format == -1)
/* 297 */       sFormat = ""FORMAT [Lucene Pre-2.1]""; 
/* 298 */     if (format == -2) {
/* 299 */       sFormat = ""FORMAT_LOCKLESS [Lucene 2.1]"";
/* 300 */     } else if (format == -3) {
/* 301 */       sFormat = ""FORMAT_SINGLE_NORM_FILE [Lucene 2.2]"";
/* 302 */     } else if (format == -4) {
/* 303 */       sFormat = ""FORMAT_SHARED_DOC_STORE [Lucene 2.3]"";
/*     */     }
/* 305 */     else if (format == -5) {
/* 306 */       sFormat = ""FORMAT_CHECKSUM [Lucene 2.4]"";
/* 307 */     } else if (format == -6) {
/* 308 */       sFormat = ""FORMAT_DEL_COUNT [Lucene 2.4]"";
/* 309 */     } else if (format == -7) {
/* 310 */       sFormat = ""FORMAT_HAS_PROX [Lucene 2.4]"";
/* 311 */     } else if (format < -7) {
/* 312 */       sFormat = ""int="" + format + "" [newer version of Lucene than this tool]"";
/* 313 */       skip = true;
/*     */     } else {
/* 315 */       sFormat = format + "" [Lucene 1.3 or prior]"";
/*     */     } 
/*     */ 
/*     */     
/* 319 */     msg(""Segments file="" + segmentsFileName + "" numSegments="" + numSegments + "" version="" + sFormat);
/* 320 */     result.segmentsFileName = segmentsFileName;
/* 321 */     result.numSegments = numSegments;
/* 322 */     result.segmentFormat = sFormat;
/*     */     
/* 324 */     if (onlySegments != null) {
/* 325 */       result.partial = true;
/* 326 */       if (this.infoStream != null)
/* 327 */         this.infoStream.print(""\nChecking only these segments:""); 
/* 328 */       Iterator it = onlySegments.iterator();
/* 329 */       while (it.hasNext()) {
/* 330 */         if (this.infoStream != null)
/* 331 */           this.infoStream.print("" "" + it.next()); 
/*     */       } 
/* 333 */       result.segmentsChecked.addAll(onlySegments);
/* 334 */       msg("":"");
/*     */     } 
/*     */     
/* 337 */     if (skip) {
/* 338 */       msg(""\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting"");
/* 339 */       result.toolOutOfDate = true;
/* 340 */       return result;
/*     */     } 
/*     */ 
/*     */     
/* 344 */     result.newSegments = (SegmentInfos)sis.clone();
/* 345 */     result.newSegments.clear();
/*     */     
/* 347 */     for (int i = 0; i < numSegments; i++) {
/* 348 */       SegmentInfo info = sis.info(i);
/* 349 */       if (onlySegments == null || onlySegments.contains(info.name)) {
/*     */         
/* 351 */         Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();
/* 352 */         result.segmentInfos.add(segInfoStat);
/* 353 */         msg(""  "" + (1 + i) + "" of "" + numSegments + "": name="" + info.name + "" docCount="" + info.docCount);
/* 354 */         segInfoStat.name = info.name;
/* 355 */         segInfoStat.docCount = info.docCount;
/*     */         
/* 357 */         int toLoseDocCount = info.docCount;
/*     */         
/* 359 */         SegmentReader reader = null;
/*     */         
/*     */         try {
/* 362 */           msg(""    compound="" + info.getUseCompoundFile());
/* 363 */           segInfoStat.compound = info.getUseCompoundFile();
/* 364 */           msg(""    hasProx="" + info.getHasProx());
/* 365 */           segInfoStat.hasProx = info.getHasProx();
/* 366 */           msg(""    numFiles="" + info.files().size());
/* 367 */           segInfoStat.numFiles = info.files().size();
/* 368 */           msg(""    size (MB)="" + nf.format(info.sizeInBytes() / 1048576.0D));
/* 369 */           segInfoStat.sizeMB = info.sizeInBytes() / 1048576.0D;
/*     */ 
/*     */           
/* 372 */           int docStoreOffset = info.getDocStoreOffset();
/* 373 */           if (docStoreOffset != -1) {
/* 374 */             msg(""    docStoreOffset="" + docStoreOffset);
/* 375 */             segInfoStat.docStoreOffset = docStoreOffset;
/* 376 */             msg(""    docStoreSegment="" + info.getDocStoreSegment());
/* 377 */             segInfoStat.docStoreSegment = info.getDocStoreSegment();
/* 378 */             msg(""    docStoreIsCompoundFile="" + info.getDocStoreIsCompoundFile());
/* 379 */             segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();
/*     */           } 
/* 381 */           String delFileName = info.getDelFileName();
/* 382 */           if (delFileName == null) {
/* 383 */             msg(""    no deletions"");
/* 384 */             segInfoStat.hasDeletions = false;
/*     */           } else {
/*     */             
/* 387 */             msg(""    has deletions [delFileName="" + delFileName + ""]"");
/* 388 */             segInfoStat.hasDeletions = true;
/* 389 */             segInfoStat.deletionsFileName = delFileName;
/*     */           } 
/* 391 */           if (this.infoStream != null)
/* 392 */             this.infoStream.print(""    test: open reader.........""); 
/* 393 */           reader = SegmentReader.get(info);
/* 394 */           int numDocs = reader.numDocs();
/* 395 */           toLoseDocCount = numDocs;
/* 396 */           if (reader.hasDeletions()) {
/* 397 */             if (info.docCount - numDocs != info.getDelCount()) {
/* 398 */               throw new RuntimeException(""delete count mismatch: info="" + info.getDelCount() + "" vs reader="" + (info.docCount - numDocs));
/*     */             }
/* 400 */             segInfoStat.numDeleted = info.docCount - numDocs;
/* 401 */             msg(""OK ["" + segInfoStat.numDeleted + "" deleted docs]"");
/*     */           } else {
/* 403 */             if (info.getDelCount() != 0) {
/* 404 */               throw new RuntimeException(""delete count mismatch: info="" + info.getDelCount() + "" vs reader="" + (info.docCount - numDocs));
/*     */             }
/* 406 */             msg(""OK"");
/*     */           } 
/*     */           
/* 409 */           if (this.infoStream != null)
/* 410 */             this.infoStream.print(""    test: fields, norms.......""); 
/* 411 */           Collection fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
/* 412 */           Iterator it = fieldNames.iterator();
/* 413 */           while (it.hasNext()) {
/* 414 */             String fieldName = it.next();
/* 415 */             byte[] b = reader.norms(fieldName);
/* 416 */             if (b.length != info.docCount) {
/* 417 */               throw new RuntimeException(""norms for field \"""" + fieldName + ""\"" is length "" + b.length + "" != maxDoc "" + info.docCount);
/*     */             }
/*     */           } 
/* 420 */           msg(""OK ["" + fieldNames.size() + "" fields]"");
/* 421 */           segInfoStat.numFields = fieldNames.size();
/* 422 */           if (this.infoStream != null)
/* 423 */             this.infoStream.print(""    test: terms, freq, prox...""); 
/* 424 */           TermEnum termEnum = reader.terms();
/* 425 */           TermPositions termPositions = reader.termPositions();
/*     */ 
/*     */ 
/*     */           
/* 429 */           MySegmentTermDocs myTermDocs = new MySegmentTermDocs(reader);
/*     */           
/* 431 */           long termCount = 0L;
/* 432 */           long totFreq = 0L;
/* 433 */           long totPos = 0L;
/* 434 */           while (termEnum.next()) {
/* 435 */             int delCount; termCount++;
/* 436 */             Term term = termEnum.term();
/* 437 */             int docFreq = termEnum.docFreq();
/* 438 */             termPositions.seek(term);
/* 439 */             int lastDoc = -1;
/* 440 */             int freq0 = 0;
/* 441 */             totFreq += docFreq;
/* 442 */             while (termPositions.next()) {
/* 443 */               freq0++;
/* 444 */               delCount = termPositions.doc();
/* 445 */               int freq = termPositions.freq();
/* 446 */               if (delCount <= lastDoc)
/* 447 */                 throw new RuntimeException(""term "" + term + "": doc "" + delCount + "" <= lastDoc "" + lastDoc); 
/* 448 */               lastDoc = delCount;
/* 449 */               if (freq <= 0) {
/* 450 */                 throw new RuntimeException(""term "" + term + "": doc "" + delCount + "": freq "" + freq + "" is out of bounds"");
/*     */               }
/* 452 */               int lastPos = -1;
/* 453 */               totPos += freq;
/* 454 */               for (int j = 0; j < freq; j++) {
/* 455 */                 int pos = termPositions.nextPosition();
/* 456 */                 if (pos < -1)
/* 457 */                   throw new RuntimeException(""term "" + term + "": doc "" + delCount + "": pos "" + pos + "" is out of bounds""); 
/* 458 */                 if (pos < lastPos) {
/* 459 */                   throw new RuntimeException(""term "" + term + "": doc "" + delCount + "": pos "" + pos + "" < lastPos "" + lastPos);
/*     */                 }
/*     */               } 
/*     */             } 
/*     */ 
/*     */ 
/*     */             
/* 466 */             if (reader.hasDeletions()) {
/* 467 */               myTermDocs.seek(term);
/* 468 */               while (myTermDocs.next());
/*     */               
/* 470 */               delCount = myTermDocs.delCount;
/*     */             } else {
/* 472 */               delCount = 0;
/*     */             } 
/* 474 */             if (freq0 + delCount != docFreq) {
/* 475 */               throw new RuntimeException(""term "" + term + "" docFreq="" + docFreq + "" != num docs seen "" + freq0 + "" + num docs deleted "" + delCount);
/*     */             }
/*     */           } 
/* 478 */           msg(""OK ["" + termCount + "" terms; "" + totFreq + "" terms/docs pairs; "" + totPos + "" tokens]"");
/*     */           
/* 480 */           if (this.infoStream != null)
/* 481 */             this.infoStream.print(""    test: stored fields.......""); 
/* 482 */           int docCount = 0;
/* 483 */           long totFields = 0L;
/* 484 */           for (int j = 0; j < info.docCount; j++) {
/* 485 */             if (!reader.isDeleted(j)) {
/* 486 */               docCount++;
/* 487 */               Document doc = reader.document(j);
/* 488 */               totFields += doc.getFields().size();
/*     */             } 
/*     */           } 
/* 491 */           if (docCount != reader.numDocs()) {
/* 492 */             throw new RuntimeException(""docCount="" + docCount + "" but saw "" + docCount + "" undeleted docs"");
/*     */           }
/* 494 */           msg(""OK ["" + totFields + "" total field count; avg "" + nf.format(((float)totFields / docCount)) + "" fields per doc]"");
/*     */           
/* 496 */           if (this.infoStream != null)
/* 497 */             this.infoStream.print(""    test: term vectors........""); 
/* 498 */           int totVectors = 0;
/* 499 */           for (int j = 0; j < info.docCount; j++) {
/* 500 */             if (!reader.isDeleted(j)) {
/* 501 */               TermFreqVector[] tfv = reader.getTermFreqVectors(j);
/* 502 */               if (tfv != null)
/* 503 */                 totVectors += tfv.length; 
/*     */             } 
/*     */           } 
/* 506 */           msg(""OK ["" + totVectors + "" total vector count; avg "" + nf.format((totVectors / docCount)) + "" term/freq vector fields per doc]"");
/* 507 */           msg("""");
/*     */         }
/* 509 */         catch (Throwable t) {
/* 510 */           msg(""FAILED"");
/*     */           
/* 512 */           String comment = ""fixIndex() would remove reference to this segment"";
/* 513 */           msg(""    WARNING: "" + comment + ""; full exception:"");
/* 514 */           if (this.infoStream != null)
/* 515 */             t.printStackTrace(this.infoStream); 
/* 516 */           msg("""");
/* 517 */           result.totLoseDocCount += toLoseDocCount;
/* 518 */           result.numBadSegments++;
/*     */         } finally {
/*     */           
/* 521 */           if (reader != null) {
/* 522 */             reader.close();
/*     */           }
/*     */         } 
/*     */         
/* 526 */         result.newSegments.add((E)info.clone());
/*     */       } 
/*     */     } 
/* 529 */     if (0 == result.numBadSegments) {
/* 530 */       result.clean = true;
/* 531 */       msg(""No problems were detected with this index.\n"");
/*     */     } else {
/* 533 */       msg(""WARNING: "" + result.numBadSegments + "" broken segments (containing "" + result.totLoseDocCount + "" documents) detected"");
/*     */     } 
/* 535 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void fixIndex(Status result) throws IOException {
/* 552 */     if (result.partial)
/* 553 */       throw new IllegalArgumentException(""can only fix an index that was fully checked (this status checked a subset of segments)""); 
/* 554 */     result.newSegments.commit(result.dir);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private static boolean testAsserts() {
/* 560 */     assertsOn = true;
/* 561 */     return true;
/*     */   }
/*     */   
/*     */   private static boolean assertsOn() {
/* 565 */     assert testAsserts();
/* 566 */     return assertsOn;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) throws IOException {
/*     */     int exitCode;
/* 603 */     boolean doFix = false;
/* 604 */     List onlySegments = new ArrayList();
/* 605 */     String indexPath = null;
/* 606 */     int i = 0;
/* 607 */     while (i < args.length) {
/* 608 */       if (args[i].equals(""-fix"")) {
/* 609 */         doFix = true;
/* 610 */         i++; continue;
/* 611 */       }  if (args[i].equals(""-segment"")) {
/* 612 */         if (i == args.length - 1) {
/* 613 */           System.out.println(""ERROR: missing name for -segment option"");
/* 614 */           System.exit(1);
/*     */         } 
/* 616 */         onlySegments.add(args[i + 1]);
/* 617 */         i += 2; continue;
/*     */       } 
/* 619 */       if (indexPath != null) {
/* 620 */         System.out.println(""ERROR: unexpected extra argument '"" + args[i] + ""'"");
/* 621 */         System.exit(1);
/*     */       } 
/* 623 */       indexPath = args[i];
/* 624 */       i++;
/*     */     } 
/*     */ 
/*     */     
/* 628 */     if (indexPath == null) {
/* 629 */       System.out.println(""\nERROR: index path not specified"");
/* 630 */       System.out.println(""\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n\n  -fix: actually write a new segments_N file, removing any problematic segments\n  -segment X: only check the specified segments.  This can be specified multiple\n              times, to check more than one segment, eg '-segment _2 -segment _a'.\n              You can't use this with the -fix option\n\n**WARNING**: -fix should only be used on an emergency basis as it will cause\ndocuments (perhaps many) to be permanently removed from the index.  Always make\na backup copy of your index before running this!  Do not run this tool on an index\nthat is actively being written to.  You have been warned!\n\nRun without -fix, this tool will open the index, report version information\nand report any exceptions it hits and what action it would take if -fix were\nspecified.  With -fix, this tool will remove any segments that have issues and\nwrite a new segments_N file.  This means all documents contained in the affected\nsegments will be removed.\n\nThis tool exits with exit code 1 if the index cannot be opened or has any\ncorruption, else 0.\n"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 650 */       System.exit(1);
/*     */     } 
/*     */     
/* 653 */     if (!assertsOn()) {
/* 654 */       System.out.println(""\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled"");
/*     */     }
/* 656 */     if (onlySegments.size() == 0) {
/* 657 */       onlySegments = null;
/* 658 */     } else if (doFix) {
/* 659 */       System.out.println(""ERROR: cannot specify both -fix and -segment"");
/* 660 */       System.exit(1);
/*     */     } 
/*     */     
/* 663 */     System.out.println(""\nOpening index @ "" + indexPath + ""\n"");
/* 664 */     Object object = null;
/*     */     try {
/* 666 */       object = FSDirectory.getDirectory(indexPath);
/* 667 */     } catch (Throwable t) {
/* 668 */       System.out.println(""ERROR: could not open directory \"""" + indexPath + ""\""; exiting"");
/* 669 */       t.printStackTrace(System.out);
/* 670 */       System.exit(1);
/*     */     } 
/*     */     
/* 673 */     CheckIndex checker = new CheckIndex((Directory)object);
/* 674 */     checker.setInfoStream(System.out);
/*     */     
/* 676 */     Status result = checker.checkIndex(onlySegments);
/*     */     
/* 678 */     if (!result.clean) {
/* 679 */       if (!doFix) {
/* 680 */         System.out.println(""WARNING: would write new segments file, and "" + result.totLoseDocCount + "" documents would be lost, if -fix were specified\n"");
/*     */       } else {
/* 682 */         System.out.println(""WARNING: "" + result.totLoseDocCount + "" documents will be lost\n"");
/* 683 */         System.out.println(""NOTE: will write new segments file in 5 seconds; this will remove "" + result.totLoseDocCount + "" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!"");
/* 684 */         for (exitCode = 0; exitCode < 5; exitCode++) {
/*     */           try {
/* 686 */             Thread.sleep(1000L);
/* 687 */           } catch (InterruptedException ie) {
/* 688 */             Thread.currentThread().interrupt();
/* 689 */             exitCode--;
/*     */           } 
/*     */           
/* 692 */           System.out.println(""  "" + (5 - exitCode) + ""..."");
/*     */         } 
/* 694 */         System.out.println(""Writing..."");
/* 695 */         checker.fixIndex(result);
/* 696 */         System.out.println(""OK"");
/* 697 */         System.out.println(""Wrote new segments file \"""" + result.newSegments.getCurrentSegmentFileName() + ""\"""");
/*     */       } 
/*     */     }
/* 700 */     System.out.println("""");
/*     */ 
/*     */     
/* 703 */     if (result != null && result.clean == true) {
/* 704 */       exitCode = 0;
/*     */     } else {
/* 706 */       exitCode = 1;
/* 707 */     }  System.exit(exitCode);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\CheckIndex.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CompoundFileReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import org.apache.lucene.store.BufferedIndexInput;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.Lock;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class CompoundFileReader
/*     */   extends Directory
/*     */ {
/*     */   private int readBufferSize;
/*     */   private Directory directory;
/*     */   private String fileName;
/*     */   private IndexInput stream;
/*     */   
/*     */   private static final class FileEntry
/*     */   {
/*     */     long offset;
/*     */     long length;
/*     */     
/*     */     private FileEntry() {}
/*     */   }
/*  53 */   private HashMap entries = new HashMap();
/*     */ 
/*     */ 
/*     */   
/*  57 */   public CompoundFileReader(Directory dir, String name) throws IOException { this(dir, name, 1024); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public CompoundFileReader(Directory dir, String name, int readBufferSize) throws IOException {
/*  63 */     this.directory = dir;
/*  64 */     this.fileName = name;
/*  65 */     this.readBufferSize = readBufferSize;
/*     */     
/*  67 */     boolean success = false;
/*     */     
/*     */     try {
/*  70 */       this.stream = dir.openInput(name, readBufferSize);
/*     */ 
/*     */       
/*  73 */       int count = this.stream.readVInt();
/*  74 */       FileEntry entry = null;
/*  75 */       for (int i = 0; i < count; i++) {
/*  76 */         long offset = this.stream.readLong();
/*  77 */         String id = this.stream.readString();
/*     */         
/*  79 */         if (entry != null)
/*     */         {
/*  81 */           entry.length = offset - entry.offset;
/*     */         }
/*     */         
/*  84 */         entry = new FileEntry();
/*  85 */         entry.offset = offset;
/*  86 */         this.entries.put(id, entry);
/*     */       } 
/*     */ 
/*     */       
/*  90 */       if (entry != null) {
/*  91 */         entry.length = this.stream.length() - entry.offset;
/*     */       }
/*     */       
/*  94 */       success = true;
/*     */     } finally {
/*     */       
/*  97 */       if (!success && this.stream != null) {
/*     */         try {
/*  99 */           this.stream.close();
/* 100 */         } catch (IOException e) {}
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 106 */   public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */   
/* 110 */   public String getName() { return this.fileName; }
/*     */ 
/*     */   
/*     */   public synchronized void close() throws IOException {
/* 114 */     if (this.stream == null) {
/* 115 */       throw new IOException(""Already closed"");
/*     */     }
/* 117 */     this.entries.clear();
/* 118 */     this.stream.close();
/* 119 */     this.stream = null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public synchronized IndexInput openInput(String id) throws IOException { return openInput(id, this.readBufferSize); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized IndexInput openInput(String id, int readBufferSize) throws IOException {
/* 132 */     if (this.stream == null) {
/* 133 */       throw new IOException(""Stream closed"");
/*     */     }
/* 135 */     FileEntry entry = (FileEntry)this.entries.get(id);
/* 136 */     if (entry == null) {
/* 137 */       throw new IOException(""No sub-file with id "" + id + "" found"");
/*     */     }
/* 139 */     return (IndexInput)new CSIndexInput(this.stream, entry.offset, entry.length, readBufferSize);
/*     */   }
/*     */ 
/*     */   
/*     */   public String[] list() {
/* 144 */     String[] res = new String[this.entries.size()];
/* 145 */     return (String[])this.entries.keySet().toArray((Object[])res);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 150 */   public boolean fileExists(String name) { return this.entries.containsKey(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public long fileModified(String name) throws IOException { return this.directory.fileModified(this.fileName); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public void touchFile(String name) throws IOException { this.directory.touchFile(this.fileName); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 167 */   public void deleteFile(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 174 */   public void renameFile(String from, String to) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long fileLength(String name) throws IOException {
/* 182 */     FileEntry e = (FileEntry)this.entries.get(name);
/* 183 */     if (e == null)
/* 184 */       throw new IOException(""File "" + name + "" does not exist""); 
/* 185 */     return e.length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 192 */   public IndexOutput createOutput(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 199 */   public Lock makeLock(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/*     */   static final class CSIndexInput
/*     */     extends BufferedIndexInput
/*     */   {
/*     */     IndexInput base;
/*     */ 
/*     */     
/*     */     long fileOffset;
/*     */ 
/*     */     
/*     */     long length;
/*     */ 
/*     */     
/* 215 */     CSIndexInput(IndexInput base, long fileOffset, long length) { this(base, fileOffset, length, 1024); }
/*     */ 
/*     */ 
/*     */     
/*     */     CSIndexInput(IndexInput base, long fileOffset, long length, int readBufferSize) {
/* 220 */       super(readBufferSize);
/* 221 */       this.base = (IndexInput)base.clone();
/* 222 */       this.fileOffset = fileOffset;
/* 223 */       this.length = length;
/*     */     }
/*     */     
/*     */     public Object clone() {
/* 227 */       CSIndexInput clone = (CSIndexInput)super.clone();
/* 228 */       clone.base = (IndexInput)this.base.clone();
/* 229 */       clone.fileOffset = this.fileOffset;
/* 230 */       clone.length = this.length;
/* 231 */       return clone;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected void readInternal(byte[] b, int offset, int len) throws IOException {
/* 243 */       long start = getFilePointer();
/* 244 */       if (start + len > this.length)
/* 245 */         throw new IOException(""read past EOF""); 
/* 246 */       this.base.seek(this.fileOffset + start);
/* 247 */       this.base.readBytes(b, offset, len, false);
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected void seekInternal(long pos) {}
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 258 */     public void close() throws IOException { this.base.close(); }
/*     */ 
/*     */ 
/*     */     
/* 262 */     public long length() { return this.length; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\CompoundFileReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CompoundFileWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class CompoundFileWriter
/*     */ {
/*     */   private Directory directory;
/*     */   private String fileName;
/*     */   private HashSet ids;
/*     */   private LinkedList entries;
/*     */   
/*     */   private static final class FileEntry
/*     */   {
/*     */     String file;
/*     */     long directoryOffset;
/*     */     long dataOffset;
/*     */     
/*     */     private FileEntry() {}
/*     */   }
/*     */   private boolean merged = false;
/*     */   private SegmentMerger.CheckAbort checkAbort;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  78 */   public CompoundFileWriter(Directory dir, String name) { this(dir, name, null); }
/*     */ 
/*     */   
/*     */   CompoundFileWriter(Directory dir, String name, SegmentMerger.CheckAbort checkAbort) {
/*  82 */     if (dir == null)
/*  83 */       throw new NullPointerException(""directory cannot be null""); 
/*  84 */     if (name == null)
/*  85 */       throw new NullPointerException(""name cannot be null""); 
/*  86 */     this.checkAbort = checkAbort;
/*  87 */     this.directory = dir;
/*  88 */     this.fileName = name;
/*  89 */     this.ids = new HashSet();
/*  90 */     this.entries = new LinkedList();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  95 */   public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 100 */   public String getName() { return this.fileName; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addFile(String file) {
/* 112 */     if (this.merged) {
/* 113 */       throw new IllegalStateException(""Can't add extensions after merge has been called"");
/*     */     }
/*     */     
/* 116 */     if (file == null) {
/* 117 */       throw new NullPointerException(""file cannot be null"");
/*     */     }
/*     */     
/* 120 */     if (!this.ids.add(file)) {
/* 121 */       throw new IllegalArgumentException(""File "" + file + "" already added"");
/*     */     }
/*     */     
/* 124 */     FileEntry entry = new FileEntry();
/* 125 */     entry.file = file;
/* 126 */     this.entries.add(entry);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 137 */     if (this.merged) {
/* 138 */       throw new IllegalStateException(""Merge already performed"");
/*     */     }
/*     */     
/* 141 */     if (this.entries.isEmpty()) {
/* 142 */       throw new IllegalStateException(""No entries to merge have been defined"");
/*     */     }
/*     */     
/* 145 */     this.merged = true;
/*     */ 
/*     */     
/* 148 */     IndexOutput os = null;
/*     */     try {
/* 150 */       os = this.directory.createOutput(this.fileName);
/*     */ 
/*     */       
/* 153 */       os.writeVInt(this.entries.size());
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 158 */       Iterator it = this.entries.iterator();
/* 159 */       long totalSize = 0L;
/* 160 */       while (it.hasNext()) {
/* 161 */         FileEntry fe = it.next();
/* 162 */         fe.directoryOffset = os.getFilePointer();
/* 163 */         os.writeLong(0L);
/* 164 */         os.writeString(fe.file);
/* 165 */         totalSize += this.directory.fileLength(fe.file);
/*     */       } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 174 */       long finalLength = totalSize + os.getFilePointer();
/* 175 */       os.setLength(finalLength);
/*     */ 
/*     */ 
/*     */       
/* 179 */       byte[] buffer = new byte[16384];
/* 180 */       it = this.entries.iterator();
/* 181 */       while (it.hasNext()) {
/* 182 */         FileEntry fe = it.next();
/* 183 */         fe.dataOffset = os.getFilePointer();
/* 184 */         copyFile(fe, os, buffer);
/*     */       } 
/*     */ 
/*     */       
/* 188 */       it = this.entries.iterator();
/* 189 */       while (it.hasNext()) {
/* 190 */         FileEntry fe = it.next();
/* 191 */         os.seek(fe.directoryOffset);
/* 192 */         os.writeLong(fe.dataOffset);
/*     */       } 
/*     */       
/* 195 */       assert finalLength == os.length();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 201 */       IndexOutput tmp = os;
/* 202 */       os = null;
/* 203 */       tmp.close();
/*     */     } finally {
/*     */       
/* 206 */       if (os != null) try { os.close(); } catch (IOException e) {}
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void copyFile(FileEntry source, IndexOutput os, byte[] buffer) throws IOException {
/* 217 */     IndexInput is = null;
/*     */     try {
/* 219 */       long startPtr = os.getFilePointer();
/*     */       
/* 221 */       is = this.directory.openInput(source.file);
/* 222 */       long length = is.length();
/* 223 */       long remainder = length;
/* 224 */       int chunk = buffer.length;
/*     */       
/* 226 */       while (remainder > 0L) {
/* 227 */         int len = (int)Math.min(chunk, remainder);
/* 228 */         is.readBytes(buffer, 0, len, false);
/* 229 */         os.writeBytes(buffer, len);
/* 230 */         remainder -= len;
/* 231 */         if (this.checkAbort != null)
/*     */         {
/*     */           
/* 234 */           this.checkAbort.work(80.0D);
/*     */         }
/*     */       } 
/*     */       
/* 238 */       if (remainder != 0L) {
/* 239 */         throw new IOException(""Non-zero remainder length after copying: "" + remainder + "" (id: "" + source.file + "", length: "" + length + "", buffer size: "" + chunk + "")"");
/*     */       }
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 245 */       long endPtr = os.getFilePointer();
/* 246 */       long diff = endPtr - startPtr;
/* 247 */       if (diff != length) {
/* 248 */         throw new IOException(""Difference in the output file offsets "" + diff + "" does not match the original file length "" + length);
/*     */       }
/*     */     }
/*     */     finally {
/*     */       
/* 253 */       if (is != null) is.close(); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\CompoundFileWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ConcurrentMergeScheduler,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ConcurrentMergeScheduler
/*     */   extends MergeScheduler
/*     */ {
/*  37 */   private int mergeThreadPriority = -1;
/*     */   
/*  39 */   protected List mergeThreads = new ArrayList();
/*     */ 
/*     */   
/*  42 */   private int maxThreadCount = 3;
/*     */   
/*  44 */   private List exceptions = new ArrayList();
/*     */   
/*     */   protected Directory dir;
/*     */   private boolean closed;
/*     */   protected IndexWriter writer;
/*     */   protected int mergeThreadCount;
/*     */   
/*     */   public ConcurrentMergeScheduler() {
/*  52 */     if (allInstances != null)
/*     */     {
/*  54 */       addMyself();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxThreadCount(int count) {
/*  64 */     if (count < 1)
/*  65 */       throw new IllegalArgumentException(""count should be at least 1""); 
/*  66 */     this.maxThreadCount = count;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  72 */   public int getMaxThreadCount() { return this.maxThreadCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized int getMergeThreadPriority() {
/*  80 */     initMergeThreadPriority();
/*  81 */     return this.mergeThreadPriority;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void setMergeThreadPriority(int pri) {
/*  86 */     if (pri > 10 || pri < 1)
/*  87 */       throw new IllegalArgumentException(""priority must be in range 1 .. 10 inclusive""); 
/*  88 */     this.mergeThreadPriority = pri;
/*     */     
/*  90 */     int numThreads = mergeThreadCount();
/*  91 */     for (int i = 0; i < numThreads; i++) {
/*  92 */       MergeThread merge = this.mergeThreads.get(i);
/*  93 */       merge.setThreadPriority(pri);
/*     */     } 
/*     */   }
/*     */   
/*     */   private void message(String message) {
/*  98 */     if (this.writer != null)
/*  99 */       this.writer.message(""CMS: "" + message); 
/*     */   }
/*     */   
/*     */   private synchronized void initMergeThreadPriority() {
/* 103 */     if (this.mergeThreadPriority == -1) {
/*     */ 
/*     */       
/* 106 */       this.mergeThreadPriority = 1 + Thread.currentThread().getPriority();
/* 107 */       if (this.mergeThreadPriority > 10) {
/* 108 */         this.mergeThreadPriority = 10;
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/* 113 */   public void close() { this.closed = true; }
/*     */ 
/*     */   
/*     */   public synchronized void sync() {
/* 117 */     while (mergeThreadCount() > 0) {
/* 118 */       message(""now wait for threads; currently "" + this.mergeThreads.size() + "" still running"");
/* 119 */       int count = this.mergeThreads.size();
/* 120 */       for (int i = 0; i < count; i++) {
/* 121 */         message(""    "" + i + "": "" + (MergeThread)this.mergeThreads.get(i));
/*     */       }
/*     */       try {
/* 124 */         wait();
/* 125 */       } catch (InterruptedException e) {}
/*     */     } 
/*     */   }
/*     */   
/*     */   private synchronized int mergeThreadCount() {
/* 130 */     int count = 0;
/* 131 */     int numThreads = this.mergeThreads.size();
/* 132 */     for (int i = 0; i < numThreads; i++) {
/* 133 */       if (((MergeThread)this.mergeThreads.get(i)).isAlive())
/* 134 */         count++; 
/* 135 */     }  return count;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void merge(IndexWriter writer) throws CorruptIndexException, IOException {
/* 144 */     this.writer = writer;
/*     */     
/* 146 */     initMergeThreadPriority();
/*     */     
/* 148 */     this.dir = writer.getDirectory();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 157 */     message(""now merge"");
/* 158 */     message(""  index: "" + writer.segString());
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     while (true) {
/* 168 */       MergePolicy.OneMerge merge = writer.getNextMerge();
/* 169 */       if (merge == null) {
/* 170 */         message(""  no more merges pending; now return"");
/*     */ 
/*     */         
/*     */         return;
/*     */       } 
/*     */       
/* 176 */       writer.mergeInit(merge);
/*     */       
/* 178 */       synchronized (this) {
/* 179 */         while (mergeThreadCount() >= this.maxThreadCount) {
/* 180 */           message(""    too many merge threads running; stalling..."");
/*     */           try {
/* 182 */             wait();
/* 183 */           } catch (InterruptedException ie) {
/* 184 */             Thread.currentThread().interrupt();
/*     */           } 
/*     */         } 
/*     */         
/* 188 */         message(""  consider merge "" + merge.segString(this.dir));
/*     */         
/* 190 */         assert mergeThreadCount() < this.maxThreadCount;
/*     */ 
/*     */ 
/*     */         
/* 194 */         MergeThread merger = getMergeThread(writer, merge);
/* 195 */         this.mergeThreads.add(merger);
/* 196 */         message(""    launch new thread ["" + merger.getName() + ""]"");
/* 197 */         merger.start();
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 205 */   protected void doMerge(MergePolicy.OneMerge merge) throws IOException { this.writer.merge(merge); }
/*     */ 
/*     */ 
/*     */   
/*     */   protected synchronized MergeThread getMergeThread(IndexWriter writer, MergePolicy.OneMerge merge) throws IOException {
/* 210 */     MergeThread thread = new MergeThread(writer, merge);
/* 211 */     thread.setThreadPriority(this.mergeThreadPriority);
/* 212 */     thread.setDaemon(true);
/* 213 */     thread.setName(""Lucene Merge Thread #"" + this.mergeThreadCount++);
/* 214 */     return thread;
/*     */   }
/*     */   
/*     */   protected class MergeThread extends Thread { IndexWriter writer;
/*     */     MergePolicy.OneMerge startMerge;
/*     */     MergePolicy.OneMerge runningMerge;
/*     */     static final boolean $assertionsDisabled;
/*     */     private final ConcurrentMergeScheduler this$0;
/*     */     
/*     */     public MergeThread(IndexWriter writer, MergePolicy.OneMerge startMerge) throws IOException {
/* 224 */       this.writer = writer;
/* 225 */       this.startMerge = startMerge;
/*     */     }
/*     */ 
/*     */     
/* 229 */     public synchronized void setRunningMerge(MergePolicy.OneMerge merge) { this.runningMerge = merge; }
/*     */ 
/*     */ 
/*     */     
/* 233 */     public synchronized MergePolicy.OneMerge getRunningMerge() { return this.runningMerge; }
/*     */ 
/*     */     
/*     */     public void setThreadPriority(int pri) {
/*     */       try {
/* 238 */         setPriority(pri);
/* 239 */       } catch (NullPointerException npe) {
/*     */ 
/*     */       
/* 242 */       } catch (SecurityException se) {}
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public void run() {
/* 252 */       MergePolicy.OneMerge merge = this.startMerge;
/*     */ 
/*     */       
/*     */       try {
/* 256 */         ConcurrentMergeScheduler.this.message(""  merge thread: start"");
/*     */         
/*     */         while (true) {
/* 259 */           setRunningMerge(merge);
/* 260 */           ConcurrentMergeScheduler.this.doMerge(merge);
/*     */ 
/*     */ 
/*     */           
/* 264 */           merge = this.writer.getNextMerge();
/* 265 */           if (merge != null) {
/* 266 */             this.writer.mergeInit(merge);
/* 267 */             ConcurrentMergeScheduler.this.message(""  merge thread: do another merge "" + merge.segString(ConcurrentMergeScheduler.this.dir));
/*     */             continue;
/*     */           } 
/*     */           break;
/*     */         } 
/* 272 */         ConcurrentMergeScheduler.this.message(""  merge thread: done"");
/*     */       }
/* 274 */       catch (Throwable exc) {
/*     */ 
/*     */         
/* 277 */         if (!(exc instanceof MergePolicy.MergeAbortedException)) {
/* 278 */           synchronized (ConcurrentMergeScheduler.this) {
/* 279 */             ConcurrentMergeScheduler.this.exceptions.add(exc);
/*     */           } 
/*     */           
/* 282 */           if (!ConcurrentMergeScheduler.this.suppressExceptions) {
/*     */ 
/*     */             
/* 285 */             ConcurrentMergeScheduler.anyExceptions = true;
/* 286 */             ConcurrentMergeScheduler.this.handleMergeException(exc);
/*     */           } 
/*     */         } 
/*     */       } finally {
/* 290 */         synchronized (ConcurrentMergeScheduler.this) {
/* 291 */           ConcurrentMergeScheduler.this.notifyAll();
/* 292 */           boolean removed = ConcurrentMergeScheduler.this.mergeThreads.remove(this);
/* 293 */           assert removed;
/*     */         } 
/*     */       } 
/*     */     }
/*     */     
/*     */     public String toString() {
/* 299 */       MergePolicy.OneMerge merge = getRunningMerge();
/* 300 */       if (merge == null)
/* 301 */         merge = this.startMerge; 
/* 302 */       return ""merge thread: "" + merge.segString(ConcurrentMergeScheduler.this.dir);
/*     */     } }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 309 */   protected void handleMergeException(Throwable exc) { throw new MergePolicy.MergeException(exc, this.dir); }
/*     */   static boolean anyExceptions = false;
/*     */   private boolean suppressExceptions;
/*     */   private static List allInstances;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public static boolean anyUnhandledExceptions() {
/* 316 */     synchronized (allInstances) {
/* 317 */       int count = allInstances.size();
/*     */ 
/*     */       
/* 320 */       for (int i = 0; i < count; i++)
/* 321 */         ((ConcurrentMergeScheduler)allInstances.get(i)).sync(); 
/* 322 */       boolean v = anyExceptions;
/* 323 */       anyExceptions = false;
/* 324 */       return v;
/*     */     } 
/*     */   }
/*     */   
/*     */   public static void clearUnhandledExceptions() {
/* 329 */     synchronized (allInstances) {
/* 330 */       anyExceptions = false;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void addMyself() {
/* 336 */     synchronized (allInstances) {
/* 337 */       int size = 0;
/* 338 */       int upto = 0;
/* 339 */       for (int i = 0; i < 0; i++) {
/* 340 */         ConcurrentMergeScheduler other = allInstances.get(i);
/* 341 */         if (!other.closed || 0 != other.mergeThreadCount())
/*     */         {
/*     */           
/* 344 */           allInstances.set(upto++, other); } 
/*     */       } 
/* 346 */       allInstances.subList(upto, allInstances.size()).clear();
/* 347 */       allInstances.add(this);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 355 */   void setSuppressExceptions() { this.suppressExceptions = true; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 360 */   void clearSuppressExceptions() { this.suppressExceptions = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 366 */   public static void setTestMode() { allInstances = new ArrayList(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ConcurrentMergeScheduler.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CorruptIndexException,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CorruptIndexException
/*    */   extends IOException
/*    */ {
/* 28 */   public CorruptIndexException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\CorruptIndexException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DefaultSkipListReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DefaultSkipListReader
/*     */   extends MultiLevelSkipListReader
/*     */ {
/*     */   private boolean currentFieldStoresPayloads;
/*     */   private long[] freqPointer;
/*     */   private long[] proxPointer;
/*     */   private int[] payloadLength;
/*     */   private long lastFreqPointer;
/*     */   private long lastProxPointer;
/*     */   private int lastPayloadLength;
/*     */   
/*     */   DefaultSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval) {
/*  42 */     super(skipStream, maxSkipLevels, skipInterval);
/*  43 */     this.freqPointer = new long[maxSkipLevels];
/*  44 */     this.proxPointer = new long[maxSkipLevels];
/*  45 */     this.payloadLength = new int[maxSkipLevels];
/*     */   }
/*     */   
/*     */   void init(long skipPointer, long freqBasePointer, long proxBasePointer, int df, boolean storesPayloads) {
/*  49 */     init(skipPointer, df);
/*  50 */     this.currentFieldStoresPayloads = storesPayloads;
/*  51 */     this.lastFreqPointer = freqBasePointer;
/*  52 */     this.lastProxPointer = proxBasePointer;
/*     */     
/*  54 */     Arrays.fill(this.freqPointer, freqBasePointer);
/*  55 */     Arrays.fill(this.proxPointer, proxBasePointer);
/*  56 */     Arrays.fill(this.payloadLength, 0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  62 */   long getFreqPointer() { return this.lastFreqPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   long getProxPointer() { return this.lastProxPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  75 */   int getPayloadLength() { return this.lastPayloadLength; }
/*     */ 
/*     */   
/*     */   protected void seekChild(int level) throws IOException {
/*  79 */     super.seekChild(level);
/*  80 */     this.freqPointer[level] = this.lastFreqPointer;
/*  81 */     this.proxPointer[level] = this.lastProxPointer;
/*  82 */     this.payloadLength[level] = this.lastPayloadLength;
/*     */   }
/*     */   
/*     */   protected void setLastSkipData(int level) {
/*  86 */     super.setLastSkipData(level);
/*  87 */     this.lastFreqPointer = this.freqPointer[level];
/*  88 */     this.lastProxPointer = this.proxPointer[level];
/*  89 */     this.lastPayloadLength = this.payloadLength[level];
/*     */   }
/*     */ 
/*     */   
/*     */   protected int readSkipData(int level, IndexInput skipStream) throws IOException {
/*     */     int delta;
/*  95 */     if (this.currentFieldStoresPayloads) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 101 */       delta = skipStream.readVInt();
/* 102 */       if ((delta & 0x1) != 0) {
/* 103 */         this.payloadLength[level] = skipStream.readVInt();
/*     */       }
/* 105 */       delta >>>= 1;
/*     */     } else {
/* 107 */       delta = skipStream.readVInt();
/*     */     } 
/* 109 */     this.freqPointer[level] = this.freqPointer[level] + skipStream.readVInt();
/* 110 */     this.proxPointer[level] = this.proxPointer[level] + skipStream.readVInt();
/*     */     
/* 112 */     return delta;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DefaultSkipListReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DefaultSkipListWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DefaultSkipListWriter
/*     */   extends MultiLevelSkipListWriter
/*     */ {
/*     */   private int[] lastSkipDoc;
/*     */   private int[] lastSkipPayloadLength;
/*     */   private long[] lastSkipFreqPointer;
/*     */   private long[] lastSkipProxPointer;
/*     */   private IndexOutput freqOutput;
/*     */   private IndexOutput proxOutput;
/*     */   private int curDoc;
/*     */   private boolean curStorePayloads;
/*     */   private int curPayloadLength;
/*     */   private long curFreqPointer;
/*     */   private long curProxPointer;
/*     */   
/*     */   DefaultSkipListWriter(int skipInterval, int numberOfSkipLevels, int docCount, IndexOutput freqOutput, IndexOutput proxOutput) {
/*  47 */     super(skipInterval, numberOfSkipLevels, docCount);
/*  48 */     this.freqOutput = freqOutput;
/*  49 */     this.proxOutput = proxOutput;
/*     */     
/*  51 */     this.lastSkipDoc = new int[numberOfSkipLevels];
/*  52 */     this.lastSkipPayloadLength = new int[numberOfSkipLevels];
/*  53 */     this.lastSkipFreqPointer = new long[numberOfSkipLevels];
/*  54 */     this.lastSkipProxPointer = new long[numberOfSkipLevels];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setSkipData(int doc, boolean storePayloads, int payloadLength) {
/*  61 */     this.curDoc = doc;
/*  62 */     this.curStorePayloads = storePayloads;
/*  63 */     this.curPayloadLength = payloadLength;
/*  64 */     this.curFreqPointer = this.freqOutput.getFilePointer();
/*  65 */     if (this.proxOutput != null)
/*  66 */       this.curProxPointer = this.proxOutput.getFilePointer(); 
/*     */   }
/*     */   
/*     */   protected void resetSkip() {
/*  70 */     super.resetSkip();
/*  71 */     Arrays.fill(this.lastSkipDoc, 0);
/*  72 */     Arrays.fill(this.lastSkipPayloadLength, -1);
/*  73 */     Arrays.fill(this.lastSkipFreqPointer, this.freqOutput.getFilePointer());
/*  74 */     if (this.proxOutput != null) {
/*  75 */       Arrays.fill(this.lastSkipProxPointer, this.proxOutput.getFilePointer());
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void writeSkipData(int level, IndexOutput skipBuffer) throws IOException {
/*  99 */     if (this.curStorePayloads) {
/* 100 */       int delta = this.curDoc - this.lastSkipDoc[level];
/* 101 */       if (this.curPayloadLength == this.lastSkipPayloadLength[level]) {
/*     */ 
/*     */         
/* 104 */         skipBuffer.writeVInt(delta * 2);
/*     */       }
/*     */       else {
/*     */         
/* 108 */         skipBuffer.writeVInt(delta * 2 + 1);
/* 109 */         skipBuffer.writeVInt(this.curPayloadLength);
/* 110 */         this.lastSkipPayloadLength[level] = this.curPayloadLength;
/*     */       } 
/*     */     } else {
/*     */       
/* 114 */       skipBuffer.writeVInt(this.curDoc - this.lastSkipDoc[level]);
/*     */     } 
/* 116 */     skipBuffer.writeVInt((int)(this.curFreqPointer - this.lastSkipFreqPointer[level]));
/* 117 */     skipBuffer.writeVInt((int)(this.curProxPointer - this.lastSkipProxPointer[level]));
/*     */     
/* 119 */     this.lastSkipDoc[level] = this.curDoc;
/*     */ 
/*     */     
/* 122 */     this.lastSkipFreqPointer[level] = this.curFreqPointer;
/* 123 */     this.lastSkipProxPointer[level] = this.curProxPointer;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DefaultSkipListWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DirectoryIndexReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.FileNotFoundException;
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashSet;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.Lock;
/*     */ import org.apache.lucene.store.LockObtainFailedException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class DirectoryIndexReader
/*     */   extends IndexReader
/*     */ {
/*     */   protected Directory directory;
/*     */   protected boolean closeDirectory;
/*     */   private IndexDeletionPolicy deletionPolicy;
/*     */   private SegmentInfos segmentInfos;
/*     */   private Lock writeLock;
/*     */   private boolean stale;
/*  46 */   private final HashSet synced = new HashSet();
/*     */   
/*     */   private boolean rollbackHasChanges;
/*     */   
/*     */   private SegmentInfos rollbackSegmentInfos;
/*     */   
/*     */   protected boolean readOnly;
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */ 
/*     */   
/*     */   void init(Directory directory, SegmentInfos segmentInfos, boolean closeDirectory, boolean readOnly) throws IOException {
/*  58 */     this.directory = directory;
/*  59 */     this.segmentInfos = segmentInfos;
/*  60 */     this.closeDirectory = closeDirectory;
/*  61 */     this.readOnly = readOnly;
/*     */     
/*  63 */     if (!readOnly && segmentInfos != null)
/*     */     {
/*     */       
/*  66 */       for (int i = 0; i < segmentInfos.size(); i++) {
/*  67 */         SegmentInfo info = segmentInfos.info(i);
/*  68 */         List files = info.files();
/*  69 */         for (int j = 0; j < files.size(); j++) {
/*  70 */           this.synced.add(files.get(j));
/*     */         }
/*     */       } 
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   DirectoryIndexReader(Directory directory, SegmentInfos segmentInfos, boolean closeDirectory, boolean readOnly) throws IOException { init(directory, segmentInfos, closeDirectory, readOnly); }
/*     */ 
/*     */ 
/*     */   
/*  84 */   static DirectoryIndexReader open(Directory directory, boolean closeDirectory, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException { return open(directory, closeDirectory, deletionPolicy, null, false); }
/*     */ 
/*     */ 
/*     */   
/*     */   static DirectoryIndexReader open(Directory directory, final boolean closeDirectory, final IndexDeletionPolicy deletionPolicy, IndexCommit commit, final boolean readOnly) throws CorruptIndexException, IOException {
/*  89 */     SegmentInfos.FindSegmentsFile finder = new SegmentInfos.FindSegmentsFile(directory) { private final boolean val$readOnly;
/*     */         
/*     */         protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
/*     */           DirectoryIndexReader reader;
/*  93 */           SegmentInfos infos = new SegmentInfos();
/*  94 */           infos.read(this.directory, segmentFileName);
/*     */ 
/*     */ 
/*     */           
/*  98 */           if (infos.size() == 1) {
/*  99 */             reader = SegmentReader.get(readOnly, infos, infos.info(0), closeDirectory);
/* 100 */           } else if (readOnly) {
/* 101 */             reader = new ReadOnlyMultiSegmentReader(this.directory, infos, closeDirectory);
/*     */           } else {
/* 103 */             reader = new MultiSegmentReader(this.directory, infos, closeDirectory, false);
/*     */           } 
/* 105 */           reader.setDeletionPolicy(deletionPolicy);
/* 106 */           return reader;
/*     */         }
/*     */         private final boolean val$closeDirectory; private final IndexDeletionPolicy val$deletionPolicy; }
/*     */       ;
/* 110 */     if (commit == null) {
/* 111 */       return (DirectoryIndexReader)finder.run();
/*     */     }
/* 113 */     if (directory != commit.getDirectory()) {
/* 114 */       throw new IOException(""the specified commit does not match the specified Directory"");
/*     */     }
/*     */     
/* 117 */     return (DirectoryIndexReader)finder.doBody(commit.getSegmentsFileName());
/*     */   }
/*     */ 
/*     */   
/*     */   public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {
/* 122 */     ensureOpen();
/*     */     
/* 124 */     if (this.hasChanges || isCurrent())
/*     */     {
/*     */       
/* 127 */       return this;
/*     */     }
/*     */     
/* 130 */     return (DirectoryIndexReader)(new SegmentInfos.FindSegmentsFile(this.directory) { private final DirectoryIndexReader this$0;
/*     */         
/*     */         protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
/* 133 */           SegmentInfos infos = new SegmentInfos();
/* 134 */           infos.read(this.directory, segmentFileName);
/*     */           
/* 136 */           DirectoryIndexReader newReader = DirectoryIndexReader.this.doReopen(infos);
/*     */           
/* 138 */           if (DirectoryIndexReader.this != newReader) {
/* 139 */             newReader.init(this.directory, infos, DirectoryIndexReader.this.closeDirectory, DirectoryIndexReader.this.readOnly);
/* 140 */             newReader.deletionPolicy = DirectoryIndexReader.this.deletionPolicy;
/*     */           } 
/*     */           
/* 143 */           return newReader;
/*     */         } }
/*     */       ).run();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 154 */   public void setDeletionPolicy(IndexDeletionPolicy deletionPolicy) { this.deletionPolicy = deletionPolicy; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Directory directory() {
/* 160 */     ensureOpen();
/* 161 */     return this.directory;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long getVersion() {
/* 168 */     ensureOpen();
/* 169 */     return this.segmentInfos.getVersion();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isCurrent() throws CorruptIndexException, IOException {
/* 187 */     ensureOpen();
/* 188 */     return (SegmentInfos.readCurrentVersion(this.directory) == this.segmentInfos.getVersion());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isOptimized() {
/* 196 */     ensureOpen();
/* 197 */     return (this.segmentInfos.size() == 1 && !hasDeletions());
/*     */   }
/*     */   
/*     */   protected void doClose() throws IOException {
/* 201 */     if (this.closeDirectory) {
/* 202 */       this.directory.close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 215 */     if (this.hasChanges)
/* 216 */       if (this.segmentInfos != null) {
/*     */ 
/*     */ 
/*     */         
/* 220 */         IndexFileDeleter deleter = new IndexFileDeleter(this.directory, (this.deletionPolicy == null) ? new KeepOnlyLastCommitDeletionPolicy() : this.deletionPolicy, this.segmentInfos, null, null);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 226 */         startCommit();
/*     */         
/* 228 */         boolean success = false;
/*     */         try {
/* 230 */           commitChanges();
/*     */ 
/*     */           
/* 233 */           for (int i = 0; i < this.segmentInfos.size(); i++) {
/* 234 */             SegmentInfo info = this.segmentInfos.info(i);
/* 235 */             List files = info.files();
/* 236 */             for (int j = 0; j < files.size(); j++) {
/* 237 */               String fileName = files.get(j);
/* 238 */               if (!this.synced.contains(fileName)) {
/* 239 */                 assert this.directory.fileExists(fileName);
/* 240 */                 this.directory.sync(fileName);
/* 241 */                 this.synced.add(fileName);
/*     */               } 
/*     */             } 
/*     */           } 
/*     */           
/* 246 */           this.segmentInfos.commit(this.directory);
/* 247 */           success = true;
/*     */         } finally {
/*     */           
/* 250 */           if (!success) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 257 */             rollbackCommit();
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 262 */             deleter.refresh();
/*     */           } 
/*     */         } 
/*     */ 
/*     */ 
/*     */         
/* 268 */         deleter.checkpoint(this.segmentInfos, true);
/*     */         
/* 270 */         if (this.writeLock != null) {
/* 271 */           this.writeLock.release();
/* 272 */           this.writeLock = null;
/*     */         } 
/*     */       } else {
/*     */         
/* 276 */         commitChanges();
/*     */       }  
/* 278 */     this.hasChanges = false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void acquireWriteLock() throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 296 */     if (this.segmentInfos != null) {
/* 297 */       ensureOpen();
/* 298 */       if (this.stale) {
/* 299 */         throw new StaleReaderException(""IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"");
/*     */       }
/* 301 */       if (this.writeLock == null) {
/* 302 */         Lock writeLock = this.directory.makeLock(""write.lock"");
/* 303 */         if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT))
/* 304 */           throw new LockObtainFailedException(""Index locked for write: "" + writeLock); 
/* 305 */         this.writeLock = writeLock;
/*     */ 
/*     */ 
/*     */         
/* 309 */         if (SegmentInfos.readCurrentVersion(this.directory) > this.segmentInfos.getVersion()) {
/* 310 */           this.stale = true;
/* 311 */           this.writeLock.release();
/* 312 */           this.writeLock = null;
/* 313 */           throw new StaleReaderException(""IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"");
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void startCommit() {
/* 324 */     if (this.segmentInfos != null) {
/* 325 */       this.rollbackSegmentInfos = (SegmentInfos)this.segmentInfos.clone();
/*     */     }
/* 327 */     this.rollbackHasChanges = this.hasChanges;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void rollbackCommit() {
/* 336 */     if (this.segmentInfos != null) {
/* 337 */       for (int i = 0; i < this.segmentInfos.size(); i++)
/*     */       {
/*     */ 
/*     */ 
/*     */         
/* 342 */         this.segmentInfos.info(i).reset(this.rollbackSegmentInfos.info(i));
/*     */       }
/* 344 */       this.rollbackSegmentInfos = null;
/*     */     } 
/*     */     
/* 347 */     this.hasChanges = this.rollbackHasChanges;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void finalize() throws Throwable {
/*     */     try {
/* 353 */       if (this.writeLock != null) {
/* 354 */         this.writeLock.release();
/* 355 */         this.writeLock = null;
/*     */       } 
/*     */     } finally {
/* 358 */       super.finalize();
/*     */     } 
/*     */   }
/*     */   
/*     */   private static class ReaderCommit extends IndexCommit {
/*     */     private String segmentsFileName;
/*     */     Collection files;
/*     */     Directory dir;
/*     */     long generation;
/*     */     long version;
/*     */     final boolean isOptimized;
/*     */     
/*     */     ReaderCommit(SegmentInfos infos, Directory dir) throws IOException {
/* 371 */       this.segmentsFileName = infos.getCurrentSegmentFileName();
/* 372 */       this.dir = dir;
/* 373 */       int size = infos.size();
/* 374 */       this.files = new ArrayList(size);
/* 375 */       this.files.add(this.segmentsFileName);
/* 376 */       for (int i = 0; i < size; i++) {
/* 377 */         SegmentInfo info = infos.info(i);
/* 378 */         if (info.dir == dir)
/* 379 */           this.files.addAll(info.files()); 
/*     */       } 
/* 381 */       this.version = infos.getVersion();
/* 382 */       this.generation = infos.getGeneration();
/* 383 */       this.isOptimized = (infos.size() == 1 && !infos.info(0).hasDeletions());
/*     */     }
/*     */ 
/*     */     
/* 387 */     public boolean isOptimized() { return this.isOptimized; }
/*     */ 
/*     */     
/* 390 */     public String getSegmentsFileName() { return this.segmentsFileName; }
/*     */ 
/*     */     
/* 393 */     public Collection getFileNames() { return this.files; }
/*     */ 
/*     */     
/* 396 */     public Directory getDirectory() { return this.dir; }
/*     */ 
/*     */     
/* 399 */     public long getVersion() { return this.version; }
/*     */ 
/*     */     
/* 402 */     public long getGeneration() { return this.generation; }
/*     */ 
/*     */     
/* 405 */     public boolean isDeleted() { return false; }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 417 */   public IndexCommit getIndexCommit() throws IOException { return new ReaderCommit(this.segmentInfos, this.directory); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Collection listCommits(Directory dir) throws IOException {
/* 423 */     String[] files = dir.list();
/* 424 */     if (files == null) {
/* 425 */       throw new IOException(""cannot read directory "" + dir + "": list() returned null"");
/*     */     }
/* 427 */     Collection commits = new ArrayList();
/*     */     
/* 429 */     SegmentInfos latest = new SegmentInfos();
/* 430 */     latest.read(dir);
/* 431 */     long currentGen = latest.getGeneration();
/*     */     
/* 433 */     commits.add(new ReaderCommit(latest, dir));
/*     */     
/* 435 */     for (int i = 0; i < files.length; i++) {
/*     */       
/* 437 */       String fileName = files[i];
/*     */       
/* 439 */       if (fileName.startsWith(""segments"") && !fileName.equals(""segments.gen"") && SegmentInfos.generationFromSegmentsFileName(fileName) < currentGen) {
/*     */ 
/*     */ 
/*     */         
/* 443 */         SegmentInfos sis = new SegmentInfos();
/*     */ 
/*     */         
/*     */         try {
/* 447 */           sis.read(dir, fileName);
/* 448 */         } catch (FileNotFoundException fnfe) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 456 */           sis = null;
/*     */         } 
/*     */         
/* 459 */         if (sis != null) {
/* 460 */           commits.add(new ReaderCommit(sis, dir));
/*     */         }
/*     */       } 
/*     */     } 
/* 464 */     return commits;
/*     */   }
/*     */   
/*     */   protected DirectoryIndexReader() {}
/*     */   
/*     */   protected abstract DirectoryIndexReader doReopen(SegmentInfos paramSegmentInfos) throws CorruptIndexException, IOException;
/*     */   
/*     */   protected abstract void commitChanges() throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DirectoryIndexReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocConsumer,"package org.apache.lucene.index;
import java.io.IOException;
import java.util.Collection;
abstract class DocConsumer {
  abstract DocConsumerPerThread addThread(DocumentsWriterThreadState paramDocumentsWriterThreadState) throws IOException;
  abstract void flush(Collection paramCollection, DocumentsWriter.FlushState paramFlushState) throws IOException;
  abstract void closeDocStore(DocumentsWriter.FlushState paramFlushState) throws IOException;
  abstract void abort();
  abstract boolean freeRAM();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocConsumer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocConsumerPerThread,"package org.apache.lucene.index;
import java.io.IOException;
abstract class DocConsumerPerThread {
  abstract DocumentsWriter.DocWriter processDocument() throws IOException;
  abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocConsumerPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldConsumer,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ abstract class DocFieldConsumer
/*    */ {
/*    */   FieldInfos fieldInfos;
/*    */   
/*    */   abstract void flush(Map paramMap, DocumentsWriter.FlushState paramFlushState) throws IOException;
/*    */   
/*    */   abstract void closeDocStore(DocumentsWriter.FlushState paramFlushState) throws IOException;
/*    */   
/*    */   abstract void abort();
/*    */   
/*    */   abstract DocFieldConsumerPerThread addThread(DocFieldProcessorPerThread paramDocFieldProcessorPerThread) throws IOException;
/*    */   
/*    */   abstract boolean freeRAM();
/*    */   
/* 47 */   void setFieldInfos(FieldInfos fieldInfos) { this.fieldInfos = fieldInfos; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldConsumer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldConsumerPerField,"package org.apache.lucene.index;
import java.io.IOException;
import org.apache.lucene.document.Fieldable;
abstract class DocFieldConsumerPerField {
  abstract void processFields(Fieldable[] paramArrayOfFieldable, int paramInt) throws IOException;
  abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldConsumerPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldConsumerPerThread,"package org.apache.lucene.index;
import java.io.IOException;
abstract class DocFieldConsumerPerThread {
  abstract void startDocument() throws IOException;
  abstract DocumentsWriter.DocWriter finishDocument() throws IOException;
  abstract DocFieldConsumerPerField addField(FieldInfo paramFieldInfo);
  abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldConsumerPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldConsumers,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.util.ArrayUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class DocFieldConsumers
/*     */   extends DocFieldConsumer
/*     */ {
/*     */   final DocFieldConsumer one;
/*     */   final DocFieldConsumer two;
/*     */   PerDoc[] docFreeList;
/*     */   int freeCount;
/*     */   int allocCount;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public DocFieldConsumers(DocFieldConsumer one, DocFieldConsumer two) {
/* 105 */     this.docFreeList = new PerDoc[1]; this.one = one; this.two = two;
/*     */   }
/*     */   void setFieldInfos(FieldInfos fieldInfos) { super.setFieldInfos(fieldInfos); this.one.setFieldInfos(fieldInfos); this.two.setFieldInfos(fieldInfos); }
/*     */   public void flush(Map threadsAndFields, DocumentsWriter.FlushState state) throws IOException { Map oneThreadsAndFields = new HashMap(); Map twoThreadsAndFields = new HashMap(); Iterator it = threadsAndFields.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry = it.next(); DocFieldConsumersPerThread perThread = (DocFieldConsumersPerThread)entry.getKey(); Collection fields = (Collection)entry.getValue(); Iterator fieldsIt = fields.iterator(); Collection oneFields = new HashSet(); Collection twoFields = new HashSet(); while (fieldsIt.hasNext()) { DocFieldConsumersPerField perField = fieldsIt.next(); oneFields.add(perField.one); twoFields.add(perField.two); }  oneThreadsAndFields.put(perThread.one, oneFields); twoThreadsAndFields.put(perThread.two, twoFields); }  this.one.flush(oneThreadsAndFields, state); this.two.flush(twoThreadsAndFields, state); } public void closeDocStore(DocumentsWriter.FlushState state) throws IOException { try { this.one.closeDocStore(state); }
/*     */     finally { this.two.closeDocStore(state); }
/* 110 */      } synchronized PerDoc getPerDoc() { if (this.freeCount == 0) {
/* 111 */       this.allocCount++;
/* 112 */       if (this.allocCount > this.docFreeList.length) {
/*     */ 
/*     */ 
/*     */         
/* 116 */         assert this.allocCount == 1 + this.docFreeList.length;
/* 117 */         this.docFreeList = new PerDoc[ArrayUtil.getNextSize(this.allocCount)];
/*     */       } 
/* 119 */       return new PerDoc();
/*     */     } 
/* 121 */     return this.docFreeList[--this.freeCount]; }
/*     */   public void abort() { try { this.one.abort(); }
/*     */     finally { this.two.abort(); }
/*     */      }
/* 125 */   public boolean freeRAM() { boolean any = this.one.freeRAM(); any |= this.two.freeRAM(); return any; } public DocFieldConsumerPerThread addThread(DocFieldProcessorPerThread docFieldProcessorPerThread) throws IOException { return new DocFieldConsumersPerThread(docFieldProcessorPerThread, this, this.one.addThread(docFieldProcessorPerThread), this.two.addThread(docFieldProcessorPerThread)); } synchronized void freePerDoc(PerDoc perDoc) { assert this.freeCount < this.docFreeList.length;
/* 126 */     this.docFreeList[this.freeCount++] = perDoc; }
/*     */ 
/*     */   
/*     */   class PerDoc
/*     */     extends DocumentsWriter.DocWriter {
/*     */     DocumentsWriter.DocWriter one;
/*     */     DocumentsWriter.DocWriter two;
/*     */     private final DocFieldConsumers this$0;
/*     */     
/* 135 */     public long sizeInBytes() { return this.one.sizeInBytes() + this.two.sizeInBytes(); }
/*     */ 
/*     */     
/*     */     public void finish() throws IOException {
/*     */       try {
/*     */         try {
/* 141 */           this.one.finish();
/*     */         } finally {
/* 143 */           this.two.finish();
/*     */         } 
/*     */       } finally {
/* 146 */         DocFieldConsumers.this.freePerDoc(this);
/*     */       } 
/*     */     }
/*     */     
/*     */     public void abort() {
/*     */       try {
/*     */         try {
/* 153 */           this.one.abort();
/*     */         } finally {
/* 155 */           this.two.abort();
/*     */         } 
/*     */       } finally {
/* 158 */         DocFieldConsumers.this.freePerDoc(this);
/*     */       } 
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldConsumers.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldConsumersPerField,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.document.Fieldable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class DocFieldConsumersPerField
/*    */   extends DocFieldConsumerPerField
/*    */ {
/*    */   final DocFieldConsumerPerField one;
/*    */   final DocFieldConsumerPerField two;
/*    */   final DocFieldConsumersPerThread perThread;
/*    */   
/*    */   public DocFieldConsumersPerField(DocFieldConsumersPerThread perThread, DocFieldConsumerPerField one, DocFieldConsumerPerField two) {
/* 30 */     this.perThread = perThread;
/* 31 */     this.one = one;
/* 32 */     this.two = two;
/*    */   }
/*    */   
/*    */   public void processFields(Fieldable[] fields, int count) throws IOException {
/* 36 */     this.one.processFields(fields, count);
/* 37 */     this.two.processFields(fields, count);
/*    */   }
/*    */   
/*    */   public void abort() {
/*    */     try {
/* 42 */       this.one.abort();
/*    */     } finally {
/* 44 */       this.two.abort();
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldConsumersPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldConsumersPerThread,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class DocFieldConsumersPerThread
/*    */   extends DocFieldConsumerPerThread
/*    */ {
/*    */   final DocFieldConsumerPerThread one;
/*    */   final DocFieldConsumerPerThread two;
/*    */   final DocFieldConsumers parent;
/*    */   final DocumentsWriter.DocState docState;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public DocFieldConsumersPerThread(DocFieldProcessorPerThread docFieldProcessorPerThread, DocFieldConsumers parent, DocFieldConsumerPerThread one, DocFieldConsumerPerThread two) {
/* 31 */     this.parent = parent;
/* 32 */     this.one = one;
/* 33 */     this.two = two;
/* 34 */     this.docState = docFieldProcessorPerThread.docState;
/*    */   }
/*    */   
/*    */   public void startDocument() throws IOException {
/* 38 */     this.one.startDocument();
/* 39 */     this.two.startDocument();
/*    */   }
/*    */   
/*    */   public void abort() {
/*    */     try {
/* 44 */       this.one.abort();
/*    */     } finally {
/* 46 */       this.two.abort();
/*    */     } 
/*    */   }
/*    */   
/*    */   public DocumentsWriter.DocWriter finishDocument() throws IOException {
/* 51 */     DocumentsWriter.DocWriter oneDoc = this.one.finishDocument();
/* 52 */     DocumentsWriter.DocWriter twoDoc = this.two.finishDocument();
/* 53 */     if (oneDoc == null)
/* 54 */       return twoDoc; 
/* 55 */     if (twoDoc == null) {
/* 56 */       return oneDoc;
/*    */     }
/* 58 */     DocFieldConsumers.PerDoc both = this.parent.getPerDoc();
/* 59 */     both.docID = this.docState.docID;
/* 60 */     assert oneDoc.docID == this.docState.docID;
/* 61 */     assert twoDoc.docID == this.docState.docID;
/* 62 */     both.one = oneDoc;
/* 63 */     both.two = twoDoc;
/* 64 */     return both;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 69 */   public DocFieldConsumerPerField addField(FieldInfo fi) { return new DocFieldConsumersPerField(this, this.one.addField(fi), this.two.addField(fi)); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldConsumersPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldProcessor,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Collection;
/*    */ import java.util.HashMap;
/*    */ import java.util.Iterator;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class DocFieldProcessor
/*    */   extends DocConsumer
/*    */ {
/*    */   final DocumentsWriter docWriter;
/* 37 */   final FieldInfos fieldInfos = new FieldInfos();
/*    */   final DocFieldConsumer consumer;
/*    */   
/*    */   public DocFieldProcessor(DocumentsWriter docWriter, DocFieldConsumer consumer) {
/* 41 */     this.docWriter = docWriter;
/* 42 */     this.consumer = consumer;
/* 43 */     consumer.setFieldInfos(this.fieldInfos);
/*    */   }
/*    */ 
/*    */   
/* 47 */   public void closeDocStore(DocumentsWriter.FlushState state) throws IOException { this.consumer.closeDocStore(state); }
/*    */ 
/*    */ 
/*    */   
/*    */   public void flush(Collection threads, DocumentsWriter.FlushState state) throws IOException {
/* 52 */     Map childThreadsAndFields = new HashMap();
/* 53 */     Iterator it = threads.iterator();
/* 54 */     while (it.hasNext()) {
/* 55 */       DocFieldProcessorPerThread perThread = it.next();
/* 56 */       childThreadsAndFields.put(perThread.consumer, perThread.fields());
/* 57 */       perThread.trimFields(state);
/*    */     } 
/*    */     
/* 60 */     this.consumer.flush(childThreadsAndFields, state);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */     
/* 66 */     this.fieldInfos.write(state.directory, state.segmentName + "".fnm"");
/*    */   }
/*    */ 
/*    */   
/* 70 */   public void abort() { this.consumer.abort(); }
/*    */ 
/*    */ 
/*    */   
/* 74 */   public boolean freeRAM() { return this.consumer.freeRAM(); }
/*    */ 
/*    */ 
/*    */   
/* 78 */   public DocConsumerPerThread addThread(DocumentsWriterThreadState threadState) throws IOException { return new DocFieldProcessorPerThread(threadState, this); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldProcessor.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldProcessorPerField,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import org.apache.lucene.document.Fieldable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class DocFieldProcessorPerField
/*    */ {
/*    */   final DocFieldConsumerPerField consumer;
/*    */   final FieldInfo fieldInfo;
/*    */   DocFieldProcessorPerField next;
/* 32 */   int lastGen = -1;
/*    */   
/*    */   int fieldCount;
/* 35 */   Fieldable[] fields = new Fieldable[1];
/*    */   
/*    */   public DocFieldProcessorPerField(DocFieldProcessorPerThread perThread, FieldInfo fieldInfo) {
/* 38 */     this.consumer = perThread.consumer.addField(fieldInfo);
/* 39 */     this.fieldInfo = fieldInfo;
/*    */   }
/*    */ 
/*    */   
/* 43 */   public void abort() { this.consumer.abort(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldProcessorPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocFieldProcessorPerThread,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.HashSet;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class DocFieldProcessorPerThread
/*     */   extends DocConsumerPerThread
/*     */ {
/*     */   float docBoost;
/*     */   int fieldGen;
/*     */   final DocFieldProcessor docFieldProcessor;
/*     */   final FieldInfos fieldInfos;
/*     */   final DocFieldConsumerPerThread consumer;
/*  45 */   DocFieldProcessorPerField[] fields = new DocFieldProcessorPerField[1];
/*     */   
/*     */   int fieldCount;
/*     */   
/*  49 */   DocFieldProcessorPerField[] fieldHash = new DocFieldProcessorPerField[2];
/*  50 */   int hashMask = 1;
/*     */   int totalFieldCount;
/*     */   final DocumentsWriter.DocState docState;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public DocFieldProcessorPerThread(DocumentsWriterThreadState threadState, DocFieldProcessor docFieldProcessor) throws IOException {
/*  56 */     this.docState = threadState.docState;
/*  57 */     this.docFieldProcessor = docFieldProcessor;
/*  58 */     this.fieldInfos = docFieldProcessor.fieldInfos;
/*  59 */     this.consumer = docFieldProcessor.consumer.addThread(this);
/*     */   }
/*     */   
/*     */   public void abort() {
/*  63 */     for (int i = 0; i < this.fieldHash.length; i++) {
/*  64 */       DocFieldProcessorPerField field = this.fieldHash[i];
/*  65 */       while (field != null) {
/*  66 */         DocFieldProcessorPerField next = field.next;
/*  67 */         field.abort();
/*  68 */         field = next;
/*     */       } 
/*     */     } 
/*  71 */     this.consumer.abort();
/*     */   }
/*     */   
/*     */   public Collection fields() {
/*  75 */     Collection fields = new HashSet();
/*  76 */     for (int i = 0; i < this.fieldHash.length; i++) {
/*  77 */       DocFieldProcessorPerField field = this.fieldHash[i];
/*  78 */       while (field != null) {
/*  79 */         fields.add(field.consumer);
/*  80 */         field = field.next;
/*     */       } 
/*     */     } 
/*  83 */     assert fields.size() == this.totalFieldCount;
/*  84 */     return fields;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void trimFields(DocumentsWriter.FlushState state) {
/*  92 */     for (int i = 0; i < this.fieldHash.length; i++) {
/*  93 */       DocFieldProcessorPerField perField = this.fieldHash[i];
/*  94 */       DocFieldProcessorPerField lastPerField = null;
/*     */       
/*  96 */       while (perField != null) {
/*     */         
/*  98 */         if (perField.lastGen == -1) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 104 */           if (lastPerField == null) {
/* 105 */             this.fieldHash[i] = perField.next;
/*     */           } else {
/* 107 */             lastPerField.next = perField.next;
/*     */           } 
/* 109 */           if (state.docWriter.infoStream != null) {
/* 110 */             state.docWriter.infoStream.println(""  purge field="" + perField.fieldInfo.name);
/*     */           }
/* 112 */           this.totalFieldCount--;
/*     */         }
/*     */         else {
/*     */           
/* 116 */           perField.lastGen = -1;
/* 117 */           lastPerField = perField;
/*     */         } 
/*     */         
/* 120 */         perField = perField.next;
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void rehash() {
/* 126 */     int newHashSize = this.fieldHash.length * 2;
/* 127 */     assert newHashSize > this.fieldHash.length;
/*     */     
/* 129 */     DocFieldProcessorPerField[] newHashArray = new DocFieldProcessorPerField[newHashSize];
/*     */ 
/*     */     
/* 132 */     int newHashMask = newHashSize - 1;
/* 133 */     for (int j = 0; j < this.fieldHash.length; j++) {
/* 134 */       DocFieldProcessorPerField fp0 = this.fieldHash[j];
/* 135 */       while (fp0 != null) {
/* 136 */         int hashPos2 = fp0.fieldInfo.name.hashCode() & newHashMask;
/* 137 */         DocFieldProcessorPerField nextFP0 = fp0.next;
/* 138 */         fp0.next = newHashArray[hashPos2];
/* 139 */         newHashArray[hashPos2] = fp0;
/* 140 */         fp0 = nextFP0;
/*     */       } 
/*     */     } 
/*     */     
/* 144 */     this.fieldHash = newHashArray;
/* 145 */     this.hashMask = newHashMask;
/*     */   }
/*     */ 
/*     */   
/*     */   public DocumentsWriter.DocWriter processDocument() throws IOException {
/* 150 */     this.consumer.startDocument();
/* 151 */     Document doc = this.docState.doc;
/*     */     
/* 153 */     assert this.docFieldProcessor.docWriter.writer.testPoint(""DocumentsWriter.ThreadState.init start"");
/*     */     
/* 155 */     this.fieldCount = 0;
/*     */     
/* 157 */     int thisFieldGen = this.fieldGen++;
/*     */     
/* 159 */     List docFields = doc.getFields();
/* 160 */     int numDocFields = docFields.size();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 167 */     for (int i = 0; i < numDocFields; i++) {
/* 168 */       Fieldable field = docFields.get(i);
/* 169 */       String fieldName = field.name();
/*     */ 
/*     */       
/* 172 */       int hashPos = fieldName.hashCode() & this.hashMask;
/* 173 */       DocFieldProcessorPerField fp = this.fieldHash[hashPos];
/* 174 */       while (fp != null && !fp.fieldInfo.name.equals(fieldName)) {
/* 175 */         fp = fp.next;
/*     */       }
/* 177 */       if (fp == null) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 184 */         FieldInfo fi = this.fieldInfos.add(fieldName, field.isIndexed(), field.isTermVectorStored(), field.isStorePositionWithTermVector(), field.isStoreOffsetWithTermVector(), field.getOmitNorms(), false, field.getOmitTf());
/*     */ 
/*     */ 
/*     */         
/* 188 */         fp = new DocFieldProcessorPerField(this, fi);
/* 189 */         fp.next = this.fieldHash[hashPos];
/* 190 */         this.fieldHash[hashPos] = fp;
/* 191 */         this.totalFieldCount++;
/*     */         
/* 193 */         if (this.totalFieldCount >= this.fieldHash.length / 2)
/* 194 */           rehash(); 
/*     */       } else {
/* 196 */         fp.fieldInfo.update(field.isIndexed(), field.isTermVectorStored(), field.isStorePositionWithTermVector(), field.isStoreOffsetWithTermVector(), field.getOmitNorms(), false, field.getOmitTf());
/*     */       } 
/*     */ 
/*     */       
/* 200 */       if (thisFieldGen != fp.lastGen) {
/*     */ 
/*     */         
/* 203 */         fp.fieldCount = 0;
/*     */         
/* 205 */         if (this.fieldCount == this.fields.length) {
/* 206 */           int newSize = this.fields.length * 2;
/* 207 */           DocFieldProcessorPerField[] newArray = new DocFieldProcessorPerField[newSize];
/* 208 */           System.arraycopy(this.fields, 0, newArray, 0, this.fieldCount);
/* 209 */           this.fields = newArray;
/*     */         } 
/*     */         
/* 212 */         this.fields[this.fieldCount++] = fp;
/* 213 */         fp.lastGen = thisFieldGen;
/*     */       } 
/*     */       
/* 216 */       if (fp.fieldCount == fp.fields.length) {
/* 217 */         Fieldable[] newArray = new Fieldable[fp.fields.length * 2];
/* 218 */         System.arraycopy(fp.fields, 0, newArray, 0, fp.fieldCount);
/* 219 */         fp.fields = newArray;
/*     */       } 
/*     */       
/* 222 */       fp.fields[fp.fieldCount++] = field;
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 231 */     quickSort(this.fields, 0, this.fieldCount - 1);
/*     */     
/* 233 */     for (int i = 0; i < this.fieldCount; i++) {
/* 234 */       (this.fields[i]).consumer.processFields((this.fields[i]).fields, (this.fields[i]).fieldCount);
/*     */     }
/* 236 */     if (this.docState.maxTermPrefix != null && this.docState.infoStream != null) {
/* 237 */       this.docState.infoStream.println(""WARNING: document contains at least one immense term (longer than the max length 16383), all of which were skipped.  Please correct the analyzer to not produce such terms.  The prefix of the first immense term is: '"" + this.docState.maxTermPrefix + ""...'"");
/*     */     }
/* 239 */     return this.consumer.finishDocument();
/*     */   }
/*     */   
/*     */   void quickSort(DocFieldProcessorPerField[] array, int lo, int hi) {
/* 243 */     if (lo >= hi)
/*     */       return; 
/* 245 */     if (hi == 1 + lo) {
/* 246 */       if ((array[lo]).fieldInfo.name.compareTo((array[hi]).fieldInfo.name) > 0) {
/* 247 */         DocFieldProcessorPerField tmp = array[lo];
/* 248 */         array[lo] = array[hi];
/* 249 */         array[hi] = tmp;
/*     */       } 
/*     */       
/*     */       return;
/*     */     } 
/* 254 */     int mid = lo + hi >>> 1;
/*     */     
/* 256 */     if ((array[lo]).fieldInfo.name.compareTo((array[mid]).fieldInfo.name) > 0) {
/* 257 */       DocFieldProcessorPerField tmp = array[lo];
/* 258 */       array[lo] = array[mid];
/* 259 */       array[mid] = tmp;
/*     */     } 
/*     */     
/* 262 */     if ((array[mid]).fieldInfo.name.compareTo((array[hi]).fieldInfo.name) > 0) {
/* 263 */       DocFieldProcessorPerField tmp = array[mid];
/* 264 */       array[mid] = array[hi];
/* 265 */       array[hi] = tmp;
/*     */       
/* 267 */       if ((array[lo]).fieldInfo.name.compareTo((array[mid]).fieldInfo.name) > 0) {
/* 268 */         DocFieldProcessorPerField tmp2 = array[lo];
/* 269 */         array[lo] = array[mid];
/* 270 */         array[mid] = tmp2;
/*     */       } 
/*     */     } 
/*     */     
/* 274 */     int left = lo + 1;
/* 275 */     int right = hi - 1;
/*     */     
/* 277 */     if (left >= right) {
/*     */       return;
/*     */     }
/* 280 */     DocFieldProcessorPerField partition = array[mid];
/*     */     
/*     */     while (true) {
/* 283 */       while ((array[right]).fieldInfo.name.compareTo(partition.fieldInfo.name) > 0) {
/* 284 */         right--;
/*     */       }
/* 286 */       while (left < right && (array[left]).fieldInfo.name.compareTo(partition.fieldInfo.name) <= 0) {
/* 287 */         left++;
/*     */       }
/* 289 */       if (left < right) {
/* 290 */         DocFieldProcessorPerField tmp = array[left];
/* 291 */         array[left] = array[right];
/* 292 */         array[right] = tmp;
/* 293 */         right--;
/*     */         
/*     */         continue;
/*     */       } 
/*     */       break;
/*     */     } 
/* 299 */     quickSort(array, lo, left);
/* 300 */     quickSort(array, left + 1, hi);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocFieldProcessorPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocInverter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class DocInverter
/*     */   extends DocFieldConsumer
/*     */ {
/*     */   final InvertedDocConsumer consumer;
/*     */   final InvertedDocEndConsumer endConsumer;
/*     */   
/*     */   public DocInverter(InvertedDocConsumer consumer, InvertedDocEndConsumer endConsumer) {
/*  37 */     this.consumer = consumer;
/*  38 */     this.endConsumer = endConsumer;
/*     */   }
/*     */   
/*     */   void setFieldInfos(FieldInfos fieldInfos) {
/*  42 */     super.setFieldInfos(fieldInfos);
/*  43 */     this.consumer.setFieldInfos(fieldInfos);
/*  44 */     this.endConsumer.setFieldInfos(fieldInfos);
/*     */   }
/*     */ 
/*     */   
/*     */   void flush(Map threadsAndFields, DocumentsWriter.FlushState state) throws IOException {
/*  49 */     Map childThreadsAndFields = new HashMap();
/*  50 */     Map endChildThreadsAndFields = new HashMap();
/*     */     
/*  52 */     Iterator it = threadsAndFields.entrySet().iterator();
/*  53 */     while (it.hasNext()) {
/*     */       
/*  55 */       Map.Entry entry = it.next();
/*     */       
/*  57 */       DocInverterPerThread perThread = (DocInverterPerThread)entry.getKey();
/*     */       
/*  59 */       Collection fields = (Collection)entry.getValue();
/*     */       
/*  61 */       Iterator fieldsIt = fields.iterator();
/*  62 */       Collection childFields = new HashSet();
/*  63 */       Collection endChildFields = new HashSet();
/*  64 */       while (fieldsIt.hasNext()) {
/*  65 */         DocInverterPerField perField = fieldsIt.next();
/*  66 */         childFields.add(perField.consumer);
/*  67 */         endChildFields.add(perField.endConsumer);
/*     */       } 
/*     */       
/*  70 */       childThreadsAndFields.put(perThread.consumer, childFields);
/*  71 */       endChildThreadsAndFields.put(perThread.endConsumer, endChildFields);
/*     */     } 
/*     */     
/*  74 */     this.consumer.flush(childThreadsAndFields, state);
/*  75 */     this.endConsumer.flush(endChildThreadsAndFields, state);
/*     */   }
/*     */   
/*     */   public void closeDocStore(DocumentsWriter.FlushState state) throws IOException {
/*  79 */     this.consumer.closeDocStore(state);
/*  80 */     this.endConsumer.closeDocStore(state);
/*     */   }
/*     */   
/*     */   void abort() {
/*  84 */     this.consumer.abort();
/*  85 */     this.endConsumer.abort();
/*     */   }
/*     */ 
/*     */   
/*  89 */   public boolean freeRAM() { return this.consumer.freeRAM(); }
/*     */ 
/*     */ 
/*     */   
/*  93 */   public DocFieldConsumerPerThread addThread(DocFieldProcessorPerThread docFieldProcessorPerThread) { return new DocInverterPerThread(docFieldProcessorPerThread, this); }
/*     */   
/*     */   static final class FieldInvertState
/*     */   {
/*     */     int position;
/*     */     int length;
/*     */     int offset;
/*     */     float boost;
/*     */     
/*     */     void reset(float docBoost) {
/* 103 */       this.position = 0;
/* 104 */       this.length = 0;
/* 105 */       this.offset = 0;
/* 106 */       this.boost = docBoost;
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocInverter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocInverterPerField,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class DocInverterPerField
/*     */   extends DocFieldConsumerPerField
/*     */ {
/*     */   private final DocInverterPerThread perThread;
/*     */   private final FieldInfo fieldInfo;
/*     */   final InvertedDocConsumerPerField consumer;
/*     */   final InvertedDocEndConsumerPerField endConsumer;
/*     */   final DocumentsWriter.DocState docState;
/*     */   final DocInverter.FieldInvertState fieldState;
/*     */   
/*     */   public DocInverterPerField(DocInverterPerThread perThread, FieldInfo fieldInfo) {
/*  45 */     this.perThread = perThread;
/*  46 */     this.fieldInfo = fieldInfo;
/*  47 */     this.docState = perThread.docState;
/*  48 */     this.fieldState = perThread.fieldState;
/*  49 */     this.consumer = perThread.consumer.addField(this, fieldInfo);
/*  50 */     this.endConsumer = perThread.endConsumer.addField(this, fieldInfo);
/*     */   }
/*     */   
/*     */   void abort() {
/*  54 */     this.consumer.abort();
/*  55 */     this.endConsumer.abort();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void processFields(Fieldable[] fields, int count) throws IOException {
/*  61 */     this.fieldState.reset(this.docState.doc.getBoost());
/*     */     
/*  63 */     int maxFieldLength = this.docState.maxFieldLength;
/*     */     
/*  65 */     boolean doInvert = this.consumer.start(fields, count);
/*     */     
/*  67 */     for (int i = 0; i < count; i++) {
/*     */       
/*  69 */       Fieldable field = fields[i];
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  74 */       if (field.isIndexed() && doInvert) {
/*     */         
/*  76 */         if (this.fieldState.length > 0) {
/*  77 */           this.fieldState.position += this.docState.analyzer.getPositionIncrementGap(this.fieldInfo.name);
/*     */         }
/*  79 */         if (!field.isTokenized()) {
/*  80 */           String stringValue = field.stringValue();
/*  81 */           int valueLength = stringValue.length();
/*  82 */           Token token = this.perThread.localToken.reinit(stringValue, this.fieldState.offset, this.fieldState.offset + valueLength);
/*  83 */           boolean success = false;
/*     */           try {
/*  85 */             this.consumer.add(token);
/*  86 */             success = true;
/*     */           } finally {
/*  88 */             if (!success)
/*  89 */               this.docState.docWriter.setAborting(); 
/*     */           } 
/*  91 */           this.fieldState.offset += valueLength;
/*  92 */           this.fieldState.length++;
/*  93 */           this.fieldState.position++;
/*     */         } else {
/*     */           
/*  96 */           TokenStream stream, streamValue = field.tokenStreamValue();
/*     */           
/*  98 */           if (streamValue != null) {
/*  99 */             stream = streamValue;
/*     */           
/*     */           }
/*     */           else {
/*     */             
/* 104 */             Reader reader, readerValue = field.readerValue();
/*     */             
/* 106 */             if (readerValue != null) {
/* 107 */               reader = readerValue;
/*     */             } else {
/* 109 */               String stringValue = field.stringValue();
/* 110 */               if (stringValue == null)
/* 111 */                 throw new IllegalArgumentException(""field must have either TokenStream, String or Reader value""); 
/* 112 */               this.perThread.stringReader.init(stringValue);
/* 113 */               reader = this.perThread.stringReader;
/*     */             } 
/*     */ 
/*     */             
/* 117 */             stream = this.docState.analyzer.reusableTokenStream(this.fieldInfo.name, reader);
/*     */           } 
/*     */ 
/*     */           
/* 121 */           stream.reset();
/*     */           
/*     */           try {
/* 124 */             int offsetEnd = this.fieldState.offset - 1;
/* 125 */             Token localToken = this.perThread.localToken;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/*     */             while (true) {
/* 134 */               Token token = stream.next(localToken);
/*     */               
/* 136 */               if (token == null)
/* 137 */                 break;  this.fieldState.position += token.getPositionIncrement() - 1;
/* 138 */               boolean success = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */               
/*     */               try {
/* 146 */                 this.consumer.add(token);
/* 147 */                 success = true;
/*     */               } finally {
/* 149 */                 if (!success)
/* 150 */                   this.docState.docWriter.setAborting(); 
/*     */               } 
/* 152 */               this.fieldState.position++;
/* 153 */               offsetEnd = this.fieldState.offset + token.endOffset();
/* 154 */               if (++this.fieldState.length >= maxFieldLength) {
/* 155 */                 if (this.docState.infoStream != null)
/* 156 */                   this.docState.infoStream.println(""maxFieldLength "" + maxFieldLength + "" reached for field "" + this.fieldInfo.name + "", ignoring following tokens""); 
/*     */                 break;
/*     */               } 
/*     */             } 
/* 160 */             this.fieldState.offset = offsetEnd + 1;
/*     */           } finally {
/* 162 */             stream.close();
/*     */           } 
/*     */         } 
/*     */         
/* 166 */         this.fieldState.boost *= field.getBoost();
/*     */       } 
/*     */     } 
/*     */     
/* 170 */     this.consumer.finish();
/* 171 */     this.endConsumer.finish();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocInverterPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocInverterPerThread,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.analysis.Token;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class DocInverterPerThread
/*    */   extends DocFieldConsumerPerThread
/*    */ {
/*    */   final DocInverter docInverter;
/*    */   final InvertedDocConsumerPerThread consumer;
/*    */   final InvertedDocEndConsumerPerThread endConsumer;
/* 32 */   final Token localToken = new Token();
/*    */   
/*    */   final DocumentsWriter.DocState docState;
/* 35 */   final DocInverter.FieldInvertState fieldState = new DocInverter.FieldInvertState();
/*    */ 
/*    */   
/* 38 */   final ReusableStringReader stringReader = new ReusableStringReader();
/*    */   
/*    */   public DocInverterPerThread(DocFieldProcessorPerThread docFieldProcessorPerThread, DocInverter docInverter) {
/* 41 */     this.docInverter = docInverter;
/* 42 */     this.docState = docFieldProcessorPerThread.docState;
/* 43 */     this.consumer = docInverter.consumer.addThread(this);
/* 44 */     this.endConsumer = docInverter.endConsumer.addThread(this);
/*    */   }
/*    */   
/*    */   public void startDocument() throws IOException {
/* 48 */     this.consumer.startDocument();
/* 49 */     this.endConsumer.startDocument();
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public DocumentsWriter.DocWriter finishDocument() throws IOException {
/* 55 */     this.endConsumer.finishDocument();
/* 56 */     return this.consumer.finishDocument();
/*    */   }
/*    */   
/*    */   void abort() {
/*    */     try {
/* 61 */       this.consumer.abort();
/*    */     } finally {
/* 63 */       this.endConsumer.abort();
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 68 */   public DocFieldConsumerPerField addField(FieldInfo fi) { return new DocInverterPerField(this, fi); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocInverterPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocumentsWriter,"/*      */ package org.apache.lucene.index;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ import java.text.NumberFormat;
/*      */ import java.util.ArrayList;
/*      */ import java.util.Collection;
/*      */ import java.util.HashMap;
/*      */ import java.util.HashSet;
/*      */ import java.util.Iterator;
/*      */ import java.util.List;
/*      */ import java.util.Map;
/*      */ import org.apache.lucene.analysis.Analyzer;
/*      */ import org.apache.lucene.document.Document;
/*      */ import org.apache.lucene.search.IndexSearcher;
/*      */ import org.apache.lucene.search.Query;
/*      */ import org.apache.lucene.search.Scorer;
/*      */ import org.apache.lucene.search.Searcher;
/*      */ import org.apache.lucene.search.Similarity;
/*      */ import org.apache.lucene.search.Weight;
/*      */ import org.apache.lucene.store.AlreadyClosedException;
/*      */ import org.apache.lucene.store.Directory;
/*      */ import org.apache.lucene.util.ArrayUtil;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ final class DocumentsWriter
/*      */ {
/*      */   IndexWriter writer;
/*      */   Directory directory;
/*      */   String segment;
/*      */   private String docStoreSegment;
/*      */   private int docStoreOffset;
/*      */   private int nextDocID;
/*      */   private int numDocsInRAM;
/*      */   int numDocsInStore;
/*      */   private static final int MAX_THREAD_STATE = 5;
/*  126 */   private DocumentsWriterThreadState[] threadStates = new DocumentsWriterThreadState[0];
/*  127 */   private final HashMap threadBindings = new HashMap();
/*      */   
/*      */   private int pauseThreads;
/*      */   
/*      */   boolean flushPending;
/*      */   
/*      */   boolean bufferIsFull;
/*      */   
/*      */   private boolean aborting;
/*      */   private DocFieldProcessor docFieldProcessor;
/*      */   PrintStream infoStream;
/*  138 */   int maxFieldLength = 10000;
/*      */   
/*      */   Similarity similarity;
/*      */   List newFiles;
/*      */   final DocConsumer consumer;
/*      */   
/*      */   static class DocState
/*      */   {
/*      */     DocumentsWriter docWriter;
/*      */     Analyzer analyzer;
/*      */     int maxFieldLength;
/*      */     PrintStream infoStream;
/*      */     Similarity similarity;
/*      */     int docID;
/*      */     Document doc;
/*      */     String maxTermPrefix;
/*      */     
/*  155 */     public boolean testPoint(String name) { return this.docWriter.writer.testPoint(name); }
/*      */   }
/*      */ 
/*      */   
/*      */   static class FlushState
/*      */   {
/*      */     DocumentsWriter docWriter;
/*      */     Directory directory;
/*      */     String segmentName;
/*      */     String docStoreSegmentName;
/*      */     int numDocsInRAM;
/*      */     int numDocsInStore;
/*      */     Collection flushedFiles;
/*      */     
/*  169 */     public String segmentFileName(String ext) { return this.segmentName + ""."" + ext; }
/*      */   }
/*      */ 
/*      */   
/*      */   static abstract class DocWriter
/*      */   {
/*      */     DocWriter next;
/*      */     int docID;
/*      */     
/*      */     abstract void finish() throws IOException;
/*      */     
/*      */     abstract void abort();
/*      */     
/*      */     abstract long sizeInBytes();
/*      */     
/*  184 */     void setNext(DocWriter next) { this.next = next; }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  192 */   private BufferedDeletes deletesInRAM = new BufferedDeletes();
/*      */ 
/*      */ 
/*      */   
/*  196 */   private BufferedDeletes deletesFlushed = new BufferedDeletes();
/*      */ 
/*      */ 
/*      */   
/*  200 */   private int maxBufferedDeleteTerms = -1;
/*      */ 
/*      */ 
/*      */   
/*  204 */   private long ramBufferSize = 16777216L;
/*  205 */   private long waitQueuePauseBytes = (long)(this.ramBufferSize * 0.1D);
/*  206 */   private long waitQueueResumeBytes = (long)(this.ramBufferSize * 0.05D);
/*      */ 
/*      */ 
/*      */   
/*  210 */   private long freeTrigger = 17616076L;
/*  211 */   private long freeLevel = 15938355L;
/*      */ 
/*      */ 
/*      */   
/*  215 */   private int maxBufferedDocs = -1; private int flushedDocCount; private boolean closed; private Collection abortedFiles; private FlushState flushState; final List openFiles; final List closedFiles; final SkipDocWriter skipDocWriter; long numBytesAlloc; long numBytesUsed; NumberFormat nf; static final int OBJECT_HEADER_BYTES = 8; static final int POINTER_NUM_BYTE = 4; static final int INT_NUM_BYTE = 4; static final int CHAR_NUM_BYTE = 2; static final int BYTE_BLOCK_SHIFT = 15; static final int BYTE_BLOCK_SIZE = 32768; static final int BYTE_BLOCK_MASK = 32767; static final int BYTE_BLOCK_NOT_MASK = -32768; static final int INT_BLOCK_SHIFT = 13; static final int INT_BLOCK_SIZE = 8192; static final int INT_BLOCK_MASK = 8191; private ArrayList freeIntBlocks; ByteBlockAllocator byteBlockAllocator; static final int CHAR_BLOCK_SHIFT = 14; static final int CHAR_BLOCK_SIZE = 16384; static final int CHAR_BLOCK_MASK = 16383; static final int MAX_TERM_LENGTH = 16383;
/*      */   private ArrayList freeCharBlocks;
/*      */   final WaitQueue waitQueue;
/*      */   static final boolean $assertionsDisabled;
/*      */   
/*  220 */   synchronized void updateFlushedDocCount(int n) { this.flushedDocCount += n; }
/*      */ 
/*      */   
/*  223 */   synchronized int getFlushedDocCount() { return this.flushedDocCount; }
/*      */ 
/*      */   
/*  226 */   synchronized void setFlushedDocCount(int n) { this.flushedDocCount = n; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  272 */   boolean hasProx() { return this.docFieldProcessor.fieldInfos.hasProx(); }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   synchronized void setInfoStream(PrintStream infoStream) {
/*  278 */     this.infoStream = infoStream;
/*  279 */     for (int i = 0; i < this.threadStates.length; i++)
/*  280 */       (this.threadStates[i]).docState.infoStream = infoStream; 
/*      */   }
/*      */   
/*      */   synchronized void setMaxFieldLength(int maxFieldLength) {
/*  284 */     this.maxFieldLength = maxFieldLength;
/*  285 */     for (int i = 0; i < this.threadStates.length; i++)
/*  286 */       (this.threadStates[i]).docState.maxFieldLength = maxFieldLength; 
/*      */   }
/*      */   
/*      */   synchronized void setSimilarity(Similarity similarity) {
/*  290 */     this.similarity = similarity;
/*  291 */     for (int i = 0; i < this.threadStates.length; i++) {
/*  292 */       (this.threadStates[i]).docState.similarity = similarity;
/*      */     }
/*      */   }
/*      */   
/*      */   synchronized void setRAMBufferSizeMB(double mb) {
/*  297 */     if (mb == -1.0D) {
/*  298 */       this.ramBufferSize = -1L;
/*  299 */       this.waitQueuePauseBytes = 4194304L;
/*  300 */       this.waitQueueResumeBytes = 2097152L;
/*      */     } else {
/*  302 */       this.ramBufferSize = (long)(mb * 1024.0D * 1024.0D);
/*  303 */       this.waitQueuePauseBytes = (long)(this.ramBufferSize * 0.1D);
/*  304 */       this.waitQueueResumeBytes = (long)(this.ramBufferSize * 0.05D);
/*  305 */       this.freeTrigger = (long)(1.05D * this.ramBufferSize);
/*  306 */       this.freeLevel = (long)(0.95D * this.ramBufferSize);
/*      */     } 
/*      */   }
/*      */   
/*      */   synchronized double getRAMBufferSizeMB() {
/*  311 */     if (this.ramBufferSize == -1L) {
/*  312 */       return this.ramBufferSize;
/*      */     }
/*  314 */     return this.ramBufferSize / 1024.0D / 1024.0D;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  321 */   void setMaxBufferedDocs(int count) { this.maxBufferedDocs = count; }
/*      */ 
/*      */ 
/*      */   
/*  325 */   int getMaxBufferedDocs() { return this.maxBufferedDocs; }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  330 */   String getSegment() { return this.segment; }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  335 */   int getNumDocsInRAM() { return this.numDocsInRAM; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  342 */   synchronized String getDocStoreSegment() { return this.docStoreSegment; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  348 */   int getDocStoreOffset() { return this.docStoreOffset; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   synchronized String closeDocStore() throws IOException {
/*  356 */     assert allThreadsIdle();
/*      */     
/*  358 */     if (this.infoStream != null) {
/*  359 */       message(""closeDocStore: "" + this.openFiles.size() + "" files to flush to segment "" + this.docStoreSegment + "" numDocs="" + this.numDocsInStore);
/*      */     }
/*  361 */     boolean success = false;
/*      */     
/*      */     try {
/*  364 */       initFlushState(true);
/*  365 */       this.closedFiles.clear();
/*      */       
/*  367 */       this.consumer.closeDocStore(this.flushState);
/*  368 */       assert 0 == this.openFiles.size();
/*      */       
/*  370 */       String s = this.docStoreSegment;
/*  371 */       this.docStoreSegment = null;
/*  372 */       this.docStoreOffset = 0;
/*  373 */       this.numDocsInStore = 0;
/*  374 */       success = true;
/*  375 */       return s;
/*      */     } finally {
/*  377 */       if (!success) {
/*  378 */         abort();
/*      */       }
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  388 */   Collection abortedFiles() { return this.abortedFiles; }
/*      */ 
/*      */ 
/*      */   
/*  392 */   void message(String message) { this.writer.message(""DW: "" + message); }
/*      */   synchronized List openFiles() { return (List)((ArrayList)this.openFiles).clone(); }
/*      */   synchronized List closedFiles() { return (List)((ArrayList)this.closedFiles).clone(); }
/*  395 */   synchronized void addOpenFile(String name) { assert !this.openFiles.contains(name); this.openFiles.add(name); } synchronized void removeOpenFile(String name) { assert this.openFiles.contains(name); this.openFiles.remove(name); this.closedFiles.add(name); } synchronized void setAborting() { this.aborting = true; } synchronized void abort() throws IOException { try { message(""docWriter: now abort""); this.waitQueue.abort(); pauseAllThreads(); try { assert 0 == this.waitQueue.numWaiting; this.waitQueue.waitingBytes = 0L; try { this.abortedFiles = openFiles(); } catch (Throwable t) { this.abortedFiles = null; }  this.deletesInRAM.clear(); this.openFiles.clear(); for (int i = 0; i < this.threadStates.length; i++) { try { (this.threadStates[i]).consumer.abort(); } catch (Throwable t) {} }  try { this.consumer.abort(); } catch (Throwable t) {} this.docStoreSegment = null; this.numDocsInStore = 0; this.docStoreOffset = 0; doAfterFlush(); } finally { resumeAllThreads(); }  } finally { this.aborting = false; notifyAll(); }  } private void doAfterFlush() throws IOException { assert allThreadsIdle(); this.threadBindings.clear(); this.waitQueue.reset(); this.segment = null; this.numDocsInRAM = 0; this.nextDocID = 0; this.bufferIsFull = false; this.flushPending = false; for (int i = 0; i < this.threadStates.length; i++) this.threadStates[i].doAfterFlush();  this.numBytesUsed = 0L; } synchronized boolean pauseAllThreads() { this.pauseThreads++; while (!allThreadsIdle()) { try { wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }  }  return this.aborting; } synchronized void resumeAllThreads() { this.pauseThreads--; assert this.pauseThreads >= 0; if (0 == this.pauseThreads) notifyAll();  } private synchronized boolean allThreadsIdle() { for (int i = 0; i < this.threadStates.length; i++) { if (!(this.threadStates[i]).isIdle) return false;  }  return true; } private synchronized void initFlushState(boolean onlyDocStore) { initSegmentName(onlyDocStore); if (this.flushState == null) { this.flushState = new FlushState(); this.flushState.directory = this.directory; this.flushState.docWriter = this; }  this.flushState.docStoreSegmentName = this.docStoreSegment; this.flushState.segmentName = this.segment; this.flushState.numDocsInRAM = this.numDocsInRAM; this.flushState.numDocsInStore = this.numDocsInStore; this.flushState.flushedFiles = new HashSet(); } synchronized int flush(boolean closeDocStore) throws IOException { assert allThreadsIdle(); assert this.numDocsInRAM > 0; assert this.nextDocID == this.numDocsInRAM; assert this.waitQueue.numWaiting == 0; assert this.waitQueue.waitingBytes == 0L; initFlushState(false); this.docStoreOffset = this.numDocsInStore; if (this.infoStream != null) message(""flush postings as segment "" + this.flushState.segmentName + "" numDocs="" + this.numDocsInRAM);  boolean success = false; try { if (closeDocStore) { assert this.flushState.docStoreSegmentName != null; assert this.flushState.docStoreSegmentName.equals(this.flushState.segmentName); closeDocStore(); this.flushState.numDocsInStore = 0; }  Collection threads = new HashSet(); for (int i = 0; i < this.threadStates.length; i++) threads.add((this.threadStates[i]).consumer);  this.consumer.flush(threads, this.flushState); if (this.infoStream != null) { long newSegmentSize = segmentSize(this.flushState.segmentName); String message = ""  oldRAMSize="" + this.numBytesUsed + "" newFlushedSize="" + newSegmentSize + "" docs/MB="" + this.nf.format(this.numDocsInRAM / newSegmentSize / 1024.0D / 1024.0D) + "" new/old="" + this.nf.format(100.0D * newSegmentSize / this.numBytesUsed) + ""%""; message(message); }  this.flushedDocCount += this.flushState.numDocsInRAM; doAfterFlush(); success = true; } finally { if (!success) abort();  }  assert this.waitQueue.waitingBytes == 0L; return this.flushState.numDocsInRAM; } void createCompoundFile(String segment) throws IOException { CompoundFileWriter cfsWriter = new CompoundFileWriter(this.directory, segment + ""."" + ""cfs""); Iterator it = this.flushState.flushedFiles.iterator(); while (it.hasNext()) cfsWriter.addFile(it.next());  cfsWriter.close(); } synchronized boolean setFlushPending() { if (this.flushPending) return false;  this.flushPending = true; return true; } synchronized void clearFlushPending() { this.flushPending = false; } synchronized void pushDeletes() { this.deletesFlushed.update(this.deletesInRAM); } synchronized void close() { this.closed = true; notifyAll(); } synchronized void initSegmentName(boolean onlyDocStore) { if (this.segment == null && (!onlyDocStore || this.docStoreSegment == null)) { this.segment = this.writer.newSegmentName(); assert this.numDocsInRAM == 0; }  if (this.docStoreSegment == null) { this.docStoreSegment = this.segment; assert this.numDocsInStore == 0; }  } synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException { DocumentsWriterThreadState state = (DocumentsWriterThreadState)this.threadBindings.get(Thread.currentThread()); if (state == null) { DocumentsWriterThreadState minThreadState = null; for (int i = 0; i < this.threadStates.length; i++) { DocumentsWriterThreadState ts = this.threadStates[i]; if (minThreadState == null || ts.numThreads < minThreadState.numThreads) minThreadState = ts;  }  if (minThreadState != null && (minThreadState.numThreads == 0 || this.threadStates.length >= 5)) { state = minThreadState; state.numThreads++; } else { DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1 + this.threadStates.length]; if (this.threadStates.length > 0) System.arraycopy(this.threadStates, 0, newArray, 0, this.threadStates.length);  state = newArray[this.threadStates.length] = new DocumentsWriterThreadState(this); this.threadStates = newArray; }  this.threadBindings.put(Thread.currentThread(), state); }  waitReady(state); initSegmentName(false); state.isIdle = false; boolean success = false; try { state.docState.docID = this.nextDocID; assert this.writer.testPoint(""DocumentsWriter.ThreadState.init start""); if (delTerm != null) { addDeleteTerm(delTerm, state.docState.docID); state.doFlushAfter = timeToFlushDeletes(); }  assert this.writer.testPoint(""DocumentsWriter.ThreadState.init after delTerm""); this.nextDocID++; this.numDocsInRAM++; if (!this.flushPending && this.maxBufferedDocs != -1 && this.numDocsInRAM >= this.maxBufferedDocs) { this.flushPending = true; state.doFlushAfter = true; }  success = true; } finally { if (!success) { state.isIdle = true; notifyAll(); if (state.doFlushAfter) { state.doFlushAfter = false; this.flushPending = false; }  }  }  return state; } boolean addDocument(Document doc, Analyzer analyzer) throws CorruptIndexException, IOException { return updateDocument(doc, analyzer, null); } boolean updateDocument(Term t, Document doc, Analyzer analyzer) throws CorruptIndexException, IOException { return updateDocument(doc, analyzer, t); } boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws CorruptIndexException, IOException { DocumentsWriterThreadState state = getThreadState(doc, delTerm); DocState docState = state.docState; docState.doc = doc; docState.analyzer = analyzer; boolean success = false; try { DocWriter perDoc = state.consumer.processDocument(); finishDocument(state, perDoc); success = true; } finally { if (!success) synchronized (this) { if (this.aborting) { state.isIdle = true; notifyAll(); abort(); } else { this.skipDocWriter.docID = docState.docID; boolean success2 = false; try { this.waitQueue.add(this.skipDocWriter); success2 = true; } finally { if (!success2) { state.isIdle = true; notifyAll(); abort(); return false; }  }  state.isIdle = true; notifyAll(); if (state.doFlushAfter) { state.doFlushAfter = false; this.flushPending = false; notifyAll(); }  addDeleteDocID(state.docState.docID); }  }   }  return (state.doFlushAfter || timeToFlushDeletes()); } synchronized int getNumBufferedDeleteTerms() { return this.deletesInRAM.numTerms; } synchronized HashMap getBufferedDeleteTerms() { return this.deletesInRAM.terms; } synchronized void remapDeletes(SegmentInfos infos, int[][] docMaps, int[] delCounts, MergePolicy.OneMerge merge, int mergeDocCount) { if (docMaps == null) return;  MergeDocIDRemapper mapper = new MergeDocIDRemapper(infos, docMaps, delCounts, merge, mergeDocCount); this.deletesInRAM.remap(mapper, infos, docMaps, delCounts, merge, mergeDocCount); this.deletesFlushed.remap(mapper, infos, docMaps, delCounts, merge, mergeDocCount); this.flushedDocCount -= mapper.docShift; } private synchronized void waitReady(DocumentsWriterThreadState state) { while (!this.closed && ((state != null && !state.isIdle) || this.pauseThreads != 0 || this.flushPending || this.aborting)) { try { wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }  }  if (this.closed) throw new AlreadyClosedException(""this IndexWriter is closed"");  } synchronized boolean bufferDeleteTerms(Term[] terms) throws IOException { waitReady(null); for (int i = 0; i < terms.length; i++) addDeleteTerm(terms[i], this.numDocsInRAM);  return timeToFlushDeletes(); } synchronized boolean bufferDeleteTerm(Term term) throws IOException { waitReady(null); addDeleteTerm(term, this.numDocsInRAM); return timeToFlushDeletes(); } DocumentsWriter(Directory directory, IndexWriter writer) throws IOException { this.openFiles = new ArrayList();
/*  396 */     this.closedFiles = new ArrayList();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1100 */     this.skipDocWriter = new SkipDocWriter();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1109 */     this.nf = NumberFormat.getInstance();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1184 */     this.freeIntBlocks = new ArrayList();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1223 */     this.byteBlockAllocator = new ByteBlockAllocator();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1233 */     this.freeCharBlocks = new ArrayList();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1361 */     this.waitQueue = new WaitQueue(); this.directory = directory; this.writer = writer; this.similarity = writer.getSimilarity(); this.flushedDocCount = writer.maxDoc(); TermsHashConsumer termVectorsWriter = new TermVectorsTermsWriter(this); TermsHashConsumer freqProxWriter = new FreqProxTermsWriter(); InvertedDocConsumer termsHash = new TermsHash(this, true, freqProxWriter, new TermsHash(this, false, termVectorsWriter, null)); NormsWriter normsWriter = new NormsWriter(); DocInverter docInverter = new DocInverter(termsHash, normsWriter); StoredFieldsWriter fieldsWriter = new StoredFieldsWriter(this); DocFieldConsumers docFieldConsumers = new DocFieldConsumers(docInverter, fieldsWriter); this.consumer = this.docFieldProcessor = new DocFieldProcessor(this, docFieldConsumers); }
/*      */   synchronized boolean bufferDeleteQueries(Query[] queries) throws IOException { waitReady(null); for (int i = 0; i < queries.length; i++) addDeleteQuery(queries[i], this.numDocsInRAM);  return timeToFlushDeletes(); }
/*      */   synchronized boolean bufferDeleteQuery(Query query) throws IOException { waitReady(null); addDeleteQuery(query, this.numDocsInRAM); return timeToFlushDeletes(); }
/*      */   synchronized boolean deletesFull() { return (this.maxBufferedDeleteTerms != -1 && this.deletesInRAM.numTerms + this.deletesInRAM.queries.size() + this.deletesInRAM.docIDs.size() >= this.maxBufferedDeleteTerms); }
/*      */   private synchronized boolean timeToFlushDeletes() { return ((this.bufferIsFull || deletesFull()) && setFlushPending()); }
/*      */   void setMaxBufferedDeleteTerms(int maxBufferedDeleteTerms) { this.maxBufferedDeleteTerms = maxBufferedDeleteTerms; }
/*      */   int getMaxBufferedDeleteTerms() { return this.maxBufferedDeleteTerms; } synchronized boolean hasDeletes() { return this.deletesFlushed.any(); } synchronized boolean applyDeletes(SegmentInfos infos) throws IOException { if (!hasDeletes()) return false;  if (this.infoStream != null) message(""apply "" + this.deletesFlushed.numTerms + "" buffered deleted terms and "" + this.deletesFlushed.docIDs.size() + "" deleted docIDs and "" + this.deletesFlushed.queries.size() + "" deleted queries on "" + infos.size() + "" segments."");  int infosEnd = infos.size(); int docStart = 0; boolean any = false; for (int i = 0; i < infosEnd; i++) { IndexReader reader = SegmentReader.get(infos.info(i), false); boolean success = false; try { any |= applyDeletes(reader, docStart); docStart += reader.maxDoc(); success = true; } finally { if (reader != null) try { if (success) reader.doCommit();  } finally { reader.doClose(); }   }  }  this.deletesFlushed.clear(); return any; } private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart) throws CorruptIndexException, IOException { int docEnd = docIDStart + reader.maxDoc(); boolean any = false; Iterator iter = this.deletesFlushed.terms.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = iter.next(); Term term = (Term)entry.getKey(); TermDocs docs = reader.termDocs(term); if (docs != null) { int limit = ((BufferedDeletes.Num)entry.getValue()).getNum(); try { while (docs.next()) { int docID = docs.doc(); if (docIDStart + docID >= limit) break;  reader.deleteDocument(docID); any = true; }  } finally { docs.close(); }  }  }  iter = this.deletesFlushed.docIDs.iterator(); while (iter.hasNext()) { int docID = ((Integer)iter.next()).intValue(); if (docID >= docIDStart && docID < docEnd) { reader.deleteDocument(docID - docIDStart); any = true; }  }  IndexSearcher searcher = new IndexSearcher(reader); iter = this.deletesFlushed.queries.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = iter.next(); Query query = (Query)entry.getKey(); int limit = ((Integer)entry.getValue()).intValue(); Weight weight = query.weight((Searcher)searcher); Scorer scorer = weight.scorer(reader); while (scorer.next()) { int docID = scorer.doc(); if (docIDStart + docID >= limit) break;  reader.deleteDocument(docID); any = true; }  }  searcher.close(); return any; } private synchronized void addDeleteTerm(Term term, int docCount) { BufferedDeletes.Num num = (BufferedDeletes.Num)this.deletesInRAM.terms.get(term); int docIDUpto = this.flushedDocCount + docCount; if (num == null) { this.deletesInRAM.terms.put(term, new BufferedDeletes.Num(docIDUpto)); } else { num.setNum(docIDUpto); }  this.deletesInRAM.numTerms++; } private synchronized void addDeleteDocID(int docID) { this.deletesInRAM.docIDs.add(new Integer(this.flushedDocCount + docID)); } private synchronized void addDeleteQuery(Query query, int docID) { this.deletesInRAM.queries.put(query, new Integer(this.flushedDocCount + docID)); } synchronized boolean doBalanceRAM() { return (this.ramBufferSize != -1L && !this.bufferIsFull && (this.numBytesUsed >= this.ramBufferSize || this.numBytesAlloc >= this.freeTrigger)); } private void finishDocument(DocumentsWriterThreadState perThread, DocWriter docWriter) throws IOException { if (doBalanceRAM()) balanceRAM();  synchronized (this) { boolean doPause; assert docWriter == null || docWriter.docID == perThread.docState.docID; if (this.aborting) { if (docWriter != null) try { docWriter.abort(); } catch (Throwable t) {}  perThread.isIdle = true; notifyAll(); return; }  if (docWriter != null) { doPause = this.waitQueue.add(docWriter); } else { this.skipDocWriter.docID = perThread.docState.docID; doPause = this.waitQueue.add(this.skipDocWriter); }  if (doPause) waitForWaitQueue();  if (this.bufferIsFull && !this.flushPending) { this.flushPending = true; perThread.doFlushAfter = true; }  perThread.isIdle = true; notifyAll(); }  } synchronized void waitForWaitQueue() { do { try { wait(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }  } while (!this.waitQueue.doResume()); } private static class SkipDocWriter extends DocWriter {
/*      */     private SkipDocWriter() {} void finish() {} void abort() {} long sizeInBytes() { return 0L; }
/*      */   } long getRAMUsed() { return this.numBytesUsed; } private long segmentSize(String segmentName) throws IOException { assert this.infoStream != null; long size = this.directory.fileLength(segmentName + "".tii"") + this.directory.fileLength(segmentName + "".tis"") + this.directory.fileLength(segmentName + "".frq"") + this.directory.fileLength(segmentName + "".prx""); String normFileName = segmentName + "".nrm""; if (this.directory.fileExists(normFileName)) size += this.directory.fileLength(normFileName);  return size; } private class ByteBlockAllocator extends ByteBlockPool.Allocator {
/*      */     ArrayList freeByteBlocks = new ArrayList(); static final boolean $assertionsDisabled; private final DocumentsWriter this$0; byte[] getByteBlock(boolean trackAllocations) { synchronized (DocumentsWriter.this) { byte[] b; int size = this.freeByteBlocks.size(); if (0 == size) { DocumentsWriter.this.numBytesAlloc += 32768L; b = new byte[32768]; } else { b = this.freeByteBlocks.remove(size - 1); }  if (trackAllocations) DocumentsWriter.this.numBytesUsed += 32768L;  assert DocumentsWriter.this.numBytesUsed <= DocumentsWriter.this.numBytesAlloc; return b; }  } void recycleByteBlocks(byte[][] blocks, int start, int end) { synchronized (DocumentsWriter.this) { for (int i = start; i < end; i++) this.freeByteBlocks.add(blocks[i]);  }  } private ByteBlockAllocator() {}
/* 1371 */   } synchronized int[] getIntBlock(boolean trackAllocations) { int b[], size = this.freeIntBlocks.size(); if (0 == size) { this.numBytesAlloc += 32768L; b = new int[8192]; } else { b = this.freeIntBlocks.remove(size - 1); }  if (trackAllocations) this.numBytesUsed += 32768L;  assert this.numBytesUsed <= this.numBytesAlloc; return b; } synchronized void bytesAllocated(long numBytes) { this.numBytesAlloc += numBytes; assert this.numBytesUsed <= this.numBytesAlloc; } synchronized void bytesUsed(long numBytes) { this.numBytesUsed += numBytes; assert this.numBytesUsed <= this.numBytesAlloc; } synchronized void recycleIntBlocks(int[][] blocks, int start, int end) { for (int i = start; i < end; i++) this.freeIntBlocks.add(blocks[i]);  } synchronized char[] getCharBlock() { char[] c; int size = this.freeCharBlocks.size(); if (0 == size) { this.numBytesAlloc += 32768L; c = new char[16384]; } else { c = this.freeCharBlocks.remove(size - 1); }  this.numBytesUsed += 32768L; assert this.numBytesUsed <= this.numBytesAlloc; return c; } synchronized void recycleCharBlocks(char[][] blocks, int numBlocks) { for (int i = 0; i < numBlocks; i++) this.freeCharBlocks.add(blocks[i]);  } String toMB(long v) { return this.nf.format(v / 1024.0D / 1024.0D); } void balanceRAM() { long flushTrigger = this.ramBufferSize; if (this.numBytesAlloc > this.freeTrigger) { if (this.infoStream != null) message(""  RAM: now balance allocations: usedMB="" + toMB(this.numBytesUsed) + "" vs trigger="" + toMB(flushTrigger) + "" allocMB="" + toMB(this.numBytesAlloc) + "" vs trigger="" + toMB(this.freeTrigger) + "" byteBlockFree="" + toMB((this.byteBlockAllocator.freeByteBlocks.size() * 32768)) + "" charBlockFree="" + toMB((this.freeCharBlocks.size() * 16384 * 2)));  long startBytesAlloc = this.numBytesAlloc; int iter = 0; boolean any = true; while (this.numBytesAlloc > this.freeLevel) { synchronized (this) { if (0 == this.byteBlockAllocator.freeByteBlocks.size() && 0 == this.freeCharBlocks.size() && 0 == this.freeIntBlocks.size() && !any) { this.bufferIsFull = (this.numBytesUsed > flushTrigger); if (this.infoStream != null) if (this.numBytesUsed > flushTrigger) { message(""    nothing to free; now set bufferIsFull""); } else { message(""    nothing to free""); }   assert this.numBytesUsed <= this.numBytesAlloc; break; }  if (0 == iter % 4 && this.byteBlockAllocator.freeByteBlocks.size() > 0) { this.byteBlockAllocator.freeByteBlocks.remove(this.byteBlockAllocator.freeByteBlocks.size() - 1); this.numBytesAlloc -= 32768L; }  if (1 == iter % 4 && this.freeCharBlocks.size() > 0) { this.freeCharBlocks.remove(this.freeCharBlocks.size() - 1); this.numBytesAlloc -= 32768L; }  if (2 == iter % 4 && this.freeIntBlocks.size() > 0) { this.freeIntBlocks.remove(this.freeIntBlocks.size() - 1); this.numBytesAlloc -= 32768L; }  }  if (3 == iter % 4 && any) any = this.consumer.freeRAM();  iter++; }  if (this.infoStream != null) message(""    after free: freedMB="" + this.nf.format((startBytesAlloc - this.numBytesAlloc) / 1024.0D / 1024.0D) + "" usedMB="" + this.nf.format(this.numBytesUsed / 1024.0D / 1024.0D) + "" allocMB="" + this.nf.format(this.numBytesAlloc / 1024.0D / 1024.0D));  } else { synchronized (this) { if (this.numBytesUsed > flushTrigger) { if (this.infoStream != null) message(""  RAM: now flush @ usedMB="" + this.nf.format(this.numBytesUsed / 1024.0D / 1024.0D) + "" allocMB="" + this.nf.format(this.numBytesAlloc / 1024.0D / 1024.0D) + "" triggerMB="" + this.nf.format(flushTrigger / 1024.0D / 1024.0D));  this.bufferIsFull = true; }  }  }  } private class WaitQueue { DocumentsWriter.DocWriter[] waiting = new DocumentsWriter.DocWriter[10]; int nextWriteDocID; int nextWriteLoc; int numWaiting; long waitingBytes;
/*      */     static final boolean $assertionsDisabled;
/*      */     private final DocumentsWriter this$0;
/*      */     
/*      */     synchronized void reset() {
/* 1376 */       assert this.numWaiting == 0;
/* 1377 */       assert this.waitingBytes == 0L;
/* 1378 */       this.nextWriteDocID = 0;
/*      */     }
/*      */ 
/*      */     
/* 1382 */     synchronized boolean doResume() { return (this.waitingBytes <= DocumentsWriter.this.waitQueueResumeBytes); }
/*      */ 
/*      */ 
/*      */     
/* 1386 */     synchronized boolean doPause() { return (this.waitingBytes > DocumentsWriter.this.waitQueuePauseBytes); }
/*      */ 
/*      */     
/*      */     synchronized void abort() {
/* 1390 */       int count = 0;
/* 1391 */       for (int i = 0; i < this.waiting.length; i++) {
/* 1392 */         DocumentsWriter.DocWriter doc = this.waiting[i];
/* 1393 */         if (doc != null) {
/* 1394 */           doc.abort();
/* 1395 */           this.waiting[i] = null;
/* 1396 */           count++;
/*      */         } 
/*      */       } 
/* 1399 */       this.waitingBytes = 0L;
/* 1400 */       assert count == this.numWaiting;
/* 1401 */       this.numWaiting = 0;
/*      */     }
/*      */     
/*      */     private void writeDocument(DocumentsWriter.DocWriter doc) throws IOException {
/* 1405 */       assert doc == DocumentsWriter.this.skipDocWriter || this.nextWriteDocID == doc.docID;
/* 1406 */       boolean success = false;
/*      */       try {
/* 1408 */         doc.finish();
/* 1409 */         this.nextWriteDocID++;
/* 1410 */         DocumentsWriter.this.numDocsInStore++;
/* 1411 */         this.nextWriteLoc++;
/* 1412 */         assert this.nextWriteLoc <= this.waiting.length;
/* 1413 */         if (this.nextWriteLoc == this.waiting.length)
/* 1414 */           this.nextWriteLoc = 0; 
/* 1415 */         success = true;
/*      */       } finally {
/* 1417 */         if (!success) {
/* 1418 */           DocumentsWriter.this.setAborting();
/*      */         }
/*      */       } 
/*      */     }
/*      */     
/*      */     public synchronized boolean add(DocumentsWriter.DocWriter doc) throws IOException {
/* 1424 */       assert doc.docID >= this.nextWriteDocID;
/*      */       
/* 1426 */       if (doc.docID == this.nextWriteDocID) {
/* 1427 */         writeDocument(doc);
/*      */         while (true) {
/* 1429 */           doc = this.waiting[this.nextWriteLoc];
/* 1430 */           if (doc != null) {
/* 1431 */             this.numWaiting--;
/* 1432 */             this.waiting[this.nextWriteLoc] = null;
/* 1433 */             this.waitingBytes -= doc.sizeInBytes();
/* 1434 */             writeDocument(doc);
/*      */ 
/*      */ 
/*      */             
/*      */             continue;
/*      */           } 
/*      */ 
/*      */ 
/*      */           
/*      */           break;
/*      */         } 
/*      */       } else {
/* 1446 */         int gap = doc.docID - this.nextWriteDocID;
/* 1447 */         if (gap >= this.waiting.length) {
/*      */           
/* 1449 */           DocumentsWriter.DocWriter[] newArray = new DocumentsWriter.DocWriter[ArrayUtil.getNextSize(gap)];
/* 1450 */           assert this.nextWriteLoc >= 0;
/* 1451 */           System.arraycopy(this.waiting, this.nextWriteLoc, newArray, 0, this.waiting.length - this.nextWriteLoc);
/* 1452 */           System.arraycopy(this.waiting, 0, newArray, this.waiting.length - this.nextWriteLoc, this.nextWriteLoc);
/* 1453 */           this.nextWriteLoc = 0;
/* 1454 */           this.waiting = newArray;
/* 1455 */           gap = doc.docID - this.nextWriteDocID;
/*      */         } 
/*      */         
/* 1458 */         int loc = this.nextWriteLoc + gap;
/* 1459 */         if (loc >= this.waiting.length) {
/* 1460 */           loc -= this.waiting.length;
/*      */         }
/*      */         
/* 1463 */         assert loc < this.waiting.length;
/*      */ 
/*      */         
/* 1466 */         assert this.waiting[loc] == null;
/* 1467 */         this.waiting[loc] = doc;
/* 1468 */         this.numWaiting++;
/* 1469 */         this.waitingBytes += doc.sizeInBytes();
/*      */       } 
/*      */       
/* 1472 */       return doPause();
/*      */     } }
/*      */ 
/*      */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocumentsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocumentsWriterThreadState,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class DocumentsWriterThreadState
/*    */ {
/*    */   boolean isIdle = true;
/* 29 */   int numThreads = 1;
/*    */   
/*    */   boolean doFlushAfter;
/*    */   final DocConsumerPerThread consumer;
/*    */   final DocumentsWriter.DocState docState;
/*    */   final DocumentsWriter docWriter;
/*    */   
/*    */   public DocumentsWriterThreadState(DocumentsWriter docWriter) throws IOException {
/* 37 */     this.docWriter = docWriter;
/* 38 */     this.docState = new DocumentsWriter.DocState();
/* 39 */     this.docState.maxFieldLength = docWriter.maxFieldLength;
/* 40 */     this.docState.infoStream = docWriter.infoStream;
/* 41 */     this.docState.similarity = docWriter.similarity;
/* 42 */     this.docState.docWriter = docWriter;
/* 43 */     this.consumer = docWriter.consumer.addThread(this);
/*    */   }
/*    */   
/*    */   void doAfterFlush() {
/* 47 */     this.numThreads = 0;
/* 48 */     this.doFlushAfter = false;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\DocumentsWriterThreadState.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class FieldInfo
/*    */ {
/*    */   String name;
/*    */   boolean isIndexed;
/*    */   int number;
/*    */   boolean storeTermVector;
/*    */   boolean storeOffsetWithTermVector;
/*    */   boolean storePositionWithTermVector;
/*    */   boolean omitNorms;
/*    */   boolean omitTf;
/*    */   boolean storePayloads;
/*    */   
/*    */   FieldInfo(String na, boolean tk, int nu, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, boolean omitTf) {
/* 38 */     this.name = na;
/* 39 */     this.isIndexed = tk;
/* 40 */     this.number = nu;
/* 41 */     this.storeTermVector = storeTermVector;
/* 42 */     this.storeOffsetWithTermVector = storeOffsetWithTermVector;
/* 43 */     this.storePositionWithTermVector = storePositionWithTermVector;
/* 44 */     this.omitNorms = omitNorms;
/* 45 */     this.storePayloads = storePayloads;
/* 46 */     this.omitTf = omitTf;
/*    */   }
/*    */ 
/*    */   
/* 50 */   public Object clone() { return new FieldInfo(this.name, this.isIndexed, this.number, this.storeTermVector, this.storePositionWithTermVector, this.storeOffsetWithTermVector, this.omitNorms, this.storePayloads, this.omitTf); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   void update(boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, boolean omitTf) {
/* 56 */     if (this.isIndexed != isIndexed) {
/* 57 */       this.isIndexed = true;
/*    */     }
/* 59 */     if (this.storeTermVector != storeTermVector) {
/* 60 */       this.storeTermVector = true;
/*    */     }
/* 62 */     if (this.storePositionWithTermVector != storePositionWithTermVector) {
/* 63 */       this.storePositionWithTermVector = true;
/*    */     }
/* 65 */     if (this.storeOffsetWithTermVector != storeOffsetWithTermVector) {
/* 66 */       this.storeOffsetWithTermVector = true;
/*    */     }
/* 68 */     if (this.omitNorms != omitNorms) {
/* 69 */       this.omitNorms = false;
/*    */     }
/* 71 */     if (this.omitTf != omitTf) {
/* 72 */       this.omitTf = true;
/*    */     }
/* 74 */     if (this.storePayloads != storePayloads) {
/* 75 */       this.storePayloads = true;
/*    */     }
/*    */   }
/*    */   
/*    */   void update(FieldInfo other) {
/* 80 */     if (this.isIndexed != other.isIndexed) {
/* 81 */       this.isIndexed = true;
/*    */     }
/* 83 */     if (this.storeTermVector != other.storeTermVector) {
/* 84 */       this.storeTermVector = true;
/*    */     }
/* 86 */     if (this.storePositionWithTermVector != other.storePositionWithTermVector) {
/* 87 */       this.storePositionWithTermVector = true;
/*    */     }
/* 89 */     if (this.storeOffsetWithTermVector != other.storeOffsetWithTermVector) {
/* 90 */       this.storeOffsetWithTermVector = true;
/*    */     }
/* 92 */     if (this.omitNorms != other.omitNorms) {
/* 93 */       this.omitNorms = false;
/*    */     }
/* 95 */     if (this.omitTf != this.omitTf) {
/* 96 */       this.omitTf = true;
/*    */     }
/* 98 */     if (this.storePayloads != other.storePayloads)
/* 99 */       this.storePayloads = true; 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FieldInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldInfos,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldInfos
/*     */ {
/*     */   static final byte IS_INDEXED = 1;
/*     */   static final byte STORE_TERMVECTOR = 2;
/*     */   static final byte STORE_POSITIONS_WITH_TERMVECTOR = 4;
/*     */   static final byte STORE_OFFSET_WITH_TERMVECTOR = 8;
/*     */   static final byte OMIT_NORMS = 16;
/*     */   static final byte STORE_PAYLOADS = 32;
/*     */   static final byte OMIT_TF = 64;
/*  45 */   private ArrayList byNumber = new ArrayList();
/*  46 */   private HashMap byName = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldInfos() {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldInfos(Directory d, String name) throws IOException {
/*  58 */     IndexInput input = d.openInput(name);
/*     */     try {
/*  60 */       read(input);
/*     */     } finally {
/*  62 */       input.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized Object clone() {
/*  70 */     FieldInfos fis = new FieldInfos();
/*  71 */     int numField = this.byNumber.size();
/*  72 */     for (int i = 0; i < numField; i++) {
/*  73 */       FieldInfo fi = (FieldInfo)((FieldInfo)this.byNumber.get(i)).clone();
/*  74 */       fis.byNumber.add(fi);
/*  75 */       fis.byName.put(fi.name, fi);
/*     */     } 
/*  77 */     return fis;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void add(Document doc) {
/*  82 */     List fields = doc.getFields();
/*  83 */     Iterator fieldIterator = fields.iterator();
/*  84 */     while (fieldIterator.hasNext()) {
/*  85 */       Fieldable field = fieldIterator.next();
/*  86 */       add(field.name(), field.isIndexed(), field.isTermVectorStored(), field.isStorePositionWithTermVector(), field.isStoreOffsetWithTermVector(), field.getOmitNorms());
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   boolean hasProx() {
/*  93 */     int numFields = this.byNumber.size();
/*  94 */     for (int i = 0; i < numFields; i++) {
/*  95 */       if (!(fieldInfo(i)).omitTf)
/*  96 */         return true; 
/*  97 */     }  return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void addIndexed(Collection names, boolean storeTermVectors, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) {
/* 110 */     Iterator i = names.iterator();
/* 111 */     while (i.hasNext()) {
/* 112 */       add(i.next(), true, storeTermVectors, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void add(Collection names, boolean isIndexed) {
/* 125 */     Iterator i = names.iterator();
/* 126 */     while (i.hasNext()) {
/* 127 */       add(i.next(), isIndexed);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 139 */   public synchronized void add(String name, boolean isIndexed) { add(name, isIndexed, false, false, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 150 */   public synchronized void add(String name, boolean isIndexed, boolean storeTermVector) { add(name, isIndexed, storeTermVector, false, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 167 */   public synchronized void add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) { add(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 184 */   public synchronized void add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms) { add(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized FieldInfo add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, boolean omitTf) {
/* 205 */     FieldInfo fi = fieldInfo(name);
/* 206 */     if (fi == null) {
/* 207 */       return addInternal(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTf);
/*     */     }
/* 209 */     fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTf);
/*     */     
/* 211 */     return fi;
/*     */   }
/*     */   
/*     */   public synchronized FieldInfo add(FieldInfo fieldInfo) {
/* 215 */     FieldInfo fi = fieldInfo(fieldInfo.name);
/* 216 */     if (fi == null) {
/* 217 */       return addInternal(fieldInfo.name, fieldInfo.isIndexed, fieldInfo.storeTermVector, fieldInfo.storePositionWithTermVector, fieldInfo.storeOffsetWithTermVector, fieldInfo.omitNorms, fieldInfo.storePayloads, fieldInfo.omitTf);
/*     */     }
/*     */ 
/*     */     
/* 221 */     fi.update(fieldInfo);
/*     */     
/* 223 */     return fi;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private FieldInfo addInternal(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, boolean omitTf) {
/* 229 */     FieldInfo fi = new FieldInfo(name, isIndexed, this.byNumber.size(), storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTf);
/*     */ 
/*     */     
/* 232 */     this.byNumber.add(fi);
/* 233 */     this.byName.put(name, fi);
/* 234 */     return fi;
/*     */   }
/*     */   
/*     */   public int fieldNumber(String fieldName) {
/* 238 */     FieldInfo fi = fieldInfo(fieldName);
/* 239 */     return (fi != null) ? fi.number : -1;
/*     */   }
/*     */ 
/*     */   
/* 243 */   public FieldInfo fieldInfo(String fieldName) { return (FieldInfo)this.byName.get(fieldName); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String fieldName(int fieldNumber) {
/* 254 */     FieldInfo fi = fieldInfo(fieldNumber);
/* 255 */     return (fi != null) ? fi.name : """";
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 265 */   public FieldInfo fieldInfo(int fieldNumber) { return (fieldNumber >= 0) ? this.byNumber.get(fieldNumber) : null; }
/*     */ 
/*     */ 
/*     */   
/* 269 */   public int size() { return this.byNumber.size(); }
/*     */ 
/*     */   
/*     */   public boolean hasVectors() {
/* 273 */     boolean hasVectors = false;
/* 274 */     for (int i = 0; i < size(); i++) {
/* 275 */       if ((fieldInfo(i)).storeTermVector) {
/* 276 */         hasVectors = true;
/*     */         break;
/*     */       } 
/*     */     } 
/* 280 */     return hasVectors;
/*     */   }
/*     */   
/*     */   public void write(Directory d, String name) throws IOException {
/* 284 */     IndexOutput output = d.createOutput(name);
/*     */     try {
/* 286 */       write(output);
/*     */     } finally {
/* 288 */       output.close();
/*     */     } 
/*     */   }
/*     */   
/*     */   public void write(IndexOutput output) throws IOException {
/* 293 */     output.writeVInt(size());
/* 294 */     for (int i = 0; i < size(); i++) {
/* 295 */       FieldInfo fi = fieldInfo(i);
/* 296 */       byte bits = 0;
/* 297 */       if (fi.isIndexed) bits = (byte)(bits | 0x1); 
/* 298 */       if (fi.storeTermVector) bits = (byte)(bits | 0x2); 
/* 299 */       if (fi.storePositionWithTermVector) bits = (byte)(bits | 0x4); 
/* 300 */       if (fi.storeOffsetWithTermVector) bits = (byte)(bits | 0x8); 
/* 301 */       if (fi.omitNorms) bits = (byte)(bits | 0x10); 
/* 302 */       if (fi.storePayloads) bits = (byte)(bits | 0x20); 
/* 303 */       if (fi.omitTf) bits = (byte)(bits | 0x40);
/*     */       
/* 305 */       output.writeString(fi.name);
/* 306 */       output.writeByte(bits);
/*     */     } 
/*     */   }
/*     */   
/*     */   private void read(IndexInput input) throws IOException {
/* 311 */     int size = input.readVInt();
/* 312 */     for (int i = 0; i < size; i++) {
/* 313 */       String name = input.readString().intern();
/* 314 */       byte bits = input.readByte();
/* 315 */       boolean isIndexed = ((bits & 0x1) != 0);
/* 316 */       boolean storeTermVector = ((bits & 0x2) != 0);
/* 317 */       boolean storePositionsWithTermVector = ((bits & 0x4) != 0);
/* 318 */       boolean storeOffsetWithTermVector = ((bits & 0x8) != 0);
/* 319 */       boolean omitNorms = ((bits & 0x10) != 0);
/* 320 */       boolean storePayloads = ((bits & 0x20) != 0);
/* 321 */       boolean omitTf = ((bits & 0x40) != 0);
/*     */       
/* 323 */       addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTf);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FieldInfos.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldReaderException,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FieldReaderException
/*    */   extends RuntimeException
/*    */ {
/*    */   public FieldReaderException() {}
/*    */   
/* 47 */   public FieldReaderException(Throwable cause) { super(cause); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public FieldReaderException(String message) { super(message); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 77 */   public FieldReaderException(String message, Throwable cause) { super(message, cause); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FieldReaderException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldSortedTermVectorMapper,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.util.Comparator;
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ import java.util.SortedSet;
/*    */ import java.util.TreeSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FieldSortedTermVectorMapper
/*    */   extends TermVectorMapper
/*    */ {
/* 27 */   private Map fieldToTerms = new HashMap();
/*    */ 
/*    */   
/*    */   private SortedSet currentSet;
/*    */   
/*    */   private String currentField;
/*    */   
/*    */   private Comparator comparator;
/*    */ 
/*    */   
/* 37 */   public FieldSortedTermVectorMapper(Comparator comparator) { this(false, false, comparator); }
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldSortedTermVectorMapper(boolean ignoringPositions, boolean ignoringOffsets, Comparator comparator) {
/* 42 */     super(ignoringPositions, ignoringOffsets);
/* 43 */     this.comparator = comparator;
/*    */   }
/*    */   
/*    */   public void map(String term, int frequency, TermVectorOffsetInfo[] offsets, int[] positions) {
/* 47 */     TermVectorEntry entry = new TermVectorEntry(this.currentField, term, frequency, offsets, positions);
/* 48 */     this.currentSet.add(entry);
/*    */   }
/*    */   
/*    */   public void setExpectations(String field, int numTerms, boolean storeOffsets, boolean storePositions) {
/* 52 */     this.currentSet = new TreeSet(this.comparator);
/* 53 */     this.currentField = field;
/* 54 */     this.fieldToTerms.put(field, this.currentSet);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 63 */   public Map getFieldToTerms() { return this.fieldToTerms; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 68 */   public Comparator getComparator() { return this.comparator; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FieldSortedTermVectorMapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldsReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.ByteArrayOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.zip.DataFormatException;
/*     */ import java.util.zip.Inflater;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.document.AbstractField;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Field;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.document.FieldSelectorResult;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.store.AlreadyClosedException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.util.CloseableThreadLocal;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldsReader
/*     */ {
/*     */   private final FieldInfos fieldInfos;
/*     */   private final IndexInput cloneableFieldsStream;
/*     */   private final IndexInput fieldsStream;
/*     */   private final IndexInput indexStream;
/*     */   private int numTotalDocs;
/*     */   private int size;
/*     */   private boolean closed;
/*     */   private final int format;
/*     */   private final int formatSize;
/*     */   private int docStoreOffset;
/*  62 */   private CloseableThreadLocal fieldsStreamTL = new CloseableThreadLocal();
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  65 */   FieldsReader(Directory d, String segment, FieldInfos fn) throws IOException { this(d, segment, fn, 1024, -1, 0); }
/*     */ 
/*     */ 
/*     */   
/*  69 */   FieldsReader(Directory d, String segment, FieldInfos fn, int readBufferSize) throws IOException { this(d, segment, fn, readBufferSize, -1, 0); }
/*     */ 
/*     */   
/*     */   FieldsReader(Directory d, String segment, FieldInfos fn, int readBufferSize, int docStoreOffset, int size) throws IOException {
/*  73 */     boolean success = false;
/*     */     
/*     */     try {
/*  76 */       this.fieldInfos = fn;
/*     */       
/*  78 */       this.cloneableFieldsStream = d.openInput(segment + ""."" + ""fdt"", readBufferSize);
/*  79 */       this.indexStream = d.openInput(segment + ""."" + ""fdx"", readBufferSize);
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  84 */       int firstInt = this.indexStream.readInt();
/*  85 */       if (firstInt == 0) {
/*  86 */         this.format = 0;
/*     */       } else {
/*  88 */         this.format = firstInt;
/*     */       } 
/*  90 */       if (this.format > 1) {
/*  91 */         throw new CorruptIndexException(""Incompatible format version: "" + this.format + "" expected "" + '\001' + "" or lower"");
/*     */       }
/*     */       
/*  94 */       if (this.format > 0) {
/*  95 */         this.formatSize = 4;
/*     */       } else {
/*  97 */         this.formatSize = 0;
/*     */       } 
/*  99 */       if (this.format < 1) {
/* 100 */         this.cloneableFieldsStream.setModifiedUTF8StringsMode();
/*     */       }
/* 102 */       this.fieldsStream = (IndexInput)this.cloneableFieldsStream.clone();
/*     */       
/* 104 */       long indexSize = this.indexStream.length() - this.formatSize;
/*     */       
/* 106 */       if (docStoreOffset != -1) {
/*     */         
/* 108 */         this.docStoreOffset = docStoreOffset;
/* 109 */         this.size = size;
/*     */ 
/*     */ 
/*     */         
/* 113 */         assert (int)(indexSize / 8L) >= size + this.docStoreOffset : ""indexSize="" + indexSize + "" size="" + size + "" docStoreOffset="" + docStoreOffset;
/*     */       } else {
/* 115 */         this.docStoreOffset = 0;
/* 116 */         this.size = (int)(indexSize >> 3L);
/*     */       } 
/*     */       
/* 119 */       this.numTotalDocs = (int)(indexSize >> 3L);
/* 120 */       success = true;
/*     */ 
/*     */     
/*     */     }
/*     */     finally {
/*     */ 
/*     */       
/* 127 */       if (!success) {
/* 128 */         close();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final void ensureOpen() throws AlreadyClosedException {
/* 137 */     if (this.closed) {
/* 138 */       throw new AlreadyClosedException(""this FieldsReader is closed"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/* 149 */     if (!this.closed) {
/* 150 */       if (this.fieldsStream != null) {
/* 151 */         this.fieldsStream.close();
/*     */       }
/* 153 */       if (this.cloneableFieldsStream != null) {
/* 154 */         this.cloneableFieldsStream.close();
/*     */       }
/* 156 */       if (this.indexStream != null) {
/* 157 */         this.indexStream.close();
/*     */       }
/* 159 */       this.fieldsStreamTL.close();
/* 160 */       this.closed = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 165 */   final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */   
/* 169 */   private final void seekIndex(int docID) throws IOException { this.indexStream.seek(this.formatSize + (docID + this.docStoreOffset) * 8L); }
/*     */ 
/*     */ 
/*     */   
/* 173 */   boolean canReadRawDocs() { return (this.format >= 1); }
/*     */ 
/*     */   
/*     */   final Document doc(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 177 */     seekIndex(n);
/* 178 */     long position = this.indexStream.readLong();
/* 179 */     this.fieldsStream.seek(position);
/*     */     
/* 181 */     Document doc = new Document();
/* 182 */     int numFields = this.fieldsStream.readVInt();
/* 183 */     for (int i = 0; i < numFields; i++) {
/* 184 */       int fieldNumber = this.fieldsStream.readVInt();
/* 185 */       FieldInfo fi = this.fieldInfos.fieldInfo(fieldNumber);
/* 186 */       FieldSelectorResult acceptField = (fieldSelector == null) ? FieldSelectorResult.LOAD : fieldSelector.accept(fi.name);
/*     */       
/* 188 */       byte bits = this.fieldsStream.readByte();
/* 189 */       assert bits <= 7;
/*     */       
/* 191 */       boolean compressed = ((bits & 0x4) != 0);
/* 192 */       boolean tokenize = ((bits & 0x1) != 0);
/* 193 */       boolean binary = ((bits & 0x2) != 0);
/*     */ 
/*     */       
/* 196 */       if (acceptField.equals(FieldSelectorResult.LOAD)) {
/* 197 */         addField(doc, fi, binary, compressed, tokenize);
/*     */       }
/* 199 */       else if (acceptField.equals(FieldSelectorResult.LOAD_FOR_MERGE)) {
/* 200 */         addFieldForMerge(doc, fi, binary, compressed, tokenize);
/*     */       } else {
/* 202 */         if (acceptField.equals(FieldSelectorResult.LOAD_AND_BREAK)) {
/* 203 */           addField(doc, fi, binary, compressed, tokenize);
/*     */           break;
/*     */         } 
/* 206 */         if (acceptField.equals(FieldSelectorResult.LAZY_LOAD)) {
/* 207 */           addFieldLazy(doc, fi, binary, compressed, tokenize);
/*     */         }
/* 209 */         else if (acceptField.equals(FieldSelectorResult.SIZE)) {
/* 210 */           skipField(binary, compressed, addFieldSize(doc, fi, binary, compressed));
/*     */         } else {
/* 212 */           if (acceptField.equals(FieldSelectorResult.SIZE_AND_BREAK)) {
/* 213 */             addFieldSize(doc, fi, binary, compressed);
/*     */             
/*     */             break;
/*     */           } 
/* 217 */           skipField(binary, compressed);
/*     */         } 
/*     */       } 
/*     */     } 
/* 221 */     return doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final IndexInput rawDocs(int[] lengths, int startDocID, int numDocs) throws IOException {
/* 229 */     seekIndex(startDocID);
/* 230 */     long startOffset = this.indexStream.readLong();
/* 231 */     long lastOffset = startOffset;
/* 232 */     int count = 0;
/* 233 */     while (count < numDocs) {
/*     */       long offset;
/* 235 */       int docID = this.docStoreOffset + startDocID + count + 1;
/* 236 */       assert docID <= this.numTotalDocs;
/* 237 */       if (docID < this.numTotalDocs) {
/* 238 */         offset = this.indexStream.readLong();
/*     */       } else {
/* 240 */         offset = this.fieldsStream.length();
/* 241 */       }  lengths[count++] = (int)(offset - lastOffset);
/* 242 */       lastOffset = offset;
/*     */     } 
/*     */     
/* 245 */     this.fieldsStream.seek(startOffset);
/*     */     
/* 247 */     return this.fieldsStream;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 255 */   private void skipField(boolean binary, boolean compressed) throws IOException { skipField(binary, compressed, this.fieldsStream.readVInt()); }
/*     */ 
/*     */   
/*     */   private void skipField(boolean binary, boolean compressed, int toRead) throws IOException {
/* 259 */     if (this.format >= 1 || binary || compressed) {
/* 260 */       this.fieldsStream.seek(this.fieldsStream.getFilePointer() + toRead);
/*     */     } else {
/*     */       
/* 263 */       this.fieldsStream.skipChars(toRead);
/*     */     } 
/*     */   }
/*     */   
/*     */   private void addFieldLazy(Document doc, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) throws IOException {
/* 268 */     if (binary) {
/* 269 */       int toRead = this.fieldsStream.readVInt();
/* 270 */       long pointer = this.fieldsStream.getFilePointer();
/* 271 */       if (compressed) {
/*     */         
/* 273 */         doc.add(new LazyField(fi.name, Field.Store.COMPRESS, toRead, pointer, binary));
/*     */       } else {
/*     */         
/* 276 */         doc.add(new LazyField(fi.name, Field.Store.YES, toRead, pointer, binary));
/*     */       } 
/*     */       
/* 279 */       this.fieldsStream.seek(pointer + toRead);
/*     */     } else {
/* 281 */       Fieldable f; Field.Store store = Field.Store.YES;
/* 282 */       Field.Index index = getIndexType(fi, tokenize);
/* 283 */       Field.TermVector termVector = getTermVectorType(fi);
/*     */ 
/*     */       
/* 286 */       if (compressed) {
/* 287 */         store = Field.Store.COMPRESS;
/* 288 */         int toRead = this.fieldsStream.readVInt();
/* 289 */         long pointer = this.fieldsStream.getFilePointer();
/* 290 */         f = new LazyField(fi.name, store, toRead, pointer, binary);
/*     */         
/* 292 */         this.fieldsStream.seek(pointer + toRead);
/* 293 */         f.setOmitNorms(fi.omitNorms);
/*     */       } else {
/* 295 */         int length = this.fieldsStream.readVInt();
/* 296 */         long pointer = this.fieldsStream.getFilePointer();
/*     */         
/* 298 */         if (this.format >= 1) {
/* 299 */           this.fieldsStream.seek(pointer + length);
/*     */         } else {
/* 301 */           this.fieldsStream.skipChars(length);
/* 302 */         }  f = new LazyField(fi.name, store, index, termVector, length, pointer, binary);
/* 303 */         f.setOmitNorms(fi.omitNorms);
/*     */       } 
/* 305 */       doc.add(f);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void addFieldForMerge(Document doc, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) throws IOException {
/*     */     Object data;
/* 314 */     if (binary || compressed) {
/* 315 */       int toRead = this.fieldsStream.readVInt();
/* 316 */       byte[] b = new byte[toRead];
/* 317 */       this.fieldsStream.readBytes(b, 0, b.length);
/* 318 */       data = b;
/*     */     } else {
/* 320 */       data = this.fieldsStream.readString();
/*     */     } 
/*     */     
/* 323 */     doc.add((Fieldable)new FieldForMerge(data, fi, binary, compressed, tokenize));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void addField(Document doc, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) throws CorruptIndexException, IOException {
/* 329 */     if (binary) {
/* 330 */       int toRead = this.fieldsStream.readVInt();
/* 331 */       byte[] b = new byte[toRead];
/* 332 */       this.fieldsStream.readBytes(b, 0, b.length);
/* 333 */       if (compressed) {
/* 334 */         doc.add((Fieldable)new Field(fi.name, uncompress(b), Field.Store.COMPRESS));
/*     */       } else {
/* 336 */         doc.add((Fieldable)new Field(fi.name, b, Field.Store.YES));
/*     */       } 
/*     */     } else {
/* 339 */       Field field; Field.Store store = Field.Store.YES;
/* 340 */       Field.Index index = getIndexType(fi, tokenize);
/* 341 */       Field.TermVector termVector = getTermVectorType(fi);
/*     */ 
/*     */       
/* 344 */       if (compressed) {
/* 345 */         store = Field.Store.COMPRESS;
/* 346 */         int toRead = this.fieldsStream.readVInt();
/*     */         
/* 348 */         byte[] b = new byte[toRead];
/* 349 */         this.fieldsStream.readBytes(b, 0, b.length);
/* 350 */         field = new Field(fi.name, new String(uncompress(b), ""UTF-8""), store, index, termVector);
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 355 */         field.setOmitNorms(fi.omitNorms);
/*     */       } else {
/* 357 */         field = new Field(fi.name, this.fieldsStream.readString(), store, index, termVector);
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 362 */         field.setOmitNorms(fi.omitNorms);
/*     */       } 
/* 364 */       doc.add((Fieldable)field);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private int addFieldSize(Document doc, FieldInfo fi, boolean binary, boolean compressed) throws IOException {
/* 372 */     int size = this.fieldsStream.readVInt(), bytesize = (binary || compressed) ? size : (2 * size);
/* 373 */     byte[] sizebytes = new byte[4];
/* 374 */     sizebytes[0] = (byte)(bytesize >>> 24);
/* 375 */     sizebytes[1] = (byte)(bytesize >>> 16);
/* 376 */     sizebytes[2] = (byte)(bytesize >>> 8);
/* 377 */     sizebytes[3] = (byte)bytesize;
/* 378 */     doc.add((Fieldable)new Field(fi.name, sizebytes, Field.Store.YES));
/* 379 */     return size;
/*     */   }
/*     */   
/*     */   private Field.TermVector getTermVectorType(FieldInfo fi) {
/* 383 */     Field.TermVector termVector = null;
/* 384 */     if (fi.storeTermVector) {
/* 385 */       if (fi.storeOffsetWithTermVector) {
/* 386 */         if (fi.storePositionWithTermVector) {
/* 387 */           termVector = Field.TermVector.WITH_POSITIONS_OFFSETS;
/*     */         } else {
/* 389 */           termVector = Field.TermVector.WITH_OFFSETS;
/*     */         } 
/* 391 */       } else if (fi.storePositionWithTermVector) {
/* 392 */         termVector = Field.TermVector.WITH_POSITIONS;
/*     */       } else {
/* 394 */         termVector = Field.TermVector.YES;
/*     */       } 
/*     */     } else {
/* 397 */       termVector = Field.TermVector.NO;
/*     */     } 
/* 399 */     return termVector;
/*     */   }
/*     */   
/*     */   private Field.Index getIndexType(FieldInfo fi, boolean tokenize) {
/*     */     Field.Index index;
/* 404 */     if (fi.isIndexed && tokenize) {
/* 405 */       index = Field.Index.ANALYZED;
/* 406 */     } else if (fi.isIndexed && !tokenize) {
/* 407 */       index = Field.Index.NOT_ANALYZED;
/*     */     } else {
/* 409 */       index = Field.Index.NO;
/* 410 */     }  return index;
/*     */   }
/*     */   
/*     */   private class LazyField
/*     */     extends AbstractField
/*     */     implements Fieldable
/*     */   {
/*     */     private int toRead;
/*     */     private long pointer;
/*     */     private final FieldsReader this$0;
/*     */     
/*     */     public LazyField(String name, Field.Store store, int toRead, long pointer, boolean isBinary) {
/* 422 */       super(name, store, Field.Index.NO, Field.TermVector.NO);
/* 423 */       this.toRead = toRead;
/* 424 */       this.pointer = pointer;
/* 425 */       this.isBinary = isBinary;
/* 426 */       this.lazy = true;
/*     */     }
/*     */     
/*     */     public LazyField(String name, Field.Store store, Field.Index index, Field.TermVector termVector, int toRead, long pointer, boolean isBinary) {
/* 430 */       super(name, store, index, termVector);
/* 431 */       this.toRead = toRead;
/* 432 */       this.pointer = pointer;
/* 433 */       this.isBinary = isBinary;
/* 434 */       this.lazy = true;
/*     */     }
/*     */     
/*     */     private IndexInput getFieldStream() {
/* 438 */       IndexInput localFieldsStream = (IndexInput)FieldsReader.this.fieldsStreamTL.get();
/* 439 */       if (localFieldsStream == null) {
/* 440 */         localFieldsStream = (IndexInput)FieldsReader.this.cloneableFieldsStream.clone();
/* 441 */         FieldsReader.this.fieldsStreamTL.set(localFieldsStream);
/*     */       } 
/* 443 */       return localFieldsStream;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 450 */     public byte[] binaryValue() { return getBinaryValue(null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Reader readerValue() {
/* 457 */       FieldsReader.this.ensureOpen();
/* 458 */       return null;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public TokenStream tokenStreamValue() {
/* 465 */       FieldsReader.this.ensureOpen();
/* 466 */       return null;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public String stringValue() {
/* 473 */       FieldsReader.this.ensureOpen();
/* 474 */       if (this.isBinary) {
/* 475 */         return null;
/*     */       }
/* 477 */       if (this.fieldsData == null) {
/* 478 */         IndexInput localFieldsStream = getFieldStream();
/*     */         try {
/* 480 */           localFieldsStream.seek(this.pointer);
/* 481 */           if (this.isCompressed) {
/* 482 */             byte[] b = new byte[this.toRead];
/* 483 */             localFieldsStream.readBytes(b, 0, b.length);
/* 484 */             this.fieldsData = new String(FieldsReader.this.uncompress(b), ""UTF-8"");
/*     */           }
/* 486 */           else if (FieldsReader.this.format >= 1) {
/* 487 */             byte[] bytes = new byte[this.toRead];
/* 488 */             localFieldsStream.readBytes(bytes, 0, this.toRead);
/* 489 */             this.fieldsData = new String(bytes, ""UTF-8"");
/*     */           } else {
/*     */             
/* 492 */             char[] chars = new char[this.toRead];
/* 493 */             localFieldsStream.readChars(chars, 0, this.toRead);
/* 494 */             this.fieldsData = new String(chars);
/*     */           }
/*     */         
/* 497 */         } catch (IOException e) {
/* 498 */           throw new FieldReaderException(e);
/*     */         } 
/*     */       } 
/* 501 */       return (String)this.fieldsData;
/*     */     }
/*     */ 
/*     */     
/*     */     public long getPointer() {
/* 506 */       FieldsReader.this.ensureOpen();
/* 507 */       return this.pointer;
/*     */     }
/*     */     
/*     */     public void setPointer(long pointer) {
/* 511 */       FieldsReader.this.ensureOpen();
/* 512 */       this.pointer = pointer;
/*     */     }
/*     */     
/*     */     public int getToRead() {
/* 516 */       FieldsReader.this.ensureOpen();
/* 517 */       return this.toRead;
/*     */     }
/*     */     
/*     */     public void setToRead(int toRead) {
/* 521 */       FieldsReader.this.ensureOpen();
/* 522 */       this.toRead = toRead;
/*     */     }
/*     */     
/*     */     public byte[] getBinaryValue(byte[] result) {
/* 526 */       FieldsReader.this.ensureOpen();
/*     */       
/* 528 */       if (this.isBinary) {
/* 529 */         if (this.fieldsData == null) {
/*     */           byte[] b;
/*     */           
/* 532 */           if (result == null || result.length < this.toRead) {
/* 533 */             b = new byte[this.toRead];
/*     */           } else {
/* 535 */             b = result;
/*     */           } 
/* 537 */           IndexInput localFieldsStream = getFieldStream();
/*     */ 
/*     */ 
/*     */           
/*     */           try {
/* 542 */             localFieldsStream.seek(this.pointer);
/* 543 */             localFieldsStream.readBytes(b, 0, this.toRead);
/* 544 */             if (this.isCompressed == true) {
/* 545 */               this.fieldsData = FieldsReader.this.uncompress(b);
/*     */             } else {
/* 547 */               this.fieldsData = b;
/*     */             } 
/* 549 */           } catch (IOException e) {
/* 550 */             throw new FieldReaderException(e);
/*     */           } 
/*     */           
/* 553 */           this.binaryOffset = 0;
/* 554 */           this.binaryLength = this.toRead;
/*     */         } 
/*     */         
/* 557 */         return (byte[])this.fieldsData;
/*     */       } 
/* 559 */       return null;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final byte[] uncompress(byte[] input) throws CorruptIndexException, IOException {
/* 567 */     ByteArrayOutputStream bos = new ByteArrayOutputStream(input.length);
/*     */     
/* 569 */     Inflater decompressor = new Inflater();
/*     */     
/*     */     try {
/* 572 */       decompressor.setInput(input);
/*     */ 
/*     */       
/* 575 */       byte[] buf = new byte[1024];
/* 576 */       while (!decompressor.finished()) {
/*     */         try {
/* 578 */           int count = decompressor.inflate(buf);
/* 579 */           bos.write(buf, 0, count);
/*     */         }
/* 581 */         catch (DataFormatException e) {
/*     */           
/* 583 */           CorruptIndexException newException = new CorruptIndexException(""field data are in wrong format: "" + e.toString());
/* 584 */           newException.initCause(e);
/* 585 */           throw newException;
/*     */         } 
/*     */       } 
/*     */     } finally {
/* 589 */       decompressor.end();
/*     */     } 
/*     */ 
/*     */     
/* 593 */     return bos.toByteArray();
/*     */   }
/*     */ 
/*     */   
/*     */   static final class FieldForMerge
/*     */     extends AbstractField
/*     */   {
/* 600 */     public String stringValue() { return (String)this.fieldsData; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 605 */     public Reader readerValue() { return null; }
/*     */ 
/*     */ 
/*     */     
/* 609 */     public byte[] binaryValue() { return (byte[])this.fieldsData; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 614 */     public TokenStream tokenStreamValue() { return null; }
/*     */ 
/*     */     
/*     */     public FieldForMerge(Object value, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) {
/* 618 */       this.isStored = true;
/* 619 */       this.fieldsData = value;
/* 620 */       this.isCompressed = compressed;
/* 621 */       this.isBinary = binary;
/* 622 */       this.isTokenized = tokenize;
/*     */       
/* 624 */       this.name = fi.name.intern();
/* 625 */       this.isIndexed = fi.isIndexed;
/* 626 */       this.omitNorms = fi.omitNorms;
/* 627 */       this.storeOffsetWithTermVector = fi.storeOffsetWithTermVector;
/* 628 */       this.storePositionWithTermVector = fi.storePositionWithTermVector;
/* 629 */       this.storeTermVector = fi.storeTermVector;
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FieldsReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.ByteArrayOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.zip.Deflater;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.RAMOutputStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldsWriter
/*     */ {
/*     */   static final byte FIELD_IS_TOKENIZED = 1;
/*     */   static final byte FIELD_IS_BINARY = 2;
/*     */   static final byte FIELD_IS_COMPRESSED = 4;
/*     */   static final int FORMAT = 0;
/*     */   static final int FORMAT_VERSION_UTF8_LENGTH_IN_BYTES = 1;
/*     */   static final int FORMAT_CURRENT = 1;
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexOutput fieldsStream;
/*     */   private IndexOutput indexStream;
/*     */   private boolean doClose;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   FieldsWriter(Directory d, String segment, FieldInfos fn) throws IOException {
/*  57 */     this.fieldInfos = fn;
/*     */     
/*  59 */     boolean success = false;
/*  60 */     String fieldsName = segment + ""."" + ""fdt"";
/*     */     try {
/*  62 */       this.fieldsStream = d.createOutput(fieldsName);
/*  63 */       this.fieldsStream.writeInt(1);
/*  64 */       success = true;
/*     */     } finally {
/*  66 */       if (!success) {
/*     */         try {
/*  68 */           close();
/*  69 */         } catch (Throwable t) {}
/*     */ 
/*     */         
/*     */         try {
/*  73 */           d.deleteFile(fieldsName);
/*  74 */         } catch (Throwable t) {}
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/*  80 */     success = false;
/*  81 */     String indexName = segment + ""."" + ""fdx"";
/*     */     try {
/*  83 */       this.indexStream = d.createOutput(indexName);
/*  84 */       this.indexStream.writeInt(1);
/*  85 */       success = true;
/*     */     } finally {
/*  87 */       if (!success) {
/*     */         try {
/*  89 */           close();
/*  90 */         } catch (IOException ioe) {}
/*     */         
/*     */         try {
/*  93 */           d.deleteFile(fieldsName);
/*  94 */         } catch (Throwable t) {}
/*     */ 
/*     */         
/*     */         try {
/*  98 */           d.deleteFile(indexName);
/*  99 */         } catch (Throwable t) {}
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 105 */     this.doClose = true;
/*     */   }
/*     */   
/*     */   FieldsWriter(IndexOutput fdx, IndexOutput fdt, FieldInfos fn) {
/* 109 */     this.fieldInfos = fn;
/* 110 */     this.fieldsStream = fdt;
/* 111 */     this.indexStream = fdx;
/* 112 */     this.doClose = false;
/*     */   }
/*     */ 
/*     */   
/* 116 */   void setFieldsStream(IndexOutput stream) { this.fieldsStream = stream; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void flushDocument(int numStoredFields, RAMOutputStream buffer) throws IOException {
/* 124 */     this.indexStream.writeLong(this.fieldsStream.getFilePointer());
/* 125 */     this.fieldsStream.writeVInt(numStoredFields);
/* 126 */     buffer.writeTo(this.fieldsStream);
/*     */   }
/*     */   
/*     */   void skipDocument() throws IOException {
/* 130 */     this.indexStream.writeLong(this.fieldsStream.getFilePointer());
/* 131 */     this.fieldsStream.writeVInt(0);
/*     */   }
/*     */   
/*     */   void flush() throws IOException {
/* 135 */     this.indexStream.flush();
/* 136 */     this.fieldsStream.flush();
/*     */   }
/*     */   
/*     */   final void close() throws IOException {
/* 140 */     if (this.doClose) {
/*     */       
/*     */       try {
/* 143 */         if (this.fieldsStream != null) {
/*     */           try {
/* 145 */             this.fieldsStream.close();
/*     */           } finally {
/* 147 */             this.fieldsStream = null;
/*     */           } 
/*     */         }
/* 150 */       } catch (IOException ioe) {
/*     */         try {
/* 152 */           if (this.indexStream != null) {
/*     */             try {
/* 154 */               this.indexStream.close();
/*     */             } finally {
/* 156 */               this.indexStream = null;
/*     */             } 
/*     */           }
/* 159 */         } catch (IOException ioe2) {}
/*     */ 
/*     */         
/* 162 */         throw ioe;
/*     */       } finally {
/* 164 */         if (this.indexStream != null) {
/*     */           try {
/* 166 */             this.indexStream.close();
/*     */           } finally {
/* 168 */             this.indexStream = null;
/*     */           } 
/*     */         }
/*     */       } 
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void writeField(FieldInfo fi, Fieldable field) throws IOException {
/* 179 */     boolean disableCompression = field instanceof FieldsReader.FieldForMerge;
/* 180 */     this.fieldsStream.writeVInt(fi.number);
/* 181 */     byte bits = 0;
/* 182 */     if (field.isTokenized())
/* 183 */       bits = (byte)(bits | 0x1); 
/* 184 */     if (field.isBinary())
/* 185 */       bits = (byte)(bits | 0x2); 
/* 186 */     if (field.isCompressed()) {
/* 187 */       bits = (byte)(bits | 0x4);
/*     */     }
/* 189 */     this.fieldsStream.writeByte(bits);
/*     */     
/* 191 */     if (field.isCompressed()) {
/*     */       int offset, len;
/*     */       
/*     */       byte[] data;
/*     */       
/* 196 */       if (disableCompression) {
/*     */ 
/*     */         
/* 199 */         data = field.getBinaryValue();
/* 200 */         assert data != null;
/* 201 */         len = field.getBinaryLength();
/* 202 */         offset = field.getBinaryOffset();
/*     */       } else {
/*     */         
/* 205 */         if (field.isBinary()) {
/* 206 */           data = compress(field.getBinaryValue(), field.getBinaryOffset(), field.getBinaryLength());
/*     */         } else {
/* 208 */           byte[] x = field.stringValue().getBytes(""UTF-8"");
/* 209 */           data = compress(x, 0, x.length);
/*     */         } 
/* 211 */         len = data.length;
/* 212 */         offset = 0;
/*     */       } 
/*     */       
/* 215 */       this.fieldsStream.writeVInt(len);
/* 216 */       this.fieldsStream.writeBytes(data, offset, len);
/*     */ 
/*     */     
/*     */     }
/* 220 */     else if (field.isBinary()) {
/*     */ 
/*     */ 
/*     */       
/* 224 */       byte[] data = field.getBinaryValue();
/* 225 */       int len = field.getBinaryLength();
/* 226 */       int offset = field.getBinaryOffset();
/*     */       
/* 228 */       this.fieldsStream.writeVInt(len);
/* 229 */       this.fieldsStream.writeBytes(data, offset, len);
/*     */     } else {
/*     */       
/* 232 */       this.fieldsStream.writeString(field.stringValue());
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void addRawDocuments(IndexInput stream, int[] lengths, int numDocs) throws IOException {
/* 243 */     long position = this.fieldsStream.getFilePointer();
/* 244 */     long start = position;
/* 245 */     for (int i = 0; i < numDocs; i++) {
/* 246 */       this.indexStream.writeLong(position);
/* 247 */       position += lengths[i];
/*     */     } 
/* 249 */     this.fieldsStream.copyBytes(stream, position - start);
/* 250 */     assert this.fieldsStream.getFilePointer() == position;
/*     */   }
/*     */   
/*     */   final void addDocument(Document doc) throws IOException {
/* 254 */     this.indexStream.writeLong(this.fieldsStream.getFilePointer());
/*     */     
/* 256 */     int storedCount = 0;
/* 257 */     Iterator fieldIterator = doc.getFields().iterator();
/* 258 */     while (fieldIterator.hasNext()) {
/* 259 */       Fieldable field = fieldIterator.next();
/* 260 */       if (field.isStored())
/* 261 */         storedCount++; 
/*     */     } 
/* 263 */     this.fieldsStream.writeVInt(storedCount);
/*     */     
/* 265 */     fieldIterator = doc.getFields().iterator();
/* 266 */     while (fieldIterator.hasNext()) {
/* 267 */       Fieldable field = fieldIterator.next();
/* 268 */       if (field.isStored()) {
/* 269 */         writeField(this.fieldInfos.fieldInfo(field.name()), field);
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   private final byte[] compress(byte[] input, int offset, int length) {
/* 275 */     Deflater compressor = new Deflater();
/* 276 */     compressor.setLevel(9);
/*     */ 
/*     */     
/* 279 */     compressor.setInput(input, offset, length);
/* 280 */     compressor.finish();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 288 */     ByteArrayOutputStream bos = new ByteArrayOutputStream(length);
/*     */     
/*     */     try {
/* 291 */       compressor.setLevel(9);
/*     */ 
/*     */       
/* 294 */       compressor.setInput(input);
/* 295 */       compressor.finish();
/*     */ 
/*     */       
/* 298 */       byte[] buf = new byte[1024];
/* 299 */       while (!compressor.finished()) {
/* 300 */         int count = compressor.deflate(buf);
/* 301 */         bos.write(buf, 0, count);
/*     */       } 
/*     */     } finally {
/*     */       
/* 305 */       compressor.end();
/*     */     } 
/*     */ 
/*     */     
/* 309 */     return bos.toByteArray();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FieldsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FilterIndexReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilterIndexReader
/*     */   extends IndexReader
/*     */ {
/*     */   protected IndexReader in;
/*     */   
/*     */   public static class FilterTermDocs
/*     */     implements TermDocs
/*     */   {
/*     */     protected TermDocs in;
/*     */     
/*  42 */     public FilterTermDocs(TermDocs in) { this.in = in; }
/*     */     
/*  44 */     public void seek(Term term) throws IOException { this.in.seek(term); }
/*  45 */     public void seek(TermEnum termEnum) throws IOException { this.in.seek(termEnum); }
/*  46 */     public int doc() { return this.in.doc(); }
/*  47 */     public int freq() { return this.in.freq(); }
/*  48 */     public boolean next() throws IOException { return this.in.next(); }
/*     */     
/*  50 */     public int read(int[] docs, int[] freqs) throws IOException { return this.in.read(docs, freqs); }
/*     */     
/*  52 */     public boolean skipTo(int i) throws IOException { return this.in.skipTo(i); }
/*  53 */     public void close() throws IOException { this.in.close(); }
/*     */   }
/*     */   
/*     */   public static class FilterTermPositions
/*     */     extends FilterTermDocs
/*     */     implements TermPositions
/*     */   {
/*  60 */     public FilterTermPositions(TermPositions in) { super(in); }
/*     */ 
/*     */     
/*  63 */     public int nextPosition() throws IOException { return ((TermPositions)this.in).nextPosition(); }
/*     */ 
/*     */ 
/*     */     
/*  67 */     public int getPayloadLength() { return ((TermPositions)this.in).getPayloadLength(); }
/*     */ 
/*     */ 
/*     */     
/*  71 */     public byte[] getPayload(byte[] data, int offset) throws IOException { return ((TermPositions)this.in).getPayload(data, offset); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  77 */     public boolean isPayloadAvailable() { return ((TermPositions)this.in).isPayloadAvailable(); }
/*     */   }
/*     */   
/*     */   public static class FilterTermEnum
/*     */     extends TermEnum
/*     */   {
/*     */     protected TermEnum in;
/*     */     
/*  85 */     public FilterTermEnum(TermEnum in) { this.in = in; }
/*     */     
/*  87 */     public boolean next() throws IOException { return this.in.next(); }
/*  88 */     public Term term() { return this.in.term(); }
/*  89 */     public int docFreq() { return this.in.docFreq(); }
/*  90 */     public void close() throws IOException { this.in.close(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 104 */   public FilterIndexReader(IndexReader in) { this.in = in; }
/*     */ 
/*     */ 
/*     */   
/* 108 */   public Directory directory() { return this.in.directory(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int docNumber) throws IOException {
/* 113 */     ensureOpen();
/* 114 */     return this.in.getTermFreqVectors(docNumber);
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int docNumber, String field) throws IOException {
/* 119 */     ensureOpen();
/* 120 */     return this.in.getTermFreqVector(docNumber, field);
/*     */   }
/*     */ 
/*     */   
/*     */   public void getTermFreqVector(int docNumber, String field, TermVectorMapper mapper) throws IOException {
/* 125 */     ensureOpen();
/* 126 */     this.in.getTermFreqVector(docNumber, field, mapper);
/*     */   }
/*     */ 
/*     */   
/*     */   public void getTermFreqVector(int docNumber, TermVectorMapper mapper) throws IOException {
/* 131 */     ensureOpen();
/* 132 */     this.in.getTermFreqVector(docNumber, mapper);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 137 */   public int numDocs() { return this.in.numDocs(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 142 */   public int maxDoc() { return this.in.maxDoc(); }
/*     */ 
/*     */   
/*     */   public Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 146 */     ensureOpen();
/* 147 */     return this.in.document(n, fieldSelector);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 152 */   public boolean isDeleted(int n) { return this.in.isDeleted(n); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 157 */   public boolean hasDeletions() { return this.in.hasDeletions(); }
/*     */ 
/*     */   
/* 160 */   protected void doUndeleteAll() throws CorruptIndexException, IOException { this.in.undeleteAll(); }
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 163 */     ensureOpen();
/* 164 */     return this.in.hasNorms(field);
/*     */   }
/*     */   
/*     */   public byte[] norms(String f) throws IOException {
/* 168 */     ensureOpen();
/* 169 */     return this.in.norms(f);
/*     */   }
/*     */   
/*     */   public void norms(String f, byte[] bytes, int offset) throws IOException {
/* 173 */     ensureOpen();
/* 174 */     this.in.norms(f, bytes, offset);
/*     */   }
/*     */ 
/*     */   
/* 178 */   protected void doSetNorm(int d, String f, byte b) throws CorruptIndexException, IOException { this.in.setNorm(d, f, b); }
/*     */ 
/*     */   
/*     */   public TermEnum terms() throws IOException {
/* 182 */     ensureOpen();
/* 183 */     return this.in.terms();
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term t) throws IOException {
/* 187 */     ensureOpen();
/* 188 */     return this.in.terms(t);
/*     */   }
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 192 */     ensureOpen();
/* 193 */     return this.in.docFreq(t);
/*     */   }
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 197 */     ensureOpen();
/* 198 */     return this.in.termDocs();
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 202 */     ensureOpen();
/* 203 */     return this.in.termPositions();
/*     */   }
/*     */   
/* 206 */   protected void doDelete(int n) throws CorruptIndexException, IOException { this.in.deleteDocument(n); }
/* 207 */   protected void doCommit() throws IOException { this.in.commit(); }
/* 208 */   protected void doClose() throws IOException { this.in.close(); }
/*     */ 
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 212 */     ensureOpen();
/* 213 */     return this.in.getFieldNames(fieldNames);
/*     */   }
/*     */   
/*     */   public long getVersion() {
/* 217 */     ensureOpen();
/* 218 */     return this.in.getVersion();
/*     */   }
/*     */   
/*     */   public boolean isCurrent() throws CorruptIndexException, IOException {
/* 222 */     ensureOpen();
/* 223 */     return this.in.isCurrent();
/*     */   }
/*     */   
/*     */   public boolean isOptimized() {
/* 227 */     ensureOpen();
/* 228 */     return this.in.isOptimized();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FilterIndexReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FreqProxFieldMergeState,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FreqProxFieldMergeState
/*     */ {
/*     */   final FreqProxTermsWriterPerField field;
/*     */   final int numPostings;
/*     */   final CharBlockPool charPool;
/*     */   final RawPostingList[] postings;
/*     */   private FreqProxTermsWriter.PostingList p;
/*     */   char[] text;
/*     */   int textOffset;
/*  39 */   private int postingUpto = -1;
/*     */   
/*  41 */   final ByteSliceReader freq = new ByteSliceReader();
/*  42 */   final ByteSliceReader prox = new ByteSliceReader();
/*     */   int docID;
/*     */   int termFreq;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public FreqProxFieldMergeState(FreqProxTermsWriterPerField field) {
/*  48 */     this.field = field;
/*  49 */     this.charPool = field.perThread.termsHashPerThread.charPool;
/*  50 */     this.numPostings = field.termsHashPerField.numPostings;
/*  51 */     this.postings = field.termsHashPerField.sortPostings();
/*     */   }
/*     */   
/*     */   boolean nextTerm() throws IOException {
/*  55 */     this.postingUpto++;
/*  56 */     if (this.postingUpto == this.numPostings) {
/*  57 */       return false;
/*     */     }
/*  59 */     this.p = (FreqProxTermsWriter.PostingList)this.postings[this.postingUpto];
/*  60 */     this.docID = 0;
/*     */     
/*  62 */     this.text = this.charPool.buffers[this.p.textStart >> 14];
/*  63 */     this.textOffset = this.p.textStart & 0x3FFF;
/*     */     
/*  65 */     this.field.termsHashPerField.initReader(this.freq, this.p, 0);
/*  66 */     if (!this.field.fieldInfo.omitTf) {
/*  67 */       this.field.termsHashPerField.initReader(this.prox, this.p, 1);
/*     */     }
/*     */     
/*  70 */     boolean result = nextDoc();
/*  71 */     assert result;
/*     */     
/*  73 */     return true;
/*     */   }
/*     */   
/*     */   public boolean nextDoc() throws IOException {
/*  77 */     if (this.freq.eof()) {
/*  78 */       if (this.p.lastDocCode != -1) {
/*     */         
/*  80 */         this.docID = this.p.lastDocID;
/*  81 */         if (!this.field.omitTf)
/*  82 */           this.termFreq = this.p.docFreq; 
/*  83 */         this.p.lastDocCode = -1;
/*  84 */         return true;
/*     */       } 
/*     */       
/*  87 */       return false;
/*     */     } 
/*     */     
/*  90 */     int code = this.freq.readVInt();
/*  91 */     if (this.field.omitTf) {
/*  92 */       this.docID += code;
/*     */     } else {
/*  94 */       this.docID += code >>> 1;
/*  95 */       if ((code & 0x1) != 0) {
/*  96 */         this.termFreq = 1;
/*     */       } else {
/*  98 */         this.termFreq = this.freq.readVInt();
/*     */       } 
/*     */     } 
/* 101 */     assert this.docID != this.p.lastDocID;
/*     */     
/* 103 */     return true;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FreqProxFieldMergeState.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FreqProxTermsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Collections;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.UnicodeUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FreqProxTermsWriter
/*     */   extends TermsHashConsumer
/*     */ {
/*  35 */   public TermsHashConsumerPerThread addThread(TermsHashPerThread perThread) { return new FreqProxTermsWriterPerThread(perThread); }
/*     */ 
/*     */   
/*     */   void createPostings(RawPostingList[] postings, int start, int count) {
/*  39 */     int end = start + count;
/*  40 */     for (int i = start; i < end; i++)
/*  41 */       postings[i] = new PostingList(); 
/*     */   }
/*     */   private static int compareText(char[] text1, int pos1, char[] text2, int pos2) {
/*     */     char c1;
/*     */     do {
/*  46 */       c1 = text1[pos1++];
/*  47 */       char c2 = text2[pos2++];
/*  48 */       if (c1 != c2)
/*  49 */       { if (Character.MAX_VALUE == c2)
/*  50 */           return 1; 
/*  51 */         if (Character.MAX_VALUE == c1) {
/*  52 */           return -1;
/*     */         }
/*  54 */         return c1 - c2; } 
/*  55 */     } while (Character.MAX_VALUE != c1);
/*  56 */     return 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void closeDocStore(DocumentsWriter.FlushState state) {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void abort() {}
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush(Map threadsAndFields, DocumentsWriter.FlushState state) throws IOException {
/*     */     Object proxOut;
/*  73 */     List allFields = new ArrayList();
/*     */     
/*  75 */     Iterator it = threadsAndFields.entrySet().iterator();
/*  76 */     while (it.hasNext()) {
/*     */       
/*  78 */       Map.Entry entry = it.next();
/*     */       
/*  80 */       Collection fields = (Collection)entry.getValue();
/*     */       
/*  82 */       Iterator fieldsIt = fields.iterator();
/*     */       
/*  84 */       while (fieldsIt.hasNext()) {
/*  85 */         proxOut = fieldsIt.next();
/*  86 */         if (proxOut.termsHashPerField.numPostings > 0) {
/*  87 */           allFields.add((FreqProxTermsWriterPerField)proxOut);
/*     */         }
/*     */       } 
/*     */     } 
/*     */     
/*  92 */     Collections.sort(allFields);
/*  93 */     int numAllFields = allFields.size();
/*     */     
/*  95 */     TermInfosWriter termsOut = new TermInfosWriter(state.directory, state.segmentName, this.fieldInfos, state.docWriter.writer.getTermIndexInterval());
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 100 */     IndexOutput freqOut = state.directory.createOutput(state.segmentFileName(""frq""));
/*     */ 
/*     */     
/* 103 */     if (this.fieldInfos.hasProx()) {
/* 104 */       proxOut = state.directory.createOutput(state.segmentFileName(""prx""));
/*     */     } else {
/* 106 */       proxOut = null;
/*     */     } 
/* 108 */     DefaultSkipListWriter skipListWriter = new DefaultSkipListWriter(termsOut.skipInterval, termsOut.maxSkipLevels, state.numDocsInRAM, freqOut, (IndexOutput)proxOut);
/*     */ 
/*     */ 
/*     */     
/* 112 */     int start = 0;
/* 113 */     while (start < numAllFields) {
/* 114 */       FieldInfo fieldInfo = ((FreqProxTermsWriterPerField)allFields.get(start)).fieldInfo;
/* 115 */       String fieldName = fieldInfo.name;
/*     */       
/* 117 */       int end = start + 1;
/* 118 */       while (end < numAllFields && ((FreqProxTermsWriterPerField)allFields.get(end)).fieldInfo.name.equals(fieldName)) {
/* 119 */         end++;
/*     */       }
/* 121 */       FreqProxTermsWriterPerField[] fields = new FreqProxTermsWriterPerField[end - start];
/* 122 */       for (int i = start; i < end; i++) {
/* 123 */         fields[i - start] = allFields.get(i);
/*     */ 
/*     */ 
/*     */         
/* 127 */         fieldInfo.storePayloads |= (fields[i - start]).hasPayloads;
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 132 */       appendPostings(state, fields, termsOut, freqOut, (IndexOutput)proxOut, skipListWriter);
/*     */       
/* 134 */       for (int i = 0; i < fields.length; i++) {
/* 135 */         TermsHashPerField perField = (fields[i]).termsHashPerField;
/* 136 */         int numPostings = perField.numPostings;
/* 137 */         perField.reset();
/* 138 */         perField.shrinkHash(numPostings);
/* 139 */         fields[i].reset();
/*     */       } 
/*     */       
/* 142 */       start = end;
/*     */     } 
/*     */     
/* 145 */     it = threadsAndFields.entrySet().iterator();
/* 146 */     while (it.hasNext()) {
/* 147 */       Map.Entry entry = it.next();
/* 148 */       FreqProxTermsWriterPerThread perThread = (FreqProxTermsWriterPerThread)entry.getKey();
/* 149 */       perThread.termsHashPerThread.reset(true);
/*     */     } 
/*     */     
/* 152 */     freqOut.close();
/* 153 */     if (proxOut != null) {
/* 154 */       state.flushedFiles.add(state.segmentFileName(""prx""));
/* 155 */       proxOut.close();
/*     */     } 
/* 157 */     termsOut.close();
/*     */ 
/*     */     
/* 160 */     state.flushedFiles.add(state.segmentFileName(""fnm""));
/* 161 */     state.flushedFiles.add(state.segmentFileName(""frq""));
/* 162 */     state.flushedFiles.add(state.segmentFileName(""tis""));
/* 163 */     state.flushedFiles.add(state.segmentFileName(""tii""));
/*     */   }
/*     */   
/* 166 */   final byte[] copyByteBuffer = new byte[4096];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void copyBytes(IndexInput srcIn, IndexOutput destIn, long numBytes) throws IOException {
/* 173 */     while (numBytes > 0L) {
/*     */       int chunk;
/* 175 */       if (numBytes > 4096L) {
/* 176 */         chunk = 4096;
/*     */       } else {
/* 178 */         chunk = (int)numBytes;
/* 179 */       }  srcIn.readBytes(this.copyByteBuffer, 0, chunk);
/* 180 */       destIn.writeBytes(this.copyByteBuffer, 0, chunk);
/* 181 */       numBytes -= chunk;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void appendPostings(DocumentsWriter.FlushState flushState, FreqProxTermsWriterPerField[] fields, TermInfosWriter termsOut, IndexOutput freqOut, IndexOutput proxOut, DefaultSkipListWriter skipListWriter) throws CorruptIndexException, IOException {
/* 196 */     int fieldNumber = (fields[0]).fieldInfo.number;
/* 197 */     int numFields = fields.length;
/*     */     
/* 199 */     FreqProxFieldMergeState[] mergeStates = new FreqProxFieldMergeState[numFields];
/*     */     
/* 201 */     for (int i = 0; i < numFields; i++) {
/* 202 */       FreqProxFieldMergeState fms = mergeStates[i] = new FreqProxFieldMergeState(fields[i]);
/*     */       
/* 204 */       assert fms.field.fieldInfo == (fields[0]).fieldInfo;
/*     */ 
/*     */       
/* 207 */       boolean result = fms.nextTerm();
/* 208 */       assert result;
/*     */     } 
/*     */     
/* 211 */     int skipInterval = termsOut.skipInterval;
/* 212 */     boolean currentFieldOmitTf = (fields[0]).fieldInfo.omitTf;
/*     */ 
/*     */ 
/*     */     
/* 216 */     boolean currentFieldStorePayloads = currentFieldOmitTf ? false : (fields[0]).fieldInfo.storePayloads;
/*     */     
/* 218 */     FreqProxFieldMergeState[] termStates = new FreqProxFieldMergeState[numFields];
/*     */     
/* 220 */     while (numFields > 0) {
/*     */       long proxPointer;
/*     */       
/* 223 */       termStates[0] = mergeStates[0];
/* 224 */       int numToMerge = 1;
/*     */       
/* 226 */       for (int i = 1; i < numFields; i++) {
/* 227 */         char[] text = (mergeStates[i]).text;
/* 228 */         int textOffset = (mergeStates[i]).textOffset;
/* 229 */         int cmp = compareText(text, textOffset, (termStates[0]).text, (termStates[0]).textOffset);
/*     */         
/* 231 */         if (cmp < 0) {
/* 232 */           termStates[0] = mergeStates[i];
/* 233 */           numToMerge = 1;
/* 234 */         } else if (cmp == 0) {
/* 235 */           termStates[numToMerge++] = mergeStates[i];
/*     */         } 
/*     */       } 
/* 238 */       int df = 0;
/* 239 */       int lastPayloadLength = -1;
/*     */       
/* 241 */       int lastDoc = 0;
/*     */       
/* 243 */       char[] text = (termStates[0]).text;
/* 244 */       int start = (termStates[0]).textOffset;
/*     */       
/* 246 */       long freqPointer = freqOut.getFilePointer();
/*     */       
/* 248 */       if (proxOut != null) {
/* 249 */         proxPointer = proxOut.getFilePointer();
/*     */       } else {
/* 251 */         proxPointer = 0L;
/*     */       } 
/* 253 */       skipListWriter.resetSkip();
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 258 */       while (numToMerge > 0) {
/*     */         
/* 260 */         if (++df % skipInterval == 0) {
/* 261 */           skipListWriter.setSkipData(lastDoc, currentFieldStorePayloads, lastPayloadLength);
/* 262 */           skipListWriter.bufferSkip(df);
/*     */         } 
/*     */         
/* 265 */         FreqProxFieldMergeState minState = termStates[0];
/* 266 */         for (int i = 1; i < numToMerge; i++) {
/* 267 */           if ((termStates[i]).docID < minState.docID)
/* 268 */             minState = termStates[i]; 
/*     */         } 
/* 270 */         int doc = minState.docID;
/* 271 */         int termDocFreq = minState.termFreq;
/*     */         
/* 273 */         assert doc < flushState.numDocsInRAM;
/* 274 */         assert doc > lastDoc || df == 1;
/*     */         
/* 276 */         ByteSliceReader prox = minState.prox;
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 281 */         if (!currentFieldOmitTf) {
/*     */           
/* 283 */           assert proxOut != null;
/* 284 */           for (int j = 0; j < termDocFreq; j++) {
/* 285 */             int code = prox.readVInt();
/* 286 */             if (currentFieldStorePayloads) {
/*     */               int payloadLength;
/* 288 */               if ((code & 0x1) != 0) {
/*     */                 
/* 290 */                 payloadLength = prox.readVInt();
/*     */               } else {
/* 292 */                 payloadLength = 0;
/* 293 */               }  if (payloadLength != lastPayloadLength) {
/* 294 */                 proxOut.writeVInt(code | 0x1);
/* 295 */                 proxOut.writeVInt(payloadLength);
/* 296 */                 lastPayloadLength = payloadLength;
/*     */               } else {
/* 298 */                 proxOut.writeVInt(code & 0xFFFFFFFE);
/* 299 */               }  if (payloadLength > 0)
/* 300 */                 copyBytes(prox, proxOut, payloadLength); 
/*     */             } else {
/* 302 */               assert 0 == (code & 0x1);
/* 303 */               proxOut.writeVInt(code >> 1);
/*     */             } 
/*     */           } 
/*     */           
/* 307 */           int newDocCode = doc - lastDoc << 1;
/*     */           
/* 309 */           if (1 == termDocFreq) {
/* 310 */             freqOut.writeVInt(newDocCode | 0x1);
/*     */           } else {
/* 312 */             freqOut.writeVInt(newDocCode);
/* 313 */             freqOut.writeVInt(termDocFreq);
/*     */           }
/*     */         
/*     */         } else {
/*     */           
/* 318 */           freqOut.writeVInt(doc - lastDoc);
/*     */         } 
/*     */         
/* 321 */         lastDoc = doc;
/*     */         
/* 323 */         if (!minState.nextDoc()) {
/*     */ 
/*     */           
/* 326 */           int upto = 0;
/* 327 */           for (int i = 0; i < numToMerge; i++) {
/* 328 */             if (termStates[i] != minState)
/* 329 */               termStates[upto++] = termStates[i]; 
/* 330 */           }  numToMerge--;
/* 331 */           assert upto == numToMerge;
/*     */ 
/*     */ 
/*     */           
/* 335 */           if (!minState.nextTerm()) {
/*     */ 
/*     */             
/* 338 */             upto = 0;
/* 339 */             for (int i = 0; i < numFields; i++) {
/* 340 */               if (mergeStates[i] != minState)
/* 341 */                 mergeStates[upto++] = mergeStates[i]; 
/* 342 */             }  numFields--;
/* 343 */             assert upto == numFields;
/*     */           } 
/*     */         } 
/*     */       } 
/*     */       
/* 348 */       assert df > 0;
/*     */ 
/*     */ 
/*     */       
/* 352 */       long skipPointer = skipListWriter.writeSkip(freqOut);
/*     */ 
/*     */       
/* 355 */       this.termInfo.set(df, freqPointer, proxPointer, (int)(skipPointer - freqPointer));
/*     */ 
/*     */       
/* 358 */       UnicodeUtil.UTF16toUTF8(text, start, this.termsUTF8);
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 363 */       termsOut.add(fieldNumber, this.termsUTF8.result, this.termsUTF8.length, this.termInfo);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 370 */   private final TermInfo termInfo = new TermInfo();
/*     */   
/* 372 */   final UnicodeUtil.UTF8Result termsUTF8 = new UnicodeUtil.UTF8Result();
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   void files(Collection files) {}
/*     */   
/*     */   static final class PostingList extends RawPostingList {
/*     */     int docFreq;
/*     */     int lastDocID;
/*     */     int lastDocCode;
/*     */     int lastPosition;
/*     */   }
/*     */   
/* 384 */   int bytesPerPosting() { return 36; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FreqProxTermsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FreqProxTermsWriterPerField,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FreqProxTermsWriterPerField
/*     */   extends TermsHashConsumerPerField
/*     */   implements Comparable
/*     */ {
/*     */   final FreqProxTermsWriterPerThread perThread;
/*     */   final TermsHashPerField termsHashPerField;
/*     */   final FieldInfo fieldInfo;
/*     */   final DocumentsWriter.DocState docState;
/*     */   final DocInverter.FieldInvertState fieldState;
/*     */   boolean omitTf;
/*     */   boolean hasPayloads;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public FreqProxTermsWriterPerField(TermsHashPerField termsHashPerField, FreqProxTermsWriterPerThread perThread, FieldInfo fieldInfo) {
/*  37 */     this.termsHashPerField = termsHashPerField;
/*  38 */     this.perThread = perThread;
/*  39 */     this.fieldInfo = fieldInfo;
/*  40 */     this.docState = termsHashPerField.docState;
/*  41 */     this.fieldState = termsHashPerField.fieldState;
/*  42 */     this.omitTf = fieldInfo.omitTf;
/*     */   }
/*     */   
/*     */   int getStreamCount() {
/*  46 */     if (this.fieldInfo.omitTf) {
/*  47 */       return 1;
/*     */     }
/*  49 */     return 2;
/*     */   }
/*     */ 
/*     */   
/*     */   void finish() {}
/*     */ 
/*     */   
/*     */   void skippingLongTerm(Token t) throws IOException {}
/*     */   
/*     */   public int compareTo(Object other0) {
/*  59 */     FreqProxTermsWriterPerField other = (FreqProxTermsWriterPerField)other0;
/*  60 */     return this.fieldInfo.name.compareTo(other.fieldInfo.name);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  66 */   void reset() { this.omitTf = this.fieldInfo.omitTf; }
/*     */ 
/*     */   
/*     */   boolean start(Fieldable[] fields, int count) {
/*  70 */     for (int i = 0; i < count; i++) {
/*  71 */       if (fields[i].isIndexed())
/*  72 */         return true; 
/*  73 */     }  return false;
/*     */   }
/*     */   
/*     */   final void writeProx(Token t, FreqProxTermsWriter.PostingList p, int proxCode) {
/*  77 */     Payload payload = t.getPayload();
/*  78 */     if (payload != null && payload.length > 0) {
/*  79 */       this.termsHashPerField.writeVInt(1, proxCode << 1 | 0x1);
/*  80 */       this.termsHashPerField.writeVInt(1, payload.length);
/*  81 */       this.termsHashPerField.writeBytes(1, payload.data, payload.offset, payload.length);
/*  82 */       this.hasPayloads = true;
/*     */     } else {
/*  84 */       this.termsHashPerField.writeVInt(1, proxCode << 1);
/*  85 */     }  p.lastPosition = this.fieldState.position;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   final void newTerm(Token t, RawPostingList p0) {
/*  91 */     assert this.docState.testPoint(""FreqProxTermsWriterPerField.newTerm start"");
/*  92 */     FreqProxTermsWriter.PostingList p = (FreqProxTermsWriter.PostingList)p0;
/*  93 */     p.lastDocID = this.docState.docID;
/*  94 */     if (this.omitTf) {
/*  95 */       p.lastDocCode = this.docState.docID;
/*     */     } else {
/*  97 */       p.lastDocCode = this.docState.docID << 1;
/*  98 */       p.docFreq = 1;
/*  99 */       writeProx(t, p, this.fieldState.position);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   final void addTerm(Token t, RawPostingList p0) {
/* 105 */     assert this.docState.testPoint(""FreqProxTermsWriterPerField.addTerm start"");
/*     */     
/* 107 */     FreqProxTermsWriter.PostingList p = (FreqProxTermsWriter.PostingList)p0;
/*     */     
/* 109 */     assert this.omitTf || p.docFreq > 0;
/*     */     
/* 111 */     if (this.omitTf) {
/* 112 */       if (this.docState.docID != p.lastDocID) {
/* 113 */         assert this.docState.docID > p.lastDocID;
/* 114 */         this.termsHashPerField.writeVInt(0, p.lastDocCode);
/* 115 */         p.lastDocCode = this.docState.docID - p.lastDocID;
/* 116 */         p.lastDocID = this.docState.docID;
/*     */       }
/*     */     
/* 119 */     } else if (this.docState.docID != p.lastDocID) {
/* 120 */       assert this.docState.docID > p.lastDocID;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 126 */       if (1 == p.docFreq) {
/* 127 */         this.termsHashPerField.writeVInt(0, p.lastDocCode | 0x1);
/*     */       } else {
/* 129 */         this.termsHashPerField.writeVInt(0, p.lastDocCode);
/* 130 */         this.termsHashPerField.writeVInt(0, p.docFreq);
/*     */       } 
/* 132 */       p.docFreq = 1;
/* 133 */       p.lastDocCode = this.docState.docID - p.lastDocID << 1;
/* 134 */       p.lastDocID = this.docState.docID;
/* 135 */       writeProx(t, p, this.fieldState.position);
/*     */     } else {
/* 137 */       p.docFreq++;
/* 138 */       writeProx(t, p, this.fieldState.position - p.lastPosition);
/*     */     } 
/*     */   }
/*     */   
/*     */   public void abort() {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FreqProxTermsWriterPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FreqProxTermsWriterPerThread,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class FreqProxTermsWriterPerThread
/*    */   extends TermsHashConsumerPerThread
/*    */ {
/*    */   final TermsHashPerThread termsHashPerThread;
/*    */   final DocumentsWriter.DocState docState;
/*    */   
/*    */   public FreqProxTermsWriterPerThread(TermsHashPerThread perThread) {
/* 25 */     this.docState = perThread.docState;
/* 26 */     this.termsHashPerThread = perThread;
/*    */   }
/*    */ 
/*    */   
/* 30 */   public TermsHashConsumerPerField addField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo) { return new FreqProxTermsWriterPerField(termsHashPerField, this, fieldInfo); }
/*    */ 
/*    */ 
/*    */   
/*    */   void startDocument() {}
/*    */ 
/*    */   
/* 37 */   DocumentsWriter.DocWriter finishDocument() { return null; }
/*    */   
/*    */   public void abort() {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\FreqProxTermsWriterPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexCommit,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexCommit
/*     */   implements IndexCommitPoint
/*     */ {
/*     */   public abstract String getSegmentsFileName();
/*     */   
/*     */   public abstract Collection getFileNames() throws IOException;
/*     */   
/*     */   public abstract Directory getDirectory();
/*     */   
/*  74 */   public void delete() { throw new UnsupportedOperationException(""This IndexCommit does not support this method.""); }
/*     */ 
/*     */ 
/*     */   
/*  78 */   public boolean isDeleted() { throw new UnsupportedOperationException(""This IndexCommit does not support this method.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public boolean isOptimized() { throw new UnsupportedOperationException(""This IndexCommit does not support this method.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object other) {
/*  92 */     if (other instanceof IndexCommit) {
/*  93 */       IndexCommit otherCommit = (IndexCommit)other;
/*  94 */       return (otherCommit.getDirectory().equals(getDirectory()) && otherCommit.getVersion() == getVersion());
/*     */     } 
/*  96 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 100 */   public int hashCode() { return getDirectory().hashCode() + getSegmentsFileName().hashCode(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public long getVersion() { throw new UnsupportedOperationException(""This IndexCommit does not support this method.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 113 */   public long getGeneration() { throw new UnsupportedOperationException(""This IndexCommit does not support this method.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 121 */   public long getTimestamp() throws IOException { return getDirectory().fileModified(getSegmentsFileName()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexCommit.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexCommitPoint,"package org.apache.lucene.index;
import java.io.IOException;
import java.util.Collection;
public interface IndexCommitPoint {
  String getSegmentsFileName();
  Collection getFileNames() throws IOException;
  void delete();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexCommitPoint.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexDeletionPolicy,"package org.apache.lucene.index;
import java.io.IOException;
import java.util.List;
public interface IndexDeletionPolicy {
  void onInit(List paramList) throws IOException;
  void onCommit(List paramList) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexDeletionPolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileDeleter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.FileNotFoundException;
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Collections;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class IndexFileDeleter
/*     */ {
/*     */   private List deletable;
/*  87 */   private Map refCounts = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  94 */   private List commits = new ArrayList();
/*     */ 
/*     */ 
/*     */   
/*  98 */   private List lastFiles = new ArrayList();
/*     */ 
/*     */   
/* 101 */   private List commitsToDelete = new ArrayList();
/*     */   
/*     */   private PrintStream infoStream;
/*     */   
/*     */   private Directory directory;
/*     */   
/*     */   private IndexDeletionPolicy policy;
/*     */   private DocumentsWriter docWriter;
/*     */   public static boolean VERBOSE_REF_COUNTS = false;
/*     */   static Class class$org$apache$lucene$index$IndexFileDeleter;
/*     */   
/*     */   void setInfoStream(PrintStream infoStream) {
/* 113 */     this.infoStream = infoStream;
/* 114 */     if (infoStream != null) {
/* 115 */       message(""setInfoStream deletionPolicy="" + this.policy);
/*     */     }
/*     */   }
/*     */   
/* 119 */   private void message(String message) { this.infoStream.println(""IFD ["" + Thread.currentThread().getName() + ""]: "" + message); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter) throws CorruptIndexException, IOException {
/* 135 */     this.docWriter = docWriter;
/* 136 */     this.infoStream = infoStream;
/*     */     
/* 138 */     if (infoStream != null) {
/* 139 */       message(""init: current segments file is \"""" + segmentInfos.getCurrentSegmentFileName() + ""\""; deletionPolicy="" + policy);
/*     */     }
/* 141 */     this.policy = policy;
/* 142 */     this.directory = directory;
/*     */ 
/*     */ 
/*     */     
/* 146 */     long currentGen = segmentInfos.getGeneration();
/* 147 */     IndexFileNameFilter filter = IndexFileNameFilter.getFilter();
/*     */     
/* 149 */     String[] files = directory.list();
/* 150 */     if (files == null) {
/* 151 */       throw new IOException(""cannot read directory "" + directory + "": list() returned null"");
/*     */     }
/* 153 */     CommitPoint currentCommitPoint = null;
/*     */     
/* 155 */     for (int i = 0; i < files.length; i++) {
/*     */       
/* 157 */       String fileName = files[i];
/*     */       
/* 159 */       if (filter.accept(null, fileName) && !fileName.equals(""segments.gen"")) {
/*     */ 
/*     */         
/* 162 */         getRefCount(fileName);
/*     */         
/* 164 */         if (fileName.startsWith(""segments""))
/*     */         {
/*     */ 
/*     */ 
/*     */           
/* 169 */           if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {
/* 170 */             if (infoStream != null) {
/* 171 */               message(""init: load commit \"""" + fileName + ""\"""");
/*     */             }
/* 173 */             SegmentInfos sis = new SegmentInfos();
/*     */             try {
/* 175 */               sis.read(directory, fileName);
/* 176 */             } catch (FileNotFoundException e) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */               
/* 184 */               if (infoStream != null) {
/* 185 */                 message(""init: hit FileNotFoundException when loading commit \"""" + fileName + ""\""; skipping this commit point"");
/*     */               }
/* 187 */               sis = null;
/*     */             } 
/* 189 */             if (sis != null) {
/* 190 */               CommitPoint commitPoint = new CommitPoint(this.commitsToDelete, directory, sis);
/* 191 */               if (sis.getGeneration() == segmentInfos.getGeneration()) {
/* 192 */                 currentCommitPoint = commitPoint;
/*     */               }
/* 194 */               this.commits.add(commitPoint);
/* 195 */               incRef(sis, true);
/*     */             } 
/*     */           } 
/*     */         }
/*     */       } 
/*     */     } 
/*     */     
/* 202 */     if (currentCommitPoint == null) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 210 */       SegmentInfos sis = new SegmentInfos();
/*     */       try {
/* 212 */         sis.read(directory, segmentInfos.getCurrentSegmentFileName());
/* 213 */       } catch (IOException e) {
/* 214 */         throw new CorruptIndexException(""failed to locate current segments_N file"");
/*     */       } 
/* 216 */       if (infoStream != null)
/* 217 */         message(""forced open of current segments file "" + segmentInfos.getCurrentSegmentFileName()); 
/* 218 */       currentCommitPoint = new CommitPoint(this.commitsToDelete, directory, sis);
/* 219 */       this.commits.add(currentCommitPoint);
/* 220 */       incRef(sis, true);
/*     */     } 
/*     */ 
/*     */     
/* 224 */     Collections.sort(this.commits);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 229 */     Iterator it = this.refCounts.keySet().iterator();
/* 230 */     while (it.hasNext()) {
/* 231 */       String fileName = it.next();
/* 232 */       RefCount rc = (RefCount)this.refCounts.get(fileName);
/* 233 */       if (0 == rc.count) {
/* 234 */         if (infoStream != null) {
/* 235 */           message(""init: removing unreferenced file \"""" + fileName + ""\"""");
/*     */         }
/* 237 */         deleteFile(fileName);
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 243 */     policy.onInit(this.commits);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 248 */     if (currentCommitPoint.deleted) {
/* 249 */       checkpoint(segmentInfos, false);
/*     */     }
/*     */     
/* 252 */     deleteCommits();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void deleteCommits() throws IOException {
/* 261 */     int size = this.commitsToDelete.size();
/*     */     
/* 263 */     if (size > 0) {
/*     */ 
/*     */ 
/*     */       
/* 267 */       for (int i = 0; i < size; i++) {
/* 268 */         CommitPoint commit = this.commitsToDelete.get(i);
/* 269 */         if (this.infoStream != null) {
/* 270 */           message(""deleteCommits: now decRef commit \"""" + commit.getSegmentsFileName() + ""\"""");
/*     */         }
/* 272 */         int size2 = commit.files.size();
/* 273 */         for (int j = 0; j < size2; j++) {
/* 274 */           decRef(commit.files.get(j));
/*     */         }
/*     */       } 
/* 277 */       this.commitsToDelete.clear();
/*     */ 
/*     */       
/* 280 */       size = this.commits.size();
/* 281 */       int readFrom = 0;
/* 282 */       int writeTo = 0;
/* 283 */       while (readFrom < size) {
/* 284 */         CommitPoint commit = this.commits.get(readFrom);
/* 285 */         if (!commit.deleted) {
/* 286 */           if (writeTo != readFrom) {
/* 287 */             this.commits.set(writeTo, this.commits.get(readFrom));
/*     */           }
/* 289 */           writeTo++;
/*     */         } 
/* 291 */         readFrom++;
/*     */       } 
/*     */       
/* 294 */       while (size > writeTo) {
/* 295 */         this.commits.remove(size - 1);
/* 296 */         size--;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void refresh(String segmentName) throws IOException {
/* 310 */     String segmentPrefix2, segmentPrefix1, files[] = this.directory.list();
/* 311 */     if (files == null)
/* 312 */       throw new IOException(""cannot read directory "" + this.directory + "": list() returned null""); 
/* 313 */     IndexFileNameFilter filter = IndexFileNameFilter.getFilter();
/*     */ 
/*     */     
/* 316 */     if (segmentName != null) {
/* 317 */       segmentPrefix1 = segmentName + ""."";
/* 318 */       segmentPrefix2 = segmentName + ""_"";
/*     */     } else {
/* 320 */       segmentPrefix1 = null;
/* 321 */       segmentPrefix2 = null;
/*     */     } 
/*     */     
/* 324 */     for (int i = 0; i < files.length; i++) {
/* 325 */       String fileName = files[i];
/* 326 */       if (filter.accept(null, fileName) && (segmentName == null || fileName.startsWith(segmentPrefix1) || fileName.startsWith(segmentPrefix2)) && !this.refCounts.containsKey(fileName) && !fileName.equals(""segments.gen"")) {
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 331 */         if (this.infoStream != null) {
/* 332 */           message(""refresh [prefix="" + segmentName + ""]: removing newly created unreferenced file \"""" + fileName + ""\"""");
/*     */         }
/* 334 */         deleteFile(fileName);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 340 */   public void refresh() throws IOException { refresh(null); }
/*     */ 
/*     */ 
/*     */   
/* 344 */   public void close() throws IOException { deletePendingFiles(); }
/*     */ 
/*     */   
/*     */   private void deletePendingFiles() throws IOException {
/* 348 */     if (this.deletable != null) {
/* 349 */       List oldDeletable = this.deletable;
/* 350 */       this.deletable = null;
/* 351 */       int size = oldDeletable.size();
/* 352 */       for (int i = 0; i < size; i++) {
/* 353 */         if (this.infoStream != null)
/* 354 */           message(""delete pending file "" + oldDeletable.get(i)); 
/* 355 */         deleteFile(oldDeletable.get(i));
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {
/* 382 */     if (this.infoStream != null) {
/* 383 */       message(""now checkpoint \"""" + segmentInfos.getCurrentSegmentFileName() + ""\"" ["" + segmentInfos.size() + "" segments "" + ""; isCommit = "" + isCommit + ""]"");
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 388 */     deletePendingFiles();
/*     */ 
/*     */     
/* 391 */     incRef(segmentInfos, isCommit);
/*     */     
/* 393 */     if (isCommit) {
/*     */       
/* 395 */       this.commits.add(new CommitPoint(this.commitsToDelete, this.directory, segmentInfos));
/*     */ 
/*     */       
/* 398 */       this.policy.onCommit(this.commits);
/*     */ 
/*     */       
/* 401 */       deleteCommits();
/*     */     } else {
/*     */       List docWriterFiles;
/*     */       
/* 405 */       if (this.docWriter != null) {
/* 406 */         docWriterFiles = this.docWriter.openFiles();
/* 407 */         if (docWriterFiles != null)
/*     */         {
/*     */ 
/*     */           
/* 411 */           incRef(docWriterFiles); } 
/*     */       } else {
/* 413 */         docWriterFiles = null;
/*     */       } 
/*     */       
/* 416 */       int size = this.lastFiles.size();
/* 417 */       if (size > 0) {
/* 418 */         for (int i = 0; i < size; i++)
/* 419 */           decRef(this.lastFiles.get(i)); 
/* 420 */         this.lastFiles.clear();
/*     */       } 
/*     */ 
/*     */       
/* 424 */       size = segmentInfos.size();
/* 425 */       for (int i = 0; i < size; i++) {
/* 426 */         SegmentInfo segmentInfo = segmentInfos.info(i);
/* 427 */         if (segmentInfo.dir == this.directory) {
/* 428 */           this.lastFiles.add(segmentInfo.files());
/*     */         }
/*     */       } 
/* 431 */       if (docWriterFiles != null)
/* 432 */         this.lastFiles.add(docWriterFiles); 
/*     */     } 
/*     */   }
/*     */   
/*     */   void incRef(SegmentInfos segmentInfos, boolean isCommit) throws IOException {
/* 437 */     int size = segmentInfos.size();
/* 438 */     for (int i = 0; i < size; i++) {
/* 439 */       SegmentInfo segmentInfo = segmentInfos.info(i);
/* 440 */       if (segmentInfo.dir == this.directory) {
/* 441 */         incRef(segmentInfo.files());
/*     */       }
/*     */     } 
/*     */     
/* 445 */     if (isCommit)
/*     */     {
/*     */       
/* 448 */       getRefCount(segmentInfos.getCurrentSegmentFileName()).IncRef();
/*     */     }
/*     */   }
/*     */   
/*     */   void incRef(List files) throws IOException {
/* 453 */     int size = files.size();
/* 454 */     for (int i = 0; i < size; i++) {
/* 455 */       String fileName = files.get(i);
/* 456 */       RefCount rc = getRefCount(fileName);
/* 457 */       if (this.infoStream != null && VERBOSE_REF_COUNTS) {
/* 458 */         message(""  IncRef \"""" + fileName + ""\"": pre-incr count is "" + rc.count);
/*     */       }
/* 460 */       rc.IncRef();
/*     */     } 
/*     */   }
/*     */   
/*     */   void decRef(List files) throws IOException {
/* 465 */     int size = files.size();
/* 466 */     for (int i = 0; i < size; i++) {
/* 467 */       decRef(files.get(i));
/*     */     }
/*     */   }
/*     */   
/*     */   void decRef(String fileName) throws IOException {
/* 472 */     RefCount rc = getRefCount(fileName);
/* 473 */     if (this.infoStream != null && VERBOSE_REF_COUNTS) {
/* 474 */       message(""  DecRef \"""" + fileName + ""\"": pre-decr count is "" + rc.count);
/*     */     }
/* 476 */     if (0 == rc.DecRef()) {
/*     */ 
/*     */       
/* 479 */       deleteFile(fileName);
/* 480 */       this.refCounts.remove(fileName);
/*     */     } 
/*     */   }
/*     */   
/*     */   void decRef(SegmentInfos segmentInfos) throws IOException {
/* 485 */     int size = segmentInfos.size();
/* 486 */     for (int i = 0; i < size; i++) {
/* 487 */       SegmentInfo segmentInfo = segmentInfos.info(i);
/* 488 */       if (segmentInfo.dir == this.directory) {
/* 489 */         decRef(segmentInfo.files());
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   private RefCount getRefCount(String fileName) {
/*     */     RefCount rc;
/* 496 */     if (!this.refCounts.containsKey(fileName)) {
/* 497 */       rc = new RefCount();
/* 498 */       this.refCounts.put(fileName, rc);
/*     */     } else {
/* 500 */       rc = (RefCount)this.refCounts.get(fileName);
/*     */     } 
/* 502 */     return rc;
/*     */   }
/*     */   
/*     */   void deleteFiles(List files) throws IOException {
/* 506 */     int size = files.size();
/* 507 */     for (int i = 0; i < size; i++) {
/* 508 */       deleteFile(files.get(i));
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   void deleteNewFiles(Collection files) throws IOException {
/* 514 */     Iterator it = files.iterator();
/* 515 */     while (it.hasNext()) {
/* 516 */       String fileName = it.next();
/* 517 */       if (!this.refCounts.containsKey(fileName)) {
/* 518 */         deleteFile(fileName);
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   void deleteFile(String fileName) throws IOException {
/*     */     try {
/* 525 */       if (this.infoStream != null) {
/* 526 */         message(""delete \"""" + fileName + ""\"""");
/*     */       }
/* 528 */       this.directory.deleteFile(fileName);
/* 529 */     } catch (IOException e) {
/* 530 */       if (this.directory.fileExists(fileName)) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 539 */         if (this.infoStream != null) {
/* 540 */           message(""IndexFileDeleter: unable to remove file \"""" + fileName + ""\"": "" + e.toString() + ""; Will re-try later."");
/*     */         }
/* 542 */         if (this.deletable == null) {
/* 543 */           this.deletable = new ArrayList();
/*     */         }
/* 545 */         this.deletable.add(fileName);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   static Class class$(String x0) { 
/* 553 */     try { return Class.forName(x0); } catch (ClassNotFoundException x1) { throw (new NoClassDefFoundError()).initCause(x1); }
/*     */      }
/*     */   
/*     */   private static final class RefCount { int count;
/*     */     
/* 558 */     public int IncRef() { return ++this.count; }
/*     */     static final boolean $assertionsDisabled;
/*     */     private RefCount() {}
/*     */     public int DecRef() {
/* 562 */       assert this.count > 0;
/* 563 */       return --this.count;
/*     */     } }
/*     */ 
/*     */ 
/*     */   
/*     */   private static final class CommitPoint
/*     */     extends IndexCommit
/*     */     implements Comparable
/*     */   {
/*     */     long gen;
/*     */     
/*     */     List files;
/*     */     
/*     */     String segmentsFileName;
/*     */     
/*     */     boolean deleted;
/*     */     
/*     */     Directory directory;
/*     */     Collection commitsToDelete;
/*     */     long version;
/*     */     long generation;
/*     */     final boolean isOptimized;
/*     */     
/*     */     public CommitPoint(Collection commitsToDelete, Directory directory, SegmentInfos segmentInfos) throws IOException {
/* 587 */       this.directory = directory;
/* 588 */       this.commitsToDelete = commitsToDelete;
/* 589 */       this.segmentsFileName = segmentInfos.getCurrentSegmentFileName();
/* 590 */       this.version = segmentInfos.getVersion();
/* 591 */       this.generation = segmentInfos.getGeneration();
/* 592 */       int size = segmentInfos.size();
/* 593 */       this.files = new ArrayList(size);
/* 594 */       this.files.add(this.segmentsFileName);
/* 595 */       this.gen = segmentInfos.getGeneration();
/* 596 */       for (int i = 0; i < size; i++) {
/* 597 */         SegmentInfo segmentInfo = segmentInfos.info(i);
/* 598 */         if (segmentInfo.dir == directory) {
/* 599 */           this.files.addAll(segmentInfo.files());
/*     */         }
/*     */       } 
/* 602 */       this.isOptimized = (segmentInfos.size() == 1 && !segmentInfos.info(0).hasDeletions());
/*     */     }
/*     */ 
/*     */     
/* 606 */     public boolean isOptimized() { return this.isOptimized; }
/*     */ 
/*     */ 
/*     */     
/* 610 */     public String getSegmentsFileName() { return this.segmentsFileName; }
/*     */ 
/*     */ 
/*     */     
/* 614 */     public Collection getFileNames() throws IOException { return Collections.unmodifiableCollection(this.files); }
/*     */ 
/*     */ 
/*     */     
/* 618 */     public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */     
/* 622 */     public long getVersion() { return this.version; }
/*     */ 
/*     */ 
/*     */     
/* 626 */     public long getGeneration() { return this.generation; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public void delete() {
/* 634 */       if (!this.deleted) {
/* 635 */         this.deleted = true;
/* 636 */         this.commitsToDelete.add(this);
/*     */       } 
/*     */     }
/*     */ 
/*     */     
/* 641 */     public boolean isDeleted() { return this.deleted; }
/*     */ 
/*     */     
/*     */     public int compareTo(Object obj) {
/* 645 */       CommitPoint commit = (CommitPoint)obj;
/* 646 */       if (this.gen < commit.gen)
/* 647 */         return -1; 
/* 648 */       if (this.gen > commit.gen) {
/* 649 */         return 1;
/*     */       }
/* 651 */       return 0;
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexFileDeleter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileNameFilter,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.FilenameFilter;
/*    */ import java.util.HashSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class IndexFileNameFilter
/*    */   implements FilenameFilter
/*    */ {
/* 31 */   static IndexFileNameFilter singleton = new IndexFileNameFilter();
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 36 */   private HashSet extensions = new HashSet(); public IndexFileNameFilter() {
/* 37 */     for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS.length; i++) {
/* 38 */       this.extensions.add(IndexFileNames.INDEX_EXTENSIONS[i]);
/*    */     }
/* 40 */     this.extensionsInCFS = new HashSet();
/* 41 */     for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE.length; i++) {
/* 42 */       this.extensionsInCFS.add(IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE[i]);
/*    */     }
/*    */   }
/*    */ 
/*    */   
/*    */   private HashSet extensionsInCFS;
/*    */   
/*    */   public boolean accept(File dir, String name) {
/* 50 */     int i = name.lastIndexOf('.');
/* 51 */     if (i != -1) {
/* 52 */       String extension = name.substring(1 + i);
/* 53 */       if (this.extensions.contains(extension))
/* 54 */         return true; 
/* 55 */       if (extension.startsWith(""f"") && extension.matches(""f\\d+""))
/*    */       {
/* 57 */         return true; } 
/* 58 */       if (extension.startsWith(""s"") && extension.matches(""s\\d+""))
/*    */       {
/* 60 */         return true;
/*    */       }
/*    */     } else {
/* 63 */       if (name.equals(""deletable"")) return true; 
/* 64 */       if (name.startsWith(""segments"")) return true; 
/*    */     } 
/* 66 */     return false;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean isCFSFile(String name) {
/* 76 */     int i = name.lastIndexOf('.');
/* 77 */     if (i != -1) {
/* 78 */       String extension = name.substring(1 + i);
/* 79 */       if (this.extensionsInCFS.contains(extension)) {
/* 80 */         return true;
/*    */       }
/* 82 */       if (extension.startsWith(""f"") && extension.matches(""f\\d+""))
/*    */       {
/* 84 */         return true;
/*    */       }
/*    */     } 
/* 87 */     return false;
/*    */   }
/*    */ 
/*    */   
/* 91 */   public static IndexFileNameFilter getFilter() { return singleton; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexFileNameFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileNames,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class IndexFileNames
/*     */ {
/*     */   static final String SEGMENTS = ""segments"";
/*     */   static final String SEGMENTS_GEN = ""segments.gen"";
/*     */   static final String DELETABLE = ""deletable"";
/*     */   static final String NORMS_EXTENSION = ""nrm"";
/*     */   static final String FREQ_EXTENSION = ""frq"";
/*     */   static final String PROX_EXTENSION = ""prx"";
/*     */   static final String TERMS_EXTENSION = ""tis"";
/*     */   static final String TERMS_INDEX_EXTENSION = ""tii"";
/*     */   static final String FIELDS_INDEX_EXTENSION = ""fdx"";
/*     */   static final String FIELDS_EXTENSION = ""fdt"";
/*     */   static final String VECTORS_FIELDS_EXTENSION = ""tvf"";
/*     */   static final String VECTORS_DOCUMENTS_EXTENSION = ""tvd"";
/*     */   static final String VECTORS_INDEX_EXTENSION = ""tvx"";
/*     */   static final String COMPOUND_FILE_EXTENSION = ""cfs"";
/*     */   static final String COMPOUND_FILE_STORE_EXTENSION = ""cfx"";
/*     */   static final String DELETES_EXTENSION = ""del"";
/*     */   static final String FIELD_INFOS_EXTENSION = ""fnm"";
/*     */   static final String PLAIN_NORMS_EXTENSION = ""f"";
/*     */   static final String SEPARATE_NORMS_EXTENSION = ""s"";
/*     */   static final String GEN_EXTENSION = ""gen"";
/*  96 */   static final String[] INDEX_EXTENSIONS = new String[] { ""cfs"", ""fnm"", ""fdx"", ""fdt"", ""tii"", ""tis"", ""frq"", ""prx"", ""del"", ""tvx"", ""tvd"", ""tvf"", ""gen"", ""nrm"", ""cfx"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 116 */   static final String[] INDEX_EXTENSIONS_IN_COMPOUND_FILE = new String[] { ""fnm"", ""fdx"", ""fdt"", ""tii"", ""tis"", ""frq"", ""prx"", ""tvx"", ""tvd"", ""tvf"", ""nrm"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 130 */   static final String[] STORE_INDEX_EXTENSIONS = new String[] { ""tvx"", ""tvf"", ""tvd"", ""fdx"", ""fdt"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 138 */   static final String[] NON_STORE_INDEX_EXTENSIONS = new String[] { ""fnm"", ""frq"", ""prx"", ""tis"", ""tii"", ""nrm"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 148 */   static final String[] COMPOUND_EXTENSIONS = new String[] { ""fnm"", ""frq"", ""prx"", ""fdx"", ""fdt"", ""tii"", ""tis"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 159 */   static final String[] VECTOR_EXTENSIONS = new String[] { ""tvx"", ""tvd"", ""tvf"" };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static final String fileNameFromGeneration(String base, String extension, long gen) {
/* 176 */     if (gen == -1L)
/* 177 */       return null; 
/* 178 */     if (gen == 0L) {
/* 179 */       return base + extension;
/*     */     }
/* 181 */     return base + ""_"" + Long.toString(gen, 36) + extension;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static final boolean isDocStoreFile(String fileName) {
/* 191 */     if (fileName.endsWith(""cfx""))
/* 192 */       return true; 
/* 193 */     for (int i = 0; i < STORE_INDEX_EXTENSIONS.length; i++) {
/* 194 */       if (fileName.endsWith(STORE_INDEX_EXTENSIONS[i]))
/* 195 */         return true; 
/* 196 */     }  return false;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexFileNames.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexModifier,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.FSDirectory;
/*     */ import org.apache.lucene.store.LockObtainFailedException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IndexModifier
/*     */ {
/*  95 */   protected IndexWriter indexWriter = null;
/*  96 */   protected IndexReader indexReader = null;
/*     */   
/*  98 */   protected Directory directory = null;
/*  99 */   protected Analyzer analyzer = null;
/*     */   
/*     */   protected boolean open = false;
/*     */   
/* 103 */   protected PrintStream infoStream = null;
/*     */   protected boolean useCompoundFile = true;
/* 105 */   protected int maxBufferedDocs = -1;
/* 106 */   protected int maxFieldLength = 10000;
/* 107 */   protected int mergeFactor = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 123 */   public IndexModifier(Directory directory, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { init(directory, analyzer, create); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexModifier(String dirName, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 140 */     FSDirectory fSDirectory = FSDirectory.getDirectory(dirName);
/* 141 */     init((Directory)fSDirectory, analyzer, create);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexModifier(File file, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 158 */     FSDirectory fSDirectory = FSDirectory.getDirectory(file);
/* 159 */     init((Directory)fSDirectory, analyzer, create);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void init(Directory directory, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 171 */     this.directory = directory;
/* 172 */     synchronized (this.directory) {
/* 173 */       this.analyzer = analyzer;
/* 174 */       this.indexWriter = new IndexWriter(directory, analyzer, create, IndexWriter.MaxFieldLength.LIMITED);
/* 175 */       this.open = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void assureOpen() {
/* 184 */     if (!this.open) {
/* 185 */       throw new IllegalStateException(""Index is closed"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void createIndexWriter() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 198 */     if (this.indexWriter == null) {
/* 199 */       if (this.indexReader != null) {
/* 200 */         this.indexReader.close();
/* 201 */         this.indexReader = null;
/*     */       } 
/* 203 */       this.indexWriter = new IndexWriter(this.directory, this.analyzer, false, new IndexWriter.MaxFieldLength(this.maxFieldLength));
/*     */ 
/*     */ 
/*     */       
/* 207 */       this.indexWriter.setMergeScheduler(new SerialMergeScheduler());
/* 208 */       this.indexWriter.setInfoStream(this.infoStream);
/* 209 */       this.indexWriter.setUseCompoundFile(this.useCompoundFile);
/* 210 */       if (this.maxBufferedDocs != -1)
/* 211 */         this.indexWriter.setMaxBufferedDocs(this.maxBufferedDocs); 
/* 212 */       this.indexWriter.setMergeFactor(this.mergeFactor);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void createIndexReader() throws CorruptIndexException, IOException {
/* 222 */     if (this.indexReader == null) {
/* 223 */       if (this.indexWriter != null) {
/* 224 */         this.indexWriter.close();
/* 225 */         this.indexWriter = null;
/*     */       } 
/* 227 */       this.indexReader = IndexReader.open(this.directory);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 240 */     synchronized (this.directory) {
/* 241 */       assureOpen();
/* 242 */       if (this.indexWriter != null) {
/* 243 */         this.indexWriter.close();
/* 244 */         this.indexWriter = null;
/* 245 */         createIndexWriter();
/*     */       } else {
/* 247 */         this.indexReader.close();
/* 248 */         this.indexReader = null;
/* 249 */         createIndexReader();
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addDocument(Document doc, Analyzer docAnalyzer) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 268 */     synchronized (this.directory) {
/* 269 */       assureOpen();
/* 270 */       createIndexWriter();
/* 271 */       if (docAnalyzer != null) {
/* 272 */         this.indexWriter.addDocument(doc, docAnalyzer);
/*     */       } else {
/* 274 */         this.indexWriter.addDocument(doc);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 291 */   public void addDocument(Document doc) throws CorruptIndexException, LockObtainFailedException, IOException { addDocument(doc, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int deleteDocuments(Term term) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 312 */     synchronized (this.directory) {
/* 313 */       assureOpen();
/* 314 */       createIndexReader();
/* 315 */       return this.indexReader.deleteDocuments(term);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void deleteDocument(int docNum) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 331 */     synchronized (this.directory) {
/* 332 */       assureOpen();
/* 333 */       createIndexReader();
/* 334 */       this.indexReader.deleteDocument(docNum);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int docCount() {
/* 349 */     synchronized (this.directory) {
/* 350 */       assureOpen();
/* 351 */       if (this.indexWriter != null) {
/* 352 */         return this.indexWriter.docCount();
/*     */       }
/* 354 */       return this.indexReader.numDocs();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void optimize() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 371 */     synchronized (this.directory) {
/* 372 */       assureOpen();
/* 373 */       createIndexWriter();
/* 374 */       this.indexWriter.optimize();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setInfoStream(PrintStream infoStream) {
/* 386 */     synchronized (this.directory) {
/* 387 */       assureOpen();
/* 388 */       if (this.indexWriter != null) {
/* 389 */         this.indexWriter.setInfoStream(infoStream);
/*     */       }
/* 391 */       this.infoStream = infoStream;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public PrintStream getInfoStream() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 404 */     synchronized (this.directory) {
/* 405 */       assureOpen();
/* 406 */       createIndexWriter();
/* 407 */       return this.indexWriter.getInfoStream();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setUseCompoundFile(boolean useCompoundFile) {
/* 419 */     synchronized (this.directory) {
/* 420 */       assureOpen();
/* 421 */       if (this.indexWriter != null) {
/* 422 */         this.indexWriter.setUseCompoundFile(useCompoundFile);
/*     */       }
/* 424 */       this.useCompoundFile = useCompoundFile;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean getUseCompoundFile() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 437 */     synchronized (this.directory) {
/* 438 */       assureOpen();
/* 439 */       createIndexWriter();
/* 440 */       return this.indexWriter.getUseCompoundFile();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxFieldLength(int maxFieldLength) {
/* 459 */     synchronized (this.directory) {
/* 460 */       assureOpen();
/* 461 */       if (this.indexWriter != null) {
/* 462 */         this.indexWriter.setMaxFieldLength(maxFieldLength);
/*     */       }
/* 464 */       this.maxFieldLength = maxFieldLength;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMaxFieldLength() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 477 */     synchronized (this.directory) {
/* 478 */       assureOpen();
/* 479 */       createIndexWriter();
/* 480 */       return this.indexWriter.getMaxFieldLength();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxBufferedDocs(int maxBufferedDocs) {
/* 498 */     synchronized (this.directory) {
/* 499 */       assureOpen();
/* 500 */       if (this.indexWriter != null) {
/* 501 */         this.indexWriter.setMaxBufferedDocs(maxBufferedDocs);
/*     */       }
/* 503 */       this.maxBufferedDocs = maxBufferedDocs;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMaxBufferedDocs() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 516 */     synchronized (this.directory) {
/* 517 */       assureOpen();
/* 518 */       createIndexWriter();
/* 519 */       return this.indexWriter.getMaxBufferedDocs();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMergeFactor(int mergeFactor) {
/* 537 */     synchronized (this.directory) {
/* 538 */       assureOpen();
/* 539 */       if (this.indexWriter != null) {
/* 540 */         this.indexWriter.setMergeFactor(mergeFactor);
/*     */       }
/* 542 */       this.mergeFactor = mergeFactor;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMergeFactor() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 555 */     synchronized (this.directory) {
/* 556 */       assureOpen();
/* 557 */       createIndexWriter();
/* 558 */       return this.indexWriter.getMergeFactor();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws CorruptIndexException, IOException {
/* 570 */     synchronized (this.directory) {
/* 571 */       if (!this.open)
/* 572 */         throw new IllegalStateException(""Index is closed already""); 
/* 573 */       if (this.indexWriter != null) {
/* 574 */         this.indexWriter.close();
/* 575 */         this.indexWriter = null;
/* 576 */       } else if (this.indexReader != null) {
/* 577 */         this.indexReader.close();
/* 578 */         this.indexReader = null;
/*     */       } 
/* 580 */       this.open = false;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 585 */   public String toString() { return ""Index@"" + this.directory; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexModifier.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexReader,"/*      */ package org.apache.lucene.index;
/*      */ 
/*      */ import java.io.File;
/*      */ import java.io.FileOutputStream;
/*      */ import java.io.IOException;
/*      */ import java.util.Arrays;
/*      */ import java.util.Collection;
/*      */ import org.apache.lucene.document.Document;
/*      */ import org.apache.lucene.document.FieldSelector;
/*      */ import org.apache.lucene.search.Similarity;
/*      */ import org.apache.lucene.store.AlreadyClosedException;
/*      */ import org.apache.lucene.store.Directory;
/*      */ import org.apache.lucene.store.FSDirectory;
/*      */ import org.apache.lucene.store.IndexInput;
/*      */ import org.apache.lucene.store.LockObtainFailedException;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public abstract class IndexReader
/*      */ {
/*      */   static final boolean READ_ONLY_DEFAULT = false;
/*      */   private boolean closed;
/*      */   protected boolean hasChanges;
/*      */   private volatile int refCount;
/*      */   private Directory directory;
/*      */   static final boolean $assertionsDisabled;
/*      */   
/*      */   public static final class FieldOption
/*      */   {
/*      */     private String option;
/*      */     
/*      */     private FieldOption() {}
/*      */     
/*   83 */     private FieldOption(String option) { this.option = option; }
/*      */ 
/*      */     
/*   86 */     public String toString() { return this.option; }
/*      */ 
/*      */     
/*   89 */     public static final FieldOption ALL = new FieldOption(""ALL"");
/*      */     
/*   91 */     public static final FieldOption INDEXED = new FieldOption(""INDEXED"");
/*      */     
/*   93 */     public static final FieldOption STORES_PAYLOADS = new FieldOption(""STORES_PAYLOADS"");
/*      */     
/*   95 */     public static final FieldOption OMIT_TF = new FieldOption(""OMIT_TF"");
/*      */     
/*   97 */     public static final FieldOption UNINDEXED = new FieldOption(""UNINDEXED"");
/*      */     
/*   99 */     public static final FieldOption INDEXED_WITH_TERMVECTOR = new FieldOption(""INDEXED_WITH_TERMVECTOR"");
/*      */     
/*  101 */     public static final FieldOption INDEXED_NO_TERMVECTOR = new FieldOption(""INDEXED_NO_TERMVECTOR"");
/*      */     
/*  103 */     public static final FieldOption TERMVECTOR = new FieldOption(""TERMVECTOR"");
/*      */     
/*  105 */     public static final FieldOption TERMVECTOR_WITH_POSITION = new FieldOption(""TERMVECTOR_WITH_POSITION"");
/*      */     
/*  107 */     public static final FieldOption TERMVECTOR_WITH_OFFSET = new FieldOption(""TERMVECTOR_WITH_OFFSET"");
/*      */     
/*  109 */     public static final FieldOption TERMVECTOR_WITH_POSITION_OFFSET = new FieldOption(""TERMVECTOR_WITH_POSITION_OFFSET"");
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  119 */   synchronized int getRefCount() { return this.refCount; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void incRef() {
/*  137 */     assert this.refCount > 0;
/*  138 */     ensureOpen();
/*  139 */     this.refCount++;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void decRef() throws IOException {
/*  153 */     assert this.refCount > 0;
/*  154 */     ensureOpen();
/*  155 */     if (this.refCount == 1) {
/*  156 */       commit();
/*  157 */       doClose();
/*      */     } 
/*  159 */     this.refCount--;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected IndexReader(Directory directory) {
/*  183 */     this();
/*  184 */     this.directory = directory;
/*      */   }
/*      */ 
/*      */   
/*  188 */   protected IndexReader() { this.refCount = 1; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected final void ensureOpen() throws AlreadyClosedException {
/*  195 */     if (this.refCount <= 0) {
/*  196 */       throw new AlreadyClosedException(""this IndexReader is closed"");
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  206 */   public static IndexReader open(String path) throws CorruptIndexException, IOException { return open((Directory)FSDirectory.getDirectory(path), true, null, null, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  216 */   public static IndexReader open(File path) throws CorruptIndexException, IOException { return open((Directory)FSDirectory.getDirectory(path), true, null, null, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  227 */   public static IndexReader open(Directory directory) throws CorruptIndexException, IOException { return open(directory, false, null, null, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  237 */   public static IndexReader open(Directory directory, boolean readOnly) throws CorruptIndexException, IOException { return open(directory, false, null, null, readOnly); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  248 */   public static IndexReader open(IndexCommit commit) throws CorruptIndexException, IOException { return open(commit.getDirectory(), false, null, commit, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  263 */   public static IndexReader open(Directory directory, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException { return open(directory, false, deletionPolicy, null, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  279 */   public static IndexReader open(Directory directory, IndexDeletionPolicy deletionPolicy, boolean readOnly) throws CorruptIndexException, IOException { return open(directory, false, deletionPolicy, null, readOnly); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  296 */   public static IndexReader open(IndexCommit commit, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException { return open(commit.getDirectory(), false, deletionPolicy, commit, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  312 */   public static IndexReader open(IndexCommit commit, IndexDeletionPolicy deletionPolicy, boolean readOnly) throws CorruptIndexException, IOException { return open(commit.getDirectory(), false, deletionPolicy, commit, readOnly); }
/*      */ 
/*      */ 
/*      */   
/*  316 */   private static IndexReader open(Directory directory, boolean closeDirectory, IndexDeletionPolicy deletionPolicy, IndexCommit commit, boolean readOnly) throws CorruptIndexException, IOException { return DirectoryIndexReader.open(directory, closeDirectory, deletionPolicy, commit, readOnly); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  355 */   public synchronized IndexReader reopen() throws CorruptIndexException, IOException { throw new UnsupportedOperationException(""This reader does not support reopen().""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Directory directory() {
/*  366 */     ensureOpen();
/*  367 */     if (null != this.directory) {
/*  368 */       return this.directory;
/*      */     }
/*  370 */     throw new UnsupportedOperationException(""This reader does not support this method."");
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  382 */   public static long lastModified(String directory) throws CorruptIndexException, IOException { return lastModified(new File(directory)); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  393 */   public static long lastModified(File fileDirectory) throws CorruptIndexException, IOException { return ((Long)(new SegmentInfos.FindSegmentsFile(fileDirectory)
/*      */       {
/*  395 */         public Object doBody(String segmentFileName) { return new Long(FSDirectory.fileModified(this.fileDirectory, segmentFileName)); }
/*      */       }).run()).longValue(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  408 */   public static long lastModified(final Directory directory2) throws CorruptIndexException, IOException { return ((Long)(new SegmentInfos.FindSegmentsFile(directory2)
/*      */       {
/*  410 */         public Object doBody(String segmentFileName) throws IOException { return new Long(directory2.fileModified(segmentFileName)); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */         
/*      */         private final Directory val$directory2;
/*      */       }).run()).longValue(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  426 */   public static long getCurrentVersion(String directory) throws CorruptIndexException, IOException { return getCurrentVersion(new File(directory)); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static long getCurrentVersion(File directory) throws CorruptIndexException, IOException {
/*  440 */     FSDirectory fSDirectory = FSDirectory.getDirectory(directory);
/*  441 */     long version = getCurrentVersion((Directory)fSDirectory);
/*  442 */     fSDirectory.close();
/*  443 */     return version;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  457 */   public static long getCurrentVersion(Directory directory) throws CorruptIndexException, IOException { return SegmentInfos.readCurrentVersion(directory); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  465 */   public long getVersion() { throw new UnsupportedOperationException(""This reader does not support this method.""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  486 */   public void setTermInfosIndexDivisor(int indexDivisor) throws IllegalStateException { throw new UnsupportedOperationException(""This reader does not support this method.""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  494 */   public int getTermInfosIndexDivisor() { throw new UnsupportedOperationException(""This reader does not support this method.""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  516 */   public boolean isCurrent() throws CorruptIndexException, IOException { throw new UnsupportedOperationException(""This reader does not support this method.""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  526 */   public boolean isOptimized() { throw new UnsupportedOperationException(""This reader does not support this method.""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  591 */   public static boolean indexExists(String directory) { return indexExists(new File(directory)); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  602 */   public static boolean indexExists(File directory) { return (SegmentInfos.getCurrentSegmentGeneration(directory.list()) != -1L); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  613 */   public static boolean indexExists(Directory directory) throws IOException { return (SegmentInfos.getCurrentSegmentGeneration(directory) != -1L); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  627 */   public int numDeletedDocs() { return maxDoc() - numDocs(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Document document(int n) throws CorruptIndexException, IOException {
/*  636 */     ensureOpen();
/*  637 */     return document(n, null);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public boolean hasNorms(String field) throws IOException {
/*  675 */     ensureOpen();
/*  676 */     return (norms(field) != null);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void setNorm(int doc, String field, byte value) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/*  712 */     ensureOpen();
/*  713 */     acquireWriteLock();
/*  714 */     this.hasChanges = true;
/*  715 */     doSetNorm(doc, field, value);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setNorm(int doc, String field, float value) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/*  738 */     ensureOpen();
/*  739 */     setNorm(doc, field, Similarity.encodeNorm(value));
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public TermDocs termDocs(Term term) throws IOException {
/*  778 */     ensureOpen();
/*  779 */     TermDocs termDocs = termDocs();
/*  780 */     termDocs.seek(term);
/*  781 */     return termDocs;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public TermPositions termPositions(Term term) throws IOException {
/*  807 */     ensureOpen();
/*  808 */     TermPositions termPositions = termPositions();
/*  809 */     termPositions.seek(term);
/*  810 */     return termPositions;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void deleteDocument(int docNum) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/*  836 */     ensureOpen();
/*  837 */     acquireWriteLock();
/*  838 */     this.hasChanges = true;
/*  839 */     doDelete(docNum);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int deleteDocuments(Term term) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/*  867 */     ensureOpen();
/*  868 */     TermDocs docs = termDocs(term);
/*  869 */     if (docs == null) return 0; 
/*  870 */     int n = 0;
/*      */     try {
/*  872 */       while (docs.next()) {
/*  873 */         deleteDocument(docs.doc());
/*  874 */         n++;
/*      */       } 
/*      */     } finally {
/*  877 */       docs.close();
/*      */     } 
/*  879 */     return n;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void undeleteAll() throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/*  893 */     ensureOpen();
/*  894 */     acquireWriteLock();
/*  895 */     this.hasChanges = true;
/*  896 */     doUndeleteAll();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected synchronized void acquireWriteLock() throws IOException {}
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final synchronized void flush() throws IOException {
/*  913 */     ensureOpen();
/*  914 */     commit();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected final synchronized void commit() throws IOException {
/*  927 */     if (this.hasChanges) {
/*  928 */       doCommit();
/*      */     }
/*  930 */     this.hasChanges = false;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final synchronized void close() throws IOException {
/*  943 */     if (!this.closed) {
/*  944 */       decRef();
/*  945 */       this.closed = true;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  970 */   public static boolean isLocked(Directory directory) throws IOException { return directory.makeLock(""write.lock"").isLocked(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static boolean isLocked(String directory) throws IOException {
/*  982 */     FSDirectory fSDirectory = FSDirectory.getDirectory(directory);
/*  983 */     boolean result = isLocked((Directory)fSDirectory);
/*  984 */     fSDirectory.close();
/*  985 */     return result;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  997 */   public static void unlock(Directory directory) throws IOException { directory.makeLock(""write.lock"").release(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 1010 */   public IndexCommit getIndexCommit() throws IOException { throw new UnsupportedOperationException(""This reader does not support this method.""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static void main(String[] args) {
/* 1021 */     String filename = null;
/* 1022 */     boolean extract = false;
/*      */     
/* 1024 */     for (int i = 0; i < args.length; i++) {
/* 1025 */       if (args[i].equals(""-extract"")) {
/* 1026 */         extract = true;
/* 1027 */       } else if (filename == null) {
/* 1028 */         filename = args[i];
/*      */       } 
/*      */     } 
/*      */     
/* 1032 */     if (filename == null) {
/* 1033 */       System.out.println(""Usage: org.apache.lucene.index.IndexReader [-extract] <cfsfile>"");
/*      */       
/*      */       return;
/*      */     } 
/* 1037 */     Object object = null;
/* 1038 */     CompoundFileReader cfr = null;
/*      */     
/*      */     try {
/* 1041 */       File file = new File(filename);
/* 1042 */       String dirname = file.getAbsoluteFile().getParent();
/* 1043 */       filename = file.getName();
/* 1044 */       object = FSDirectory.getDirectory(dirname);
/* 1045 */       cfr = new CompoundFileReader((Directory)object, filename);
/*      */       
/* 1047 */       String[] files = cfr.list();
/* 1048 */       Arrays.sort((Object[])files);
/*      */       
/* 1050 */       for (int i = 0; i < files.length; i++) {
/* 1051 */         long len = cfr.fileLength(files[i]);
/*      */         
/* 1053 */         if (extract)
/* 1054 */         { System.out.println(""extract "" + files[i] + "" with "" + len + "" bytes to local directory..."");
/* 1055 */           IndexInput ii = cfr.openInput(files[i]);
/*      */           
/* 1057 */           FileOutputStream f = new FileOutputStream(files[i]);
/*      */ 
/*      */           
/* 1060 */           byte[] buffer = new byte[1024];
/* 1061 */           int chunk = buffer.length;
/* 1062 */           while (len > 0L) {
/* 1063 */             int bufLen = (int)Math.min(chunk, len);
/* 1064 */             ii.readBytes(buffer, 0, bufLen);
/* 1065 */             f.write(buffer, 0, bufLen);
/* 1066 */             len -= bufLen;
/*      */           } 
/*      */           
/* 1069 */           f.close();
/* 1070 */           ii.close(); }
/*      */         else
/*      */         
/* 1073 */         { System.out.println(files[i] + "": "" + len + "" bytes""); } 
/*      */       } 
/* 1075 */     } catch (IOException ioe) {
/* 1076 */       ioe.printStackTrace();
/*      */     } finally {
/*      */       
/*      */       try {
/* 1080 */         if (object != null)
/* 1081 */           object.close(); 
/* 1082 */         if (cfr != null) {
/* 1083 */           cfr.close();
/*      */         }
/* 1085 */       } catch (IOException ioe) {
/* 1086 */         ioe.printStackTrace();
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 1104 */   public static Collection listCommits(Directory dir) throws IOException { return DirectoryIndexReader.listCommits(dir); }
/*      */   
/*      */   public abstract TermFreqVector[] getTermFreqVectors(int paramInt) throws IOException;
/*      */   
/*      */   public abstract TermFreqVector getTermFreqVector(int paramInt, String paramString) throws IOException;
/*      */   
/*      */   public abstract void getTermFreqVector(int paramInt, String paramString, TermVectorMapper paramTermVectorMapper) throws IOException;
/*      */   
/*      */   public abstract void getTermFreqVector(int paramInt, TermVectorMapper paramTermVectorMapper) throws IOException;
/*      */   
/*      */   public abstract int numDocs();
/*      */   
/*      */   public abstract int maxDoc();
/*      */   
/*      */   public abstract Document document(int paramInt, FieldSelector paramFieldSelector) throws CorruptIndexException, IOException;
/*      */   
/*      */   public abstract boolean isDeleted(int paramInt);
/*      */   
/*      */   public abstract boolean hasDeletions();
/*      */   
/*      */   public abstract byte[] norms(String paramString) throws IOException;
/*      */   
/*      */   public abstract void norms(String paramString, byte[] paramArrayOfbyte, int paramInt) throws IOException;
/*      */   
/*      */   protected abstract void doSetNorm(int paramInt, String paramString, byte paramByte) throws CorruptIndexException, IOException;
/*      */   
/*      */   public abstract TermEnum terms() throws IOException;
/*      */   
/*      */   public abstract TermEnum terms(Term paramTerm) throws IOException;
/*      */   
/*      */   public abstract int docFreq(Term paramTerm) throws IOException;
/*      */   
/*      */   public abstract TermDocs termDocs() throws IOException;
/*      */   
/*      */   public abstract TermPositions termPositions() throws IOException;
/*      */   
/*      */   protected abstract void doDelete(int paramInt) throws CorruptIndexException, IOException;
/*      */   
/*      */   protected abstract void doUndeleteAll() throws CorruptIndexException, IOException;
/*      */   
/*      */   protected abstract void doCommit() throws IOException;
/*      */   
/*      */   protected abstract void doClose() throws IOException;
/*      */   
/*      */   public abstract Collection getFieldNames(FieldOption paramFieldOption);
/*      */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexWriter,"/*      */ package org.apache.lucene.index;
/*      */ 
/*      */ import java.io.File;
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ import java.util.ArrayList;
/*      */ import java.util.Collection;
/*      */ import java.util.HashMap;
/*      */ import java.util.HashSet;
/*      */ import java.util.Iterator;
/*      */ import java.util.LinkedList;
/*      */ import java.util.List;
/*      */ import java.util.Set;
/*      */ import org.apache.lucene.analysis.Analyzer;
/*      */ import org.apache.lucene.document.Document;
/*      */ import org.apache.lucene.search.Query;
/*      */ import org.apache.lucene.search.Similarity;
/*      */ import org.apache.lucene.store.AlreadyClosedException;
/*      */ import org.apache.lucene.store.Directory;
/*      */ import org.apache.lucene.store.FSDirectory;
/*      */ import org.apache.lucene.store.Lock;
/*      */ import org.apache.lucene.store.LockObtainFailedException;
/*      */ import org.apache.lucene.util.BitVector;
/*      */ import org.apache.lucene.util.Constants;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class IndexWriter
/*      */ {
/*  213 */   public static long WRITE_LOCK_TIMEOUT = 1000L;
/*      */   
/*  215 */   private long writeLockTimeout = WRITE_LOCK_TIMEOUT;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final String WRITE_LOCK_NAME = ""write.lock"";
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MERGE_FACTOR = 10;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DISABLE_AUTO_FLUSH = -1;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_BUFFERED_DOCS = -1;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final double DEFAULT_RAM_BUFFER_SIZE_MB = 16.0D;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_BUFFERED_DELETE_TERMS = -1;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_MERGE_DOCS = 2147483647;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_FIELD_LENGTH = 10000;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_TERM_INDEX_INTERVAL = 128;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int MAX_TERM_LENGTH = 16383;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final double DEFAULT_MAX_SYNC_PAUSE_SECONDS;
/*      */ 
/*      */ 
/*      */   
/*      */   private static final int MERGE_READ_BUFFER_SIZE = 4096;
/*      */ 
/*      */ 
/*      */   
/*      */   private static Object MESSAGE_ID_LOCK;
/*      */ 
/*      */ 
/*      */   
/*      */   private static int MESSAGE_ID;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   static  {
/*  282 */     if (Constants.WINDOWS) {
/*  283 */       DEFAULT_MAX_SYNC_PAUSE_SECONDS = 10.0D;
/*      */     } else {
/*  285 */       DEFAULT_MAX_SYNC_PAUSE_SECONDS = 0.0D;
/*      */     } 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  297 */     MESSAGE_ID_LOCK = new Object();
/*  298 */     MESSAGE_ID = 0;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 2103 */     defaultInfoStream = null;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private int messageID = -1;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private volatile boolean hitOOM;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private Directory directory;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private Analyzer analyzer;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private Similarity similarity = Similarity.getDefault();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private volatile long changeCount;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private long lastCommitChangeCount;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private SegmentInfos rollbackSegmentInfos;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private HashMap rollbackSegments;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   volatile SegmentInfos pendingCommit;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   volatile long pendingCommitChangeCount;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private SegmentInfos localRollbackSegmentInfos;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean localAutoCommit;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private int localFlushedDocCount;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean autoCommit = true;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private SegmentInfos segmentInfos = new SegmentInfos();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private DocumentsWriter docWriter;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private IndexFileDeleter deleter;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private Set segmentsToOptimize = new HashSet();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private Lock writeLock;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private int termIndexInterval = 128;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean closeDir;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean closed;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean closing;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private HashSet mergingSegments = new HashSet();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private MergePolicy mergePolicy = new LogByteSizeMergePolicy();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private MergeScheduler mergeScheduler = new ConcurrentMergeScheduler();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private LinkedList pendingMerges = new LinkedList();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private Set runningMerges = new HashSet();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private List mergeExceptions = new ArrayList();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private long mergeGen;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean stopMerges;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private int flushCount;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private int flushDeletesCount;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private double maxSyncPauseSeconds = DEFAULT_MAX_SYNC_PAUSE_SECONDS;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private int readCount;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private Thread writeThread;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private int maxFieldLength;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private PrintStream infoStream;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private static PrintStream defaultInfoStream;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean committing;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private HashSet synced;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private HashSet syncing;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   static final boolean $assertionsDisabled;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   synchronized void acquireWrite() {
/*      */     while (this.writeThread != null || this.readCount > 0) {
/*      */       doWait();
/*      */     }
/*      */     ensureOpen();
/*      */     this.writeThread = Thread.currentThread();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   synchronized void releaseWrite() {
/*      */     assert Thread.currentThread() == this.writeThread;
/*      */     this.writeThread = null;
/*      */     notifyAll();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   synchronized void acquireRead() {
/*      */     Thread current = Thread.currentThread();
/*      */     while (this.writeThread != null && this.writeThread != current) {
/*      */       doWait();
/*      */     }
/*      */     this.readCount++;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   synchronized void releaseRead() {
/*      */     this.readCount--;
/*      */     assert this.readCount >= 0;
/*      */     if (0 == this.readCount) {
/*      */       notifyAll();
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected final synchronized void ensureOpen(boolean includePendingClose) throws AlreadyClosedException {
/*      */     if (this.closed || (includePendingClose && this.closing)) {
/*      */       throw new AlreadyClosedException(""this IndexWriter is closed"");
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected final synchronized void ensureOpen() throws AlreadyClosedException { ensureOpen(true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void message(String message) {
/*      */     if (this.infoStream != null) {
/*      */       this.infoStream.println(""IW "" + this.messageID + "" ["" + Thread.currentThread().getName() + ""]: "" + message);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private synchronized void setMessageID(PrintStream infoStream) {
/*      */     if (infoStream != null && this.messageID == -1) {
/*      */       synchronized (MESSAGE_ID_LOCK) {
/*      */         this.messageID = MESSAGE_ID++;
/*      */       } 
/*      */     }
/*      */     this.infoStream = infoStream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private LogMergePolicy getLogMergePolicy() {
/*      */     if (this.mergePolicy instanceof LogMergePolicy) {
/*      */       return (LogMergePolicy)this.mergePolicy;
/*      */     }
/*      */     throw new IllegalArgumentException(""this method can only be called when the merge policy is the default LogMergePolicy"");
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public boolean getUseCompoundFile() { return getLogMergePolicy().getUseCompoundFile(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setUseCompoundFile(boolean value) {
/*      */     getLogMergePolicy().setUseCompoundFile(value);
/*      */     getLogMergePolicy().setUseCompoundDocStore(value);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setSimilarity(Similarity similarity) {
/*      */     ensureOpen();
/*      */     this.similarity = similarity;
/*      */     this.docWriter.setSimilarity(similarity);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Similarity getSimilarity() {
/*      */     ensureOpen();
/*      */     return this.similarity;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setTermIndexInterval(int interval) {
/*      */     ensureOpen();
/*      */     this.termIndexInterval = interval;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getTermIndexInterval() {
/*      */     ensureOpen(false);
/*      */     return this.termIndexInterval;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void init(Directory d, Analyzer a, boolean closeDir, IndexDeletionPolicy deletionPolicy, boolean autoCommit, int maxFieldLength) throws CorruptIndexException, LockObtainFailedException, IOException {
/*      */     if (IndexReader.indexExists(d)) {
/*      */       init(d, a, false, closeDir, deletionPolicy, autoCommit, maxFieldLength);
/*      */     } else {
/*      */       init(d, a, true, closeDir, deletionPolicy, autoCommit, maxFieldLength);
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void init(Directory d, Analyzer a, boolean create, boolean closeDir, IndexDeletionPolicy deletionPolicy, boolean autoCommit, int maxFieldLength) throws CorruptIndexException, LockObtainFailedException, IOException {
/*      */     this.closeDir = closeDir;
/*      */     this.directory = d;
/*      */     this.analyzer = a;
/*      */     setMessageID(defaultInfoStream);
/*      */     this.maxFieldLength = maxFieldLength;
/*      */     if (create) {
/*      */       this.directory.clearLock(""write.lock"");
/*      */     }
/*      */     Lock writeLock = this.directory.makeLock(""write.lock"");
/*      */     if (!writeLock.obtain(this.writeLockTimeout)) {
/*      */       throw new LockObtainFailedException(""Index locked for write: "" + writeLock);
/*      */     }
/*      */     this.writeLock = writeLock;
/*      */     try {
/*      */       if (create) {
/*      */         try {
/*      */           this.segmentInfos.read(this.directory);
/*      */           this.segmentInfos.clear();
/*      */         } catch (IOException e) {}
/*      */         this.segmentInfos.commit(this.directory);
/*      */       } else {
/*      */         this.segmentInfos.read(this.directory);
/*      */         for (int i = 0; i < this.segmentInfos.size(); i++) {
/*      */           SegmentInfo info = this.segmentInfos.info(i);
/*      */           List files = info.files();
/*      */           for (int j = 0; j < files.size(); j++) {
/*      */             this.synced.add(files.get(j));
/*      */           }
/*      */         } 
/*      */       } 
/*      */       this.autoCommit = autoCommit;
/*      */       setRollbackSegmentInfos(this.segmentInfos);
/*      */       this.docWriter = new DocumentsWriter(this.directory, this);
/*      */       this.docWriter.setInfoStream(this.infoStream);
/*      */       this.docWriter.setMaxFieldLength(maxFieldLength);
/*      */       this.deleter = new IndexFileDeleter(this.directory, (deletionPolicy == null) ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy, this.segmentInfos, this.infoStream, this.docWriter);
/*      */       pushMaxBufferedDocs();
/*      */       if (this.infoStream != null) {
/*      */         message(""init: create="" + create);
/*      */         messageState();
/*      */       } 
/*      */     } catch (IOException e) {
/*      */       this.writeLock.release();
/*      */       this.writeLock = null;
/*      */       throw e;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private synchronized void setRollbackSegmentInfos(SegmentInfos infos) {
/*      */     this.rollbackSegmentInfos = (SegmentInfos)infos.clone();
/*      */     assert !hasExternalSegments(this.rollbackSegmentInfos);
/*      */     this.rollbackSegments = new HashMap();
/*      */     int size = this.rollbackSegmentInfos.size();
/*      */     for (int i = 0; i < size; i++) {
/*      */       this.rollbackSegments.put(this.rollbackSegmentInfos.info(i), new Integer(i));
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMergePolicy(MergePolicy mp) {
/*      */     ensureOpen();
/*      */     if (mp == null) {
/*      */       throw new NullPointerException(""MergePolicy must be non-null"");
/*      */     }
/*      */     if (this.mergePolicy != mp) {
/*      */       this.mergePolicy.close();
/*      */     }
/*      */     this.mergePolicy = mp;
/*      */     pushMaxBufferedDocs();
/*      */     if (this.infoStream != null) {
/*      */       message(""setMergePolicy "" + mp);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public MergePolicy getMergePolicy() {
/*      */     ensureOpen();
/*      */     return this.mergePolicy;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void setMergeScheduler(MergeScheduler mergeScheduler) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     if (mergeScheduler == null) {
/*      */       throw new NullPointerException(""MergeScheduler must be non-null"");
/*      */     }
/*      */     if (this.mergeScheduler != mergeScheduler) {
/*      */       finishMerges(true);
/*      */       this.mergeScheduler.close();
/*      */     } 
/*      */     this.mergeScheduler = mergeScheduler;
/*      */     if (this.infoStream != null) {
/*      */       message(""setMergeScheduler "" + mergeScheduler);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public MergeScheduler getMergeScheduler() {
/*      */     ensureOpen();
/*      */     return this.mergeScheduler;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxMergeDocs(int maxMergeDocs) { getLogMergePolicy().setMaxMergeDocs(maxMergeDocs); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxMergeDocs() { return getLogMergePolicy().getMaxMergeDocs(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxFieldLength(int maxFieldLength) {
/*      */     ensureOpen();
/*      */     this.maxFieldLength = maxFieldLength;
/*      */     this.docWriter.setMaxFieldLength(maxFieldLength);
/*      */     if (this.infoStream != null) {
/*      */       message(""setMaxFieldLength "" + maxFieldLength);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxFieldLength() {
/*      */     ensureOpen();
/*      */     return this.maxFieldLength;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxBufferedDocs(int maxBufferedDocs) {
/*      */     ensureOpen();
/*      */     if (maxBufferedDocs != -1 && maxBufferedDocs < 2) {
/*      */       throw new IllegalArgumentException(""maxBufferedDocs must at least be 2 when enabled"");
/*      */     }
/*      */     if (maxBufferedDocs == -1 && getRAMBufferSizeMB() == -1.0D) {
/*      */       throw new IllegalArgumentException(""at least one of ramBufferSize and maxBufferedDocs must be enabled"");
/*      */     }
/*      */     this.docWriter.setMaxBufferedDocs(maxBufferedDocs);
/*      */     pushMaxBufferedDocs();
/*      */     if (this.infoStream != null) {
/*      */       message(""setMaxBufferedDocs "" + maxBufferedDocs);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void pushMaxBufferedDocs() {
/*      */     if (this.docWriter.getMaxBufferedDocs() != -1) {
/*      */       MergePolicy mp = this.mergePolicy;
/*      */       if (mp instanceof LogDocMergePolicy) {
/*      */         LogDocMergePolicy lmp = (LogDocMergePolicy)mp;
/*      */         int maxBufferedDocs = this.docWriter.getMaxBufferedDocs();
/*      */         if (lmp.getMinMergeDocs() != maxBufferedDocs) {
/*      */           if (this.infoStream != null) {
/*      */             message(""now push maxBufferedDocs "" + maxBufferedDocs + "" to LogDocMergePolicy"");
/*      */           }
/*      */           lmp.setMinMergeDocs(maxBufferedDocs);
/*      */         } 
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxBufferedDocs() {
/*      */     ensureOpen();
/*      */     return this.docWriter.getMaxBufferedDocs();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setRAMBufferSizeMB(double mb) {
/*      */     if (mb != -1.0D && mb <= 0.0D) {
/*      */       throw new IllegalArgumentException(""ramBufferSize should be > 0.0 MB when enabled"");
/*      */     }
/*      */     if (mb == -1.0D && getMaxBufferedDocs() == -1) {
/*      */       throw new IllegalArgumentException(""at least one of ramBufferSize and maxBufferedDocs must be enabled"");
/*      */     }
/*      */     this.docWriter.setRAMBufferSizeMB(mb);
/*      */     if (this.infoStream != null) {
/*      */       message(""setRAMBufferSizeMB "" + mb);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public double getRAMBufferSizeMB() { return this.docWriter.getRAMBufferSizeMB(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxBufferedDeleteTerms(int maxBufferedDeleteTerms) {
/*      */     ensureOpen();
/*      */     if (maxBufferedDeleteTerms != -1 && maxBufferedDeleteTerms < 1) {
/*      */       throw new IllegalArgumentException(""maxBufferedDeleteTerms must at least be 1 when enabled"");
/*      */     }
/*      */     this.docWriter.setMaxBufferedDeleteTerms(maxBufferedDeleteTerms);
/*      */     if (this.infoStream != null) {
/*      */       message(""setMaxBufferedDeleteTerms "" + maxBufferedDeleteTerms);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxBufferedDeleteTerms() {
/*      */     ensureOpen();
/*      */     return this.docWriter.getMaxBufferedDeleteTerms();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMergeFactor(int mergeFactor) { getLogMergePolicy().setMergeFactor(mergeFactor); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMergeFactor() { return getLogMergePolicy().getMergeFactor(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public double getMaxSyncPauseSeconds() { return this.maxSyncPauseSeconds; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxSyncPauseSeconds(double seconds) { this.maxSyncPauseSeconds = seconds; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static void setDefaultInfoStream(PrintStream infoStream) { defaultInfoStream = infoStream; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static PrintStream getDefaultInfoStream() { return defaultInfoStream; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setInfoStream(PrintStream infoStream) {
/*      */     ensureOpen();
/*      */     setMessageID(infoStream);
/*      */     this.docWriter.setInfoStream(infoStream);
/*      */     this.deleter.setInfoStream(infoStream);
/*      */     if (infoStream != null) {
/*      */       messageState();
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void messageState() { message(""setInfoStream: dir="" + this.directory + "" autoCommit="" + this.autoCommit + "" mergePolicy="" + this.mergePolicy + "" mergeScheduler="" + this.mergeScheduler + "" ramBufferSizeMB="" + this.docWriter.getRAMBufferSizeMB() + "" maxBufferedDocs="" + this.docWriter.getMaxBufferedDocs() + "" maxBuffereDeleteTerms="" + this.docWriter.getMaxBufferedDeleteTerms() + "" maxFieldLength="" + this.maxFieldLength + "" index="" + segString()); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public PrintStream getInfoStream() {
/*      */     ensureOpen();
/*      */     return this.infoStream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setWriteLockTimeout(long writeLockTimeout) {
/*      */     ensureOpen();
/*      */     this.writeLockTimeout = writeLockTimeout;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public long getWriteLockTimeout() {
/*      */     ensureOpen();
/*      */     return this.writeLockTimeout;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static void setDefaultWriteLockTimeout(long writeLockTimeout) { WRITE_LOCK_TIMEOUT = writeLockTimeout; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static long getDefaultWriteLockTimeout() { return WRITE_LOCK_TIMEOUT; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void close() throws CorruptIndexException, IOException { close(true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void close(boolean waitForMerges) throws CorruptIndexException, IOException {
/*      */     if (this.hitOOM) {
/*      */       rollback();
/*      */       return;
/*      */     } 
/*      */     if (shouldClose()) {
/*      */       closeInternal(waitForMerges);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private synchronized boolean shouldClose() {
/*      */     while (!this.closed) {
/*      */       if (!this.closing) {
/*      */         this.closing = true;
/*      */         return true;
/*      */       } 
/*      */       doWait();
/*      */     } 
/*      */     return false;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void closeInternal(boolean waitForMerges) throws CorruptIndexException, IOException {
/*      */     this.docWriter.pauseAllThreads();
/*      */     try {
/*      */       if (this.infoStream != null) {
/*      */         message(""now flush at close"");
/*      */       }
/*      */       this.docWriter.close();
/*      */       flush(waitForMerges, true, true);
/*      */       if (waitForMerges) {
/*      */         this.mergeScheduler.merge(this);
/*      */       }
/*      */       this.mergePolicy.close();
/*      */       finishMerges(waitForMerges);
/*      */       this.mergeScheduler.close();
/*      */       if (this.infoStream != null) {
/*      */         message(""now call final commit()"");
/*      */       }
/*      */       commit(0L);
/*      */       if (this.infoStream != null) {
/*      */         message(""at close: "" + segString());
/*      */       }
/*      */       synchronized (this) {
/*      */         this.docWriter = null;
/*      */         this.deleter.close();
/*      */       } 
/*      */       if (this.closeDir) {
/*      */         this.directory.close();
/*      */       }
/*      */       if (this.writeLock != null) {
/*      */         this.writeLock.release();
/*      */         this.writeLock = null;
/*      */       } 
/*      */       synchronized (this) {
/*      */         this.closed = true;
/*      */       } 
/*      */     } catch (OutOfMemoryError oom) {
/*      */       this.hitOOM = true;
/*      */       throw oom;
/*      */     } finally {
/*      */       synchronized (this) {
/*      */         this.closing = false;
/*      */         notifyAll();
/*      */         if (!this.closed) {
/*      */           if (this.docWriter != null) {
/*      */             this.docWriter.resumeAllThreads();
/*      */           }
/*      */           if (this.infoStream != null) {
/*      */             message(""hit exception while closing"");
/*      */           }
/*      */         } 
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private synchronized boolean flushDocStores() throws IOException {
/*      */     String docStoreSegment;
/*      */     boolean useCompoundDocStore = false;
/*      */     boolean success = false;
/*      */     try {
/*      */       docStoreSegment = this.docWriter.closeDocStore();
/*      */       success = true;
/*      */     } finally {
/*      */       if (!success && this.infoStream != null) {
/*      */         message(""hit exception closing doc store segment"");
/*      */       }
/*      */     } 
/*      */     useCompoundDocStore = this.mergePolicy.useCompoundDocStore(this.segmentInfos);
/*      */     if (useCompoundDocStore && docStoreSegment != null && this.docWriter.closedFiles().size() != 0) {
/*      */       success = false;
/*      */       int numSegments = this.segmentInfos.size();
/*      */       String compoundFileName = docStoreSegment + ""."" + ""cfx"";
/*      */       try {
/*      */         CompoundFileWriter cfsWriter = new CompoundFileWriter(this.directory, compoundFileName);
/*      */         Iterator it = this.docWriter.closedFiles().iterator();
/*      */         while (it.hasNext()) {
/*      */           cfsWriter.addFile(it.next());
/*      */         }
/*      */         cfsWriter.close();
/*      */         success = true;
/*      */       } finally {
/*      */         if (!success) {
/*      */           if (this.infoStream != null) {
/*      */             message(""hit exception building compound file doc store for segment "" + docStoreSegment);
/*      */           }
/*      */           this.deleter.deleteFile(compoundFileName);
/*      */         } 
/*      */       } 
/*      */       for (int i = 0; i < numSegments; i++) {
/*      */         SegmentInfo si = this.segmentInfos.info(i);
/*      */         if (si.getDocStoreOffset() != -1 && si.getDocStoreSegment().equals(docStoreSegment)) {
/*      */           si.setDocStoreIsCompoundFile(true);
/*      */         }
/*      */       } 
/*      */       checkpoint();
/*      */       this.deleter.deleteNewFiles(this.docWriter.closedFiles());
/*      */     } 
/*      */     return useCompoundDocStore;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected void finalize() throws Throwable {
/*      */     try {
/*      */       if (this.writeLock != null) {
/*      */         this.writeLock.release();
/*      */         this.writeLock = null;
/*      */       } 
/*      */     } finally {
/*      */       super.finalize();
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Directory getDirectory() {
/*      */     ensureOpen(false);
/*      */     return this.directory;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Analyzer getAnalyzer() {
/*      */     ensureOpen();
/*      */     return this.analyzer;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized int docCount() {
/*      */     ensureOpen();
/*      */     return maxDoc();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized int maxDoc() {
/*      */     int count;
/*      */     if (this.docWriter != null) {
/*      */       count = this.docWriter.getNumDocsInRAM();
/*      */     } else {
/*      */       count = 0;
/*      */     } 
/*      */     for (int i = 0; i < this.segmentInfos.size(); i++) {
/*      */       count += (this.segmentInfos.info(i)).docCount;
/*      */     }
/*      */     return count;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized int numDocs() throws IOException {
/*      */     int count;
/*      */     if (this.docWriter != null) {
/*      */       count = this.docWriter.getNumDocsInRAM();
/*      */     } else {
/*      */       count = 0;
/*      */     } 
/*      */     for (int i = 0; i < this.segmentInfos.size(); i++) {
/*      */       SegmentInfo info = this.segmentInfos.info(i);
/*      */       count += info.docCount - info.getDelCount();
/*      */     } 
/*      */     return count;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized boolean hasDeletions() throws IOException {
/*      */     ensureOpen();
/*      */     if (this.docWriter.hasDeletes()) {
/*      */       return true;
/*      */     }
/*      */     for (int i = 0; i < this.segmentInfos.size(); i++) {
/*      */       if (this.segmentInfos.info(i).hasDeletions()) {
/*      */         return true;
/*      */       }
/*      */     } 
/*      */     return false;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void addDocument(Document doc) throws CorruptIndexException, IOException { addDocument(doc, this.analyzer); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void addDocument(Document doc, Analyzer analyzer) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     boolean doFlush = false;
/*      */     boolean success = false;
/*      */     try {
/*      */       try {
/*      */         doFlush = this.docWriter.addDocument(doc, analyzer);
/*      */         success = true;
/*      */       } finally {
/*      */         if (!success) {
/*      */           if (this.infoStream != null) {
/*      */             message(""hit exception adding document"");
/*      */           }
/*      */           synchronized (this) {
/*      */             if (this.docWriter != null) {
/*      */               Collection files = this.docWriter.abortedFiles();
/*      */               if (files != null) {
/*      */                 this.deleter.deleteNewFiles(files);
/*      */               }
/*      */             } 
/*      */           } 
/*      */         } 
/*      */       } 
/*      */       if (doFlush) {
/*      */         flush(true, false, false);
/*      */       }
/*      */     } catch (OutOfMemoryError oom) {
/*      */       this.hitOOM = true;
/*      */       throw oom;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void deleteDocuments(Term term) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     try {
/*      */       boolean doFlush = this.docWriter.bufferDeleteTerm(term);
/*      */       if (doFlush) {
/*      */         flush(true, false, false);
/*      */       }
/*      */     } catch (OutOfMemoryError oom) {
/*      */       this.hitOOM = true;
/*      */       throw oom;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void deleteDocuments(Term[] terms) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     try {
/*      */       boolean doFlush = this.docWriter.bufferDeleteTerms(terms);
/*      */       if (doFlush) {
/*      */         flush(true, false, false);
/*      */       }
/*      */     } catch (OutOfMemoryError oom) {
/*      */       this.hitOOM = true;
/*      */       throw oom;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void deleteDocuments(Query query) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     boolean doFlush = this.docWriter.bufferDeleteQuery(query);
/*      */     if (doFlush) {
/*      */       flush(true, false, false);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void deleteDocuments(Query[] queries) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     boolean doFlush = this.docWriter.bufferDeleteQueries(queries);
/*      */     if (doFlush) {
/*      */       flush(true, false, false);
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void updateDocument(Term term, Document doc) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     updateDocument(term, doc, getAnalyzer());
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void updateDocument(Term term, Document doc, Analyzer analyzer) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     try {
/*      */       boolean doFlush = false;
/*      */       boolean success = false;
/*      */       try {
/*      */         doFlush = this.docWriter.updateDocument(term, doc, analyzer);
/*      */         success = true;
/*      */       } finally {
/*      */         if (!success) {
/*      */           if (this.infoStream != null) {
/*      */             message(""hit exception updating document"");
/*      */           }
/*      */           synchronized (this) {
/*      */             Collection files = this.docWriter.abortedFiles();
/*      */             if (files != null) {
/*      */               this.deleter.deleteNewFiles(files);
/*      */             }
/*      */           } 
/*      */         } 
/*      */       } 
/*      */       if (doFlush) {
/*      */         flush(true, false, false);
/*      */       }
/*      */     } catch (OutOfMemoryError oom) {
/*      */       this.hitOOM = true;
/*      */       throw oom;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   final synchronized int getSegmentCount() { return this.segmentInfos.size(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   final synchronized int getNumBufferedDocuments() { return this.docWriter.getNumDocsInRAM(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   final synchronized int getDocCount(int i) {
/*      */     if (i >= 0 && i < this.segmentInfos.size()) {
/*      */       return (this.segmentInfos.info(i)).docCount;
/*      */     }
/*      */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   final synchronized int getFlushCount() { return this.flushCount; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   final synchronized int getFlushDeletesCount() { return this.flushDeletesCount; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   final String newSegmentName() {
/*      */     synchronized (this.segmentInfos) {
/*      */       this.changeCount++;
/*      */       return ""_"" + Integer.toString(this.segmentInfos.counter++, 36);
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public IndexWriter(String path, Analyzer a, boolean create, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException
/*      */   {
/*      */     this.infoStream = null;
/* 4401 */     this.synced = new HashSet();
/*      */ 
/*      */     
/* 4404 */     this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, create, true, null, false, mfl.getLimit()); } public IndexWriter(String path, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, create, true, null, true, 10000); } public IndexWriter(File path, Analyzer a, boolean create, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, create, true, null, false, mfl.getLimit()); } public IndexWriter(File path, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, create, true, null, true, 10000); } public IndexWriter(Directory d, Analyzer a, boolean create, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, create, false, null, false, mfl.getLimit()); } public IndexWriter(Directory d, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, create, false, null, true, 10000); } public IndexWriter(String path, Analyzer a, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, true, null, false, mfl.getLimit()); } public IndexWriter(String path, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, true, null, true, 10000); } public IndexWriter(File path, Analyzer a, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, true, null, false, mfl.getLimit()); } public IndexWriter(File path, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init((Directory)FSDirectory.getDirectory(path), a, true, null, true, 10000); } public IndexWriter(Directory d, Analyzer a, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, false, null, false, mfl.getLimit()); } public IndexWriter(Directory d, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, false, null, true, 10000); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, false, null, autoCommit, 10000); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, create, false, null, autoCommit, 10000); } public IndexWriter(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, false, deletionPolicy, false, mfl.getLimit()); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, false, deletionPolicy, autoCommit, 10000); } public IndexWriter(Directory d, Analyzer a, boolean create, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, create, false, deletionPolicy, false, mfl.getLimit()); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a, boolean create, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, LockObtainFailedException, IOException { this.infoStream = null; this.synced = new HashSet(); this.syncing = new HashSet(); init(d, a, create, false, deletionPolicy, autoCommit, 10000); }
/*      */   public void optimize() throws CorruptIndexException, IOException { optimize(true); }
/*      */   public void optimize(int maxNumSegments) throws CorruptIndexException, IOException { optimize(maxNumSegments, true); }
/* 4407 */   public void optimize(boolean doWait) throws CorruptIndexException, IOException { optimize(1, doWait); } public void optimize(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException { ensureOpen(); if (maxNumSegments < 1) throw new IllegalArgumentException(""maxNumSegments must be >= 1; got "" + maxNumSegments);  if (this.infoStream != null) message(""optimize: index now "" + segString());  flush(true, false, true); synchronized (this) { resetMergeExceptions(); this.segmentsToOptimize = new HashSet(); int numSegments = this.segmentInfos.size(); for (int i = 0; i < numSegments; i++) this.segmentsToOptimize.add(this.segmentInfos.info(i));  Iterator it = this.pendingMerges.iterator(); while (it.hasNext()) { MergePolicy.OneMerge merge = it.next(); merge.optimize = true; merge.maxNumSegmentsOptimize = maxNumSegments; }  it = this.runningMerges.iterator(); while (it.hasNext()) { MergePolicy.OneMerge merge = it.next(); merge.optimize = true; merge.maxNumSegmentsOptimize = maxNumSegments; }  }  maybeMerge(maxNumSegments, true); if (doWait) { synchronized (this) { while (true) { if (this.mergeExceptions.size() > 0) { int size = this.mergeExceptions.size(); for (int i = 0; i < size; i++) { MergePolicy.OneMerge merge = this.mergeExceptions.get(0); if (merge.optimize) { IOException err = new IOException(""background merge hit exception: "" + merge.segString(this.directory)); Throwable t = merge.getException(); if (t != null) err.initCause(t);  throw err; }  }  }  if (optimizeMergesPending()) { doWait(); continue; }  break; }  }  ensureOpen(); }  } private synchronized boolean optimizeMergesPending() { Iterator it = this.pendingMerges.iterator(); while (it.hasNext()) { if (((MergePolicy.OneMerge)it.next()).optimize) return true;  }  it = this.runningMerges.iterator(); while (it.hasNext()) { if (((MergePolicy.OneMerge)it.next()).optimize) return true;  }  return false; } public void expungeDeletes(boolean doWait) throws CorruptIndexException, IOException { MergePolicy.MergeSpecification spec; ensureOpen(); if (this.infoStream != null) message(""expungeDeletes: index now "" + segString());  synchronized (this) { spec = this.mergePolicy.findMergesToExpungeDeletes(this.segmentInfos, this); if (spec != null) { int numMerges = spec.merges.size(); for (int i = 0; i < numMerges; i++) registerMerge(spec.merges.get(i));  }  }  this.mergeScheduler.merge(this); if (spec != null && doWait) { int numMerges = spec.merges.size(); synchronized (this) { boolean running = true; while (running) { running = false; for (int i = 0; i < numMerges; i++) { MergePolicy.OneMerge merge = spec.merges.get(i); if (this.pendingMerges.contains(merge) || this.runningMerges.contains(merge)) running = true;  Throwable t = merge.getException(); if (t != null) { IOException ioe = new IOException(""background merge hit exception: "" + merge.segString(this.directory)); ioe.initCause(t); throw ioe; }  }  if (running) doWait();  }  }  }  } public void expungeDeletes() throws CorruptIndexException, IOException { expungeDeletes(true); } public final void maybeMerge() throws CorruptIndexException, IOException { maybeMerge(false); } private final void maybeMerge(boolean optimize) throws CorruptIndexException, IOException { maybeMerge(1, optimize); } private final void maybeMerge(int maxNumSegmentsOptimize, boolean optimize) throws CorruptIndexException, IOException { updatePendingMerges(maxNumSegmentsOptimize, optimize); this.mergeScheduler.merge(this); } private synchronized void updatePendingMerges(int maxNumSegmentsOptimize, boolean optimize) throws CorruptIndexException, IOException { MergePolicy.MergeSpecification spec; assert !optimize || maxNumSegmentsOptimize > 0; if (this.stopMerges) return;  if (optimize) { spec = this.mergePolicy.findMergesForOptimize(this.segmentInfos, this, maxNumSegmentsOptimize, this.segmentsToOptimize); if (spec != null) { int numMerges = spec.merges.size(); for (int i = 0; i < numMerges; i++) { MergePolicy.OneMerge merge = spec.merges.get(i); merge.optimize = true; merge.maxNumSegmentsOptimize = maxNumSegmentsOptimize; }  }  } else { spec = this.mergePolicy.findMerges(this.segmentInfos, this); }  if (spec != null) { int numMerges = spec.merges.size(); for (int i = 0; i < numMerges; i++) registerMerge(spec.merges.get(i));  }  } synchronized MergePolicy.OneMerge getNextMerge() { if (this.pendingMerges.size() == 0) return null;  MergePolicy.OneMerge merge = this.pendingMerges.removeFirst(); this.runningMerges.add(merge); return merge; } private synchronized MergePolicy.OneMerge getNextExternalMerge() { if (this.pendingMerges.size() == 0) return null;  Iterator it = this.pendingMerges.iterator(); while (it.hasNext()) { MergePolicy.OneMerge merge = it.next(); if (merge.isExternal) { it.remove(); this.runningMerges.add(merge); return merge; }  }  return null; } private synchronized void startTransaction(boolean haveWriteLock) throws IOException { boolean success = false; try { if (this.infoStream != null) message(""now start transaction"");  assert this.docWriter.getNumBufferedDeleteTerms() == 0 : ""calling startTransaction with buffered delete terms not supported: numBufferedDeleteTerms="" + this.docWriter.getNumBufferedDeleteTerms(); assert this.docWriter.getNumDocsInRAM() == 0 : ""calling startTransaction with buffered documents not supported: numDocsInRAM="" + this.docWriter.getNumDocsInRAM(); ensureOpen(); synchronized (this) { while (this.stopMerges) doWait();  }  success = true; } finally { if (!success && haveWriteLock) releaseWrite();  }  if (!haveWriteLock) acquireWrite();  success = false; try { this.localRollbackSegmentInfos = (SegmentInfos)this.segmentInfos.clone(); assert !hasExternalSegments(this.segmentInfos); this.localAutoCommit = this.autoCommit; this.localFlushedDocCount = this.docWriter.getFlushedDocCount(); if (this.localAutoCommit) { if (this.infoStream != null) message(""flush at startTransaction"");  flush(true, false, false); this.autoCommit = false; } else { this.deleter.incRef(this.segmentInfos, false); }  success = true; } finally { if (!success) finishAddIndexes();  }  } private synchronized void rollbackTransaction() throws IOException { if (this.infoStream != null) message(""now rollback transaction"");  this.autoCommit = this.localAutoCommit; this.docWriter.setFlushedDocCount(this.localFlushedDocCount); finishMerges(false); this.segmentInfos.clear(); this.segmentInfos.addAll(this.localRollbackSegmentInfos); this.localRollbackSegmentInfos = null; finishAddIndexes(); this.deleter.checkpoint(this.segmentInfos, false); if (!this.autoCommit) this.deleter.decRef(this.segmentInfos);  this.deleter.refresh(); notifyAll(); assert !hasExternalSegments(); } private synchronized void commitTransaction() throws IOException { if (this.infoStream != null) message(""now commit transaction"");  this.autoCommit = this.localAutoCommit; checkpoint(); if (this.autoCommit) { boolean success = false; try { commit(0L); success = true; } finally { if (!success) { if (this.infoStream != null) message(""hit exception committing transaction"");  rollbackTransaction(); }  }  } else { this.deleter.decRef(this.localRollbackSegmentInfos); }  this.localRollbackSegmentInfos = null; assert !hasExternalSegments(); finishAddIndexes(); } public void abort() throws IOException { rollback(); } public void rollback() throws IOException { ensureOpen(); if (this.autoCommit) throw new IllegalStateException(""rollback() can only be called when IndexWriter was opened with autoCommit=false"");  if (shouldClose()) rollbackInternal();  } private void rollbackInternal() throws IOException { boolean success = false; this.docWriter.pauseAllThreads(); try { finishMerges(false); this.mergePolicy.close(); this.mergeScheduler.close(); synchronized (this) { if (this.pendingCommit != null) { this.pendingCommit.rollbackCommit(this.directory); this.deleter.decRef(this.pendingCommit); this.pendingCommit = null; notifyAll(); }  this.segmentInfos.clear(); this.segmentInfos.addAll(this.rollbackSegmentInfos); assert !hasExternalSegments(); this.docWriter.abort(); assert testPoint(""rollback before checkpoint""); this.deleter.checkpoint(this.segmentInfos, false); this.deleter.refresh(); }  this.lastCommitChangeCount = this.changeCount; success = true; } catch (OutOfMemoryError oom) { this.hitOOM = true; throw oom; } finally { synchronized (this) { if (!success) { this.docWriter.resumeAllThreads(); this.closing = false; notifyAll(); if (this.infoStream != null) message(""hit exception during rollback"");  }  }  }  closeInternal(false); } private synchronized void finishMerges(boolean waitForMerges) throws IOException { if (!waitForMerges) { this.stopMerges = true; Iterator it = this.pendingMerges.iterator(); while (it.hasNext()) { MergePolicy.OneMerge merge = it.next(); if (this.infoStream != null) message(""now abort pending merge "" + merge.segString(this.directory));  merge.abort(); mergeFinish(merge); }  this.pendingMerges.clear(); it = this.runningMerges.iterator(); while (it.hasNext()) { MergePolicy.OneMerge merge = it.next(); if (this.infoStream != null) message(""now abort running merge "" + merge.segString(this.directory));  merge.abort(); }  acquireRead(); releaseRead(); while (this.runningMerges.size() > 0) { if (this.infoStream != null) message(""now wait for "" + this.runningMerges.size() + "" running merge to abort"");  doWait(); }  this.stopMerges = false; notifyAll(); assert 0 == this.mergingSegments.size(); if (this.infoStream != null) message(""all running merges have aborted"");  } else { acquireRead(); releaseRead(); while (this.pendingMerges.size() > 0 || this.runningMerges.size() > 0) doWait();  assert 0 == this.mergingSegments.size(); }  } private synchronized void checkpoint() throws IOException { this.changeCount++; this.deleter.checkpoint(this.segmentInfos, false); } private void finishAddIndexes() { releaseWrite(); } private void blockAddIndexes(boolean includePendingClose) { acquireRead(); boolean success = false; try { ensureOpen(includePendingClose); success = true; } finally { if (!success) releaseRead();  }  } private void resumeAddIndexes() { releaseRead(); } public void addIndexes(Directory[] dirs) throws CorruptIndexException, IOException { ensureOpen(); noDupDirs(dirs); this.docWriter.pauseAllThreads(); try { if (this.infoStream != null) message(""flush at addIndexes"");  flush(true, false, true); boolean success = false; startTransaction(false); try { int docCount = 0; synchronized (this) { ensureOpen(); for (int i = 0; i < dirs.length; i++) { SegmentInfos sis = new SegmentInfos(); sis.read(dirs[i]); for (int j = 0; j < sis.size(); j++) { SegmentInfo info = sis.info(j); docCount += info.docCount; assert !this.segmentInfos.contains(info); this.segmentInfos.add((E)info); }  }  }  this.docWriter.updateFlushedDocCount(docCount); optimize(); success = true; } finally { if (success) { commitTransaction(); } else { rollbackTransaction(); }  }  } catch (OutOfMemoryError oom) { this.hitOOM = true; throw oom; } finally { this.docWriter.resumeAllThreads(); }  } private synchronized void resetMergeExceptions() { this.mergeExceptions = new ArrayList(); this.mergeGen++; } private void noDupDirs(Directory[] dirs) { HashSet dups = new HashSet(); for (int i = 0; i < dirs.length; i++) { if (dups.contains(dirs[i])) throw new IllegalArgumentException(""Directory "" + dirs[i] + "" appears more than once"");  if (dirs[i] == this.directory) throw new IllegalArgumentException(""Cannot add directory to itself"");  dups.add(dirs[i]); }  } public void addIndexesNoOptimize(Directory[] dirs) throws CorruptIndexException, IOException { ensureOpen(); noDupDirs(dirs); this.docWriter.pauseAllThreads(); try { if (this.infoStream != null) message(""flush at addIndexesNoOptimize"");  flush(true, false, true); boolean success = false; startTransaction(false); try { int docCount = 0; synchronized (this) { ensureOpen(); for (int i = 0; i < dirs.length; i++) { if (this.directory == dirs[i]) throw new IllegalArgumentException(""Cannot add this index to itself"");  SegmentInfos sis = new SegmentInfos(); sis.read(dirs[i]); for (int j = 0; j < sis.size(); j++) { SegmentInfo info = sis.info(j); assert !this.segmentInfos.contains(info) : ""dup info dir="" + info.dir + "" name="" + info.name; docCount += info.docCount; this.segmentInfos.add((E)info); }  }  }  this.docWriter.updateFlushedDocCount(docCount); maybeMerge(); ensureOpen(); resolveExternalSegments(); ensureOpen(); success = true; } finally { if (success) { commitTransaction(); } else { rollbackTransaction(); }  }  } catch (OutOfMemoryError oom) { this.hitOOM = true; throw oom; } finally { this.docWriter.resumeAllThreads(); }  } private boolean hasExternalSegments() { return hasExternalSegments(this.segmentInfos); } private boolean hasExternalSegments(SegmentInfos infos) { int numSegments = infos.size(); for (int i = 0; i < numSegments; i++) { if ((infos.info(i)).dir != this.directory) return true;  }  return false; } private void resolveExternalSegments() throws CorruptIndexException, IOException { boolean any = false; boolean done = false; while (!done) { SegmentInfo info = null; MergePolicy.OneMerge merge = null; synchronized (this) { if (this.stopMerges) throw new MergePolicy.MergeAbortedException(""rollback() was called or addIndexes* hit an unhandled exception"");  int numSegments = this.segmentInfos.size(); done = true; for (int i = 0; i < numSegments; i++) { info = this.segmentInfos.info(i); if (info.dir != this.directory) { done = false; MergePolicy.OneMerge newMerge = new MergePolicy.OneMerge(this.segmentInfos.range(i, 1 + i), info.getUseCompoundFile()); if (registerMerge(newMerge)) { merge = newMerge; this.pendingMerges.remove(merge); this.runningMerges.add(merge); break; }  }  }  if (!done && merge == null) merge = getNextExternalMerge();  if (!done && merge == null) doWait();  }  if (merge != null) { any = true; merge(merge); }  }  if (any) this.mergeScheduler.merge(this);  } public void addIndexes(IndexReader[] readers) throws CorruptIndexException, IOException { ensureOpen(); this.docWriter.pauseAllThreads(); acquireWrite(); try { boolean success = false; SegmentInfo info = null; String mergedName = null; SegmentMerger merger = null; try { flush(true, false, true); optimize(); success = true; } finally { if (!success) releaseWrite();  }  startTransaction(true); try { mergedName = newSegmentName(); merger = new SegmentMerger(this, mergedName, null); IndexReader sReader = null; synchronized (this) { if (this.segmentInfos.size() == 1) sReader = SegmentReader.get(true, this.segmentInfos.info(0));  }  try { if (sReader != null) merger.add(sReader);  for (int i = 0; i < readers.length; i++) merger.add(readers[i]);  int docCount = merger.merge(); if (sReader != null) { sReader.close(); sReader = null; }  synchronized (this) { this.segmentInfos.clear(); info = new SegmentInfo(mergedName, docCount, this.directory, false, true, -1, null, false, merger.hasProx()); this.segmentInfos.add((E)info); }  this.docWriter.updateFlushedDocCount(docCount); success = true; } finally { if (sReader != null) sReader.close();  }  } finally { if (!success) { if (this.infoStream != null) message(""hit exception in addIndexes during merge"");  rollbackTransaction(); } else { commitTransaction(); }  }  if (this.mergePolicy instanceof LogMergePolicy && getUseCompoundFile()) { List files = null; synchronized (this) { if (this.segmentInfos.contains(info)) { files = info.files(); this.deleter.incRef(files); }  }  if (files != null) { success = false; startTransaction(false); try { merger.createCompoundFile(mergedName + "".cfs""); synchronized (this) { info.setUseCompoundFile(true); }  success = true; } finally { this.deleter.decRef(files); if (!success) { if (this.infoStream != null) message(""hit exception building compound file in addIndexes during merge"");  rollbackTransaction(); } else { commitTransaction(); }  }  }  }  } catch (OutOfMemoryError oom) { this.hitOOM = true; throw oom; } finally { this.docWriter.resumeAllThreads(); }  } private boolean startSync(String fileName, Collection pending) { synchronized (this.synced)
/* 4408 */     { if (!this.synced.contains(fileName)) {
/* 4409 */         if (!this.syncing.contains(fileName)) {
/* 4410 */           this.syncing.add(fileName);
/* 4411 */           return true;
/*      */         } 
/* 4413 */         pending.add(fileName);
/* 4414 */         return false;
/*      */       } 
/*      */       
/* 4417 */       return false; }  }
/*      */   void doAfterFlush() throws IOException {}
/*      */   public final void flush() throws CorruptIndexException, IOException { flush(true, false, true); }
/*      */   public final void prepareCommit() throws CorruptIndexException, IOException { ensureOpen(); prepareCommit(false); }
/*      */   private final void prepareCommit(boolean internal) throws CorruptIndexException, IOException { if (this.hitOOM) throw new IllegalStateException(""this writer hit an OutOfMemoryError; cannot commit"");  if (this.autoCommit && !internal) throw new IllegalStateException(""this method can only be used when autoCommit is false"");  if (!this.autoCommit && this.pendingCommit != null) throw new IllegalStateException(""prepareCommit was already called with no corresponding call to commit"");  message(""prepareCommit: flush""); flush(true, true, true); startCommit(0L); }
/* 4422 */   private void commit(long sizeInBytes) throws IOException { startCommit(sizeInBytes); finishCommit(); } private synchronized void waitForCommit() { while (this.committing) doWait();  this.committing = true; } private synchronized void doneCommit() { this.committing = false; notifyAll(); } public final void commit() throws CorruptIndexException, IOException { ensureOpen(); waitForCommit(); try { message(""commit: start""); if (this.autoCommit || this.pendingCommit == null) { message(""commit: now prepare""); prepareCommit(true); } else { message(""commit: already prepared""); }  finishCommit(); } finally { doneCommit(); }  } private final synchronized void finishCommit() throws CorruptIndexException, IOException { if (this.pendingCommit != null) { try { message(""commit: pendingCommit != null""); this.pendingCommit.finishCommit(this.directory); this.lastCommitChangeCount = this.pendingCommitChangeCount; this.segmentInfos.updateGeneration(this.pendingCommit); setRollbackSegmentInfos(this.pendingCommit); this.deleter.checkpoint(this.pendingCommit, true); } finally { this.deleter.decRef(this.pendingCommit); this.pendingCommit = null; notifyAll(); }  } else { message(""commit: pendingCommit == null; skip""); }  message(""commit: done""); } protected final void flush(boolean triggerMerge, boolean flushDocStores, boolean flushDeletes) throws CorruptIndexException, IOException { ensureOpen(false); if (doFlush(flushDocStores, flushDeletes) && triggerMerge) maybeMerge();  } private final synchronized boolean doFlush(boolean flushDocStores, boolean flushDeletes) throws CorruptIndexException, IOException { ensureOpen(false); assert testPoint(""startDoFlush""); this.flushCount++; flushDeletes |= this.docWriter.deletesFull(); flushDeletes |= this.autoCommit; if (this.docWriter.pauseAllThreads()) { this.docWriter.resumeAllThreads(); return false; }  try { SegmentInfo newSegment = null; int numDocs = this.docWriter.getNumDocsInRAM(); boolean flushDocs = (numDocs > 0); flushDocStores |= this.autoCommit; String docStoreSegment = this.docWriter.getDocStoreSegment(); if (docStoreSegment == null) flushDocStores = false;  int docStoreOffset = this.docWriter.getDocStoreOffset(); assert !this.autoCommit || 0 == docStoreOffset; boolean docStoreIsCompoundFile = false; if (this.infoStream != null) { message(""  flush: segment="" + this.docWriter.getSegment() + "" docStoreSegment="" + this.docWriter.getDocStoreSegment() + "" docStoreOffset="" + docStoreOffset + "" flushDocs="" + flushDocs + "" flushDeletes="" + flushDeletes + "" flushDocStores="" + flushDocStores + "" numDocs="" + numDocs + "" numBufDelTerms="" + this.docWriter.getNumBufferedDeleteTerms()); message(""  index before flush "" + segString()); }  if (flushDocStores && (!flushDocs || !this.docWriter.getSegment().equals(this.docWriter.getDocStoreSegment()))) { if (this.infoStream != null) message(""  flush shared docStore segment "" + docStoreSegment);  docStoreIsCompoundFile = flushDocStores(); flushDocStores = false; }  String segment = this.docWriter.getSegment(); assert segment != null || !flushDocs; if (flushDocs) { int flushedDocCount; boolean success = false; try { flushedDocCount = this.docWriter.flush(flushDocStores); success = true; } finally { if (!success) { if (this.infoStream != null) message(""hit exception flushing segment "" + segment);  this.deleter.refresh(segment); }  }  if (0 == docStoreOffset && flushDocStores) { assert docStoreSegment != null; assert docStoreSegment.equals(segment); docStoreOffset = -1; docStoreIsCompoundFile = false; docStoreSegment = null; }  newSegment = new SegmentInfo(segment, flushedDocCount, this.directory, false, true, docStoreOffset, docStoreSegment, docStoreIsCompoundFile, this.docWriter.hasProx()); }  this.docWriter.pushDeletes(); if (flushDocs) this.segmentInfos.add((E)newSegment);  if (flushDeletes) { this.flushDeletesCount++; applyDeletes(); }  doAfterFlush(); if (flushDocs) checkpoint();  if (flushDocs && this.mergePolicy.useCompoundFile(this.segmentInfos, newSegment)) { boolean success = false; try { this.docWriter.createCompoundFile(segment); success = true; } finally { if (!success) { if (this.infoStream != null) message(""hit exception creating compound file for newly flushed segment "" + segment);  this.deleter.deleteFile(segment + ""."" + ""cfs""); }  }  newSegment.setUseCompoundFile(true); checkpoint(); }  return flushDocs; } catch (OutOfMemoryError oom) { this.hitOOM = true; throw oom; } finally { this.docWriter.clearFlushPending(); this.docWriter.resumeAllThreads(); }  } public final long ramSizeInBytes() { ensureOpen(); return this.docWriter.getRAMUsed(); } public final synchronized int numRamDocs() { ensureOpen(); return this.docWriter.getNumDocsInRAM(); } private int ensureContiguousMerge(MergePolicy.OneMerge merge) { int first = this.segmentInfos.indexOf(merge.segments.info(0)); if (first == -1) throw new MergePolicy.MergeException(""could not find segment "" + (merge.segments.info(0)).name + "" in current segments"", this.directory);  int numSegments = this.segmentInfos.size(); int numSegmentsToMerge = merge.segments.size(); for (int i = 0; i < numSegmentsToMerge; i++) { SegmentInfo info = merge.segments.info(i); if (first + i >= numSegments || !this.segmentInfos.info(first + i).equals(info)) { if (this.segmentInfos.indexOf(info) == -1) throw new MergePolicy.MergeException(""MergePolicy selected a segment ("" + info.name + "") that is not in the index"", this.directory);  throw new MergePolicy.MergeException(""MergePolicy selected non-contiguous segments to merge ("" + merge.segString(this.directory) + "" vs "" + segString() + ""), which IndexWriter (currently) cannot handle"", this.directory); }  }  return first; } private synchronized void commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException { assert testPoint(""startCommitMergeDeletes""); SegmentInfos sourceSegmentsClone = merge.segmentsClone; SegmentInfos sourceSegments = merge.segments; if (this.infoStream != null) message(""commitMergeDeletes "" + merge.segString(this.directory));  BitVector deletes = null; int docUpto = 0; int delCount = 0; int numSegmentsToMerge = sourceSegments.size(); for (int i = 0; i < numSegmentsToMerge; i++) { SegmentInfo previousInfo = sourceSegmentsClone.info(i); SegmentInfo currentInfo = sourceSegments.info(i); assert currentInfo.docCount == previousInfo.docCount; int docCount = currentInfo.docCount; if (previousInfo.hasDeletions()) { assert currentInfo.hasDeletions(); BitVector previousDeletes = new BitVector(previousInfo.dir, previousInfo.getDelFileName()); if (!currentInfo.getDelFileName().equals(previousInfo.getDelFileName())) { if (deletes == null) deletes = new BitVector(merge.info.docCount);  BitVector currentDeletes = new BitVector(currentInfo.dir, currentInfo.getDelFileName()); for (int j = 0; j < docCount; j++) { if (previousDeletes.get(j)) { assert currentDeletes.get(j); } else { if (currentDeletes.get(j)) { deletes.set(docUpto); delCount++; }  docUpto++; }  }  } else { docUpto += docCount - previousDeletes.count(); }  } else if (currentInfo.hasDeletions()) { if (deletes == null) deletes = new BitVector(merge.info.docCount);  BitVector currentDeletes = new BitVector(this.directory, currentInfo.getDelFileName()); for (int j = 0; j < docCount; j++) { if (currentDeletes.get(j)) { deletes.set(docUpto); delCount++; }  docUpto++; }  } else { docUpto += currentInfo.docCount; }  }  if (deletes != null) { merge.info.advanceDelGen(); message(""commit merge deletes to "" + merge.info.getDelFileName()); deletes.write(this.directory, merge.info.getDelFileName()); merge.info.setDelCount(delCount); assert delCount == deletes.count(); }  } private synchronized boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount) throws IOException { assert testPoint(""startCommitMerge""); if (this.hitOOM) return false;  if (this.infoStream != null) message(""commitMerge: "" + merge.segString(this.directory) + "" index="" + segString());  assert merge.registerDone; if (merge.isAborted()) { if (this.infoStream != null) message(""commitMerge: skipping merge "" + merge.segString(this.directory) + "": it was aborted"");  this.deleter.refresh(merge.info.name); return false; }  int start = ensureContiguousMerge(merge); commitMergedDeletes(merge); this.docWriter.remapDeletes(this.segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount); String mergeDocStoreSegment = merge.info.getDocStoreSegment(); if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) { int size = this.segmentInfos.size(); for (int i = 0; i < size; i++) { SegmentInfo info = this.segmentInfos.info(i); String docStoreSegment = info.getDocStoreSegment(); if (docStoreSegment != null && docStoreSegment.equals(mergeDocStoreSegment) && info.getDocStoreIsCompoundFile()) { merge.info.setDocStoreIsCompoundFile(true); break; }  }  }  merge.info.setHasProx(merger.hasProx()); this.segmentInfos.subList(start, start + merge.segments.size()).clear(); assert !this.segmentInfos.contains(merge.info); this.segmentInfos.add(start, (E)merge.info); checkpoint(); decrefMergeSegments(merge); if (merge.optimize) this.segmentsToOptimize.add(merge.info);  return true; } private void decrefMergeSegments(MergePolicy.OneMerge merge) throws IOException { SegmentInfos sourceSegmentsClone = merge.segmentsClone; int numSegmentsToMerge = sourceSegmentsClone.size(); assert merge.increfDone; merge.increfDone = false; for (int i = 0; i < numSegmentsToMerge; i++) { SegmentInfo previousInfo = sourceSegmentsClone.info(i); if (previousInfo.dir == this.directory) this.deleter.decRef(previousInfo.files());  }  } private final void handleMergeException(Throwable t, MergePolicy.OneMerge merge) throws IOException { merge.setException(t); addMergeException(merge); if (t instanceof MergePolicy.MergeAbortedException) { if (merge.isExternal) throw (MergePolicy.MergeAbortedException)t;  } else { if (t instanceof IOException) throw (IOException)t;  if (t instanceof RuntimeException) throw (RuntimeException)t;  if (t instanceof Error) throw (Error)t;  throw new RuntimeException(t); }  } final void merge(MergePolicy.OneMerge merge) throws CorruptIndexException, IOException { boolean success = false; try { try { mergeInit(merge); if (this.infoStream != null) message(""now merge\n  merge="" + merge.segString(this.directory) + ""\n  merge="" + merge + ""\n  index="" + segString());  mergeMiddle(merge); success = true; } catch (Throwable t) { handleMergeException(t, merge); } finally { synchronized (this) { try { mergeFinish(merge); if (!success) { if (this.infoStream != null) message(""hit exception during merge"");  if (merge.info != null && !this.segmentInfos.contains(merge.info)) this.deleter.refresh(merge.info.name);  }  if (success && !merge.isAborted() && !this.closed && !this.closing) updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);  } finally { this.runningMerges.remove(merge); }  }  }  } catch (OutOfMemoryError oom) { this.hitOOM = true; throw oom; }  } final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException { if (merge.registerDone) return true;  if (this.stopMerges) { merge.abort(); throw new MergePolicy.MergeAbortedException(""merge is aborted: "" + merge.segString(this.directory)); }  int count = merge.segments.size(); boolean isExternal = false; for (int i = 0; i < count; i++) { SegmentInfo info = merge.segments.info(i); if (this.mergingSegments.contains(info)) return false;  if (this.segmentInfos.indexOf(info) == -1) return false;  if (info.dir != this.directory) isExternal = true;  }  ensureContiguousMerge(merge); this.pendingMerges.add(merge); if (this.infoStream != null) message(""add merge to pendingMerges: "" + merge.segString(this.directory) + "" [total "" + this.pendingMerges.size() + "" pending]"");  merge.mergeGen = this.mergeGen; merge.isExternal = isExternal; for (int i = 0; i < count; i++) this.mergingSegments.add(merge.segments.info(i));  merge.registerDone = true; return true; } final synchronized void mergeInit(MergePolicy.OneMerge merge) throws IOException { boolean success = false; try { _mergeInit(merge); success = true; } finally { if (!success) { mergeFinish(merge); this.runningMerges.remove(merge); }  }  } private final synchronized void _mergeInit(MergePolicy.OneMerge merge) throws IOException { boolean docStoreIsCompoundFile; Object docStoreSegment; assert testPoint(""startMergeInit""); assert merge.registerDone; assert !merge.optimize || merge.maxNumSegmentsOptimize > 0; if (merge.info != null) return;  if (merge.isAborted()) return;  boolean changed = applyDeletes(); assert !changed || !this.autoCommit; SegmentInfos sourceSegments = merge.segments; int end = sourceSegments.size(); Directory lastDir = this.directory; String lastDocStoreSegment = null; int next = -1; boolean mergeDocStores = false; boolean doFlushDocStore = false; String currentDocStoreSegment = this.docWriter.getDocStoreSegment(); int docStoreOffset; for (docStoreOffset = 0; docStoreOffset < end; docStoreOffset++) { docStoreSegment = sourceSegments.info(docStoreOffset); if (docStoreSegment.hasDeletions()) mergeDocStores = true;  if (-1 == docStoreSegment.getDocStoreOffset()) mergeDocStores = true;  String docStoreSegment = docStoreSegment.getDocStoreSegment(); if (docStoreSegment == null) { mergeDocStores = true; } else if (lastDocStoreSegment == null) { lastDocStoreSegment = docStoreSegment; } else if (!lastDocStoreSegment.equals(docStoreSegment)) { mergeDocStores = true; }  if (-1 == next) { next = docStoreSegment.getDocStoreOffset() + docStoreSegment.docCount; } else if (next != docStoreSegment.getDocStoreOffset()) { mergeDocStores = true; } else { next = docStoreSegment.getDocStoreOffset() + docStoreSegment.docCount; }  if (lastDir != docStoreSegment.dir) mergeDocStores = true;  if (docStoreSegment.getDocStoreOffset() != -1 && currentDocStoreSegment != null && docStoreSegment.getDocStoreSegment().equals(currentDocStoreSegment)) doFlushDocStore = true;  }  if (mergeDocStores) { int docStoreOffset = -1; docStoreSegment = null; docStoreIsCompoundFile = false; } else { SegmentInfo si = sourceSegments.info(0); docStoreOffset = si.getDocStoreOffset(); docStoreSegment = si.getDocStoreSegment(); docStoreIsCompoundFile = si.getDocStoreIsCompoundFile(); }  if (mergeDocStores && doFlushDocStore) { if (this.infoStream != null) message(""now flush at merge"");  doFlush(true, false); }  merge.segmentsClone = (SegmentInfos)merge.segments.clone(); for (int i = 0; i < end; i++) { SegmentInfo si = merge.segmentsClone.info(i); if (si.dir == this.directory) this.deleter.incRef(si.files());  }  merge.increfDone = true; merge.mergeDocStores = mergeDocStores; merge.info = new SegmentInfo(newSegmentName(), 0, this.directory, false, true, docStoreOffset, (String)docStoreSegment, docStoreIsCompoundFile, false); this.mergingSegments.add(merge.info); } private synchronized boolean doCommitBeforeMergeCFS(MergePolicy.OneMerge merge) throws IOException { long freeableBytes = 0L; int size = merge.segments.size(); for (int i = 0; i < size; i++) { SegmentInfo info = merge.segments.info(i); Integer loc = (Integer)this.rollbackSegments.get(info); if (loc != null) { SegmentInfo oldInfo = this.rollbackSegmentInfos.info(loc.intValue()); if (oldInfo.getUseCompoundFile() != info.getUseCompoundFile()) freeableBytes += info.sizeInBytes();  }  }  long totalBytes = 0L; int numSegments = this.segmentInfos.size(); for (int i = 0; i < numSegments; i++) totalBytes += this.segmentInfos.info(i).sizeInBytes();  if (3L * freeableBytes > totalBytes) return true;  return false; } final synchronized void mergeFinish(MergePolicy.OneMerge merge) throws IOException { notifyAll(); if (merge.increfDone) decrefMergeSegments(merge);  assert merge.registerDone; SegmentInfos sourceSegments = merge.segments; int end = sourceSegments.size(); for (int i = 0; i < end; i++) this.mergingSegments.remove(sourceSegments.info(i));  this.mergingSegments.remove(merge.info); merge.registerDone = false; } private final int mergeMiddle(MergePolicy.OneMerge merge) throws CorruptIndexException, IOException { merge.checkAborted(this.directory); String mergedName = merge.info.name; SegmentMerger merger = null; int mergedDocCount = 0; SegmentInfos sourceSegments = merge.segments; SegmentInfos sourceSegmentsClone = merge.segmentsClone; int numSegments = sourceSegments.size(); if (this.infoStream != null) message(""merging "" + merge.segString(this.directory));  merger = new SegmentMerger(this, mergedName, merge); boolean success = false; try { int totDocCount = 0; for (int i = 0; i < numSegments; i++) { SegmentInfo si = sourceSegmentsClone.info(i); IndexReader reader = SegmentReader.get(true, si, 4096, merge.mergeDocStores); merger.add(reader); totDocCount += reader.numDocs(); }  if (this.infoStream != null) message(""merge: total "" + totDocCount + "" docs"");  merge.checkAborted(this.directory); mergedDocCount = merge.info.docCount = merger.merge(merge.mergeDocStores); assert mergedDocCount == totDocCount; success = true; } finally { if (merger != null) merger.closeReaders();  }  if (!commitMerge(merge, merger, mergedDocCount)) return 0;  if (merge.useCompoundFile) { if (this.autoCommit && doCommitBeforeMergeCFS(merge)) { long size; synchronized (this) { size = merge.info.sizeInBytes(); }  commit(size); }  success = false; String compoundFileName = mergedName + ""."" + ""cfs""; try { merger.createCompoundFile(compoundFileName); success = true; } catch (IOException ioe) { synchronized (this) { if (merge.isAborted()) { success = true; } else { handleMergeException(ioe, merge); }  }  } catch (Throwable t) { handleMergeException(t, merge); } finally { if (!success) { if (this.infoStream != null) message(""hit exception creating compound file during merge"");  synchronized (this) { this.deleter.deleteFile(compoundFileName); }  }  }  if (merge.isAborted()) { if (this.infoStream != null) message(""abort merge after building CFS"");  this.deleter.deleteFile(compoundFileName); return 0; }  synchronized (this) { if (this.segmentInfos.indexOf(merge.info) == -1 || merge.isAborted()) { this.deleter.deleteFile(compoundFileName); } else { merge.info.setUseCompoundFile(true); checkpoint(); }  }  }  if (this.autoCommit) { long size; synchronized (this) { size = merge.info.sizeInBytes(); }  commit(size); }  return mergedDocCount; } synchronized void addMergeException(MergePolicy.OneMerge merge) { assert merge.getException() != null; if (!this.mergeExceptions.contains(merge) && this.mergeGen == merge.mergeGen) this.mergeExceptions.add(merge);  } private final synchronized boolean applyDeletes() throws CorruptIndexException, IOException { boolean changed; assert testPoint(""startApplyDeletes""); SegmentInfos rollback = (SegmentInfos)this.segmentInfos.clone(); boolean success = false; try { changed = this.docWriter.applyDeletes(this.segmentInfos); success = true; } finally { if (!success) { if (this.infoStream != null) message(""hit exception flushing deletes"");  int size = rollback.size(); for (int i = 0; i < size; i++) { String newDelFileName = this.segmentInfos.info(i).getDelFileName(); String delFileName = rollback.info(i).getDelFileName(); if (newDelFileName != null && !newDelFileName.equals(delFileName)) this.deleter.deleteFile(newDelFileName);  }  this.segmentInfos.clear(); this.segmentInfos.addAll(rollback); }  }  if (changed) checkpoint();  return changed; } final synchronized int getBufferedDeleteTermsSize() { return this.docWriter.getBufferedDeleteTerms().size(); } final synchronized int getNumBufferedDeleteTerms() { return this.docWriter.getNumBufferedDeleteTerms(); } SegmentInfo newestSegment() { return this.segmentInfos.info(this.segmentInfos.size() - 1); } public synchronized String segString() { return segString(this.segmentInfos); } private synchronized String segString(SegmentInfos infos) { StringBuffer buffer = new StringBuffer(); int count = infos.size(); for (int i = 0; i < count; i++) { if (i > 0) buffer.append(' ');  SegmentInfo info = infos.info(i); buffer.append(info.segString(this.directory)); if (info.dir != this.directory) buffer.append(""**"");  }  return buffer.toString(); } private void finishSync(String fileName, boolean success) { synchronized (this.synced) {
/* 4423 */       assert this.syncing.contains(fileName);
/* 4424 */       this.syncing.remove(fileName);
/* 4425 */       if (success)
/* 4426 */         this.synced.add(fileName); 
/* 4427 */       this.synced.notifyAll();
/*      */     }  }
/*      */ 
/*      */ 
/*      */   
/*      */   private boolean waitForAllSynced(Collection syncing) throws IOException {
/* 4433 */     synchronized (this.synced) {
/* 4434 */       Iterator it = syncing.iterator();
/* 4435 */       while (it.hasNext()) {
/* 4436 */         String fileName = it.next();
/* 4437 */         while (!this.synced.contains(fileName)) {
/* 4438 */           if (!syncing.contains(fileName))
/*      */           {
/*      */             
/* 4441 */             return false;
/*      */           }
/*      */           try {
/* 4444 */             this.synced.wait();
/* 4445 */           } catch (InterruptedException ie) {}
/*      */         } 
/*      */       } 
/*      */ 
/*      */       
/* 4450 */       return true;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void syncPause(long sizeInBytes) {
/* 4461 */     if (this.mergeScheduler instanceof ConcurrentMergeScheduler && this.maxSyncPauseSeconds > 0.0D) {
/*      */ 
/*      */       
/* 4464 */       long pauseTime = 1000L * sizeInBytes / 10L / 1024L / 1024L;
/* 4465 */       long maxPauseTime = (long)(this.maxSyncPauseSeconds * 1000.0D);
/* 4466 */       if (pauseTime > maxPauseTime)
/* 4467 */         pauseTime = maxPauseTime; 
/* 4468 */       int sleepCount = (int)(pauseTime / 100L);
/* 4469 */       for (int i = 0; i < sleepCount; i++) {
/* 4470 */         synchronized (this) {
/* 4471 */           if (this.stopMerges || this.closing)
/*      */             break; 
/*      */         } 
/*      */         try {
/* 4475 */           Thread.sleep(100L);
/* 4476 */         } catch (InterruptedException ie) {
/* 4477 */           Thread.currentThread().interrupt();
/*      */         } 
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private synchronized void doWait() {
/*      */     try {
/* 4491 */       wait(1000L);
/* 4492 */     } catch (InterruptedException ie) {
/* 4493 */       Thread.currentThread().interrupt();
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void startCommit(long sizeInBytes) throws IOException {
/* 4504 */     assert testPoint(""startStartCommit"");
/*      */     
/* 4506 */     if (this.hitOOM) {
/*      */       return;
/*      */     }
/*      */     try {
/*      */       long myChangeCount;
/* 4511 */       if (this.infoStream != null) {
/* 4512 */         message(""startCommit(): start sizeInBytes="" + sizeInBytes);
/*      */       }
/* 4514 */       if (sizeInBytes > 0L) {
/* 4515 */         syncPause(sizeInBytes);
/*      */       }
/* 4517 */       SegmentInfos toSync = null;
/*      */ 
/*      */       
/* 4520 */       synchronized (this) {
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */         
/* 4527 */         if (sizeInBytes > 0L && this.stopMerges) {
/*      */           return;
/*      */         }
/*      */ 
/*      */ 
/*      */         
/* 4533 */         blockAddIndexes(false);
/*      */         
/* 4535 */         assert !hasExternalSegments();
/*      */ 
/*      */         
/*      */         try {
/* 4539 */           assert this.lastCommitChangeCount <= this.changeCount;
/*      */           
/* 4541 */           if (this.changeCount == this.lastCommitChangeCount) {
/* 4542 */             if (this.infoStream != null) {
/* 4543 */               message(""  skip startCommit(): no changes pending"");
/*      */             }
/*      */ 
/*      */ 
/*      */             
/*      */             return;
/*      */           } 
/*      */ 
/*      */ 
/*      */           
/* 4553 */           if (this.infoStream != null) {
/* 4554 */             message(""startCommit index="" + segString(this.segmentInfos) + "" changeCount="" + this.changeCount);
/*      */           }
/* 4556 */           toSync = (SegmentInfos)this.segmentInfos.clone();
/* 4557 */           this.deleter.incRef(toSync, false);
/* 4558 */           myChangeCount = this.changeCount;
/*      */         } finally {
/* 4560 */           resumeAddIndexes();
/*      */         } 
/*      */       } 
/*      */       
/* 4564 */       assert testPoint(""midStartCommit"");
/*      */       
/* 4566 */       boolean setPending = false;
/*      */ 
/*      */       
/*      */       try {
/*      */         Collection pending;
/*      */         
/*      */         do {
/* 4573 */           pending = new ArrayList();
/*      */           
/* 4575 */           for (int i = 0; i < toSync.size(); i++) {
/* 4576 */             SegmentInfo info = toSync.info(i);
/* 4577 */             List files = info.files();
/* 4578 */             for (int j = 0; j < files.size(); j++) {
/* 4579 */               String fileName = files.get(j);
/* 4580 */               if (startSync(fileName, pending)) {
/* 4581 */                 boolean success = false;
/*      */ 
/*      */                 
/*      */                 try {
/* 4585 */                   assert this.directory.fileExists(fileName) : ""file '"" + fileName + ""' does not exist dir="" + this.directory;
/* 4586 */                   message(""now sync "" + fileName);
/* 4587 */                   this.directory.sync(fileName);
/* 4588 */                   success = true;
/*      */                 } finally {
/* 4590 */                   finishSync(fileName, success);
/*      */                 
/*      */                 }
/*      */ 
/*      */               
/*      */               }
/*      */             
/*      */             }
/*      */           
/*      */           }
/*      */         
/*      */         }
/* 4602 */         while (!waitForAllSynced(pending));
/*      */ 
/*      */ 
/*      */         
/* 4606 */         assert testPoint(""midStartCommit2"");
/*      */         
/* 4608 */         synchronized (this) {
/*      */ 
/*      */ 
/*      */ 
/*      */           
/* 4613 */           if (myChangeCount > this.lastCommitChangeCount && (this.pendingCommit == null || myChangeCount > this.pendingCommitChangeCount)) {
/*      */ 
/*      */             
/* 4616 */             while (this.pendingCommit != null) {
/* 4617 */               message(""wait for existing pendingCommit to finish..."");
/* 4618 */               doWait();
/*      */             } 
/*      */             
/* 4621 */             if (this.segmentInfos.getGeneration() > toSync.getGeneration()) {
/* 4622 */               toSync.updateGeneration(this.segmentInfos);
/*      */             }
/* 4624 */             boolean success = false;
/*      */ 
/*      */ 
/*      */ 
/*      */             
/*      */             try {
/*      */               try {
/* 4631 */                 toSync.prepareCommit(this.directory);
/*      */               
/*      */               }
/*      */               finally {
/*      */ 
/*      */                 
/* 4637 */                 this.segmentInfos.updateGeneration(toSync);
/*      */               } 
/*      */               
/* 4640 */               assert this.pendingCommit == null;
/* 4641 */               setPending = true;
/* 4642 */               this.pendingCommit = toSync;
/* 4643 */               this.pendingCommitChangeCount = myChangeCount;
/* 4644 */               success = true;
/*      */             } finally {
/* 4646 */               if (!success)
/* 4647 */                 message(""hit exception committing segments file""); 
/*      */             } 
/*      */           } else {
/* 4650 */             message(""sync superseded by newer infos"");
/*      */           } 
/*      */         } 
/* 4653 */         message(""done all syncs"");
/*      */         
/* 4655 */         assert testPoint(""midStartCommitSuccess"");
/*      */       } finally {
/*      */         
/* 4658 */         synchronized (this) {
/* 4659 */           if (!setPending)
/* 4660 */             this.deleter.decRef(toSync); 
/*      */         } 
/*      */       } 
/* 4663 */     } catch (OutOfMemoryError oom) {
/* 4664 */       this.hitOOM = true;
/* 4665 */       throw oom;
/*      */     } 
/* 4667 */     assert testPoint(""finishStartCommit"");
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 4677 */   public static boolean isLocked(Directory directory) throws IOException { return directory.makeLock(""write.lock"").isLocked(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static boolean isLocked(String directory) throws IOException {
/* 4687 */     FSDirectory fSDirectory = FSDirectory.getDirectory(directory);
/*      */     try {
/* 4689 */       return isLocked((Directory)fSDirectory);
/*      */     } finally {
/* 4691 */       fSDirectory.close();
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 4703 */   public static void unlock(Directory directory) throws IOException { directory.makeLock(""write.lock"").release(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final class MaxFieldLength
/*      */   {
/*      */     private int limit;
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     private String name;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     private MaxFieldLength(String name, int limit) {
/* 4723 */       this.name = name;
/* 4724 */       this.limit = limit;
/*      */     }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 4733 */     public MaxFieldLength(int limit) { this(""User-specified"", limit); }
/*      */ 
/*      */ 
/*      */     
/* 4737 */     public int getLimit() { return this.limit; }
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 4742 */     public String toString() { return this.name + "":"" + this.limit; }
/*      */ 
/*      */ 
/*      */     
/* 4746 */     public static final MaxFieldLength UNLIMITED = new MaxFieldLength(""UNLIMITED"", 2147483647);
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 4753 */     public static final MaxFieldLength LIMITED = new MaxFieldLength(""LIMITED"", 10000);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 4770 */   boolean testPoint(String name) { return true; }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IndexWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IntBlockPool,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class IntBlockPool
/*    */ {
/* 22 */   public int[][] buffers = new int[10][];
/*    */   
/* 24 */   int bufferUpto = -1;
/* 25 */   public int intUpto = 8192;
/*    */   
/*    */   public int[] buffer;
/* 28 */   public int intOffset = -8192;
/*    */   
/*    */   private final DocumentsWriter docWriter;
/*    */   final boolean trackAllocations;
/*    */   
/*    */   public IntBlockPool(DocumentsWriter docWriter, boolean trackAllocations) {
/* 34 */     this.docWriter = docWriter;
/* 35 */     this.trackAllocations = trackAllocations;
/*    */   }
/*    */   
/*    */   public void reset() {
/* 39 */     if (this.bufferUpto != -1) {
/* 40 */       if (this.bufferUpto > 0)
/*    */       {
/* 42 */         this.docWriter.recycleIntBlocks(this.buffers, 1, 1 + this.bufferUpto);
/*    */       }
/*    */       
/* 45 */       this.bufferUpto = 0;
/* 46 */       this.intUpto = 0;
/* 47 */       this.intOffset = 0;
/* 48 */       this.buffer = this.buffers[0];
/*    */     } 
/*    */   }
/*    */   
/*    */   public void nextBuffer() {
/* 53 */     if (1 + this.bufferUpto == this.buffers.length) {
/* 54 */       int[][] newBuffers = new int[(int)(this.buffers.length * 1.5D)][];
/* 55 */       System.arraycopy(this.buffers, 0, newBuffers, 0, this.buffers.length);
/* 56 */       this.buffers = newBuffers;
/*    */     } 
/* 58 */     this.buffer = this.buffers[1 + this.bufferUpto] = this.docWriter.getIntBlock(this.trackAllocations);
/* 59 */     this.bufferUpto++;
/*    */     
/* 61 */     this.intUpto = 0;
/* 62 */     this.intOffset += 8192;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\IntBlockPool.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.InvertedDocConsumer,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ abstract class InvertedDocConsumer
/*    */ {
/*    */   FieldInfos fieldInfos;
/*    */   
/*    */   abstract InvertedDocConsumerPerThread addThread(DocInverterPerThread paramDocInverterPerThread);
/*    */   
/*    */   abstract void abort();
/*    */   
/*    */   abstract void flush(Map paramMap, DocumentsWriter.FlushState paramFlushState) throws IOException;
/*    */   
/*    */   abstract void closeDocStore(DocumentsWriter.FlushState paramFlushState) throws IOException;
/*    */   
/*    */   abstract boolean freeRAM();
/*    */   
/* 44 */   void setFieldInfos(FieldInfos fieldInfos) { this.fieldInfos = fieldInfos; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\InvertedDocConsumer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.InvertedDocConsumerPerField,"package org.apache.lucene.index;
import java.io.IOException;
import org.apache.lucene.analysis.Token;
import org.apache.lucene.document.Fieldable;
abstract class InvertedDocConsumerPerField {
  abstract boolean start(Fieldable[] paramArrayOfFieldable, int paramInt) throws IOException;
  abstract void add(Token paramToken) throws IOException;
  abstract void finish() throws IOException;
  abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\InvertedDocConsumerPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.InvertedDocConsumerPerThread,"package org.apache.lucene.index;
import java.io.IOException;
abstract class InvertedDocConsumerPerThread {
  abstract void startDocument() throws IOException;
  abstract InvertedDocConsumerPerField addField(DocInverterPerField paramDocInverterPerField, FieldInfo paramFieldInfo);
  abstract DocumentsWriter.DocWriter finishDocument() throws IOException;
  abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\InvertedDocConsumerPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.InvertedDocEndConsumer,"package org.apache.lucene.index;
import java.io.IOException;
import java.util.Map;
abstract class InvertedDocEndConsumer {
  abstract InvertedDocEndConsumerPerThread addThread(DocInverterPerThread paramDocInverterPerThread);
  abstract void flush(Map paramMap, DocumentsWriter.FlushState paramFlushState) throws IOException;
  abstract void closeDocStore(DocumentsWriter.FlushState paramFlushState) throws IOException;
  abstract void abort();
  abstract void setFieldInfos(FieldInfos paramFieldInfos);
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\InvertedDocEndConsumer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.InvertedDocEndConsumerPerField,"package org.apache.lucene.index;
abstract class InvertedDocEndConsumerPerField {
  abstract void finish();
  abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\InvertedDocEndConsumerPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.InvertedDocEndConsumerPerThread,"package org.apache.lucene.index;
abstract class InvertedDocEndConsumerPerThread {
  abstract void startDocument();
  abstract InvertedDocEndConsumerPerField addField(DocInverterPerField paramDocInverterPerField, FieldInfo paramFieldInfo);
  abstract void finishDocument();
  abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\InvertedDocEndConsumerPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.util.List;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class KeepOnlyLastCommitDeletionPolicy
/*    */   implements IndexDeletionPolicy
/*    */ {
/* 36 */   public void onInit(List commits) { onCommit(commits); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void onCommit(List commits) {
/* 45 */     int size = commits.size();
/* 46 */     for (int i = 0; i < size - 1; i++)
/* 47 */       ((IndexCommit)commits.get(i)).delete(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\KeepOnlyLastCommitDeletionPolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.LogByteSizeMergePolicy,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LogByteSizeMergePolicy
/*    */   extends LogMergePolicy
/*    */ {
/*    */   public static final double DEFAULT_MIN_MERGE_MB = 1.6D;
/*    */   public static final double DEFAULT_MAX_MERGE_MB = 9.223372036854776E18D;
/*    */   
/* 39 */   protected long size(SegmentInfo info) throws IOException { return info.sizeInBytes(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 54 */   public void setMaxMergeMB(double mb) { this.maxMergeSize = (long)(mb * 1024.0D * 1024.0D); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 62 */   public double getMaxMergeMB() { return this.maxMergeSize / 1024.0D / 1024.0D; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 75 */   public void setMinMergeMB(double mb) { this.minMergeSize = (long)(mb * 1024.0D * 1024.0D); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 82 */   public double getMinMergeMB() { return this.minMergeSize / 1024.0D / 1024.0D; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\LogByteSizeMergePolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.LogDocMergePolicy,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LogDocMergePolicy
/*    */   extends LogMergePolicy
/*    */ {
/*    */   public static final int DEFAULT_MIN_MERGE_DOCS = 1000;
/*    */   
/* 38 */   protected long size(SegmentInfo info) { return info.docCount; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 51 */   public void setMinMergeDocs(int minMergeDocs) { this.minMergeSize = minMergeDocs; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 58 */   public int getMinMergeDocs() { return (int)this.minMergeSize; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\LogDocMergePolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.LogMergePolicy,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class LogMergePolicy
/*     */   extends MergePolicy
/*     */ {
/*     */   public static final double LEVEL_LOG_SPAN = 0.75D;
/*     */   public static final int DEFAULT_MERGE_FACTOR = 10;
/*     */   public static final int DEFAULT_MAX_MERGE_DOCS = 2147483647;
/*  56 */   private int mergeFactor = 10;
/*     */   
/*     */   long minMergeSize;
/*     */   long maxMergeSize;
/*  60 */   int maxMergeDocs = Integer.MAX_VALUE;
/*     */   private boolean useCompoundFile = true;
/*     */   private boolean useCompoundDocStore = true;
/*     */   private IndexWriter writer;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   private void message(String message) {
/*  67 */     if (this.writer != null) {
/*  68 */       this.writer.message(""LMP: "" + message);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  75 */   public int getMergeFactor() { return this.mergeFactor; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMergeFactor(int mergeFactor) {
/*  88 */     if (mergeFactor < 2)
/*  89 */       throw new IllegalArgumentException(""mergeFactor cannot be less than 2""); 
/*  90 */     this.mergeFactor = mergeFactor;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  95 */   public boolean useCompoundFile(SegmentInfos infos, SegmentInfo info) { return this.useCompoundFile; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public void setUseCompoundFile(boolean useCompoundFile) { this.useCompoundFile = useCompoundFile; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 108 */   public boolean getUseCompoundFile() { return this.useCompoundFile; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 113 */   public boolean useCompoundDocStore(SegmentInfos infos) { return this.useCompoundDocStore; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 120 */   public void setUseCompoundDocStore(boolean useCompoundDocStore) { this.useCompoundDocStore = useCompoundDocStore; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 128 */   public boolean getUseCompoundDocStore() { return this.useCompoundDocStore; }
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() {}
/*     */ 
/*     */   
/*     */   private boolean isOptimized(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {
/* 136 */     int numSegments = infos.size();
/* 137 */     int numToOptimize = 0;
/* 138 */     SegmentInfo optimizeInfo = null;
/* 139 */     for (int i = 0; i < numSegments && numToOptimize <= maxNumSegments; i++) {
/* 140 */       SegmentInfo info = infos.info(i);
/* 141 */       if (segmentsToOptimize.contains(info)) {
/* 142 */         numToOptimize++;
/* 143 */         optimizeInfo = info;
/*     */       } 
/*     */     } 
/*     */     
/* 147 */     return (numToOptimize <= maxNumSegments && (numToOptimize != 1 || isOptimized(writer, optimizeInfo)));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 156 */   private boolean isOptimized(IndexWriter writer, SegmentInfo info) throws IOException { return (!info.hasDeletions() && !info.hasSeparateNorms() && info.dir == writer.getDirectory() && info.getUseCompoundFile() == this.useCompoundFile); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MergePolicy.MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {
/*     */     MergePolicy.MergeSpecification spec;
/* 173 */     assert maxNumSegments > 0;
/*     */     
/* 175 */     if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize))
/*     */     
/*     */     { 
/*     */ 
/*     */       
/* 180 */       int last = infos.size();
/* 181 */       while (last > 0) {
/* 182 */         SegmentInfo info = infos.info(--last);
/* 183 */         if (segmentsToOptimize.contains(info)) {
/* 184 */           last++;
/*     */           
/*     */           break;
/*     */         } 
/*     */       } 
/* 189 */       if (last > 0) {
/*     */         
/* 191 */         spec = new MergePolicy.MergeSpecification();
/*     */ 
/*     */ 
/*     */         
/* 195 */         while (last - maxNumSegments + 1 >= this.mergeFactor) {
/* 196 */           spec.add(new MergePolicy.OneMerge(infos.range(last - this.mergeFactor, last), this.useCompoundFile));
/* 197 */           last -= this.mergeFactor;
/*     */         } 
/*     */ 
/*     */ 
/*     */         
/* 202 */         if (0 == spec.merges.size()) {
/* 203 */           if (maxNumSegments == 1) {
/*     */ 
/*     */ 
/*     */             
/* 207 */             if (last > 1 || !isOptimized(writer, infos.info(0)))
/* 208 */               spec.add(new MergePolicy.OneMerge(infos.range(0, last), this.useCompoundFile)); 
/* 209 */           } else if (last > maxNumSegments) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 220 */             int finalMergeSize = last - maxNumSegments + 1;
/*     */ 
/*     */             
/* 223 */             long bestSize = 0L;
/* 224 */             int bestStart = 0;
/*     */             
/* 226 */             for (int i = 0; i < last - finalMergeSize + 1; i++) {
/* 227 */               long sumSize = 0L;
/* 228 */               for (int j = 0; j < finalMergeSize; j++)
/* 229 */                 sumSize += size(infos.info(j + i)); 
/* 230 */               if (i == 0 || (sumSize < 2L * size(infos.info(i - 1)) && sumSize < bestSize)) {
/* 231 */                 bestStart = i;
/* 232 */                 bestSize = sumSize;
/*     */               } 
/*     */             } 
/*     */             
/* 236 */             spec.add(new MergePolicy.OneMerge(infos.range(bestStart, bestStart + finalMergeSize), this.useCompoundFile));
/*     */           } 
/*     */         }
/*     */       } else {
/*     */         
/* 241 */         spec = null;
/*     */       }  }
/* 243 */     else { spec = null; }
/*     */     
/* 245 */     return spec;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MergePolicy.MergeSpecification findMergesToExpungeDeletes(SegmentInfos segmentInfos, IndexWriter writer) throws CorruptIndexException, IOException {
/* 257 */     this.writer = writer;
/*     */     
/* 259 */     int numSegments = segmentInfos.size();
/*     */     
/* 261 */     message(""findMergesToExpungeDeletes: "" + numSegments + "" segments"");
/*     */     
/* 263 */     MergePolicy.MergeSpecification spec = new MergePolicy.MergeSpecification();
/* 264 */     int firstSegmentWithDeletions = -1;
/* 265 */     for (int i = 0; i < numSegments; i++) {
/* 266 */       SegmentInfo info = segmentInfos.info(i);
/* 267 */       if (info.hasDeletions()) {
/* 268 */         message(""  segment "" + info.name + "" has deletions"");
/* 269 */         if (firstSegmentWithDeletions == -1) {
/* 270 */           firstSegmentWithDeletions = i;
/* 271 */         } else if (i - firstSegmentWithDeletions == this.mergeFactor) {
/*     */ 
/*     */           
/* 274 */           message(""  add merge "" + firstSegmentWithDeletions + "" to "" + (i - 1) + "" inclusive"");
/* 275 */           spec.add(new MergePolicy.OneMerge(segmentInfos.range(firstSegmentWithDeletions, i), this.useCompoundFile));
/* 276 */           firstSegmentWithDeletions = i;
/*     */         } 
/* 278 */       } else if (firstSegmentWithDeletions != -1) {
/*     */ 
/*     */ 
/*     */         
/* 282 */         message(""  add merge "" + firstSegmentWithDeletions + "" to "" + (i - 1) + "" inclusive"");
/* 283 */         spec.add(new MergePolicy.OneMerge(segmentInfos.range(firstSegmentWithDeletions, i), this.useCompoundFile));
/* 284 */         firstSegmentWithDeletions = -1;
/*     */       } 
/*     */     } 
/*     */     
/* 288 */     if (firstSegmentWithDeletions != -1) {
/* 289 */       message(""  add merge "" + firstSegmentWithDeletions + "" to "" + (numSegments - 1) + "" inclusive"");
/* 290 */       spec.add(new MergePolicy.OneMerge(segmentInfos.range(firstSegmentWithDeletions, numSegments), this.useCompoundFile));
/*     */     } 
/*     */     
/* 293 */     return spec;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MergePolicy.MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {
/* 305 */     int numSegments = infos.size();
/* 306 */     this.writer = writer;
/* 307 */     message(""findMerges: "" + numSegments + "" segments"");
/*     */ 
/*     */ 
/*     */     
/* 311 */     float[] levels = new float[numSegments];
/* 312 */     float norm = (float)Math.log(this.mergeFactor);
/*     */     
/* 314 */     Directory directory = writer.getDirectory();
/*     */     int levelFloor;
/* 316 */     for (levelFloor = 0; levelFloor < numSegments; levelFloor++) {
/* 317 */       SegmentInfo info = infos.info(levelFloor);
/* 318 */       long size = size(info);
/*     */ 
/*     */       
/* 321 */       if (size < 1L)
/* 322 */         size = 1L; 
/* 323 */       levels[levelFloor] = (float)Math.log(size) / norm;
/*     */     } 
/*     */ 
/*     */     
/* 327 */     if (this.minMergeSize <= 0L) {
/* 328 */       float levelFloor = 0.0F;
/*     */     } else {
/* 330 */       levelFloor = (float)(Math.log(this.minMergeSize) / norm);
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 339 */     MergePolicy.MergeSpecification spec = null;
/*     */     
/* 341 */     int start = 0;
/* 342 */     while (start < numSegments) {
/*     */ 
/*     */ 
/*     */       
/* 346 */       float maxLevel = levels[start]; int j;
/* 347 */       for (j = 1 + start; j < numSegments; j++) {
/* 348 */         float level = levels[j];
/* 349 */         if (level > maxLevel) {
/* 350 */           maxLevel = level;
/*     */         }
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 356 */       if (maxLevel < levelFloor) {
/*     */         
/* 358 */         float levelBottom = -1.0F;
/*     */       } else {
/* 360 */         float levelBottom = (float)(maxLevel - 0.75D);
/*     */ 
/*     */         
/* 363 */         if (levelBottom < levelFloor && maxLevel >= levelFloor) {
/* 364 */           j = levelFloor;
/*     */         }
/*     */       } 
/* 367 */       int upto = numSegments - 1;
/* 368 */       while (upto >= start && 
/* 369 */         levels[upto] < j)
/*     */       {
/*     */         
/* 372 */         upto--;
/*     */       }
/* 374 */       message(""  level "" + j + "" to "" + maxLevel + "": "" + (1 + upto - start) + "" segments"");
/*     */ 
/*     */       
/* 377 */       int end = start + this.mergeFactor;
/* 378 */       while (end <= 1 + upto) {
/* 379 */         int k = 0;
/* 380 */         for (int i = start; i < end; i++) {
/* 381 */           SegmentInfo info = infos.info(i);
/* 382 */           k = k | ((size(info) >= this.maxMergeSize || info.docCount >= this.maxMergeDocs) ? 1 : 0);
/*     */         } 
/*     */         
/* 385 */         if (k == 0) {
/* 386 */           if (spec == null)
/* 387 */             spec = new MergePolicy.MergeSpecification(); 
/* 388 */           message(""    "" + start + "" to "" + end + "": add this merge"");
/* 389 */           spec.add(new MergePolicy.OneMerge(infos.range(start, end), this.useCompoundFile));
/*     */         } else {
/* 391 */           message(""    "" + start + "" to "" + end + "": contains segment over maxMergeSize or maxMergeDocs; skipping"");
/*     */         } 
/* 393 */         start = end;
/* 394 */         end = start + this.mergeFactor;
/*     */       } 
/*     */       
/* 397 */       start = 1 + upto;
/*     */     } 
/*     */     
/* 400 */     return spec;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 419 */   public void setMaxMergeDocs(int maxMergeDocs) { this.maxMergeDocs = maxMergeDocs; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 426 */   public int getMaxMergeDocs() { return this.maxMergeDocs; }
/*     */   
/*     */   protected abstract long size(SegmentInfo paramSegmentInfo) throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\LogMergePolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MergeDocIDRemapper,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class MergeDocIDRemapper
/*     */ {
/*     */   int[] starts;
/*     */   int[] newStarts;
/*     */   int[][] docMaps;
/*     */   int minDocID;
/*     */   int maxDocID;
/*     */   int docShift;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public MergeDocIDRemapper(SegmentInfos infos, int[][] docMaps, int[] delCounts, MergePolicy.OneMerge merge, int mergedDocCount) {
/*  34 */     this.docMaps = docMaps;
/*  35 */     SegmentInfo firstSegment = merge.segments.info(0);
/*  36 */     int i = 0;
/*     */     while (true) {
/*  38 */       SegmentInfo info = infos.info(i);
/*  39 */       if (info.equals(firstSegment))
/*     */         break; 
/*  41 */       this.minDocID += info.docCount;
/*  42 */       i++;
/*     */     } 
/*     */     
/*  45 */     int numDocs = 0;
/*  46 */     for (int j = 0; j < docMaps.length; i++, j++) {
/*  47 */       numDocs += (infos.info(i)).docCount;
/*  48 */       assert infos.info(i).equals(merge.segments.info(j));
/*     */     } 
/*  50 */     this.maxDocID = this.minDocID + numDocs;
/*     */     
/*  52 */     this.starts = new int[docMaps.length];
/*  53 */     this.newStarts = new int[docMaps.length];
/*     */     
/*  55 */     this.starts[0] = this.minDocID;
/*  56 */     this.newStarts[0] = this.minDocID;
/*  57 */     for (i = 1; i < docMaps.length; i++) {
/*  58 */       int lastDocCount = (merge.segments.info(i - 1)).docCount;
/*  59 */       this.starts[i] = this.starts[i - 1] + lastDocCount;
/*  60 */       this.newStarts[i] = this.newStarts[i - 1] + lastDocCount - delCounts[i - 1];
/*     */     } 
/*  62 */     this.docShift = numDocs - mergedDocCount;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  72 */     assert this.docShift == this.maxDocID - this.newStarts[docMaps.length - 1] + (merge.segments.info(docMaps.length - 1)).docCount - delCounts[docMaps.length - 1];
/*     */   }
/*     */   
/*     */   public int remap(int oldDocID) {
/*  76 */     if (oldDocID < this.minDocID)
/*     */     {
/*  78 */       return oldDocID; } 
/*  79 */     if (oldDocID >= this.maxDocID)
/*     */     {
/*  81 */       return oldDocID - this.docShift;
/*     */     }
/*     */     
/*  84 */     int lo = 0;
/*  85 */     int hi = this.docMaps.length - 1;
/*     */     
/*  87 */     while (hi >= lo) {
/*  88 */       int mid = lo + hi >> 1;
/*  89 */       int midValue = this.starts[mid];
/*  90 */       if (oldDocID < midValue) {
/*  91 */         hi = mid - 1; continue;
/*  92 */       }  if (oldDocID > midValue) {
/*  93 */         lo = mid + 1; continue;
/*     */       } 
/*  95 */       while (mid + 1 < this.docMaps.length && this.starts[mid + 1] == midValue) {
/*  96 */         mid++;
/*     */       }
/*  98 */       if (this.docMaps[mid] != null) {
/*  99 */         return this.newStarts[mid] + this.docMaps[mid][oldDocID - this.starts[mid]];
/*     */       }
/* 101 */       return this.newStarts[mid] + oldDocID - this.starts[mid];
/*     */     } 
/*     */     
/* 104 */     if (this.docMaps[hi] != null) {
/* 105 */       return this.newStarts[hi] + this.docMaps[hi][oldDocID - this.starts[hi]];
/*     */     }
/* 107 */     return this.newStarts[hi] + oldDocID - this.starts[hi];
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MergeDocIDRemapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MergePolicy,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class MergePolicy
/*     */ {
/*     */   abstract MergeSpecification findMerges(SegmentInfos paramSegmentInfos, IndexWriter paramIndexWriter) throws CorruptIndexException, IOException;
/*     */   
/*     */   abstract MergeSpecification findMergesForOptimize(SegmentInfos paramSegmentInfos, IndexWriter paramIndexWriter, int paramInt, Set paramSet) throws CorruptIndexException, IOException;
/*     */   
/*     */   public static class OneMerge
/*     */   {
/*     */     SegmentInfo info;
/*     */     boolean mergeDocStores;
/*     */     boolean optimize;
/*     */     SegmentInfos segmentsClone;
/*     */     boolean increfDone;
/*     */     boolean registerDone;
/*     */     long mergeGen;
/*     */     boolean isExternal;
/*     */     int maxNumSegmentsOptimize;
/*     */     final SegmentInfos segments;
/*     */     final boolean useCompoundFile;
/*     */     boolean aborted;
/*     */     Throwable error;
/*     */     
/*     */     public OneMerge(SegmentInfos segments, boolean useCompoundFile) {
/*  83 */       if (0 == segments.size())
/*  84 */         throw new RuntimeException(""segments must include at least one segment""); 
/*  85 */       this.segments = segments;
/*  86 */       this.useCompoundFile = useCompoundFile;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  92 */     synchronized void setException(Throwable error) { this.error = error; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  98 */     synchronized Throwable getException() { return this.error; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 105 */     synchronized void abort() { this.aborted = true; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 110 */     synchronized boolean isAborted() { return this.aborted; }
/*     */ 
/*     */     
/*     */     synchronized void checkAborted(Directory dir) throws MergePolicy.MergeAbortedException {
/* 114 */       if (this.aborted)
/* 115 */         throw new MergePolicy.MergeAbortedException(""merge is aborted: "" + segString(dir)); 
/*     */     }
/*     */     
/*     */     String segString(Directory dir) {
/* 119 */       StringBuffer b = new StringBuffer();
/* 120 */       int numSegments = this.segments.size();
/* 121 */       for (int i = 0; i < numSegments; i++) {
/* 122 */         if (i > 0) b.append(' '); 
/* 123 */         b.append(this.segments.info(i).segString(dir));
/*     */       } 
/* 125 */       if (this.info != null)
/* 126 */         b.append("" into "").append(this.info.name); 
/* 127 */       if (this.optimize)
/* 128 */         b.append("" [optimize]""); 
/* 129 */       return b.toString();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static class MergeSpecification
/*     */   {
/* 145 */     public List merges = new ArrayList();
/*     */ 
/*     */     
/* 148 */     public void add(MergePolicy.OneMerge merge) { this.merges.add(merge); }
/*     */ 
/*     */     
/*     */     public String segString(Directory dir) {
/* 152 */       StringBuffer b = new StringBuffer();
/* 153 */       b.append(""MergeSpec:\n"");
/* 154 */       int count = this.merges.size();
/* 155 */       for (int i = 0; i < count; i++)
/* 156 */         b.append(""  "").append(1 + i).append("": "").append(((MergePolicy.OneMerge)this.merges.get(i)).segString(dir)); 
/* 157 */       return b.toString();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public static class MergeException
/*     */     extends RuntimeException
/*     */   {
/*     */     private Directory dir;
/*     */ 
/*     */     
/* 168 */     public MergeException(String message) { super(message); }
/*     */     
/*     */     public MergeException(String message, Directory dir) {
/* 171 */       super(message);
/* 172 */       this.dir = dir;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 177 */     public MergeException(Throwable exc) { super(exc); }
/*     */     
/*     */     public MergeException(Throwable exc, Directory dir) {
/* 180 */       super(exc);
/* 181 */       this.dir = dir;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 186 */     public Directory getDirectory() { return this.dir; }
/*     */   }
/*     */   
/*     */   public static class MergeAbortedException
/*     */     extends IOException
/*     */   {
/* 192 */     public MergeAbortedException() { super(""merge is aborted""); }
/*     */ 
/*     */     
/* 195 */     public MergeAbortedException(String message) { super(message); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 244 */   MergeSpecification findMergesToExpungeDeletes(SegmentInfos segmentInfos, IndexWriter writer) throws CorruptIndexException, IOException { throw new RuntimeException(""not implemented""); }
/*     */   
/*     */   abstract void close();
/*     */   
/*     */   abstract boolean useCompoundFile(SegmentInfos paramSegmentInfos, SegmentInfo paramSegmentInfo);
/*     */   
/*     */   abstract boolean useCompoundDocStore(SegmentInfos paramSegmentInfos);
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MergePolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MergeScheduler,"package org.apache.lucene.index;
import java.io.IOException;
public abstract class MergeScheduler {
  abstract void merge(IndexWriter paramIndexWriter) throws CorruptIndexException, IOException;
  abstract void close() throws CorruptIndexException, IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MergeScheduler.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiLevelSkipListReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.store.BufferedIndexInput;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class MultiLevelSkipListReader
/*     */ {
/*     */   private int maxNumberOfSkipLevels;
/*     */   private int numberOfSkipLevels;
/*  49 */   private int numberOfLevelsToBuffer = 1;
/*     */   
/*     */   private int docCount;
/*     */   
/*     */   private boolean haveSkipped;
/*     */   
/*     */   private IndexInput[] skipStream;
/*     */   
/*     */   private long[] skipPointer;
/*     */   private int[] skipInterval;
/*     */   private int[] numSkipped;
/*     */   private int[] skipDoc;
/*     */   private int lastDoc;
/*     */   private long[] childPointer;
/*     */   private long lastChildPointer;
/*     */   private boolean inputIsBuffered;
/*     */   
/*     */   public MultiLevelSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval) {
/*  67 */     this.skipStream = new IndexInput[maxSkipLevels];
/*  68 */     this.skipPointer = new long[maxSkipLevels];
/*  69 */     this.childPointer = new long[maxSkipLevels];
/*  70 */     this.numSkipped = new int[maxSkipLevels];
/*  71 */     this.maxNumberOfSkipLevels = maxSkipLevels;
/*  72 */     this.skipInterval = new int[maxSkipLevels];
/*  73 */     this.skipStream[0] = skipStream;
/*  74 */     this.inputIsBuffered = skipStream instanceof BufferedIndexInput;
/*  75 */     this.skipInterval[0] = skipInterval;
/*  76 */     for (int i = 1; i < maxSkipLevels; i++)
/*     */     {
/*  78 */       this.skipInterval[i] = this.skipInterval[i - 1] * skipInterval;
/*     */     }
/*  80 */     this.skipDoc = new int[maxSkipLevels];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   int getDoc() { return this.lastDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   int skipTo(int target) throws IOException {
/*  95 */     if (!this.haveSkipped) {
/*     */       
/*  97 */       loadSkipLevels();
/*  98 */       this.haveSkipped = true;
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 103 */     int level = 0;
/* 104 */     while (level < this.numberOfSkipLevels - 1 && target > this.skipDoc[level + 1]) {
/* 105 */       level++;
/*     */     }
/*     */     
/* 108 */     while (level >= 0) {
/* 109 */       if (target > this.skipDoc[level]) {
/* 110 */         if (!loadNextSkip(level));
/*     */         
/*     */         continue;
/*     */       } 
/*     */       
/* 115 */       if (level > 0 && this.lastChildPointer > this.skipStream[level - 1].getFilePointer()) {
/* 116 */         seekChild(level - 1);
/*     */       }
/* 118 */       level--;
/*     */     } 
/*     */ 
/*     */     
/* 122 */     return this.numSkipped[0] - this.skipInterval[0] - 1;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean loadNextSkip(int level) throws IOException {
/* 128 */     setLastSkipData(level);
/*     */     
/* 130 */     this.numSkipped[level] = this.numSkipped[level] + this.skipInterval[level];
/*     */     
/* 132 */     if (this.numSkipped[level] > this.docCount) {
/*     */       
/* 134 */       this.skipDoc[level] = Integer.MAX_VALUE;
/* 135 */       if (this.numberOfSkipLevels > level) this.numberOfSkipLevels = level; 
/* 136 */       return false;
/*     */     } 
/*     */ 
/*     */     
/* 140 */     this.skipDoc[level] = this.skipDoc[level] + readSkipData(level, this.skipStream[level]);
/*     */     
/* 142 */     if (level != 0)
/*     */     {
/* 144 */       this.childPointer[level] = this.skipStream[level].readVLong() + this.skipPointer[level - 1];
/*     */     }
/*     */     
/* 147 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   protected void seekChild(int level) throws IOException {
/* 153 */     this.skipStream[level].seek(this.lastChildPointer);
/* 154 */     this.numSkipped[level] = this.numSkipped[level + 1] - this.skipInterval[level + 1];
/* 155 */     this.skipDoc[level] = this.lastDoc;
/* 156 */     if (level > 0) {
/* 157 */       this.childPointer[level] = this.skipStream[level].readVLong() + this.skipPointer[level - 1];
/*     */     }
/*     */   }
/*     */   
/*     */   void close() throws IOException {
/* 162 */     for (int i = 1; i < this.skipStream.length; i++) {
/* 163 */       if (this.skipStream[i] != null) {
/* 164 */         this.skipStream[i].close();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   void init(long skipPointer, int df) {
/* 171 */     this.skipPointer[0] = skipPointer;
/* 172 */     this.docCount = df;
/* 173 */     Arrays.fill(this.skipDoc, 0);
/* 174 */     Arrays.fill(this.numSkipped, 0);
/* 175 */     Arrays.fill(this.childPointer, 0L);
/*     */     
/* 177 */     this.haveSkipped = false;
/* 178 */     for (int i = 1; i < this.numberOfSkipLevels; i++) {
/* 179 */       this.skipStream[i] = null;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private void loadSkipLevels() throws IOException {
/* 185 */     this.numberOfSkipLevels = (this.docCount == 0) ? 0 : (int)Math.floor(Math.log(this.docCount) / Math.log(this.skipInterval[0]));
/* 186 */     if (this.numberOfSkipLevels > this.maxNumberOfSkipLevels) {
/* 187 */       this.numberOfSkipLevels = this.maxNumberOfSkipLevels;
/*     */     }
/*     */     
/* 190 */     this.skipStream[0].seek(this.skipPointer[0]);
/*     */     
/* 192 */     int toBuffer = this.numberOfLevelsToBuffer;
/*     */     
/* 194 */     for (int i = this.numberOfSkipLevels - 1; i > 0; i--) {
/*     */       
/* 196 */       long length = this.skipStream[0].readVLong();
/*     */ 
/*     */       
/* 199 */       this.skipPointer[i] = this.skipStream[0].getFilePointer();
/* 200 */       if (toBuffer > 0) {
/*     */         
/* 202 */         this.skipStream[i] = new SkipBuffer(this.skipStream[0], (int)length);
/* 203 */         toBuffer--;
/*     */       } else {
/*     */         
/* 206 */         this.skipStream[i] = (IndexInput)this.skipStream[0].clone();
/* 207 */         if (this.inputIsBuffered && length < 1024L) {
/* 208 */           ((BufferedIndexInput)this.skipStream[i]).setBufferSize((int)length);
/*     */         }
/*     */ 
/*     */         
/* 212 */         this.skipStream[0].seek(this.skipStream[0].getFilePointer() + length);
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 217 */     this.skipPointer[0] = this.skipStream[0].getFilePointer();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract int readSkipData(int paramInt, IndexInput paramIndexInput) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void setLastSkipData(int level) {
/* 230 */     this.lastDoc = this.skipDoc[level];
/* 231 */     this.lastChildPointer = this.childPointer[level];
/*     */   }
/*     */   
/*     */   private static final class SkipBuffer
/*     */     extends IndexInput
/*     */   {
/*     */     private byte[] data;
/*     */     private long pointer;
/*     */     private int pos;
/*     */     
/*     */     SkipBuffer(IndexInput input, int length) throws IOException {
/* 242 */       this.data = new byte[length];
/* 243 */       this.pointer = input.getFilePointer();
/* 244 */       input.readBytes(this.data, 0, length);
/*     */     }
/*     */ 
/*     */     
/* 248 */     public void close() throws IOException { this.data = null; }
/*     */ 
/*     */ 
/*     */     
/* 252 */     public long getFilePointer() { return this.pointer + this.pos; }
/*     */ 
/*     */ 
/*     */     
/* 256 */     public long length() { return this.data.length; }
/*     */ 
/*     */ 
/*     */     
/* 260 */     public byte readByte() throws IOException { return this.data[this.pos++]; }
/*     */ 
/*     */     
/*     */     public void readBytes(byte[] b, int offset, int len) throws IOException {
/* 264 */       System.arraycopy(this.data, this.pos, b, offset, len);
/* 265 */       this.pos += len;
/*     */     }
/*     */ 
/*     */     
/* 269 */     public void seek(long pos) throws IOException { this.pos = (int)(pos - this.pointer); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MultiLevelSkipListReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiLevelSkipListWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.RAMOutputStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class MultiLevelSkipListWriter
/*     */ {
/*     */   private int numberOfSkipLevels;
/*     */   private int skipInterval;
/*     */   private RAMOutputStream[] skipBuffer;
/*     */   
/*     */   protected MultiLevelSkipListWriter(int skipInterval, int maxSkipLevels, int df) {
/*  60 */     this.skipInterval = skipInterval;
/*     */ 
/*     */     
/*  63 */     this.numberOfSkipLevels = (df == 0) ? 0 : (int)Math.floor(Math.log(df) / Math.log(skipInterval));
/*     */ 
/*     */     
/*  66 */     if (this.numberOfSkipLevels > maxSkipLevels) {
/*  67 */       this.numberOfSkipLevels = maxSkipLevels;
/*     */     }
/*     */   }
/*     */   
/*     */   protected void init() {
/*  72 */     this.skipBuffer = new RAMOutputStream[this.numberOfSkipLevels];
/*  73 */     for (int i = 0; i < this.numberOfSkipLevels; i++) {
/*  74 */       this.skipBuffer[i] = new RAMOutputStream();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   protected void resetSkip() {
/*  80 */     if (this.skipBuffer == null) {
/*  81 */       init();
/*     */     } else {
/*  83 */       for (int i = 0; i < this.skipBuffer.length; i++) {
/*  84 */         this.skipBuffer[i].reset();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void writeSkipData(int paramInt, IndexOutput paramIndexOutput) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void bufferSkip(int df) throws IOException {
/*     */     int numLevels;
/* 108 */     for (numLevels = 0; df % this.skipInterval == 0 && numLevels < this.numberOfSkipLevels; df /= this.skipInterval) {
/* 109 */       numLevels++;
/*     */     }
/*     */     
/* 112 */     long childPointer = 0L;
/*     */     
/* 114 */     for (int level = 0; level < numLevels; level++) {
/* 115 */       writeSkipData(level, (IndexOutput)this.skipBuffer[level]);
/*     */       
/* 117 */       long newChildPointer = this.skipBuffer[level].getFilePointer();
/*     */       
/* 119 */       if (level != 0)
/*     */       {
/* 121 */         this.skipBuffer[level].writeVLong(childPointer);
/*     */       }
/*     */ 
/*     */       
/* 125 */       childPointer = newChildPointer;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   long writeSkip(IndexOutput output) throws IOException {
/* 136 */     long skipPointer = output.getFilePointer();
/* 137 */     if (this.skipBuffer == null || this.skipBuffer.length == 0) return skipPointer;
/*     */     
/* 139 */     for (int level = this.numberOfSkipLevels - 1; level > 0; level--) {
/* 140 */       long length = this.skipBuffer[level].getFilePointer();
/* 141 */       if (length > 0L) {
/* 142 */         output.writeVLong(length);
/* 143 */         this.skipBuffer[level].writeTo(output);
/*     */       } 
/*     */     } 
/* 146 */     this.skipBuffer[0].writeTo(output);
/*     */     
/* 148 */     return skipPointer;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MultiLevelSkipListWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultipleTermPositions,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultipleTermPositions
/*     */   implements TermPositions
/*     */ {
/*     */   private int _doc;
/*     */   private int _freq;
/*     */   private TermPositionsQueue _termPositionsQueue;
/*     */   private IntQueue _posList;
/*     */   
/*     */   private static final class TermPositionsQueue
/*     */     extends PriorityQueue
/*     */   {
/*     */     TermPositionsQueue(List termPositions) throws IOException {
/*  37 */       initialize(termPositions.size());
/*     */       
/*  39 */       Iterator i = termPositions.iterator();
/*  40 */       while (i.hasNext()) {
/*  41 */         TermPositions tp = i.next();
/*  42 */         if (tp.next()) {
/*  43 */           put(tp);
/*     */         }
/*     */       } 
/*     */     }
/*     */     
/*  48 */     final TermPositions peek() { return (TermPositions)top(); }
/*     */ 
/*     */ 
/*     */     
/*  52 */     public final boolean lessThan(Object a, Object b) { return (((TermPositions)a).doc() < ((TermPositions)b).doc()); }
/*     */   }
/*     */   
/*     */   private static final class IntQueue
/*     */   {
/*  57 */     private int _arraySize = 16;
/*  58 */     private int _index = 0;
/*  59 */     private int _lastIndex = 0;
/*  60 */     private int[] _array = new int[this._arraySize];
/*     */     
/*     */     final void add(int i) {
/*  63 */       if (this._lastIndex == this._arraySize) {
/*  64 */         growArray();
/*     */       }
/*  66 */       this._array[this._lastIndex++] = i;
/*     */     }
/*     */ 
/*     */     
/*  70 */     final int next() { return this._array[this._index++]; }
/*     */ 
/*     */ 
/*     */     
/*  74 */     final void sort() { Arrays.sort(this._array, this._index, this._lastIndex); }
/*     */ 
/*     */     
/*     */     final void clear() {
/*  78 */       this._index = 0;
/*  79 */       this._lastIndex = 0;
/*     */     }
/*     */ 
/*     */     
/*  83 */     final int size() { return this._lastIndex - this._index; }
/*     */ 
/*     */     
/*     */     private void growArray() {
/*  87 */       int[] newArray = new int[this._arraySize * 2];
/*  88 */       System.arraycopy(this._array, 0, newArray, 0, this._arraySize);
/*  89 */       this._array = newArray;
/*  90 */       this._arraySize *= 2;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     private IntQueue() {}
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultipleTermPositions(IndexReader indexReader, Term[] terms) throws IOException {
/* 105 */     List termPositions = new LinkedList();
/*     */     
/* 107 */     for (int i = 0; i < terms.length; i++) {
/* 108 */       termPositions.add(indexReader.termPositions(terms[i]));
/*     */     }
/* 110 */     this._termPositionsQueue = new TermPositionsQueue(termPositions);
/* 111 */     this._posList = new IntQueue();
/*     */   }
/*     */   
/*     */   public final boolean next() throws IOException {
/* 115 */     if (this._termPositionsQueue.size() == 0) {
/* 116 */       return false;
/*     */     }
/* 118 */     this._posList.clear();
/* 119 */     this._doc = this._termPositionsQueue.peek().doc();
/*     */ 
/*     */     
/*     */     do {
/* 123 */       TermPositions tp = this._termPositionsQueue.peek();
/*     */       
/* 125 */       for (int i = 0; i < tp.freq(); i++) {
/* 126 */         this._posList.add(tp.nextPosition());
/*     */       }
/* 128 */       if (tp.next()) {
/* 129 */         this._termPositionsQueue.adjustTop();
/*     */       } else {
/* 131 */         this._termPositionsQueue.pop();
/* 132 */         tp.close();
/*     */       } 
/* 134 */     } while (this._termPositionsQueue.size() > 0 && this._termPositionsQueue.peek().doc() == this._doc);
/*     */     
/* 136 */     this._posList.sort();
/* 137 */     this._freq = this._posList.size();
/*     */     
/* 139 */     return true;
/*     */   }
/*     */ 
/*     */   
/* 143 */   public final int nextPosition() { return this._posList.next(); }
/*     */ 
/*     */   
/*     */   public final boolean skipTo(int target) throws IOException {
/* 147 */     while (this._termPositionsQueue.peek() != null && target > this._termPositionsQueue.peek().doc()) {
/* 148 */       TermPositions tp = (TermPositions)this._termPositionsQueue.pop();
/* 149 */       if (tp.skipTo(target)) {
/* 150 */         this._termPositionsQueue.put(tp); continue;
/*     */       } 
/* 152 */       tp.close();
/*     */     } 
/* 154 */     return next();
/*     */   }
/*     */ 
/*     */   
/* 158 */   public final int doc() { return this._doc; }
/*     */ 
/*     */ 
/*     */   
/* 162 */   public final int freq() { return this._freq; }
/*     */ 
/*     */   
/*     */   public final void close() throws IOException {
/* 166 */     while (this._termPositionsQueue.size() > 0) {
/* 167 */       ((TermPositions)this._termPositionsQueue.pop()).close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 175 */   public void seek(Term arg0) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 183 */   public void seek(TermEnum termEnum) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 191 */   public int read(int[] arg0, int[] arg1) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 200 */   public int getPayloadLength() { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 208 */   public byte[] getPayload(byte[] data, int offset) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 217 */   public boolean isPayloadAvailable() { return false; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MultipleTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiReader
/*     */   extends IndexReader
/*     */ {
/*     */   protected IndexReader[] subReaders;
/*     */   private int[] starts;
/*     */   private boolean[] decrefOnClose;
/*  40 */   private Map normsCache = new HashMap();
/*  41 */   private int maxDoc = 0;
/*  42 */   private int numDocs = -1;
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean hasDeletions = false;
/*     */ 
/*     */ 
/*     */   
/*     */   private byte[] ones;
/*     */ 
/*     */ 
/*     */   
/*  54 */   public MultiReader(IndexReader[] subReaders) { initialize(subReaders, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  67 */   public MultiReader(IndexReader[] subReaders, boolean closeSubReaders) { initialize(subReaders, closeSubReaders); }
/*     */ 
/*     */   
/*     */   private void initialize(IndexReader[] subReaders, boolean closeSubReaders) {
/*  71 */     this.subReaders = (IndexReader[])subReaders.clone();
/*  72 */     this.starts = new int[subReaders.length + 1];
/*  73 */     this.decrefOnClose = new boolean[subReaders.length];
/*  74 */     for (int i = 0; i < subReaders.length; i++) {
/*  75 */       this.starts[i] = this.maxDoc;
/*  76 */       this.maxDoc += subReaders[i].maxDoc();
/*     */       
/*  78 */       if (!closeSubReaders) {
/*  79 */         subReaders[i].incRef();
/*  80 */         this.decrefOnClose[i] = true;
/*     */       } else {
/*  82 */         this.decrefOnClose[i] = false;
/*     */       } 
/*     */       
/*  85 */       if (subReaders[i].hasDeletions())
/*  86 */         this.hasDeletions = true; 
/*     */     } 
/*  88 */     this.starts[subReaders.length] = this.maxDoc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexReader reopen() throws CorruptIndexException, IOException {
/* 111 */     ensureOpen();
/*     */     
/* 113 */     boolean reopened = false;
/* 114 */     IndexReader[] newSubReaders = new IndexReader[this.subReaders.length];
/* 115 */     boolean[] newDecrefOnClose = new boolean[this.subReaders.length];
/*     */     
/* 117 */     boolean success = false;
/*     */     try {
/* 119 */       for (int i = 0; i < this.subReaders.length; i++) {
/* 120 */         newSubReaders[i] = this.subReaders[i].reopen();
/*     */ 
/*     */         
/* 123 */         if (newSubReaders[i] != this.subReaders[i]) {
/* 124 */           reopened = true;
/*     */ 
/*     */           
/* 127 */           newDecrefOnClose[i] = false;
/*     */         } 
/*     */       } 
/*     */       
/* 131 */       if (reopened) {
/* 132 */         for (int i = 0; i < this.subReaders.length; i++) {
/* 133 */           if (newSubReaders[i] == this.subReaders[i]) {
/* 134 */             newSubReaders[i].incRef();
/* 135 */             newDecrefOnClose[i] = true;
/*     */           } 
/*     */         } 
/*     */         
/* 139 */         MultiReader mr = new MultiReader(newSubReaders);
/* 140 */         mr.decrefOnClose = newDecrefOnClose;
/* 141 */         success = true;
/* 142 */         return mr;
/*     */       } 
/* 144 */       success = true;
/* 145 */       return this;
/*     */     } finally {
/*     */       
/* 148 */       if (!success && reopened) {
/* 149 */         for (int i = 0; i < newSubReaders.length; i++) {
/* 150 */           if (newSubReaders[i] != null) {
/*     */             try {
/* 152 */               if (newDecrefOnClose[i]) {
/* 153 */                 newSubReaders[i].decRef();
/*     */               } else {
/* 155 */                 newSubReaders[i].close();
/*     */               } 
/* 157 */             } catch (IOException ignore) {}
/*     */           }
/*     */         } 
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int n) throws IOException {
/* 167 */     ensureOpen();
/* 168 */     int i = readerIndex(n);
/* 169 */     return this.subReaders[i].getTermFreqVectors(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int n, String field) throws IOException {
/* 174 */     ensureOpen();
/* 175 */     int i = readerIndex(n);
/* 176 */     return this.subReaders[i].getTermFreqVector(n - this.starts[i], field);
/*     */   }
/*     */ 
/*     */   
/*     */   public void getTermFreqVector(int docNumber, String field, TermVectorMapper mapper) throws IOException {
/* 181 */     ensureOpen();
/* 182 */     int i = readerIndex(docNumber);
/* 183 */     this.subReaders[i].getTermFreqVector(docNumber - this.starts[i], field, mapper);
/*     */   }
/*     */   
/*     */   public void getTermFreqVector(int docNumber, TermVectorMapper mapper) throws IOException {
/* 187 */     ensureOpen();
/* 188 */     int i = readerIndex(docNumber);
/* 189 */     this.subReaders[i].getTermFreqVector(docNumber - this.starts[i], mapper);
/*     */   }
/*     */ 
/*     */   
/* 193 */   public boolean isOptimized() { return false; }
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized int numDocs() {
/* 198 */     if (this.numDocs == -1) {
/* 199 */       int n = 0;
/* 200 */       for (int i = 0; i < this.subReaders.length; i++)
/* 201 */         n += this.subReaders[i].numDocs(); 
/* 202 */       this.numDocs = n;
/*     */     } 
/* 204 */     return this.numDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 209 */   public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 214 */     ensureOpen();
/* 215 */     int i = readerIndex(n);
/* 216 */     return this.subReaders[i].document(n - this.starts[i], fieldSelector);
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean isDeleted(int n) {
/* 221 */     int i = readerIndex(n);
/* 222 */     return this.subReaders[i].isDeleted(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 227 */   public boolean hasDeletions() { return this.hasDeletions; }
/*     */ 
/*     */   
/*     */   protected void doDelete(int n) throws CorruptIndexException, IOException {
/* 231 */     this.numDocs = -1;
/* 232 */     int i = readerIndex(n);
/* 233 */     this.subReaders[i].deleteDocument(n - this.starts[i]);
/* 234 */     this.hasDeletions = true;
/*     */   }
/*     */   
/*     */   protected void doUndeleteAll() throws CorruptIndexException, IOException {
/* 238 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 239 */       this.subReaders[i].undeleteAll();
/*     */     }
/* 241 */     this.hasDeletions = false;
/* 242 */     this.numDocs = -1;
/*     */   }
/*     */ 
/*     */   
/* 246 */   private int readerIndex(int n) { return MultiSegmentReader.readerIndex(n, this.starts, this.subReaders.length); }
/*     */ 
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 250 */     ensureOpen();
/* 251 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 252 */       if (this.subReaders[i].hasNorms(field)) return true; 
/*     */     } 
/* 254 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   private byte[] fakeNorms() {
/* 259 */     if (this.ones == null) this.ones = SegmentReader.createFakeNorms(maxDoc()); 
/* 260 */     return this.ones;
/*     */   }
/*     */   
/*     */   public synchronized byte[] norms(String field) throws IOException {
/* 264 */     ensureOpen();
/* 265 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 266 */     if (bytes != null)
/* 267 */       return bytes; 
/* 268 */     if (!hasNorms(field)) {
/* 269 */       return fakeNorms();
/*     */     }
/* 271 */     bytes = new byte[maxDoc()];
/* 272 */     for (int i = 0; i < this.subReaders.length; i++)
/* 273 */       this.subReaders[i].norms(field, bytes, this.starts[i]); 
/* 274 */     this.normsCache.put(field, bytes);
/* 275 */     return bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void norms(String field, byte[] result, int offset) throws IOException {
/* 280 */     ensureOpen();
/* 281 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 282 */     if (bytes == null && !hasNorms(field)) bytes = fakeNorms(); 
/* 283 */     if (bytes != null) {
/* 284 */       System.arraycopy(bytes, 0, result, offset, maxDoc());
/*     */     }
/* 286 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 287 */       this.subReaders[i].norms(field, result, offset + this.starts[i]);
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doSetNorm(int n, String field, byte value) throws CorruptIndexException, IOException {
/* 292 */     synchronized (this.normsCache) {
/* 293 */       this.normsCache.remove(field);
/*     */     } 
/* 295 */     int i = readerIndex(n);
/* 296 */     this.subReaders[i].setNorm(n - this.starts[i], field, value);
/*     */   }
/*     */   
/*     */   public TermEnum terms() throws IOException {
/* 300 */     ensureOpen();
/* 301 */     return new MultiSegmentReader.MultiTermEnum(this.subReaders, this.starts, null);
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term term) throws IOException {
/* 305 */     ensureOpen();
/* 306 */     return new MultiSegmentReader.MultiTermEnum(this.subReaders, this.starts, term);
/*     */   }
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 310 */     ensureOpen();
/* 311 */     int total = 0;
/* 312 */     for (int i = 0; i < this.subReaders.length; i++)
/* 313 */       total += this.subReaders[i].docFreq(t); 
/* 314 */     return total;
/*     */   }
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 318 */     ensureOpen();
/* 319 */     return new MultiSegmentReader.MultiTermDocs(this.subReaders, this.starts);
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 323 */     ensureOpen();
/* 324 */     return new MultiSegmentReader.MultiTermPositions(this.subReaders, this.starts);
/*     */   }
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 328 */     for (int i = 0; i < this.subReaders.length; i++)
/* 329 */       this.subReaders[i].commit(); 
/*     */   }
/*     */   
/*     */   protected synchronized void doClose() throws IOException {
/* 333 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 334 */       if (this.decrefOnClose[i]) {
/* 335 */         this.subReaders[i].decRef();
/*     */       } else {
/* 337 */         this.subReaders[i].close();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 343 */     ensureOpen();
/* 344 */     return MultiSegmentReader.getFieldNames(fieldNames, this.subReaders);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isCurrent() throws CorruptIndexException, IOException {
/* 351 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 352 */       if (!this.subReaders[i].isCurrent()) {
/* 353 */         return false;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 358 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 365 */   public long getVersion() { throw new UnsupportedOperationException(""MultiReader does not support this method.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 370 */   IndexReader[] getSubReaders() { return this.subReaders; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MultiReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiSegmentReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiSegmentReader
/*     */   extends DirectoryIndexReader
/*     */ {
/*     */   protected SegmentReader[] subReaders;
/*     */   private int[] starts;
/*  39 */   private Map normsCache = new HashMap();
/*  40 */   private int maxDoc = 0;
/*  41 */   private int numDocs = -1;
/*     */   private boolean hasDeletions = false;
/*     */   private byte[] ones;
/*     */   
/*     */   MultiSegmentReader(Directory directory, SegmentInfos sis, boolean closeDirectory, boolean readOnly) throws IOException {
/*  46 */     super(directory, sis, closeDirectory, readOnly);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  53 */     SegmentReader[] readers = new SegmentReader[sis.size()];
/*  54 */     for (int i = sis.size() - 1; i >= 0; i--) {
/*     */       try {
/*  56 */         readers[i] = SegmentReader.get(readOnly, sis.info(i));
/*  57 */       } catch (IOException e) {
/*     */         
/*  59 */         for (; ++i < sis.size(); i++) {
/*     */           try {
/*  61 */             readers[i].close();
/*  62 */           } catch (IOException ignore) {}
/*     */         } 
/*     */ 
/*     */         
/*  66 */         throw e;
/*     */       } 
/*     */     } 
/*     */     
/*  70 */     initialize(readers);
/*     */   }
/*     */ 
/*     */   
/*     */   MultiSegmentReader(Directory directory, SegmentInfos infos, boolean closeDirectory, SegmentReader[] oldReaders, int[] oldStarts, Map oldNormsCache, boolean readOnly) throws IOException {
/*  75 */     super(directory, infos, closeDirectory, readOnly);
/*     */ 
/*     */ 
/*     */     
/*  79 */     Map segmentReaders = new HashMap();
/*     */     
/*  81 */     if (oldReaders != null)
/*     */     {
/*  83 */       for (int i = 0; i < oldReaders.length; i++) {
/*  84 */         segmentReaders.put(oldReaders[i].getSegmentName(), new Integer(i));
/*     */       }
/*     */     }
/*     */     
/*  88 */     SegmentReader[] newReaders = new SegmentReader[infos.size()];
/*     */ 
/*     */ 
/*     */     
/*  92 */     boolean[] readerShared = new boolean[infos.size()];
/*     */     
/*  94 */     for (int i = infos.size() - 1; i >= 0; i--) {
/*     */       
/*  96 */       Integer oldReaderIndex = (Integer)segmentReaders.get((infos.info(i)).name);
/*  97 */       if (oldReaderIndex == null) {
/*     */         
/*  99 */         newReaders[i] = null;
/*     */       } else {
/*     */         
/* 102 */         newReaders[i] = oldReaders[oldReaderIndex.intValue()];
/*     */       } 
/*     */       
/* 105 */       boolean success = false;
/*     */       try {
/*     */         SegmentReader newReader;
/* 108 */         if (newReaders[i] == null || infos.info(i).getUseCompoundFile() != newReaders[i].getSegmentInfo().getUseCompoundFile()) {
/*     */           
/* 110 */           newReader = SegmentReader.get(readOnly, infos.info(i));
/*     */         } else {
/* 112 */           newReader = newReaders[i].reopenSegment(infos.info(i));
/*     */         } 
/* 114 */         if (newReader == newReaders[i]) {
/*     */ 
/*     */           
/* 117 */           readerShared[i] = true;
/* 118 */           newReader.incRef();
/*     */         } else {
/* 120 */           readerShared[i] = false;
/* 121 */           newReaders[i] = newReader;
/*     */         } 
/* 123 */         success = true;
/*     */       } finally {
/* 125 */         if (!success) {
/* 126 */           for (; ++i < infos.size(); i++) {
/* 127 */             if (newReaders[i] != null) {
/*     */               try {
/* 129 */                 if (!readerShared[i]) {
/*     */ 
/*     */                   
/* 132 */                   newReaders[i].close();
/*     */                 }
/*     */                 else {
/*     */                   
/* 136 */                   newReaders[i].decRef();
/*     */                 } 
/* 138 */               } catch (IOException ignore) {}
/*     */             }
/*     */           } 
/*     */         }
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 148 */     initialize(newReaders);
/*     */ 
/*     */     
/* 151 */     if (oldNormsCache != null) {
/* 152 */       Iterator it = oldNormsCache.entrySet().iterator();
/* 153 */       while (it.hasNext()) {
/* 154 */         Map.Entry entry = it.next();
/* 155 */         String field = (String)entry.getKey();
/* 156 */         if (!hasNorms(field)) {
/*     */           continue;
/*     */         }
/*     */         
/* 160 */         byte[] oldBytes = (byte[])entry.getValue();
/*     */         
/* 162 */         byte[] bytes = new byte[maxDoc()];
/*     */         
/* 164 */         for (int i = 0; i < this.subReaders.length; i++) {
/* 165 */           Integer oldReaderIndex = (Integer)segmentReaders.get(this.subReaders[i].getSegmentName());
/*     */ 
/*     */           
/* 168 */           if (oldReaderIndex != null && (oldReaders[oldReaderIndex.intValue()] == this.subReaders[i] || (oldReaders[oldReaderIndex.intValue()]).norms.get(field) == (this.subReaders[i]).norms.get(field))) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 174 */             System.arraycopy(oldBytes, oldStarts[oldReaderIndex.intValue()], bytes, this.starts[i], this.starts[i + 1] - this.starts[i]);
/*     */           } else {
/* 176 */             this.subReaders[i].norms(field, bytes, this.starts[i]);
/*     */           } 
/*     */         } 
/*     */         
/* 180 */         this.normsCache.put(field, bytes);
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void initialize(SegmentReader[] subReaders) {
/* 186 */     this.subReaders = subReaders;
/* 187 */     this.starts = new int[subReaders.length + 1];
/* 188 */     for (int i = 0; i < subReaders.length; i++) {
/* 189 */       this.starts[i] = this.maxDoc;
/* 190 */       this.maxDoc += subReaders[i].maxDoc();
/*     */       
/* 192 */       if (subReaders[i].hasDeletions())
/* 193 */         this.hasDeletions = true; 
/*     */     } 
/* 195 */     this.starts[subReaders.length] = this.maxDoc;
/*     */   }
/*     */   
/*     */   protected synchronized DirectoryIndexReader doReopen(SegmentInfos infos) throws CorruptIndexException, IOException {
/* 199 */     if (infos.size() == 1)
/*     */     {
/*     */       
/* 202 */       return SegmentReader.get(this.readOnly, infos, infos.info(0), false); } 
/* 203 */     if (this.readOnly) {
/* 204 */       return new ReadOnlyMultiSegmentReader(this.directory, infos, this.closeDirectory, this.subReaders, this.starts, this.normsCache);
/*     */     }
/* 206 */     return new MultiSegmentReader(this.directory, infos, this.closeDirectory, this.subReaders, this.starts, this.normsCache, false);
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int n) throws IOException {
/* 211 */     ensureOpen();
/* 212 */     int i = readerIndex(n);
/* 213 */     return this.subReaders[i].getTermFreqVectors(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int n, String field) throws IOException {
/* 218 */     ensureOpen();
/* 219 */     int i = readerIndex(n);
/* 220 */     return this.subReaders[i].getTermFreqVector(n - this.starts[i], field);
/*     */   }
/*     */ 
/*     */   
/*     */   public void getTermFreqVector(int docNumber, String field, TermVectorMapper mapper) throws IOException {
/* 225 */     ensureOpen();
/* 226 */     int i = readerIndex(docNumber);
/* 227 */     this.subReaders[i].getTermFreqVector(docNumber - this.starts[i], field, mapper);
/*     */   }
/*     */   
/*     */   public void getTermFreqVector(int docNumber, TermVectorMapper mapper) throws IOException {
/* 231 */     ensureOpen();
/* 232 */     int i = readerIndex(docNumber);
/* 233 */     this.subReaders[i].getTermFreqVector(docNumber - this.starts[i], mapper);
/*     */   }
/*     */ 
/*     */   
/* 237 */   public boolean isOptimized() { return false; }
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized int numDocs() {
/* 242 */     if (this.numDocs == -1) {
/* 243 */       int n = 0;
/* 244 */       for (int i = 0; i < this.subReaders.length; i++)
/* 245 */         n += this.subReaders[i].numDocs(); 
/* 246 */       this.numDocs = n;
/*     */     } 
/* 248 */     return this.numDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 253 */   public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 258 */     ensureOpen();
/* 259 */     int i = readerIndex(n);
/* 260 */     return this.subReaders[i].document(n - this.starts[i], fieldSelector);
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean isDeleted(int n) {
/* 265 */     int i = readerIndex(n);
/* 266 */     return this.subReaders[i].isDeleted(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 271 */   public boolean hasDeletions() { return this.hasDeletions; }
/*     */ 
/*     */   
/*     */   protected void doDelete(int n) throws CorruptIndexException, IOException {
/* 275 */     this.numDocs = -1;
/* 276 */     int i = readerIndex(n);
/* 277 */     this.subReaders[i].deleteDocument(n - this.starts[i]);
/* 278 */     this.hasDeletions = true;
/*     */   }
/*     */   
/*     */   protected void doUndeleteAll() throws CorruptIndexException, IOException {
/* 282 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 283 */       this.subReaders[i].undeleteAll();
/*     */     }
/* 285 */     this.hasDeletions = false;
/* 286 */     this.numDocs = -1;
/*     */   }
/*     */ 
/*     */   
/* 290 */   private int readerIndex(int n) { return readerIndex(n, this.starts, this.subReaders.length); }
/*     */ 
/*     */   
/*     */   static final int readerIndex(int n, int[] starts, int numSubReaders) {
/* 294 */     int lo = 0;
/* 295 */     int hi = numSubReaders - 1;
/*     */     
/* 297 */     while (hi >= lo) {
/* 298 */       int mid = lo + hi >> 1;
/* 299 */       int midValue = starts[mid];
/* 300 */       if (n < midValue) {
/* 301 */         hi = mid - 1; continue;
/* 302 */       }  if (n > midValue) {
/* 303 */         lo = mid + 1; continue;
/*     */       } 
/* 305 */       while (mid + 1 < numSubReaders && starts[mid + 1] == midValue) {
/* 306 */         mid++;
/*     */       }
/* 308 */       return mid;
/*     */     } 
/*     */     
/* 311 */     return hi;
/*     */   }
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 315 */     ensureOpen();
/* 316 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 317 */       if (this.subReaders[i].hasNorms(field)) return true; 
/*     */     } 
/* 319 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   private byte[] fakeNorms() {
/* 324 */     if (this.ones == null) this.ones = SegmentReader.createFakeNorms(maxDoc()); 
/* 325 */     return this.ones;
/*     */   }
/*     */   
/*     */   public synchronized byte[] norms(String field) throws IOException {
/* 329 */     ensureOpen();
/* 330 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 331 */     if (bytes != null)
/* 332 */       return bytes; 
/* 333 */     if (!hasNorms(field)) {
/* 334 */       return fakeNorms();
/*     */     }
/* 336 */     bytes = new byte[maxDoc()];
/* 337 */     for (int i = 0; i < this.subReaders.length; i++)
/* 338 */       this.subReaders[i].norms(field, bytes, this.starts[i]); 
/* 339 */     this.normsCache.put(field, bytes);
/* 340 */     return bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void norms(String field, byte[] result, int offset) throws IOException {
/* 345 */     ensureOpen();
/* 346 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 347 */     if (bytes == null && !hasNorms(field)) bytes = fakeNorms(); 
/* 348 */     if (bytes != null) {
/* 349 */       System.arraycopy(bytes, 0, result, offset, maxDoc());
/*     */     }
/* 351 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 352 */       this.subReaders[i].norms(field, result, offset + this.starts[i]);
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doSetNorm(int n, String field, byte value) throws CorruptIndexException, IOException {
/* 357 */     synchronized (this.normsCache) {
/* 358 */       this.normsCache.remove(field);
/*     */     } 
/* 360 */     int i = readerIndex(n);
/* 361 */     this.subReaders[i].setNorm(n - this.starts[i], field, value);
/*     */   }
/*     */   
/*     */   public TermEnum terms() throws IOException {
/* 365 */     ensureOpen();
/* 366 */     return new MultiTermEnum((IndexReader[])this.subReaders, this.starts, null);
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term term) throws IOException {
/* 370 */     ensureOpen();
/* 371 */     return new MultiTermEnum((IndexReader[])this.subReaders, this.starts, term);
/*     */   }
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 375 */     ensureOpen();
/* 376 */     int total = 0;
/* 377 */     for (int i = 0; i < this.subReaders.length; i++)
/* 378 */       total += this.subReaders[i].docFreq(t); 
/* 379 */     return total;
/*     */   }
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 383 */     ensureOpen();
/* 384 */     return new MultiTermDocs((IndexReader[])this.subReaders, this.starts);
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 388 */     ensureOpen();
/* 389 */     return new MultiTermPositions((IndexReader[])this.subReaders, this.starts);
/*     */   }
/*     */   
/*     */   protected void commitChanges() throws IOException {
/* 393 */     for (int i = 0; i < this.subReaders.length; i++)
/* 394 */       this.subReaders[i].commit(); 
/*     */   }
/*     */   
/*     */   void startCommit() {
/* 398 */     super.startCommit();
/* 399 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 400 */       this.subReaders[i].startCommit();
/*     */     }
/*     */   }
/*     */   
/*     */   void rollbackCommit() {
/* 405 */     super.rollbackCommit();
/* 406 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 407 */       this.subReaders[i].rollbackCommit();
/*     */     }
/*     */   }
/*     */   
/*     */   protected synchronized void doClose() throws IOException {
/* 412 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 413 */       this.subReaders[i].decRef();
/*     */     }
/*     */     
/* 416 */     super.doClose();
/*     */   }
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 420 */     ensureOpen();
/* 421 */     return getFieldNames(fieldNames, (IndexReader[])this.subReaders);
/*     */   }
/*     */ 
/*     */   
/*     */   static Collection getFieldNames(IndexReader.FieldOption fieldNames, IndexReader[] subReaders) {
/* 426 */     Set fieldSet = new HashSet();
/* 427 */     for (int i = 0; i < subReaders.length; i++) {
/* 428 */       IndexReader reader = subReaders[i];
/* 429 */       Collection names = reader.getFieldNames(fieldNames);
/* 430 */       fieldSet.addAll(names);
/*     */     } 
/* 432 */     return fieldSet;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 437 */   SegmentReader[] getSubReaders() { return this.subReaders; }
/*     */ 
/*     */   
/*     */   public void setTermInfosIndexDivisor(int indexDivisor) throws IllegalStateException {
/* 441 */     for (int i = 0; i < this.subReaders.length; i++)
/* 442 */       this.subReaders[i].setTermInfosIndexDivisor(indexDivisor); 
/*     */   }
/*     */   
/*     */   public int getTermInfosIndexDivisor() throws IllegalStateException {
/* 446 */     if (this.subReaders.length > 0) {
/* 447 */       return this.subReaders[0].getTermInfosIndexDivisor();
/*     */     }
/* 449 */     throw new IllegalStateException(""no readers"");
/*     */   }
/*     */   
/*     */   static class MultiTermEnum
/*     */     extends TermEnum
/*     */   {
/*     */     private SegmentMergeQueue queue;
/*     */     private Term term;
/*     */     private int docFreq;
/*     */     
/*     */     public MultiTermEnum(IndexReader[] readers, int[] starts, Term t) throws IOException {
/* 460 */       this.queue = new SegmentMergeQueue(readers.length);
/* 461 */       for (int i = 0; i < readers.length; i++) {
/* 462 */         TermEnum termEnum; IndexReader reader = readers[i];
/*     */ 
/*     */         
/* 465 */         if (t != null) {
/* 466 */           termEnum = reader.terms(t);
/*     */         } else {
/* 468 */           termEnum = reader.terms();
/*     */         } 
/* 470 */         SegmentMergeInfo smi = new SegmentMergeInfo(starts[i], termEnum, reader);
/* 471 */         if ((t == null) ? smi.next() : (termEnum.term() != null)) {
/* 472 */           this.queue.put(smi);
/*     */         } else {
/* 474 */           smi.close();
/*     */         } 
/*     */       } 
/* 477 */       if (t != null && this.queue.size() > 0) {
/* 478 */         next();
/*     */       }
/*     */     }
/*     */     
/*     */     public boolean next() throws IOException {
/* 483 */       SegmentMergeInfo top = (SegmentMergeInfo)this.queue.top();
/* 484 */       if (top == null) {
/* 485 */         this.term = null;
/* 486 */         return false;
/*     */       } 
/*     */       
/* 489 */       this.term = top.term;
/* 490 */       this.docFreq = 0;
/*     */       
/* 492 */       while (top != null && this.term.compareTo(top.term) == 0) {
/* 493 */         this.queue.pop();
/* 494 */         this.docFreq += top.termEnum.docFreq();
/* 495 */         if (top.next()) {
/* 496 */           this.queue.put(top);
/*     */         } else {
/* 498 */           top.close();
/* 499 */         }  top = (SegmentMergeInfo)this.queue.top();
/*     */       } 
/* 501 */       return true;
/*     */     }
/*     */ 
/*     */     
/* 505 */     public Term term() { return this.term; }
/*     */ 
/*     */ 
/*     */     
/* 509 */     public int docFreq() { return this.docFreq; }
/*     */ 
/*     */ 
/*     */     
/* 513 */     public void close() throws IOException { this.queue.close(); }
/*     */   }
/*     */   
/*     */   static class MultiTermDocs
/*     */     implements TermDocs
/*     */   {
/*     */     protected IndexReader[] readers;
/*     */     protected int[] starts;
/*     */     protected Term term;
/* 522 */     protected int base = 0;
/* 523 */     protected int pointer = 0;
/*     */     
/*     */     private TermDocs[] readerTermDocs;
/*     */     protected TermDocs current;
/*     */     
/*     */     public MultiTermDocs(IndexReader[] r, int[] s) {
/* 529 */       this.readers = r;
/* 530 */       this.starts = s;
/*     */       
/* 532 */       this.readerTermDocs = new TermDocs[r.length];
/*     */     }
/*     */ 
/*     */     
/* 536 */     public int doc() { return this.base + this.current.doc(); }
/*     */ 
/*     */     
/* 539 */     public int freq() { return this.current.freq(); }
/*     */ 
/*     */     
/*     */     public void seek(Term term) {
/* 543 */       this.term = term;
/* 544 */       this.base = 0;
/* 545 */       this.pointer = 0;
/* 546 */       this.current = null;
/*     */     }
/*     */ 
/*     */     
/* 550 */     public void seek(TermEnum termEnum) throws IOException { seek(termEnum.term()); }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/*     */       while (true) {
/* 555 */         if (this.current != null && this.current.next()) {
/* 556 */           return true;
/*     */         }
/* 558 */         if (this.pointer < this.readers.length) {
/* 559 */           this.base = this.starts[this.pointer];
/* 560 */           this.current = termDocs(this.pointer++); continue;
/*     */         }  break;
/* 562 */       }  return false;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     public int read(int[] docs, int[] freqs) throws IOException {
/*     */       int end;
/*     */       while (true) {
/* 570 */         while (this.current == null) {
/* 571 */           if (this.pointer < this.readers.length) {
/* 572 */             this.base = this.starts[this.pointer];
/* 573 */             this.current = termDocs(this.pointer++); continue;
/*     */           } 
/* 575 */           return 0;
/*     */         } 
/*     */         
/* 578 */         end = this.current.read(docs, freqs);
/* 579 */         if (end == 0) {
/* 580 */           this.current = null; continue;
/*     */         }  break;
/* 582 */       }  int b = this.base;
/* 583 */       for (int i = 0; i < end; i++)
/* 584 */         docs[i] = docs[i] + b; 
/* 585 */       return end;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/*     */       while (true) {
/* 593 */         if (this.current != null && this.current.skipTo(target - this.base))
/* 594 */           return true; 
/* 595 */         if (this.pointer < this.readers.length) {
/* 596 */           this.base = this.starts[this.pointer];
/* 597 */           this.current = termDocs(this.pointer++); continue;
/*     */         }  break;
/* 599 */       }  return false;
/*     */     }
/*     */ 
/*     */     
/*     */     private TermDocs termDocs(int i) throws IOException {
/* 604 */       if (this.term == null)
/* 605 */         return null; 
/* 606 */       TermDocs result = this.readerTermDocs[i];
/* 607 */       if (result == null)
/* 608 */         result = this.readerTermDocs[i] = termDocs(this.readers[i]); 
/* 609 */       result.seek(this.term);
/* 610 */       return result;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 615 */     protected TermDocs termDocs(IndexReader reader) throws IOException { return reader.termDocs(); }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {
/* 619 */       for (int i = 0; i < this.readerTermDocs.length; i++) {
/* 620 */         if (this.readerTermDocs[i] != null)
/* 621 */           this.readerTermDocs[i].close(); 
/*     */       } 
/*     */     }
/*     */   }
/*     */   
/*     */   static class MultiTermPositions
/*     */     extends MultiTermDocs implements TermPositions {
/* 628 */     public MultiTermPositions(IndexReader[] r, int[] s) { super(r, s); }
/*     */ 
/*     */ 
/*     */     
/* 632 */     protected TermDocs termDocs(IndexReader reader) throws IOException { return reader.termPositions(); }
/*     */ 
/*     */ 
/*     */     
/* 636 */     public int nextPosition() throws IOException { return ((TermPositions)this.current).nextPosition(); }
/*     */ 
/*     */ 
/*     */     
/* 640 */     public int getPayloadLength() { return ((TermPositions)this.current).getPayloadLength(); }
/*     */ 
/*     */ 
/*     */     
/* 644 */     public byte[] getPayload(byte[] data, int offset) throws IOException { return ((TermPositions)this.current).getPayload(data, offset); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 650 */     public boolean isPayloadAvailable() { return ((TermPositions)this.current).isPayloadAvailable(); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\MultiSegmentReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.NormsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class NormsWriter
/*     */   extends InvertedDocEndConsumer
/*     */ {
/*  40 */   private static final byte defaultNorm = Similarity.encodeNorm(1.0F);
/*     */   private FieldInfos fieldInfos;
/*     */   
/*  43 */   public InvertedDocEndConsumerPerThread addThread(DocInverterPerThread docInverterPerThread) { return new NormsWriterPerThread(docInverterPerThread, this); }
/*     */ 
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public void abort() {}
/*     */   
/*     */   void files(Collection files) {}
/*     */   
/*  52 */   void setFieldInfos(FieldInfos fieldInfos) { this.fieldInfos = fieldInfos; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush(Map threadsAndFields, DocumentsWriter.FlushState state) throws IOException {
/*  59 */     Map byField = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  65 */     Iterator it = threadsAndFields.entrySet().iterator();
/*  66 */     while (it.hasNext()) {
/*  67 */       Map.Entry entry = it.next();
/*     */       
/*  69 */       Collection fields = (Collection)entry.getValue();
/*  70 */       Iterator fieldsIt = fields.iterator();
/*     */       
/*  72 */       while (fieldsIt.hasNext()) {
/*  73 */         NormsWriterPerField perField = fieldsIt.next();
/*     */         
/*  75 */         if (perField.upto > 0) {
/*     */           
/*  77 */           List l = (List)byField.get(perField.fieldInfo);
/*  78 */           if (l == null) {
/*  79 */             l = new ArrayList();
/*  80 */             byField.put(perField.fieldInfo, l);
/*     */           } 
/*  82 */           l.add(perField);
/*     */           
/*     */           continue;
/*     */         } 
/*  86 */         fieldsIt.remove();
/*     */       } 
/*     */     } 
/*     */     
/*  90 */     String normsFileName = state.segmentName + ""."" + ""nrm"";
/*  91 */     state.flushedFiles.add(normsFileName);
/*  92 */     IndexOutput normsOut = state.directory.createOutput(normsFileName);
/*     */     
/*     */     try {
/*  95 */       normsOut.writeBytes(SegmentMerger.NORMS_HEADER, 0, SegmentMerger.NORMS_HEADER.length);
/*     */       
/*  97 */       int numField = this.fieldInfos.size();
/*     */       
/*  99 */       int normCount = 0;
/*     */       
/* 101 */       for (int fieldNumber = 0; fieldNumber < numField; fieldNumber++) {
/*     */         
/* 103 */         FieldInfo fieldInfo = this.fieldInfos.fieldInfo(fieldNumber);
/*     */         
/* 105 */         List toMerge = (List)byField.get(fieldInfo);
/* 106 */         int upto = 0;
/* 107 */         if (toMerge != null) {
/*     */           
/* 109 */           int numFields = toMerge.size();
/*     */           
/* 111 */           normCount++;
/*     */           
/* 113 */           NormsWriterPerField[] fields = new NormsWriterPerField[numFields];
/* 114 */           int[] uptos = new int[numFields];
/*     */           
/* 116 */           for (int j = 0; j < numFields; j++) {
/* 117 */             fields[j] = toMerge.get(j);
/*     */           }
/* 119 */           int numLeft = numFields;
/*     */           
/* 121 */           while (numLeft > 0) {
/*     */             
/* 123 */             assert uptos[0] < (fields[0]).docIDs.length : "" uptos[0]="" + uptos[false] + "" len="" + (fields[false]).docIDs.length;
/*     */             
/* 125 */             int minLoc = 0;
/* 126 */             int minDocID = (fields[0]).docIDs[uptos[0]];
/*     */             
/* 128 */             for (int j = 1; j < numLeft; j++) {
/* 129 */               int docID = (fields[j]).docIDs[uptos[j]];
/* 130 */               if (docID < minDocID) {
/* 131 */                 minDocID = docID;
/* 132 */                 minLoc = j;
/*     */               } 
/*     */             } 
/*     */             
/* 136 */             assert minDocID < state.numDocsInRAM;
/*     */ 
/*     */             
/* 139 */             for (; upto < minDocID; upto++) {
/* 140 */               normsOut.writeByte(defaultNorm);
/*     */             }
/* 142 */             normsOut.writeByte((fields[minLoc]).norms[uptos[minLoc]]);
/* 143 */             uptos[minLoc] = uptos[minLoc] + 1;
/* 144 */             upto++;
/*     */             
/* 146 */             if (uptos[minLoc] == (fields[minLoc]).upto) {
/* 147 */               fields[minLoc].reset();
/* 148 */               if (minLoc != numLeft - 1) {
/* 149 */                 fields[minLoc] = fields[numLeft - 1];
/* 150 */                 uptos[minLoc] = uptos[numLeft - 1];
/*     */               } 
/* 152 */               numLeft--;
/*     */             } 
/*     */           } 
/*     */ 
/*     */           
/* 157 */           for (; upto < state.numDocsInRAM; upto++)
/* 158 */             normsOut.writeByte(defaultNorm); 
/* 159 */         } else if (fieldInfo.isIndexed && !fieldInfo.omitNorms) {
/* 160 */           normCount++;
/*     */           
/* 162 */           for (; upto < state.numDocsInRAM; upto++) {
/* 163 */             normsOut.writeByte(defaultNorm);
/*     */           }
/*     */         } 
/* 166 */         assert (4 + normCount * state.numDocsInRAM) == normsOut.getFilePointer() : "".nrm file size mismatch: expected="" + (4 + normCount * state.numDocsInRAM) + "" actual="" + normsOut.getFilePointer();
/*     */       } 
/*     */     } finally {
/*     */       
/* 170 */       normsOut.close();
/*     */     } 
/*     */   }
/*     */   
/*     */   void closeDocStore(DocumentsWriter.FlushState state) {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\NormsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.NormsWriterPerField,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import org.apache.lucene.search.Similarity;
/*    */ import org.apache.lucene.util.ArrayUtil;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class NormsWriterPerField
/*    */   extends InvertedDocEndConsumerPerField
/*    */   implements Comparable
/*    */ {
/*    */   final NormsWriterPerThread perThread;
/*    */   final FieldInfo fieldInfo;
/*    */   final DocumentsWriter.DocState docState;
/* 35 */   int[] docIDs = new int[1];
/* 36 */   byte[] norms = new byte[1];
/*    */   
/*    */   int upto;
/*    */   final DocInverter.FieldInvertState fieldState;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public void reset() {
/* 43 */     this.docIDs = ArrayUtil.shrink(this.docIDs, this.upto);
/* 44 */     this.norms = ArrayUtil.shrink(this.norms, this.upto);
/* 45 */     this.upto = 0;
/*    */   }
/*    */   
/*    */   public NormsWriterPerField(DocInverterPerField docInverterPerField, NormsWriterPerThread perThread, FieldInfo fieldInfo) {
/* 49 */     this.perThread = perThread;
/* 50 */     this.fieldInfo = fieldInfo;
/* 51 */     this.docState = perThread.docState;
/* 52 */     this.fieldState = docInverterPerField.fieldState;
/*    */   }
/*    */ 
/*    */   
/* 56 */   void abort() { this.upto = 0; }
/*    */ 
/*    */ 
/*    */   
/* 60 */   public int compareTo(Object other) { return this.fieldInfo.name.compareTo(((NormsWriterPerField)other).fieldInfo.name); }
/*    */ 
/*    */   
/*    */   void finish() {
/* 64 */     assert this.docIDs.length == this.norms.length;
/* 65 */     if (this.fieldInfo.isIndexed && !this.fieldInfo.omitNorms) {
/* 66 */       if (this.docIDs.length <= this.upto) {
/* 67 */         assert this.docIDs.length == this.upto;
/* 68 */         this.docIDs = ArrayUtil.grow(this.docIDs, 1 + this.upto);
/* 69 */         this.norms = ArrayUtil.grow(this.norms, 1 + this.upto);
/*    */       } 
/* 71 */       float norm = this.fieldState.boost * this.docState.similarity.lengthNorm(this.fieldInfo.name, this.fieldState.length);
/* 72 */       this.norms[this.upto] = Similarity.encodeNorm(norm);
/* 73 */       this.docIDs[this.upto] = this.docState.docID;
/* 74 */       this.upto++;
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\NormsWriterPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.NormsWriterPerThread,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class NormsWriterPerThread
/*    */   extends InvertedDocEndConsumerPerThread
/*    */ {
/*    */   final NormsWriter normsWriter;
/*    */   final DocumentsWriter.DocState docState;
/*    */   
/*    */   public NormsWriterPerThread(DocInverterPerThread docInverterPerThread, NormsWriter normsWriter) {
/* 25 */     this.normsWriter = normsWriter;
/* 26 */     this.docState = docInverterPerThread.docState;
/*    */   }
/*    */ 
/*    */   
/* 30 */   InvertedDocEndConsumerPerField addField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo) { return new NormsWriterPerField(docInverterPerField, this, fieldInfo); }
/*    */ 
/*    */   
/*    */   void abort() {}
/*    */   
/*    */   void startDocument() {}
/*    */   
/*    */   void finishDocument() {}
/*    */   
/* 39 */   boolean freeRAM() { return false; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\NormsWriterPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ParallelArrayTermVectorMapper,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class ParallelArrayTermVectorMapper
/*     */   extends TermVectorMapper
/*     */ {
/*     */   private String[] terms;
/*     */   private int[] termFreqs;
/*     */   private int[][] positions;
/*     */   private TermVectorOffsetInfo[][] offsets;
/*     */   private int currentPosition;
/*     */   private boolean storingOffsets;
/*     */   private boolean storingPositions;
/*     */   private String field;
/*     */   
/*     */   public void setExpectations(String field, int numTerms, boolean storeOffsets, boolean storePositions) {
/* 559 */     this.field = field;
/* 560 */     this.terms = new String[numTerms];
/* 561 */     this.termFreqs = new int[numTerms];
/* 562 */     this.storingOffsets = storeOffsets;
/* 563 */     this.storingPositions = storePositions;
/* 564 */     if (storePositions)
/* 565 */       this.positions = new int[numTerms][]; 
/* 566 */     if (storeOffsets)
/* 567 */       this.offsets = new TermVectorOffsetInfo[numTerms][]; 
/*     */   }
/*     */   
/*     */   public void map(String term, int frequency, TermVectorOffsetInfo[] offsets, int[] positions) {
/* 571 */     this.terms[this.currentPosition] = term;
/* 572 */     this.termFreqs[this.currentPosition] = frequency;
/* 573 */     if (this.storingOffsets)
/*     */     {
/* 575 */       this.offsets[this.currentPosition] = offsets;
/*     */     }
/* 577 */     if (this.storingPositions)
/*     */     {
/* 579 */       this.positions[this.currentPosition] = positions;
/*     */     }
/* 581 */     this.currentPosition++;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector materializeVector() {
/* 589 */     SegmentTermVector tv = null;
/* 590 */     if (this.field != null && this.terms != null) {
/* 591 */       if (this.storingPositions || this.storingOffsets) {
/* 592 */         tv = new SegmentTermPositionVector(this.field, this.terms, this.termFreqs, this.positions, this.offsets);
/*     */       } else {
/* 594 */         tv = new SegmentTermVector(this.field, this.terms, this.termFreqs);
/*     */       } 
/*     */     }
/* 597 */     return tv;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ParallelArrayTermVectorMapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ParallelReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import java.util.SortedMap;
/*     */ import java.util.TreeMap;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.document.FieldSelectorResult;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParallelReader
/*     */   extends IndexReader
/*     */ {
/*  47 */   private List readers = new ArrayList();
/*  48 */   private List decrefOnClose = new ArrayList();
/*     */   boolean incRefReaders = false;
/*  50 */   private SortedMap fieldToReader = new TreeMap();
/*  51 */   private Map readerToFields = new HashMap();
/*  52 */   private List storedFieldReaders = new ArrayList();
/*     */   
/*     */   private int maxDoc;
/*     */   
/*     */   private int numDocs;
/*     */   
/*     */   private boolean hasDeletions;
/*     */ 
/*     */   
/*  61 */   public ParallelReader() throws IOException { this(true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  69 */   public ParallelReader(boolean closeSubReaders) throws IOException { this.incRefReaders = !closeSubReaders; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(IndexReader reader) throws IOException {
/*  76 */     ensureOpen();
/*  77 */     add(reader, false);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(IndexReader reader, boolean ignoreStoredFields) throws IOException {
/*  93 */     ensureOpen();
/*  94 */     if (this.readers.size() == 0) {
/*  95 */       this.maxDoc = reader.maxDoc();
/*  96 */       this.numDocs = reader.numDocs();
/*  97 */       this.hasDeletions = reader.hasDeletions();
/*     */     } 
/*     */     
/* 100 */     if (reader.maxDoc() != this.maxDoc) {
/* 101 */       throw new IllegalArgumentException(""All readers must have same maxDoc: "" + this.maxDoc + ""!="" + reader.maxDoc());
/*     */     }
/* 103 */     if (reader.numDocs() != this.numDocs) {
/* 104 */       throw new IllegalArgumentException(""All readers must have same numDocs: "" + this.numDocs + ""!="" + reader.numDocs());
/*     */     }
/*     */     
/* 107 */     Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);
/* 108 */     this.readerToFields.put(reader, fields);
/* 109 */     Iterator i = fields.iterator();
/* 110 */     while (i.hasNext()) {
/* 111 */       String field = i.next();
/* 112 */       if (this.fieldToReader.get(field) == null) {
/* 113 */         this.fieldToReader.put(field, reader);
/*     */       }
/*     */     } 
/* 116 */     if (!ignoreStoredFields)
/* 117 */       this.storedFieldReaders.add(reader); 
/* 118 */     this.readers.add(reader);
/*     */     
/* 120 */     if (this.incRefReaders) {
/* 121 */       reader.incRef();
/*     */     }
/* 123 */     this.decrefOnClose.add(Boolean.valueOf(this.incRefReaders));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexReader reopen() throws CorruptIndexException, IOException {
/* 146 */     ensureOpen();
/*     */     
/* 148 */     boolean reopened = false;
/* 149 */     List newReaders = new ArrayList();
/* 150 */     List newDecrefOnClose = new ArrayList();
/*     */     
/* 152 */     boolean success = false;
/*     */ 
/*     */     
/*     */     try {
/* 156 */       for (int i = 0; i < this.readers.size(); i++) {
/* 157 */         IndexReader oldReader = this.readers.get(i);
/* 158 */         IndexReader newReader = oldReader.reopen();
/* 159 */         newReaders.add(newReader);
/*     */ 
/*     */         
/* 162 */         if (newReader != oldReader) {
/* 163 */           reopened = true;
/*     */         }
/*     */       } 
/*     */       
/* 167 */       if (reopened) {
/* 168 */         ParallelReader pr = new ParallelReader();
/* 169 */         for (int i = 0; i < this.readers.size(); i++) {
/* 170 */           IndexReader oldReader = this.readers.get(i);
/* 171 */           IndexReader newReader = newReaders.get(i);
/* 172 */           if (newReader == oldReader) {
/* 173 */             newDecrefOnClose.add(Boolean.TRUE);
/* 174 */             newReader.incRef();
/*     */           }
/*     */           else {
/*     */             
/* 178 */             newDecrefOnClose.add(Boolean.FALSE);
/*     */           } 
/* 180 */           pr.add(newReader, !this.storedFieldReaders.contains(oldReader));
/*     */         } 
/* 182 */         pr.decrefOnClose = newDecrefOnClose;
/* 183 */         pr.incRefReaders = this.incRefReaders;
/* 184 */         success = true;
/* 185 */         return pr;
/*     */       } 
/* 187 */       success = true;
/*     */       
/* 189 */       return this;
/*     */     } finally {
/*     */       
/* 192 */       if (!success && reopened) {
/* 193 */         for (int i = 0; i < newReaders.size(); i++) {
/* 194 */           IndexReader r = newReaders.get(i);
/* 195 */           if (r != null) {
/*     */             try {
/* 197 */               if (((Boolean)newDecrefOnClose.get(i)).booleanValue()) {
/* 198 */                 r.decRef();
/*     */               } else {
/* 200 */                 r.close();
/*     */               } 
/* 202 */             } catch (IOException ignore) {}
/*     */           }
/*     */         } 
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 214 */   public int numDocs() { return this.numDocs; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 219 */   public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 224 */   public boolean hasDeletions() { return this.hasDeletions; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isDeleted(int n) {
/* 230 */     if (this.readers.size() > 0)
/* 231 */       return ((IndexReader)this.readers.get(0)).isDeleted(n); 
/* 232 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doDelete(int n) throws CorruptIndexException, IOException {
/* 237 */     for (int i = 0; i < this.readers.size(); i++) {
/* 238 */       ((IndexReader)this.readers.get(i)).deleteDocument(n);
/*     */     }
/* 240 */     this.hasDeletions = true;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doUndeleteAll() throws CorruptIndexException, IOException {
/* 245 */     for (int i = 0; i < this.readers.size(); i++) {
/* 246 */       ((IndexReader)this.readers.get(i)).undeleteAll();
/*     */     }
/* 248 */     this.hasDeletions = false;
/*     */   }
/*     */ 
/*     */   
/*     */   public Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 253 */     ensureOpen();
/* 254 */     Document result = new Document();
/* 255 */     for (int i = 0; i < this.storedFieldReaders.size(); i++) {
/* 256 */       IndexReader reader = this.storedFieldReaders.get(i);
/*     */       
/* 258 */       boolean include = (fieldSelector == null);
/* 259 */       if (!include) {
/* 260 */         Iterator it = ((Collection)this.readerToFields.get(reader)).iterator();
/* 261 */         while (it.hasNext()) {
/* 262 */           if (fieldSelector.accept(it.next()) != FieldSelectorResult.NO_LOAD) {
/* 263 */             include = true; break;
/*     */           } 
/*     */         } 
/*     */       } 
/* 267 */       if (include) {
/* 268 */         Iterator fieldIterator = reader.document(n, fieldSelector).getFields().iterator();
/* 269 */         while (fieldIterator.hasNext()) {
/* 270 */           result.add(fieldIterator.next());
/*     */         }
/*     */       } 
/*     */     } 
/* 274 */     return result;
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int n) throws IOException {
/* 279 */     ensureOpen();
/* 280 */     ArrayList results = new ArrayList();
/* 281 */     Iterator i = this.fieldToReader.entrySet().iterator();
/* 282 */     while (i.hasNext()) {
/* 283 */       Map.Entry e = i.next();
/* 284 */       String field = (String)e.getKey();
/* 285 */       IndexReader reader = (IndexReader)e.getValue();
/* 286 */       TermFreqVector vector = reader.getTermFreqVector(n, field);
/* 287 */       if (vector != null)
/* 288 */         results.add(vector); 
/*     */     } 
/* 290 */     return results.toArray(new TermFreqVector[results.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int n, String field) throws IOException {
/* 296 */     ensureOpen();
/* 297 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 298 */     return (reader == null) ? null : reader.getTermFreqVector(n, field);
/*     */   }
/*     */ 
/*     */   
/*     */   public void getTermFreqVector(int docNumber, String field, TermVectorMapper mapper) throws IOException {
/* 303 */     ensureOpen();
/* 304 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 305 */     if (reader != null) {
/* 306 */       reader.getTermFreqVector(docNumber, field, mapper);
/*     */     }
/*     */   }
/*     */   
/*     */   public void getTermFreqVector(int docNumber, TermVectorMapper mapper) throws IOException {
/* 311 */     ensureOpen();
/* 312 */     ensureOpen();
/*     */     
/* 314 */     Iterator i = this.fieldToReader.entrySet().iterator();
/* 315 */     while (i.hasNext()) {
/* 316 */       Map.Entry e = i.next();
/* 317 */       String field = (String)e.getKey();
/* 318 */       IndexReader reader = (IndexReader)e.getValue();
/* 319 */       reader.getTermFreqVector(docNumber, field, mapper);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 325 */     ensureOpen();
/* 326 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 327 */     return (reader == null) ? false : reader.hasNorms(field);
/*     */   }
/*     */   
/*     */   public byte[] norms(String field) throws IOException {
/* 331 */     ensureOpen();
/* 332 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 333 */     return (reader == null) ? null : reader.norms(field);
/*     */   }
/*     */ 
/*     */   
/*     */   public void norms(String field, byte[] result, int offset) throws IOException {
/* 338 */     ensureOpen();
/* 339 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 340 */     if (reader != null) {
/* 341 */       reader.norms(field, result, offset);
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doSetNorm(int n, String field, byte value) throws CorruptIndexException, IOException {
/* 346 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 347 */     if (reader != null)
/* 348 */       reader.doSetNorm(n, field, value); 
/*     */   }
/*     */   
/*     */   public TermEnum terms() throws IOException {
/* 352 */     ensureOpen();
/* 353 */     return new ParallelTermEnum();
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term term) throws IOException {
/* 357 */     ensureOpen();
/* 358 */     return new ParallelTermEnum(term);
/*     */   }
/*     */   
/*     */   public int docFreq(Term term) throws IOException {
/* 362 */     ensureOpen();
/* 363 */     IndexReader reader = (IndexReader)this.fieldToReader.get(term.field());
/* 364 */     return (reader == null) ? 0 : reader.docFreq(term);
/*     */   }
/*     */   
/*     */   public TermDocs termDocs(Term term) throws IOException {
/* 368 */     ensureOpen();
/* 369 */     return new ParallelTermDocs(term);
/*     */   }
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 373 */     ensureOpen();
/* 374 */     return new ParallelTermDocs();
/*     */   }
/*     */   
/*     */   public TermPositions termPositions(Term term) throws IOException {
/* 378 */     ensureOpen();
/* 379 */     return new ParallelTermPositions(term);
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 383 */     ensureOpen();
/* 384 */     return new ParallelTermPositions();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isCurrent() throws CorruptIndexException, IOException {
/* 391 */     for (int i = 0; i < this.readers.size(); i++) {
/* 392 */       if (!((IndexReader)this.readers.get(i)).isCurrent()) {
/* 393 */         return false;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 398 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isOptimized() {
/* 405 */     for (int i = 0; i < this.readers.size(); i++) {
/* 406 */       if (!((IndexReader)this.readers.get(i)).isOptimized()) {
/* 407 */         return false;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 412 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 420 */   public long getVersion() { throw new UnsupportedOperationException(""ParallelReader does not support this method.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 425 */   IndexReader[] getSubReaders() { return (IndexReader[])this.readers.toArray((Object[])new IndexReader[this.readers.size()]); }
/*     */ 
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 429 */     for (int i = 0; i < this.readers.size(); i++)
/* 430 */       ((IndexReader)this.readers.get(i)).commit(); 
/*     */   }
/*     */   
/*     */   protected synchronized void doClose() throws IOException {
/* 434 */     for (int i = 0; i < this.readers.size(); i++) {
/* 435 */       if (((Boolean)this.decrefOnClose.get(i)).booleanValue()) {
/* 436 */         ((IndexReader)this.readers.get(i)).decRef();
/*     */       } else {
/* 438 */         ((IndexReader)this.readers.get(i)).close();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 444 */     ensureOpen();
/* 445 */     Set fieldSet = new HashSet();
/* 446 */     for (int i = 0; i < this.readers.size(); i++) {
/* 447 */       IndexReader reader = this.readers.get(i);
/* 448 */       Collection names = reader.getFieldNames(fieldNames);
/* 449 */       fieldSet.addAll(names);
/*     */     } 
/* 451 */     return fieldSet;
/*     */   }
/*     */   
/*     */   private class ParallelTermEnum extends TermEnum { private String field;
/*     */     private Iterator fieldIterator;
/*     */     private TermEnum termEnum;
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermEnum() throws IOException {
/* 460 */       this.field = (String)ParallelReader.this.fieldToReader.firstKey();
/* 461 */       if (this.field != null)
/* 462 */         this.termEnum = ((IndexReader)ParallelReader.this.fieldToReader.get(this.field)).terms(); 
/*     */     }
/*     */     
/*     */     public ParallelTermEnum(Term term) throws IOException {
/* 466 */       this.field = term.field();
/* 467 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(this.field);
/* 468 */       if (reader != null)
/* 469 */         this.termEnum = reader.terms(term); 
/*     */     }
/*     */     
/*     */     public boolean next() throws IOException {
/* 473 */       if (this.termEnum == null) {
/* 474 */         return false;
/*     */       }
/*     */       
/* 477 */       if (this.termEnum.next() && this.termEnum.term().field() == this.field) {
/* 478 */         return true;
/*     */       }
/* 480 */       this.termEnum.close();
/*     */ 
/*     */       
/* 483 */       if (this.fieldIterator == null) {
/* 484 */         this.fieldIterator = ParallelReader.this.fieldToReader.tailMap(this.field).keySet().iterator();
/* 485 */         this.fieldIterator.next();
/*     */       } 
/* 487 */       while (this.fieldIterator.hasNext()) {
/* 488 */         this.field = this.fieldIterator.next();
/* 489 */         this.termEnum = ((IndexReader)ParallelReader.this.fieldToReader.get(this.field)).terms(new Term(this.field));
/* 490 */         Term term = this.termEnum.term();
/* 491 */         if (term != null && term.field() == this.field) {
/* 492 */           return true;
/*     */         }
/* 494 */         this.termEnum.close();
/*     */       } 
/*     */       
/* 497 */       return false;
/*     */     }
/*     */     
/*     */     public Term term() {
/* 501 */       if (this.termEnum == null) {
/* 502 */         return null;
/*     */       }
/* 504 */       return this.termEnum.term();
/*     */     }
/*     */     
/*     */     public int docFreq() {
/* 508 */       if (this.termEnum == null) {
/* 509 */         return 0;
/*     */       }
/* 511 */       return this.termEnum.docFreq();
/*     */     }
/*     */     
/*     */     public void close() throws IOException {
/* 515 */       if (this.termEnum != null)
/* 516 */         this.termEnum.close(); 
/*     */     } }
/*     */ 
/*     */   
/*     */   private class ParallelTermDocs implements TermDocs {
/*     */     protected TermDocs termDocs;
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermDocs() {}
/*     */     
/* 526 */     public ParallelTermDocs(Term term) throws IOException { seek(term); }
/*     */     
/* 528 */     public int doc() { return this.termDocs.doc(); }
/* 529 */     public int freq() { return this.termDocs.freq(); }
/*     */     
/*     */     public void seek(Term term) throws IOException {
/* 532 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(term.field());
/* 533 */       this.termDocs = (reader != null) ? reader.termDocs(term) : null;
/*     */     }
/*     */ 
/*     */     
/* 537 */     public void seek(TermEnum termEnum) throws IOException { seek(termEnum.term()); }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/* 541 */       if (this.termDocs == null) {
/* 542 */         return false;
/*     */       }
/* 544 */       return this.termDocs.next();
/*     */     }
/*     */     
/*     */     public int read(int[] docs, int[] freqs) throws IOException {
/* 548 */       if (this.termDocs == null) {
/* 549 */         return 0;
/*     */       }
/* 551 */       return this.termDocs.read(docs, freqs);
/*     */     }
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 555 */       if (this.termDocs == null) {
/* 556 */         return false;
/*     */       }
/* 558 */       return this.termDocs.skipTo(target);
/*     */     }
/*     */     
/*     */     public void close() throws IOException {
/* 562 */       if (this.termDocs != null)
/* 563 */         this.termDocs.close(); 
/*     */     }
/*     */   }
/*     */   
/*     */   private class ParallelTermPositions extends ParallelTermDocs implements TermPositions {
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermPositions() {}
/*     */     
/* 572 */     public ParallelTermPositions(Term term) throws IOException { seek(term); }
/*     */     
/*     */     public void seek(Term term) throws IOException {
/* 575 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(term.field());
/* 576 */       this.termDocs = (reader != null) ? reader.termPositions(term) : null;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 581 */     public int nextPosition() throws IOException { return ((TermPositions)this.termDocs).nextPosition(); }
/*     */ 
/*     */ 
/*     */     
/* 585 */     public int getPayloadLength() { return ((TermPositions)this.termDocs).getPayloadLength(); }
/*     */ 
/*     */ 
/*     */     
/* 589 */     public byte[] getPayload(byte[] data, int offset) throws IOException { return ((TermPositions)this.termDocs).getPayload(data, offset); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 595 */     public boolean isPayloadAvailable() { return ((TermPositions)this.termDocs).isPayloadAvailable(); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ParallelReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.Payload,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.util.ArrayUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Payload
/*     */   implements Serializable, Cloneable
/*     */ {
/*     */   protected byte[] data;
/*     */   protected int offset;
/*     */   protected int length;
/*     */   
/*     */   public Payload() {}
/*     */   
/*  61 */   public Payload(byte[] data) { this(data, 0, data.length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Payload(byte[] data, int offset, int length) {
/*  74 */     if (offset < 0 || offset + length > data.length) {
/*  75 */       throw new IllegalArgumentException();
/*     */     }
/*  77 */     this.data = data;
/*  78 */     this.offset = offset;
/*  79 */     this.length = length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  88 */   public void setData(byte[] data) { setData(data, 0, data.length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setData(byte[] data, int offset, int length) {
/*  97 */     this.data = data;
/*  98 */     this.offset = offset;
/*  99 */     this.length = length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public byte[] getData() { return this.data; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 114 */   public int getOffset() { return this.offset; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 121 */   public int length() { return this.length; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public byte byteAt(int index) {
/* 128 */     if (0 <= index && index < this.length) {
/* 129 */       return this.data[this.offset + index];
/*     */     }
/* 131 */     throw new ArrayIndexOutOfBoundsException(index);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public byte[] toByteArray() {
/* 138 */     byte[] retArray = new byte[this.length];
/* 139 */     System.arraycopy(this.data, this.offset, retArray, 0, this.length);
/* 140 */     return retArray;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void copyTo(byte[] target, int targetOffset) {
/* 150 */     if (this.length > target.length + targetOffset) {
/* 151 */       throw new ArrayIndexOutOfBoundsException();
/*     */     }
/* 153 */     System.arraycopy(this.data, this.offset, target, targetOffset, this.length);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/*     */     try {
/* 163 */       Payload clone = (Payload)super.clone();
/*     */       
/* 165 */       if (this.offset == 0 && this.length == this.data.length) {
/*     */         
/* 167 */         clone.data = (byte[])this.data.clone();
/*     */       }
/*     */       else {
/*     */         
/* 171 */         clone.data = toByteArray();
/* 172 */         clone.offset = 0;
/*     */       } 
/* 174 */       return clone;
/* 175 */     } catch (CloneNotSupportedException e) {
/* 176 */       throw new RuntimeException(e);
/*     */     } 
/*     */   }
/*     */   
/*     */   public boolean equals(Object obj) {
/* 181 */     if (obj == this)
/* 182 */       return true; 
/* 183 */     if (obj instanceof Payload) {
/* 184 */       Payload other = (Payload)obj;
/* 185 */       if (this.length == other.length) {
/* 186 */         for (int i = 0; i < this.length; i++) {
/* 187 */           if (this.data[this.offset + i] != other.data[other.offset + i])
/* 188 */             return false; 
/* 189 */         }  return true;
/*     */       } 
/* 191 */       return false;
/*     */     } 
/* 193 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 197 */   public int hashCode() { return ArrayUtil.hashCode(this.data, this.offset, this.offset + this.length); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\Payload.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.PositionBasedTermVectorMapper,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.HashMap;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class PositionBasedTermVectorMapper
/*     */   extends TermVectorMapper
/*     */ {
/*     */   private Map fieldToTerms;
/*     */   private String currentField;
/*     */   private Map currentPositions;
/*     */   private boolean storeOffsets;
/*     */   
/*  47 */   public PositionBasedTermVectorMapper() { super(false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  52 */   public PositionBasedTermVectorMapper(boolean ignoringOffsets) { super(false, ignoringOffsets); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public boolean isIgnoringPositions() { return false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void map(String term, int frequency, TermVectorOffsetInfo[] offsets, int[] positions) {
/*  71 */     for (int i = 0; i < positions.length; i++) {
/*  72 */       Integer posVal = new Integer(positions[i]);
/*  73 */       TVPositionInfo pos = (TVPositionInfo)this.currentPositions.get(posVal);
/*  74 */       if (pos == null) {
/*  75 */         pos = new TVPositionInfo(positions[i], this.storeOffsets);
/*  76 */         this.currentPositions.put(posVal, pos);
/*     */       } 
/*  78 */       pos.addTerm(term, (offsets != null) ? offsets[i] : null);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setExpectations(String field, int numTerms, boolean storeOffsets, boolean storePositions) {
/*  90 */     if (!storePositions)
/*     */     {
/*  92 */       throw new RuntimeException(""You must store positions in order to use this Mapper"");
/*     */     }
/*  94 */     if (storeOffsets == true);
/*     */ 
/*     */ 
/*     */     
/*  98 */     this.fieldToTerms = new HashMap(numTerms);
/*  99 */     this.storeOffsets = storeOffsets;
/* 100 */     this.currentField = field;
/* 101 */     this.currentPositions = new HashMap();
/* 102 */     this.fieldToTerms.put(this.currentField, this.currentPositions);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 111 */   public Map getFieldToTerms() { return this.fieldToTerms; }
/*     */ 
/*     */ 
/*     */   
/*     */   public static class TVPositionInfo
/*     */   {
/*     */     private int position;
/*     */ 
/*     */     
/*     */     private List terms;
/*     */     
/*     */     private List offsets;
/*     */ 
/*     */     
/*     */     public TVPositionInfo(int position, boolean storeOffsets) {
/* 126 */       this.position = position;
/* 127 */       this.terms = new ArrayList();
/* 128 */       if (storeOffsets) {
/* 129 */         this.offsets = new ArrayList();
/*     */       }
/*     */     }
/*     */ 
/*     */     
/*     */     void addTerm(String term, TermVectorOffsetInfo info) {
/* 135 */       this.terms.add(term);
/* 136 */       if (this.offsets != null) {
/* 137 */         this.offsets.add(info);
/*     */       }
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 146 */     public int getPosition() { return this.position; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 154 */     public List getTerms() { return this.terms; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 162 */     public List getOffsets() { return this.offsets; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\PositionBasedTermVectorMapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.RawPostingList,"package org.apache.lucene.index;
abstract class RawPostingList {
  static final int BYTES_SIZE = 20;
  int textStart;
  int intStart;
  int byteStart;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\RawPostingList.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ReadOnlyMultiSegmentReader,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Map;
/*    */ import org.apache.lucene.store.Directory;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class ReadOnlyMultiSegmentReader
/*    */   extends MultiSegmentReader
/*    */ {
/* 27 */   ReadOnlyMultiSegmentReader(Directory directory, SegmentInfos sis, boolean closeDirectory) throws IOException { super(directory, sis, closeDirectory, true); }
/*    */ 
/*    */ 
/*    */   
/* 31 */   ReadOnlyMultiSegmentReader(Directory directory, SegmentInfos infos, boolean closeDirectory, SegmentReader[] oldReaders, int[] oldStarts, Map oldNormsCache) throws IOException { super(directory, infos, closeDirectory, oldReaders, oldStarts, oldNormsCache, true); }
/*    */ 
/*    */ 
/*    */   
/* 35 */   protected void acquireWriteLock() { ReadOnlySegmentReader.noWrite(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ReadOnlyMultiSegmentReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ReadOnlySegmentReader,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class ReadOnlySegmentReader
/*    */   extends SegmentReader
/*    */ {
/* 23 */   static void noWrite() { throw new UnsupportedOperationException(""This IndexReader cannot make any changes to the index (it was opened with readOnly = true)""); }
/*    */ 
/*    */ 
/*    */   
/* 27 */   protected void acquireWriteLock() { noWrite(); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 32 */   public boolean isDeleted(int n) { return (this.deletedDocs != null && this.deletedDocs.get(n)); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ReadOnlySegmentReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ReusableStringReader,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class ReusableStringReader
/*    */   extends Reader
/*    */ {
/*    */   int upto;
/*    */   int left;
/*    */   String s;
/*    */   
/*    */   void init(String s) {
/* 30 */     this.s = s;
/* 31 */     this.left = s.length();
/* 32 */     this.upto = 0;
/*    */   }
/*    */   
/* 35 */   public int read(char[] c) { return read(c, 0, c.length); }
/*    */   
/*    */   public int read(char[] c, int off, int len) {
/* 38 */     if (this.left > len) {
/* 39 */       this.s.getChars(this.upto, this.upto + len, c, off);
/* 40 */       this.upto += len;
/* 41 */       this.left -= len;
/* 42 */       return len;
/* 43 */     }  if (0 == this.left) {
/* 44 */       return -1;
/*    */     }
/* 46 */     this.s.getChars(this.upto, this.upto + this.left, c, off);
/* 47 */     int r = this.left;
/* 48 */     this.left = 0;
/* 49 */     this.upto = this.s.length();
/* 50 */     return r;
/*    */   }
/*    */   
/*    */   public void close() {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\ReusableStringReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentInfo,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.BitVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentInfo
/*     */ {
/*     */   static final int NO = -1;
/*     */   static final int YES = 1;
/*     */   static final int CHECK_DIR = 0;
/*     */   static final int WITHOUT_GEN = 0;
/*     */   public String name;
/*     */   public int docCount;
/*     */   public Directory dir;
/*     */   private boolean preLockless;
/*     */   private long delGen;
/*     */   private long[] normGen;
/*     */   private byte isCompoundFile;
/*     */   private boolean hasSingleNormFile;
/*     */   private List files;
/*  69 */   long sizeInBytes = -1L;
/*     */   
/*     */   private int docStoreOffset;
/*     */   
/*     */   private String docStoreSegment;
/*     */   
/*     */   private boolean docStoreIsCompoundFile;
/*     */   
/*     */   private int delCount;
/*     */   
/*     */   private boolean hasProx;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public SegmentInfo(String name, int docCount, Directory dir) {
/*  83 */     this.name = name;
/*  84 */     this.docCount = docCount;
/*  85 */     this.dir = dir;
/*  86 */     this.delGen = -1L;
/*  87 */     this.isCompoundFile = 0;
/*  88 */     this.preLockless = true;
/*  89 */     this.hasSingleNormFile = false;
/*  90 */     this.docStoreOffset = -1;
/*  91 */     this.docStoreSegment = name;
/*  92 */     this.docStoreIsCompoundFile = false;
/*  93 */     this.delCount = 0;
/*  94 */     this.hasProx = true;
/*     */   }
/*     */ 
/*     */   
/*  98 */   public SegmentInfo(String name, int docCount, Directory dir, boolean isCompoundFile, boolean hasSingleNormFile) { this(name, docCount, dir, isCompoundFile, hasSingleNormFile, -1, null, false, true); }
/*     */ 
/*     */ 
/*     */   
/*     */   public SegmentInfo(String name, int docCount, Directory dir, boolean isCompoundFile, boolean hasSingleNormFile, int docStoreOffset, String docStoreSegment, boolean docStoreIsCompoundFile, boolean hasProx) {
/* 103 */     this(name, docCount, dir);
/* 104 */     this.isCompoundFile = (byte)(isCompoundFile ? 1 : -1);
/* 105 */     this.hasSingleNormFile = hasSingleNormFile;
/* 106 */     this.preLockless = false;
/* 107 */     this.docStoreOffset = docStoreOffset;
/* 108 */     this.docStoreSegment = docStoreSegment;
/* 109 */     this.docStoreIsCompoundFile = docStoreIsCompoundFile;
/* 110 */     this.hasProx = hasProx;
/* 111 */     this.delCount = 0;
/* 112 */     assert docStoreOffset == -1 || docStoreSegment != null : ""dso="" + docStoreOffset + "" dss="" + docStoreSegment + "" docCount="" + docCount;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void reset(SegmentInfo src) {
/* 119 */     clearFiles();
/* 120 */     this.name = src.name;
/* 121 */     this.docCount = src.docCount;
/* 122 */     this.dir = src.dir;
/* 123 */     this.preLockless = src.preLockless;
/* 124 */     this.delGen = src.delGen;
/* 125 */     this.docStoreOffset = src.docStoreOffset;
/* 126 */     this.docStoreIsCompoundFile = src.docStoreIsCompoundFile;
/* 127 */     if (src.normGen == null) {
/* 128 */       this.normGen = null;
/*     */     } else {
/* 130 */       this.normGen = new long[src.normGen.length];
/* 131 */       System.arraycopy(src.normGen, 0, this.normGen, 0, src.normGen.length);
/*     */     } 
/* 133 */     this.isCompoundFile = src.isCompoundFile;
/* 134 */     this.hasSingleNormFile = src.hasSingleNormFile;
/* 135 */     this.delCount = src.delCount;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   SegmentInfo(Directory dir, int format, IndexInput input) throws IOException {
/* 147 */     this.dir = dir;
/* 148 */     this.name = input.readString();
/* 149 */     this.docCount = input.readInt();
/* 150 */     if (format <= -2)
/* 151 */     { this.delGen = input.readLong();
/* 152 */       if (format <= -4) {
/* 153 */         this.docStoreOffset = input.readInt();
/* 154 */         if (this.docStoreOffset != -1) {
/* 155 */           this.docStoreSegment = input.readString();
/* 156 */           this.docStoreIsCompoundFile = (1 == input.readByte());
/*     */         } else {
/* 158 */           this.docStoreSegment = this.name;
/* 159 */           this.docStoreIsCompoundFile = false;
/*     */         } 
/*     */       } else {
/* 162 */         this.docStoreOffset = -1;
/* 163 */         this.docStoreSegment = this.name;
/* 164 */         this.docStoreIsCompoundFile = false;
/*     */       } 
/* 166 */       if (format <= -3) {
/* 167 */         this.hasSingleNormFile = (1 == input.readByte());
/*     */       } else {
/* 169 */         this.hasSingleNormFile = false;
/*     */       } 
/* 171 */       int numNormGen = input.readInt();
/* 172 */       if (numNormGen == -1) {
/* 173 */         this.normGen = null;
/*     */       } else {
/* 175 */         this.normGen = new long[numNormGen];
/* 176 */         for (int j = 0; j < numNormGen; j++) {
/* 177 */           this.normGen[j] = input.readLong();
/*     */         }
/*     */       } 
/* 180 */       this.isCompoundFile = input.readByte();
/* 181 */       this.preLockless = (this.isCompoundFile == 0);
/* 182 */       if (format <= -6) {
/* 183 */         this.delCount = input.readInt();
/* 184 */         assert this.delCount <= this.docCount;
/*     */       } else {
/* 186 */         this.delCount = -1;
/* 187 */       }  if (format <= -7) {
/* 188 */         this.hasProx = (input.readByte() == 1);
/*     */       } else {
/* 190 */         this.hasProx = true;
/*     */       }  }
/* 192 */     else { this.delGen = 0L;
/* 193 */       this.normGen = null;
/* 194 */       this.isCompoundFile = 0;
/* 195 */       this.preLockless = true;
/* 196 */       this.hasSingleNormFile = false;
/* 197 */       this.docStoreOffset = -1;
/* 198 */       this.docStoreIsCompoundFile = false;
/* 199 */       this.docStoreSegment = null;
/* 200 */       this.delCount = -1;
/* 201 */       this.hasProx = true; }
/*     */   
/*     */   }
/*     */   
/*     */   void setNumFields(int numFields) {
/* 206 */     if (this.normGen == null) {
/*     */ 
/*     */ 
/*     */       
/* 210 */       this.normGen = new long[numFields];
/*     */       
/* 212 */       if (!this.preLockless)
/*     */       {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 219 */         for (int i = 0; i < numFields; i++) {
/* 220 */           this.normGen[i] = -1L;
/*     */         }
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   long sizeInBytes() throws IOException {
/* 229 */     if (this.sizeInBytes == -1L) {
/* 230 */       List files = files();
/* 231 */       int size = files.size();
/* 232 */       this.sizeInBytes = 0L;
/* 233 */       for (int i = 0; i < size; i++) {
/* 234 */         String fileName = files.get(i);
/*     */ 
/*     */         
/* 237 */         if (this.docStoreOffset == -1 || !IndexFileNames.isDocStoreFile(fileName))
/* 238 */           this.sizeInBytes += this.dir.fileLength(fileName); 
/*     */       } 
/*     */     } 
/* 241 */     return this.sizeInBytes;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean hasDeletions() throws IOException {
/* 260 */     if (this.delGen == -1L)
/* 261 */       return false; 
/* 262 */     if (this.delGen >= 1L) {
/* 263 */       return true;
/*     */     }
/* 265 */     return this.dir.fileExists(getDelFileName());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void advanceDelGen() {
/* 271 */     if (this.delGen == -1L) {
/* 272 */       this.delGen = 1L;
/*     */     } else {
/* 274 */       this.delGen++;
/*     */     } 
/* 276 */     clearFiles();
/*     */   }
/*     */   
/*     */   void clearDelGen() {
/* 280 */     this.delGen = -1L;
/* 281 */     clearFiles();
/*     */   }
/*     */   
/*     */   public Object clone() {
/* 285 */     SegmentInfo si = new SegmentInfo(this.name, this.docCount, this.dir);
/* 286 */     si.isCompoundFile = this.isCompoundFile;
/* 287 */     si.delGen = this.delGen;
/* 288 */     si.delCount = this.delCount;
/* 289 */     si.preLockless = this.preLockless;
/* 290 */     si.hasSingleNormFile = this.hasSingleNormFile;
/* 291 */     if (this.normGen != null) {
/* 292 */       si.normGen = (long[])this.normGen.clone();
/*     */     }
/* 294 */     si.docStoreOffset = this.docStoreOffset;
/* 295 */     si.docStoreSegment = this.docStoreSegment;
/* 296 */     si.docStoreIsCompoundFile = this.docStoreIsCompoundFile;
/* 297 */     return si;
/*     */   }
/*     */   
/*     */   String getDelFileName() {
/* 301 */     if (this.delGen == -1L)
/*     */     {
/*     */       
/* 304 */       return null;
/*     */     }
/*     */     
/* 307 */     return IndexFileNames.fileNameFromGeneration(this.name, "".del"", this.delGen);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean hasSeparateNorms(int fieldNumber) throws IOException {
/* 318 */     if ((this.normGen == null && this.preLockless) || (this.normGen != null && this.normGen[fieldNumber] == 0L)) {
/*     */       
/* 320 */       String fileName = this.name + "".s"" + fieldNumber;
/* 321 */       return this.dir.fileExists(fileName);
/* 322 */     }  if (this.normGen == null || this.normGen[fieldNumber] == -1L) {
/* 323 */       return false;
/*     */     }
/* 325 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean hasSeparateNorms() throws IOException {
/* 334 */     if (this.normGen == null) {
/* 335 */       if (!this.preLockless)
/*     */       {
/*     */         
/* 338 */         return false;
/*     */       }
/*     */ 
/*     */ 
/*     */       
/* 343 */       String[] result = this.dir.list();
/* 344 */       if (result == null) {
/* 345 */         throw new IOException(""cannot read directory "" + this.dir + "": list() returned null"");
/*     */       }
/*     */       
/* 348 */       String pattern = this.name + "".s"";
/* 349 */       int patternLength = pattern.length();
/* 350 */       for (int i = 0; i < result.length; i++) {
/* 351 */         if (result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))
/* 352 */           return true; 
/*     */       } 
/* 354 */       return false;
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 360 */     for (int i = 0; i < this.normGen.length; i++) {
/* 361 */       if (this.normGen[i] >= 1L) {
/* 362 */         return true;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 367 */     for (int i = 0; i < this.normGen.length; i++) {
/* 368 */       if (this.normGen[i] == 0L && 
/* 369 */         hasSeparateNorms(i)) {
/* 370 */         return true;
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 376 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void advanceNormGen(int fieldIndex) {
/* 386 */     if (this.normGen[fieldIndex] == -1L) {
/* 387 */       this.normGen[fieldIndex] = 1L;
/*     */     } else {
/* 389 */       this.normGen[fieldIndex] = this.normGen[fieldIndex] + 1L;
/*     */     } 
/* 391 */     clearFiles();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   String getNormFileName(int number) throws IOException {
/*     */     long gen;
/* 403 */     if (this.normGen == null) {
/* 404 */       gen = 0L;
/*     */     } else {
/* 406 */       gen = this.normGen[number];
/*     */     } 
/*     */     
/* 409 */     if (hasSeparateNorms(number)) {
/*     */       
/* 411 */       String prefix = "".s"";
/* 412 */       return IndexFileNames.fileNameFromGeneration(this.name, prefix + number, gen);
/*     */     } 
/*     */     
/* 415 */     if (this.hasSingleNormFile) {
/*     */       
/* 417 */       String prefix = "".nrm"";
/* 418 */       return IndexFileNames.fileNameFromGeneration(this.name, prefix, 0L);
/*     */     } 
/*     */ 
/*     */     
/* 422 */     String prefix = "".f"";
/* 423 */     return IndexFileNames.fileNameFromGeneration(this.name, prefix + number, 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setUseCompoundFile(boolean isCompoundFile) {
/* 433 */     if (isCompoundFile) {
/* 434 */       this.isCompoundFile = 1;
/*     */     } else {
/* 436 */       this.isCompoundFile = -1;
/*     */     } 
/* 438 */     clearFiles();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean getUseCompoundFile() throws IOException {
/* 446 */     if (this.isCompoundFile == -1)
/* 447 */       return false; 
/* 448 */     if (this.isCompoundFile == 1) {
/* 449 */       return true;
/*     */     }
/* 451 */     return this.dir.fileExists(this.name + ""."" + ""cfs"");
/*     */   }
/*     */ 
/*     */   
/*     */   int getDelCount() throws IOException {
/* 456 */     if (this.delCount == -1)
/* 457 */       if (hasDeletions()) {
/* 458 */         String delFileName = getDelFileName();
/* 459 */         this.delCount = (new BitVector(this.dir, delFileName)).count();
/*     */       } else {
/* 461 */         this.delCount = 0;
/*     */       }  
/* 463 */     assert this.delCount <= this.docCount;
/* 464 */     return this.delCount;
/*     */   }
/*     */   
/*     */   void setDelCount(int delCount) {
/* 468 */     this.delCount = delCount;
/* 469 */     assert delCount <= this.docCount;
/*     */   }
/*     */ 
/*     */   
/* 473 */   int getDocStoreOffset() { return this.docStoreOffset; }
/*     */ 
/*     */ 
/*     */   
/* 477 */   boolean getDocStoreIsCompoundFile() { return this.docStoreIsCompoundFile; }
/*     */ 
/*     */   
/*     */   void setDocStoreIsCompoundFile(boolean v) {
/* 481 */     this.docStoreIsCompoundFile = v;
/* 482 */     clearFiles();
/*     */   }
/*     */ 
/*     */   
/* 486 */   String getDocStoreSegment() { return this.docStoreSegment; }
/*     */ 
/*     */   
/*     */   void setDocStoreOffset(int offset) {
/* 490 */     this.docStoreOffset = offset;
/* 491 */     clearFiles();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void write(IndexOutput output) throws IOException {
/* 499 */     output.writeString(this.name);
/* 500 */     output.writeInt(this.docCount);
/* 501 */     output.writeLong(this.delGen);
/* 502 */     output.writeInt(this.docStoreOffset);
/* 503 */     if (this.docStoreOffset != -1) {
/* 504 */       output.writeString(this.docStoreSegment);
/* 505 */       output.writeByte((byte)(this.docStoreIsCompoundFile ? 1 : 0));
/*     */     } 
/*     */     
/* 508 */     output.writeByte((byte)(this.hasSingleNormFile ? 1 : 0));
/* 509 */     if (this.normGen == null) {
/* 510 */       output.writeInt(-1);
/*     */     } else {
/* 512 */       output.writeInt(this.normGen.length);
/* 513 */       for (int j = 0; j < this.normGen.length; j++) {
/* 514 */         output.writeLong(this.normGen[j]);
/*     */       }
/*     */     } 
/* 517 */     output.writeByte(this.isCompoundFile);
/* 518 */     output.writeInt(this.delCount);
/* 519 */     output.writeByte((byte)(this.hasProx ? 1 : 0));
/*     */   }
/*     */   
/*     */   void setHasProx(boolean hasProx) {
/* 523 */     this.hasProx = hasProx;
/* 524 */     clearFiles();
/*     */   }
/*     */ 
/*     */   
/* 528 */   boolean getHasProx() { return this.hasProx; }
/*     */ 
/*     */   
/*     */   private void addIfExists(List files, String fileName) throws IOException {
/* 532 */     if (this.dir.fileExists(fileName)) {
/* 533 */       files.add(fileName);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public List files() throws IOException {
/* 544 */     if (this.files != null)
/*     */     {
/* 546 */       return this.files;
/*     */     }
/*     */     
/* 549 */     this.files = new ArrayList();
/*     */     
/* 551 */     boolean useCompoundFile = getUseCompoundFile();
/*     */     
/* 553 */     if (useCompoundFile) {
/* 554 */       this.files.add(this.name + ""."" + ""cfs"");
/*     */     } else {
/* 556 */       String[] exts = IndexFileNames.NON_STORE_INDEX_EXTENSIONS;
/* 557 */       for (int i = 0; i < exts.length; i++) {
/* 558 */         addIfExists(this.files, this.name + ""."" + exts[i]);
/*     */       }
/*     */     } 
/* 561 */     if (this.docStoreOffset != -1) {
/*     */ 
/*     */       
/* 564 */       assert this.docStoreSegment != null;
/* 565 */       if (this.docStoreIsCompoundFile) {
/* 566 */         this.files.add(this.docStoreSegment + ""."" + ""cfx"");
/*     */       } else {
/* 568 */         String[] exts = IndexFileNames.STORE_INDEX_EXTENSIONS;
/* 569 */         for (int i = 0; i < exts.length; i++)
/* 570 */           addIfExists(this.files, this.docStoreSegment + ""."" + exts[i]); 
/*     */       } 
/* 572 */     } else if (!useCompoundFile) {
/*     */ 
/*     */       
/* 575 */       String[] exts = IndexFileNames.STORE_INDEX_EXTENSIONS;
/* 576 */       for (int i = 0; i < exts.length; i++) {
/* 577 */         addIfExists(this.files, this.name + ""."" + exts[i]);
/*     */       }
/*     */     } 
/* 580 */     String delFileName = IndexFileNames.fileNameFromGeneration(this.name, "".del"", this.delGen);
/* 581 */     if (delFileName != null && (this.delGen >= 1L || this.dir.fileExists(delFileName))) {
/* 582 */       this.files.add(delFileName);
/*     */     }
/*     */ 
/*     */     
/* 586 */     if (this.normGen != null) {
/* 587 */       for (int i = 0; i < this.normGen.length; i++) {
/* 588 */         long gen = this.normGen[i];
/* 589 */         if (gen >= 1L) {
/*     */           
/* 591 */           this.files.add(IndexFileNames.fileNameFromGeneration(this.name, "".s"" + i, gen));
/* 592 */         } else if (-1L == gen) {
/*     */ 
/*     */           
/* 595 */           if (!this.hasSingleNormFile && !useCompoundFile) {
/* 596 */             String fileName = this.name + ""."" + ""f"" + i;
/* 597 */             if (this.dir.fileExists(fileName)) {
/* 598 */               this.files.add(fileName);
/*     */             }
/*     */           } 
/* 601 */         } else if (0L == gen) {
/*     */           
/* 603 */           String fileName = null;
/* 604 */           if (useCompoundFile) {
/* 605 */             fileName = this.name + ""."" + ""s"" + i;
/* 606 */           } else if (!this.hasSingleNormFile) {
/* 607 */             fileName = this.name + ""."" + ""f"" + i;
/*     */           } 
/* 609 */           if (fileName != null && this.dir.fileExists(fileName)) {
/* 610 */             this.files.add(fileName);
/*     */           }
/*     */         } 
/*     */       } 
/* 614 */     } else if (this.preLockless || (!this.hasSingleNormFile && !useCompoundFile)) {
/*     */       String prefix;
/*     */ 
/*     */       
/* 618 */       if (useCompoundFile) {
/* 619 */         prefix = this.name + ""."" + ""s"";
/*     */       } else {
/* 621 */         prefix = this.name + ""."" + ""f"";
/* 622 */       }  int prefixLength = prefix.length();
/* 623 */       String[] allFiles = this.dir.list();
/* 624 */       if (allFiles == null)
/* 625 */         throw new IOException(""cannot read directory "" + this.dir + "": list() returned null""); 
/* 626 */       for (int i = 0; i < allFiles.length; i++) {
/* 627 */         String fileName = allFiles[i];
/* 628 */         if (fileName.length() > prefixLength && Character.isDigit(fileName.charAt(prefixLength)) && fileName.startsWith(prefix)) {
/* 629 */           this.files.add(fileName);
/*     */         }
/*     */       } 
/*     */     } 
/* 633 */     return this.files;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void clearFiles() {
/* 639 */     this.files = null;
/* 640 */     this.sizeInBytes = -1L;
/*     */   }
/*     */   
/*     */   public String segString(Directory dir) {
/*     */     Object docStore;
/*     */     String str;
/*     */     try {
/* 647 */       if (getUseCompoundFile())
/* 648 */       { str = ""c""; }
/*     */       else
/* 650 */       { str = ""C""; } 
/* 651 */     } catch (IOException ioe) {
/* 652 */       str = ""?"";
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 657 */     if (this.docStoreOffset != -1) {
/* 658 */       docStore = ""->"" + this.docStoreSegment;
/*     */     } else {
/* 660 */       docStore = """";
/*     */     } 
/* 662 */     return this.name + "":"" + str + ((this.dir == dir) ? """" : ""x"") + this.docCount + docStore;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object obj) {
/*     */     SegmentInfo other;
/*     */     try {
/* 673 */       other = (SegmentInfo)obj;
/* 674 */     } catch (ClassCastException cce) {
/* 675 */       return false;
/*     */     } 
/* 677 */     return (other.dir == this.dir && other.name.equals(this.name));
/*     */   }
/*     */ 
/*     */   
/* 681 */   public int hashCode() { return this.dir.hashCode() + this.name.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentInfos,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileNotFoundException;
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.store.ChecksumIndexInput;
/*     */ import org.apache.lucene.store.ChecksumIndexOutput;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentInfos
/*     */   extends Vector
/*     */ {
/*     */   public static final int FORMAT = -1;
/*     */   public static final int FORMAT_LOCKLESS = -2;
/*     */   public static final int FORMAT_SINGLE_NORM_FILE = -3;
/*     */   public static final int FORMAT_SHARED_DOC_STORE = -4;
/*     */   public static final int FORMAT_CHECKSUM = -5;
/*     */   public static final int FORMAT_DEL_COUNT = -6;
/*     */   public static final int FORMAT_HAS_PROX = -7;
/*     */   static final int CURRENT_FORMAT = -7;
/*  75 */   public int counter = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   private long version = System.currentTimeMillis();
/*     */   
/*  82 */   private long generation = 0L;
/*  83 */   private long lastGeneration = 0L;
/*     */ 
/*     */ 
/*     */   
/*     */   private static PrintStream infoStream;
/*     */ 
/*     */   
/*     */   ChecksumIndexOutput pendingOutput;
/*     */ 
/*     */ 
/*     */   
/*  94 */   public final SegmentInfo info(int i) { return (SegmentInfo)get(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long getCurrentSegmentGeneration(String[] files) {
/* 104 */     if (files == null) {
/* 105 */       return -1L;
/*     */     }
/* 107 */     long max = -1L;
/* 108 */     for (int i = 0; i < files.length; i++) {
/* 109 */       String file = files[i];
/* 110 */       if (file.startsWith(""segments"") && !file.equals(""segments.gen"")) {
/* 111 */         long gen = generationFromSegmentsFileName(file);
/* 112 */         if (gen > max) {
/* 113 */           max = gen;
/*     */         }
/*     */       } 
/*     */     } 
/* 117 */     return max;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long getCurrentSegmentGeneration(Directory directory) throws IOException {
/* 127 */     String[] files = directory.list();
/* 128 */     if (files == null)
/* 129 */       throw new IOException(""cannot read directory "" + directory + "": list() returned null""); 
/* 130 */     return getCurrentSegmentGeneration(files);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 141 */   public static String getCurrentSegmentFileName(String[] files) throws IOException { return IndexFileNames.fileNameFromGeneration(""segments"", """", getCurrentSegmentGeneration(files)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 153 */   public static String getCurrentSegmentFileName(Directory directory) throws IOException { return IndexFileNames.fileNameFromGeneration(""segments"", """", getCurrentSegmentGeneration(directory)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 162 */   public String getCurrentSegmentFileName() { return IndexFileNames.fileNameFromGeneration(""segments"", """", this.lastGeneration); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long generationFromSegmentsFileName(String fileName) {
/* 172 */     if (fileName.equals(""segments""))
/* 173 */       return 0L; 
/* 174 */     if (fileName.startsWith(""segments"")) {
/* 175 */       return Long.parseLong(fileName.substring(1 + ""segments"".length()), 36);
/*     */     }
/*     */     
/* 178 */     throw new IllegalArgumentException(""fileName \"""" + fileName + ""\"" is not a segments file"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String getNextSegmentFileName() {
/*     */     long nextGeneration;
/* 189 */     if (this.generation == -1L) {
/* 190 */       nextGeneration = 1L;
/*     */     } else {
/* 192 */       nextGeneration = this.generation + 1L;
/*     */     } 
/* 194 */     return IndexFileNames.fileNameFromGeneration(""segments"", """", nextGeneration);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void read(Directory directory, String segmentFileName) throws CorruptIndexException, IOException {
/* 209 */     boolean success = false;
/*     */ 
/*     */     
/* 212 */     clear();
/*     */     
/* 214 */     ChecksumIndexInput input = new ChecksumIndexInput(directory.openInput(segmentFileName));
/*     */     
/* 216 */     this.generation = generationFromSegmentsFileName(segmentFileName);
/*     */     
/* 218 */     this.lastGeneration = this.generation;
/*     */     
/*     */     try {
/* 221 */       int format = input.readInt();
/* 222 */       if (format < 0) {
/*     */         
/* 224 */         if (format < -7)
/* 225 */           throw new CorruptIndexException(""Unknown format version: "" + format); 
/* 226 */         this.version = input.readLong();
/* 227 */         this.counter = input.readInt();
/*     */       } else {
/*     */         
/* 230 */         this.counter = format;
/*     */       } 
/*     */       
/* 233 */       for (int i = input.readInt(); i > 0; i--) {
/* 234 */         add((E)new SegmentInfo(directory, format, (IndexInput)input));
/*     */       }
/*     */       
/* 237 */       if (format >= 0) {
/* 238 */         if (input.getFilePointer() >= input.length()) {
/* 239 */           this.version = System.currentTimeMillis();
/*     */         } else {
/* 241 */           this.version = input.readLong();
/*     */         } 
/*     */       }
/* 244 */       if (format <= -5) {
/* 245 */         long checksumNow = input.getChecksum();
/* 246 */         long checksumThen = input.readLong();
/* 247 */         if (checksumNow != checksumThen)
/* 248 */           throw new CorruptIndexException(""checksum mismatch in segments file""); 
/*     */       } 
/* 250 */       success = true;
/*     */     } finally {
/*     */       
/* 253 */       input.close();
/* 254 */       if (!success)
/*     */       {
/*     */         
/* 257 */         clear();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void read(Directory directory) throws CorruptIndexException, IOException {
/* 270 */     this.generation = this.lastGeneration = -1L;
/*     */     
/* 272 */     (new FindSegmentsFile(directory) { private final SegmentInfos this$0;
/*     */         
/*     */         protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
/* 275 */           SegmentInfos.this.read(this.directory, segmentFileName);
/* 276 */           return null;
/*     */         } }
/*     */       ).run();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void write(Directory directory) throws IOException {
/* 287 */     String segmentFileName = getNextSegmentFileName();
/*     */ 
/*     */     
/* 290 */     if (this.generation == -1L) {
/* 291 */       this.generation = 1L;
/*     */     } else {
/* 293 */       this.generation++;
/*     */     } 
/*     */     
/* 296 */     ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));
/*     */     
/* 298 */     boolean success = false;
/*     */     
/*     */     try {
/* 301 */       output.writeInt(-7);
/* 302 */       output.writeLong(++this.version);
/*     */       
/* 304 */       output.writeInt(this.counter);
/* 305 */       output.writeInt(size());
/* 306 */       for (int i = 0; i < size(); i++) {
/* 307 */         info(i).write((IndexOutput)output);
/*     */       }
/* 309 */       output.prepareCommit();
/* 310 */       success = true;
/* 311 */       this.pendingOutput = output;
/*     */     } finally {
/* 313 */       if (!success) {
/*     */ 
/*     */         
/*     */         try {
/* 317 */           output.close();
/* 318 */         } catch (Throwable t) {}
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*     */         try {
/* 324 */           directory.deleteFile(segmentFileName);
/* 325 */         } catch (Throwable t) {}
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 338 */     SegmentInfos sis = (SegmentInfos)super.clone();
/* 339 */     for (int i = 0; i < sis.size(); i++) {
/* 340 */       sis.set(i, (E)sis.info(i).clone());
/*     */     }
/* 342 */     return sis;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 349 */   public long getVersion() { return this.version; }
/*     */ 
/*     */   
/* 352 */   public long getGeneration() { return this.generation; }
/*     */ 
/*     */   
/* 355 */   public long getLastGeneration() { return this.lastGeneration; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 366 */   public static long readCurrentVersion(Directory directory) throws CorruptIndexException, IOException { return ((Long)(new FindSegmentsFile(directory)
/*     */       {
/*     */         protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
/* 369 */           IndexInput input = this.directory.openInput(segmentFileName);
/*     */           
/* 371 */           int format = 0;
/* 372 */           long version = 0L;
/*     */           try {
/* 374 */             format = input.readInt();
/* 375 */             if (format < 0) {
/* 376 */               if (format < -7)
/* 377 */                 throw new CorruptIndexException(""Unknown format version: "" + format); 
/* 378 */               version = input.readLong();
/*     */             } 
/*     */           } finally {
/*     */             
/* 382 */             input.close();
/*     */           } 
/*     */           
/* 385 */           if (format < 0) {
/* 386 */             return new Long(version);
/*     */           }
/*     */ 
/*     */           
/* 390 */           SegmentInfos sis = new SegmentInfos();
/* 391 */           sis.read(this.directory, segmentFileName);
/* 392 */           return new Long(sis.getVersion());
/*     */         }
/*     */       }).run()).longValue(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 401 */   public static void setInfoStream(PrintStream infoStream) { SegmentInfos.infoStream = infoStream; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 406 */   private static int defaultGenFileRetryCount = 10;
/* 407 */   private static int defaultGenFileRetryPauseMsec = 50;
/* 408 */   private static int defaultGenLookaheadCount = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 417 */   public static void setDefaultGenFileRetryCount(int count) { defaultGenFileRetryCount = count; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 424 */   public static int getDefaultGenFileRetryCount() { return defaultGenFileRetryCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 432 */   public static void setDefaultGenFileRetryPauseMsec(int msec) { defaultGenFileRetryPauseMsec = msec; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 439 */   public static int getDefaultGenFileRetryPauseMsec() { return defaultGenFileRetryPauseMsec; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 450 */   public static void setDefaultGenLookaheadCount(int count) { defaultGenLookaheadCount = count; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 456 */   public static int getDefaultGenLookahedCount() { return defaultGenLookaheadCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 463 */   public static PrintStream getInfoStream() { return infoStream; }
/*     */ 
/*     */   
/*     */   private static void message(String message) {
/* 467 */     if (infoStream != null) {
/* 468 */       infoStream.println(""SIS ["" + Thread.currentThread().getName() + ""]: "" + message);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static abstract class FindSegmentsFile
/*     */   {
/*     */     File fileDirectory;
/*     */ 
/*     */ 
/*     */     
/*     */     Directory directory;
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 487 */     public FindSegmentsFile(File directory) { this.fileDirectory = directory; }
/*     */ 
/*     */ 
/*     */     
/* 491 */     public FindSegmentsFile(Directory directory) { this.directory = directory; }
/*     */ 
/*     */     
/*     */     public Object run() throws CorruptIndexException, IOException {
/* 495 */       String segmentFileName = null;
/* 496 */       long lastGen = -1L;
/* 497 */       long gen = 0L;
/* 498 */       int genLookaheadCount = 0;
/* 499 */       IOException exc = null;
/* 500 */       boolean retry = false;
/*     */       
/* 502 */       int method = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*     */       while (true) {
/* 521 */         if (0 == method) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 528 */           String[] files = null;
/*     */           
/* 530 */           long genA = -1L;
/*     */           
/* 532 */           if (this.directory != null) {
/* 533 */             files = this.directory.list();
/*     */           } else {
/* 535 */             files = this.fileDirectory.list();
/*     */           } 
/* 537 */           if (files != null) {
/* 538 */             genA = SegmentInfos.getCurrentSegmentGeneration(files);
/*     */           }
/* 540 */           SegmentInfos.message(""directory listing genA="" + genA);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 547 */           long genB = -1L;
/* 548 */           if (this.directory != null) {
/* 549 */             for (int i = 0; i < defaultGenFileRetryCount; i++) {
/* 550 */               IndexInput genInput = null;
/*     */               try {
/* 552 */                 genInput = this.directory.openInput(""segments.gen"");
/* 553 */               } catch (FileNotFoundException e) {
/* 554 */                 SegmentInfos.message(""segments.gen open: FileNotFoundException "" + e);
/*     */                 break;
/* 556 */               } catch (IOException e) {
/* 557 */                 SegmentInfos.message(""segments.gen open: IOException "" + e);
/*     */               } 
/*     */               
/* 560 */               if (genInput != null) {
/*     */                 
/* 562 */                 try { int version = genInput.readInt();
/* 563 */                   if (version == -2)
/* 564 */                   { long gen0 = genInput.readLong();
/* 565 */                     long gen1 = genInput.readLong();
/* 566 */                     SegmentInfos.message(""fallback check: "" + gen0 + ""; "" + gen1);
/* 567 */                     if (gen0 == gen1)
/*     */                     
/* 569 */                     { genB = gen0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */                       
/* 576 */                       genInput.close(); break; }  }  } catch (IOException err2) {  } finally { genInput.close(); }
/*     */               
/*     */               }
/*     */               try {
/* 580 */                 Thread.sleep(defaultGenFileRetryPauseMsec);
/* 581 */               } catch (InterruptedException e) {}
/*     */             } 
/*     */           }
/*     */ 
/*     */ 
/*     */           
/* 587 */           SegmentInfos.message(""segments.gen check: genB="" + genB);
/*     */ 
/*     */           
/* 590 */           if (genA > genB) {
/* 591 */             gen = genA;
/*     */           } else {
/* 593 */             gen = genB;
/*     */           } 
/* 595 */           if (gen == -1L) {
/*     */             String s;
/*     */             
/* 598 */             if (files != null) {
/* 599 */               s = """";
/* 600 */               for (int i = 0; i < files.length; i++)
/* 601 */                 s = s + "" "" + files[i]; 
/*     */             } else {
/* 603 */               s = "" null"";
/* 604 */             }  throw new FileNotFoundException(""no segments* file found in "" + this.directory + "": files:"" + s);
/*     */           } 
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 612 */         if (1 == method || (0 == method && lastGen == gen && retry)) {
/*     */           
/* 614 */           method = 1;
/*     */           
/* 616 */           if (genLookaheadCount < defaultGenLookaheadCount) {
/* 617 */             gen++;
/* 618 */             genLookaheadCount++;
/* 619 */             SegmentInfos.message(""look ahead increment gen to "" + gen);
/*     */           } 
/*     */         } 
/*     */         
/* 623 */         if (lastGen == gen) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 630 */           if (retry)
/*     */           {
/*     */ 
/*     */ 
/*     */             
/* 635 */             throw exc;
/*     */           }
/* 637 */           retry = true;
/*     */         
/*     */         }
/* 640 */         else if (0 == method) {
/*     */ 
/*     */           
/* 643 */           retry = false;
/*     */         } 
/*     */         
/* 646 */         lastGen = gen;
/*     */         
/* 648 */         segmentFileName = IndexFileNames.fileNameFromGeneration(""segments"", """", gen);
/*     */ 
/*     */ 
/*     */         
/*     */         try {
/* 653 */           Object v = doBody(segmentFileName);
/* 654 */           if (exc != null) {
/* 655 */             SegmentInfos.message(""success on "" + segmentFileName);
/*     */           }
/* 657 */           return v;
/* 658 */         } catch (IOException err) {
/*     */ 
/*     */           
/* 661 */           if (exc == null) {
/* 662 */             exc = err;
/*     */           }
/*     */           
/* 665 */           SegmentInfos.message(""primary Exception on '"" + segmentFileName + ""': "" + err + ""'; will retry: retry="" + retry + ""; gen = "" + gen);
/*     */           
/* 667 */           if (!retry && gen > 1L) {
/*     */             boolean prevExists;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 674 */             String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(""segments"", """", gen - 1L);
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 679 */             if (this.directory != null) {
/* 680 */               prevExists = this.directory.fileExists(prevSegmentFileName);
/*     */             } else {
/* 682 */               prevExists = (new File(this.fileDirectory, prevSegmentFileName)).exists();
/*     */             } 
/* 684 */             if (prevExists) {
/* 685 */               SegmentInfos.message(""fallback to prior segment file '"" + prevSegmentFileName + ""'"");
/*     */               try {
/* 687 */                 Object v = doBody(prevSegmentFileName);
/* 688 */                 if (exc != null) {
/* 689 */                   SegmentInfos.message(""success on fallback "" + prevSegmentFileName);
/*     */                 }
/* 691 */                 return v;
/* 692 */               } catch (IOException err2) {
/* 693 */                 SegmentInfos.message(""secondary Exception on '"" + prevSegmentFileName + ""': "" + err2 + ""'; will retry"");
/*     */               } 
/*     */             } 
/*     */           } 
/*     */         } 
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected abstract Object doBody(String param1String) throws CorruptIndexException, IOException;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SegmentInfos range(int first, int last) {
/* 717 */     SegmentInfos infos = new SegmentInfos();
/* 718 */     infos.addAll(subList(first, last));
/* 719 */     return infos;
/*     */   }
/*     */ 
/*     */   
/*     */   void updateGeneration(SegmentInfos other) {
/* 724 */     this.lastGeneration = other.lastGeneration;
/* 725 */     this.generation = other.generation;
/* 726 */     this.version = other.version;
/*     */   }
/*     */   
/*     */   public final void rollbackCommit(Directory dir) throws IOException {
/* 730 */     if (this.pendingOutput != null) {
/*     */       try {
/* 732 */         this.pendingOutput.close();
/* 733 */       } catch (Throwable t) {}
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*     */       try {
/* 741 */         String segmentFileName = IndexFileNames.fileNameFromGeneration(""segments"", """", this.generation);
/*     */ 
/*     */         
/* 744 */         dir.deleteFile(segmentFileName);
/* 745 */       } catch (Throwable t) {}
/*     */ 
/*     */ 
/*     */       
/* 749 */       this.pendingOutput = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void prepareCommit(Directory dir) throws IOException {
/* 759 */     if (this.pendingOutput != null)
/* 760 */       throw new IllegalStateException(""prepareCommit was already called""); 
/* 761 */     write(dir);
/*     */   }
/*     */   
/*     */   public final void finishCommit(Directory dir) throws IOException {
/* 765 */     if (this.pendingOutput == null)
/* 766 */       throw new IllegalStateException(""prepareCommit was not called""); 
/* 767 */     boolean success = false;
/*     */     try {
/* 769 */       this.pendingOutput.finishCommit();
/* 770 */       this.pendingOutput.close();
/* 771 */       this.pendingOutput = null;
/* 772 */       success = true;
/*     */     } finally {
/* 774 */       if (!success) {
/* 775 */         rollbackCommit(dir);
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 788 */     String fileName = IndexFileNames.fileNameFromGeneration(""segments"", """", this.generation);
/*     */ 
/*     */     
/* 791 */     success = false;
/*     */     try {
/* 793 */       dir.sync(fileName);
/* 794 */       success = true;
/*     */     } finally {
/* 796 */       if (!success) {
/*     */         try {
/* 798 */           dir.deleteFile(fileName);
/* 799 */         } catch (Throwable t) {}
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 805 */     this.lastGeneration = this.generation;
/*     */     
/*     */     try {
/* 808 */       IndexOutput genOutput = dir.createOutput(""segments.gen"");
/*     */       try {
/* 810 */         genOutput.writeInt(-2);
/* 811 */         genOutput.writeLong(this.generation);
/* 812 */         genOutput.writeLong(this.generation);
/*     */       } finally {
/* 814 */         genOutput.close();
/*     */       } 
/* 816 */     } catch (Throwable t) {}
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void commit(Directory dir) throws IOException {
/* 825 */     prepareCommit(dir);
/* 826 */     finishCommit(dir);
/*     */   }
/*     */   
/*     */   synchronized String segString(Directory directory) {
/* 830 */     StringBuffer buffer = new StringBuffer();
/* 831 */     int count = size();
/* 832 */     for (int i = 0; i < count; i++) {
/* 833 */       if (i > 0) {
/* 834 */         buffer.append(' ');
/*     */       }
/* 836 */       SegmentInfo info = info(i);
/* 837 */       buffer.append(info.segString(directory));
/* 838 */       if (info.dir != directory)
/* 839 */         buffer.append(""**""); 
/*     */     } 
/* 841 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentInfos.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMergeInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentMergeInfo
/*    */ {
/*    */   Term term;
/*    */   int base;
/*    */   TermEnum termEnum;
/*    */   IndexReader reader;
/*    */   private TermPositions postings;
/*    */   private int[] docMap;
/*    */   
/*    */   SegmentMergeInfo(int b, TermEnum te, IndexReader r) throws IOException {
/* 32 */     this.base = b;
/* 33 */     this.reader = r;
/* 34 */     this.termEnum = te;
/* 35 */     this.term = te.term();
/*    */   }
/*    */ 
/*    */   
/*    */   int[] getDocMap() {
/* 40 */     if (this.docMap == null)
/*    */     {
/* 42 */       if (this.reader.hasDeletions()) {
/* 43 */         int maxDoc = this.reader.maxDoc();
/* 44 */         this.docMap = new int[maxDoc];
/* 45 */         int j = 0;
/* 46 */         for (int i = 0; i < maxDoc; i++) {
/* 47 */           if (this.reader.isDeleted(i)) {
/* 48 */             this.docMap[i] = -1;
/*    */           } else {
/* 50 */             this.docMap[i] = j++;
/*    */           } 
/*    */         } 
/*    */       }  } 
/* 54 */     return this.docMap;
/*    */   }
/*    */   
/*    */   TermPositions getPositions() throws IOException {
/* 58 */     if (this.postings == null) {
/* 59 */       this.postings = this.reader.termPositions();
/*    */     }
/* 61 */     return this.postings;
/*    */   }
/*    */   
/*    */   final boolean next() throws IOException {
/* 65 */     if (this.termEnum.next()) {
/* 66 */       this.term = this.termEnum.term();
/* 67 */       return true;
/*    */     } 
/* 69 */     this.term = null;
/* 70 */     return false;
/*    */   }
/*    */ 
/*    */   
/*    */   final void close() throws IOException {
/* 75 */     this.termEnum.close();
/* 76 */     if (this.postings != null)
/* 77 */       this.postings.close(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentMergeInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMergeQueue,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentMergeQueue
/*    */   extends PriorityQueue
/*    */ {
/* 25 */   SegmentMergeQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object a, Object b) {
/* 29 */     SegmentMergeInfo stiA = (SegmentMergeInfo)a;
/* 30 */     SegmentMergeInfo stiB = (SegmentMergeInfo)b;
/* 31 */     int comparison = stiA.term.compareTo(stiB.term);
/* 32 */     if (comparison == 0) {
/* 33 */       return (stiA.base < stiB.base);
/*    */     }
/* 35 */     return (comparison < 0);
/*    */   }
/*    */   
/*    */   final void close() throws IOException {
/* 39 */     while (top() != null)
/* 40 */       ((SegmentMergeInfo)pop()).close(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentMergeQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMerger,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.document.FieldSelectorResult;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentMerger
/*     */ {
/*  47 */   static final byte[] NORMS_HEADER = new byte[] { 78, 82, 77, -1 };
/*     */   
/*     */   private Directory directory;
/*     */   private String segment;
/*  51 */   private int termIndexInterval = 128;
/*     */   
/*  53 */   private List readers = new ArrayList();
/*     */   
/*     */   private FieldInfos fieldInfos;
/*     */   
/*     */   private int mergedDocs;
/*     */   
/*     */   private CheckAbort checkAbort;
/*     */   
/*     */   private boolean mergeDocStores;
/*     */   
/*     */   private static final int MAX_RAW_MERGE_DOCS = 4192;
/*     */   
/*     */   private SegmentReader[] matchingSegmentReaders;
/*     */   
/*     */   private int[] rawDocLengths;
/*     */   
/*     */   private int[] rawDocLengths2;
/*     */   
/*     */   private IndexOutput freqOutput;
/*     */   
/*     */   private IndexOutput proxOutput;
/*     */   
/*     */   private TermInfosWriter termInfosWriter;
/*     */   
/*     */   private int skipInterval;
/*     */   
/*     */   private int maxSkipLevels;
/*     */   
/*     */   private SegmentMergeQueue queue;
/*     */   private DefaultSkipListWriter skipListWriter;
/*     */   private final TermInfo termInfo;
/*     */   private byte[] payloadBuffer;
/*     */   private int[][] docMaps;
/*     */   private int[] delCounts;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  89 */   boolean hasProx() { return this.fieldInfos.hasProx(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   final void add(IndexReader reader) { this.readers.add(reader); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   final IndexReader segmentReader(int i) { return this.readers.get(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 116 */   final int merge() throws CorruptIndexException, IOException { return merge(true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {
/* 130 */     this.mergeDocStores = mergeDocStores;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 139 */     this.mergedDocs = mergeFields();
/* 140 */     mergeTerms();
/* 141 */     mergeNorms();
/*     */     
/* 143 */     if (mergeDocStores && this.fieldInfos.hasVectors()) {
/* 144 */       mergeVectors();
/*     */     }
/* 146 */     return this.mergedDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void closeReaders() throws IOException {
/* 155 */     for (int i = 0; i < this.readers.size(); i++) {
/* 156 */       IndexReader reader = this.readers.get(i);
/* 157 */       reader.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   final List createCompoundFile(String fileName) throws IOException {
/* 163 */     CompoundFileWriter cfsWriter = new CompoundFileWriter(this.directory, fileName, this.checkAbort);
/*     */ 
/*     */     
/* 166 */     List files = new ArrayList(IndexFileNames.COMPOUND_EXTENSIONS.length + 1);
/*     */ 
/*     */ 
/*     */     
/* 170 */     for (int i = 0; i < IndexFileNames.COMPOUND_EXTENSIONS.length; i++) {
/* 171 */       String ext = IndexFileNames.COMPOUND_EXTENSIONS[i];
/*     */       
/* 173 */       if (!ext.equals(""prx"") || hasProx())
/*     */       {
/*     */         
/* 176 */         if (this.mergeDocStores || (!ext.equals(""fdt"") && !ext.equals(""fdx"")))
/*     */         {
/* 178 */           files.add(this.segment + ""."" + ext);
/*     */         }
/*     */       }
/*     */     } 
/* 182 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 183 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 184 */       if (fi.isIndexed && !fi.omitNorms) {
/* 185 */         files.add(this.segment + ""."" + ""nrm"");
/*     */         
/*     */         break;
/*     */       } 
/*     */     } 
/*     */     
/* 191 */     if (this.fieldInfos.hasVectors() && this.mergeDocStores) {
/* 192 */       for (int i = 0; i < IndexFileNames.VECTOR_EXTENSIONS.length; i++) {
/* 193 */         files.add(this.segment + ""."" + IndexFileNames.VECTOR_EXTENSIONS[i]);
/*     */       }
/*     */     }
/*     */ 
/*     */     
/* 198 */     Iterator it = files.iterator();
/* 199 */     while (it.hasNext()) {
/* 200 */       cfsWriter.addFile(it.next());
/*     */     }
/*     */ 
/*     */     
/* 204 */     cfsWriter.close();
/*     */     
/* 206 */     return files;
/*     */   }
/*     */ 
/*     */   
/*     */   private void addIndexed(IndexReader reader, FieldInfos fieldInfos, Collection names, boolean storeTermVectors, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean storePayloads, boolean omitTf) throws IOException {
/* 211 */     Iterator i = names.iterator();
/* 212 */     while (i.hasNext()) {
/* 213 */       String field = i.next();
/* 214 */       fieldInfos.add(field, true, storeTermVectors, storePositionWithTermVector, storeOffsetWithTermVector, !reader.hasNorms(field), storePayloads, omitTf);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void setMatchingSegmentReaders() {
/* 226 */     this.matchingSegmentReaders = new SegmentReader[this.readers.size()];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 232 */     for (int i = 0; i < this.readers.size(); i++) {
/* 233 */       IndexReader reader = this.readers.get(i);
/* 234 */       if (reader instanceof SegmentReader) {
/* 235 */         SegmentReader segmentReader = (SegmentReader)reader;
/* 236 */         boolean same = true;
/* 237 */         FieldInfos segmentFieldInfos = segmentReader.getFieldInfos();
/* 238 */         for (int j = 0; same && j < segmentFieldInfos.size(); j++)
/* 239 */           same = this.fieldInfos.fieldName(j).equals(segmentFieldInfos.fieldName(j)); 
/* 240 */         if (same) {
/* 241 */           this.matchingSegmentReaders[i] = segmentReader;
/*     */         }
/*     */       } 
/*     */     } 
/*     */     
/* 246 */     this.rawDocLengths = new int[4192];
/* 247 */     this.rawDocLengths2 = new int[4192];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int mergeFields() throws CorruptIndexException, IOException {
/* 258 */     if (!this.mergeDocStores) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 265 */       SegmentReader sr = this.readers.get(this.readers.size() - 1);
/* 266 */       this.fieldInfos = (FieldInfos)sr.fieldInfos.clone();
/*     */     } else {
/* 268 */       this.fieldInfos = new FieldInfos();
/*     */     } 
/*     */     
/* 271 */     for (int i = 0; i < this.readers.size(); i++) {
/* 272 */       IndexReader reader = this.readers.get(i);
/* 273 */       if (reader instanceof SegmentReader) {
/* 274 */         SegmentReader segmentReader = (SegmentReader)reader;
/* 275 */         for (int j = 0; j < segmentReader.getFieldInfos().size(); j++) {
/* 276 */           FieldInfo fi = segmentReader.getFieldInfos().fieldInfo(j);
/* 277 */           this.fieldInfos.add(fi.name, fi.isIndexed, fi.storeTermVector, fi.storePositionWithTermVector, fi.storeOffsetWithTermVector, !reader.hasNorms(fi.name), fi.storePayloads, fi.omitTf);
/*     */         } 
/*     */       } else {
/* 280 */         addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, false);
/* 281 */         addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, false);
/* 282 */         addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, false);
/* 283 */         addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR), true, false, false, false, false);
/* 284 */         addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.OMIT_TF), false, false, false, false, true);
/* 285 */         addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.STORES_PAYLOADS), false, false, false, true, false);
/* 286 */         addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.INDEXED), false, false, false, false, false);
/* 287 */         this.fieldInfos.add(reader.getFieldNames(IndexReader.FieldOption.UNINDEXED), false);
/*     */       } 
/*     */     } 
/* 290 */     this.fieldInfos.write(this.directory, this.segment + "".fnm"");
/*     */     
/* 292 */     int docCount = 0;
/*     */     
/* 294 */     setMatchingSegmentReaders();
/*     */     
/* 296 */     if (this.mergeDocStores) {
/*     */ 
/*     */ 
/*     */       
/* 300 */       FieldSelector fieldSelectorMerge = new FieldSelector() { private final SegmentMerger this$0;
/*     */           
/* 302 */           public FieldSelectorResult accept(String fieldName) { return FieldSelectorResult.LOAD_FOR_MERGE; }
/*     */            }
/*     */         ;
/*     */ 
/*     */       
/* 307 */       FieldsWriter fieldsWriter = new FieldsWriter(this.directory, this.segment, this.fieldInfos);
/*     */       
/*     */       try {
/* 310 */         for (int i = 0; i < this.readers.size(); i++) {
/* 311 */           boolean hasMatchingReader; FieldsReader matchingFieldsReader; IndexReader reader = this.readers.get(i);
/* 312 */           SegmentReader matchingSegmentReader = this.matchingSegmentReaders[i];
/*     */ 
/*     */           
/* 315 */           if (matchingSegmentReader != null) {
/* 316 */             FieldsReader fieldsReader = matchingSegmentReader.getFieldsReader();
/* 317 */             if (fieldsReader != null && !fieldsReader.canReadRawDocs()) {
/* 318 */               matchingFieldsReader = null;
/* 319 */               hasMatchingReader = false;
/*     */             } else {
/* 321 */               matchingFieldsReader = fieldsReader;
/* 322 */               hasMatchingReader = true;
/*     */             } 
/*     */           } else {
/* 325 */             hasMatchingReader = false;
/* 326 */             matchingFieldsReader = null;
/*     */           } 
/* 328 */           int maxDoc = reader.maxDoc();
/* 329 */           boolean hasDeletions = reader.hasDeletions();
/* 330 */           for (int j = 0; j < maxDoc; ) {
/* 331 */             if (!hasDeletions || !reader.isDeleted(j)) {
/* 332 */               if (hasMatchingReader) {
/*     */ 
/*     */ 
/*     */                 
/* 336 */                 int start = j;
/* 337 */                 int numDocs = 0;
/*     */                 do {
/* 339 */                   j++;
/* 340 */                   numDocs++;
/* 341 */                   if (j >= maxDoc)
/*     */                     break; 
/* 343 */                   if (hasDeletions && matchingSegmentReader.isDeleted(j)) {
/* 344 */                     j++;
/*     */                     break;
/*     */                   } 
/* 347 */                 } while (numDocs < 4192);
/*     */                 
/* 349 */                 IndexInput stream = matchingFieldsReader.rawDocs(this.rawDocLengths, start, numDocs);
/* 350 */                 fieldsWriter.addRawDocuments(stream, this.rawDocLengths, numDocs);
/* 351 */                 docCount += numDocs;
/* 352 */                 if (this.checkAbort != null) {
/* 353 */                   this.checkAbort.work((300 * numDocs));
/*     */                 }
/*     */                 
/*     */                 continue;
/*     */               } 
/*     */               
/* 359 */               Document doc = reader.document(j, fieldSelectorMerge);
/* 360 */               fieldsWriter.addDocument(doc);
/* 361 */               j++;
/* 362 */               docCount++;
/* 363 */               if (this.checkAbort != null)
/* 364 */                 this.checkAbort.work(300.0D); 
/*     */               continue;
/*     */             } 
/* 367 */             j++;
/*     */           } 
/*     */         } 
/*     */       } finally {
/* 371 */         fieldsWriter.close();
/*     */       } 
/*     */       
/* 374 */       long fdxFileLength = this.directory.fileLength(this.segment + ""."" + ""fdx"");
/*     */       
/* 376 */       if ((4 + docCount * 8) != fdxFileLength)
/*     */       {
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 382 */         throw new RuntimeException(""mergeFields produced an invalid result: docCount is "" + docCount + "" but fdx file size is "" + fdxFileLength + ""; now aborting this merge to prevent index corruption"");
/*     */       
/*     */       }
/*     */     }
/*     */     else {
/*     */       
/* 388 */       for (int i = 0; i < this.readers.size(); i++)
/* 389 */         docCount += ((IndexReader)this.readers.get(i)).numDocs(); 
/*     */     } 
/* 391 */     return docCount;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void mergeVectors() throws IOException {
/* 399 */     TermVectorsWriter termVectorsWriter = new TermVectorsWriter(this.directory, this.segment, this.fieldInfos);
/*     */ 
/*     */     
/*     */     try {
/* 403 */       for (int r = 0; r < this.readers.size(); r++) {
/* 404 */         boolean hasMatchingReader; TermVectorsReader matchingVectorsReader; SegmentReader matchingSegmentReader = this.matchingSegmentReaders[r];
/*     */ 
/*     */         
/* 407 */         if (matchingSegmentReader != null) {
/* 408 */           matchingVectorsReader = matchingSegmentReader.termVectorsReaderOrig;
/*     */ 
/*     */ 
/*     */           
/* 412 */           if (matchingVectorsReader != null && !matchingVectorsReader.canReadRawDocs()) {
/* 413 */             matchingVectorsReader = null;
/* 414 */             hasMatchingReader = false;
/*     */           } else {
/* 416 */             hasMatchingReader = (matchingVectorsReader != null);
/*     */           } 
/*     */         } else {
/* 419 */           hasMatchingReader = false;
/* 420 */           matchingVectorsReader = null;
/*     */         } 
/* 422 */         IndexReader reader = this.readers.get(r);
/* 423 */         boolean hasDeletions = reader.hasDeletions();
/* 424 */         int maxDoc = reader.maxDoc();
/* 425 */         for (int docNum = 0; docNum < maxDoc; ) {
/*     */           
/* 427 */           if (!hasDeletions || !reader.isDeleted(docNum)) {
/* 428 */             if (hasMatchingReader) {
/*     */ 
/*     */ 
/*     */               
/* 432 */               int start = docNum;
/* 433 */               int numDocs = 0;
/*     */               do {
/* 435 */                 docNum++;
/* 436 */                 numDocs++;
/* 437 */                 if (docNum >= maxDoc)
/*     */                   break; 
/* 439 */                 if (hasDeletions && matchingSegmentReader.isDeleted(docNum)) {
/* 440 */                   docNum++;
/*     */                   break;
/*     */                 } 
/* 443 */               } while (numDocs < 4192);
/*     */               
/* 445 */               matchingVectorsReader.rawDocs(this.rawDocLengths, this.rawDocLengths2, start, numDocs);
/* 446 */               termVectorsWriter.addRawDocuments(matchingVectorsReader, this.rawDocLengths, this.rawDocLengths2, numDocs);
/* 447 */               if (this.checkAbort != null) {
/* 448 */                 this.checkAbort.work((300 * numDocs));
/*     */               }
/*     */               
/*     */               continue;
/*     */             } 
/*     */             
/* 454 */             TermFreqVector[] vectors = reader.getTermFreqVectors(docNum);
/* 455 */             termVectorsWriter.addAllDocVectors(vectors);
/* 456 */             docNum++;
/* 457 */             if (this.checkAbort != null)
/* 458 */               this.checkAbort.work(300.0D); 
/*     */             continue;
/*     */           } 
/* 461 */           docNum++;
/*     */         } 
/*     */       } 
/*     */     } finally {
/* 465 */       termVectorsWriter.close();
/*     */     } 
/*     */     
/* 468 */     long tvxSize = this.directory.fileLength(this.segment + ""."" + ""tvx"");
/*     */     
/* 470 */     if ((4 + this.mergedDocs * 16) != tvxSize)
/*     */     {
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 476 */       throw new RuntimeException(""mergeVectors produced an invalid result: mergedDocs is "" + this.mergedDocs + "" but tvx size is "" + tvxSize + ""; now aborting this merge to prevent index corruption""); } 
/*     */   }
/*     */   
/* 479 */   SegmentMerger(Directory dir, String name) { this.freqOutput = null;
/* 480 */     this.proxOutput = null;
/* 481 */     this.termInfosWriter = null;
/*     */ 
/*     */     
/* 484 */     this.queue = null;
/* 485 */     this.skipListWriter = null;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 562 */     this.termInfo = new TermInfo(); this.directory = dir; this.segment = name; } SegmentMerger(IndexWriter writer, String name, MergePolicy.OneMerge merge) { this.freqOutput = null; this.proxOutput = null; this.termInfosWriter = null; this.queue = null; this.skipListWriter = null; this.termInfo = new TermInfo(); this.directory = writer.getDirectory(); this.segment = name; if (merge != null)
/*     */       this.checkAbort = new CheckAbort(merge, this.directory);  this.termIndexInterval = writer.getTermIndexInterval(); } private final void mergeTerms() throws CorruptIndexException, IOException { try {
/*     */       this.freqOutput = this.directory.createOutput(this.segment + "".frq""); if (hasProx())
/*     */         this.proxOutput = this.directory.createOutput(this.segment + "".prx"");  this.termInfosWriter = new TermInfosWriter(this.directory, this.segment, this.fieldInfos, this.termIndexInterval); this.skipInterval = this.termInfosWriter.skipInterval; this.maxSkipLevels = this.termInfosWriter.maxSkipLevels; this.skipListWriter = new DefaultSkipListWriter(this.skipInterval, this.maxSkipLevels, this.mergedDocs, this.freqOutput, this.proxOutput); this.queue = new SegmentMergeQueue(this.readers.size()); mergeTermInfos();
/*     */     } finally {
/*     */       if (this.freqOutput != null)
/*     */         this.freqOutput.close();  if (this.proxOutput != null)
/*     */         this.proxOutput.close();  if (this.termInfosWriter != null)
/*     */         this.termInfosWriter.close(); 
/*     */       if (this.queue != null)
/*     */         this.queue.close(); 
/*     */     }  }
/*     */   private final int mergeTermInfo(SegmentMergeInfo[] smis, int n) throws CorruptIndexException, IOException { int df;
/* 575 */     long proxPointer, freqPointer = this.freqOutput.getFilePointer();
/*     */     
/* 577 */     if (this.proxOutput != null) {
/* 578 */       proxPointer = this.proxOutput.getFilePointer();
/*     */     } else {
/* 580 */       proxPointer = 0L;
/*     */     } 
/*     */     
/* 583 */     if ((this.fieldInfos.fieldInfo((smis[0]).term.field)).omitTf) {
/* 584 */       df = appendPostingsNoTf(smis, n);
/*     */     } else {
/* 586 */       df = appendPostings(smis, n);
/*     */     } 
/*     */     
/* 589 */     long skipPointer = this.skipListWriter.writeSkip(this.freqOutput);
/*     */     
/* 591 */     if (df > 0) {
/*     */       
/* 593 */       this.termInfo.set(df, freqPointer, proxPointer, (int)(skipPointer - freqPointer));
/* 594 */       this.termInfosWriter.add((smis[0]).term, this.termInfo);
/*     */     } 
/*     */     
/* 597 */     return df; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 603 */   int[][] getDocMaps() { return this.docMaps; }
/*     */   private final void mergeTermInfos() throws CorruptIndexException, IOException { int base = 0; int readerCount = this.readers.size(); for (int i = 0; i < readerCount; i++) { IndexReader reader = this.readers.get(i); TermEnum termEnum = reader.terms(); SegmentMergeInfo smi = new SegmentMergeInfo(base, termEnum, reader); int[] docMap = smi.getDocMap(); if (docMap != null) { if (this.docMaps == null) { this.docMaps = new int[readerCount][]; this.delCounts = new int[readerCount]; }  this.docMaps[i] = docMap; this.delCounts[i] = smi.reader.maxDoc() - smi.reader.numDocs(); }  base += reader.numDocs(); if (smi.next()) { this.queue.put(smi); } else { smi.close(); }  }  SegmentMergeInfo[] match = new SegmentMergeInfo[this.readers.size()]; while (this.queue.size() > 0) { int matchSize = 0; match[matchSize++] = (SegmentMergeInfo)this.queue.pop(); Term term = (match[0]).term; SegmentMergeInfo top = (SegmentMergeInfo)this.queue.top(); while (top != null && term.compareTo(top.term) == 0) { match[matchSize++] = (SegmentMergeInfo)this.queue.pop(); top = (SegmentMergeInfo)this.queue.top(); }  int df = mergeTermInfo(match, matchSize); if (this.checkAbort != null)
/*     */         this.checkAbort.work(df / 3.0D);  while (matchSize > 0) { SegmentMergeInfo smi = match[--matchSize]; if (smi.next()) { this.queue.put(smi); continue; }  smi.close(); }
/*     */        }
/* 607 */      } int[] getDelCounts() { return this.delCounts; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int appendPostings(SegmentMergeInfo[] smis, int n) throws CorruptIndexException, IOException {
/* 622 */     int lastDoc = 0;
/* 623 */     int df = 0;
/* 624 */     this.skipListWriter.resetSkip();
/* 625 */     boolean storePayloads = (this.fieldInfos.fieldInfo((smis[0]).term.field)).storePayloads;
/* 626 */     int lastPayloadLength = -1;
/* 627 */     for (int i = 0; i < n; i++) {
/* 628 */       SegmentMergeInfo smi = smis[i];
/* 629 */       TermPositions postings = smi.getPositions();
/* 630 */       assert postings != null;
/* 631 */       int base = smi.base;
/* 632 */       int[] docMap = smi.getDocMap();
/* 633 */       postings.seek(smi.termEnum);
/* 634 */       while (postings.next()) {
/* 635 */         int doc = postings.doc();
/* 636 */         if (docMap != null)
/* 637 */           doc = docMap[doc]; 
/* 638 */         doc += base;
/*     */         
/* 640 */         if (doc < 0 || (df > 0 && doc <= lastDoc)) {
/* 641 */           throw new CorruptIndexException(""docs out of order ("" + doc + "" <= "" + lastDoc + "" )"");
/*     */         }
/*     */         
/* 644 */         df++;
/*     */         
/* 646 */         if (df % this.skipInterval == 0) {
/* 647 */           this.skipListWriter.setSkipData(lastDoc, storePayloads, lastPayloadLength);
/* 648 */           this.skipListWriter.bufferSkip(df);
/*     */         } 
/*     */         
/* 651 */         int docCode = doc - lastDoc << 1;
/* 652 */         lastDoc = doc;
/*     */         
/* 654 */         int freq = postings.freq();
/* 655 */         if (freq == 1) {
/* 656 */           this.freqOutput.writeVInt(docCode | 0x1);
/*     */         } else {
/* 658 */           this.freqOutput.writeVInt(docCode);
/* 659 */           this.freqOutput.writeVInt(freq);
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 665 */         int lastPosition = 0;
/* 666 */         for (int j = 0; j < freq; j++) {
/* 667 */           int position = postings.nextPosition();
/* 668 */           int delta = position - lastPosition;
/* 669 */           if (storePayloads) {
/* 670 */             int payloadLength = postings.getPayloadLength();
/* 671 */             if (payloadLength == lastPayloadLength) {
/* 672 */               this.proxOutput.writeVInt(delta * 2);
/*     */             } else {
/* 674 */               this.proxOutput.writeVInt(delta * 2 + 1);
/* 675 */               this.proxOutput.writeVInt(payloadLength);
/* 676 */               lastPayloadLength = payloadLength;
/*     */             } 
/* 678 */             if (payloadLength > 0) {
/* 679 */               if (this.payloadBuffer == null || this.payloadBuffer.length < payloadLength) {
/* 680 */                 this.payloadBuffer = new byte[payloadLength];
/*     */               }
/* 682 */               postings.getPayload(this.payloadBuffer, 0);
/* 683 */               this.proxOutput.writeBytes(this.payloadBuffer, 0, payloadLength);
/*     */             } 
/*     */           } else {
/* 686 */             this.proxOutput.writeVInt(delta);
/*     */           } 
/* 688 */           lastPosition = position;
/*     */         } 
/*     */       } 
/*     */     } 
/* 692 */     return df;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int appendPostingsNoTf(SegmentMergeInfo[] smis, int n) throws CorruptIndexException, IOException {
/* 706 */     int lastDoc = 0;
/* 707 */     int df = 0;
/* 708 */     this.skipListWriter.resetSkip();
/* 709 */     int lastPayloadLength = -1;
/* 710 */     for (int i = 0; i < n; i++) {
/* 711 */       SegmentMergeInfo smi = smis[i];
/* 712 */       TermPositions postings = smi.getPositions();
/* 713 */       assert postings != null;
/* 714 */       int base = smi.base;
/* 715 */       int[] docMap = smi.getDocMap();
/* 716 */       postings.seek(smi.termEnum);
/* 717 */       while (postings.next()) {
/* 718 */         int doc = postings.doc();
/* 719 */         if (docMap != null)
/* 720 */           doc = docMap[doc]; 
/* 721 */         doc += base;
/*     */         
/* 723 */         if (doc < 0 || (df > 0 && doc <= lastDoc)) {
/* 724 */           throw new CorruptIndexException(""docs out of order ("" + doc + "" <= "" + lastDoc + "" )"");
/*     */         }
/*     */         
/* 727 */         df++;
/*     */         
/* 729 */         if (df % this.skipInterval == 0) {
/* 730 */           this.skipListWriter.setSkipData(lastDoc, false, lastPayloadLength);
/* 731 */           this.skipListWriter.bufferSkip(df);
/*     */         } 
/*     */         
/* 734 */         int docCode = doc - lastDoc;
/* 735 */         lastDoc = doc;
/* 736 */         this.freqOutput.writeVInt(docCode);
/*     */       } 
/*     */     } 
/* 739 */     return df;
/*     */   }
/*     */   
/*     */   private void mergeNorms() throws IOException {
/* 743 */     byte[] normBuffer = null;
/* 744 */     IndexOutput output = null;
/*     */     try {
/* 746 */       for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 747 */         FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 748 */         if (fi.isIndexed && !fi.omitNorms) {
/* 749 */           if (output == null) {
/* 750 */             output = this.directory.createOutput(this.segment + ""."" + ""nrm"");
/* 751 */             output.writeBytes(NORMS_HEADER, NORMS_HEADER.length);
/*     */           } 
/* 753 */           for (int j = 0; j < this.readers.size(); j++) {
/* 754 */             IndexReader reader = this.readers.get(j);
/* 755 */             int maxDoc = reader.maxDoc();
/* 756 */             if (normBuffer == null || normBuffer.length < maxDoc)
/*     */             {
/* 758 */               normBuffer = new byte[maxDoc];
/*     */             }
/* 760 */             reader.norms(fi.name, normBuffer, 0);
/* 761 */             if (!reader.hasDeletions()) {
/*     */               
/* 763 */               output.writeBytes(normBuffer, maxDoc);
/*     */             }
/*     */             else {
/*     */               
/* 767 */               for (int k = 0; k < maxDoc; k++) {
/* 768 */                 if (!reader.isDeleted(k)) {
/* 769 */                   output.writeByte(normBuffer[k]);
/*     */                 }
/*     */               } 
/*     */             } 
/* 773 */             if (this.checkAbort != null)
/* 774 */               this.checkAbort.work(maxDoc); 
/*     */           } 
/*     */         } 
/*     */       } 
/*     */     } finally {
/* 779 */       if (output != null)
/* 780 */         output.close(); 
/*     */     } 
/*     */   }
/*     */   
/*     */   static final class CheckAbort {
/*     */     private double workCount;
/*     */     private MergePolicy.OneMerge merge;
/*     */     private Directory dir;
/*     */     
/*     */     public CheckAbort(MergePolicy.OneMerge merge, Directory dir) {
/* 790 */       this.merge = merge;
/* 791 */       this.dir = dir;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public void work(double units) throws MergePolicy.MergeAbortedException {
/* 803 */       this.workCount += units;
/* 804 */       if (this.workCount >= 10000.0D) {
/* 805 */         this.merge.checkAborted(this.dir);
/* 806 */         this.workCount = 0.0D;
/*     */       } 
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentMerger.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentReader,"/*      */ package org.apache.lucene.index;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.util.ArrayList;
/*      */ import java.util.Arrays;
/*      */ import java.util.Collection;
/*      */ import java.util.HashMap;
/*      */ import java.util.HashSet;
/*      */ import java.util.Iterator;
/*      */ import java.util.List;
/*      */ import java.util.Map;
/*      */ import java.util.Set;
/*      */ import org.apache.lucene.document.Document;
/*      */ import org.apache.lucene.document.FieldSelector;
/*      */ import org.apache.lucene.search.DefaultSimilarity;
/*      */ import org.apache.lucene.store.Directory;
/*      */ import org.apache.lucene.store.IndexInput;
/*      */ import org.apache.lucene.store.IndexOutput;
/*      */ import org.apache.lucene.util.BitVector;
/*      */ import org.apache.lucene.util.CloseableThreadLocal;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ class SegmentReader
/*      */   extends DirectoryIndexReader
/*      */ {
/*      */   private String segment;
/*      */   private SegmentInfo si;
/*      */   private int readBufferSize;
/*      */   FieldInfos fieldInfos;
/*      */   private FieldsReader fieldsReader;
/*      */   TermInfosReader tis;
/*   53 */   TermVectorsReader termVectorsReaderOrig = null;
/*   54 */   CloseableThreadLocal termVectorsLocal = new CloseableThreadLocal();
/*      */   
/*   56 */   BitVector deletedDocs = null;
/*      */   
/*      */   private boolean deletedDocsDirty = false;
/*      */   
/*      */   private boolean normsDirty = false;
/*      */   
/*      */   private boolean undeleteAll = false;
/*      */   
/*      */   private int pendingDeleteCount;
/*      */   
/*      */   private boolean rollbackDeletedDocsDirty = false;
/*      */   
/*      */   private boolean rollbackNormsDirty = false;
/*      */   private boolean rollbackUndeleteAll = false;
/*      */   private int rollbackPendingDeleteCount;
/*      */   private boolean readOnly;
/*      */   IndexInput freqStream;
/*      */   IndexInput proxStream;
/*      */   private IndexInput singleNormStream;
/*   75 */   CompoundFileReader cfsReader = null;
/*   76 */   CompoundFileReader storeCFSReader = null;
/*      */ 
/*      */ 
/*      */   
/*   80 */   private SegmentReader referencedSegmentReader = null;
/*      */   private class Norm { volatile int refCount; boolean useSingleNormStream;
/*      */     private IndexInput in;
/*      */     private byte[] bytes;
/*      */     private boolean dirty;
/*      */     
/*      */     public synchronized void incRef() {
/*   87 */       assert this.refCount > 0;
/*   88 */       this.refCount++;
/*      */     }
/*      */     private int number; private long normSeek; private boolean rollbackDirty; static final boolean $assertionsDisabled; private final SegmentReader this$0;
/*      */     public synchronized void decRef() throws IOException {
/*   92 */       assert this.refCount > 0;
/*   93 */       if (this.refCount == 1) {
/*   94 */         close();
/*      */       }
/*   96 */       this.refCount--;
/*      */     }
/*      */ 
/*      */ 
/*      */     
/*      */     public Norm(IndexInput in, boolean useSingleNormStream, int number, long normSeek) {
/*  102 */       this.refCount = 1;
/*  103 */       this.in = in;
/*  104 */       this.number = number;
/*  105 */       this.normSeek = normSeek;
/*  106 */       this.useSingleNormStream = useSingleNormStream;
/*      */     }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     private void reWrite(SegmentInfo si) throws IOException {
/*  118 */       si.advanceNormGen(this.number);
/*  119 */       IndexOutput out = SegmentReader.this.directory().createOutput(si.getNormFileName(this.number));
/*      */       try {
/*  121 */         out.writeBytes(this.bytes, SegmentReader.this.maxDoc());
/*      */       } finally {
/*  123 */         out.close();
/*      */       } 
/*  125 */       this.dirty = false;
/*      */     }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     private synchronized void close() throws IOException {
/*  133 */       if (this.in != null && !this.useSingleNormStream) {
/*  134 */         this.in.close();
/*      */       }
/*  136 */       this.in = null;
/*      */     } }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void incRef() {
/*  145 */     super.incRef();
/*  146 */     Iterator it = this.norms.values().iterator();
/*  147 */     while (it.hasNext()) {
/*  148 */       Norm norm = it.next();
/*  149 */       norm.incRef();
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  160 */   private synchronized void incRefReaderNotNorms() { super.incRef(); }
/*      */ 
/*      */   
/*      */   public synchronized void decRef() throws IOException {
/*  164 */     super.decRef();
/*  165 */     Iterator it = this.norms.values().iterator();
/*  166 */     while (it.hasNext()) {
/*  167 */       Norm norm = it.next();
/*  168 */       norm.decRef();
/*      */     } 
/*      */   }
/*      */ 
/*      */   
/*  173 */   private synchronized void decRefReaderNotNorms() throws IOException { super.decRef(); }
/*      */ 
/*      */   
/*  176 */   Map norms = new HashMap(); private static Class IMPL; private static Class READONLY_IMPL;
/*      */   private byte[] ones;
/*      */   static final boolean $assertionsDisabled;
/*      */   
/*      */   static  {
/*      */     try {
/*  182 */       String name = System.getProperty(""org.apache.lucene.SegmentReader.class"", SegmentReader.class.getName());
/*      */ 
/*      */       
/*  185 */       IMPL = Class.forName(name);
/*  186 */     } catch (ClassNotFoundException e) {
/*  187 */       throw new RuntimeException(""cannot load SegmentReader class: "" + e, e);
/*  188 */     } catch (SecurityException se) {
/*      */       try {
/*  190 */         IMPL = Class.forName(SegmentReader.class.getName());
/*  191 */       } catch (ClassNotFoundException e) {
/*  192 */         throw new RuntimeException(""cannot load default SegmentReader class: "" + e, e);
/*      */       } 
/*      */     } 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     try {
/*  200 */       String name = System.getProperty(""org.apache.lucene.ReadOnlySegmentReader.class"", ReadOnlySegmentReader.class.getName());
/*      */ 
/*      */       
/*  203 */       READONLY_IMPL = Class.forName(name);
/*  204 */     } catch (ClassNotFoundException e) {
/*  205 */       throw new RuntimeException(""cannot load ReadOnlySegmentReader class: "" + e, e);
/*  206 */     } catch (SecurityException se) {
/*      */       try {
/*  208 */         READONLY_IMPL = Class.forName(ReadOnlySegmentReader.class.getName());
/*  209 */       } catch (ClassNotFoundException e) {
/*  210 */         throw new RuntimeException(""cannot load default ReadOnlySegmentReader class: "" + e, e);
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  220 */   public static SegmentReader get(SegmentInfo si) throws CorruptIndexException, IOException { return get(false, si.dir, si, null, false, false, 1024, true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  228 */   public static SegmentReader get(boolean readOnly, SegmentInfo si) throws CorruptIndexException, IOException { return get(readOnly, si.dir, si, null, false, false, 1024, true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  236 */   static SegmentReader get(SegmentInfo si, boolean doOpenStores) throws CorruptIndexException, IOException { return get(false, si.dir, si, null, false, false, 1024, doOpenStores); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  244 */   public static SegmentReader get(SegmentInfo si, int readBufferSize) throws CorruptIndexException, IOException { return get(false, si.dir, si, null, false, false, readBufferSize, true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  252 */   static SegmentReader get(SegmentInfo si, int readBufferSize, boolean doOpenStores) throws CorruptIndexException, IOException { return get(false, si.dir, si, null, false, false, readBufferSize, doOpenStores); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  260 */   static SegmentReader get(boolean readOnly, SegmentInfo si, int readBufferSize, boolean doOpenStores) throws CorruptIndexException, IOException { return get(readOnly, si.dir, si, null, false, false, readBufferSize, doOpenStores); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  269 */   public static SegmentReader get(boolean readOnly, SegmentInfos sis, SegmentInfo si, boolean closeDir) throws CorruptIndexException, IOException { return get(readOnly, si.dir, si, sis, closeDir, true, 1024, true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  281 */   public static SegmentReader get(Directory dir, SegmentInfo si, SegmentInfos sis, boolean closeDir, boolean ownDir, int readBufferSize) throws CorruptIndexException, IOException { return get(false, dir, si, sis, closeDir, ownDir, readBufferSize, true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static SegmentReader get(boolean readOnly, Directory dir, SegmentInfo si, SegmentInfos sis, boolean closeDir, boolean ownDir, int readBufferSize, boolean doOpenStores) throws CorruptIndexException, IOException {
/*      */     SegmentReader instance;
/*      */     try {
/*  298 */       if (readOnly)
/*  299 */       { instance = READONLY_IMPL.newInstance(); }
/*      */       else
/*  301 */       { instance = IMPL.newInstance(); } 
/*  302 */     } catch (Exception e) {
/*  303 */       throw new RuntimeException(""cannot load SegmentReader class: "" + e, e);
/*      */     } 
/*  305 */     instance.init(dir, sis, closeDir, readOnly);
/*  306 */     instance.initialize(si, readBufferSize, doOpenStores);
/*  307 */     return instance;
/*      */   }
/*      */   
/*      */   private void initialize(SegmentInfo si, int readBufferSize, boolean doOpenStores) throws CorruptIndexException, IOException {
/*  311 */     this.segment = si.name;
/*  312 */     this.si = si;
/*  313 */     this.readBufferSize = readBufferSize;
/*      */     
/*  315 */     boolean success = false;
/*      */     
/*      */     try {
/*      */       String fieldsSegment;
/*  319 */       Directory storeDir, cfsDir = directory();
/*  320 */       if (si.getUseCompoundFile()) {
/*  321 */         this.cfsReader = new CompoundFileReader(directory(), this.segment + ""."" + ""cfs"", readBufferSize);
/*  322 */         cfsDir = this.cfsReader;
/*      */       } 
/*      */ 
/*      */ 
/*      */       
/*  327 */       if (doOpenStores) {
/*  328 */         if (si.getDocStoreOffset() != -1) {
/*  329 */           if (si.getDocStoreIsCompoundFile()) {
/*  330 */             this.storeCFSReader = new CompoundFileReader(directory(), si.getDocStoreSegment() + ""."" + ""cfx"", readBufferSize);
/*  331 */             storeDir = this.storeCFSReader;
/*      */           } else {
/*  333 */             storeDir = directory();
/*      */           } 
/*      */         } else {
/*  336 */           storeDir = cfsDir;
/*      */         } 
/*      */       } else {
/*  339 */         storeDir = null;
/*      */       } 
/*  341 */       this.fieldInfos = new FieldInfos(cfsDir, this.segment + "".fnm"");
/*      */       
/*  343 */       boolean anyProx = false;
/*  344 */       int numFields = this.fieldInfos.size();
/*  345 */       for (int i = 0; !anyProx && i < numFields; i++) {
/*  346 */         if (!(this.fieldInfos.fieldInfo(i)).omitTf) {
/*  347 */           anyProx = true;
/*      */         }
/*      */       } 
/*      */       
/*  351 */       if (si.getDocStoreOffset() != -1) {
/*  352 */         fieldsSegment = si.getDocStoreSegment();
/*      */       } else {
/*  354 */         fieldsSegment = this.segment;
/*      */       } 
/*  356 */       if (doOpenStores) {
/*  357 */         this.fieldsReader = new FieldsReader(storeDir, fieldsSegment, this.fieldInfos, readBufferSize, si.getDocStoreOffset(), si.docCount);
/*      */ 
/*      */ 
/*      */         
/*  361 */         if (si.getDocStoreOffset() == -1 && this.fieldsReader.size() != si.docCount) {
/*  362 */           throw new CorruptIndexException(""doc counts differ for segment "" + si.name + "": fieldsReader shows "" + this.fieldsReader.size() + "" but segmentInfo shows "" + si.docCount);
/*      */         }
/*      */       } 
/*      */       
/*  366 */       this.tis = new TermInfosReader(cfsDir, this.segment, this.fieldInfos, readBufferSize);
/*      */       
/*  368 */       loadDeletedDocs();
/*      */ 
/*      */ 
/*      */       
/*  372 */       this.freqStream = cfsDir.openInput(this.segment + "".frq"", readBufferSize);
/*  373 */       if (anyProx)
/*  374 */         this.proxStream = cfsDir.openInput(this.segment + "".prx"", readBufferSize); 
/*  375 */       openNorms(cfsDir, readBufferSize);
/*      */       
/*  377 */       if (doOpenStores && this.fieldInfos.hasVectors()) {
/*      */         String vectorsSegment;
/*  379 */         if (si.getDocStoreOffset() != -1) {
/*  380 */           vectorsSegment = si.getDocStoreSegment();
/*      */         } else {
/*  382 */           vectorsSegment = this.segment;
/*  383 */         }  this.termVectorsReaderOrig = new TermVectorsReader(storeDir, vectorsSegment, this.fieldInfos, readBufferSize, si.getDocStoreOffset(), si.docCount);
/*      */       } 
/*  385 */       success = true;
/*      */ 
/*      */     
/*      */     }
/*      */     finally {
/*      */ 
/*      */ 
/*      */       
/*  393 */       if (!success) {
/*  394 */         doClose();
/*      */       }
/*      */     } 
/*      */   }
/*      */ 
/*      */   
/*      */   private void loadDeletedDocs() throws IOException {
/*  401 */     if (hasDeletions(this.si)) {
/*  402 */       this.deletedDocs = new BitVector(directory(), this.si.getDelFileName());
/*      */ 
/*      */       
/*  405 */       assert this.si.getDelCount() == this.deletedDocs.count() : ""delete count mismatch: info="" + this.si.getDelCount() + "" vs BitVector="" + this.deletedDocs.count();
/*      */ 
/*      */ 
/*      */ 
/*      */       
/*  410 */       assert this.si.getDelCount() <= maxDoc() : ""delete count mismatch: "" + this.deletedDocs.count() + "") exceeds max doc ("" + maxDoc() + "") for segment "" + this.si.name;
/*      */     } else {
/*      */       
/*  413 */       assert this.si.getDelCount() == 0;
/*      */     } 
/*      */   }
/*      */   
/*      */   protected synchronized DirectoryIndexReader doReopen(SegmentInfos infos) throws CorruptIndexException, IOException {
/*      */     DirectoryIndexReader newReader;
/*  419 */     if (infos.size() == 1) {
/*  420 */       SegmentInfo si = infos.info(0);
/*  421 */       if (this.segment.equals(si.name) && si.getUseCompoundFile() == this.si.getUseCompoundFile()) {
/*  422 */         newReader = reopenSegment(si);
/*      */       }
/*      */       else {
/*      */         
/*  426 */         newReader = get(this.readOnly, infos, infos.info(0), false);
/*      */       } 
/*      */     } else {
/*  429 */       if (this.readOnly) {
/*  430 */         return new ReadOnlyMultiSegmentReader(this.directory, infos, this.closeDirectory, new SegmentReader[] { this }, null, null);
/*      */       }
/*  432 */       return new MultiSegmentReader(this.directory, infos, this.closeDirectory, new SegmentReader[] { this }, null, null, false);
/*      */     } 
/*      */     
/*  435 */     return newReader;
/*      */   }
/*      */   synchronized SegmentReader reopenSegment(SegmentInfo si) throws CorruptIndexException, IOException {
/*      */     SegmentReader clone;
/*  439 */     boolean deletionsUpToDate = (this.si.hasDeletions() == si.hasDeletions() && (!si.hasDeletions() || this.si.getDelFileName().equals(si.getDelFileName())));
/*      */     
/*  441 */     boolean normsUpToDate = true;
/*      */ 
/*      */     
/*  444 */     boolean[] fieldNormsChanged = new boolean[this.fieldInfos.size()];
/*  445 */     if (normsUpToDate) {
/*  446 */       for (int i = 0; i < this.fieldInfos.size(); i++) {
/*  447 */         if (!this.si.getNormFileName(i).equals(si.getNormFileName(i))) {
/*  448 */           normsUpToDate = false;
/*  449 */           fieldNormsChanged[i] = true;
/*      */         } 
/*      */       } 
/*      */     }
/*      */     
/*  454 */     if (normsUpToDate && deletionsUpToDate) {
/*  455 */       return this;
/*      */     }
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  461 */     if (this.readOnly) {
/*  462 */       clone = new ReadOnlySegmentReader();
/*      */     } else {
/*  464 */       clone = new SegmentReader();
/*      */     } 
/*  466 */     boolean success = false; try {
/*      */       String fieldsSegment;
/*  468 */       clone.readOnly = this.readOnly;
/*  469 */       clone.directory = this.directory;
/*  470 */       clone.si = si;
/*  471 */       clone.segment = this.segment;
/*  472 */       clone.readBufferSize = this.readBufferSize;
/*  473 */       clone.cfsReader = this.cfsReader;
/*  474 */       clone.storeCFSReader = this.storeCFSReader;
/*      */       
/*  476 */       clone.fieldInfos = this.fieldInfos;
/*  477 */       clone.tis = this.tis;
/*  478 */       clone.freqStream = this.freqStream;
/*  479 */       clone.proxStream = this.proxStream;
/*  480 */       clone.termVectorsReaderOrig = this.termVectorsReaderOrig;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/*  488 */       Directory storeDir = directory();
/*      */       
/*  490 */       if (si.getDocStoreOffset() != -1) {
/*  491 */         fieldsSegment = si.getDocStoreSegment();
/*  492 */         if (this.storeCFSReader != null) {
/*  493 */           storeDir = this.storeCFSReader;
/*      */         }
/*      */       } else {
/*  496 */         fieldsSegment = this.segment;
/*  497 */         if (this.cfsReader != null) {
/*  498 */           storeDir = this.cfsReader;
/*      */         }
/*      */       } 
/*      */       
/*  502 */       if (this.fieldsReader != null) {
/*  503 */         clone.fieldsReader = new FieldsReader(storeDir, fieldsSegment, this.fieldInfos, this.readBufferSize, si.getDocStoreOffset(), si.docCount);
/*      */       }
/*      */ 
/*      */ 
/*      */       
/*  508 */       if (!deletionsUpToDate) {
/*      */         
/*  510 */         clone.deletedDocs = null;
/*  511 */         clone.loadDeletedDocs();
/*      */       } else {
/*  513 */         clone.deletedDocs = this.deletedDocs;
/*      */       } 
/*      */       
/*  516 */       clone.norms = new HashMap();
/*  517 */       if (!normsUpToDate) {
/*      */         
/*  519 */         for (int i = 0; i < fieldNormsChanged.length; i++) {
/*      */           
/*  521 */           if (!fieldNormsChanged[i]) {
/*  522 */             String curField = (this.fieldInfos.fieldInfo(i)).name;
/*  523 */             Norm norm = (Norm)this.norms.get(curField);
/*  524 */             norm.incRef();
/*  525 */             clone.norms.put(curField, norm);
/*      */           } 
/*      */         } 
/*      */         
/*  529 */         clone.openNorms(si.getUseCompoundFile() ? this.cfsReader : directory(), this.readBufferSize);
/*      */       } else {
/*  531 */         Iterator it = this.norms.keySet().iterator();
/*  532 */         while (it.hasNext()) {
/*  533 */           String field = it.next();
/*  534 */           Norm norm = (Norm)this.norms.get(field);
/*  535 */           norm.incRef();
/*  536 */           clone.norms.put(field, norm);
/*      */         } 
/*      */       } 
/*      */       
/*  540 */       if (clone.singleNormStream == null) {
/*  541 */         for (int i = 0; i < this.fieldInfos.size(); i++) {
/*  542 */           FieldInfo fi = this.fieldInfos.fieldInfo(i);
/*  543 */           if (fi.isIndexed && !fi.omitNorms) {
/*  544 */             Directory d = si.getUseCompoundFile() ? this.cfsReader : directory();
/*  545 */             String fileName = si.getNormFileName(fi.number);
/*  546 */             if (!si.hasSeparateNorms(fi.number))
/*      */             {
/*      */ 
/*      */               
/*  550 */               if (fileName.endsWith("".nrm"")) {
/*  551 */                 clone.singleNormStream = d.openInput(fileName, this.readBufferSize);
/*      */                 break;
/*      */               } 
/*      */             }
/*      */           } 
/*      */         } 
/*      */       }
/*  558 */       success = true;
/*      */     } finally {
/*  560 */       if (this.referencedSegmentReader != null) {
/*      */ 
/*      */ 
/*      */ 
/*      */         
/*  565 */         clone.referencedSegmentReader = this.referencedSegmentReader;
/*  566 */         this.referencedSegmentReader.incRefReaderNotNorms();
/*      */       }
/*      */       else {
/*      */         
/*  570 */         clone.referencedSegmentReader = this;
/*  571 */         incRefReaderNotNorms();
/*      */       } 
/*      */       
/*  574 */       if (!success)
/*      */       {
/*      */         
/*  577 */         clone.decRef();
/*      */       }
/*      */     } 
/*      */     
/*  581 */     return clone;
/*      */   }
/*      */   
/*      */   protected void commitChanges() throws IOException {
/*  585 */     if (this.deletedDocsDirty) {
/*  586 */       this.si.advanceDelGen();
/*      */ 
/*      */ 
/*      */ 
/*      */       
/*  591 */       this.deletedDocs.write(directory(), this.si.getDelFileName());
/*      */       
/*  593 */       this.si.setDelCount(this.si.getDelCount() + this.pendingDeleteCount);
/*      */     } 
/*  595 */     if (this.undeleteAll && this.si.hasDeletions()) {
/*  596 */       this.si.clearDelGen();
/*  597 */       this.si.setDelCount(0);
/*      */     } 
/*  599 */     if (this.normsDirty) {
/*  600 */       this.si.setNumFields(this.fieldInfos.size());
/*  601 */       Iterator it = this.norms.values().iterator();
/*  602 */       while (it.hasNext()) {
/*  603 */         Norm norm = it.next();
/*  604 */         if (norm.dirty) {
/*  605 */           norm.reWrite(this.si);
/*      */         }
/*      */       } 
/*      */     } 
/*  609 */     this.deletedDocsDirty = false;
/*  610 */     this.normsDirty = false;
/*  611 */     this.undeleteAll = false;
/*      */   }
/*      */ 
/*      */   
/*  615 */   FieldsReader getFieldsReader() { return this.fieldsReader; }
/*      */ 
/*      */   
/*      */   protected void doClose() throws IOException {
/*  619 */     boolean hasReferencedReader = (this.referencedSegmentReader != null);
/*      */     
/*  621 */     this.termVectorsLocal.close();
/*      */     
/*  623 */     if (hasReferencedReader) {
/*  624 */       this.referencedSegmentReader.decRefReaderNotNorms();
/*  625 */       this.referencedSegmentReader = null;
/*      */     } 
/*      */     
/*  628 */     this.deletedDocs = null;
/*      */ 
/*      */     
/*  631 */     if (this.singleNormStream != null) {
/*      */ 
/*      */ 
/*      */       
/*  635 */       this.singleNormStream.close();
/*  636 */       this.singleNormStream = null;
/*      */     } 
/*      */ 
/*      */     
/*  640 */     if (this.fieldsReader != null) {
/*  641 */       this.fieldsReader.close();
/*      */     }
/*      */     
/*  644 */     if (!hasReferencedReader) {
/*      */       
/*  646 */       if (this.tis != null) {
/*  647 */         this.tis.close();
/*      */       }
/*      */       
/*  650 */       if (this.freqStream != null)
/*  651 */         this.freqStream.close(); 
/*  652 */       if (this.proxStream != null) {
/*  653 */         this.proxStream.close();
/*      */       }
/*  655 */       if (this.termVectorsReaderOrig != null) {
/*  656 */         this.termVectorsReaderOrig.close();
/*      */       }
/*  658 */       if (this.cfsReader != null) {
/*  659 */         this.cfsReader.close();
/*      */       }
/*  661 */       if (this.storeCFSReader != null) {
/*  662 */         this.storeCFSReader.close();
/*      */       }
/*      */       
/*  665 */       super.doClose();
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  671 */   static boolean hasDeletions(SegmentInfo si) throws IOException { return si.hasDeletions(); }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  676 */   public boolean hasDeletions() { return (this.deletedDocs != null); }
/*      */ 
/*      */ 
/*      */   
/*  680 */   static boolean usesCompoundFile(SegmentInfo si) throws IOException { return si.getUseCompoundFile(); }
/*      */ 
/*      */ 
/*      */   
/*  684 */   static boolean hasSeparateNorms(SegmentInfo si) throws IOException { return si.hasSeparateNorms(); }
/*      */ 
/*      */   
/*      */   protected void doDelete(int docNum) {
/*  688 */     if (this.deletedDocs == null)
/*  689 */       this.deletedDocs = new BitVector(maxDoc()); 
/*  690 */     this.deletedDocsDirty = true;
/*  691 */     this.undeleteAll = false;
/*  692 */     if (!this.deletedDocs.getAndSet(docNum))
/*  693 */       this.pendingDeleteCount++; 
/*      */   }
/*      */   
/*      */   protected void doUndeleteAll() {
/*  697 */     this.deletedDocs = null;
/*  698 */     this.deletedDocsDirty = false;
/*  699 */     this.undeleteAll = true;
/*      */   }
/*      */ 
/*      */   
/*  703 */   List files() throws IOException { return new ArrayList(this.si.files()); }
/*      */ 
/*      */   
/*      */   public TermEnum terms() {
/*  707 */     ensureOpen();
/*  708 */     return this.tis.terms();
/*      */   }
/*      */   
/*      */   public TermEnum terms(Term t) throws IOException {
/*  712 */     ensureOpen();
/*  713 */     return this.tis.terms(t);
/*      */   }
/*      */ 
/*      */   
/*  717 */   FieldInfos getFieldInfos() { return this.fieldInfos; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/*  725 */     ensureOpen();
/*  726 */     if (isDeleted(n)) {
/*  727 */       throw new IllegalArgumentException(""attempt to access a deleted document"");
/*      */     }
/*  729 */     return this.fieldsReader.doc(n, fieldSelector);
/*      */   }
/*      */ 
/*      */   
/*  733 */   public synchronized boolean isDeleted(int n) { return (this.deletedDocs != null && this.deletedDocs.get(n)); }
/*      */ 
/*      */   
/*      */   public TermDocs termDocs() throws IOException {
/*  737 */     ensureOpen();
/*  738 */     return new SegmentTermDocs(this);
/*      */   }
/*      */   
/*      */   public TermPositions termPositions() throws IOException {
/*  742 */     ensureOpen();
/*  743 */     return new SegmentTermPositions(this);
/*      */   }
/*      */   
/*      */   public int docFreq(Term t) throws IOException {
/*  747 */     ensureOpen();
/*  748 */     TermInfo ti = this.tis.get(t);
/*  749 */     if (ti != null) {
/*  750 */       return ti.docFreq;
/*      */     }
/*  752 */     return 0;
/*      */   }
/*      */ 
/*      */   
/*      */   public int numDocs() {
/*  757 */     int n = maxDoc();
/*  758 */     if (this.deletedDocs != null)
/*  759 */       n -= this.deletedDocs.count(); 
/*  760 */     return n;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  765 */   public int maxDoc() { return this.si.docCount; }
/*      */ 
/*      */ 
/*      */   
/*  769 */   public void setTermInfosIndexDivisor(int indexDivisor) throws IllegalStateException { this.tis.setIndexDivisor(indexDivisor); }
/*      */ 
/*      */ 
/*      */   
/*  773 */   public int getTermInfosIndexDivisor() { return this.tis.getIndexDivisor(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Collection getFieldNames(IndexReader.FieldOption fieldOption) {
/*  780 */     ensureOpen();
/*      */     
/*  782 */     Set fieldSet = new HashSet();
/*  783 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/*  784 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/*  785 */       if (fieldOption == IndexReader.FieldOption.ALL) {
/*  786 */         fieldSet.add(fi.name);
/*      */       }
/*  788 */       else if (!fi.isIndexed && fieldOption == IndexReader.FieldOption.UNINDEXED) {
/*  789 */         fieldSet.add(fi.name);
/*      */       }
/*  791 */       else if (fi.omitTf && fieldOption == IndexReader.FieldOption.OMIT_TF) {
/*  792 */         fieldSet.add(fi.name);
/*      */       }
/*  794 */       else if (fi.storePayloads && fieldOption == IndexReader.FieldOption.STORES_PAYLOADS) {
/*  795 */         fieldSet.add(fi.name);
/*      */       }
/*  797 */       else if (fi.isIndexed && fieldOption == IndexReader.FieldOption.INDEXED) {
/*  798 */         fieldSet.add(fi.name);
/*      */       }
/*  800 */       else if (fi.isIndexed && !fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_NO_TERMVECTOR) {
/*  801 */         fieldSet.add(fi.name);
/*      */       }
/*  803 */       else if (fi.storeTermVector == true && !fi.storePositionWithTermVector && !fi.storeOffsetWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR) {
/*      */ 
/*      */ 
/*      */         
/*  807 */         fieldSet.add(fi.name);
/*      */       }
/*  809 */       else if (fi.isIndexed && fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR) {
/*  810 */         fieldSet.add(fi.name);
/*      */       }
/*  812 */       else if (fi.storePositionWithTermVector && !fi.storeOffsetWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION) {
/*  813 */         fieldSet.add(fi.name);
/*      */       }
/*  815 */       else if (fi.storeOffsetWithTermVector && !fi.storePositionWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET) {
/*  816 */         fieldSet.add(fi.name);
/*      */       }
/*  818 */       else if (fi.storeOffsetWithTermVector && fi.storePositionWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET) {
/*      */         
/*  820 */         fieldSet.add(fi.name);
/*      */       } 
/*      */     } 
/*  823 */     return fieldSet;
/*      */   }
/*      */ 
/*      */   
/*      */   public synchronized boolean hasNorms(String field) {
/*  828 */     ensureOpen();
/*  829 */     return this.norms.containsKey(field);
/*      */   }
/*      */   
/*      */   static byte[] createFakeNorms(int size) {
/*  833 */     byte[] ones = new byte[size];
/*  834 */     Arrays.fill(ones, DefaultSimilarity.encodeNorm(1.0F));
/*  835 */     return ones;
/*      */   }
/*      */ 
/*      */   
/*      */   private byte[] fakeNorms() {
/*  840 */     if (this.ones == null) this.ones = createFakeNorms(maxDoc()); 
/*  841 */     return this.ones;
/*      */   }
/*      */ 
/*      */   
/*      */   protected synchronized byte[] getNorms(String field) throws IOException {
/*  846 */     Norm norm = (Norm)this.norms.get(field);
/*  847 */     if (norm == null) return null; 
/*  848 */     synchronized (norm) {
/*  849 */       if (norm.bytes == null) {
/*  850 */         byte[] bytes = new byte[maxDoc()];
/*  851 */         norms(field, bytes, 0);
/*  852 */         norm.bytes = bytes;
/*      */ 
/*      */         
/*  855 */         norm.close();
/*      */       } 
/*  857 */       return norm.bytes;
/*      */     } 
/*      */   }
/*      */ 
/*      */   
/*      */   public synchronized byte[] norms(String field) throws IOException {
/*  863 */     ensureOpen();
/*  864 */     byte[] bytes = getNorms(field);
/*  865 */     if (bytes == null) bytes = fakeNorms(); 
/*  866 */     return bytes;
/*      */   }
/*      */ 
/*      */   
/*      */   protected void doSetNorm(int doc, String field, byte value) throws IOException {
/*  871 */     Norm norm = (Norm)this.norms.get(field);
/*  872 */     if (norm == null) {
/*      */       return;
/*      */     }
/*  875 */     norm.dirty = true;
/*  876 */     this.normsDirty = true;
/*      */     
/*  878 */     norms(field)[doc] = value;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void norms(String field, byte[] bytes, int offset) throws IOException {
/*  885 */     ensureOpen();
/*  886 */     Norm norm = (Norm)this.norms.get(field);
/*  887 */     if (norm == null) {
/*  888 */       System.arraycopy(fakeNorms(), 0, bytes, offset, maxDoc());
/*      */       
/*      */       return;
/*      */     } 
/*  892 */     synchronized (norm) {
/*  893 */       IndexInput normStream; if (norm.bytes != null) {
/*  894 */         System.arraycopy(norm.bytes, 0, bytes, offset, maxDoc());
/*      */ 
/*      */         
/*      */         return;
/*      */       } 
/*      */ 
/*      */       
/*  901 */       if (norm.useSingleNormStream) {
/*  902 */         normStream = this.singleNormStream;
/*      */       } else {
/*  904 */         normStream = norm.in;
/*      */       } 
/*  906 */       normStream.seek(norm.normSeek);
/*  907 */       normStream.readBytes(bytes, offset, maxDoc());
/*      */     } 
/*      */   }
/*      */ 
/*      */   
/*      */   private void openNorms(Directory cfsDir, int readBufferSize) throws IOException {
/*  913 */     long nextNormSeek = SegmentMerger.NORMS_HEADER.length;
/*  914 */     int maxDoc = maxDoc();
/*  915 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/*  916 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/*  917 */       if (!this.norms.containsKey(fi.name))
/*      */       {
/*      */ 
/*      */ 
/*      */         
/*  922 */         if (fi.isIndexed && !fi.omitNorms) {
/*  923 */           long normSeek; Directory d = directory();
/*  924 */           String fileName = this.si.getNormFileName(fi.number);
/*  925 */           if (!this.si.hasSeparateNorms(fi.number)) {
/*  926 */             d = cfsDir;
/*      */           }
/*      */ 
/*      */           
/*  930 */           boolean singleNormFile = fileName.endsWith("".nrm"");
/*  931 */           IndexInput normInput = null;
/*      */ 
/*      */           
/*  934 */           if (singleNormFile) {
/*  935 */             normSeek = nextNormSeek;
/*  936 */             if (this.singleNormStream == null) {
/*  937 */               this.singleNormStream = d.openInput(fileName, readBufferSize);
/*      */             }
/*      */ 
/*      */ 
/*      */             
/*  942 */             normInput = this.singleNormStream;
/*      */           } else {
/*  944 */             normSeek = 0L;
/*  945 */             normInput = d.openInput(fileName);
/*      */           } 
/*      */           
/*  948 */           this.norms.put(fi.name, new Norm(normInput, singleNormFile, fi.number, normSeek));
/*  949 */           nextNormSeek += maxDoc;
/*      */         } 
/*      */       }
/*      */     } 
/*      */   }
/*      */   
/*      */   boolean normsClosed() {
/*  956 */     if (this.singleNormStream != null) {
/*  957 */       return false;
/*      */     }
/*  959 */     Iterator it = this.norms.values().iterator();
/*  960 */     while (it.hasNext()) {
/*  961 */       Norm norm = it.next();
/*  962 */       if (norm.refCount > 0) {
/*  963 */         return false;
/*      */       }
/*      */     } 
/*  966 */     return true;
/*      */   }
/*      */ 
/*      */   
/*      */   boolean normsClosed(String field) {
/*  971 */     Norm norm = (Norm)this.norms.get(field);
/*  972 */     return (norm.refCount == 0);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private TermVectorsReader getTermVectorsReader() {
/*  980 */     assert this.termVectorsReaderOrig != null;
/*  981 */     TermVectorsReader tvReader = (TermVectorsReader)this.termVectorsLocal.get();
/*  982 */     if (tvReader == null) {
/*      */       try {
/*  984 */         tvReader = (TermVectorsReader)this.termVectorsReaderOrig.clone();
/*  985 */       } catch (CloneNotSupportedException cnse) {
/*  986 */         return null;
/*      */       } 
/*  988 */       this.termVectorsLocal.set(tvReader);
/*      */     } 
/*  990 */     return tvReader;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public TermFreqVector getTermFreqVector(int docNumber, String field) throws IOException {
/* 1001 */     ensureOpen();
/* 1002 */     FieldInfo fi = this.fieldInfos.fieldInfo(field);
/* 1003 */     if (fi == null || !fi.storeTermVector || this.termVectorsReaderOrig == null) {
/* 1004 */       return null;
/*      */     }
/* 1006 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 1007 */     if (termVectorsReader == null) {
/* 1008 */       return null;
/*      */     }
/* 1010 */     return termVectorsReader.get(docNumber, field);
/*      */   }
/*      */ 
/*      */   
/*      */   public void getTermFreqVector(int docNumber, String field, TermVectorMapper mapper) throws IOException {
/* 1015 */     ensureOpen();
/* 1016 */     FieldInfo fi = this.fieldInfos.fieldInfo(field);
/* 1017 */     if (fi == null || !fi.storeTermVector || this.termVectorsReaderOrig == null) {
/*      */       return;
/*      */     }
/* 1020 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 1021 */     if (termVectorsReader == null) {
/*      */       return;
/*      */     }
/*      */ 
/*      */ 
/*      */     
/* 1027 */     termVectorsReader.get(docNumber, field, mapper);
/*      */   }
/*      */ 
/*      */   
/*      */   public void getTermFreqVector(int docNumber, TermVectorMapper mapper) throws IOException {
/* 1032 */     ensureOpen();
/* 1033 */     if (this.termVectorsReaderOrig == null) {
/*      */       return;
/*      */     }
/* 1036 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 1037 */     if (termVectorsReader == null) {
/*      */       return;
/*      */     }
/* 1040 */     termVectorsReader.get(docNumber, mapper);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public TermFreqVector[] getTermFreqVectors(int docNumber) throws IOException {
/* 1051 */     ensureOpen();
/* 1052 */     if (this.termVectorsReaderOrig == null) {
/* 1053 */       return null;
/*      */     }
/* 1055 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 1056 */     if (termVectorsReader == null) {
/* 1057 */       return null;
/*      */     }
/* 1059 */     return termVectorsReader.get(docNumber);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/* 1064 */   FieldInfos fieldInfos() { return this.fieldInfos; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 1071 */   String getSegmentName() { return this.segment; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 1078 */   SegmentInfo getSegmentInfo() { return this.si; }
/*      */ 
/*      */ 
/*      */   
/* 1082 */   void setSegmentInfo(SegmentInfo info) { this.si = info; }
/*      */ 
/*      */   
/*      */   void startCommit() {
/* 1086 */     super.startCommit();
/* 1087 */     this.rollbackDeletedDocsDirty = this.deletedDocsDirty;
/* 1088 */     this.rollbackNormsDirty = this.normsDirty;
/* 1089 */     this.rollbackUndeleteAll = this.undeleteAll;
/* 1090 */     this.rollbackPendingDeleteCount = this.pendingDeleteCount;
/* 1091 */     Iterator it = this.norms.values().iterator();
/* 1092 */     while (it.hasNext()) {
/* 1093 */       Norm norm = it.next();
/* 1094 */       norm.rollbackDirty = norm.dirty;
/*      */     } 
/*      */   }
/*      */   
/*      */   void rollbackCommit() {
/* 1099 */     super.rollbackCommit();
/* 1100 */     this.deletedDocsDirty = this.rollbackDeletedDocsDirty;
/* 1101 */     this.normsDirty = this.rollbackNormsDirty;
/* 1102 */     this.undeleteAll = this.rollbackUndeleteAll;
/* 1103 */     this.pendingDeleteCount = this.rollbackPendingDeleteCount;
/* 1104 */     Iterator it = this.norms.values().iterator();
/* 1105 */     while (it.hasNext()) {
/* 1106 */       Norm norm = it.next();
/* 1107 */       norm.dirty = norm.rollbackDirty;
/*      */     } 
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermDocs,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.util.BitVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SegmentTermDocs
/*     */   implements TermDocs
/*     */ {
/*     */   protected SegmentReader parent;
/*     */   protected IndexInput freqStream;
/*     */   protected int count;
/*     */   protected int df;
/*     */   protected BitVector deletedDocs;
/*  30 */   int doc = 0;
/*     */   
/*     */   int freq;
/*     */   
/*     */   private int skipInterval;
/*     */   
/*     */   private int maxSkipLevels;
/*     */   
/*     */   private DefaultSkipListReader skipListReader;
/*     */   private long freqBasePointer;
/*     */   private long proxBasePointer;
/*     */   private long skipPointer;
/*     */   private boolean haveSkipped;
/*     */   protected boolean currentFieldStoresPayloads;
/*     */   protected boolean currentFieldOmitTf;
/*     */   
/*     */   protected SegmentTermDocs(SegmentReader parent) {
/*  47 */     this.parent = parent;
/*  48 */     this.freqStream = (IndexInput)parent.freqStream.clone();
/*  49 */     this.deletedDocs = parent.deletedDocs;
/*  50 */     this.skipInterval = parent.tis.getSkipInterval();
/*  51 */     this.maxSkipLevels = parent.tis.getMaxSkipLevels();
/*     */   }
/*     */   
/*     */   public void seek(Term term) throws IOException {
/*  55 */     TermInfo ti = this.parent.tis.get(term);
/*  56 */     seek(ti, term);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(TermEnum termEnum) throws IOException {
/*     */     Term term;
/*     */     TermInfo ti;
/*  64 */     if (termEnum instanceof SegmentTermEnum && ((SegmentTermEnum)termEnum).fieldInfos == this.parent.fieldInfos) {
/*  65 */       SegmentTermEnum segmentTermEnum = (SegmentTermEnum)termEnum;
/*  66 */       term = segmentTermEnum.term();
/*  67 */       ti = segmentTermEnum.termInfo();
/*     */     } else {
/*  69 */       term = termEnum.term();
/*  70 */       ti = this.parent.tis.get(term);
/*     */     } 
/*     */     
/*  73 */     seek(ti, term);
/*     */   }
/*     */   
/*     */   void seek(TermInfo ti, Term term) throws IOException {
/*  77 */     this.count = 0;
/*  78 */     FieldInfo fi = this.parent.fieldInfos.fieldInfo(term.field);
/*  79 */     this.currentFieldOmitTf = (fi != null) ? fi.omitTf : false;
/*  80 */     this.currentFieldStoresPayloads = (fi != null) ? fi.storePayloads : false;
/*  81 */     if (ti == null) {
/*  82 */       this.df = 0;
/*     */     } else {
/*  84 */       this.df = ti.docFreq;
/*  85 */       this.doc = 0;
/*  86 */       this.freqBasePointer = ti.freqPointer;
/*  87 */       this.proxBasePointer = ti.proxPointer;
/*  88 */       this.skipPointer = this.freqBasePointer + ti.skipOffset;
/*  89 */       this.freqStream.seek(this.freqBasePointer);
/*  90 */       this.haveSkipped = false;
/*     */     } 
/*     */   }
/*     */   
/*     */   public void close() throws IOException {
/*  95 */     this.freqStream.close();
/*  96 */     if (this.skipListReader != null)
/*  97 */       this.skipListReader.close(); 
/*     */   }
/*     */   
/* 100 */   public final int doc() { return this.doc; }
/* 101 */   public final int freq() { return this.freq; }
/*     */ 
/*     */   
/*     */   protected void skippingDoc() throws IOException {}
/*     */   
/*     */   public boolean next() throws IOException {
/*     */     while (true) {
/* 108 */       if (this.count == this.df)
/* 109 */         return false; 
/* 110 */       int docCode = this.freqStream.readVInt();
/*     */       
/* 112 */       if (this.currentFieldOmitTf) {
/* 113 */         this.doc += docCode;
/* 114 */         this.freq = 1;
/*     */       } else {
/* 116 */         this.doc += docCode >>> 1;
/* 117 */         if ((docCode & 0x1) != 0) {
/* 118 */           this.freq = 1;
/*     */         } else {
/* 120 */           this.freq = this.freqStream.readVInt();
/*     */         } 
/*     */       } 
/* 123 */       this.count++;
/*     */       
/* 125 */       if (this.deletedDocs == null || !this.deletedDocs.get(this.doc))
/*     */         break; 
/* 127 */       skippingDoc();
/*     */     } 
/* 129 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int read(int[] docs, int[] freqs) throws IOException {
/* 135 */     int length = docs.length;
/* 136 */     if (this.currentFieldOmitTf) {
/* 137 */       return readNoTf(docs, freqs, length);
/*     */     }
/* 139 */     int i = 0;
/* 140 */     while (i < length && this.count < this.df) {
/*     */       
/* 142 */       int docCode = this.freqStream.readVInt();
/* 143 */       this.doc += docCode >>> 1;
/* 144 */       if ((docCode & 0x1) != 0) {
/* 145 */         this.freq = 1;
/*     */       } else {
/* 147 */         this.freq = this.freqStream.readVInt();
/* 148 */       }  this.count++;
/*     */       
/* 150 */       if (this.deletedDocs == null || !this.deletedDocs.get(this.doc)) {
/* 151 */         docs[i] = this.doc;
/* 152 */         freqs[i] = this.freq;
/* 153 */         i++;
/*     */       } 
/*     */     } 
/* 156 */     return i;
/*     */   }
/*     */ 
/*     */   
/*     */   private final int readNoTf(int[] docs, int[] freqs, int length) throws IOException {
/* 161 */     int i = 0;
/* 162 */     while (i < length && this.count < this.df) {
/*     */       
/* 164 */       this.doc += this.freqStream.readVInt();
/* 165 */       this.count++;
/*     */       
/* 167 */       if (this.deletedDocs == null || !this.deletedDocs.get(this.doc)) {
/* 168 */         docs[i] = this.doc;
/*     */ 
/*     */         
/* 171 */         freqs[i] = 1;
/* 172 */         i++;
/*     */       } 
/*     */     } 
/* 175 */     return i;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   protected void skipProx(long proxPointer, int payloadLength) throws IOException {}
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 184 */     if (this.df >= this.skipInterval) {
/* 185 */       if (this.skipListReader == null) {
/* 186 */         this.skipListReader = new DefaultSkipListReader((IndexInput)this.freqStream.clone(), this.maxSkipLevels, this.skipInterval);
/*     */       }
/* 188 */       if (!this.haveSkipped) {
/* 189 */         this.skipListReader.init(this.skipPointer, this.freqBasePointer, this.proxBasePointer, this.df, this.currentFieldStoresPayloads);
/* 190 */         this.haveSkipped = true;
/*     */       } 
/*     */       
/* 193 */       int newCount = this.skipListReader.skipTo(target);
/* 194 */       if (newCount > this.count) {
/* 195 */         this.freqStream.seek(this.skipListReader.getFreqPointer());
/* 196 */         skipProx(this.skipListReader.getProxPointer(), this.skipListReader.getPayloadLength());
/*     */         
/* 198 */         this.doc = this.skipListReader.getDoc();
/* 199 */         this.count = newCount;
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/*     */     do {
/* 205 */       if (!next())
/* 206 */         return false; 
/* 207 */     } while (target > this.doc);
/* 208 */     return true;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentTermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermEnum,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentTermEnum
/*     */   extends TermEnum
/*     */   implements Cloneable
/*     */ {
/*     */   private IndexInput input;
/*     */   FieldInfos fieldInfos;
/*     */   long size;
/*  27 */   long position = -1L;
/*     */   
/*  29 */   private TermBuffer termBuffer = new TermBuffer();
/*  30 */   private TermBuffer prevBuffer = new TermBuffer();
/*  31 */   private TermBuffer scanBuffer = new TermBuffer();
/*     */   
/*  33 */   private TermInfo termInfo = new TermInfo();
/*     */   
/*     */   private int format;
/*     */   private boolean isIndex = false;
/*  37 */   long indexPointer = 0L;
/*     */   
/*     */   int indexInterval;
/*     */   int skipInterval;
/*     */   int maxSkipLevels;
/*     */   private int formatM1SkipInterval;
/*     */   
/*     */   SegmentTermEnum(IndexInput i, FieldInfos fis, boolean isi) throws CorruptIndexException, IOException {
/*  45 */     this.input = i;
/*  46 */     this.fieldInfos = fis;
/*  47 */     this.isIndex = isi;
/*  48 */     this.maxSkipLevels = 1;
/*     */     
/*  50 */     int firstInt = this.input.readInt();
/*  51 */     if (firstInt >= 0) {
/*     */       
/*  53 */       this.format = 0;
/*  54 */       this.size = firstInt;
/*     */ 
/*     */       
/*  57 */       this.indexInterval = 128;
/*  58 */       this.skipInterval = Integer.MAX_VALUE;
/*     */     } else {
/*     */       
/*  61 */       this.format = firstInt;
/*     */ 
/*     */       
/*  64 */       if (this.format < -4) {
/*  65 */         throw new CorruptIndexException(""Unknown format version:"" + this.format + "" expected "" + -4 + "" or higher"");
/*     */       }
/*  67 */       this.size = this.input.readLong();
/*     */       
/*  69 */       if (this.format == -1) {
/*  70 */         if (!this.isIndex) {
/*  71 */           this.indexInterval = this.input.readInt();
/*  72 */           this.formatM1SkipInterval = this.input.readInt();
/*     */         } 
/*     */ 
/*     */         
/*  76 */         this.skipInterval = Integer.MAX_VALUE;
/*     */       } else {
/*  78 */         this.indexInterval = this.input.readInt();
/*  79 */         this.skipInterval = this.input.readInt();
/*  80 */         if (this.format <= -3)
/*     */         {
/*  82 */           this.maxSkipLevels = this.input.readInt();
/*     */         }
/*     */       } 
/*     */     } 
/*  86 */     if (this.format > -4) {
/*  87 */       this.termBuffer.setPreUTF8Strings();
/*  88 */       this.scanBuffer.setPreUTF8Strings();
/*  89 */       this.prevBuffer.setPreUTF8Strings();
/*     */     } 
/*     */   }
/*     */   
/*     */   protected Object clone() {
/*  94 */     SegmentTermEnum clone = null;
/*     */     try {
/*  96 */       clone = (SegmentTermEnum)super.clone();
/*  97 */     } catch (CloneNotSupportedException e) {}
/*     */     
/*  99 */     clone.input = (IndexInput)this.input.clone();
/* 100 */     clone.termInfo = new TermInfo(this.termInfo);
/*     */     
/* 102 */     clone.termBuffer = (TermBuffer)this.termBuffer.clone();
/* 103 */     clone.prevBuffer = (TermBuffer)this.prevBuffer.clone();
/* 104 */     clone.scanBuffer = new TermBuffer();
/*     */     
/* 106 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   final void seek(long pointer, int p, Term t, TermInfo ti) throws IOException {
/* 111 */     this.input.seek(pointer);
/* 112 */     this.position = p;
/* 113 */     this.termBuffer.set(t);
/* 114 */     this.prevBuffer.reset();
/* 115 */     this.termInfo.set(ti);
/*     */   }
/*     */ 
/*     */   
/*     */   public final boolean next() throws IOException {
/* 120 */     if (this.position++ >= this.size - 1L) {
/* 121 */       this.prevBuffer.set(this.termBuffer);
/* 122 */       this.termBuffer.reset();
/* 123 */       return false;
/*     */     } 
/*     */     
/* 126 */     this.prevBuffer.set(this.termBuffer);
/* 127 */     this.termBuffer.read(this.input, this.fieldInfos);
/*     */     
/* 129 */     this.termInfo.docFreq = this.input.readVInt();
/* 130 */     this.termInfo.freqPointer += this.input.readVLong();
/* 131 */     this.termInfo.proxPointer += this.input.readVLong();
/*     */     
/* 133 */     if (this.format == -1) {
/*     */ 
/*     */       
/* 136 */       if (!this.isIndex && 
/* 137 */         this.termInfo.docFreq > this.formatM1SkipInterval) {
/* 138 */         this.termInfo.skipOffset = this.input.readVInt();
/*     */       
/*     */       }
/*     */     
/*     */     }
/* 143 */     else if (this.termInfo.docFreq >= this.skipInterval) {
/* 144 */       this.termInfo.skipOffset = this.input.readVInt();
/*     */     } 
/*     */     
/* 147 */     if (this.isIndex) {
/* 148 */       this.indexPointer += this.input.readVLong();
/*     */     }
/* 150 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   final int scanTo(Term term) throws IOException {
/* 156 */     this.scanBuffer.set(term);
/* 157 */     int count = 0;
/* 158 */     while (this.scanBuffer.compareTo(this.termBuffer) > 0 && next()) {
/* 159 */       count++;
/*     */     }
/* 161 */     return count;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 167 */   public final Term term() { return this.termBuffer.toTerm(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 172 */   final Term prev() { return this.prevBuffer.toTerm(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 178 */   final TermInfo termInfo() { return new TermInfo(this.termInfo); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 184 */   final void termInfo(TermInfo ti) { ti.set(this.termInfo); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 190 */   public final int docFreq() { return this.termInfo.docFreq; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   final long freqPointer() { return this.termInfo.freqPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 202 */   final long proxPointer() { return this.termInfo.proxPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 207 */   public final void close() throws IOException { this.input.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermPositions,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentTermPositions
/*     */   extends SegmentTermDocs
/*     */   implements TermPositions
/*     */ {
/*     */   private IndexInput proxStream;
/*     */   private int proxCount;
/*     */   private int position;
/*     */   private int payloadLength;
/*     */   private boolean needToLoadPayload;
/*  38 */   private long lazySkipPointer = -1L;
/*  39 */   private int lazySkipProxCount = 0;
/*     */   
/*     */   SegmentTermPositions(SegmentReader p) {
/*  42 */     super(p);
/*  43 */     this.proxStream = null;
/*     */   }
/*     */   static final boolean $assertionsDisabled;
/*     */   final void seek(TermInfo ti, Term term) throws IOException {
/*  47 */     super.seek(ti, term);
/*  48 */     if (ti != null) {
/*  49 */       this.lazySkipPointer = ti.proxPointer;
/*     */     }
/*  51 */     this.lazySkipProxCount = 0;
/*  52 */     this.proxCount = 0;
/*  53 */     this.payloadLength = 0;
/*  54 */     this.needToLoadPayload = false;
/*     */   }
/*     */   
/*     */   public final void close() throws IOException {
/*  58 */     super.close();
/*  59 */     if (this.proxStream != null) this.proxStream.close(); 
/*     */   }
/*     */   
/*     */   public final int nextPosition() throws IOException {
/*  63 */     if (this.currentFieldOmitTf)
/*     */     {
/*  65 */       return 0;
/*     */     }
/*  67 */     lazySkip();
/*  68 */     this.proxCount--;
/*  69 */     return this.position += readDeltaPosition();
/*     */   }
/*     */   
/*     */   private final int readDeltaPosition() throws IOException {
/*  73 */     int delta = this.proxStream.readVInt();
/*  74 */     if (this.currentFieldStoresPayloads) {
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  79 */       if ((delta & 0x1) != 0) {
/*  80 */         this.payloadLength = this.proxStream.readVInt();
/*     */       }
/*  82 */       delta >>>= 1;
/*  83 */       this.needToLoadPayload = true;
/*     */     } 
/*  85 */     return delta;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  90 */   protected final void skippingDoc() throws IOException { this.lazySkipProxCount += this.freq; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean next() throws IOException {
/*  96 */     this.lazySkipProxCount += this.proxCount;
/*     */     
/*  98 */     if (super.next()) {
/*  99 */       this.proxCount = this.freq;
/* 100 */       this.position = 0;
/* 101 */       return true;
/*     */     } 
/* 103 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 107 */   public final int read(int[] docs, int[] freqs) { throw new UnsupportedOperationException(""TermPositions does not support processing multiple documents in one call. Use TermDocs instead.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void skipProx(long proxPointer, int payloadLength) throws IOException {
/* 114 */     this.lazySkipPointer = proxPointer;
/* 115 */     this.lazySkipProxCount = 0;
/* 116 */     this.proxCount = 0;
/* 117 */     this.payloadLength = payloadLength;
/* 118 */     this.needToLoadPayload = false;
/*     */   }
/*     */   
/*     */   private void skipPositions(int n) throws IOException {
/* 122 */     assert !this.currentFieldOmitTf;
/* 123 */     for (int f = n; f > 0; f--) {
/* 124 */       readDeltaPosition();
/* 125 */       skipPayload();
/*     */     } 
/*     */   }
/*     */   
/*     */   private void skipPayload() throws IOException {
/* 130 */     if (this.needToLoadPayload && this.payloadLength > 0) {
/* 131 */       this.proxStream.seek(this.proxStream.getFilePointer() + this.payloadLength);
/*     */     }
/* 133 */     this.needToLoadPayload = false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void lazySkip() throws IOException {
/* 147 */     if (this.proxStream == null)
/*     */     {
/* 149 */       this.proxStream = (IndexInput)this.parent.proxStream.clone();
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 154 */     skipPayload();
/*     */     
/* 156 */     if (this.lazySkipPointer != -1L) {
/* 157 */       this.proxStream.seek(this.lazySkipPointer);
/* 158 */       this.lazySkipPointer = -1L;
/*     */     } 
/*     */     
/* 161 */     if (this.lazySkipProxCount != 0) {
/* 162 */       skipPositions(this.lazySkipProxCount);
/* 163 */       this.lazySkipProxCount = 0;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 168 */   public int getPayloadLength() { return this.payloadLength; }
/*     */   public byte[] getPayload(byte[] data, int offset) throws IOException {
/*     */     int retOffset;
/*     */     byte[] retArray;
/* 172 */     if (!this.needToLoadPayload) {
/* 173 */       throw new IOException(""Payload cannot be loaded more than once for the same term position."");
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 179 */     if (data == null || data.length - offset < this.payloadLength) {
/*     */ 
/*     */       
/* 182 */       retArray = new byte[this.payloadLength];
/* 183 */       retOffset = 0;
/*     */     } else {
/* 185 */       retArray = data;
/* 186 */       retOffset = offset;
/*     */     } 
/* 188 */     this.proxStream.readBytes(retArray, retOffset, this.payloadLength);
/* 189 */     this.needToLoadPayload = false;
/* 190 */     return retArray;
/*     */   }
/*     */ 
/*     */   
/* 194 */   public boolean isPayloadAvailable() { return (this.needToLoadPayload && this.payloadLength > 0); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermPositionVector,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class SegmentTermPositionVector
/*    */   extends SegmentTermVector
/*    */   implements TermPositionVector
/*    */ {
/*    */   protected int[][] positions;
/*    */   protected TermVectorOffsetInfo[][] offsets;
/* 23 */   public static final int[] EMPTY_TERM_POS = new int[0];
/*    */   
/*    */   public SegmentTermPositionVector(String field, String[] terms, int[] termFreqs, int[][] positions, TermVectorOffsetInfo[][] offsets) {
/* 26 */     super(field, terms, termFreqs);
/* 27 */     this.offsets = offsets;
/* 28 */     this.positions = positions;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public TermVectorOffsetInfo[] getOffsets(int index) {
/* 39 */     TermVectorOffsetInfo[] result = TermVectorOffsetInfo.EMPTY_OFFSET_INFO;
/* 40 */     if (this.offsets == null)
/* 41 */       return null; 
/* 42 */     if (index >= 0 && index < this.offsets.length)
/*    */     {
/* 44 */       result = this.offsets[index];
/*    */     }
/* 46 */     return result;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int[] getTermPositions(int index) {
/* 55 */     int[] result = EMPTY_TERM_POS;
/* 56 */     if (this.positions == null)
/* 57 */       return null; 
/* 58 */     if (index >= 0 && index < this.positions.length)
/*    */     {
/* 60 */       result = this.positions[index];
/*    */     }
/*    */     
/* 63 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentTermPositionVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermVector,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.util.Arrays;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class SegmentTermVector
/*    */   implements TermFreqVector
/*    */ {
/*    */   private String field;
/*    */   private String[] terms;
/*    */   private int[] termFreqs;
/*    */   
/*    */   SegmentTermVector(String field, String[] terms, int[] termFreqs) {
/* 29 */     this.field = field;
/* 30 */     this.terms = terms;
/* 31 */     this.termFreqs = termFreqs;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 39 */   public String getField() { return this.field; }
/*    */ 
/*    */   
/*    */   public String toString() {
/* 43 */     StringBuffer sb = new StringBuffer();
/* 44 */     sb.append('{');
/* 45 */     sb.append(this.field).append("": "");
/* 46 */     if (this.terms != null) {
/* 47 */       for (int i = 0; i < this.terms.length; i++) {
/* 48 */         if (i > 0) sb.append("", ""); 
/* 49 */         sb.append(this.terms[i]).append('/').append(this.termFreqs[i]);
/*    */       } 
/*    */     }
/* 52 */     sb.append('}');
/*    */     
/* 54 */     return sb.toString();
/*    */   }
/*    */ 
/*    */   
/* 58 */   public int size() { return (this.terms == null) ? 0 : this.terms.length; }
/*    */ 
/*    */ 
/*    */   
/* 62 */   public String[] getTerms() { return this.terms; }
/*    */ 
/*    */ 
/*    */   
/* 66 */   public int[] getTermFrequencies() { return this.termFreqs; }
/*    */ 
/*    */   
/*    */   public int indexOf(String termText) {
/* 70 */     if (this.terms == null)
/* 71 */       return -1; 
/* 72 */     int res = Arrays.binarySearch((Object[])this.terms, termText);
/* 73 */     return (res >= 0) ? res : -1;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int[] indexesOf(String[] termNumbers, int start, int len) {
/* 82 */     int[] res = new int[len];
/*    */     
/* 84 */     for (int i = 0; i < len; i++) {
/* 85 */       res[i] = indexOf(termNumbers[start + i]);
/*    */     }
/* 87 */     return res;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SegmentTermVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SerialMergeScheduler,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SerialMergeScheduler
/*    */   extends MergeScheduler
/*    */ {
/*    */   public synchronized void merge(IndexWriter writer) throws CorruptIndexException, IOException {
/*    */     while (true) {
/* 33 */       MergePolicy.OneMerge merge = writer.getNextMerge();
/* 34 */       if (merge == null)
/*    */         break; 
/* 36 */       writer.merge(merge);
/*    */     } 
/*    */   }
/*    */   
/*    */   public void close() {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SerialMergeScheduler.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SnapshotDeletionPolicy,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SnapshotDeletionPolicy
/*     */   implements IndexDeletionPolicy
/*     */ {
/*     */   private IndexCommit lastCommit;
/*     */   private IndexDeletionPolicy primary;
/*     */   private String snapshot;
/*     */   
/*  51 */   public SnapshotDeletionPolicy(IndexDeletionPolicy primary) { this.primary = primary; }
/*     */ 
/*     */   
/*     */   public synchronized void onInit(List commits) throws IOException {
/*  55 */     this.primary.onInit(wrapCommits(commits));
/*  56 */     this.lastCommit = commits.get(commits.size() - 1);
/*     */   }
/*     */   
/*     */   public synchronized void onCommit(List commits) throws IOException {
/*  60 */     this.primary.onCommit(wrapCommits(commits));
/*  61 */     this.lastCommit = commits.get(commits.size() - 1);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized IndexCommitPoint snapshot() {
/*  75 */     if (this.snapshot == null) {
/*  76 */       this.snapshot = this.lastCommit.getSegmentsFileName();
/*     */     } else {
/*  78 */       throw new IllegalStateException(""snapshot is already set; please call release() first"");
/*  79 */     }  return this.lastCommit;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void release() {
/*  84 */     if (this.snapshot != null) {
/*  85 */       this.snapshot = null;
/*     */     } else {
/*  87 */       throw new IllegalStateException(""snapshot was not set; please call snapshot() first"");
/*     */     } 
/*     */   }
/*     */   
/*     */   private class MyCommitPoint extends IndexCommit { IndexCommit cp;
/*     */     
/*  93 */     MyCommitPoint(IndexCommit cp) { this.cp = cp; }
/*     */     private final SnapshotDeletionPolicy this$0;
/*     */     
/*  96 */     public String getSegmentsFileName() { return this.cp.getSegmentsFileName(); }
/*     */ 
/*     */     
/*  99 */     public Collection getFileNames() throws IOException { return this.cp.getFileNames(); }
/*     */ 
/*     */     
/* 102 */     public Directory getDirectory() { return this.cp.getDirectory(); }
/*     */     
/*     */     public void delete() {
/* 105 */       synchronized (SnapshotDeletionPolicy.this) {
/*     */ 
/*     */         
/* 108 */         if (SnapshotDeletionPolicy.this.snapshot == null || !SnapshotDeletionPolicy.this.snapshot.equals(getSegmentsFileName()))
/* 109 */           this.cp.delete(); 
/*     */       } 
/*     */     }
/*     */     
/* 113 */     public boolean isDeleted() { return this.cp.isDeleted(); }
/*     */ 
/*     */     
/* 116 */     public long getVersion() { return this.cp.getVersion(); }
/*     */ 
/*     */     
/* 119 */     public long getGeneration() { return this.cp.getGeneration(); } }
/*     */ 
/*     */ 
/*     */   
/*     */   private List wrapCommits(List commits) {
/* 124 */     int count = commits.size();
/* 125 */     List myCommits = new ArrayList(count);
/* 126 */     for (int i = 0; i < count; i++)
/* 127 */       myCommits.add(new MyCommitPoint(commits.get(i))); 
/* 128 */     return myCommits;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SnapshotDeletionPolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SortedTermVectorMapper,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.util.Comparator;
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import java.util.SortedSet;
/*     */ import java.util.TreeSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SortedTermVectorMapper
/*     */   extends TermVectorMapper
/*     */ {
/*     */   private SortedSet currentSet;
/*  33 */   private Map termToTVE = new HashMap();
/*     */ 
/*     */   
/*     */   private boolean storeOffsets;
/*     */ 
/*     */   
/*     */   private boolean storePositions;
/*     */ 
/*     */   
/*     */   public static final String ALL = ""_ALL_"";
/*     */ 
/*     */ 
/*     */   
/*  46 */   public SortedTermVectorMapper(Comparator comparator) { this(false, false, comparator); }
/*     */ 
/*     */ 
/*     */   
/*     */   public SortedTermVectorMapper(boolean ignoringPositions, boolean ignoringOffsets, Comparator comparator) {
/*  51 */     super(ignoringPositions, ignoringOffsets);
/*  52 */     this.currentSet = new TreeSet(comparator);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void map(String term, int frequency, TermVectorOffsetInfo[] offsets, int[] positions) {
/*  64 */     TermVectorEntry entry = (TermVectorEntry)this.termToTVE.get(term);
/*  65 */     if (entry == null) {
/*  66 */       entry = new TermVectorEntry(""_ALL_"", term, frequency, (this.storeOffsets == true) ? offsets : null, (this.storePositions == true) ? positions : null);
/*     */ 
/*     */       
/*  69 */       this.termToTVE.put(term, entry);
/*  70 */       this.currentSet.add(entry);
/*     */     } else {
/*  72 */       entry.setFrequency(entry.getFrequency() + frequency);
/*  73 */       if (this.storeOffsets) {
/*     */         
/*  75 */         TermVectorOffsetInfo[] existingOffsets = entry.getOffsets();
/*     */         
/*  77 */         if (existingOffsets != null && offsets != null && offsets.length > 0) {
/*     */ 
/*     */           
/*  80 */           TermVectorOffsetInfo[] newOffsets = new TermVectorOffsetInfo[existingOffsets.length + offsets.length];
/*  81 */           System.arraycopy(existingOffsets, 0, newOffsets, 0, existingOffsets.length);
/*  82 */           System.arraycopy(offsets, 0, newOffsets, existingOffsets.length, offsets.length);
/*  83 */           entry.setOffsets(newOffsets);
/*     */         }
/*  85 */         else if (existingOffsets == null && offsets != null && offsets.length > 0) {
/*     */           
/*  87 */           entry.setOffsets(offsets);
/*     */         } 
/*     */       } 
/*     */       
/*  91 */       if (this.storePositions) {
/*     */         
/*  93 */         int[] existingPositions = entry.getPositions();
/*  94 */         if (existingPositions != null && positions != null && positions.length > 0) {
/*     */           
/*  96 */           int[] newPositions = new int[existingPositions.length + positions.length];
/*  97 */           System.arraycopy(existingPositions, 0, newPositions, 0, existingPositions.length);
/*  98 */           System.arraycopy(positions, 0, newPositions, existingPositions.length, positions.length);
/*  99 */           entry.setPositions(newPositions);
/*     */         }
/* 101 */         else if (existingPositions == null && positions != null && positions.length > 0) {
/*     */           
/* 103 */           entry.setPositions(positions);
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setExpectations(String field, int numTerms, boolean storeOffsets, boolean storePositions) {
/* 113 */     this.storeOffsets = storeOffsets;
/* 114 */     this.storePositions = storePositions;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public SortedSet getTermVectorEntrySet() { return this.currentSet; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\SortedTermVectorMapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.StaleReaderException,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StaleReaderException
/*    */   extends IOException
/*    */ {
/* 34 */   public StaleReaderException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\StaleReaderException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.StoredFieldsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.store.RAMOutputStream;
/*     */ import org.apache.lucene.util.ArrayUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class StoredFieldsWriter
/*     */   extends DocFieldConsumer
/*     */ {
/*     */   FieldsWriter fieldsWriter;
/*     */   final DocumentsWriter docWriter;
/*     */   int lastDocID;
/*  32 */   PerDoc[] docFreeList = new PerDoc[1];
/*     */   
/*     */   int freeCount;
/*     */   
/*  36 */   public StoredFieldsWriter(DocumentsWriter docWriter) { this.docWriter = docWriter; }
/*     */   int allocCount;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  40 */   public DocFieldConsumerPerThread addThread(DocFieldProcessorPerThread docFieldProcessorPerThread) throws IOException { return new StoredFieldsWriterPerThread(docFieldProcessorPerThread, this); }
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void flush(Map threadsAndFields, DocumentsWriter.FlushState state) throws IOException {
/*  45 */     if (state.numDocsInStore > 0) {
/*     */ 
/*     */ 
/*     */       
/*  49 */       initFieldsWriter();
/*     */ 
/*     */ 
/*     */       
/*  53 */       fill(state.numDocsInStore - this.docWriter.getDocStoreOffset());
/*     */     } 
/*     */     
/*  56 */     if (this.fieldsWriter != null)
/*  57 */       this.fieldsWriter.flush(); 
/*     */   }
/*     */   
/*     */   private void initFieldsWriter() throws IOException {
/*  61 */     if (this.fieldsWriter == null) {
/*  62 */       String docStoreSegment = this.docWriter.getDocStoreSegment();
/*  63 */       if (docStoreSegment != null) {
/*  64 */         assert docStoreSegment != null;
/*  65 */         this.fieldsWriter = new FieldsWriter(this.docWriter.directory, docStoreSegment, this.fieldInfos);
/*     */ 
/*     */         
/*  68 */         this.docWriter.addOpenFile(docStoreSegment + ""."" + ""fdt"");
/*  69 */         this.docWriter.addOpenFile(docStoreSegment + ""."" + ""fdx"");
/*  70 */         this.lastDocID = 0;
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public synchronized void closeDocStore(DocumentsWriter.FlushState state) throws IOException {
/*  76 */     int inc = state.numDocsInStore - this.lastDocID;
/*  77 */     if (inc > 0) {
/*  78 */       initFieldsWriter();
/*  79 */       fill(state.numDocsInStore - this.docWriter.getDocStoreOffset());
/*     */     } 
/*     */     
/*  82 */     if (this.fieldsWriter != null) {
/*  83 */       this.fieldsWriter.close();
/*  84 */       this.fieldsWriter = null;
/*  85 */       this.lastDocID = 0;
/*  86 */       assert state.docStoreSegmentName != null;
/*  87 */       state.flushedFiles.add(state.docStoreSegmentName + ""."" + ""fdt"");
/*  88 */       state.flushedFiles.add(state.docStoreSegmentName + ""."" + ""fdx"");
/*     */       
/*  90 */       state.docWriter.removeOpenFile(state.docStoreSegmentName + ""."" + ""fdt"");
/*  91 */       state.docWriter.removeOpenFile(state.docStoreSegmentName + ""."" + ""fdx"");
/*     */       
/*  93 */       if ((4 + state.numDocsInStore * 8) != state.directory.fileLength(state.docStoreSegmentName + ""."" + ""fdx"")) {
/*  94 */         throw new RuntimeException(""after flush: fdx size mismatch: "" + state.numDocsInStore + "" docs vs "" + state.directory.fileLength(state.docStoreSegmentName + ""."" + ""fdx"") + "" length in bytes of "" + state.docStoreSegmentName + ""."" + ""fdx"");
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   synchronized PerDoc getPerDoc() {
/* 101 */     if (this.freeCount == 0) {
/* 102 */       this.allocCount++;
/* 103 */       if (this.allocCount > this.docFreeList.length) {
/*     */ 
/*     */ 
/*     */         
/* 107 */         assert this.allocCount == 1 + this.docFreeList.length;
/* 108 */         this.docFreeList = new PerDoc[ArrayUtil.getNextSize(this.allocCount)];
/*     */       } 
/* 110 */       return new PerDoc();
/*     */     } 
/* 112 */     return this.docFreeList[--this.freeCount];
/*     */   }
/*     */   
/*     */   synchronized void abort() {
/* 116 */     if (this.fieldsWriter != null) {
/*     */       try {
/* 118 */         this.fieldsWriter.close();
/* 119 */       } catch (Throwable t) {}
/*     */       
/* 121 */       this.fieldsWriter = null;
/* 122 */       this.lastDocID = 0;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   void fill(int docID) throws IOException {
/* 128 */     int docStoreOffset = this.docWriter.getDocStoreOffset();
/*     */ 
/*     */ 
/*     */     
/* 132 */     int end = docID + docStoreOffset;
/* 133 */     while (this.lastDocID < end) {
/* 134 */       this.fieldsWriter.skipDocument();
/* 135 */       this.lastDocID++;
/*     */     } 
/*     */   }
/*     */   
/*     */   synchronized void finishDocument(PerDoc perDoc) throws IOException {
/* 140 */     assert this.docWriter.writer.testPoint(""StoredFieldsWriter.finishDocument start"");
/* 141 */     initFieldsWriter();
/*     */     
/* 143 */     fill(perDoc.docID);
/*     */ 
/*     */     
/* 146 */     this.fieldsWriter.flushDocument(perDoc.numStoredFields, perDoc.fdt);
/* 147 */     this.lastDocID++;
/* 148 */     perDoc.reset();
/* 149 */     free(perDoc);
/* 150 */     assert this.docWriter.writer.testPoint(""StoredFieldsWriter.finishDocument end"");
/*     */   }
/*     */ 
/*     */   
/* 154 */   public boolean freeRAM() { return false; }
/*     */ 
/*     */   
/*     */   synchronized void free(PerDoc perDoc) {
/* 158 */     assert this.freeCount < this.docFreeList.length;
/* 159 */     assert 0 == perDoc.numStoredFields;
/* 160 */     assert 0L == perDoc.fdt.length();
/* 161 */     assert 0L == perDoc.fdt.getFilePointer();
/* 162 */     this.docFreeList[this.freeCount++] = perDoc;
/*     */   }
/*     */ 
/*     */   
/*     */   class PerDoc
/*     */     extends DocumentsWriter.DocWriter
/*     */   {
/* 169 */     RAMOutputStream fdt = new RAMOutputStream(); int numStoredFields;
/*     */     private final StoredFieldsWriter this$0;
/*     */     
/*     */     void reset() {
/* 173 */       this.fdt.reset();
/* 174 */       this.numStoredFields = 0;
/*     */     }
/*     */     
/*     */     void abort() {
/* 178 */       reset();
/* 179 */       StoredFieldsWriter.this.free(this);
/*     */     }
/*     */ 
/*     */     
/* 183 */     public long sizeInBytes() { return this.fdt.sizeInBytes(); }
/*     */ 
/*     */ 
/*     */     
/* 187 */     public void finish() throws IOException { StoredFieldsWriter.this.finishDocument(this); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\StoredFieldsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.StoredFieldsWriterPerField,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.document.Fieldable;
/*    */ import org.apache.lucene.store.IndexOutput;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class StoredFieldsWriterPerField
/*    */   extends DocFieldConsumerPerField
/*    */ {
/*    */   final StoredFieldsWriterPerThread perThread;
/*    */   final FieldInfo fieldInfo;
/*    */   final DocumentsWriter.DocState docState;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public StoredFieldsWriterPerField(StoredFieldsWriterPerThread perThread, FieldInfo fieldInfo) {
/* 30 */     this.perThread = perThread;
/* 31 */     this.fieldInfo = fieldInfo;
/* 32 */     this.docState = perThread.docState;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void processFields(Fieldable[] fields, int count) throws IOException {
/*    */     StoredFieldsWriter.PerDoc doc;
/* 41 */     if (this.perThread.doc == null) {
/* 42 */       doc = this.perThread.doc = this.perThread.storedFieldsWriter.getPerDoc();
/* 43 */       doc.docID = this.docState.docID;
/* 44 */       this.perThread.localFieldsWriter.setFieldsStream((IndexOutput)doc.fdt);
/* 45 */       assert doc.numStoredFields == 0 : ""doc.numStoredFields="" + doc.numStoredFields;
/* 46 */       assert 0L == doc.fdt.length();
/* 47 */       assert 0L == doc.fdt.getFilePointer();
/*    */     } else {
/* 49 */       doc = this.perThread.doc;
/* 50 */       assert doc.docID == this.docState.docID : ""doc.docID="" + doc.docID + "" docState.docID="" + this.docState.docID;
/*    */     } 
/*    */     
/* 53 */     for (int i = 0; i < count; i++) {
/* 54 */       Fieldable field = fields[i];
/* 55 */       if (field.isStored()) {
/* 56 */         this.perThread.localFieldsWriter.writeField(this.fieldInfo, field);
/* 57 */         assert this.docState.testPoint(""StoredFieldsWriterPerField.processFields.writeField"");
/* 58 */         doc.numStoredFields++;
/*    */       } 
/*    */     } 
/*    */   }
/*    */   
/*    */   void abort() {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\StoredFieldsWriterPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.StoredFieldsWriterPerThread,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.store.IndexOutput;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class StoredFieldsWriterPerThread
/*    */   extends DocFieldConsumerPerThread
/*    */ {
/*    */   final FieldsWriter localFieldsWriter;
/*    */   final StoredFieldsWriter storedFieldsWriter;
/*    */   final DocumentsWriter.DocState docState;
/*    */   StoredFieldsWriter.PerDoc doc;
/*    */   
/*    */   public StoredFieldsWriterPerThread(DocFieldProcessorPerThread docFieldProcessorPerThread, StoredFieldsWriter storedFieldsWriter) throws IOException {
/* 32 */     this.storedFieldsWriter = storedFieldsWriter;
/* 33 */     this.docState = docFieldProcessorPerThread.docState;
/* 34 */     this.localFieldsWriter = new FieldsWriter((IndexOutput)null, (IndexOutput)null, storedFieldsWriter.fieldInfos);
/*    */   }
/*    */   
/*    */   public void startDocument() {
/* 38 */     if (this.doc != null) {
/*    */ 
/*    */ 
/*    */       
/* 42 */       this.doc.reset();
/* 43 */       this.doc.docID = this.docState.docID;
/*    */     } 
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public DocumentsWriter.DocWriter finishDocument() {
/*    */     try {
/* 51 */       return this.doc;
/*    */     } finally {
/* 53 */       this.doc = null;
/*    */     } 
/*    */   }
/*    */   
/*    */   public void abort() {
/* 58 */     if (this.doc != null) {
/* 59 */       this.doc.abort();
/* 60 */       this.doc = null;
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 65 */   public DocFieldConsumerPerField addField(FieldInfo fieldInfo) { return new StoredFieldsWriterPerField(this, fieldInfo); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\StoredFieldsWriterPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.Term,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.ObjectInputStream;
/*     */ import java.io.Serializable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Term
/*     */   implements Comparable, Serializable
/*     */ {
/*     */   String field;
/*     */   String text;
/*     */   
/*  36 */   public Term(String fld, String txt) { this(fld, txt, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  46 */   public Term(String fld) { this(fld, """", true); }
/*     */ 
/*     */   
/*     */   Term(String fld, String txt, boolean intern) {
/*  50 */     this.field = intern ? fld.intern() : fld;
/*  51 */     this.text = txt;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  56 */   public final String field() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  61 */   public final String text() { return this.text; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  71 */   public Term createTerm(String text) { return new Term(this.field, text, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean equals(Object o) {
/*  77 */     if (o == this)
/*  78 */       return true; 
/*  79 */     if (o == null)
/*  80 */       return false; 
/*  81 */     if (!(o instanceof Term))
/*  82 */       return false; 
/*  83 */     Term other = (Term)o;
/*  84 */     return (this.field == other.field && this.text.equals(other.text));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  89 */   public final int hashCode() { return this.field.hashCode() + this.text.hashCode(); }
/*     */ 
/*     */ 
/*     */   
/*  93 */   public int compareTo(Object other) { return compareTo((Term)other); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int compareTo(Term other) {
/* 102 */     if (this.field == other.field) {
/* 103 */       return this.text.compareTo(other.text);
/*     */     }
/* 105 */     return this.field.compareTo(other.field);
/*     */   }
/*     */ 
/*     */   
/*     */   final void set(String fld, String txt) {
/* 110 */     this.field = fld;
/* 111 */     this.text = txt;
/*     */   }
/*     */   
/* 114 */   public final String toString() { return this.field + "":"" + this.text; }
/*     */ 
/*     */ 
/*     */   
/*     */   private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
/* 119 */     in.defaultReadObject();
/* 120 */     this.field = this.field.intern();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\Term.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermBuffer,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.util.UnicodeUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermBuffer
/*     */   implements Cloneable
/*     */ {
/*     */   private String field;
/*     */   private Term term;
/*     */   private boolean preUTF8Strings;
/*     */   private boolean dirty;
/*  31 */   private UnicodeUtil.UTF16Result text = new UnicodeUtil.UTF16Result();
/*  32 */   private UnicodeUtil.UTF8Result bytes = new UnicodeUtil.UTF8Result();
/*     */   
/*     */   public final int compareTo(TermBuffer other) {
/*  35 */     if (this.field == other.field) {
/*  36 */       return compareChars(this.text.result, this.text.length, other.text.result, other.text.length);
/*     */     }
/*  38 */     return this.field.compareTo(other.field);
/*     */   }
/*     */ 
/*     */   
/*     */   private static final int compareChars(char[] chars1, int len1, char[] chars2, int len2) {
/*  43 */     int end = (len1 < len2) ? len1 : len2;
/*  44 */     for (int k = 0; k < end; k++) {
/*  45 */       char c1 = chars1[k];
/*  46 */       char c2 = chars2[k];
/*  47 */       if (c1 != c2) {
/*  48 */         return c1 - c2;
/*     */       }
/*     */     } 
/*  51 */     return len1 - len2;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  58 */   void setPreUTF8Strings() { this.preUTF8Strings = true; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void read(IndexInput input, FieldInfos fieldInfos) throws IOException {
/*  63 */     this.term = null;
/*  64 */     int start = input.readVInt();
/*  65 */     int length = input.readVInt();
/*  66 */     int totalLength = start + length;
/*  67 */     if (this.preUTF8Strings) {
/*  68 */       this.text.setLength(totalLength);
/*  69 */       input.readChars(this.text.result, start, length);
/*     */     
/*     */     }
/*  72 */     else if (this.dirty) {
/*     */       
/*  74 */       UnicodeUtil.UTF16toUTF8(this.text.result, 0, this.text.length, this.bytes);
/*  75 */       this.bytes.setLength(totalLength);
/*  76 */       input.readBytes(this.bytes.result, start, length);
/*  77 */       UnicodeUtil.UTF8toUTF16(this.bytes.result, 0, totalLength, this.text);
/*  78 */       this.dirty = false;
/*     */     } else {
/*     */       
/*  81 */       this.bytes.setLength(totalLength);
/*  82 */       input.readBytes(this.bytes.result, start, length);
/*  83 */       UnicodeUtil.UTF8toUTF16(this.bytes.result, start, length, this.text);
/*     */     } 
/*     */     
/*  86 */     this.field = fieldInfos.fieldName(input.readVInt());
/*     */   }
/*     */   
/*     */   public final void set(Term term) {
/*  90 */     if (term == null) {
/*  91 */       reset();
/*     */       return;
/*     */     } 
/*  94 */     String termText = term.text();
/*  95 */     int termLen = termText.length();
/*  96 */     this.text.setLength(termLen);
/*  97 */     termText.getChars(0, termLen, this.text.result, 0);
/*  98 */     this.dirty = true;
/*  99 */     this.field = term.field();
/* 100 */     this.term = term;
/*     */   }
/*     */   
/*     */   public final void set(TermBuffer other) {
/* 104 */     this.text.copyText(other.text);
/* 105 */     this.dirty = true;
/* 106 */     this.field = other.field;
/* 107 */     this.term = other.term;
/*     */   }
/*     */   
/*     */   public void reset() {
/* 111 */     this.field = null;
/* 112 */     this.text.setLength(0);
/* 113 */     this.term = null;
/* 114 */     this.dirty = true;
/*     */   }
/*     */   
/*     */   public Term toTerm() {
/* 118 */     if (this.field == null) {
/* 119 */       return null;
/*     */     }
/* 121 */     if (this.term == null) {
/* 122 */       this.term = new Term(this.field, new String(this.text.result, 0, this.text.length), false);
/*     */     }
/* 124 */     return this.term;
/*     */   }
/*     */   
/*     */   protected Object clone() {
/* 128 */     TermBuffer clone = null;
/*     */     try {
/* 130 */       clone = (TermBuffer)super.clone();
/* 131 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 133 */     clone.dirty = true;
/* 134 */     clone.bytes = new UnicodeUtil.UTF8Result();
/* 135 */     clone.text = new UnicodeUtil.UTF16Result();
/* 136 */     clone.text.copyText(this.text);
/* 137 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermBuffer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermDocs,"package org.apache.lucene.index;
import java.io.IOException;
public interface TermDocs {
  void seek(Term paramTerm) throws IOException;
  void seek(TermEnum paramTermEnum) throws IOException;
  int doc();
  int freq();
  boolean next() throws IOException;
  int read(int[] paramArrayOfint1, int[] paramArrayOfint2) throws IOException;
  boolean skipTo(int paramInt) throws IOException;
  void close() throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermEnum,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TermEnum
/*    */ {
/*    */   public abstract boolean next() throws IOException;
/*    */   
/*    */   public abstract Term term();
/*    */   
/*    */   public abstract int docFreq();
/*    */   
/*    */   public abstract void close() throws IOException;
/*    */   
/*    */   public boolean skipTo(Term target) throws IOException {
/*    */     do {
/* 57 */       if (!next())
/* 58 */         return false; 
/* 59 */     } while (target.compareTo(term()) > 0);
/* 60 */     return true;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermFreqVector,"package org.apache.lucene.index;
public interface TermFreqVector {
  String getField();
  int size();
  String[] getTerms();
  int[] getTermFrequencies();
  int indexOf(String paramString);
  int[] indexesOf(String[] paramArrayOfString, int paramInt1, int paramInt2);
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermFreqVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class TermInfo
/*    */ {
/* 24 */   int docFreq = 0;
/*    */   
/* 26 */   long freqPointer = 0L;
/* 27 */   long proxPointer = 0L;
/*    */   int skipOffset;
/*    */   
/*    */   TermInfo() {}
/*    */   
/*    */   TermInfo(int df, long fp, long pp) {
/* 33 */     this.docFreq = df;
/* 34 */     this.freqPointer = fp;
/* 35 */     this.proxPointer = pp;
/*    */   }
/*    */   
/*    */   TermInfo(TermInfo ti) {
/* 39 */     this.docFreq = ti.docFreq;
/* 40 */     this.freqPointer = ti.freqPointer;
/* 41 */     this.proxPointer = ti.proxPointer;
/* 42 */     this.skipOffset = ti.skipOffset;
/*    */   }
/*    */ 
/*    */   
/*    */   final void set(int docFreq, long freqPointer, long proxPointer, int skipOffset) {
/* 47 */     this.docFreq = docFreq;
/* 48 */     this.freqPointer = freqPointer;
/* 49 */     this.proxPointer = proxPointer;
/* 50 */     this.skipOffset = skipOffset;
/*    */   }
/*    */   
/*    */   final void set(TermInfo ti) {
/* 54 */     this.docFreq = ti.docFreq;
/* 55 */     this.freqPointer = ti.freqPointer;
/* 56 */     this.proxPointer = ti.proxPointer;
/* 57 */     this.skipOffset = ti.skipOffset;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfosReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.util.CloseableThreadLocal;
/*     */ import org.apache.lucene.util.cache.Cache;
/*     */ import org.apache.lucene.util.cache.SimpleLRUCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermInfosReader
/*     */ {
/*     */   private Directory directory;
/*     */   private String segment;
/*     */   private FieldInfos fieldInfos;
/*  37 */   private CloseableThreadLocal threadResources = new CloseableThreadLocal();
/*     */   
/*     */   private SegmentTermEnum origEnum;
/*     */   private long size;
/*  41 */   private Term[] indexTerms = null;
/*     */   
/*     */   private TermInfo[] indexInfos;
/*     */   
/*     */   private long[] indexPointers;
/*     */   private SegmentTermEnum indexEnum;
/*  47 */   private int indexDivisor = 1;
/*     */   
/*     */   private int totalIndexInterval;
/*     */   
/*     */   private static final int DEFAULT_CACHE_SIZE = 1024;
/*     */ 
/*     */   
/*     */   private static final class ThreadResources
/*     */   {
/*     */     SegmentTermEnum termEnum;
/*     */     
/*     */     Cache termInfoCache;
/*     */ 
/*     */     
/*     */     private ThreadResources() {}
/*     */   }
/*     */   
/*  64 */   TermInfosReader(Directory dir, String seg, FieldInfos fis) throws CorruptIndexException, IOException { this(dir, seg, fis, 1024); }
/*     */ 
/*     */ 
/*     */   
/*     */   TermInfosReader(Directory dir, String seg, FieldInfos fis, int readBufferSize) throws CorruptIndexException, IOException {
/*  69 */     boolean success = false;
/*     */     
/*     */     try {
/*  72 */       this.directory = dir;
/*  73 */       this.segment = seg;
/*  74 */       this.fieldInfos = fis;
/*     */       
/*  76 */       this.origEnum = new SegmentTermEnum(this.directory.openInput(this.segment + ""."" + ""tis"", readBufferSize), this.fieldInfos, false);
/*     */       
/*  78 */       this.size = this.origEnum.size;
/*  79 */       this.totalIndexInterval = this.origEnum.indexInterval;
/*     */       
/*  81 */       this.indexEnum = new SegmentTermEnum(this.directory.openInput(this.segment + ""."" + ""tii"", readBufferSize), this.fieldInfos, true);
/*     */ 
/*     */       
/*  84 */       success = true;
/*     */ 
/*     */     
/*     */     }
/*     */     finally {
/*     */ 
/*     */       
/*  91 */       if (!success) {
/*  92 */         close();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*  98 */   public int getSkipInterval() { return this.origEnum.skipInterval; }
/*     */ 
/*     */ 
/*     */   
/* 102 */   public int getMaxSkipLevels() { return this.origEnum.maxSkipLevels; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setIndexDivisor(int indexDivisor) throws IllegalStateException {
/* 125 */     if (indexDivisor < 1) {
/* 126 */       throw new IllegalArgumentException(""indexDivisor must be > 0: got "" + indexDivisor);
/*     */     }
/* 128 */     if (this.indexTerms != null) {
/* 129 */       throw new IllegalStateException(""index terms are already loaded"");
/*     */     }
/* 131 */     this.indexDivisor = indexDivisor;
/* 132 */     this.totalIndexInterval = this.origEnum.indexInterval * indexDivisor;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 139 */   public int getIndexDivisor() { return this.indexDivisor; }
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/* 143 */     if (this.origEnum != null)
/* 144 */       this.origEnum.close(); 
/* 145 */     if (this.indexEnum != null)
/* 146 */       this.indexEnum.close(); 
/* 147 */     this.threadResources.close();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 152 */   final long size() { return this.size; }
/*     */ 
/*     */   
/*     */   private ThreadResources getThreadResources() {
/* 156 */     ThreadResources resources = (ThreadResources)this.threadResources.get();
/* 157 */     if (resources == null) {
/* 158 */       resources = new ThreadResources();
/* 159 */       resources.termEnum = terms();
/*     */       
/* 161 */       resources.termInfoCache = (Cache)new SimpleLRUCache(1024);
/* 162 */       this.threadResources.set(resources);
/*     */     } 
/* 164 */     return resources;
/*     */   }
/*     */   
/*     */   private synchronized void ensureIndexIsRead() throws IOException {
/* 168 */     if (this.indexTerms != null)
/*     */       return; 
/*     */     try {
/* 171 */       int indexSize = 1 + ((int)this.indexEnum.size - 1) / this.indexDivisor;
/*     */       
/* 173 */       this.indexTerms = new Term[indexSize];
/* 174 */       this.indexInfos = new TermInfo[indexSize];
/* 175 */       this.indexPointers = new long[indexSize];
/*     */       
/* 177 */       for (int i = 0; this.indexEnum.next(); i++) {
/* 178 */         this.indexTerms[i] = this.indexEnum.term();
/* 179 */         this.indexInfos[i] = this.indexEnum.termInfo();
/* 180 */         this.indexPointers[i] = this.indexEnum.indexPointer;
/*     */         
/* 182 */         for (int j = 1; j < this.indexDivisor && 
/* 183 */           this.indexEnum.next(); j++);
/*     */       } 
/*     */     } finally {
/*     */       
/* 187 */       this.indexEnum.close();
/* 188 */       this.indexEnum = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final int getIndexOffset(Term term) {
/* 194 */     int lo = 0;
/* 195 */     int hi = this.indexTerms.length - 1;
/*     */     
/* 197 */     while (hi >= lo) {
/* 198 */       int mid = lo + hi >> 1;
/* 199 */       int delta = term.compareTo(this.indexTerms[mid]);
/* 200 */       if (delta < 0) {
/* 201 */         hi = mid - 1; continue;
/* 202 */       }  if (delta > 0) {
/* 203 */         lo = mid + 1; continue;
/*     */       } 
/* 205 */       return mid;
/*     */     } 
/* 207 */     return hi;
/*     */   }
/*     */ 
/*     */   
/* 211 */   private final void seekEnum(SegmentTermEnum enumerator, int indexOffset) throws IOException { enumerator.seek(this.indexPointers[indexOffset], indexOffset * this.totalIndexInterval - 1, this.indexTerms[indexOffset], this.indexInfos[indexOffset]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 218 */   TermInfo get(Term term) throws IOException { return get(term, true); }
/*     */ 
/*     */   
/*     */   private TermInfo get(Term term, boolean useCache) throws IOException {
/*     */     TermInfo ti;
/* 223 */     if (this.size == 0L) return null;
/*     */     
/* 225 */     ensureIndexIsRead();
/*     */ 
/*     */     
/* 228 */     ThreadResources resources = getThreadResources();
/* 229 */     Cache cache = null;
/*     */     
/* 231 */     if (useCache) {
/* 232 */       cache = resources.termInfoCache;
/*     */       
/* 234 */       ti = (TermInfo)cache.get(term);
/* 235 */       if (ti != null) {
/* 236 */         return ti;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 241 */     SegmentTermEnum enumerator = resources.termEnum;
/* 242 */     if (enumerator.term() != null && ((enumerator.prev() != null && term.compareTo(enumerator.prev()) > 0) || term.compareTo(enumerator.term()) >= 0)) {
/*     */ 
/*     */       
/* 245 */       int enumOffset = (int)(enumerator.position / this.totalIndexInterval) + 1;
/* 246 */       if (this.indexTerms.length == enumOffset || term.compareTo(this.indexTerms[enumOffset]) < 0) {
/*     */ 
/*     */ 
/*     */         
/* 250 */         int numScans = enumerator.scanTo(term);
/* 251 */         if (enumerator.term() != null && term.compareTo(enumerator.term()) == 0) {
/* 252 */           ti = enumerator.termInfo();
/* 253 */           if (cache != null && numScans > 1)
/*     */           {
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 259 */             cache.put(term, ti);
/*     */           }
/*     */         } else {
/* 262 */           ti = null;
/*     */         } 
/*     */         
/* 265 */         return ti;
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 270 */     seekEnum(enumerator, getIndexOffset(term));
/* 271 */     enumerator.scanTo(term);
/* 272 */     if (enumerator.term() != null && term.compareTo(enumerator.term()) == 0) {
/* 273 */       ti = enumerator.termInfo();
/* 274 */       if (cache != null) {
/* 275 */         cache.put(term, ti);
/*     */       }
/*     */     } else {
/* 278 */       ti = null;
/*     */     } 
/* 280 */     return ti;
/*     */   }
/*     */ 
/*     */   
/*     */   final Term get(int position) throws IOException {
/* 285 */     if (this.size == 0L) return null;
/*     */     
/* 287 */     SegmentTermEnum enumerator = (getThreadResources()).termEnum;
/* 288 */     if (enumerator != null && enumerator.term() != null && position >= enumerator.position && position < enumerator.position + this.totalIndexInterval)
/*     */     {
/*     */       
/* 291 */       return scanEnum(enumerator, position);
/*     */     }
/* 293 */     seekEnum(enumerator, position / this.totalIndexInterval);
/* 294 */     return scanEnum(enumerator, position);
/*     */   }
/*     */   
/*     */   private final Term scanEnum(SegmentTermEnum enumerator, int position) throws IOException {
/* 298 */     while (enumerator.position < position) {
/* 299 */       if (!enumerator.next())
/* 300 */         return null; 
/*     */     } 
/* 302 */     return enumerator.term();
/*     */   }
/*     */ 
/*     */   
/*     */   final long getPosition(Term term) throws IOException {
/* 307 */     if (this.size == 0L) return -1L;
/*     */     
/* 309 */     ensureIndexIsRead();
/* 310 */     int indexOffset = getIndexOffset(term);
/*     */     
/* 312 */     SegmentTermEnum enumerator = (getThreadResources()).termEnum;
/* 313 */     seekEnum(enumerator, indexOffset);
/*     */     
/* 315 */     while (term.compareTo(enumerator.term()) > 0 && enumerator.next());
/*     */     
/* 317 */     if (term.compareTo(enumerator.term()) == 0) {
/* 318 */       return enumerator.position;
/*     */     }
/* 320 */     return -1L;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 325 */   public SegmentTermEnum terms() { return (SegmentTermEnum)this.origEnum.clone(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SegmentTermEnum terms(Term term) throws IOException {
/* 332 */     get(term, false);
/* 333 */     return (SegmentTermEnum)(getThreadResources()).termEnum.clone();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermInfosReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfosWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.UnicodeUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermInfosWriter
/*     */ {
/*     */   public static final int FORMAT = -3;
/*     */   public static final int FORMAT_VERSION_UTF8_LENGTH_IN_BYTES = -4;
/*     */   public static final int FORMAT_CURRENT = -4;
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexOutput output;
/*  42 */   private TermInfo lastTi = new TermInfo();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private long size;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  57 */   int indexInterval = 128;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   int skipInterval = 16;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  69 */   int maxSkipLevels = 10;
/*     */   
/*     */   private long lastIndexPointer;
/*     */   private boolean isIndex;
/*  73 */   private byte[] lastTermBytes = new byte[10];
/*  74 */   private int lastTermBytesLength = 0;
/*  75 */   private int lastFieldNumber = -1;
/*     */   
/*     */   private TermInfosWriter other;
/*  78 */   private UnicodeUtil.UTF8Result utf8Result = new UnicodeUtil.UTF8Result();
/*     */   
/*     */   UnicodeUtil.UTF16Result utf16Result1;
/*     */   
/*     */   TermInfosWriter(Directory directory, String segment, FieldInfos fis, int interval) throws IOException {
/*  83 */     initialize(directory, segment, fis, interval, false);
/*  84 */     this.other = new TermInfosWriter(directory, segment, fis, interval, true);
/*  85 */     this.other.other = this;
/*     */   }
/*     */   UnicodeUtil.UTF16Result utf16Result2;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  90 */   private TermInfosWriter(Directory directory, String segment, FieldInfos fis, int interval, boolean isIndex) throws IOException { initialize(directory, segment, fis, interval, isIndex); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void initialize(Directory directory, String segment, FieldInfos fis, int interval, boolean isi) throws IOException {
/*  95 */     this.indexInterval = interval;
/*  96 */     this.fieldInfos = fis;
/*  97 */     this.isIndex = isi;
/*  98 */     this.output = directory.createOutput(segment + (this.isIndex ? "".tii"" : "".tis""));
/*  99 */     this.output.writeInt(-4);
/* 100 */     this.output.writeLong(0L);
/* 101 */     this.output.writeInt(this.indexInterval);
/* 102 */     this.output.writeInt(this.skipInterval);
/* 103 */     this.output.writeInt(this.maxSkipLevels);
/* 104 */     assert initUTF16Results();
/*     */   }
/*     */   
/*     */   void add(Term term, TermInfo ti) throws IOException {
/* 108 */     UnicodeUtil.UTF16toUTF8(term.text, 0, term.text.length(), this.utf8Result);
/* 109 */     add(this.fieldInfos.fieldNumber(term.field), this.utf8Result.result, this.utf8Result.length, ti);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean initUTF16Results() {
/* 118 */     this.utf16Result1 = new UnicodeUtil.UTF16Result();
/* 119 */     this.utf16Result2 = new UnicodeUtil.UTF16Result();
/* 120 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   private int compareToLastTerm(int fieldNumber, byte[] termBytes, int termBytesLength) {
/*     */     int len;
/* 126 */     if (this.lastFieldNumber != fieldNumber) {
/* 127 */       len = this.fieldInfos.fieldName(this.lastFieldNumber).compareTo(this.fieldInfos.fieldName(fieldNumber));
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 132 */       if (len != 0 || this.lastFieldNumber != -1) {
/* 133 */         return len;
/*     */       }
/*     */     } 
/* 136 */     UnicodeUtil.UTF8toUTF16(this.lastTermBytes, 0, this.lastTermBytesLength, this.utf16Result1);
/* 137 */     UnicodeUtil.UTF8toUTF16(termBytes, 0, termBytesLength, this.utf16Result2);
/*     */     
/* 139 */     if (this.utf16Result1.length < this.utf16Result2.length) {
/* 140 */       len = this.utf16Result1.length;
/*     */     } else {
/* 142 */       len = this.utf16Result2.length;
/*     */     } 
/* 144 */     for (int i = 0; i < len; i++) {
/* 145 */       char ch1 = this.utf16Result1.result[i];
/* 146 */       char ch2 = this.utf16Result2.result[i];
/* 147 */       if (ch1 != ch2)
/* 148 */         return ch1 - ch2; 
/*     */     } 
/* 150 */     return this.utf16Result1.length - this.utf16Result2.length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void add(int fieldNumber, byte[] termBytes, int termBytesLength, TermInfo ti) throws IOException {
/* 161 */     assert compareToLastTerm(fieldNumber, termBytes, termBytesLength) < 0 || (this.isIndex && termBytesLength == 0 && this.lastTermBytesLength == 0) : ""Terms are out of order: field="" + this.fieldInfos.fieldName(fieldNumber) + "" (number "" + fieldNumber + "")"" + "" lastField="" + this.fieldInfos.fieldName(this.lastFieldNumber) + "" (number "" + this.lastFieldNumber + "")"" + "" text="" + new String(termBytes, false, termBytesLength, ""UTF-8"") + "" lastText="" + new String(this.lastTermBytes, false, this.lastTermBytesLength, ""UTF-8"");
/*     */ 
/*     */ 
/*     */     
/* 165 */     assert ti.freqPointer >= this.lastTi.freqPointer : ""freqPointer out of order ("" + ti.freqPointer + "" < "" + this.lastTi.freqPointer + "")"";
/* 166 */     assert ti.proxPointer >= this.lastTi.proxPointer : ""proxPointer out of order ("" + ti.proxPointer + "" < "" + this.lastTi.proxPointer + "")"";
/*     */     
/* 168 */     if (!this.isIndex && this.size % this.indexInterval == 0L) {
/* 169 */       this.other.add(this.lastFieldNumber, this.lastTermBytes, this.lastTermBytesLength, this.lastTi);
/*     */     }
/* 171 */     writeTerm(fieldNumber, termBytes, termBytesLength);
/*     */     
/* 173 */     this.output.writeVInt(ti.docFreq);
/* 174 */     this.output.writeVLong(ti.freqPointer - this.lastTi.freqPointer);
/* 175 */     this.output.writeVLong(ti.proxPointer - this.lastTi.proxPointer);
/*     */     
/* 177 */     if (ti.docFreq >= this.skipInterval) {
/* 178 */       this.output.writeVInt(ti.skipOffset);
/*     */     }
/*     */     
/* 181 */     if (this.isIndex) {
/* 182 */       this.output.writeVLong(this.other.output.getFilePointer() - this.lastIndexPointer);
/* 183 */       this.lastIndexPointer = this.other.output.getFilePointer();
/*     */     } 
/*     */     
/* 186 */     this.lastFieldNumber = fieldNumber;
/* 187 */     this.lastTi.set(ti);
/* 188 */     this.size++;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void writeTerm(int fieldNumber, byte[] termBytes, int termBytesLength) throws IOException {
/* 196 */     int start = 0;
/* 197 */     int limit = (termBytesLength < this.lastTermBytesLength) ? termBytesLength : this.lastTermBytesLength;
/* 198 */     while (start < limit && 
/* 199 */       termBytes[start] == this.lastTermBytes[start])
/*     */     {
/* 201 */       start++;
/*     */     }
/*     */     
/* 204 */     int length = termBytesLength - start;
/* 205 */     this.output.writeVInt(start);
/* 206 */     this.output.writeVInt(length);
/* 207 */     this.output.writeBytes(termBytes, start, length);
/* 208 */     this.output.writeVInt(fieldNumber);
/* 209 */     if (this.lastTermBytes.length < termBytesLength) {
/* 210 */       byte[] newArray = new byte[(int)(termBytesLength * 1.5D)];
/* 211 */       System.arraycopy(this.lastTermBytes, 0, newArray, 0, start);
/* 212 */       this.lastTermBytes = newArray;
/*     */     } 
/* 214 */     System.arraycopy(termBytes, start, this.lastTermBytes, start, length);
/* 215 */     this.lastTermBytesLength = termBytesLength;
/*     */   }
/*     */ 
/*     */   
/*     */   void close() throws IOException {
/* 220 */     this.output.seek(4L);
/* 221 */     this.output.writeLong(this.size);
/* 222 */     this.output.close();
/*     */     
/* 224 */     if (!this.isIndex)
/* 225 */       this.other.close(); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermInfosWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermPositions,"package org.apache.lucene.index;
import java.io.IOException;
public interface TermPositions extends TermDocs {
  int nextPosition() throws IOException;
  int getPayloadLength();
  byte[] getPayload(byte[] paramArrayOfbyte, int paramInt) throws IOException;
  boolean isPayloadAvailable();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermPositionVector,"package org.apache.lucene.index;
public interface TermPositionVector extends TermFreqVector {
  int[] getTermPositions(int paramInt);
  TermVectorOffsetInfo[] getOffsets(int paramInt);
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermPositionVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermsHash,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.util.ArrayUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermsHash
/*     */   extends InvertedDocConsumer
/*     */ {
/*     */   final TermsHashConsumer consumer;
/*     */   final TermsHash nextTermsHash;
/*     */   final int bytesPerPosting;
/*     */   final int postingsFreeChunk;
/*     */   final DocumentsWriter docWriter;
/*     */   private TermsHash primaryTermsHash;
/*  49 */   private RawPostingList[] postingsFreeList = new RawPostingList[1];
/*     */   
/*     */   private int postingsFreeCount;
/*     */   private int postingsAllocCount;
/*     */   
/*     */   public TermsHash(DocumentsWriter docWriter, boolean trackAllocations, TermsHashConsumer consumer, TermsHash nextTermsHash) {
/*  55 */     this.docWriter = docWriter;
/*  56 */     this.consumer = consumer;
/*  57 */     this.nextTermsHash = nextTermsHash;
/*  58 */     this.trackAllocations = trackAllocations;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  65 */     this.bytesPerPosting = consumer.bytesPerPosting() + 16;
/*  66 */     this.postingsFreeChunk = 32768 / this.bytesPerPosting;
/*     */   }
/*     */   boolean trackAllocations; static final boolean $assertionsDisabled;
/*     */   
/*  70 */   InvertedDocConsumerPerThread addThread(DocInverterPerThread docInverterPerThread) { return new TermsHashPerThread(docInverterPerThread, this, this.nextTermsHash, null); }
/*     */ 
/*     */ 
/*     */   
/*  74 */   TermsHashPerThread addThread(DocInverterPerThread docInverterPerThread, TermsHashPerThread primaryPerThread) { return new TermsHashPerThread(docInverterPerThread, this, this.nextTermsHash, primaryPerThread); }
/*     */ 
/*     */   
/*     */   void setFieldInfos(FieldInfos fieldInfos) {
/*  78 */     this.fieldInfos = fieldInfos;
/*  79 */     this.consumer.setFieldInfos(fieldInfos);
/*     */   }
/*     */   
/*     */   public synchronized void abort() {
/*  83 */     this.consumer.abort();
/*  84 */     if (this.nextTermsHash != null) {
/*  85 */       this.nextTermsHash.abort();
/*     */     }
/*     */   }
/*     */   
/*     */   void shrinkFreePostings(Map threadsAndFields, DocumentsWriter.FlushState state) {
/*  90 */     assert this.postingsFreeCount == this.postingsAllocCount : Thread.currentThread().getName() + "": postingsFreeCount="" + this.postingsFreeCount + "" postingsAllocCount="" + this.postingsAllocCount + "" consumer="" + this.consumer;
/*     */     
/*  92 */     int newSize = ArrayUtil.getShrinkSize(this.postingsFreeList.length, this.postingsAllocCount);
/*  93 */     if (newSize != this.postingsFreeList.length) {
/*  94 */       RawPostingList[] newArray = new RawPostingList[newSize];
/*  95 */       System.arraycopy(this.postingsFreeList, 0, newArray, 0, this.postingsFreeCount);
/*  96 */       this.postingsFreeList = newArray;
/*     */     } 
/*     */   }
/*     */   
/*     */   synchronized void closeDocStore(DocumentsWriter.FlushState state) throws IOException {
/* 101 */     this.consumer.closeDocStore(state);
/* 102 */     if (this.nextTermsHash != null)
/* 103 */       this.nextTermsHash.closeDocStore(state); 
/*     */   }
/*     */   synchronized void flush(Map threadsAndFields, DocumentsWriter.FlushState state) throws IOException {
/*     */     Map nextThreadsAndFields;
/* 107 */     Map childThreadsAndFields = new HashMap();
/*     */ 
/*     */     
/* 110 */     if (this.nextTermsHash != null) {
/* 111 */       nextThreadsAndFields = (Map)new HashMap();
/*     */     } else {
/* 113 */       nextThreadsAndFields = null;
/*     */     } 
/* 115 */     Iterator it = threadsAndFields.entrySet().iterator();
/* 116 */     while (it.hasNext()) {
/*     */       Collection nextChildFields;
/* 118 */       Map.Entry entry = it.next();
/*     */       
/* 120 */       TermsHashPerThread perThread = (TermsHashPerThread)entry.getKey();
/*     */       
/* 122 */       Collection fields = (Collection)entry.getValue();
/*     */       
/* 124 */       Iterator fieldsIt = fields.iterator();
/* 125 */       Collection childFields = new HashSet();
/*     */ 
/*     */       
/* 128 */       if (this.nextTermsHash != null) {
/* 129 */         nextChildFields = new HashSet();
/*     */       } else {
/* 131 */         nextChildFields = null;
/*     */       } 
/* 133 */       while (fieldsIt.hasNext()) {
/* 134 */         TermsHashPerField perField = fieldsIt.next();
/* 135 */         childFields.add(perField.consumer);
/* 136 */         if (this.nextTermsHash != null) {
/* 137 */           nextChildFields.add(perField.nextPerField);
/*     */         }
/*     */       } 
/* 140 */       childThreadsAndFields.put(perThread.consumer, childFields);
/* 141 */       if (this.nextTermsHash != null) {
/* 142 */         nextThreadsAndFields.put(perThread.nextPerThread, nextChildFields);
/*     */       }
/*     */     } 
/* 145 */     this.consumer.flush(childThreadsAndFields, state);
/*     */     
/* 147 */     shrinkFreePostings(threadsAndFields, state);
/*     */     
/* 149 */     if (this.nextTermsHash != null)
/* 150 */       this.nextTermsHash.flush(nextThreadsAndFields, state); 
/*     */   }
/*     */   
/*     */   public synchronized boolean freeRAM() {
/*     */     int numToFree;
/* 155 */     if (!this.trackAllocations) {
/* 156 */       return false;
/*     */     }
/*     */ 
/*     */     
/* 160 */     if (this.postingsFreeCount >= this.postingsFreeChunk) {
/* 161 */       numToFree = this.postingsFreeChunk;
/*     */     } else {
/* 163 */       numToFree = this.postingsFreeCount;
/* 164 */     }  boolean any = (numToFree > 0);
/* 165 */     if (any) {
/* 166 */       Arrays.fill((Object[])this.postingsFreeList, this.postingsFreeCount - numToFree, this.postingsFreeCount, null);
/* 167 */       this.postingsFreeCount -= numToFree;
/* 168 */       this.postingsAllocCount -= numToFree;
/* 169 */       this.docWriter.bytesAllocated((-numToFree * this.bytesPerPosting));
/* 170 */       any = true;
/*     */     } 
/*     */     
/* 173 */     if (this.nextTermsHash != null) {
/* 174 */       any |= this.nextTermsHash.freeRAM();
/*     */     }
/* 176 */     return any;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void recyclePostings(RawPostingList[] postings, int numPostings) {
/* 181 */     assert postings.length >= numPostings;
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 186 */     assert this.postingsFreeCount + numPostings <= this.postingsFreeList.length;
/* 187 */     System.arraycopy(postings, 0, this.postingsFreeList, this.postingsFreeCount, numPostings);
/* 188 */     this.postingsFreeCount += numPostings;
/*     */   }
/*     */   
/*     */   public synchronized void getPostings(RawPostingList[] postings) {
/*     */     int numToCopy;
/* 193 */     assert this.docWriter.writer.testPoint(""TermsHash.getPostings start"");
/*     */     
/* 195 */     assert this.postingsFreeCount <= this.postingsFreeList.length;
/* 196 */     assert this.postingsFreeCount <= this.postingsAllocCount : ""postingsFreeCount="" + this.postingsFreeCount + "" postingsAllocCount="" + this.postingsAllocCount;
/*     */ 
/*     */     
/* 199 */     if (this.postingsFreeCount < postings.length) {
/* 200 */       numToCopy = this.postingsFreeCount;
/*     */     } else {
/* 202 */       numToCopy = postings.length;
/* 203 */     }  int start = this.postingsFreeCount - numToCopy;
/* 204 */     assert start >= 0;
/* 205 */     assert start + numToCopy <= this.postingsFreeList.length;
/* 206 */     assert numToCopy <= postings.length;
/* 207 */     System.arraycopy(this.postingsFreeList, start, postings, 0, numToCopy);
/*     */ 
/*     */ 
/*     */     
/* 211 */     if (numToCopy != postings.length) {
/* 212 */       int extra = postings.length - numToCopy;
/* 213 */       int newPostingsAllocCount = this.postingsAllocCount + extra;
/*     */       
/* 215 */       this.consumer.createPostings(postings, numToCopy, extra);
/* 216 */       assert this.docWriter.writer.testPoint(""TermsHash.getPostings after create"");
/* 217 */       this.postingsAllocCount += extra;
/*     */       
/* 219 */       if (this.trackAllocations) {
/* 220 */         this.docWriter.bytesAllocated((extra * this.bytesPerPosting));
/*     */       }
/* 222 */       if (newPostingsAllocCount > this.postingsFreeList.length)
/*     */       {
/*     */         
/* 225 */         this.postingsFreeList = new RawPostingList[ArrayUtil.getNextSize(newPostingsAllocCount)];
/*     */       }
/*     */     } 
/* 228 */     this.postingsFreeCount -= numToCopy;
/*     */     
/* 230 */     if (this.trackAllocations)
/* 231 */       this.docWriter.bytesUsed((postings.length * this.bytesPerPosting)); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermsHash.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermsHashConsumer,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ abstract class TermsHashConsumer
/*    */ {
/*    */   FieldInfos fieldInfos;
/*    */   
/*    */   abstract int bytesPerPosting();
/*    */   
/*    */   abstract void createPostings(RawPostingList[] paramArrayOfRawPostingList, int paramInt1, int paramInt2);
/*    */   
/*    */   abstract TermsHashConsumerPerThread addThread(TermsHashPerThread paramTermsHashPerThread);
/*    */   
/*    */   abstract void flush(Map paramMap, DocumentsWriter.FlushState paramFlushState) throws IOException;
/*    */   
/*    */   abstract void abort();
/*    */   
/*    */   abstract void closeDocStore(DocumentsWriter.FlushState paramFlushState) throws IOException;
/*    */   
/* 34 */   void setFieldInfos(FieldInfos fieldInfos) { this.fieldInfos = fieldInfos; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermsHashConsumer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermsHashConsumerPerField,"package org.apache.lucene.index;
import java.io.IOException;
import org.apache.lucene.analysis.Token;
import org.apache.lucene.document.Fieldable;
abstract class TermsHashConsumerPerField {
  abstract boolean start(Fieldable[] paramArrayOfFieldable, int paramInt) throws IOException;
  abstract void finish() throws IOException;
  abstract void skippingLongTerm(Token paramToken) throws IOException;
  abstract void newTerm(Token paramToken, RawPostingList paramRawPostingList) throws IOException;
  abstract void addTerm(Token paramToken, RawPostingList paramRawPostingList) throws IOException;
  abstract int getStreamCount();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermsHashConsumerPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermsHashConsumerPerThread,"package org.apache.lucene.index;
import java.io.IOException;
abstract class TermsHashConsumerPerThread {
  abstract void startDocument() throws IOException;
  abstract DocumentsWriter.DocWriter finishDocument() throws IOException;
  public abstract TermsHashConsumerPerField addField(TermsHashPerField paramTermsHashPerField, FieldInfo paramFieldInfo);
  public abstract void abort();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermsHashConsumerPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermsHashPerField,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermsHashPerField
/*     */   extends InvertedDocConsumerPerField
/*     */ {
/*     */   final TermsHashConsumerPerField consumer;
/*     */   final TermsHashPerField nextPerField;
/*     */   final TermsHashPerThread perThread;
/*     */   final DocumentsWriter.DocState docState;
/*     */   final DocInverter.FieldInvertState fieldState;
/*     */   final CharBlockPool charPool;
/*     */   final IntBlockPool intPool;
/*     */   final ByteBlockPool bytePool;
/*     */   final int streamCount;
/*     */   final int numPostingInt;
/*     */   final FieldInfo fieldInfo;
/*     */   boolean postingsCompacted;
/*     */   int numPostings;
/*  47 */   private int postingsHashSize = 4;
/*  48 */   private int postingsHashHalfSize = this.postingsHashSize / 2;
/*  49 */   private int postingsHashMask = this.postingsHashSize - 1; private RawPostingList p; private boolean doCall; private boolean doNextCall;
/*  50 */   private RawPostingList[] postingsHash = new RawPostingList[this.postingsHashSize]; int[] intUptos; int intUptoStart;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public TermsHashPerField(DocInverterPerField docInverterPerField, TermsHashPerThread perThread, TermsHashPerThread nextPerThread, FieldInfo fieldInfo) {
/*  54 */     this.perThread = perThread;
/*  55 */     this.intPool = perThread.intPool;
/*  56 */     this.charPool = perThread.charPool;
/*  57 */     this.bytePool = perThread.bytePool;
/*  58 */     this.docState = perThread.docState;
/*  59 */     this.fieldState = docInverterPerField.fieldState;
/*  60 */     this.consumer = perThread.consumer.addField(this, fieldInfo);
/*  61 */     this.streamCount = this.consumer.getStreamCount();
/*  62 */     this.numPostingInt = 2 * this.streamCount;
/*  63 */     this.fieldInfo = fieldInfo;
/*  64 */     if (nextPerThread != null) {
/*  65 */       this.nextPerField = (TermsHashPerField)nextPerThread.addField(docInverterPerField, fieldInfo);
/*     */     } else {
/*  67 */       this.nextPerField = null;
/*     */     } 
/*     */   }
/*     */   void shrinkHash(int targetSize) {
/*  71 */     assert this.postingsCompacted || this.numPostings == 0;
/*     */ 
/*     */ 
/*     */     
/*  75 */     int newSize = this.postingsHash.length;
/*  76 */     while (newSize >= 8 && newSize / 4 > targetSize) {
/*  77 */       newSize /= 2;
/*     */     }
/*     */     
/*  80 */     if (newSize != this.postingsHash.length) {
/*  81 */       this.postingsHash = new RawPostingList[newSize];
/*  82 */       this.postingsHashSize = newSize;
/*  83 */       this.postingsHashHalfSize = newSize / 2;
/*  84 */       this.postingsHashMask = newSize - 1;
/*     */     } 
/*     */   }
/*     */   
/*     */   public void reset() {
/*  89 */     if (!this.postingsCompacted)
/*  90 */       compactPostings(); 
/*  91 */     assert this.numPostings <= this.postingsHash.length;
/*  92 */     if (this.numPostings > 0) {
/*  93 */       this.perThread.termsHash.recyclePostings(this.postingsHash, this.numPostings);
/*  94 */       Arrays.fill((Object[])this.postingsHash, 0, this.numPostings, null);
/*  95 */       this.numPostings = 0;
/*     */     } 
/*  97 */     this.postingsCompacted = false;
/*  98 */     if (this.nextPerField != null)
/*  99 */       this.nextPerField.reset(); 
/*     */   }
/*     */   
/*     */   public synchronized void abort() {
/* 103 */     reset();
/* 104 */     if (this.nextPerField != null)
/* 105 */       this.nextPerField.abort(); 
/*     */   }
/*     */   
/*     */   public void initReader(ByteSliceReader reader, RawPostingList p, int stream) {
/* 109 */     assert stream < this.streamCount;
/* 110 */     int[] ints = this.intPool.buffers[p.intStart >> 13];
/* 111 */     int upto = p.intStart & 0x1FFF;
/* 112 */     reader.init(this.bytePool, p.byteStart + stream * ByteBlockPool.FIRST_LEVEL_SIZE, ints[upto + stream]);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private synchronized void compactPostings() {
/* 118 */     int upto = 0;
/* 119 */     for (int i = 0; i < this.postingsHashSize; i++) {
/* 120 */       if (this.postingsHash[i] != null) {
/* 121 */         if (upto < i) {
/* 122 */           this.postingsHash[upto] = this.postingsHash[i];
/* 123 */           this.postingsHash[i] = null;
/*     */         } 
/* 125 */         upto++;
/*     */       } 
/*     */     } 
/*     */     
/* 129 */     assert upto == this.numPostings;
/* 130 */     this.postingsCompacted = true;
/*     */   }
/*     */ 
/*     */   
/*     */   public RawPostingList[] sortPostings() {
/* 135 */     compactPostings();
/* 136 */     quickSort(this.postingsHash, 0, this.numPostings - 1);
/* 137 */     return this.postingsHash;
/*     */   }
/*     */   
/*     */   void quickSort(RawPostingList[] postings, int lo, int hi) {
/* 141 */     if (lo >= hi)
/*     */       return; 
/* 143 */     if (hi == 1 + lo) {
/* 144 */       if (comparePostings(postings[lo], postings[hi]) > 0) {
/* 145 */         RawPostingList tmp = postings[lo];
/* 146 */         postings[lo] = postings[hi];
/* 147 */         postings[hi] = tmp;
/*     */       } 
/*     */       
/*     */       return;
/*     */     } 
/* 152 */     int mid = lo + hi >>> 1;
/*     */     
/* 154 */     if (comparePostings(postings[lo], postings[mid]) > 0) {
/* 155 */       RawPostingList tmp = postings[lo];
/* 156 */       postings[lo] = postings[mid];
/* 157 */       postings[mid] = tmp;
/*     */     } 
/*     */     
/* 160 */     if (comparePostings(postings[mid], postings[hi]) > 0) {
/* 161 */       RawPostingList tmp = postings[mid];
/* 162 */       postings[mid] = postings[hi];
/* 163 */       postings[hi] = tmp;
/*     */       
/* 165 */       if (comparePostings(postings[lo], postings[mid]) > 0) {
/* 166 */         RawPostingList tmp2 = postings[lo];
/* 167 */         postings[lo] = postings[mid];
/* 168 */         postings[mid] = tmp2;
/*     */       } 
/*     */     } 
/*     */     
/* 172 */     int left = lo + 1;
/* 173 */     int right = hi - 1;
/*     */     
/* 175 */     if (left >= right) {
/*     */       return;
/*     */     }
/* 178 */     RawPostingList partition = postings[mid];
/*     */     
/*     */     while (true) {
/* 181 */       while (comparePostings(postings[right], partition) > 0) {
/* 182 */         right--;
/*     */       }
/* 184 */       while (left < right && comparePostings(postings[left], partition) <= 0) {
/* 185 */         left++;
/*     */       }
/* 187 */       if (left < right) {
/* 188 */         RawPostingList tmp = postings[left];
/* 189 */         postings[left] = postings[right];
/* 190 */         postings[right] = tmp;
/* 191 */         right--;
/*     */         
/*     */         continue;
/*     */       } 
/*     */       break;
/*     */     } 
/* 197 */     quickSort(postings, lo, left);
/* 198 */     quickSort(postings, left + 1, hi);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   int comparePostings(RawPostingList p1, RawPostingList p2) {
/*     */     char c1;
/* 205 */     if (p1 == p2) {
/* 206 */       return 0;
/*     */     }
/* 208 */     char[] text1 = this.charPool.buffers[p1.textStart >> 14];
/* 209 */     int pos1 = p1.textStart & 0x3FFF;
/* 210 */     char[] text2 = this.charPool.buffers[p2.textStart >> 14];
/* 211 */     int pos2 = p2.textStart & 0x3FFF;
/*     */     
/* 213 */     assert text1 != text2 || pos1 != pos2;
/*     */     
/*     */     do {
/* 216 */       c1 = text1[pos1++];
/* 217 */       char c2 = text2[pos2++];
/* 218 */       if (c1 != c2) {
/* 219 */         if (Character.MAX_VALUE == c2)
/* 220 */           return 1; 
/* 221 */         if (Character.MAX_VALUE == c1) {
/* 222 */           return -1;
/*     */         }
/* 224 */         return c1 - c2;
/*     */       }
/*     */     
/*     */     }
/* 228 */     while ($assertionsDisabled || c1 != Character.MAX_VALUE); throw new AssertionError();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean postingEquals(char[] tokenText, int tokenTextLen) {
/* 236 */     char[] text = this.perThread.charPool.buffers[this.p.textStart >> 14];
/* 237 */     assert text != null;
/* 238 */     int pos = this.p.textStart & 0x3FFF;
/*     */     
/* 240 */     int tokenPos = 0;
/* 241 */     for (; tokenPos < tokenTextLen; pos++, tokenPos++) {
/* 242 */       if (tokenText[tokenPos] != text[pos])
/* 243 */         return false; 
/* 244 */     }  return (Character.MAX_VALUE == text[pos]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean start(Fieldable[] fields, int count) throws IOException {
/* 251 */     this.doCall = this.consumer.start(fields, count);
/* 252 */     if (this.nextPerField != null)
/* 253 */       this.doNextCall = this.nextPerField.start(fields, count); 
/* 254 */     return (this.doCall || this.doNextCall);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Token token, int textStart) throws IOException {
/* 262 */     int code = textStart;
/*     */     
/* 264 */     int hashPos = code & this.postingsHashMask;
/*     */     
/* 266 */     assert !this.postingsCompacted;
/*     */ 
/*     */     
/* 269 */     this.p = this.postingsHash[hashPos];
/*     */     
/* 271 */     if (this.p != null && this.p.textStart != textStart) {
/*     */ 
/*     */       
/* 274 */       int inc = (code >> 8) + code | 0x1;
/*     */       do {
/* 276 */         code += inc;
/* 277 */         hashPos = code & this.postingsHashMask;
/* 278 */         this.p = this.postingsHash[hashPos];
/* 279 */       } while (this.p != null && this.p.textStart != textStart);
/*     */     } 
/*     */     
/* 282 */     if (this.p == null) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 288 */       if (0 == this.perThread.freePostingsCount) {
/* 289 */         this.perThread.morePostings();
/*     */       }
/*     */       
/* 292 */       this.p = this.perThread.freePostings[--this.perThread.freePostingsCount];
/* 293 */       assert this.p != null;
/*     */       
/* 295 */       this.p.textStart = textStart;
/*     */       
/* 297 */       assert this.postingsHash[hashPos] == null;
/* 298 */       this.postingsHash[hashPos] = this.p;
/* 299 */       this.numPostings++;
/*     */       
/* 301 */       if (this.numPostings == this.postingsHashHalfSize) {
/* 302 */         rehashPostings(2 * this.postingsHashSize);
/*     */       }
/*     */       
/* 305 */       if (this.numPostingInt + this.intPool.intUpto > 8192) {
/* 306 */         this.intPool.nextBuffer();
/*     */       }
/* 308 */       if (32768 - this.bytePool.byteUpto < this.numPostingInt * ByteBlockPool.FIRST_LEVEL_SIZE) {
/* 309 */         this.bytePool.nextBuffer();
/*     */       }
/* 311 */       this.intUptos = this.intPool.buffer;
/* 312 */       this.intUptoStart = this.intPool.intUpto;
/* 313 */       this.intPool.intUpto += this.streamCount;
/*     */       
/* 315 */       this.p.intStart = this.intUptoStart + this.intPool.intOffset;
/*     */       
/* 317 */       for (int i = 0; i < this.streamCount; i++) {
/* 318 */         int upto = this.bytePool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);
/* 319 */         this.intUptos[this.intUptoStart + i] = upto + this.bytePool.byteOffset;
/*     */       } 
/* 321 */       this.p.byteStart = this.intUptos[this.intUptoStart];
/*     */       
/* 323 */       this.consumer.newTerm(token, this.p);
/*     */     } else {
/*     */       
/* 326 */       this.intUptos = this.intPool.buffers[this.p.intStart >> 13];
/* 327 */       this.intUptoStart = this.p.intStart & 0x1FFF;
/* 328 */       this.consumer.addTerm(token, this.p);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void add(Token token) throws IOException {
/* 335 */     assert !this.postingsCompacted;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 341 */     char[] tokenText = token.termBuffer();
/* 342 */     int tokenTextLen = token.termLength();
/*     */ 
/*     */     
/* 345 */     int downto = tokenTextLen;
/* 346 */     int code = 0;
/* 347 */     while (downto > 0) {
/* 348 */       char ch = tokenText[--downto];
/*     */       
/* 350 */       if (ch >= '?' && ch <= '?') {
/* 351 */         if (0 == downto) {
/*     */           
/* 353 */           ch = tokenText[downto] = '�';
/*     */         } else {
/* 355 */           char ch2 = tokenText[downto - 1];
/* 356 */           if (ch2 >= '?' && ch2 <= '?') {
/*     */ 
/*     */             
/* 359 */             code = (code * 31 + ch) * 31 + ch2;
/* 360 */             downto--;
/*     */             
/*     */             continue;
/*     */           } 
/* 364 */           ch = tokenText[downto] = '�';
/*     */         }
/*     */       
/* 367 */       } else if (ch >= '?' && ch <= '?') {
/*     */         
/* 369 */         ch = tokenText[downto] = '�';
/*     */       } 
/* 371 */       code = code * 31 + ch;
/*     */     } 
/*     */     
/* 374 */     int hashPos = code & this.postingsHashMask;
/*     */ 
/*     */     
/* 377 */     this.p = this.postingsHash[hashPos];
/*     */     
/* 379 */     if (this.p != null && !postingEquals(tokenText, tokenTextLen)) {
/*     */ 
/*     */       
/* 382 */       int inc = (code >> 8) + code | 0x1;
/*     */       do {
/* 384 */         code += inc;
/* 385 */         hashPos = code & this.postingsHashMask;
/* 386 */         this.p = this.postingsHash[hashPos];
/* 387 */       } while (this.p != null && !postingEquals(tokenText, tokenTextLen));
/*     */     } 
/*     */     
/* 390 */     if (this.p == null) {
/*     */ 
/*     */ 
/*     */       
/* 394 */       int textLen1 = 1 + tokenTextLen;
/* 395 */       if (textLen1 + this.charPool.charUpto > 16384) {
/* 396 */         if (textLen1 > 16384) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 403 */           if (this.docState.maxTermPrefix == null) {
/* 404 */             this.docState.maxTermPrefix = new String(tokenText, 0, 30);
/*     */           }
/* 406 */           this.consumer.skippingLongTerm(token);
/*     */           return;
/*     */         } 
/* 409 */         this.charPool.nextBuffer();
/*     */       } 
/*     */ 
/*     */       
/* 413 */       if (0 == this.perThread.freePostingsCount) {
/* 414 */         this.perThread.morePostings();
/*     */       }
/*     */       
/* 417 */       this.p = this.perThread.freePostings[--this.perThread.freePostingsCount];
/* 418 */       assert this.p != null;
/*     */       
/* 420 */       char[] text = this.charPool.buffer;
/* 421 */       int textUpto = this.charPool.charUpto;
/* 422 */       this.p.textStart = textUpto + this.charPool.charOffset;
/* 423 */       this.charPool.charUpto += textLen1;
/* 424 */       System.arraycopy(tokenText, 0, text, textUpto, tokenTextLen);
/* 425 */       text[textUpto + tokenTextLen] = Character.MAX_VALUE;
/*     */       
/* 427 */       assert this.postingsHash[hashPos] == null;
/* 428 */       this.postingsHash[hashPos] = this.p;
/* 429 */       this.numPostings++;
/*     */       
/* 431 */       if (this.numPostings == this.postingsHashHalfSize) {
/* 432 */         rehashPostings(2 * this.postingsHashSize);
/*     */       }
/*     */       
/* 435 */       if (this.numPostingInt + this.intPool.intUpto > 8192) {
/* 436 */         this.intPool.nextBuffer();
/*     */       }
/* 438 */       if (32768 - this.bytePool.byteUpto < this.numPostingInt * ByteBlockPool.FIRST_LEVEL_SIZE) {
/* 439 */         this.bytePool.nextBuffer();
/*     */       }
/* 441 */       this.intUptos = this.intPool.buffer;
/* 442 */       this.intUptoStart = this.intPool.intUpto;
/* 443 */       this.intPool.intUpto += this.streamCount;
/*     */       
/* 445 */       this.p.intStart = this.intUptoStart + this.intPool.intOffset;
/*     */       
/* 447 */       for (int i = 0; i < this.streamCount; i++) {
/* 448 */         int upto = this.bytePool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);
/* 449 */         this.intUptos[this.intUptoStart + i] = upto + this.bytePool.byteOffset;
/*     */       } 
/* 451 */       this.p.byteStart = this.intUptos[this.intUptoStart];
/*     */       
/* 453 */       this.consumer.newTerm(token, this.p);
/*     */     } else {
/*     */       
/* 456 */       this.intUptos = this.intPool.buffers[this.p.intStart >> 13];
/* 457 */       this.intUptoStart = this.p.intStart & 0x1FFF;
/* 458 */       this.consumer.addTerm(token, this.p);
/*     */     } 
/*     */     
/* 461 */     if (this.doNextCall) {
/* 462 */       this.nextPerField.add(token, this.p.textStart);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void writeByte(int stream, byte b) {
/* 469 */     int upto = this.intUptos[this.intUptoStart + stream];
/* 470 */     byte[] bytes = this.bytePool.buffers[upto >> 15];
/* 471 */     assert bytes != null;
/* 472 */     int offset = upto & 0x7FFF;
/* 473 */     if (bytes[offset] != 0) {
/*     */       
/* 475 */       offset = this.bytePool.allocSlice(bytes, offset);
/* 476 */       bytes = this.bytePool.buffer;
/* 477 */       this.intUptos[this.intUptoStart + stream] = offset + this.bytePool.byteOffset;
/*     */     } 
/* 479 */     bytes[offset] = b;
/* 480 */     this.intUptos[this.intUptoStart + stream] = this.intUptos[this.intUptoStart + stream] + 1;
/*     */   }
/*     */ 
/*     */   
/*     */   public void writeBytes(int stream, byte[] b, int offset, int len) {
/* 485 */     int end = offset + len;
/* 486 */     for (int i = offset; i < end; i++)
/* 487 */       writeByte(stream, b[i]); 
/*     */   }
/*     */   
/*     */   void writeVInt(int stream, int i) {
/* 491 */     assert stream < this.streamCount;
/* 492 */     while ((i & 0xFFFFFF80) != 0) {
/* 493 */       writeByte(stream, (byte)(i & 0x7F | 0x80));
/* 494 */       i >>>= 7;
/*     */     } 
/* 496 */     writeByte(stream, (byte)i);
/*     */   }
/*     */   
/*     */   void finish() throws IOException {
/* 500 */     this.consumer.finish();
/* 501 */     if (this.nextPerField != null) {
/* 502 */       this.nextPerField.finish();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void rehashPostings(int newSize) {
/* 509 */     int newMask = newSize - 1;
/*     */     
/* 511 */     RawPostingList[] newHash = new RawPostingList[newSize];
/* 512 */     for (int i = 0; i < this.postingsHashSize; i++) {
/* 513 */       RawPostingList p0 = this.postingsHash[i];
/* 514 */       if (p0 != null) {
/*     */         int code;
/* 516 */         if (this.perThread.primary) {
/* 517 */           int start = p0.textStart & 0x3FFF;
/* 518 */           char[] text = this.charPool.buffers[p0.textStart >> 14];
/* 519 */           int pos = start;
/* 520 */           while (text[pos] != Character.MAX_VALUE)
/* 521 */             pos++; 
/* 522 */           code = 0;
/* 523 */           while (pos > start)
/* 524 */             code = code * 31 + text[--pos]; 
/*     */         } else {
/* 526 */           code = p0.textStart;
/*     */         } 
/* 528 */         int hashPos = code & newMask;
/* 529 */         assert hashPos >= 0;
/* 530 */         if (newHash[hashPos] != null) {
/* 531 */           int inc = (code >> 8) + code | 0x1;
/*     */           do {
/* 533 */             code += inc;
/* 534 */             hashPos = code & newMask;
/* 535 */           } while (newHash[hashPos] != null);
/*     */         } 
/* 537 */         newHash[hashPos] = p0;
/*     */       } 
/*     */     } 
/*     */     
/* 541 */     this.postingsHashMask = newMask;
/* 542 */     this.postingsHash = newHash;
/* 543 */     this.postingsHashSize = newSize;
/* 544 */     this.postingsHashHalfSize = newSize >> 1;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermsHashPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermsHashPerThread,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermsHashPerThread
/*     */   extends InvertedDocConsumerPerThread
/*     */ {
/*     */   final TermsHash termsHash;
/*     */   final TermsHashConsumerPerThread consumer;
/*     */   final TermsHashPerThread nextPerThread;
/*     */   final CharBlockPool charPool;
/*     */   final IntBlockPool intPool;
/*     */   final ByteBlockPool bytePool;
/*     */   final boolean primary;
/*     */   final DocumentsWriter.DocState docState;
/*  34 */   final RawPostingList[] freePostings = new RawPostingList[256];
/*     */   int freePostingsCount;
/*     */   
/*     */   public TermsHashPerThread(DocInverterPerThread docInverterPerThread, TermsHash termsHash, TermsHash nextTermsHash, TermsHashPerThread primaryPerThread) {
/*  38 */     this.docState = docInverterPerThread.docState;
/*     */     
/*  40 */     this.termsHash = termsHash;
/*  41 */     this.consumer = termsHash.consumer.addThread(this);
/*     */     
/*  43 */     if (nextTermsHash != null) {
/*     */       
/*  45 */       this.charPool = new CharBlockPool(termsHash.docWriter);
/*  46 */       this.primary = true;
/*     */     } else {
/*  48 */       this.charPool = primaryPerThread.charPool;
/*  49 */       this.primary = false;
/*     */     } 
/*     */     
/*  52 */     this.intPool = new IntBlockPool(termsHash.docWriter, termsHash.trackAllocations);
/*  53 */     this.bytePool = new ByteBlockPool(termsHash.docWriter.byteBlockAllocator, termsHash.trackAllocations);
/*     */     
/*  55 */     if (nextTermsHash != null) {
/*  56 */       this.nextPerThread = nextTermsHash.addThread(docInverterPerThread, this);
/*     */     } else {
/*  58 */       this.nextPerThread = null;
/*     */     } 
/*     */   }
/*     */   static final boolean $assertionsDisabled;
/*  62 */   InvertedDocConsumerPerField addField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo) { return new TermsHashPerField(docInverterPerField, this, this.nextPerThread, fieldInfo); }
/*     */ 
/*     */   
/*     */   public synchronized void abort() {
/*  66 */     reset(true);
/*  67 */     this.consumer.abort();
/*  68 */     if (this.nextPerThread != null) {
/*  69 */       this.nextPerThread.abort();
/*     */     }
/*     */   }
/*     */   
/*     */   void morePostings() throws IOException {
/*  74 */     assert this.freePostingsCount == 0;
/*  75 */     this.termsHash.getPostings(this.freePostings);
/*  76 */     this.freePostingsCount = this.freePostings.length;
/*  77 */     assert noNullPostings(this.freePostings, this.freePostingsCount, ""consumer="" + this.consumer);
/*     */   }
/*     */   
/*     */   private static boolean noNullPostings(RawPostingList[] postings, int count, String details) {
/*  81 */     for (int i = 0; i < count; i++)
/*  82 */       assert postings[i] != null : ""postings["" + i + ""] of "" + count + "" is null: "" + details; 
/*  83 */     return true;
/*     */   }
/*     */   
/*     */   public void startDocument() throws IOException {
/*  87 */     this.consumer.startDocument();
/*  88 */     if (this.nextPerThread != null)
/*  89 */       this.nextPerThread.consumer.startDocument(); 
/*     */   }
/*     */   
/*     */   public DocumentsWriter.DocWriter finishDocument() throws IOException {
/*  93 */     DocumentsWriter.DocWriter doc2, doc = this.consumer.finishDocument();
/*     */ 
/*     */     
/*  96 */     if (this.nextPerThread != null) {
/*  97 */       doc2 = this.nextPerThread.consumer.finishDocument();
/*     */     } else {
/*  99 */       doc2 = null;
/* 100 */     }  if (doc == null) {
/* 101 */       return doc2;
/*     */     }
/* 103 */     doc.setNext(doc2);
/* 104 */     return doc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void reset(boolean recyclePostings) {
/* 110 */     this.intPool.reset();
/* 111 */     this.bytePool.reset();
/*     */     
/* 113 */     if (this.primary) {
/* 114 */       this.charPool.reset();
/*     */     }
/* 116 */     if (recyclePostings) {
/* 117 */       this.termsHash.recyclePostings(this.freePostings, this.freePostingsCount);
/* 118 */       this.freePostingsCount = 0;
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermsHashPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorEntry,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TermVectorEntry
/*    */ {
/*    */   private String field;
/*    */   private String term;
/*    */   private int frequency;
/*    */   private TermVectorOffsetInfo[] offsets;
/*    */   int[] positions;
/*    */   
/*    */   public TermVectorEntry() {}
/*    */   
/*    */   public TermVectorEntry(String field, String term, int frequency, TermVectorOffsetInfo[] offsets, int[] positions) {
/* 34 */     this.field = field;
/* 35 */     this.term = term;
/* 36 */     this.frequency = frequency;
/* 37 */     this.offsets = offsets;
/* 38 */     this.positions = positions;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 43 */   public String getField() { return this.field; }
/*    */ 
/*    */ 
/*    */   
/* 47 */   public int getFrequency() { return this.frequency; }
/*    */ 
/*    */ 
/*    */   
/* 51 */   public TermVectorOffsetInfo[] getOffsets() { return this.offsets; }
/*    */ 
/*    */ 
/*    */   
/* 55 */   public int[] getPositions() { return this.positions; }
/*    */ 
/*    */ 
/*    */   
/* 59 */   public String getTerm() { return this.term; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 64 */   void setFrequency(int frequency) { this.frequency = frequency; }
/*    */ 
/*    */ 
/*    */   
/* 68 */   void setOffsets(TermVectorOffsetInfo[] offsets) { this.offsets = offsets; }
/*    */ 
/*    */ 
/*    */   
/* 72 */   void setPositions(int[] positions) { this.positions = positions; }
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 77 */     if (this == o) return true; 
/* 78 */     if (o == null || getClass() != o.getClass()) return false;
/*    */     
/* 80 */     TermVectorEntry that = (TermVectorEntry)o;
/*    */     
/* 82 */     if ((this.term != null) ? !this.term.equals(that.term) : (that.term != null)) return false;
/*    */     
/* 84 */     return true;
/*    */   }
/*    */ 
/*    */   
/* 88 */   public int hashCode() { return (this.term != null) ? this.term.hashCode() : 0; }
/*    */ 
/*    */ 
/*    */   
/* 92 */   public String toString() { return ""TermVectorEntry{field='"" + this.field + '\'' + "", term='"" + this.term + '\'' + "", frequency="" + this.frequency + '}'; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorEntry.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorEntryFreqSortedComparator,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.util.Comparator;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TermVectorEntryFreqSortedComparator
/*    */   implements Comparator
/*    */ {
/*    */   public int compare(Object object, Object object1) {
/* 28 */     int result = 0;
/* 29 */     TermVectorEntry entry = (TermVectorEntry)object;
/* 30 */     TermVectorEntry entry1 = (TermVectorEntry)object1;
/* 31 */     result = entry1.getFrequency() - entry.getFrequency();
/* 32 */     if (result == 0) {
/*    */       
/* 34 */       result = entry.getTerm().compareTo(entry1.getTerm());
/* 35 */       if (result == 0)
/*    */       {
/* 37 */         result = entry.getField().compareTo(entry1.getField());
/*    */       }
/*    */     } 
/* 40 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorEntryFreqSortedComparator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorMapper,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TermVectorMapper
/*    */ {
/*    */   private boolean ignoringPositions;
/*    */   private boolean ignoringOffsets;
/*    */   
/*    */   protected TermVectorMapper() {}
/*    */   
/*    */   protected TermVectorMapper(boolean ignoringPositions, boolean ignoringOffsets) {
/* 43 */     this.ignoringPositions = ignoringPositions;
/* 44 */     this.ignoringOffsets = ignoringOffsets;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public abstract void setExpectations(String paramString, int paramInt, boolean paramBoolean1, boolean paramBoolean2);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public abstract void map(String paramString, int paramInt, TermVectorOffsetInfo[] paramArrayOfTermVectorOffsetInfo, int[] paramArrayOfint);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 75 */   public boolean isIgnoringPositions() { return this.ignoringPositions; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 85 */   public boolean isIgnoringOffsets() { return this.ignoringOffsets; }
/*    */   
/*    */   public void setDocumentNumber(int documentNumber) {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorMapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorOffsetInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TermVectorOffsetInfo
/*    */ {
/* 29 */   public static final TermVectorOffsetInfo[] EMPTY_OFFSET_INFO = new TermVectorOffsetInfo[0];
/*    */   
/*    */   private int startOffset;
/*    */   private int endOffset;
/*    */   
/*    */   public TermVectorOffsetInfo() {}
/*    */   
/*    */   public TermVectorOffsetInfo(int startOffset, int endOffset) {
/* 37 */     this.endOffset = endOffset;
/* 38 */     this.startOffset = startOffset;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 46 */   public int getEndOffset() { return this.endOffset; }
/*    */ 
/*    */ 
/*    */   
/* 50 */   public void setEndOffset(int endOffset) { this.endOffset = endOffset; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public int getStartOffset() { return this.startOffset; }
/*    */ 
/*    */ 
/*    */   
/* 63 */   public void setStartOffset(int startOffset) { this.startOffset = startOffset; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 72 */     if (this == o) return true; 
/* 73 */     if (!(o instanceof TermVectorOffsetInfo)) return false;
/*    */     
/* 75 */     TermVectorOffsetInfo termVectorOffsetInfo = (TermVectorOffsetInfo)o;
/*    */     
/* 77 */     if (this.endOffset != termVectorOffsetInfo.endOffset) return false; 
/* 78 */     if (this.startOffset != termVectorOffsetInfo.startOffset) return false;
/*    */     
/* 80 */     return true;
/*    */   }
/*    */ 
/*    */   
/*    */   public int hashCode() {
/* 85 */     int result = this.startOffset;
/* 86 */     result = 29 * result + this.endOffset;
/* 87 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorOffsetInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class TermVectorsReader
/*     */   implements Cloneable
/*     */ {
/*     */   static final int FORMAT_VERSION = 2;
/*     */   static final int FORMAT_VERSION2 = 3;
/*     */   static final int FORMAT_UTF8_LENGTH_IN_BYTES = 4;
/*     */   static final int FORMAT_CURRENT = 4;
/*     */   static final int FORMAT_SIZE = 4;
/*     */   static final byte STORE_POSITIONS_WITH_TERMVECTOR = 1;
/*     */   static final byte STORE_OFFSET_WITH_TERMVECTOR = 2;
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexInput tvx;
/*     */   private IndexInput tvd;
/*     */   private IndexInput tvf;
/*     */   private int size;
/*     */   private int numTotalDocs;
/*     */   private int docStoreOffset;
/*     */   private final int format;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  67 */   TermVectorsReader(Directory d, String segment, FieldInfos fieldInfos) throws CorruptIndexException, IOException { this(d, segment, fieldInfos, 1024); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  72 */   TermVectorsReader(Directory d, String segment, FieldInfos fieldInfos, int readBufferSize) throws CorruptIndexException, IOException { this(d, segment, fieldInfos, readBufferSize, -1, 0); }
/*     */ 
/*     */ 
/*     */   
/*     */   TermVectorsReader(Directory d, String segment, FieldInfos fieldInfos, int readBufferSize, int docStoreOffset, int size) throws CorruptIndexException, IOException {
/*  77 */     boolean success = false;
/*     */     
/*     */     try {
/*  80 */       if (d.fileExists(segment + ""."" + ""tvx"")) {
/*  81 */         this.tvx = d.openInput(segment + ""."" + ""tvx"", readBufferSize);
/*  82 */         this.format = checkValidFormat(this.tvx);
/*  83 */         this.tvd = d.openInput(segment + ""."" + ""tvd"", readBufferSize);
/*  84 */         int tvdFormat = checkValidFormat(this.tvd);
/*  85 */         this.tvf = d.openInput(segment + ""."" + ""tvf"", readBufferSize);
/*  86 */         int tvfFormat = checkValidFormat(this.tvf);
/*     */         
/*  88 */         assert this.format == tvdFormat;
/*  89 */         assert this.format == tvfFormat;
/*     */         
/*  91 */         if (this.format >= 3) {
/*  92 */           assert (this.tvx.length() - 4L) % 16L == 0L;
/*  93 */           this.numTotalDocs = (int)(this.tvx.length() >> 4L);
/*     */         } else {
/*  95 */           assert (this.tvx.length() - 4L) % 8L == 0L;
/*  96 */           this.numTotalDocs = (int)(this.tvx.length() >> 3L);
/*     */         } 
/*     */         
/*  99 */         if (-1 == docStoreOffset) {
/* 100 */           this.docStoreOffset = 0;
/* 101 */           this.size = this.numTotalDocs;
/* 102 */           assert size == 0 || this.numTotalDocs == size;
/*     */         } else {
/* 104 */           this.docStoreOffset = docStoreOffset;
/* 105 */           this.size = size;
/*     */ 
/*     */           
/* 108 */           assert this.numTotalDocs >= size + docStoreOffset : ""numTotalDocs="" + this.numTotalDocs + "" size="" + size + "" docStoreOffset="" + docStoreOffset;
/*     */         } 
/*     */       } else {
/* 111 */         this.format = 0;
/*     */       } 
/* 113 */       this.fieldInfos = fieldInfos;
/* 114 */       success = true;
/*     */ 
/*     */     
/*     */     }
/*     */     finally {
/*     */ 
/*     */       
/* 121 */       if (!success) {
/* 122 */         close();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 129 */   IndexInput getTvdStream() { return this.tvd; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 134 */   IndexInput getTvfStream() { return this.tvf; }
/*     */ 
/*     */   
/*     */   private final void seekTvx(int docNum) throws IOException {
/* 138 */     if (this.format < 3) {
/* 139 */       this.tvx.seek((docNum + this.docStoreOffset) * 8L + 4L);
/*     */     } else {
/* 141 */       this.tvx.seek((docNum + this.docStoreOffset) * 16L + 4L);
/*     */     } 
/*     */   }
/*     */   
/* 145 */   boolean canReadRawDocs() { return (this.format >= 4); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void rawDocs(int[] tvdLengths, int[] tvfLengths, int startDocID, int numDocs) throws IOException {
/* 156 */     if (this.tvx == null) {
/* 157 */       Arrays.fill(tvdLengths, 0);
/* 158 */       Arrays.fill(tvfLengths, 0);
/*     */ 
/*     */       
/*     */       return;
/*     */     } 
/*     */     
/* 164 */     if (this.format < 3) {
/* 165 */       throw new IllegalStateException(""cannot read raw docs with older term vector formats"");
/*     */     }
/* 167 */     seekTvx(startDocID);
/*     */     
/* 169 */     long tvdPosition = this.tvx.readLong();
/* 170 */     this.tvd.seek(tvdPosition);
/*     */     
/* 172 */     long tvfPosition = this.tvx.readLong();
/* 173 */     this.tvf.seek(tvfPosition);
/*     */     
/* 175 */     long lastTvdPosition = tvdPosition;
/* 176 */     long lastTvfPosition = tvfPosition;
/*     */     
/* 178 */     int count = 0;
/* 179 */     while (count < numDocs) {
/* 180 */       int docID = this.docStoreOffset + startDocID + count + 1;
/* 181 */       assert docID <= this.numTotalDocs;
/* 182 */       if (docID < this.numTotalDocs) {
/* 183 */         tvdPosition = this.tvx.readLong();
/* 184 */         tvfPosition = this.tvx.readLong();
/*     */       } else {
/* 186 */         tvdPosition = this.tvd.length();
/* 187 */         tvfPosition = this.tvf.length();
/* 188 */         assert count == numDocs - 1;
/*     */       } 
/* 190 */       tvdLengths[count] = (int)(tvdPosition - lastTvdPosition);
/* 191 */       tvfLengths[count] = (int)(tvfPosition - lastTvfPosition);
/* 192 */       count++;
/* 193 */       lastTvdPosition = tvdPosition;
/* 194 */       lastTvfPosition = tvfPosition;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private int checkValidFormat(IndexInput in) throws CorruptIndexException, IOException {
/* 200 */     int format = in.readInt();
/* 201 */     if (format > 4) {
/* 202 */       throw new CorruptIndexException(""Incompatible format version: "" + format + "" expected "" + '\004' + "" or less"");
/*     */     }
/*     */     
/* 205 */     return format;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void close() throws IOException {
/* 211 */     IOException keep = null;
/* 212 */     if (this.tvx != null) try { this.tvx.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 213 */         if (this.tvd != null) try { this.tvd.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 214 */         if (this.tvf != null) try { this.tvf.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 215 */         if (keep != null) throw (IOException)keep.fillInStackTrace();
/*     */   
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 223 */   int size() { return this.size; }
/*     */ 
/*     */   
/*     */   public void get(int docNum, String field, TermVectorMapper mapper) throws IOException {
/* 227 */     if (this.tvx != null) {
/* 228 */       int fieldNumber = this.fieldInfos.fieldNumber(field);
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 233 */       seekTvx(docNum);
/*     */       
/* 235 */       long tvdPosition = this.tvx.readLong();
/*     */       
/* 237 */       this.tvd.seek(tvdPosition);
/* 238 */       int fieldCount = this.tvd.readVInt();
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 243 */       int number = 0;
/* 244 */       int found = -1;
/* 245 */       for (int i = 0; i < fieldCount; i++) {
/* 246 */         if (this.format >= 2) {
/* 247 */           number = this.tvd.readVInt();
/*     */         } else {
/* 249 */           number += this.tvd.readVInt();
/*     */         } 
/* 251 */         if (number == fieldNumber) {
/* 252 */           found = i;
/*     */         }
/*     */       } 
/*     */ 
/*     */       
/* 257 */       if (found != -1) {
/*     */         long position;
/*     */         
/* 260 */         if (this.format >= 3) {
/* 261 */           position = this.tvx.readLong();
/*     */         } else {
/* 263 */           position = this.tvd.readVLong();
/* 264 */         }  for (int i = 1; i <= found; i++) {
/* 265 */           position += this.tvd.readVLong();
/*     */         }
/* 267 */         mapper.setDocumentNumber(docNum);
/* 268 */         readTermVector(field, position, mapper);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermFreqVector get(int docNum, String field) throws IOException {
/* 288 */     ParallelArrayTermVectorMapper mapper = new ParallelArrayTermVectorMapper();
/* 289 */     get(docNum, field, mapper);
/*     */     
/* 291 */     return mapper.materializeVector();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private final String[] readFields(int fieldCount) throws IOException {
/* 297 */     int number = 0;
/* 298 */     String[] fields = new String[fieldCount];
/*     */     
/* 300 */     for (int i = 0; i < fieldCount; i++) {
/* 301 */       if (this.format >= 2) {
/* 302 */         number = this.tvd.readVInt();
/*     */       } else {
/* 304 */         number += this.tvd.readVInt();
/*     */       } 
/* 306 */       fields[i] = this.fieldInfos.fieldName(number);
/*     */     } 
/*     */     
/* 309 */     return fields;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final long[] readTvfPointers(int fieldCount) throws IOException {
/*     */     long position;
/* 317 */     if (this.format >= 3) {
/* 318 */       position = this.tvx.readLong();
/*     */     } else {
/* 320 */       position = this.tvd.readVLong();
/*     */     } 
/* 322 */     long[] tvfPointers = new long[fieldCount];
/* 323 */     tvfPointers[0] = position;
/*     */     
/* 325 */     for (int i = 1; i < fieldCount; i++) {
/* 326 */       position += this.tvd.readVLong();
/* 327 */       tvfPointers[i] = position;
/*     */     } 
/*     */     
/* 330 */     return tvfPointers;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermFreqVector[] get(int docNum) throws IOException {
/* 341 */     Object[] arrayOfObject = null;
/* 342 */     if (this.tvx != null) {
/*     */       
/* 344 */       seekTvx(docNum);
/* 345 */       long tvdPosition = this.tvx.readLong();
/*     */       
/* 347 */       this.tvd.seek(tvdPosition);
/* 348 */       int fieldCount = this.tvd.readVInt();
/*     */ 
/*     */       
/* 351 */       if (fieldCount != 0) {
/* 352 */         String[] fields = readFields(fieldCount);
/* 353 */         long[] tvfPointers = readTvfPointers(fieldCount);
/* 354 */         arrayOfObject = (Object[])readTermVectors(docNum, fields, tvfPointers);
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 359 */     return (TermFreqVector[])arrayOfObject;
/*     */   }
/*     */ 
/*     */   
/*     */   public void get(int docNumber, TermVectorMapper mapper) throws IOException {
/* 364 */     if (this.tvx != null) {
/*     */ 
/*     */       
/* 367 */       seekTvx(docNumber);
/* 368 */       long tvdPosition = this.tvx.readLong();
/*     */       
/* 370 */       this.tvd.seek(tvdPosition);
/* 371 */       int fieldCount = this.tvd.readVInt();
/*     */ 
/*     */       
/* 374 */       if (fieldCount != 0) {
/* 375 */         String[] fields = readFields(fieldCount);
/* 376 */         long[] tvfPointers = readTvfPointers(fieldCount);
/* 377 */         mapper.setDocumentNumber(docNumber);
/* 378 */         readTermVectors(fields, tvfPointers, mapper);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private SegmentTermVector[] readTermVectors(int docNum, String[] fields, long[] tvfPointers) throws IOException {
/* 388 */     SegmentTermVector[] res = new SegmentTermVector[fields.length];
/* 389 */     for (int i = 0; i < fields.length; i++) {
/* 390 */       ParallelArrayTermVectorMapper mapper = new ParallelArrayTermVectorMapper();
/* 391 */       mapper.setDocumentNumber(docNum);
/* 392 */       readTermVector(fields[i], tvfPointers[i], mapper);
/* 393 */       res[i] = (SegmentTermVector)mapper.materializeVector();
/*     */     } 
/* 395 */     return res;
/*     */   }
/*     */ 
/*     */   
/*     */   private void readTermVectors(String[] fields, long[] tvfPointers, TermVectorMapper mapper) throws IOException {
/* 400 */     for (int i = 0; i < fields.length; i++) {
/* 401 */       readTermVector(fields[i], tvfPointers[i], mapper);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper) throws IOException {
/*     */     char[] charBuffer;
/*     */     byte[] byteBuffer;
/*     */     boolean storeOffsets, storePositions;
/* 418 */     this.tvf.seek(tvfPointer);
/*     */     
/* 420 */     int numTerms = this.tvf.readVInt();
/*     */ 
/*     */     
/* 423 */     if (numTerms == 0) {
/*     */       return;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 429 */     if (this.format >= 2) {
/* 430 */       byte bits = this.tvf.readByte();
/* 431 */       storePositions = ((bits & 0x1) != 0);
/* 432 */       storeOffsets = ((bits & 0x2) != 0);
/*     */     } else {
/*     */       
/* 435 */       this.tvf.readVInt();
/* 436 */       storePositions = false;
/* 437 */       storeOffsets = false;
/*     */     } 
/* 439 */     mapper.setExpectations(field, numTerms, storeOffsets, storePositions);
/* 440 */     int start = 0;
/* 441 */     int deltaLength = 0;
/* 442 */     int totalLength = 0;
/*     */ 
/*     */     
/* 445 */     boolean preUTF8 = (this.format < 4);
/*     */ 
/*     */     
/* 448 */     if (preUTF8) {
/* 449 */       charBuffer = new char[10];
/* 450 */       byteBuffer = null;
/*     */     } else {
/* 452 */       charBuffer = null;
/* 453 */       byteBuffer = new byte[20];
/*     */     } 
/*     */     
/* 456 */     for (int i = 0; i < numTerms; i++) {
/* 457 */       String term; start = this.tvf.readVInt();
/* 458 */       deltaLength = this.tvf.readVInt();
/* 459 */       totalLength = start + deltaLength;
/*     */ 
/*     */ 
/*     */       
/* 463 */       if (preUTF8) {
/*     */         
/* 465 */         if (charBuffer.length < totalLength) {
/* 466 */           char[] newCharBuffer = new char[(int)(1.5D * totalLength)];
/* 467 */           System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);
/* 468 */           charBuffer = newCharBuffer;
/*     */         } 
/* 470 */         this.tvf.readChars(charBuffer, start, deltaLength);
/* 471 */         term = new String(charBuffer, 0, totalLength);
/*     */       } else {
/*     */         
/* 474 */         if (byteBuffer.length < totalLength) {
/* 475 */           byte[] newByteBuffer = new byte[(int)(1.5D * totalLength)];
/* 476 */           System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);
/* 477 */           byteBuffer = newByteBuffer;
/*     */         } 
/* 479 */         this.tvf.readBytes(byteBuffer, start, deltaLength);
/* 480 */         term = new String(byteBuffer, 0, totalLength, ""UTF-8"");
/*     */       } 
/* 482 */       int freq = this.tvf.readVInt();
/* 483 */       int[] positions = null;
/* 484 */       if (storePositions)
/*     */       {
/* 486 */         if (!mapper.isIgnoringPositions()) {
/* 487 */           positions = new int[freq];
/* 488 */           int prevPosition = 0;
/* 489 */           for (int j = 0; j < freq; j++)
/*     */           {
/* 491 */             positions[j] = prevPosition + this.tvf.readVInt();
/* 492 */             prevPosition = positions[j];
/*     */           }
/*     */         
/*     */         } else {
/*     */           
/* 497 */           for (int j = 0; j < freq; j++)
/*     */           {
/* 499 */             this.tvf.readVInt();
/*     */           }
/*     */         } 
/*     */       }
/* 503 */       TermVectorOffsetInfo[] offsets = null;
/* 504 */       if (storeOffsets)
/*     */       {
/* 506 */         if (!mapper.isIgnoringOffsets()) {
/* 507 */           offsets = new TermVectorOffsetInfo[freq];
/* 508 */           int prevOffset = 0;
/* 509 */           for (int j = 0; j < freq; j++) {
/* 510 */             int startOffset = prevOffset + this.tvf.readVInt();
/* 511 */             int endOffset = startOffset + this.tvf.readVInt();
/* 512 */             offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);
/* 513 */             prevOffset = endOffset;
/*     */           } 
/*     */         } else {
/* 516 */           for (int j = 0; j < freq; j++) {
/* 517 */             this.tvf.readVInt();
/* 518 */             this.tvf.readVInt();
/*     */           } 
/*     */         } 
/*     */       }
/* 522 */       mapper.map(term, freq, offsets, positions);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   protected Object clone() throws CloneNotSupportedException {
/* 528 */     TermVectorsReader clone = (TermVectorsReader)super.clone();
/*     */ 
/*     */ 
/*     */     
/* 532 */     if (this.tvx != null && this.tvd != null && this.tvf != null) {
/* 533 */       clone.tvx = (IndexInput)this.tvx.clone();
/* 534 */       clone.tvd = (IndexInput)this.tvd.clone();
/* 535 */       clone.tvf = (IndexInput)this.tvf.clone();
/*     */     } 
/*     */     
/* 538 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorsReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsTermsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.RAMOutputStream;
/*     */ import org.apache.lucene.util.ArrayUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermVectorsTermsWriter
/*     */   extends TermsHashConsumer
/*     */ {
/*     */   final DocumentsWriter docWriter;
/*     */   TermVectorsWriter termVectorsWriter;
/*  33 */   PerDoc[] docFreeList = new PerDoc[1];
/*     */   
/*     */   int freeCount;
/*     */   
/*     */   IndexOutput tvx;
/*     */   
/*     */   IndexOutput tvd;
/*     */   
/*  41 */   public TermVectorsTermsWriter(DocumentsWriter docWriter) { this.docWriter = docWriter; }
/*     */   IndexOutput tvf; int lastDocID; int allocCount;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  45 */   public TermsHashConsumerPerThread addThread(TermsHashPerThread termsHashPerThread) { return new TermVectorsTermsWriterPerThread(termsHashPerThread, this); }
/*     */ 
/*     */   
/*     */   void createPostings(RawPostingList[] postings, int start, int count) {
/*  49 */     int end = start + count;
/*  50 */     for (int i = start; i < end; i++) {
/*  51 */       postings[i] = new PostingList();
/*     */     }
/*     */   }
/*     */   
/*     */   synchronized void flush(Map threadsAndFields, DocumentsWriter.FlushState state) throws IOException {
/*  56 */     if (this.tvx != null) {
/*     */       
/*  58 */       if (state.numDocsInStore > 0)
/*     */       {
/*     */         
/*  61 */         fill(state.numDocsInStore - this.docWriter.getDocStoreOffset());
/*     */       }
/*  63 */       this.tvx.flush();
/*  64 */       this.tvd.flush();
/*  65 */       this.tvf.flush();
/*     */     } 
/*     */     
/*  68 */     Iterator it = threadsAndFields.entrySet().iterator();
/*  69 */     while (it.hasNext()) {
/*  70 */       Map.Entry entry = it.next();
/*  71 */       Iterator it2 = ((Collection)entry.getValue()).iterator();
/*  72 */       while (it2.hasNext()) {
/*  73 */         TermVectorsTermsWriterPerField perField = it2.next();
/*  74 */         perField.termsHashPerField.reset();
/*  75 */         perField.shrinkHash();
/*     */       } 
/*     */       
/*  78 */       TermVectorsTermsWriterPerThread perThread = (TermVectorsTermsWriterPerThread)entry.getKey();
/*  79 */       perThread.termsHashPerThread.reset(true);
/*     */     } 
/*     */   }
/*     */   
/*     */   synchronized void closeDocStore(DocumentsWriter.FlushState state) throws IOException {
/*  84 */     if (this.tvx != null) {
/*     */ 
/*     */       
/*  87 */       fill(state.numDocsInStore - this.docWriter.getDocStoreOffset());
/*  88 */       this.tvx.close();
/*  89 */       this.tvf.close();
/*  90 */       this.tvd.close();
/*  91 */       this.tvx = null;
/*  92 */       assert state.docStoreSegmentName != null;
/*  93 */       if ((4 + state.numDocsInStore * 16) != state.directory.fileLength(state.docStoreSegmentName + ""."" + ""tvx"")) {
/*  94 */         throw new RuntimeException(""after flush: tvx size mismatch: "" + state.numDocsInStore + "" docs vs "" + state.directory.fileLength(state.docStoreSegmentName + ""."" + ""tvx"") + "" length in bytes of "" + state.docStoreSegmentName + ""."" + ""tvx"");
/*     */       }
/*  96 */       state.flushedFiles.add(state.docStoreSegmentName + ""."" + ""tvx"");
/*  97 */       state.flushedFiles.add(state.docStoreSegmentName + ""."" + ""tvf"");
/*  98 */       state.flushedFiles.add(state.docStoreSegmentName + ""."" + ""tvd"");
/*     */       
/* 100 */       this.docWriter.removeOpenFile(state.docStoreSegmentName + ""."" + ""tvx"");
/* 101 */       this.docWriter.removeOpenFile(state.docStoreSegmentName + ""."" + ""tvf"");
/* 102 */       this.docWriter.removeOpenFile(state.docStoreSegmentName + ""."" + ""tvd"");
/*     */       
/* 104 */       this.lastDocID = 0;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   synchronized PerDoc getPerDoc() {
/* 111 */     if (this.freeCount == 0) {
/* 112 */       this.allocCount++;
/* 113 */       if (this.allocCount > this.docFreeList.length) {
/*     */ 
/*     */ 
/*     */         
/* 117 */         assert this.allocCount == 1 + this.docFreeList.length;
/* 118 */         this.docFreeList = new PerDoc[ArrayUtil.getNextSize(this.allocCount)];
/*     */       } 
/* 120 */       return new PerDoc();
/*     */     } 
/* 122 */     return this.docFreeList[--this.freeCount];
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void fill(int docID) throws IOException {
/* 128 */     int docStoreOffset = this.docWriter.getDocStoreOffset();
/* 129 */     int end = docID + docStoreOffset;
/* 130 */     if (this.lastDocID < end) {
/* 131 */       long tvfPosition = this.tvf.getFilePointer();
/* 132 */       while (this.lastDocID < end) {
/* 133 */         this.tvx.writeLong(this.tvd.getFilePointer());
/* 134 */         this.tvd.writeVInt(0);
/* 135 */         this.tvx.writeLong(tvfPosition);
/* 136 */         this.lastDocID++;
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   synchronized void initTermVectorsWriter() throws IOException {
/* 142 */     if (this.tvx == null) {
/*     */       
/* 144 */       String docStoreSegment = this.docWriter.getDocStoreSegment();
/*     */       
/* 146 */       if (docStoreSegment == null) {
/*     */         return;
/*     */       }
/* 149 */       assert docStoreSegment != null;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 155 */       this.tvx = this.docWriter.directory.createOutput(docStoreSegment + ""."" + ""tvx"");
/* 156 */       this.tvd = this.docWriter.directory.createOutput(docStoreSegment + ""."" + ""tvd"");
/* 157 */       this.tvf = this.docWriter.directory.createOutput(docStoreSegment + ""."" + ""tvf"");
/*     */       
/* 159 */       this.tvx.writeInt(4);
/* 160 */       this.tvd.writeInt(4);
/* 161 */       this.tvf.writeInt(4);
/*     */       
/* 163 */       this.docWriter.addOpenFile(docStoreSegment + ""."" + ""tvx"");
/* 164 */       this.docWriter.addOpenFile(docStoreSegment + ""."" + ""tvf"");
/* 165 */       this.docWriter.addOpenFile(docStoreSegment + ""."" + ""tvd"");
/*     */       
/* 167 */       this.lastDocID = 0;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   synchronized void finishDocument(PerDoc perDoc) throws IOException {
/* 173 */     assert this.docWriter.writer.testPoint(""TermVectorsTermsWriter.finishDocument start"");
/*     */     
/* 175 */     initTermVectorsWriter();
/*     */     
/* 177 */     fill(perDoc.docID);
/*     */ 
/*     */     
/* 180 */     this.tvx.writeLong(this.tvd.getFilePointer());
/* 181 */     this.tvx.writeLong(this.tvf.getFilePointer());
/* 182 */     this.tvd.writeVInt(perDoc.numVectorFields);
/* 183 */     if (perDoc.numVectorFields > 0) {
/* 184 */       for (int i = 0; i < perDoc.numVectorFields; i++)
/* 185 */         this.tvd.writeVInt(perDoc.fieldNumbers[i]); 
/* 186 */       assert 0L == perDoc.fieldPointers[0];
/* 187 */       long lastPos = perDoc.fieldPointers[0];
/* 188 */       for (int i = 1; i < perDoc.numVectorFields; i++) {
/* 189 */         long pos = perDoc.fieldPointers[i];
/* 190 */         this.tvd.writeVLong(pos - lastPos);
/* 191 */         lastPos = pos;
/*     */       } 
/* 193 */       perDoc.tvf.writeTo(this.tvf);
/* 194 */       perDoc.tvf.reset();
/* 195 */       perDoc.numVectorFields = 0;
/*     */     } 
/*     */     
/* 198 */     assert this.lastDocID == perDoc.docID + this.docWriter.getDocStoreOffset();
/*     */     
/* 200 */     this.lastDocID++;
/*     */     
/* 202 */     free(perDoc);
/* 203 */     assert this.docWriter.writer.testPoint(""TermVectorsTermsWriter.finishDocument end"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 209 */   public boolean freeRAM() { return false; }
/*     */ 
/*     */   
/*     */   public void abort() {
/* 213 */     if (this.tvx != null) {
/*     */       try {
/* 215 */         this.tvx.close();
/* 216 */       } catch (Throwable t) {}
/*     */       
/* 218 */       this.tvx = null;
/*     */     } 
/* 220 */     if (this.tvd != null) {
/*     */       try {
/* 222 */         this.tvd.close();
/* 223 */       } catch (Throwable t) {}
/*     */       
/* 225 */       this.tvd = null;
/*     */     } 
/* 227 */     if (this.tvf != null) {
/*     */       try {
/* 229 */         this.tvf.close();
/* 230 */       } catch (Throwable t) {}
/*     */       
/* 232 */       this.tvf = null;
/*     */     } 
/* 234 */     this.lastDocID = 0;
/*     */   }
/*     */   
/*     */   synchronized void free(PerDoc doc) {
/* 238 */     assert this.freeCount < this.docFreeList.length;
/* 239 */     this.docFreeList[this.freeCount++] = doc;
/*     */   }
/*     */ 
/*     */   
/*     */   class PerDoc
/*     */     extends DocumentsWriter.DocWriter
/*     */   {
/* 246 */     RAMOutputStream tvf = new RAMOutputStream();
/*     */     
/*     */     int numVectorFields;
/* 249 */     int[] fieldNumbers = new int[1];
/* 250 */     long[] fieldPointers = new long[1]; private final TermVectorsTermsWriter this$0;
/*     */     
/*     */     void reset() {
/* 253 */       this.tvf.reset();
/* 254 */       this.numVectorFields = 0;
/*     */     }
/*     */     
/*     */     void abort() {
/* 258 */       reset();
/* 259 */       TermVectorsTermsWriter.this.free(this);
/*     */     }
/*     */     
/*     */     void addField(int fieldNumber) {
/* 263 */       if (this.numVectorFields == this.fieldNumbers.length) {
/* 264 */         this.fieldNumbers = ArrayUtil.grow(this.fieldNumbers);
/* 265 */         this.fieldPointers = ArrayUtil.grow(this.fieldPointers);
/*     */       } 
/* 267 */       this.fieldNumbers[this.numVectorFields] = fieldNumber;
/* 268 */       this.fieldPointers[this.numVectorFields] = this.tvf.getFilePointer();
/* 269 */       this.numVectorFields++;
/*     */     }
/*     */ 
/*     */     
/* 273 */     public long sizeInBytes() { return this.tvf.sizeInBytes(); }
/*     */ 
/*     */ 
/*     */     
/* 277 */     public void finish() throws IOException { TermVectorsTermsWriter.this.finishDocument(this); }
/*     */   }
/*     */   
/*     */   static final class PostingList
/*     */     extends RawPostingList
/*     */   {
/*     */     int freq;
/*     */     int lastOffset;
/*     */     int lastPosition;
/*     */   }
/*     */   
/* 288 */   int bytesPerPosting() { return 32; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorsTermsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsTermsWriterPerField,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.RAMOutputStream;
/*     */ import org.apache.lucene.util.UnicodeUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermVectorsTermsWriterPerField
/*     */   extends TermsHashConsumerPerField
/*     */ {
/*     */   final TermVectorsTermsWriterPerThread perThread;
/*     */   final TermsHashPerField termsHashPerField;
/*     */   final TermVectorsTermsWriter termsWriter;
/*     */   final FieldInfo fieldInfo;
/*     */   final DocumentsWriter.DocState docState;
/*     */   final DocInverter.FieldInvertState fieldState;
/*     */   boolean doVectors;
/*     */   boolean doVectorPositions;
/*     */   boolean doVectorOffsets;
/*     */   int maxNumPostings;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public TermVectorsTermsWriterPerField(TermsHashPerField termsHashPerField, TermVectorsTermsWriterPerThread perThread, FieldInfo fieldInfo) {
/*  42 */     this.termsHashPerField = termsHashPerField;
/*  43 */     this.perThread = perThread;
/*  44 */     this.termsWriter = perThread.termsWriter;
/*  45 */     this.fieldInfo = fieldInfo;
/*  46 */     this.docState = termsHashPerField.docState;
/*  47 */     this.fieldState = termsHashPerField.fieldState;
/*     */   }
/*     */ 
/*     */   
/*  51 */   int getStreamCount() { return 2; }
/*     */ 
/*     */   
/*     */   boolean start(Fieldable[] fields, int count) {
/*  55 */     this.doVectors = false;
/*  56 */     this.doVectorPositions = false;
/*  57 */     this.doVectorOffsets = false;
/*     */     
/*  59 */     for (int i = 0; i < count; i++) {
/*  60 */       Fieldable field = fields[i];
/*  61 */       if (field.isIndexed() && field.isTermVectorStored()) {
/*  62 */         this.doVectors = true;
/*  63 */         this.doVectorPositions |= field.isStorePositionWithTermVector();
/*  64 */         this.doVectorOffsets |= field.isStoreOffsetWithTermVector();
/*     */       } 
/*     */     } 
/*     */     
/*  68 */     if (this.doVectors) {
/*  69 */       if (this.perThread.doc == null) {
/*  70 */         this.perThread.doc = this.termsWriter.getPerDoc();
/*  71 */         this.perThread.doc.docID = this.docState.docID;
/*  72 */         assert this.perThread.doc.numVectorFields == 0;
/*  73 */         assert 0L == this.perThread.doc.tvf.length();
/*  74 */         assert 0L == this.perThread.doc.tvf.getFilePointer();
/*     */       } else {
/*  76 */         assert this.perThread.doc.docID == this.docState.docID;
/*     */         
/*  78 */         if (this.termsHashPerField.numPostings != 0)
/*     */         {
/*     */ 
/*     */           
/*  82 */           this.termsHashPerField.reset();
/*     */         }
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*  89 */     return this.doVectors;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void abort() {}
/*     */ 
/*     */ 
/*     */   
/*     */   void finish() throws IOException {
/* 100 */     assert this.docState.testPoint(""TermVectorsTermsWriterPerField.finish start"");
/*     */     
/* 102 */     int numPostings = this.termsHashPerField.numPostings;
/*     */     
/* 104 */     assert numPostings >= 0;
/*     */     
/* 106 */     if (!this.doVectors || numPostings == 0) {
/*     */       return;
/*     */     }
/* 109 */     if (numPostings > this.maxNumPostings) {
/* 110 */       this.maxNumPostings = numPostings;
/*     */     }
/* 112 */     RAMOutputStream rAMOutputStream = this.perThread.doc.tvf;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 118 */     assert this.fieldInfo.storeTermVector;
/* 119 */     assert this.perThread.vectorFieldsInOrder(this.fieldInfo);
/*     */     
/* 121 */     this.perThread.doc.addField(this.termsHashPerField.fieldInfo.number);
/*     */     
/* 123 */     RawPostingList[] postings = this.termsHashPerField.sortPostings();
/*     */     
/* 125 */     rAMOutputStream.writeVInt(numPostings);
/* 126 */     byte bits = 0;
/* 127 */     if (this.doVectorPositions)
/* 128 */       bits = (byte)(bits | 0x1); 
/* 129 */     if (this.doVectorOffsets)
/* 130 */       bits = (byte)(bits | 0x2); 
/* 131 */     rAMOutputStream.writeByte(bits);
/*     */     
/* 133 */     int encoderUpto = 0;
/* 134 */     int lastTermBytesCount = 0;
/*     */     
/* 136 */     ByteSliceReader reader = this.perThread.vectorSliceReader;
/* 137 */     char[][] charBuffers = this.perThread.termsHashPerThread.charPool.buffers;
/* 138 */     for (int j = 0; j < numPostings; j++) {
/* 139 */       TermVectorsTermsWriter.PostingList posting = (TermVectorsTermsWriter.PostingList)postings[j];
/* 140 */       int freq = posting.freq;
/*     */       
/* 142 */       char[] text2 = charBuffers[posting.textStart >> 14];
/* 143 */       int start2 = posting.textStart & 0x3FFF;
/*     */ 
/*     */ 
/*     */       
/* 147 */       UnicodeUtil.UTF8Result utf8Result = this.perThread.utf8Results[encoderUpto];
/*     */ 
/*     */       
/* 150 */       UnicodeUtil.UTF16toUTF8(text2, start2, utf8Result);
/* 151 */       int termBytesCount = utf8Result.length;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 156 */       int prefix = 0;
/* 157 */       if (j > 0) {
/* 158 */         byte[] lastTermBytes = (this.perThread.utf8Results[1 - encoderUpto]).result;
/* 159 */         byte[] termBytes = (this.perThread.utf8Results[encoderUpto]).result;
/* 160 */         while (prefix < lastTermBytesCount && prefix < termBytesCount && 
/* 161 */           lastTermBytes[prefix] == termBytes[prefix])
/*     */         {
/* 163 */           prefix++;
/*     */         }
/*     */       } 
/* 166 */       encoderUpto = 1 - encoderUpto;
/* 167 */       lastTermBytesCount = termBytesCount;
/*     */       
/* 169 */       int suffix = termBytesCount - prefix;
/* 170 */       rAMOutputStream.writeVInt(prefix);
/* 171 */       rAMOutputStream.writeVInt(suffix);
/* 172 */       rAMOutputStream.writeBytes(utf8Result.result, prefix, suffix);
/* 173 */       rAMOutputStream.writeVInt(freq);
/*     */       
/* 175 */       if (this.doVectorPositions) {
/* 176 */         this.termsHashPerField.initReader(reader, posting, 0);
/* 177 */         reader.writeTo((IndexOutput)rAMOutputStream);
/*     */       } 
/*     */       
/* 180 */       if (this.doVectorOffsets) {
/* 181 */         this.termsHashPerField.initReader(reader, posting, 1);
/* 182 */         reader.writeTo((IndexOutput)rAMOutputStream);
/*     */       } 
/*     */     } 
/*     */     
/* 186 */     this.termsHashPerField.reset();
/* 187 */     this.perThread.termsHashPerThread.reset(false);
/*     */   }
/*     */   
/*     */   void shrinkHash() {
/* 191 */     this.termsHashPerField.shrinkHash(this.maxNumPostings);
/* 192 */     this.maxNumPostings = 0;
/*     */   }
/*     */ 
/*     */   
/*     */   void newTerm(Token t, RawPostingList p0) {
/* 197 */     assert this.docState.testPoint(""TermVectorsTermsWriterPerField.newTerm start"");
/*     */     
/* 199 */     TermVectorsTermsWriter.PostingList p = (TermVectorsTermsWriter.PostingList)p0;
/*     */     
/* 201 */     p.freq = 1;
/*     */     
/* 203 */     if (this.doVectorOffsets) {
/* 204 */       int startOffset = this.fieldState.offset + t.startOffset();
/* 205 */       int endOffset = this.fieldState.offset + t.endOffset();
/* 206 */       this.termsHashPerField.writeVInt(1, startOffset);
/* 207 */       this.termsHashPerField.writeVInt(1, endOffset - startOffset);
/* 208 */       p.lastOffset = endOffset;
/*     */     } 
/*     */     
/* 211 */     if (this.doVectorPositions) {
/* 212 */       this.termsHashPerField.writeVInt(0, this.fieldState.position);
/* 213 */       p.lastPosition = this.fieldState.position;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   void addTerm(Token t, RawPostingList p0) {
/* 219 */     assert this.docState.testPoint(""TermVectorsTermsWriterPerField.addTerm start"");
/*     */     
/* 221 */     TermVectorsTermsWriter.PostingList p = (TermVectorsTermsWriter.PostingList)p0;
/* 222 */     p.freq++;
/*     */     
/* 224 */     if (this.doVectorOffsets) {
/* 225 */       int startOffset = this.fieldState.offset + t.startOffset();
/* 226 */       int endOffset = this.fieldState.offset + t.endOffset();
/* 227 */       this.termsHashPerField.writeVInt(1, startOffset - p.lastOffset);
/* 228 */       this.termsHashPerField.writeVInt(1, endOffset - startOffset);
/* 229 */       p.lastOffset = endOffset;
/*     */     } 
/*     */     
/* 232 */     if (this.doVectorPositions) {
/* 233 */       this.termsHashPerField.writeVInt(0, this.fieldState.position - p.lastPosition);
/* 234 */       p.lastPosition = this.fieldState.position;
/*     */     } 
/*     */   }
/*     */   
/*     */   void skippingLongTerm(Token t) {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorsTermsWriterPerField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsTermsWriterPerThread,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import org.apache.lucene.util.UnicodeUtil;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class TermVectorsTermsWriterPerThread
/*    */   extends TermsHashConsumerPerThread
/*    */ {
/*    */   final TermVectorsTermsWriter termsWriter;
/*    */   final TermsHashPerThread termsHashPerThread;
/*    */   final DocumentsWriter.DocState docState;
/*    */   TermVectorsTermsWriter.PerDoc doc;
/*    */   final ByteSliceReader vectorSliceReader;
/*    */   final UnicodeUtil.UTF8Result[] utf8Results;
/*    */   String lastVectorFieldName;
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public TermVectorsTermsWriterPerThread(TermsHashPerThread termsHashPerThread, TermVectorsTermsWriter termsWriter) {
/* 37 */     this.vectorSliceReader = new ByteSliceReader();
/*    */     
/* 39 */     this.utf8Results = new UnicodeUtil.UTF8Result[] { new UnicodeUtil.UTF8Result(), new UnicodeUtil.UTF8Result() };
/*    */     this.termsWriter = termsWriter;
/*    */     this.termsHashPerThread = termsHashPerThread;
/*    */     this.docState = termsHashPerThread.docState; } public void startDocument() {
/* 43 */     assert clearLastVectorFieldName();
/* 44 */     if (this.doc != null) {
/* 45 */       this.doc.reset();
/* 46 */       this.doc.docID = this.docState.docID;
/*    */     } 
/*    */   }
/*    */   
/*    */   public DocumentsWriter.DocWriter finishDocument() {
/*    */     try {
/* 52 */       return this.doc;
/*    */     } finally {
/* 54 */       this.doc = null;
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 59 */   public TermsHashConsumerPerField addField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo) { return new TermVectorsTermsWriterPerField(termsHashPerField, this, fieldInfo); }
/*    */ 
/*    */   
/*    */   public void abort() {
/* 63 */     if (this.doc != null) {
/* 64 */       this.doc.abort();
/* 65 */       this.doc = null;
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/*    */   final boolean clearLastVectorFieldName() {
/* 71 */     this.lastVectorFieldName = null;
/* 72 */     return true;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   final boolean vectorFieldsInOrder(FieldInfo fi) {
/*    */     try {
/* 79 */       if (this.lastVectorFieldName != null) {
/* 80 */         return (this.lastVectorFieldName.compareTo(fi.name) < 0);
/*    */       }
/* 82 */       return true;
/*    */     } finally {
/* 84 */       this.lastVectorFieldName = fi.name;
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorsTermsWriterPerThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.StringHelper;
/*     */ import org.apache.lucene.util.UnicodeUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermVectorsWriter
/*     */ {
/*  29 */   private IndexOutput tvx = null; private IndexOutput tvd = null; private IndexOutput tvf = null;
/*     */   private FieldInfos fieldInfos;
/*  31 */   final UnicodeUtil.UTF8Result[] utf8Results = new UnicodeUtil.UTF8Result[] { new UnicodeUtil.UTF8Result(), new UnicodeUtil.UTF8Result() };
/*     */ 
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */ 
/*     */   
/*     */   public TermVectorsWriter(Directory directory, String segment, FieldInfos fieldInfos) throws IOException {
/*  38 */     this.tvx = directory.createOutput(segment + ""."" + ""tvx"");
/*  39 */     this.tvx.writeInt(4);
/*  40 */     this.tvd = directory.createOutput(segment + ""."" + ""tvd"");
/*  41 */     this.tvd.writeInt(4);
/*  42 */     this.tvf = directory.createOutput(segment + ""."" + ""tvf"");
/*  43 */     this.tvf.writeInt(4);
/*     */     
/*  45 */     this.fieldInfos = fieldInfos;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void addAllDocVectors(TermFreqVector[] vectors) throws IOException {
/*  58 */     this.tvx.writeLong(this.tvd.getFilePointer());
/*  59 */     this.tvx.writeLong(this.tvf.getFilePointer());
/*     */     
/*  61 */     if (vectors != null) {
/*  62 */       int numFields = vectors.length;
/*  63 */       this.tvd.writeVInt(numFields);
/*     */       
/*  65 */       long[] fieldPointers = new long[numFields];
/*     */       
/*  67 */       for (int i = 0; i < numFields; i++) {
/*  68 */         boolean storeOffsets, storePositions; byte bits; TermPositionVector tpVector; fieldPointers[i] = this.tvf.getFilePointer();
/*     */         
/*  70 */         int fieldNumber = this.fieldInfos.fieldNumber(vectors[i].getField());
/*     */ 
/*     */         
/*  73 */         this.tvd.writeVInt(fieldNumber);
/*     */         
/*  75 */         int numTerms = vectors[i].size();
/*  76 */         this.tvf.writeVInt(numTerms);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*  84 */         if (vectors[i] instanceof TermPositionVector) {
/*     */           
/*  86 */           tpVector = (TermPositionVector)vectors[i];
/*  87 */           storePositions = (tpVector.size() > 0 && tpVector.getTermPositions(0) != null);
/*  88 */           storeOffsets = (tpVector.size() > 0 && tpVector.getOffsets(0) != null);
/*  89 */           bits = (byte)((storePositions ? 1 : 0) + (storeOffsets ? 2 : 0));
/*     */         } else {
/*     */           
/*  92 */           tpVector = null;
/*  93 */           bits = 0;
/*  94 */           storePositions = false;
/*  95 */           storeOffsets = false;
/*     */         } 
/*     */         
/*  98 */         this.tvf.writeVInt(bits);
/*     */         
/* 100 */         String[] terms = vectors[i].getTerms();
/* 101 */         int[] freqs = vectors[i].getTermFrequencies();
/*     */         
/* 103 */         int utf8Upto = 0;
/* 104 */         (this.utf8Results[1]).length = 0;
/*     */         
/* 106 */         for (int j = 0; j < numTerms; j++) {
/*     */           
/* 108 */           UnicodeUtil.UTF16toUTF8(terms[j], 0, terms[j].length(), this.utf8Results[utf8Upto]);
/*     */           
/* 110 */           int start = StringHelper.bytesDifference((this.utf8Results[1 - utf8Upto]).result, (this.utf8Results[1 - utf8Upto]).length, (this.utf8Results[utf8Upto]).result, (this.utf8Results[utf8Upto]).length);
/*     */ 
/*     */ 
/*     */           
/* 114 */           int length = (this.utf8Results[utf8Upto]).length - start;
/* 115 */           this.tvf.writeVInt(start);
/* 116 */           this.tvf.writeVInt(length);
/* 117 */           this.tvf.writeBytes((this.utf8Results[utf8Upto]).result, start, length);
/* 118 */           utf8Upto = 1 - utf8Upto;
/*     */           
/* 120 */           int termFreq = freqs[j];
/*     */           
/* 122 */           this.tvf.writeVInt(termFreq);
/*     */           
/* 124 */           if (storePositions) {
/* 125 */             int[] positions = tpVector.getTermPositions(j);
/* 126 */             if (positions == null)
/* 127 */               throw new IllegalStateException(""Trying to write positions that are null!""); 
/* 128 */             assert positions.length == termFreq;
/*     */ 
/*     */             
/* 131 */             int lastPosition = 0;
/* 132 */             for (int k = 0; k < positions.length; k++) {
/* 133 */               int position = positions[k];
/* 134 */               this.tvf.writeVInt(position - lastPosition);
/* 135 */               lastPosition = position;
/*     */             } 
/*     */           } 
/*     */           
/* 139 */           if (storeOffsets) {
/* 140 */             TermVectorOffsetInfo[] offsets = tpVector.getOffsets(j);
/* 141 */             if (offsets == null)
/* 142 */               throw new IllegalStateException(""Trying to write offsets that are null!""); 
/* 143 */             assert offsets.length == termFreq;
/*     */ 
/*     */             
/* 146 */             int lastEndOffset = 0;
/* 147 */             for (int k = 0; k < offsets.length; k++) {
/* 148 */               int startOffset = offsets[k].getStartOffset();
/* 149 */               int endOffset = offsets[k].getEndOffset();
/* 150 */               this.tvf.writeVInt(startOffset - lastEndOffset);
/* 151 */               this.tvf.writeVInt(endOffset - startOffset);
/* 152 */               lastEndOffset = endOffset;
/*     */             } 
/*     */           } 
/*     */         } 
/*     */       } 
/*     */ 
/*     */       
/* 159 */       long lastFieldPointer = fieldPointers[0];
/* 160 */       for (int i = 1; i < numFields; i++) {
/* 161 */         long fieldPointer = fieldPointers[i];
/* 162 */         this.tvd.writeVLong(fieldPointer - lastFieldPointer);
/* 163 */         lastFieldPointer = fieldPointer;
/*     */       } 
/*     */     } else {
/* 166 */       this.tvd.writeVInt(0);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void addRawDocuments(TermVectorsReader reader, int[] tvdLengths, int[] tvfLengths, int numDocs) throws IOException {
/* 175 */     long tvdPosition = this.tvd.getFilePointer();
/* 176 */     long tvfPosition = this.tvf.getFilePointer();
/* 177 */     long tvdStart = tvdPosition;
/* 178 */     long tvfStart = tvfPosition;
/* 179 */     for (int i = 0; i < numDocs; i++) {
/* 180 */       this.tvx.writeLong(tvdPosition);
/* 181 */       tvdPosition += tvdLengths[i];
/* 182 */       this.tvx.writeLong(tvfPosition);
/* 183 */       tvfPosition += tvfLengths[i];
/*     */     } 
/* 185 */     this.tvd.copyBytes(reader.getTvdStream(), tvdPosition - tvdStart);
/* 186 */     this.tvf.copyBytes(reader.getTvfStream(), tvfPosition - tvfStart);
/* 187 */     assert this.tvd.getFilePointer() == tvdPosition;
/* 188 */     assert this.tvf.getFilePointer() == tvfPosition;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/* 195 */     IOException keep = null;
/* 196 */     if (this.tvx != null)
/*     */       try {
/* 198 */         this.tvx.close();
/* 199 */       } catch (IOException e) {
/* 200 */         if (keep == null) keep = e; 
/*     */       }  
/* 202 */     if (this.tvd != null)
/*     */       try {
/* 204 */         this.tvd.close();
/* 205 */       } catch (IOException e) {
/* 206 */         if (keep == null) keep = e; 
/*     */       }  
/* 208 */     if (this.tvf != null)
/*     */       try {
/* 210 */         this.tvf.close();
/* 211 */       } catch (IOException e) {
/* 212 */         if (keep == null) keep = e; 
/*     */       }  
/* 214 */     if (keep != null) throw (IOException)keep.fillInStackTrace(); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\index\TermVectorsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.CharStream,"package org.apache.lucene.queryParser;
import java.io.IOException;
public interface CharStream {
  char readChar() throws IOException;
  int getColumn();
  int getLine();
  int getEndColumn();
  int getEndLine();
  int getBeginColumn();
  int getBeginLine();
  void backup(int paramInt);
  char BeginToken() throws IOException;
  String GetImage();
  char[] GetSuffix(int paramInt);
  void Done();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\CharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.FastCharStream,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FastCharStream
/*     */   implements CharStream
/*     */ {
/*  28 */   char[] buffer = null;
/*     */   
/*  30 */   int bufferLength = 0;
/*  31 */   int bufferPosition = 0;
/*     */   
/*  33 */   int tokenStart = 0;
/*  34 */   int bufferStart = 0;
/*     */ 
/*     */   
/*     */   Reader input;
/*     */ 
/*     */   
/*  40 */   public FastCharStream(Reader r) { this.input = r; }
/*     */ 
/*     */   
/*     */   public final char readChar() throws IOException {
/*  44 */     if (this.bufferPosition >= this.bufferLength)
/*  45 */       refill(); 
/*  46 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */   
/*     */   private final void refill() throws IOException {
/*  50 */     int newPosition = this.bufferLength - this.tokenStart;
/*     */     
/*  52 */     if (this.tokenStart == 0) {
/*  53 */       if (this.buffer == null) {
/*  54 */         this.buffer = new char[2048];
/*  55 */       } else if (this.bufferLength == this.buffer.length) {
/*  56 */         char[] newBuffer = new char[this.buffer.length * 2];
/*  57 */         System.arraycopy(this.buffer, 0, newBuffer, 0, this.bufferLength);
/*  58 */         this.buffer = newBuffer;
/*     */       } 
/*     */     } else {
/*  61 */       System.arraycopy(this.buffer, this.tokenStart, this.buffer, 0, newPosition);
/*     */     } 
/*     */     
/*  64 */     this.bufferLength = newPosition;
/*  65 */     this.bufferPosition = newPosition;
/*  66 */     this.bufferStart += this.tokenStart;
/*  67 */     this.tokenStart = 0;
/*     */     
/*  69 */     int charsRead = this.input.read(this.buffer, newPosition, this.buffer.length - newPosition);
/*     */     
/*  71 */     if (charsRead == -1) {
/*  72 */       throw new IOException(""read past eof"");
/*     */     }
/*  74 */     this.bufferLength += charsRead;
/*     */   }
/*     */   
/*     */   public final char BeginToken() throws IOException {
/*  78 */     this.tokenStart = this.bufferPosition;
/*  79 */     return readChar();
/*     */   }
/*     */ 
/*     */   
/*  83 */   public final void backup(int amount) { this.bufferPosition -= amount; }
/*     */ 
/*     */ 
/*     */   
/*  87 */   public final String GetImage() { return new String(this.buffer, this.tokenStart, this.bufferPosition - this.tokenStart); }
/*     */ 
/*     */   
/*     */   public final char[] GetSuffix(int len) {
/*  91 */     char[] value = new char[len];
/*  92 */     System.arraycopy(this.buffer, this.bufferPosition - len, value, 0, len);
/*  93 */     return value;
/*     */   }
/*     */   
/*     */   public final void Done() {
/*     */     try {
/*  98 */       this.input.close();
/*  99 */     } catch (IOException e) {
/* 100 */       System.err.println(""Caught: "" + e + ""; ignoring."");
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 105 */   public final int getColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 108 */   public final int getLine() { return 1; }
/*     */ 
/*     */   
/* 111 */   public final int getEndColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 114 */   public final int getEndLine() { return 1; }
/*     */ 
/*     */   
/* 117 */   public final int getBeginColumn() { return this.bufferStart + this.tokenStart; }
/*     */ 
/*     */   
/* 120 */   public final int getBeginLine() { return 1; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\FastCharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.MultiFieldQueryParser,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.search.BooleanClause;
/*     */ import org.apache.lucene.search.BooleanQuery;
/*     */ import org.apache.lucene.search.MultiPhraseQuery;
/*     */ import org.apache.lucene.search.PhraseQuery;
/*     */ import org.apache.lucene.search.Query;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiFieldQueryParser
/*     */   extends QueryParser
/*     */ {
/*     */   protected String[] fields;
/*     */   protected Map boosts;
/*     */   
/*     */   public MultiFieldQueryParser(String[] fields, Analyzer analyzer, Map boosts) {
/*  71 */     this(fields, analyzer);
/*  72 */     this.boosts = boosts;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultiFieldQueryParser(String[] fields, Analyzer analyzer) {
/*  96 */     super(null, analyzer);
/*  97 */     this.fields = fields;
/*     */   }
/*     */   
/*     */   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
/* 101 */     if (field == null) {
/* 102 */       List clauses = new ArrayList();
/* 103 */       for (int i = 0; i < this.fields.length; i++) {
/* 104 */         Query q = super.getFieldQuery(this.fields[i], queryText);
/* 105 */         if (q != null) {
/*     */           
/* 107 */           if (this.boosts != null) {
/*     */             
/* 109 */             Float boost = (Float)this.boosts.get(this.fields[i]);
/* 110 */             if (boost != null) {
/* 111 */               q.setBoost(boost.floatValue());
/*     */             }
/*     */           } 
/* 114 */           applySlop(q, slop);
/* 115 */           clauses.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
/*     */         } 
/*     */       } 
/* 118 */       if (clauses.size() == 0)
/* 119 */         return null; 
/* 120 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 122 */     Query q = super.getFieldQuery(field, queryText);
/* 123 */     applySlop(q, slop);
/* 124 */     return q;
/*     */   }
/*     */   
/*     */   private void applySlop(Query q, int slop) {
/* 128 */     if (q instanceof PhraseQuery) {
/* 129 */       ((PhraseQuery)q).setSlop(slop);
/* 130 */     } else if (q instanceof MultiPhraseQuery) {
/* 131 */       ((MultiPhraseQuery)q).setSlop(slop);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 137 */   protected Query getFieldQuery(String field, String queryText) throws ParseException { return getFieldQuery(field, queryText, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
/* 143 */     if (field == null) {
/* 144 */       List clauses = new ArrayList();
/* 145 */       for (int i = 0; i < this.fields.length; i++) {
/* 146 */         clauses.add(new BooleanClause(getFuzzyQuery(this.fields[i], termStr, minSimilarity), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 149 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 151 */     return super.getFuzzyQuery(field, termStr, minSimilarity);
/*     */   }
/*     */ 
/*     */   
/*     */   protected Query getPrefixQuery(String field, String termStr) throws ParseException {
/* 156 */     if (field == null) {
/* 157 */       List clauses = new ArrayList();
/* 158 */       for (int i = 0; i < this.fields.length; i++) {
/* 159 */         clauses.add(new BooleanClause(getPrefixQuery(this.fields[i], termStr), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 162 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 164 */     return super.getPrefixQuery(field, termStr);
/*     */   }
/*     */   
/*     */   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
/* 168 */     if (field == null) {
/* 169 */       List clauses = new ArrayList();
/* 170 */       for (int i = 0; i < this.fields.length; i++) {
/* 171 */         clauses.add(new BooleanClause(getWildcardQuery(this.fields[i], termStr), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 174 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 176 */     return super.getWildcardQuery(field, termStr);
/*     */   }
/*     */ 
/*     */   
/*     */   protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
/* 181 */     if (field == null) {
/* 182 */       List clauses = new ArrayList();
/* 183 */       for (int i = 0; i < this.fields.length; i++) {
/* 184 */         clauses.add(new BooleanClause(getRangeQuery(this.fields[i], part1, part2, inclusive), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 187 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 189 */     return super.getRangeQuery(field, part1, part2, inclusive);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String[] queries, String[] fields, Analyzer analyzer) throws ParseException {
/* 211 */     if (queries.length != fields.length)
/* 212 */       throw new IllegalArgumentException(""queries.length != fields.length""); 
/* 213 */     BooleanQuery bQuery = new BooleanQuery();
/* 214 */     for (int i = 0; i < fields.length; i++) {
/*     */       
/* 216 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 217 */       Query q = qp.parse(queries[i]);
/* 218 */       if (q != null && (!(q instanceof BooleanQuery) || (((BooleanQuery)q).getClauses()).length > 0))
/*     */       {
/* 220 */         bQuery.add(q, BooleanClause.Occur.SHOULD);
/*     */       }
/*     */     } 
/* 223 */     return (Query)bQuery;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String query, String[] fields, BooleanClause.Occur[] flags, Analyzer analyzer) throws ParseException {
/* 258 */     if (fields.length != flags.length)
/* 259 */       throw new IllegalArgumentException(""fields.length != flags.length""); 
/* 260 */     BooleanQuery bQuery = new BooleanQuery();
/* 261 */     for (int i = 0; i < fields.length; i++) {
/* 262 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 263 */       Query q = qp.parse(query);
/* 264 */       if (q != null && (!(q instanceof BooleanQuery) || (((BooleanQuery)q).getClauses()).length > 0))
/*     */       {
/* 266 */         bQuery.add(q, flags[i]);
/*     */       }
/*     */     } 
/* 269 */     return (Query)bQuery;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String[] queries, String[] fields, BooleanClause.Occur[] flags, Analyzer analyzer) throws ParseException {
/* 306 */     if (queries.length != fields.length || queries.length != flags.length)
/* 307 */       throw new IllegalArgumentException(""queries, fields, and flags array have have different length""); 
/* 308 */     BooleanQuery bQuery = new BooleanQuery();
/* 309 */     for (int i = 0; i < fields.length; i++) {
/*     */       
/* 311 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 312 */       Query q = qp.parse(queries[i]);
/* 313 */       if (q != null && (!(q instanceof BooleanQuery) || (((BooleanQuery)q).getClauses()).length > 0))
/*     */       {
/* 315 */         bQuery.add(q, flags[i]);
/*     */       }
/*     */     } 
/* 318 */     return (Query)bQuery;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\MultiFieldQueryParser.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.ParseException,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParseException
/*     */   extends Exception
/*     */ {
/*     */   protected boolean specialConstructor;
/*     */   public Token currentToken;
/*     */   public int[][] expectedTokenSequences;
/*     */   public String[] tokenImage;
/*     */   protected String eol;
/*     */   
/*     */   public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
/*  33 */     super("""");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 145 */     this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = true; this.currentToken = currentTokenVal; this.expectedTokenSequences = expectedTokenSequencesVal; this.tokenImage = tokenImageVal; } public ParseException() { this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = false; } public ParseException(String message) { super(message); this.eol = System.getProperty(""line.separator"", ""\n"");
/*     */     this.specialConstructor = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected String add_escapes(String str) {
/* 153 */     StringBuffer retval = new StringBuffer();
/*     */     
/* 155 */     for (int i = 0; i < str.length(); i++) {
/* 156 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/* 161 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/* 164 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/* 167 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/* 170 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/* 173 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/* 176 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/* 179 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/* 182 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/* 185 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/* 186 */             String s = ""0000"" + Integer.toString(ch, 16);
/* 187 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/* 189 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/* 194 */     return retval.toString();
/*     */   }
/*     */   
/*     */   public String getMessage() {
/*     */     if (!this.specialConstructor)
/*     */       return super.getMessage(); 
/*     */     StringBuffer expected = new StringBuffer();
/*     */     int maxSize = 0;
/*     */     for (int i = 0; i < this.expectedTokenSequences.length; i++) {
/*     */       if (maxSize < (this.expectedTokenSequences[i]).length)
/*     */         maxSize = (this.expectedTokenSequences[i]).length; 
/*     */       for (int j = 0; j < (this.expectedTokenSequences[i]).length; j++)
/*     */         expected.append(this.tokenImage[this.expectedTokenSequences[i][j]]).append(' '); 
/*     */       if (this.expectedTokenSequences[i][(this.expectedTokenSequences[i]).length - 1] != 0)
/*     */         expected.append(""...""); 
/*     */       expected.append(this.eol).append(""    "");
/*     */     } 
/*     */     String retval = ""Encountered \"""";
/*     */     Token tok = this.currentToken.next;
/*     */     for (int i = 0; i < maxSize; i++) {
/*     */       if (i != 0)
/*     */         retval = retval + "" ""; 
/*     */       if (tok.kind == 0) {
/*     */         retval = retval + this.tokenImage[0];
/*     */         break;
/*     */       } 
/*     */       retval = retval + "" "" + this.tokenImage[tok.kind];
/*     */       retval = retval + "" \"""";
/*     */       retval = retval + add_escapes(tok.image);
/*     */       retval = retval + "" \"""";
/*     */       tok = tok.next;
/*     */     } 
/*     */     retval = retval + ""\"" at line "" + this.currentToken.next.beginLine + "", column "" + this.currentToken.next.beginColumn;
/*     */     retval = retval + ""."" + this.eol;
/*     */     if (this.expectedTokenSequences.length == 1) {
/*     */       retval = retval + ""Was expecting:"" + this.eol + ""    "";
/*     */     } else {
/*     */       retval = retval + ""Was expecting one of:"" + this.eol + ""    "";
/*     */     } 
/*     */     retval = retval + expected.toString();
/*     */     return retval;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\ParseException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParser,"/*      */ package org.apache.lucene.queryParser;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.StringReader;
/*      */ import java.text.Collator;
/*      */ import java.text.DateFormat;
/*      */ import java.util.ArrayList;
/*      */ import java.util.Calendar;
/*      */ import java.util.Date;
/*      */ import java.util.HashMap;
/*      */ import java.util.Iterator;
/*      */ import java.util.List;
/*      */ import java.util.Locale;
/*      */ import java.util.Map;
/*      */ import java.util.Vector;
/*      */ import org.apache.lucene.analysis.Analyzer;
/*      */ import org.apache.lucene.analysis.SimpleAnalyzer;
/*      */ import org.apache.lucene.analysis.Token;
/*      */ import org.apache.lucene.analysis.TokenStream;
/*      */ import org.apache.lucene.document.DateField;
/*      */ import org.apache.lucene.document.DateTools;
/*      */ import org.apache.lucene.index.Term;
/*      */ import org.apache.lucene.search.BooleanClause;
/*      */ import org.apache.lucene.search.BooleanQuery;
/*      */ import org.apache.lucene.search.ConstantScoreRangeQuery;
/*      */ import org.apache.lucene.search.FuzzyQuery;
/*      */ import org.apache.lucene.search.MatchAllDocsQuery;
/*      */ import org.apache.lucene.search.MultiPhraseQuery;
/*      */ import org.apache.lucene.search.PhraseQuery;
/*      */ import org.apache.lucene.search.PrefixQuery;
/*      */ import org.apache.lucene.search.Query;
/*      */ import org.apache.lucene.search.RangeQuery;
/*      */ import org.apache.lucene.search.TermQuery;
/*      */ import org.apache.lucene.search.WildcardQuery;
/*      */ import org.apache.lucene.util.Parameter;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class QueryParser
/*      */   implements QueryParserConstants
/*      */ {
/*      */   private static final int CONJ_NONE = 0;
/*      */   private static final int CONJ_AND = 1;
/*      */   private static final int CONJ_OR = 2;
/*      */   private static final int MOD_NONE = 0;
/*      */   private static final int MOD_NOT = 10;
/*      */   private static final int MOD_REQ = 11;
/*  112 */   public static final Operator AND_OPERATOR = Operator.AND;
/*      */   
/*  114 */   public static final Operator OR_OPERATOR = Operator.OR;
/*      */ 
/*      */   
/*  117 */   private Operator operator = OR_OPERATOR;
/*      */   
/*      */   boolean lowercaseExpandedTerms = true;
/*      */   
/*      */   boolean useOldRangeQuery = false;
/*      */   boolean allowLeadingWildcard = false;
/*      */   boolean enablePositionIncrements = false;
/*      */   Analyzer analyzer;
/*      */   String field;
/*  126 */   int phraseSlop = 0;
/*  127 */   float fuzzyMinSim = 0.5F;
/*  128 */   int fuzzyPrefixLength = 0;
/*  129 */   Locale locale = Locale.getDefault();
/*      */ 
/*      */   
/*  132 */   DateTools.Resolution dateResolution = null;
/*      */   
/*  134 */   Map fieldToDateResolution = null;
/*      */ 
/*      */ 
/*      */   
/*  138 */   Collator rangeCollator = null; public QueryParserTokenManager token_source; public Token token; public Token jj_nt;
/*      */   private int jj_ntk;
/*      */   private Token jj_scanpos;
/*      */   private Token jj_lastpos;
/*      */   private int jj_la;
/*      */   private int jj_gen;
/*      */   
/*  145 */   public static final class Operator extends Parameter { private Operator(String name) { super(name); }
/*      */     
/*  147 */     public static final Operator OR = new Operator(""OR"");
/*  148 */     public static final Operator AND = new Operator(""AND""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public QueryParser(String f, Analyzer a) {
/*  157 */     this(new FastCharStream(new StringReader("""")));
/*  158 */     this.analyzer = a;
/*  159 */     this.field = f;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Query parse(String query) throws ParseException {
/*  167 */     ReInit(new FastCharStream(new StringReader(query)));
/*      */     
/*      */     try {
/*  170 */       Query res = TopLevelQuery(this.field);
/*  171 */       return (res != null) ? res : (Query)newBooleanQuery(false);
/*      */     }
/*  173 */     catch (ParseException tme) {
/*      */       
/*  175 */       throw new ParseException(""Cannot parse '"" + query + ""': "" + tme.getMessage());
/*      */     }
/*  177 */     catch (TokenMgrError tme) {
/*  178 */       throw new ParseException(""Cannot parse '"" + query + ""': "" + tme.getMessage());
/*      */     }
/*  180 */     catch (org.apache.lucene.search.BooleanQuery.TooManyClauses tmc) {
/*  181 */       throw new ParseException(""Cannot parse '"" + query + ""': too many boolean clauses"");
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  189 */   public Analyzer getAnalyzer() { return this.analyzer; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  196 */   public String getField() { return this.field; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  203 */   public float getFuzzyMinSim() { return this.fuzzyMinSim; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  211 */   public void setFuzzyMinSim(float fuzzyMinSim) { this.fuzzyMinSim = fuzzyMinSim; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  219 */   public int getFuzzyPrefixLength() { return this.fuzzyPrefixLength; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  227 */   public void setFuzzyPrefixLength(int fuzzyPrefixLength) { this.fuzzyPrefixLength = fuzzyPrefixLength; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  235 */   public void setPhraseSlop(int phraseSlop) { this.phraseSlop = phraseSlop; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  242 */   public int getPhraseSlop() { return this.phraseSlop; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  257 */   public void setAllowLeadingWildcard(boolean allowLeadingWildcard) { this.allowLeadingWildcard = allowLeadingWildcard; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  264 */   public boolean getAllowLeadingWildcard() { return this.allowLeadingWildcard; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  278 */   public void setEnablePositionIncrements(boolean enable) { this.enablePositionIncrements = enable; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  285 */   public boolean getEnablePositionIncrements() { return this.enablePositionIncrements; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  297 */   public void setDefaultOperator(Operator op) { this.operator = op; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  306 */   public Operator getDefaultOperator() { return this.operator; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  315 */   public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) { this.lowercaseExpandedTerms = lowercaseExpandedTerms; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  323 */   public boolean getLowercaseExpandedTerms() { return this.lowercaseExpandedTerms; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  336 */   public void setUseOldRangeQuery(boolean useOldRangeQuery) { this.useOldRangeQuery = useOldRangeQuery; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  344 */   public boolean getUseOldRangeQuery() { return this.useOldRangeQuery; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  351 */   public void setLocale(Locale locale) { this.locale = locale; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  358 */   public Locale getLocale() { return this.locale; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  369 */   public void setDateResolution(DateTools.Resolution dateResolution) { this.dateResolution = dateResolution; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setDateResolution(String fieldName, DateTools.Resolution dateResolution) {
/*  379 */     if (fieldName == null) {
/*  380 */       throw new IllegalArgumentException(""Field cannot be null."");
/*      */     }
/*      */     
/*  383 */     if (this.fieldToDateResolution == null)
/*      */     {
/*  385 */       this.fieldToDateResolution = new HashMap();
/*      */     }
/*      */     
/*  388 */     this.fieldToDateResolution.put(fieldName, dateResolution);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public DateTools.Resolution getDateResolution(String fieldName) {
/*  398 */     if (fieldName == null) {
/*  399 */       throw new IllegalArgumentException(""Field cannot be null."");
/*      */     }
/*      */     
/*  402 */     if (this.fieldToDateResolution == null)
/*      */     {
/*  404 */       return this.dateResolution;
/*      */     }
/*      */     
/*  407 */     DateTools.Resolution resolution = (DateTools.Resolution)this.fieldToDateResolution.get(fieldName);
/*  408 */     if (resolution == null)
/*      */     {
/*  410 */       resolution = this.dateResolution;
/*      */     }
/*      */     
/*  413 */     return resolution;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  432 */   public void setRangeCollator(Collator rc) { this.rangeCollator = rc; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  442 */   public Collator getRangeCollator() { return this.rangeCollator; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  449 */   protected void addClause(Vector clauses, int conj, int mods, Query q) { addClause(clauses, conj, mods, q); }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected void addClause(List clauses, int conj, int mods, Query q) {
/*      */     boolean prohibited;
/*      */     boolean required;
/*  457 */     if (clauses.size() > 0 && conj == 1) {
/*  458 */       BooleanClause c = clauses.get(clauses.size() - 1);
/*  459 */       if (!c.isProhibited()) {
/*  460 */         c.setOccur(BooleanClause.Occur.MUST);
/*      */       }
/*      */     } 
/*  463 */     if (clauses.size() > 0 && this.operator == AND_OPERATOR && conj == 2) {
/*      */ 
/*      */ 
/*      */ 
/*      */       
/*  468 */       BooleanClause c = clauses.get(clauses.size() - 1);
/*  469 */       if (!c.isProhibited()) {
/*  470 */         c.setOccur(BooleanClause.Occur.SHOULD);
/*      */       }
/*      */     } 
/*      */ 
/*      */     
/*  475 */     if (q == null) {
/*      */       return;
/*      */     }
/*  478 */     if (this.operator == OR_OPERATOR) {
/*      */ 
/*      */       
/*  481 */       prohibited = (mods == 10);
/*  482 */       required = (mods == 11);
/*  483 */       if (conj == 1 && !prohibited) {
/*  484 */         required = true;
/*      */       }
/*      */     }
/*      */     else {
/*      */       
/*  489 */       prohibited = (mods == 10);
/*  490 */       required = (!prohibited && conj != 2);
/*      */     } 
/*  492 */     if (required && !prohibited) {
/*  493 */       clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));
/*  494 */     } else if (!required && !prohibited) {
/*  495 */       clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));
/*  496 */     } else if (!required && prohibited) {
/*  497 */       clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));
/*      */     } else {
/*  499 */       throw new RuntimeException(""Clause cannot be both required and prohibited"");
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFieldQuery(String field, String queryText) throws ParseException {
/*  510 */     TokenStream source = this.analyzer.tokenStream(field, new StringReader(queryText));
/*  511 */     List list = new ArrayList();
/*  512 */     Token reusableToken = new Token();
/*      */     
/*  514 */     int positionCount = 0;
/*  515 */     boolean severalTokensAtSamePosition = false;
/*      */     while (true) {
/*      */       Token token1;
/*      */       try {
/*  519 */         token1 = source.next(reusableToken);
/*      */       }
/*  521 */       catch (IOException e) {
/*  522 */         token1 = null;
/*      */       } 
/*  524 */       if (token1 == null)
/*      */         break; 
/*  526 */       list.add(token1.clone());
/*  527 */       if (token1.getPositionIncrement() != 0) {
/*  528 */         positionCount += token1.getPositionIncrement(); continue;
/*      */       } 
/*  530 */       severalTokensAtSamePosition = true;
/*      */     } 
/*      */     try {
/*  533 */       source.close();
/*      */     }
/*  535 */     catch (IOException e) {}
/*      */ 
/*      */ 
/*      */     
/*  539 */     if (list.size() == 0)
/*  540 */       return null; 
/*  541 */     if (list.size() == 1) {
/*  542 */       Token token1 = (Token)list.get(0);
/*  543 */       return newTermQuery(new Term(field, token1.term()));
/*      */     } 
/*  545 */     if (severalTokensAtSamePosition) {
/*  546 */       if (positionCount == 1) {
/*      */         
/*  548 */         BooleanQuery q = newBooleanQuery(true);
/*  549 */         for (int i = 0; i < list.size(); i++) {
/*  550 */           Token token1 = (Token)list.get(i);
/*  551 */           Query currentQuery = newTermQuery(new Term(field, token1.term()));
/*      */           
/*  553 */           q.add(currentQuery, BooleanClause.Occur.SHOULD);
/*      */         } 
/*  555 */         return (Query)q;
/*      */       } 
/*      */ 
/*      */       
/*  559 */       MultiPhraseQuery mpq = newMultiPhraseQuery();
/*  560 */       mpq.setSlop(this.phraseSlop);
/*  561 */       List multiTerms = new ArrayList();
/*  562 */       int position = -1;
/*  563 */       for (int i = 0; i < list.size(); i++) {
/*  564 */         Token token1 = (Token)list.get(i);
/*  565 */         if (token1.getPositionIncrement() > 0 && multiTerms.size() > 0) {
/*  566 */           if (this.enablePositionIncrements) {
/*  567 */             mpq.add((Term[])multiTerms.toArray((Object[])new Term[0]), position);
/*      */           } else {
/*  569 */             mpq.add((Term[])multiTerms.toArray((Object[])new Term[0]));
/*      */           } 
/*  571 */           multiTerms.clear();
/*      */         } 
/*  573 */         position += token1.getPositionIncrement();
/*  574 */         multiTerms.add(new Term(field, token1.term()));
/*      */       } 
/*  576 */       if (this.enablePositionIncrements) {
/*  577 */         mpq.add(multiTerms.toArray(new Term[0]), position);
/*      */       } else {
/*  579 */         mpq.add(multiTerms.toArray(new Term[0]));
/*      */       } 
/*  581 */       return (Query)mpq;
/*      */     } 
/*      */ 
/*      */     
/*  585 */     PhraseQuery pq = newPhraseQuery();
/*  586 */     pq.setSlop(this.phraseSlop);
/*  587 */     int position = -1;
/*  588 */     for (int i = 0; i < list.size(); i++) {
/*  589 */       Token token1 = (Token)list.get(i);
/*  590 */       if (this.enablePositionIncrements) {
/*  591 */         position += token1.getPositionIncrement();
/*  592 */         pq.add(new Term(field, token1.term()), position);
/*      */       } else {
/*  594 */         pq.add(new Term(field, token1.term()));
/*      */       } 
/*      */     } 
/*  597 */     return (Query)pq;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
/*  612 */     Query query = getFieldQuery(field, queryText);
/*      */     
/*  614 */     if (query instanceof PhraseQuery) {
/*  615 */       ((PhraseQuery)query).setSlop(slop);
/*      */     }
/*  617 */     if (query instanceof MultiPhraseQuery) {
/*  618 */       ((MultiPhraseQuery)query).setSlop(slop);
/*      */     }
/*      */     
/*  621 */     return query;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
/*  633 */     if (this.lowercaseExpandedTerms) {
/*  634 */       part1 = part1.toLowerCase();
/*  635 */       part2 = part2.toLowerCase();
/*      */     } 
/*      */     try {
/*  638 */       DateFormat df = DateFormat.getDateInstance(3, this.locale);
/*  639 */       df.setLenient(true);
/*  640 */       Date d1 = df.parse(part1);
/*  641 */       Date d2 = df.parse(part2);
/*  642 */       if (inclusive) {
/*      */ 
/*      */ 
/*      */         
/*  646 */         Calendar cal = Calendar.getInstance(this.locale);
/*  647 */         cal.setTime(d2);
/*  648 */         cal.set(11, 23);
/*  649 */         cal.set(12, 59);
/*  650 */         cal.set(13, 59);
/*  651 */         cal.set(14, 999);
/*  652 */         d2 = cal.getTime();
/*      */       } 
/*  654 */       DateTools.Resolution resolution = getDateResolution(field);
/*  655 */       if (resolution == null) {
/*      */ 
/*      */ 
/*      */         
/*  659 */         part1 = DateField.dateToString(d1);
/*  660 */         part2 = DateField.dateToString(d2);
/*      */       } else {
/*  662 */         part1 = DateTools.dateToString(d1, resolution);
/*  663 */         part2 = DateTools.dateToString(d2, resolution);
/*      */       }
/*      */     
/*  666 */     } catch (Exception e) {}
/*      */     
/*  668 */     return newRangeQuery(field, part1, part2, inclusive);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  677 */   protected BooleanQuery newBooleanQuery(boolean disableCoord) { return new BooleanQuery(disableCoord); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  687 */   protected BooleanClause newBooleanClause(Query q, BooleanClause.Occur occur) { return new BooleanClause(q, occur); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  696 */   protected Query newTermQuery(Term term) { return (Query)new TermQuery(term); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  704 */   protected PhraseQuery newPhraseQuery() { return new PhraseQuery(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  712 */   protected MultiPhraseQuery newMultiPhraseQuery() { return new MultiPhraseQuery(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  721 */   protected Query newPrefixQuery(Term prefix) { return (Query)new PrefixQuery(prefix); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  732 */   protected Query newFuzzyQuery(Term term, float minimumSimilarity, int prefixLength) { return (Query)new FuzzyQuery(term, minimumSimilarity, prefixLength); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query newRangeQuery(String field, String part1, String part2, boolean inclusive) {
/*  744 */     if (this.useOldRangeQuery)
/*      */     {
/*  746 */       return (Query)new RangeQuery(new Term(field, part1), new Term(field, part2), inclusive, this.rangeCollator);
/*      */     }
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  752 */     return (Query)new ConstantScoreRangeQuery(field, part1, part2, inclusive, inclusive, this.rangeCollator);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  762 */   protected Query newMatchAllDocsQuery() { return (Query)new MatchAllDocsQuery(); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  771 */   protected Query newWildcardQuery(Term t) { return (Query)new WildcardQuery(t); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  789 */   protected Query getBooleanQuery(Vector clauses) throws ParseException { return getBooleanQuery(clauses, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  806 */   protected Query getBooleanQuery(List clauses) throws ParseException { return getBooleanQuery(clauses, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  827 */   protected Query getBooleanQuery(Vector clauses, boolean disableCoord) throws ParseException { return getBooleanQuery(clauses, disableCoord); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getBooleanQuery(List clauses, boolean disableCoord) throws ParseException {
/*  847 */     if (clauses.size() == 0) {
/*  848 */       return null;
/*      */     }
/*  850 */     BooleanQuery query = newBooleanQuery(disableCoord);
/*  851 */     for (int i = 0; i < clauses.size(); i++) {
/*  852 */       query.add(clauses.get(i));
/*      */     }
/*  854 */     return (Query)query;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
/*  880 */     if (""*"".equals(field) && 
/*  881 */       ""*"".equals(termStr)) return newMatchAllDocsQuery();
/*      */     
/*  883 */     if (!this.allowLeadingWildcard && (termStr.startsWith(""*"") || termStr.startsWith(""?"")))
/*  884 */       throw new ParseException(""'*' or '?' not allowed as first character in WildcardQuery""); 
/*  885 */     if (this.lowercaseExpandedTerms) {
/*  886 */       termStr = termStr.toLowerCase();
/*      */     }
/*  888 */     Term t = new Term(field, termStr);
/*  889 */     return newWildcardQuery(t);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getPrefixQuery(String field, String termStr) throws ParseException {
/*  917 */     if (!this.allowLeadingWildcard && termStr.startsWith(""*""))
/*  918 */       throw new ParseException(""'*' not allowed as first character in PrefixQuery""); 
/*  919 */     if (this.lowercaseExpandedTerms) {
/*  920 */       termStr = termStr.toLowerCase();
/*      */     }
/*  922 */     Term t = new Term(field, termStr);
/*  923 */     return newPrefixQuery(t);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
/*  939 */     if (this.lowercaseExpandedTerms) {
/*  940 */       termStr = termStr.toLowerCase();
/*      */     }
/*  942 */     Term t = new Term(field, termStr);
/*  943 */     return newFuzzyQuery(t, minSimilarity, this.fuzzyPrefixLength);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private String discardEscapeChar(String input) throws ParseException {
/*  956 */     char[] output = new char[input.length()];
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  961 */     int length = 0;
/*      */ 
/*      */ 
/*      */     
/*  965 */     boolean lastCharWasEscapeChar = false;
/*      */ 
/*      */ 
/*      */     
/*  969 */     int codePointMultiplier = 0;
/*      */ 
/*      */     
/*  972 */     int codePoint = 0;
/*      */     
/*  974 */     for (int i = 0; i < input.length(); i++) {
/*  975 */       char curChar = input.charAt(i);
/*  976 */       if (codePointMultiplier > 0) {
/*  977 */         codePoint += hexToInt(curChar) * codePointMultiplier;
/*  978 */         codePointMultiplier >>>= 4;
/*  979 */         if (codePointMultiplier == 0) {
/*  980 */           output[length++] = (char)codePoint;
/*  981 */           codePoint = 0;
/*      */         } 
/*  983 */       } else if (lastCharWasEscapeChar) {
/*  984 */         if (curChar == 'u') {
/*      */           
/*  986 */           codePointMultiplier = 4096;
/*      */         } else {
/*      */           
/*  989 */           output[length] = curChar;
/*  990 */           length++;
/*      */         } 
/*  992 */         lastCharWasEscapeChar = false;
/*      */       }
/*  994 */       else if (curChar == '\\') {
/*  995 */         lastCharWasEscapeChar = true;
/*      */       } else {
/*  997 */         output[length] = curChar;
/*  998 */         length++;
/*      */       } 
/*      */     } 
/*      */ 
/*      */     
/* 1003 */     if (codePointMultiplier > 0) {
/* 1004 */       throw new ParseException(""Truncated unicode escape sequence."");
/*      */     }
/*      */     
/* 1007 */     if (lastCharWasEscapeChar) {
/* 1008 */       throw new ParseException(""Term can not end with escape character."");
/*      */     }
/*      */     
/* 1011 */     return new String(output, 0, length);
/*      */   }
/*      */ 
/*      */   
/*      */   private static final int hexToInt(char c) throws ParseException {
/* 1016 */     if ('0' <= c && c <= '9')
/* 1017 */       return c - 48; 
/* 1018 */     if ('a' <= c && c <= 'f')
/* 1019 */       return c - 97 + 10; 
/* 1020 */     if ('A' <= c && c <= 'F') {
/* 1021 */       return c - 65 + 10;
/*      */     }
/* 1023 */     throw new ParseException(""None-hex character in unicode escape sequence: "" + c);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static String escape(String s) {
/* 1032 */     StringBuffer sb = new StringBuffer();
/* 1033 */     for (int i = 0; i < s.length(); i++) {
/* 1034 */       char c = s.charAt(i);
/*      */       
/* 1036 */       if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '""' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&')
/*      */       {
/*      */         
/* 1039 */         sb.append('\\');
/*      */       }
/* 1041 */       sb.append(c);
/*      */     } 
/* 1043 */     return sb.toString();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static void main(String[] args) throws Exception {
/* 1052 */     if (args.length == 0) {
/* 1053 */       System.out.println(""Usage: java org.apache.lucene.queryParser.QueryParser <input>"");
/* 1054 */       System.exit(0);
/*      */     } 
/* 1056 */     QueryParser qp = new QueryParser(""field"", (Analyzer)new SimpleAnalyzer());
/*      */     
/* 1058 */     Query q = qp.parse(args[0]);
/* 1059 */     System.out.println(q.toString(""field""));
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public final int Conjunction() throws ParseException {
/* 1065 */     int ret = 0;
/* 1066 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */     { case 8:
/*      */       case 9:
/* 1069 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */         { case 8:
/* 1071 */             jj_consume_token(8);
/* 1072 */             ret = 1;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */             
/* 1088 */             return ret;case 9: jj_consume_token(9); ret = 2; return ret; }  this.jj_la1[0] = this.jj_gen; jj_consume_token(-1); throw new ParseException(); }  this.jj_la1[1] = this.jj_gen; return ret;
/*      */   }
/*      */ 
/*      */   
/*      */   public final int Modifiers() throws ParseException {
/* 1093 */     int ret = 0;
/* 1094 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */     { case 10:
/*      */       case 11:
/*      */       case 12:
/* 1098 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */         { case 11:
/* 1100 */             jj_consume_token(11);
/* 1101 */             ret = 11;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */             
/* 1121 */             return ret;case 12: jj_consume_token(12); ret = 10; return ret;case 10: jj_consume_token(10); ret = 10; return ret; }  this.jj_la1[2] = this.jj_gen; jj_consume_token(-1); throw new ParseException(); }  this.jj_la1[3] = this.jj_gen; return ret;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final Query TopLevelQuery(String field) throws ParseException {
/* 1128 */     Query q = Query(field);
/* 1129 */     jj_consume_token(0);
/* 1130 */     return q;
/*      */   }
/*      */ 
/*      */   
/*      */   public final Query Query(String field) throws ParseException {
/* 1135 */     List clauses = new ArrayList();
/* 1136 */     Query firstQuery = null;
/*      */     
/* 1138 */     int mods = Modifiers();
/* 1139 */     Query q = Clause(field);
/* 1140 */     addClause(clauses, 0, mods, q);
/* 1141 */     if (mods == 0) {
/* 1142 */       firstQuery = q;
/*      */     }
/*      */     while (true) {
/* 1145 */       switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */         case 8:
/*      */         case 9:
/*      */         case 10:
/*      */         case 11:
/*      */         case 12:
/*      */         case 13:
/*      */         case 16:
/*      */         case 18:
/*      */         case 19:
/*      */         case 21:
/*      */         case 22:
/*      */         case 23:
/*      */         case 24:
/*      */         case 25:
/*      */           break;
/*      */         
/*      */         default:
/* 1163 */           this.jj_la1[4] = this.jj_gen;
/*      */           break;
/*      */       } 
/* 1166 */       int conj = Conjunction();
/* 1167 */       mods = Modifiers();
/* 1168 */       q = Clause(field);
/* 1169 */       addClause(clauses, conj, mods, q);
/*      */     } 
/* 1171 */     if (clauses.size() == 1 && firstQuery != null) {
/* 1172 */       return firstQuery;
/*      */     }
/* 1174 */     return getBooleanQuery(clauses);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public final Query Clause(String field) throws ParseException {
/*      */     Query q;
/* 1181 */     Token fieldToken = null, boost = null;
/* 1182 */     if (jj_2_1(2)) {
/* 1183 */       switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */         case 19:
/* 1185 */           fieldToken = jj_consume_token(19);
/* 1186 */           jj_consume_token(15);
/* 1187 */           field = discardEscapeChar(fieldToken.image);
/*      */           break;
/*      */         case 16:
/* 1190 */           jj_consume_token(16);
/* 1191 */           jj_consume_token(15);
/* 1192 */           field = ""*"";
/*      */           break;
/*      */         default:
/* 1195 */           this.jj_la1[5] = this.jj_gen;
/* 1196 */           jj_consume_token(-1);
/* 1197 */           throw new ParseException();
/*      */       } 
/*      */ 
/*      */     
/*      */     }
/* 1202 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */       case 16:
/*      */       case 18:
/*      */       case 19:
/*      */       case 21:
/*      */       case 22:
/*      */       case 23:
/*      */       case 24:
/*      */       case 25:
/* 1211 */         q = Term(field);
/*      */         break;
/*      */       case 13:
/* 1214 */         jj_consume_token(13);
/* 1215 */         q = Query(field);
/* 1216 */         jj_consume_token(14);
/* 1217 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 17:
/* 1219 */             jj_consume_token(17);
/* 1220 */             boost = jj_consume_token(25);
/*      */             break;
/*      */         } 
/* 1223 */         this.jj_la1[6] = this.jj_gen;
/*      */         break;
/*      */ 
/*      */       
/*      */       default:
/* 1228 */         this.jj_la1[7] = this.jj_gen;
/* 1229 */         jj_consume_token(-1);
/* 1230 */         throw new ParseException();
/*      */     } 
/* 1232 */     if (boost != null) {
/* 1233 */       float f = 1.0F;
/*      */       try {
/* 1235 */         f = Float.valueOf(boost.image).floatValue();
/* 1236 */         q.setBoost(f);
/* 1237 */       } catch (Exception ignored) {}
/*      */     } 
/* 1239 */     return q;
/*      */   } public final Query Term(String field) throws ParseException {
/*      */     int s;
/*      */     String termImage;
/*      */     Query q;
/* 1244 */     Token goop2, goop1, term, boost = null, fuzzySlop = null;
/* 1245 */     boolean prefix = false;
/* 1246 */     boolean wildcard = false;
/* 1247 */     boolean fuzzy = false;
/* 1248 */     boolean rangein = false;
/*      */     
/* 1250 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */       case 16:
/*      */       case 19:
/*      */       case 21:
/*      */       case 22:
/*      */       case 25:
/* 1256 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 19:
/* 1258 */             term = jj_consume_token(19);
/*      */             break;
/*      */           case 16:
/* 1261 */             term = jj_consume_token(16);
/* 1262 */             wildcard = true;
/*      */             break;
/*      */           case 21:
/* 1265 */             term = jj_consume_token(21);
/* 1266 */             prefix = true;
/*      */             break;
/*      */           case 22:
/* 1269 */             term = jj_consume_token(22);
/* 1270 */             wildcard = true;
/*      */             break;
/*      */           case 25:
/* 1273 */             term = jj_consume_token(25);
/*      */             break;
/*      */           default:
/* 1276 */             this.jj_la1[8] = this.jj_gen;
/* 1277 */             jj_consume_token(-1);
/* 1278 */             throw new ParseException();
/*      */         } 
/* 1280 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 20:
/* 1282 */             fuzzySlop = jj_consume_token(20);
/* 1283 */             fuzzy = true;
/*      */             break;
/*      */           default:
/* 1286 */             this.jj_la1[9] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1289 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 17:
/* 1291 */             jj_consume_token(17);
/* 1292 */             boost = jj_consume_token(25);
/* 1293 */             switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */               case 20:
/* 1295 */                 fuzzySlop = jj_consume_token(20);
/* 1296 */                 fuzzy = true;
/*      */                 break;
/*      */             } 
/* 1299 */             this.jj_la1[10] = this.jj_gen;
/*      */             break;
/*      */ 
/*      */           
/*      */           default:
/* 1304 */             this.jj_la1[11] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1307 */         termImage = discardEscapeChar(term.image);
/* 1308 */         if (wildcard) {
/* 1309 */           Query q = getWildcardQuery(field, termImage); break;
/* 1310 */         }  if (prefix) {
/* 1311 */           Query q = getPrefixQuery(field, discardEscapeChar(term.image.substring(0, term.image.length() - 1)));
/*      */           break;
/*      */         } 
/* 1314 */         if (fuzzy) {
/* 1315 */           float fms = this.fuzzyMinSim;
/*      */           try {
/* 1317 */             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
/* 1318 */           } catch (Exception ignored) {}
/* 1319 */           if (fms < 0.0F || fms > 1.0F) {
/* 1320 */             throw new ParseException(""Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !"");
/*      */           }
/* 1322 */           Query q = getFuzzyQuery(field, termImage, fms); break;
/*      */         } 
/* 1324 */         q = getFieldQuery(field, termImage);
/*      */         break;
/*      */       
/*      */       case 23:
/* 1328 */         jj_consume_token(23);
/* 1329 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 29:
/* 1331 */             goop1 = jj_consume_token(29);
/*      */             break;
/*      */           case 28:
/* 1334 */             goop1 = jj_consume_token(28);
/*      */             break;
/*      */           default:
/* 1337 */             this.jj_la1[12] = this.jj_gen;
/* 1338 */             jj_consume_token(-1);
/* 1339 */             throw new ParseException();
/*      */         } 
/* 1341 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 26:
/* 1343 */             jj_consume_token(26);
/*      */             break;
/*      */           default:
/* 1346 */             this.jj_la1[13] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1349 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 29:
/* 1351 */             goop2 = jj_consume_token(29);
/*      */             break;
/*      */           case 28:
/* 1354 */             goop2 = jj_consume_token(28);
/*      */             break;
/*      */           default:
/* 1357 */             this.jj_la1[14] = this.jj_gen;
/* 1358 */             jj_consume_token(-1);
/* 1359 */             throw new ParseException();
/*      */         } 
/* 1361 */         jj_consume_token(27);
/* 1362 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 17:
/* 1364 */             jj_consume_token(17);
/* 1365 */             boost = jj_consume_token(25);
/*      */             break;
/*      */           default:
/* 1368 */             this.jj_la1[15] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1371 */         if (goop1.kind == 28) {
/* 1372 */           goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
/*      */         }
/* 1374 */         if (goop2.kind == 28) {
/* 1375 */           goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
/*      */         }
/* 1377 */         q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true);
/*      */         break;
/*      */       case 24:
/* 1380 */         jj_consume_token(24);
/* 1381 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 33:
/* 1383 */             goop1 = jj_consume_token(33);
/*      */             break;
/*      */           case 32:
/* 1386 */             goop1 = jj_consume_token(32);
/*      */             break;
/*      */           default:
/* 1389 */             this.jj_la1[16] = this.jj_gen;
/* 1390 */             jj_consume_token(-1);
/* 1391 */             throw new ParseException();
/*      */         } 
/* 1393 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 30:
/* 1395 */             jj_consume_token(30);
/*      */             break;
/*      */           default:
/* 1398 */             this.jj_la1[17] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1401 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 33:
/* 1403 */             goop2 = jj_consume_token(33);
/*      */             break;
/*      */           case 32:
/* 1406 */             goop2 = jj_consume_token(32);
/*      */             break;
/*      */           default:
/* 1409 */             this.jj_la1[18] = this.jj_gen;
/* 1410 */             jj_consume_token(-1);
/* 1411 */             throw new ParseException();
/*      */         } 
/* 1413 */         jj_consume_token(31);
/* 1414 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 17:
/* 1416 */             jj_consume_token(17);
/* 1417 */             boost = jj_consume_token(25);
/*      */             break;
/*      */           default:
/* 1420 */             this.jj_la1[19] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1423 */         if (goop1.kind == 32) {
/* 1424 */           goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
/*      */         }
/* 1426 */         if (goop2.kind == 32) {
/* 1427 */           goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
/*      */         }
/*      */         
/* 1430 */         q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false);
/*      */         break;
/*      */       case 18:
/* 1433 */         term = jj_consume_token(18);
/* 1434 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 20:
/* 1436 */             fuzzySlop = jj_consume_token(20);
/*      */             break;
/*      */           default:
/* 1439 */             this.jj_la1[20] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1442 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 17:
/* 1444 */             jj_consume_token(17);
/* 1445 */             boost = jj_consume_token(25);
/*      */             break;
/*      */           default:
/* 1448 */             this.jj_la1[21] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1451 */         s = this.phraseSlop;
/*      */         
/* 1453 */         if (fuzzySlop != null) {
/*      */           try {
/* 1455 */             s = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
/*      */           }
/* 1457 */           catch (Exception ignored) {}
/*      */         }
/* 1459 */         q = getFieldQuery(field, discardEscapeChar(term.image.substring(1, term.image.length() - 1)), s);
/*      */         break;
/*      */       default:
/* 1462 */         this.jj_la1[22] = this.jj_gen;
/* 1463 */         jj_consume_token(-1);
/* 1464 */         throw new ParseException();
/*      */     } 
/* 1466 */     if (boost != null) {
/* 1467 */       float f = 1.0F;
/*      */       try {
/* 1469 */         f = Float.valueOf(boost.image).floatValue();
/*      */       }
/* 1471 */       catch (Exception ignored) {}
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 1478 */       if (q != null) {
/* 1479 */         q.setBoost(f);
/*      */       }
/*      */     } 
/* 1482 */     return q;
/*      */   }
/*      */ 
/*      */   
/*      */   private boolean jj_2_1(int xla) {
/* 1487 */     this.jj_la = xla; this.jj_lastpos = this.jj_scanpos = this.token; 
/* 1488 */     try { return !jj_3_1(); }
/* 1489 */     catch (LookaheadSuccess ls) { return true; }
/* 1490 */     finally { jj_save(0, xla); }
/*      */   
/*      */   }
/*      */   private boolean jj_3R_3() {
/* 1494 */     if (jj_scan_token(16)) return true; 
/* 1495 */     if (jj_scan_token(15)) return true; 
/* 1496 */     return false;
/*      */   }
/*      */   
/*      */   private boolean jj_3R_2() {
/* 1500 */     if (jj_scan_token(19)) return true; 
/* 1501 */     if (jj_scan_token(15)) return true; 
/* 1502 */     return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private boolean jj_3_1() {
/* 1507 */     Token xsp = this.jj_scanpos;
/* 1508 */     if (jj_3R_2()) {
/* 1509 */       this.jj_scanpos = xsp;
/* 1510 */       if (jj_3R_3()) return true; 
/*      */     } 
/* 1512 */     return false;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 1525 */   private final int[] jj_la1 = new int[23]; private static int[] jj_la1_0;
/*      */   private static int[] jj_la1_1;
/*      */   
/*      */   static  {
/* 1529 */     jj_la1_init_0();
/* 1530 */     jj_la1_init_1();
/*      */   }
/*      */   
/* 1533 */   private static void jj_la1_init_0() { jj_la1_0 = new int[] { 768, 768, 7168, 7168, 65879808, 589824, 131072, 65871872, 40435712, 1048576, 1048576, 131072, 805306368, 67108864, 805306368, 131072, 0, 1073741824, 0, 131072, 1048576, 131072, 65863680 }; }
/*      */ 
/*      */   
/* 1536 */   private static void jj_la1_init_1() { jj_la1_1 = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0 }; }
/*      */   
/* 1538 */   private final JJCalls[] jj_2_rtns = new JJCalls[1];
/*      */   private boolean jj_rescan = false;
/* 1540 */   private int jj_gc = 0;
/*      */   
/*      */   private final LookaheadSuccess jj_ls;
/*      */   
/*      */   private List jj_expentries;
/*      */   
/*      */   private int[] jj_expentry;
/*      */   
/*      */   private int jj_kind;
/*      */   
/*      */   private int[] jj_lasttokens;
/*      */   private int jj_endpos;
/*      */   
/*      */   public void ReInit(CharStream stream) {
/* 1554 */     this.token_source.ReInit(stream);
/* 1555 */     this.token = new Token();
/* 1556 */     this.jj_ntk = -1;
/* 1557 */     this.jj_gen = 0;
/* 1558 */     for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }
/* 1559 */      for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }
/*      */   
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void ReInit(QueryParserTokenManager tm) {
/* 1574 */     this.token_source = tm;
/* 1575 */     this.token = new Token();
/* 1576 */     this.jj_ntk = -1;
/* 1577 */     this.jj_gen = 0;
/* 1578 */     for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }
/* 1579 */      for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }
/*      */   
/*      */   }
/*      */   private Token jj_consume_token(int kind) throws ParseException {
/*      */     Token oldToken;
/* 1584 */     if ((oldToken = this.token).next != null) { this.token = this.token.next; }
/* 1585 */     else { this.token = this.token.next = this.token_source.getNextToken(); }
/* 1586 */      this.jj_ntk = -1;
/* 1587 */     if (this.token.kind == kind) {
/* 1588 */       this.jj_gen++;
/* 1589 */       if (++this.jj_gc > 100) {
/* 1590 */         this.jj_gc = 0;
/* 1591 */         for (int i = 0; i < this.jj_2_rtns.length; i++) {
/* 1592 */           JJCalls c = this.jj_2_rtns[i];
/* 1593 */           while (c != null) {
/* 1594 */             if (c.gen < this.jj_gen) c.first = null; 
/* 1595 */             c = c.next;
/*      */           } 
/*      */         } 
/*      */       } 
/* 1599 */       return this.token;
/*      */     } 
/* 1601 */     this.token = oldToken;
/* 1602 */     this.jj_kind = kind;
/* 1603 */     throw generateParseException();
/*      */   }
/*      */   private static final class LookaheadSuccess extends Error {
/*      */     private LookaheadSuccess() {} }
/* 1607 */   public QueryParser(CharStream stream) { this.jj_ls = new LookaheadSuccess();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1656 */     this.jj_expentries = new ArrayList();
/*      */     
/* 1658 */     this.jj_kind = -1;
/* 1659 */     this.jj_lasttokens = new int[100]; this.token_source = new QueryParserTokenManager(stream); this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }  for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }  } public QueryParser(QueryParserTokenManager tm) { this.jj_ls = new LookaheadSuccess(); this.jj_expentries = new ArrayList(); this.jj_kind = -1; this.jj_lasttokens = new int[100]; this.token_source = tm; this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }  for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }  }
/*      */   private boolean jj_scan_token(int kind) { if (this.jj_scanpos == this.jj_lastpos) { this.jj_la--; if (this.jj_scanpos.next == null) { this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next = this.token_source.getNextToken(); } else { this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next; }  } else { this.jj_scanpos = this.jj_scanpos.next; }  if (this.jj_rescan) { int i = 0; Token tok = this.token; while (tok != null && tok != this.jj_scanpos) { i++; tok = tok.next; }  if (tok != null)
/*      */         jj_add_error_token(kind, i);  }  if (this.jj_scanpos.kind != kind)
/*      */       return true;  if (this.jj_la == 0 && this.jj_scanpos == this.jj_lastpos)
/* 1663 */       throw this.jj_ls;  return false; } private void jj_add_error_token(int kind, int pos) { if (pos >= 100)
/* 1664 */       return;  if (pos == this.jj_endpos + 1)
/* 1665 */     { this.jj_lasttokens[this.jj_endpos++] = kind; }
/* 1666 */     else if (this.jj_endpos != 0)
/* 1667 */     { this.jj_expentry = new int[this.jj_endpos];
/* 1668 */       for (int i = 0; i < this.jj_endpos; i++)
/* 1669 */         this.jj_expentry[i] = this.jj_lasttokens[i]; 
/*      */       Iterator it;
/* 1671 */       label31: for (it = this.jj_expentries.iterator(); it.hasNext(); ) {
/* 1672 */         int[] oldentry = it.next();
/* 1673 */         if (oldentry.length == this.jj_expentry.length) {
/* 1674 */           for (int i = 0; i < this.jj_expentry.length; i++) {
/* 1675 */             if (oldentry[i] != this.jj_expentry[i]) {
/*      */               continue label31;
/*      */             }
/*      */           } 
/* 1679 */           this.jj_expentries.add(this.jj_expentry);
/*      */           break;
/*      */         } 
/*      */       } 
/* 1683 */       if (pos != 0) this.jj_lasttokens[(this.jj_endpos = pos) - 1] = kind;  }  }
/*      */   public final Token getNextToken() { if (this.token.next != null) { this.token = this.token.next; } else { this.token = this.token.next = this.token_source.getNextToken(); }  this.jj_ntk = -1; this.jj_gen++; return this.token; }
/*      */   public final Token getToken(int index) { Token t = this.token; for (int i = 0; i < index; i++) { if (t.next != null) { t = t.next; } else { t = t.next = this.token_source.getNextToken(); }
/*      */        }
/*      */      return t; }
/*      */   private int jj_ntk() { if ((this.jj_nt = this.token.next) == null)
/* 1689 */       return this.jj_ntk = (this.token.next = this.token_source.getNextToken()).kind;  return this.jj_ntk = this.jj_nt.kind; } public ParseException generateParseException() { this.jj_expentries.clear();
/* 1690 */     boolean[] la1tokens = new boolean[34];
/* 1691 */     if (this.jj_kind >= 0) {
/* 1692 */       la1tokens[this.jj_kind] = true;
/* 1693 */       this.jj_kind = -1;
/*      */     } 
/* 1695 */     for (int i = 0; i < 23; i++) {
/* 1696 */       if (this.jj_la1[i] == this.jj_gen) {
/* 1697 */         for (int j = 0; j < 32; j++) {
/* 1698 */           if ((jj_la1_0[i] & 1 << j) != 0) {
/* 1699 */             la1tokens[j] = true;
/*      */           }
/* 1701 */           if ((jj_la1_1[i] & 1 << j) != 0) {
/* 1702 */             la1tokens[32 + j] = true;
/*      */           }
/*      */         } 
/*      */       }
/*      */     } 
/* 1707 */     for (int i = 0; i < 34; i++) {
/* 1708 */       if (la1tokens[i]) {
/* 1709 */         this.jj_expentry = new int[1];
/* 1710 */         this.jj_expentry[0] = i;
/* 1711 */         this.jj_expentries.add(this.jj_expentry);
/*      */       } 
/*      */     } 
/* 1714 */     this.jj_endpos = 0;
/* 1715 */     jj_rescan_token();
/* 1716 */     jj_add_error_token(0, 0);
/* 1717 */     int[][] exptokseq = new int[this.jj_expentries.size()][];
/* 1718 */     for (int i = 0; i < this.jj_expentries.size(); i++) {
/* 1719 */       exptokseq[i] = this.jj_expentries.get(i);
/*      */     }
/* 1721 */     return new ParseException(this.token, exptokseq, tokenImage); }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final void enable_tracing() {}
/*      */ 
/*      */   
/*      */   public final void disable_tracing() {}
/*      */ 
/*      */   
/*      */   private void jj_rescan_token() {
/* 1733 */     this.jj_rescan = true;
/* 1734 */     for (int i = 0; i < 1; i++) {
/*      */       try {
/* 1736 */         JJCalls p = this.jj_2_rtns[i];
/*      */         do {
/* 1738 */           if (p.gen > this.jj_gen) {
/* 1739 */             this.jj_la = p.arg; this.jj_lastpos = this.jj_scanpos = p.first;
/* 1740 */             switch (i) { case 0:
/* 1741 */                 jj_3_1(); break; }
/*      */           
/*      */           } 
/* 1744 */           p = p.next;
/* 1745 */         } while (p != null);
/* 1746 */       } catch (LookaheadSuccess ls) {}
/*      */     } 
/* 1748 */     this.jj_rescan = false;
/*      */   }
/*      */   
/*      */   private void jj_save(int index, int xla) {
/* 1752 */     JJCalls p = this.jj_2_rtns[index];
/* 1753 */     while (p.gen > this.jj_gen) {
/* 1754 */       if (p.next == null) { p = p.next = new JJCalls(); break; }
/* 1755 */        p = p.next;
/*      */     } 
/* 1757 */     p.gen = this.jj_gen + xla - this.jj_la; p.first = this.token; p.arg = xla;
/*      */   }
/*      */   
/*      */   static final class JJCalls {
/*      */     int gen;
/*      */     Token first;
/*      */     int arg;
/*      */     JJCalls next;
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\QueryParser.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParserConstants,"/*    */ package org.apache.lucene.queryParser;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface QueryParserConstants
/*    */ {
/*    */   public static final int EOF = 0;
/*    */   public static final int _NUM_CHAR = 1;
/*    */   public static final int _ESCAPED_CHAR = 2;
/*    */   public static final int _TERM_START_CHAR = 3;
/*    */   public static final int _TERM_CHAR = 4;
/*    */   public static final int _WHITESPACE = 5;
/*    */   public static final int _QUOTED_CHAR = 6;
/*    */   public static final int AND = 8;
/*    */   public static final int OR = 9;
/*    */   public static final int NOT = 10;
/*    */   public static final int PLUS = 11;
/*    */   public static final int MINUS = 12;
/*    */   public static final int LPAREN = 13;
/*    */   public static final int RPAREN = 14;
/*    */   public static final int COLON = 15;
/*    */   public static final int STAR = 16;
/*    */   public static final int CARAT = 17;
/*    */   public static final int QUOTED = 18;
/*    */   public static final int TERM = 19;
/*    */   public static final int FUZZY_SLOP = 20;
/*    */   public static final int PREFIXTERM = 21;
/*    */   public static final int WILDTERM = 22;
/*    */   public static final int RANGEIN_START = 23;
/*    */   public static final int RANGEEX_START = 24;
/*    */   public static final int NUMBER = 25;
/*    */   public static final int RANGEIN_TO = 26;
/*    */   public static final int RANGEIN_END = 27;
/*    */   public static final int RANGEIN_QUOTED = 28;
/*    */   public static final int RANGEIN_GOOP = 29;
/*    */   public static final int RANGEEX_TO = 30;
/*    */   public static final int RANGEEX_END = 31;
/*    */   public static final int RANGEEX_QUOTED = 32;
/*    */   public static final int RANGEEX_GOOP = 33;
/*    */   public static final int Boost = 0;
/*    */   public static final int RangeEx = 1;
/*    */   public static final int RangeIn = 2;
/*    */   public static final int DEFAULT = 3;
/* 88 */   public static final String[] tokenImage = new String[] { ""<EOF>"", ""<_NUM_CHAR>"", ""<_ESCAPED_CHAR>"", ""<_TERM_START_CHAR>"", ""<_TERM_CHAR>"", ""<_WHITESPACE>"", ""<_QUOTED_CHAR>"", ""<token of kind 7>"", ""<AND>"", ""<OR>"", ""<NOT>"", ""\""+\"""", ""\""-\"""", ""\""(\"""", ""\"")\"""", ""\"":\"""", ""\""*\"""", ""\""^\"""", ""<QUOTED>"", ""<TERM>"", ""<FUZZY_SLOP>"", ""<PREFIXTERM>"", ""<WILDTERM>"", ""\""[\"""", ""\""{\"""", ""<NUMBER>"", ""\""TO\"""", ""\""]\"""", ""<RANGEIN_QUOTED>"", ""<RANGEIN_GOOP>"", ""\""TO\"""", ""\""}\"""", ""<RANGEEX_QUOTED>"", ""<RANGEEX_GOOP>"" };
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\QueryParserConstants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParserTokenManager,"/*      */ package org.apache.lucene.queryParser;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class QueryParserTokenManager
/*      */   implements QueryParserConstants
/*      */ {
/*   39 */   public PrintStream debugStream = System.out;
/*      */   
/*   41 */   public void setDebugStream(PrintStream ds) { this.debugStream = ds; }
/*      */   
/*      */   private final int jjStopStringLiteralDfa_3(int pos, long active0) {
/*   44 */     switch (pos) {
/*      */     
/*      */     } 
/*   47 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*   52 */   private final int jjStartNfa_3(int pos, long active0) { return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private int jjStopAtPos(int pos, int kind) {
/*   56 */     this.jjmatchedKind = kind;
/*   57 */     this.jjmatchedPos = pos;
/*   58 */     return pos + 1;
/*      */   }
/*      */   
/*      */   private int jjMoveStringLiteralDfa0_3() {
/*   62 */     switch (this.curChar) {
/*      */       
/*      */       case '(':
/*   65 */         return jjStopAtPos(0, 13);
/*      */       case ')':
/*   67 */         return jjStopAtPos(0, 14);
/*      */       case '*':
/*   69 */         return jjStartNfaWithStates_3(0, 16, 36);
/*      */       case '+':
/*   71 */         return jjStopAtPos(0, 11);
/*      */       case '-':
/*   73 */         return jjStopAtPos(0, 12);
/*      */       case ':':
/*   75 */         return jjStopAtPos(0, 15);
/*      */       case '[':
/*   77 */         return jjStopAtPos(0, 23);
/*      */       case '^':
/*   79 */         return jjStopAtPos(0, 17);
/*      */       case '{':
/*   81 */         return jjStopAtPos(0, 24);
/*      */     } 
/*   83 */     return jjMoveNfa_3(0, 0);
/*      */   }
/*      */ 
/*      */   
/*      */   private int jjStartNfaWithStates_3(int pos, int kind, int state) {
/*   88 */     this.jjmatchedKind = kind;
/*   89 */     this.jjmatchedPos = pos; 
/*   90 */     try { this.curChar = this.input_stream.readChar(); }
/*   91 */     catch (IOException e) { return pos + 1; }
/*   92 */      return jjMoveNfa_3(state, pos + 1);
/*      */   }
/*   94 */   static final long[] jjbitVec0 = new long[] { -2L, -1L, -1L, -1L };
/*      */ 
/*      */   
/*   97 */   static final long[] jjbitVec2 = new long[] { 0L, 0L, -1L, -1L };
/*      */ 
/*      */ 
/*      */   
/*      */   private int jjMoveNfa_3(int startState, int curPos) {
/*  102 */     int startsAt = 0;
/*  103 */     this.jjnewStateCnt = 36;
/*  104 */     int i = 1;
/*  105 */     this.jjstateSet[0] = startState;
/*  106 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  109 */       if (++this.jjround == Integer.MAX_VALUE)
/*  110 */         ReInitRounds(); 
/*  111 */       if (this.curChar < '@') {
/*      */         
/*  113 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  116 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 25:
/*      */             case 36:
/*  120 */               if ((0xFBFFFCF8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  122 */               if (kind > 22)
/*  123 */                 kind = 22; 
/*  124 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 0:
/*  127 */               if ((0xFBFFD4F8FFFFD9FFL & l) != 0L) {
/*      */                 
/*  129 */                 if (kind > 22)
/*  130 */                   kind = 22; 
/*  131 */                 jjCheckNAddTwoStates(25, 26);
/*      */               }
/*  133 */               else if ((0x100002600L & l) != 0L) {
/*      */                 
/*  135 */                 if (kind > 7) {
/*  136 */                   kind = 7;
/*      */                 }
/*  138 */               } else if (this.curChar == '""') {
/*  139 */                 jjCheckNAddStates(0, 2);
/*  140 */               } else if (this.curChar == '!') {
/*      */                 
/*  142 */                 if (kind > 10)
/*  143 */                   kind = 10; 
/*      */               } 
/*  145 */               if ((0x7BFFD0F8FFFFD9FFL & l) != 0L) {
/*      */                 
/*  147 */                 if (kind > 19)
/*  148 */                   kind = 19; 
/*  149 */                 jjCheckNAddStates(3, 7);
/*      */               }
/*  151 */               else if (this.curChar == '*') {
/*      */                 
/*  153 */                 if (kind > 21)
/*  154 */                   kind = 21; 
/*      */               } 
/*  156 */               if (this.curChar == '&')
/*  157 */                 this.jjstateSet[this.jjnewStateCnt++] = 4; 
/*      */               break;
/*      */             case 4:
/*  160 */               if (this.curChar == '&' && kind > 8)
/*  161 */                 kind = 8; 
/*      */               break;
/*      */             case 5:
/*  164 */               if (this.curChar == '&')
/*  165 */                 this.jjstateSet[this.jjnewStateCnt++] = 4; 
/*      */               break;
/*      */             case 13:
/*  168 */               if (this.curChar == '!' && kind > 10)
/*  169 */                 kind = 10; 
/*      */               break;
/*      */             case 14:
/*  172 */               if (this.curChar == '""')
/*  173 */                 jjCheckNAddStates(0, 2); 
/*      */               break;
/*      */             case 15:
/*  176 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  177 */                 jjCheckNAddStates(0, 2); 
/*      */               break;
/*      */             case 17:
/*  180 */               jjCheckNAddStates(0, 2);
/*      */               break;
/*      */             case 18:
/*  183 */               if (this.curChar == '""' && kind > 18)
/*  184 */                 kind = 18; 
/*      */               break;
/*      */             case 20:
/*  187 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  189 */               if (kind > 20)
/*  190 */                 kind = 20; 
/*  191 */               jjAddStates(8, 9);
/*      */               break;
/*      */             case 21:
/*  194 */               if (this.curChar == '.')
/*  195 */                 jjCheckNAdd(22); 
/*      */               break;
/*      */             case 22:
/*  198 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  200 */               if (kind > 20)
/*  201 */                 kind = 20; 
/*  202 */               jjCheckNAdd(22);
/*      */               break;
/*      */             case 23:
/*  205 */               if (this.curChar == '*' && kind > 21)
/*  206 */                 kind = 21; 
/*      */               break;
/*      */             case 24:
/*  209 */               if ((0xFBFFD4F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  211 */               if (kind > 22)
/*  212 */                 kind = 22; 
/*  213 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 27:
/*  216 */               if (kind > 22)
/*  217 */                 kind = 22; 
/*  218 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 28:
/*  221 */               if ((0x7BFFD0F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  223 */               if (kind > 19)
/*  224 */                 kind = 19; 
/*  225 */               jjCheckNAddStates(3, 7);
/*      */               break;
/*      */             case 29:
/*  228 */               if ((0x7BFFF8F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  230 */               if (kind > 19)
/*  231 */                 kind = 19; 
/*  232 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 31:
/*  235 */               if (kind > 19)
/*  236 */                 kind = 19; 
/*  237 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 32:
/*  240 */               if ((0x7BFFF8F8FFFFD9FFL & l) != 0L)
/*  241 */                 jjCheckNAddStates(10, 12); 
/*      */               break;
/*      */             case 34:
/*  244 */               jjCheckNAddStates(10, 12);
/*      */               break;
/*      */           } 
/*      */         
/*  248 */         } while (i != startsAt);
/*      */       }
/*  250 */       else if (this.curChar < '') {
/*      */         
/*  252 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  255 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 36:
/*  258 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L) {
/*      */                 
/*  260 */                 if (kind > 22)
/*  261 */                   kind = 22; 
/*  262 */                 jjCheckNAddTwoStates(25, 26); break;
/*      */               } 
/*  264 */               if (this.curChar == '\\')
/*  265 */                 jjCheckNAddTwoStates(27, 27); 
/*      */               break;
/*      */             case 0:
/*  268 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L) {
/*      */                 
/*  270 */                 if (kind > 19)
/*  271 */                   kind = 19; 
/*  272 */                 jjCheckNAddStates(3, 7);
/*      */               }
/*  274 */               else if (this.curChar == '\\') {
/*  275 */                 jjCheckNAddStates(13, 15);
/*  276 */               } else if (this.curChar == '~') {
/*      */                 
/*  278 */                 if (kind > 20)
/*  279 */                   kind = 20; 
/*  280 */                 this.jjstateSet[this.jjnewStateCnt++] = 20;
/*      */               } 
/*  282 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L) {
/*      */                 
/*  284 */                 if (kind > 22)
/*  285 */                   kind = 22; 
/*  286 */                 jjCheckNAddTwoStates(25, 26);
/*      */               } 
/*  288 */               if (this.curChar == 'N') {
/*  289 */                 this.jjstateSet[this.jjnewStateCnt++] = 11; break;
/*  290 */               }  if (this.curChar == '|') {
/*  291 */                 this.jjstateSet[this.jjnewStateCnt++] = 8; break;
/*  292 */               }  if (this.curChar == 'O') {
/*  293 */                 this.jjstateSet[this.jjnewStateCnt++] = 6; break;
/*  294 */               }  if (this.curChar == 'A')
/*  295 */                 this.jjstateSet[this.jjnewStateCnt++] = 2; 
/*      */               break;
/*      */             case 1:
/*  298 */               if (this.curChar == 'D' && kind > 8)
/*  299 */                 kind = 8; 
/*      */               break;
/*      */             case 2:
/*  302 */               if (this.curChar == 'N')
/*  303 */                 this.jjstateSet[this.jjnewStateCnt++] = 1; 
/*      */               break;
/*      */             case 3:
/*  306 */               if (this.curChar == 'A')
/*  307 */                 this.jjstateSet[this.jjnewStateCnt++] = 2; 
/*      */               break;
/*      */             case 6:
/*  310 */               if (this.curChar == 'R' && kind > 9)
/*  311 */                 kind = 9; 
/*      */               break;
/*      */             case 7:
/*  314 */               if (this.curChar == 'O')
/*  315 */                 this.jjstateSet[this.jjnewStateCnt++] = 6; 
/*      */               break;
/*      */             case 8:
/*  318 */               if (this.curChar == '|' && kind > 9)
/*  319 */                 kind = 9; 
/*      */               break;
/*      */             case 9:
/*  322 */               if (this.curChar == '|')
/*  323 */                 this.jjstateSet[this.jjnewStateCnt++] = 8; 
/*      */               break;
/*      */             case 10:
/*  326 */               if (this.curChar == 'T' && kind > 10)
/*  327 */                 kind = 10; 
/*      */               break;
/*      */             case 11:
/*  330 */               if (this.curChar == 'O')
/*  331 */                 this.jjstateSet[this.jjnewStateCnt++] = 10; 
/*      */               break;
/*      */             case 12:
/*  334 */               if (this.curChar == 'N')
/*  335 */                 this.jjstateSet[this.jjnewStateCnt++] = 11; 
/*      */               break;
/*      */             case 15:
/*  338 */               if ((0xFFFFFFFFEFFFFFFFL & l) != 0L)
/*  339 */                 jjCheckNAddStates(0, 2); 
/*      */               break;
/*      */             case 16:
/*  342 */               if (this.curChar == '\\')
/*  343 */                 this.jjstateSet[this.jjnewStateCnt++] = 17; 
/*      */               break;
/*      */             case 17:
/*  346 */               jjCheckNAddStates(0, 2);
/*      */               break;
/*      */             case 19:
/*  349 */               if (this.curChar != '~')
/*      */                 break; 
/*  351 */               if (kind > 20)
/*  352 */                 kind = 20; 
/*  353 */               this.jjstateSet[this.jjnewStateCnt++] = 20;
/*      */               break;
/*      */             case 24:
/*  356 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  358 */               if (kind > 22)
/*  359 */                 kind = 22; 
/*  360 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 25:
/*  363 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  365 */               if (kind > 22)
/*  366 */                 kind = 22; 
/*  367 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 26:
/*  370 */               if (this.curChar == '\\')
/*  371 */                 jjCheckNAddTwoStates(27, 27); 
/*      */               break;
/*      */             case 27:
/*  374 */               if (kind > 22)
/*  375 */                 kind = 22; 
/*  376 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 28:
/*  379 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  381 */               if (kind > 19)
/*  382 */                 kind = 19; 
/*  383 */               jjCheckNAddStates(3, 7);
/*      */               break;
/*      */             case 29:
/*  386 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  388 */               if (kind > 19)
/*  389 */                 kind = 19; 
/*  390 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 30:
/*  393 */               if (this.curChar == '\\')
/*  394 */                 jjCheckNAddTwoStates(31, 31); 
/*      */               break;
/*      */             case 31:
/*  397 */               if (kind > 19)
/*  398 */                 kind = 19; 
/*  399 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 32:
/*  402 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L)
/*  403 */                 jjCheckNAddStates(10, 12); 
/*      */               break;
/*      */             case 33:
/*  406 */               if (this.curChar == '\\')
/*  407 */                 jjCheckNAddTwoStates(34, 34); 
/*      */               break;
/*      */             case 34:
/*  410 */               jjCheckNAddStates(10, 12);
/*      */               break;
/*      */             case 35:
/*  413 */               if (this.curChar == '\\') {
/*  414 */                 jjCheckNAddStates(13, 15);
/*      */               }
/*      */               break;
/*      */           } 
/*  418 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  422 */         int hiByte = this.curChar >> 8;
/*  423 */         int i1 = hiByte >> 6;
/*  424 */         long l1 = 1L << (hiByte & 0x3F);
/*  425 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  426 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  429 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 25:
/*      */             case 27:
/*      */             case 36:
/*  434 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  436 */               if (kind > 22)
/*  437 */                 kind = 22; 
/*  438 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 0:
/*  441 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*      */                 
/*  443 */                 if (kind > 22)
/*  444 */                   kind = 22; 
/*  445 */                 jjCheckNAddTwoStates(25, 26);
/*      */               } 
/*  447 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*      */                 
/*  449 */                 if (kind > 19)
/*  450 */                   kind = 19; 
/*  451 */                 jjCheckNAddStates(3, 7);
/*      */               } 
/*      */               break;
/*      */             case 15:
/*      */             case 17:
/*  456 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2))
/*  457 */                 jjCheckNAddStates(0, 2); 
/*      */               break;
/*      */             case 24:
/*  460 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  462 */               if (kind > 22)
/*  463 */                 kind = 22; 
/*  464 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 28:
/*  467 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  469 */               if (kind > 19)
/*  470 */                 kind = 19; 
/*  471 */               jjCheckNAddStates(3, 7);
/*      */               break;
/*      */             case 29:
/*      */             case 31:
/*  475 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  477 */               if (kind > 19)
/*  478 */                 kind = 19; 
/*  479 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 32:
/*      */             case 34:
/*  483 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  484 */                 jjCheckNAddStates(10, 12);
/*      */               }
/*      */               break;
/*      */           } 
/*  488 */         } while (i != startsAt);
/*      */       } 
/*  490 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  492 */         this.jjmatchedKind = kind;
/*  493 */         this.jjmatchedPos = curPos;
/*  494 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  496 */       curPos++;
/*  497 */       if ((i = this.jjnewStateCnt) == (startsAt = 36 - (this.jjnewStateCnt = startsAt)))
/*  498 */         return curPos;  
/*  499 */       try { this.curChar = this.input_stream.readChar(); }
/*  500 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   private final int jjStopStringLiteralDfa_1(int pos, long active0) {
/*  505 */     switch (pos) {
/*      */       
/*      */       case 0:
/*  508 */         if ((active0 & 0x40000000L) != 0L) {
/*      */           
/*  510 */           this.jjmatchedKind = 33;
/*  511 */           return 6;
/*      */         } 
/*  513 */         return -1;
/*      */     } 
/*  515 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  520 */   private final int jjStartNfa_1(int pos, long active0) { return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private int jjMoveStringLiteralDfa0_1() {
/*  524 */     switch (this.curChar) {
/*      */       
/*      */       case 'T':
/*  527 */         return jjMoveStringLiteralDfa1_1(1073741824L);
/*      */       case '}':
/*  529 */         return jjStopAtPos(0, 31);
/*      */     } 
/*  531 */     return jjMoveNfa_1(0, 0);
/*      */   }
/*      */   
/*      */   private int jjMoveStringLiteralDfa1_1(long active0) {
/*      */     try {
/*  536 */       this.curChar = this.input_stream.readChar();
/*  537 */     } catch (IOException e) {
/*  538 */       jjStopStringLiteralDfa_1(0, active0);
/*  539 */       return 1;
/*      */     } 
/*  541 */     switch (this.curChar) {
/*      */       
/*      */       case 'O':
/*  544 */         if ((active0 & 0x40000000L) != 0L) {
/*  545 */           return jjStartNfaWithStates_1(1, 30, 6);
/*      */         }
/*      */         break;
/*      */     } 
/*      */     
/*  550 */     return jjStartNfa_1(0, active0);
/*      */   }
/*      */   
/*      */   private int jjStartNfaWithStates_1(int pos, int kind, int state) {
/*  554 */     this.jjmatchedKind = kind;
/*  555 */     this.jjmatchedPos = pos; 
/*  556 */     try { this.curChar = this.input_stream.readChar(); }
/*  557 */     catch (IOException e) { return pos + 1; }
/*  558 */      return jjMoveNfa_1(state, pos + 1);
/*      */   }
/*      */   
/*      */   private int jjMoveNfa_1(int startState, int curPos) {
/*  562 */     int startsAt = 0;
/*  563 */     this.jjnewStateCnt = 7;
/*  564 */     int i = 1;
/*  565 */     this.jjstateSet[0] = startState;
/*  566 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  569 */       if (++this.jjround == Integer.MAX_VALUE)
/*  570 */         ReInitRounds(); 
/*  571 */       if (this.curChar < '@') {
/*      */         
/*  573 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  576 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  579 */               if ((0xFFFFFFFEFFFFFFFFL & l) != 0L) {
/*      */                 
/*  581 */                 if (kind > 33)
/*  582 */                   kind = 33; 
/*  583 */                 jjCheckNAdd(6);
/*      */               } 
/*  585 */               if ((0x100002600L & l) != 0L) {
/*      */                 
/*  587 */                 if (kind > 7)
/*  588 */                   kind = 7;  break;
/*      */               } 
/*  590 */               if (this.curChar == '""')
/*  591 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 1:
/*  594 */               if (this.curChar == '""')
/*  595 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 2:
/*  598 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  599 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 3:
/*  602 */               if (this.curChar == '""')
/*  603 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 5:
/*  606 */               if (this.curChar == '""' && kind > 32)
/*  607 */                 kind = 32; 
/*      */               break;
/*      */             case 6:
/*  610 */               if ((0xFFFFFFFEFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  612 */               if (kind > 33)
/*  613 */                 kind = 33; 
/*  614 */               jjCheckNAdd(6);
/*      */               break;
/*      */           } 
/*      */         
/*  618 */         } while (i != startsAt);
/*      */       }
/*  620 */       else if (this.curChar < '') {
/*      */         
/*  622 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  625 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  629 */               if ((0xDFFFFFFFFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  631 */               if (kind > 33)
/*  632 */                 kind = 33; 
/*  633 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  636 */               jjAddStates(16, 18);
/*      */               break;
/*      */             case 4:
/*  639 */               if (this.curChar == '\\') {
/*  640 */                 this.jjstateSet[this.jjnewStateCnt++] = 3;
/*      */               }
/*      */               break;
/*      */           } 
/*  644 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  648 */         int hiByte = this.curChar >> 8;
/*  649 */         int i1 = hiByte >> 6;
/*  650 */         long l1 = 1L << (hiByte & 0x3F);
/*  651 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  652 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  655 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  659 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  661 */               if (kind > 33)
/*  662 */                 kind = 33; 
/*  663 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  666 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  667 */                 jjAddStates(16, 18);
/*      */               }
/*      */               break;
/*      */           } 
/*  671 */         } while (i != startsAt);
/*      */       } 
/*  673 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  675 */         this.jjmatchedKind = kind;
/*  676 */         this.jjmatchedPos = curPos;
/*  677 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  679 */       curPos++;
/*  680 */       if ((i = this.jjnewStateCnt) == (startsAt = 7 - (this.jjnewStateCnt = startsAt)))
/*  681 */         return curPos;  
/*  682 */       try { this.curChar = this.input_stream.readChar(); }
/*  683 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   
/*  688 */   private int jjMoveStringLiteralDfa0_0() { return jjMoveNfa_0(0, 0); }
/*      */ 
/*      */   
/*      */   private int jjMoveNfa_0(int startState, int curPos) {
/*  692 */     int startsAt = 0;
/*  693 */     this.jjnewStateCnt = 3;
/*  694 */     int i = 1;
/*  695 */     this.jjstateSet[0] = startState;
/*  696 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  699 */       if (++this.jjround == Integer.MAX_VALUE)
/*  700 */         ReInitRounds(); 
/*  701 */       if (this.curChar < '@') {
/*      */         
/*  703 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  706 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  709 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  711 */               if (kind > 25)
/*  712 */                 kind = 25; 
/*  713 */               jjAddStates(19, 20);
/*      */               break;
/*      */             case 1:
/*  716 */               if (this.curChar == '.')
/*  717 */                 jjCheckNAdd(2); 
/*      */               break;
/*      */             case 2:
/*  720 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  722 */               if (kind > 25)
/*  723 */                 kind = 25; 
/*  724 */               jjCheckNAdd(2);
/*      */               break;
/*      */           } 
/*      */         
/*  728 */         } while (i != startsAt);
/*      */       }
/*  730 */       else if (this.curChar < '') {
/*      */         
/*  732 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  735 */           switch (this.jjstateSet[--i]) {
/*      */           
/*      */           } 
/*      */         
/*  739 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  743 */         int hiByte = this.curChar >> 8;
/*  744 */         int i1 = hiByte >> 6;
/*  745 */         long l1 = 1L << (hiByte & 0x3F);
/*  746 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  747 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  750 */           switch (this.jjstateSet[--i]) {
/*      */           
/*      */           } 
/*      */         
/*  754 */         } while (i != startsAt);
/*      */       } 
/*  756 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  758 */         this.jjmatchedKind = kind;
/*  759 */         this.jjmatchedPos = curPos;
/*  760 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  762 */       curPos++;
/*  763 */       if ((i = this.jjnewStateCnt) == (startsAt = 3 - (this.jjnewStateCnt = startsAt)))
/*  764 */         return curPos;  
/*  765 */       try { this.curChar = this.input_stream.readChar(); }
/*  766 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   private final int jjStopStringLiteralDfa_2(int pos, long active0) {
/*  771 */     switch (pos) {
/*      */       
/*      */       case 0:
/*  774 */         if ((active0 & 0x4000000L) != 0L) {
/*      */           
/*  776 */           this.jjmatchedKind = 29;
/*  777 */           return 6;
/*      */         } 
/*  779 */         return -1;
/*      */     } 
/*  781 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  786 */   private final int jjStartNfa_2(int pos, long active0) { return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private int jjMoveStringLiteralDfa0_2() {
/*  790 */     switch (this.curChar) {
/*      */       
/*      */       case 'T':
/*  793 */         return jjMoveStringLiteralDfa1_2(67108864L);
/*      */       case ']':
/*  795 */         return jjStopAtPos(0, 27);
/*      */     } 
/*  797 */     return jjMoveNfa_2(0, 0);
/*      */   }
/*      */   
/*      */   private int jjMoveStringLiteralDfa1_2(long active0) {
/*      */     try {
/*  802 */       this.curChar = this.input_stream.readChar();
/*  803 */     } catch (IOException e) {
/*  804 */       jjStopStringLiteralDfa_2(0, active0);
/*  805 */       return 1;
/*      */     } 
/*  807 */     switch (this.curChar) {
/*      */       
/*      */       case 'O':
/*  810 */         if ((active0 & 0x4000000L) != 0L) {
/*  811 */           return jjStartNfaWithStates_2(1, 26, 6);
/*      */         }
/*      */         break;
/*      */     } 
/*      */     
/*  816 */     return jjStartNfa_2(0, active0);
/*      */   }
/*      */   
/*      */   private int jjStartNfaWithStates_2(int pos, int kind, int state) {
/*  820 */     this.jjmatchedKind = kind;
/*  821 */     this.jjmatchedPos = pos; 
/*  822 */     try { this.curChar = this.input_stream.readChar(); }
/*  823 */     catch (IOException e) { return pos + 1; }
/*  824 */      return jjMoveNfa_2(state, pos + 1);
/*      */   }
/*      */   
/*      */   private int jjMoveNfa_2(int startState, int curPos) {
/*  828 */     int startsAt = 0;
/*  829 */     this.jjnewStateCnt = 7;
/*  830 */     int i = 1;
/*  831 */     this.jjstateSet[0] = startState;
/*  832 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  835 */       if (++this.jjround == Integer.MAX_VALUE)
/*  836 */         ReInitRounds(); 
/*  837 */       if (this.curChar < '@') {
/*      */         
/*  839 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  842 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  845 */               if ((0xFFFFFFFEFFFFFFFFL & l) != 0L) {
/*      */                 
/*  847 */                 if (kind > 29)
/*  848 */                   kind = 29; 
/*  849 */                 jjCheckNAdd(6);
/*      */               } 
/*  851 */               if ((0x100002600L & l) != 0L) {
/*      */                 
/*  853 */                 if (kind > 7)
/*  854 */                   kind = 7;  break;
/*      */               } 
/*  856 */               if (this.curChar == '""')
/*  857 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 1:
/*  860 */               if (this.curChar == '""')
/*  861 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 2:
/*  864 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  865 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 3:
/*  868 */               if (this.curChar == '""')
/*  869 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 5:
/*  872 */               if (this.curChar == '""' && kind > 28)
/*  873 */                 kind = 28; 
/*      */               break;
/*      */             case 6:
/*  876 */               if ((0xFFFFFFFEFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  878 */               if (kind > 29)
/*  879 */                 kind = 29; 
/*  880 */               jjCheckNAdd(6);
/*      */               break;
/*      */           } 
/*      */         
/*  884 */         } while (i != startsAt);
/*      */       }
/*  886 */       else if (this.curChar < '') {
/*      */         
/*  888 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  891 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  895 */               if ((0xFFFFFFFFDFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  897 */               if (kind > 29)
/*  898 */                 kind = 29; 
/*  899 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  902 */               jjAddStates(16, 18);
/*      */               break;
/*      */             case 4:
/*  905 */               if (this.curChar == '\\') {
/*  906 */                 this.jjstateSet[this.jjnewStateCnt++] = 3;
/*      */               }
/*      */               break;
/*      */           } 
/*  910 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  914 */         int hiByte = this.curChar >> 8;
/*  915 */         int i1 = hiByte >> 6;
/*  916 */         long l1 = 1L << (hiByte & 0x3F);
/*  917 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  918 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  921 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  925 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  927 */               if (kind > 29)
/*  928 */                 kind = 29; 
/*  929 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  932 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  933 */                 jjAddStates(16, 18);
/*      */               }
/*      */               break;
/*      */           } 
/*  937 */         } while (i != startsAt);
/*      */       } 
/*  939 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  941 */         this.jjmatchedKind = kind;
/*  942 */         this.jjmatchedPos = curPos;
/*  943 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  945 */       curPos++;
/*  946 */       if ((i = this.jjnewStateCnt) == (startsAt = 7 - (this.jjnewStateCnt = startsAt)))
/*  947 */         return curPos;  
/*  948 */       try { this.curChar = this.input_stream.readChar(); }
/*  949 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*  952 */   } static final int[] jjnextStates = new int[] { 15, 16, 18, 29, 32, 23, 33, 30, 20, 21, 32, 23, 33, 31, 34, 27, 2, 4, 5, 0, 1 };
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
/*  958 */     switch (hiByte) {
/*      */       
/*      */       case 0:
/*  961 */         return ((jjbitVec2[i2] & l2) != 0L);
/*      */     } 
/*  963 */     if ((jjbitVec0[i1] & l1) != 0L)
/*  964 */       return true; 
/*  965 */     return false;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  970 */   public static final String[] jjstrLiteralImages = new String[] { """", null, null, null, null, null, null, null, null, null, null, ""+"", ""-"", ""("", "")"", "":"", ""*"", ""^"", null, null, null, null, null, ""["", ""{"", null, ""TO"", ""]"", null, null, ""TO"", ""}"", null, null };
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  976 */   public static final String[] lexStateNames = new String[] { ""Boost"", ""RangeEx"", ""RangeIn"", ""DEFAULT"" };
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  984 */   public static final int[] jjnewLexState = new int[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 3, -1, 3, -1, -1, -1, 3, -1, -1 };
/*      */ 
/*      */ 
/*      */   
/*  988 */   static final long[] jjtoToken = new long[] { 17179868929L };
/*      */ 
/*      */   
/*  991 */   static final long[] jjtoSkip = new long[] { 128L };
/*      */   
/*      */   protected CharStream input_stream;
/*      */   
/*  995 */   private final int[] jjrounds = new int[36];
/*  996 */   private final int[] jjstateSet = new int[72]; protected char curChar;
/*      */   int curLexState;
/*      */   int defaultLexState;
/*      */   int jjnewStateCnt;
/*      */   int jjround;
/*      */   int jjmatchedPos;
/*      */   int jjmatchedKind;
/*      */   
/*      */   public QueryParserTokenManager(CharStream stream, int lexState) {
/* 1005 */     this(stream);
/* 1006 */     SwitchTo(lexState);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public void ReInit(CharStream stream) {
/* 1012 */     this.jjmatchedPos = this.jjnewStateCnt = 0;
/* 1013 */     this.curLexState = this.defaultLexState;
/* 1014 */     this.input_stream = stream;
/* 1015 */     ReInitRounds();
/*      */   }
/*      */ 
/*      */   
/*      */   private void ReInitRounds() {
/* 1020 */     this.jjround = -2147483647;
/* 1021 */     for (int i = 36; i-- > 0;) {
/* 1022 */       this.jjrounds[i] = Integer.MIN_VALUE;
/*      */     }
/*      */   }
/*      */ 
/*      */   
/*      */   public void ReInit(CharStream stream, int lexState) {
/* 1028 */     ReInit(stream);
/* 1029 */     SwitchTo(lexState);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public void SwitchTo(int lexState) {
/* 1035 */     if (lexState >= 4 || lexState < 0) {
/* 1036 */       throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", 2);
/*      */     }
/* 1038 */     this.curLexState = lexState;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Token jjFillToken() {
/* 1049 */     String im = jjstrLiteralImages[this.jjmatchedKind];
/* 1050 */     String curTokenImage = (im == null) ? this.input_stream.GetImage() : im;
/* 1051 */     int beginLine = this.input_stream.getBeginLine();
/* 1052 */     int beginColumn = this.input_stream.getBeginColumn();
/* 1053 */     int endLine = this.input_stream.getEndLine();
/* 1054 */     int endColumn = this.input_stream.getEndColumn();
/* 1055 */     Token t = Token.newToken(this.jjmatchedKind, curTokenImage);
/*      */     
/* 1057 */     t.beginLine = beginLine;
/* 1058 */     t.endLine = endLine;
/* 1059 */     t.beginColumn = beginColumn;
/* 1060 */     t.endColumn = endColumn;
/*      */     
/* 1062 */     return t;
/*      */   }
/*      */   public QueryParserTokenManager(CharStream stream) {
/* 1065 */     this.curLexState = 3;
/* 1066 */     this.defaultLexState = 3;
/*      */     this.input_stream = stream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Token getNextToken() {
/* 1076 */     int curPos = 0;
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     while (true) {
/*      */       try {
/* 1083 */         this.curChar = this.input_stream.BeginToken();
/*      */       }
/* 1085 */       catch (IOException e) {
/*      */         
/* 1087 */         this.jjmatchedKind = 0;
/* 1088 */         Token matchedToken = jjFillToken();
/* 1089 */         return matchedToken;
/*      */       } 
/*      */       
/* 1092 */       switch (this.curLexState) {
/*      */         
/*      */         case 0:
/* 1095 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1096 */           this.jjmatchedPos = 0;
/* 1097 */           curPos = jjMoveStringLiteralDfa0_0();
/*      */           break;
/*      */         case 1:
/* 1100 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1101 */           this.jjmatchedPos = 0;
/* 1102 */           curPos = jjMoveStringLiteralDfa0_1();
/*      */           break;
/*      */         case 2:
/* 1105 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1106 */           this.jjmatchedPos = 0;
/* 1107 */           curPos = jjMoveStringLiteralDfa0_2();
/*      */           break;
/*      */         case 3:
/* 1110 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1111 */           this.jjmatchedPos = 0;
/* 1112 */           curPos = jjMoveStringLiteralDfa0_3();
/*      */           break;
/*      */       } 
/* 1115 */       if (this.jjmatchedKind != Integer.MAX_VALUE) {
/*      */         
/* 1117 */         if (this.jjmatchedPos + 1 < curPos)
/* 1118 */           this.input_stream.backup(curPos - this.jjmatchedPos - 1); 
/* 1119 */         if ((jjtoToken[this.jjmatchedKind >> 6] & 1L << (this.jjmatchedKind & 0x3F)) != 0L) {
/*      */           
/* 1121 */           Token matchedToken = jjFillToken();
/* 1122 */           if (jjnewLexState[this.jjmatchedKind] != -1)
/* 1123 */             this.curLexState = jjnewLexState[this.jjmatchedKind]; 
/* 1124 */           return matchedToken;
/*      */         } 
/*      */ 
/*      */         
/* 1128 */         if (jjnewLexState[this.jjmatchedKind] != -1)
/* 1129 */           this.curLexState = jjnewLexState[this.jjmatchedKind];  continue;
/*      */       } 
/*      */       break;
/*      */     } 
/* 1133 */     int error_line = this.input_stream.getEndLine();
/* 1134 */     int error_column = this.input_stream.getEndColumn();
/* 1135 */     String error_after = null;
/* 1136 */     boolean EOFSeen = false; try {
/* 1137 */       this.input_stream.readChar(); this.input_stream.backup(1);
/* 1138 */     } catch (IOException e1) {
/* 1139 */       EOFSeen = true;
/* 1140 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/* 1141 */       if (this.curChar == '\n' || this.curChar == '\r') {
/* 1142 */         error_line++;
/* 1143 */         error_column = 0;
/*      */       } else {
/*      */         
/* 1146 */         error_column++;
/*      */       } 
/* 1148 */     }  if (!EOFSeen) {
/* 1149 */       this.input_stream.backup(1);
/* 1150 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/*      */     } 
/* 1152 */     throw new TokenMgrError(EOFSeen, this.curLexState, error_line, error_column, error_after, this.curChar, 0);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   private void jjCheckNAdd(int state) {
/* 1158 */     if (this.jjrounds[state] != this.jjround) {
/*      */       
/* 1160 */       this.jjstateSet[this.jjnewStateCnt++] = state;
/* 1161 */       this.jjrounds[state] = this.jjround;
/*      */     } 
/*      */   }
/*      */   
/*      */   private void jjAddStates(int start, int end) {
/*      */     do {
/* 1167 */       this.jjstateSet[this.jjnewStateCnt++] = jjnextStates[start];
/* 1168 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private void jjCheckNAddTwoStates(int state1, int state2) {
/* 1172 */     jjCheckNAdd(state1);
/* 1173 */     jjCheckNAdd(state2);
/*      */   }
/*      */ 
/*      */   
/*      */   private void jjCheckNAddStates(int start, int end) {
/*      */     do {
/* 1179 */       jjCheckNAdd(jjnextStates[start]);
/* 1180 */     } while (start++ != end);
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\QueryParserTokenManager.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.Token,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Token
/*     */ {
/*     */   public int kind;
/*     */   public int beginLine;
/*     */   public int beginColumn;
/*     */   public int endLine;
/*     */   public int endColumn;
/*     */   public String image;
/*     */   public Token next;
/*     */   public Token specialToken;
/*     */   
/*  65 */   public Object getValue() { return null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token() {}
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  78 */   public Token(int kind) { this(kind, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(int kind, String image) {
/*  86 */     this.kind = kind;
/*  87 */     this.image = image;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public String toString() { return this.image; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Token newToken(int ofKind, String image) {
/* 112 */     switch (ofKind) {
/*     */     
/* 114 */     }  return new Token(ofKind, image);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 120 */   public static Token newToken(int ofKind) { return newToken(ofKind, null); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.TokenMgrError,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TokenMgrError
/*     */   extends Error
/*     */ {
/*     */   static final int LEXICAL_ERROR = 0;
/*     */   static final int STATIC_LEXER_ERROR = 1;
/*     */   static final int INVALID_LEXICAL_STATE = 2;
/*     */   static final int LOOP_DETECTED = 3;
/*     */   int errorCode;
/*     */   
/*     */   protected static final String addEscapes(String str) {
/*  44 */     StringBuffer retval = new StringBuffer();
/*     */     
/*  46 */     for (int i = 0; i < str.length(); i++) {
/*  47 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/*  52 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/*  55 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/*  58 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/*  61 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/*  64 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/*  67 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/*  70 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/*  73 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/*  76 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/*  77 */             String s = ""0000"" + Integer.toString(ch, 16);
/*  78 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/*  80 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/*  85 */     return retval.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) { return ""Lexical error at line "" + errorLine + "", column "" + errorColumn + "".  Encountered: "" + (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""" + "" ("" + curChar + ""), "")) + ""after : \"""" + addEscapes(errorAfter) + ""\""""; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 118 */   public String getMessage() { return super.getMessage(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError() {}
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError(String message, int reason) {
/* 131 */     super(message);
/* 132 */     this.errorCode = reason;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 137 */   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) { this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\queryParser\TokenMgrError.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanClause,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.util.Parameter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BooleanClause
/*     */   implements Serializable
/*     */ {
/*     */   private Query query;
/*     */   private Occur occur;
/*     */   
/*     */   public static final class Occur
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  30 */     private Occur(String name) { super(name); }
/*     */ 
/*     */     
/*     */     public String toString() {
/*  34 */       if (this == MUST) return ""+""; 
/*  35 */       if (this == MUST_NOT) return ""-""; 
/*  36 */       return """";
/*     */     }
/*     */ 
/*     */     
/*  40 */     public static final Occur MUST = new Occur(""MUST"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  47 */     public static final Occur SHOULD = new Occur(""SHOULD"");
/*     */ 
/*     */ 
/*     */     
/*  51 */     public static final Occur MUST_NOT = new Occur(""MUST_NOT"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BooleanClause(Query query, Occur occur) {
/*  65 */     this.query = query;
/*  66 */     this.occur = occur;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public Occur getOccur() { return this.occur; }
/*     */ 
/*     */ 
/*     */   
/*  75 */   public void setOccur(Occur occur) { this.occur = occur; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   public Query getQuery() { return this.query; }
/*     */ 
/*     */ 
/*     */   
/*  84 */   public void setQuery(Query query) { this.query = query; }
/*     */ 
/*     */ 
/*     */   
/*  88 */   public boolean isProhibited() { return Occur.MUST_NOT.equals(this.occur); }
/*     */ 
/*     */ 
/*     */   
/*  92 */   public boolean isRequired() { return Occur.MUST.equals(this.occur); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*  99 */     if (!(o instanceof BooleanClause))
/* 100 */       return false; 
/* 101 */     BooleanClause other = (BooleanClause)o;
/* 102 */     return (this.query.equals(other.query) && this.occur.equals(other.occur));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 108 */   public int hashCode() { return this.query.hashCode() ^ (Occur.MUST.equals(this.occur) ? 1 : 0) ^ (Occur.MUST_NOT.equals(this.occur) ? 2 : 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 113 */   public String toString() { return this.occur.toString() + this.query.toString(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\BooleanClause.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BooleanQuery
/*     */   extends Query
/*     */ {
/*  34 */   private static int maxClauseCount = 1024;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static class TooManyClauses
/*     */     extends RuntimeException
/*     */   {
/*  44 */     public String getMessage() { return ""maxClauseCount is set to "" + maxClauseCount; }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  53 */   public static int getMaxClauseCount() { return maxClauseCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void setMaxClauseCount(int maxClauseCount) {
/*  69 */     if (maxClauseCount < 1)
/*  70 */       throw new IllegalArgumentException(""maxClauseCount must be >= 1""); 
/*  71 */     BooleanQuery.maxClauseCount = maxClauseCount;
/*     */   }
/*     */   
/*  74 */   private ArrayList clauses = new ArrayList();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean disableCoord;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected int minNrShouldMatch;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public boolean isCoordDisabled() { return this.disableCoord; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Similarity getSimilarity(Searcher searcher) {
/* 102 */     Similarity result = super.getSimilarity(searcher);
/* 103 */     if (this.disableCoord) {
/* 104 */       result = new SimilarityDelegator(result) { private final BooleanQuery this$0;
/*     */           
/* 106 */           public float coord(int overlap, int maxOverlap) { return 1.0F; }
/*     */            }
/*     */         ;
/*     */     }
/* 110 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 136 */   public void setMinimumNumberShouldMatch(int min) { this.minNrShouldMatch = min; }
/*     */   
/* 138 */   public BooleanQuery() { this.minNrShouldMatch = 0; } public BooleanQuery(boolean disableCoord) { this.minNrShouldMatch = 0;
/*     */     this.disableCoord = disableCoord; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public int getMinimumNumberShouldMatch() { return this.minNrShouldMatch; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 154 */   public void add(Query query, BooleanClause.Occur occur) { add(new BooleanClause(query, occur)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(BooleanClause clause) {
/* 162 */     if (this.clauses.size() >= maxClauseCount) {
/* 163 */       throw new TooManyClauses();
/*     */     }
/* 165 */     this.clauses.add(clause);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 170 */   public BooleanClause[] getClauses() { return (BooleanClause[])this.clauses.toArray((Object[])new BooleanClause[this.clauses.size()]); }
/*     */ 
/*     */ 
/*     */   
/* 174 */   public List clauses() { return this.clauses; }
/*     */   
/*     */   private class BooleanWeight implements Weight {
/*     */     protected Similarity similarity;
/* 178 */     protected ArrayList weights = new ArrayList();
/*     */     private final BooleanQuery this$0;
/*     */     
/*     */     public BooleanWeight(Searcher searcher) throws IOException {
/* 182 */       this.similarity = BooleanQuery.this.getSimilarity(searcher);
/* 183 */       for (int i = 0; i < BooleanQuery.this.clauses.size(); i++) {
/* 184 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 185 */         this.weights.add(c.getQuery().createWeight(searcher));
/*     */       } 
/*     */     }
/*     */     
/* 189 */     public Query getQuery() { return BooleanQuery.this; }
/* 190 */     public float getValue() { return BooleanQuery.this.getBoost(); }
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 193 */       float sum = 0.0F;
/* 194 */       for (int i = 0; i < this.weights.size(); i++) {
/* 195 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 196 */         Weight w = this.weights.get(i);
/*     */         
/* 198 */         float s = w.sumOfSquaredWeights();
/* 199 */         if (!c.isProhibited())
/*     */         {
/* 201 */           sum += s;
/*     */         }
/*     */       } 
/* 204 */       sum *= BooleanQuery.this.getBoost() * BooleanQuery.this.getBoost();
/*     */       
/* 206 */       return sum;
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 211 */       norm *= BooleanQuery.this.getBoost();
/* 212 */       for (int i = 0; i < this.weights.size(); i++) {
/* 213 */         Weight w = this.weights.get(i);
/*     */         
/* 215 */         w.normalize(norm);
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 223 */       BooleanScorer2 result = new BooleanScorer2(this.similarity, BooleanQuery.this.minNrShouldMatch, allowDocsOutOfOrder);
/*     */ 
/*     */ 
/*     */       
/* 227 */       for (int i = 0; i < this.weights.size(); i++) {
/* 228 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 229 */         Weight w = this.weights.get(i);
/* 230 */         Scorer subScorer = w.scorer(reader);
/* 231 */         if (subScorer != null) {
/* 232 */           result.add(subScorer, c.isRequired(), c.isProhibited());
/* 233 */         } else if (c.isRequired()) {
/* 234 */           return null;
/*     */         } 
/*     */       } 
/* 237 */       return result;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 242 */       int minShouldMatch = BooleanQuery.this.getMinimumNumberShouldMatch();
/*     */       
/* 244 */       ComplexExplanation sumExpl = new ComplexExplanation();
/* 245 */       sumExpl.setDescription(""sum of:"");
/* 246 */       int coord = 0;
/* 247 */       int maxCoord = 0;
/* 248 */       float sum = 0.0F;
/* 249 */       boolean fail = false;
/* 250 */       int shouldMatchCount = 0;
/* 251 */       for (int i = 0; i < this.weights.size(); i++) {
/* 252 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 253 */         Weight w = this.weights.get(i);
/* 254 */         Explanation e = w.explain(reader, doc);
/* 255 */         if (!c.isProhibited()) maxCoord++; 
/* 256 */         if (e.isMatch()) {
/* 257 */           if (!c.isProhibited()) {
/* 258 */             sumExpl.addDetail(e);
/* 259 */             sum += e.getValue();
/* 260 */             coord++;
/*     */           } else {
/* 262 */             Explanation r = new Explanation(0.0F, ""match on prohibited clause ("" + c.getQuery().toString() + "")"");
/*     */             
/* 264 */             r.addDetail(e);
/* 265 */             sumExpl.addDetail(r);
/* 266 */             fail = true;
/*     */           } 
/* 268 */           if (c.getOccur().equals(BooleanClause.Occur.SHOULD))
/* 269 */             shouldMatchCount++; 
/* 270 */         } else if (c.isRequired()) {
/* 271 */           Explanation r = new Explanation(0.0F, ""no match on required clause ("" + c.getQuery().toString() + "")"");
/* 272 */           r.addDetail(e);
/* 273 */           sumExpl.addDetail(r);
/* 274 */           fail = true;
/*     */         } 
/*     */       } 
/* 277 */       if (fail) {
/* 278 */         sumExpl.setMatch(Boolean.FALSE);
/* 279 */         sumExpl.setValue(0.0F);
/* 280 */         sumExpl.setDescription(""Failure to meet condition(s) of required/prohibited clause(s)"");
/*     */         
/* 282 */         return sumExpl;
/* 283 */       }  if (shouldMatchCount < minShouldMatch) {
/* 284 */         sumExpl.setMatch(Boolean.FALSE);
/* 285 */         sumExpl.setValue(0.0F);
/* 286 */         sumExpl.setDescription(""Failure to match minimum number of optional clauses: "" + minShouldMatch);
/*     */         
/* 288 */         return sumExpl;
/*     */       } 
/*     */       
/* 291 */       sumExpl.setMatch((0 < coord) ? Boolean.TRUE : Boolean.FALSE);
/* 292 */       sumExpl.setValue(sum);
/*     */       
/* 294 */       float coordFactor = this.similarity.coord(coord, maxCoord);
/* 295 */       if (coordFactor == 1.0F) {
/* 296 */         return sumExpl;
/*     */       }
/* 298 */       ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(), sum * coordFactor, ""product of:"");
/*     */ 
/*     */       
/* 301 */       result.addDetail(sumExpl);
/* 302 */       result.addDetail(new Explanation(coordFactor, ""coord("" + coord + ""/"" + maxCoord + "")""));
/*     */       
/* 304 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static boolean allowDocsOutOfOrder = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 334 */   public static void setAllowDocsOutOfOrder(boolean allow) { allowDocsOutOfOrder = allow; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 342 */   public static boolean getAllowDocsOutOfOrder() { return allowDocsOutOfOrder; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 349 */   public static void setUseScorer14(boolean use14) { setAllowDocsOutOfOrder(use14); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 356 */   public static boolean getUseScorer14() { return getAllowDocsOutOfOrder(); }
/*     */ 
/*     */ 
/*     */   
/* 360 */   protected Weight createWeight(Searcher searcher) throws IOException { return new BooleanWeight(searcher); }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 364 */     if (this.minNrShouldMatch == 0 && this.clauses.size() == 1) {
/* 365 */       BooleanClause c = this.clauses.get(0);
/* 366 */       if (!c.isProhibited()) {
/*     */         
/* 368 */         Query query = c.getQuery().rewrite(reader);
/*     */         
/* 370 */         if (getBoost() != 1.0F) {
/* 371 */           if (query == c.getQuery())
/* 372 */             query = (Query)query.clone(); 
/* 373 */           query.setBoost(getBoost() * query.getBoost());
/*     */         } 
/*     */         
/* 376 */         return query;
/*     */       } 
/*     */     } 
/*     */     
/* 380 */     BooleanQuery clone = null;
/* 381 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 382 */       BooleanClause c = this.clauses.get(i);
/* 383 */       Query query = c.getQuery().rewrite(reader);
/* 384 */       if (query != c.getQuery()) {
/* 385 */         if (clone == null)
/* 386 */           clone = (BooleanQuery)clone(); 
/* 387 */         clone.clauses.set(i, new BooleanClause(query, c.getOccur()));
/*     */       } 
/*     */     } 
/* 390 */     if (clone != null) {
/* 391 */       return clone;
/*     */     }
/* 393 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 398 */     for (Iterator i = this.clauses.iterator(); i.hasNext(); ) {
/* 399 */       BooleanClause clause = i.next();
/* 400 */       clause.getQuery().extractTerms(terms);
/*     */     } 
/*     */   }
/*     */   
/*     */   public Object clone() {
/* 405 */     BooleanQuery clone = (BooleanQuery)super.clone();
/* 406 */     clone.clauses = (ArrayList)this.clauses.clone();
/* 407 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 412 */     StringBuffer buffer = new StringBuffer();
/* 413 */     boolean needParens = (getBoost() != 1.0D || getMinimumNumberShouldMatch() > 0);
/* 414 */     if (needParens) {
/* 415 */       buffer.append(""("");
/*     */     }
/*     */     
/* 418 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 419 */       BooleanClause c = this.clauses.get(i);
/* 420 */       if (c.isProhibited()) {
/* 421 */         buffer.append(""-"");
/* 422 */       } else if (c.isRequired()) {
/* 423 */         buffer.append(""+"");
/*     */       } 
/* 425 */       Query subQuery = c.getQuery();
/* 426 */       if (subQuery instanceof BooleanQuery) {
/* 427 */         buffer.append(""("");
/* 428 */         buffer.append(c.getQuery().toString(field));
/* 429 */         buffer.append("")"");
/*     */       } else {
/* 431 */         buffer.append(c.getQuery().toString(field));
/*     */       } 
/* 433 */       if (i != this.clauses.size() - 1) {
/* 434 */         buffer.append("" "");
/*     */       }
/*     */     } 
/* 437 */     if (needParens) {
/* 438 */       buffer.append("")"");
/*     */     }
/*     */     
/* 441 */     if (getMinimumNumberShouldMatch() > 0) {
/* 442 */       buffer.append('~');
/* 443 */       buffer.append(getMinimumNumberShouldMatch());
/*     */     } 
/*     */     
/* 446 */     if (getBoost() != 1.0F)
/*     */     {
/* 448 */       buffer.append(ToStringUtils.boost(getBoost()));
/*     */     }
/*     */     
/* 451 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 456 */     if (!(o instanceof BooleanQuery))
/* 457 */       return false; 
/* 458 */     BooleanQuery other = (BooleanQuery)o;
/* 459 */     return (getBoost() == other.getBoost() && this.clauses.equals(other.clauses) && getMinimumNumberShouldMatch() == other.getMinimumNumberShouldMatch());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 466 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.clauses.hashCode() + getMinimumNumberShouldMatch(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\BooleanQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class BooleanScorer
/*     */   extends Scorer
/*     */ {
/*  23 */   private SubScorer scorers = null;
/*  24 */   private BucketTable bucketTable = new BucketTable();
/*     */   
/*  26 */   private int maxCoord = 1;
/*  27 */   private float[] coordFactors = null;
/*     */   
/*  29 */   private int requiredMask = 0;
/*  30 */   private int prohibitedMask = 0;
/*  31 */   private int nextMask = 1;
/*     */   private final int minNrShouldMatch;
/*     */   private int end;
/*     */   private Bucket current;
/*     */   
/*  36 */   BooleanScorer(Similarity similarity) { this(similarity, 1); }
/*     */ 
/*     */   
/*     */   BooleanScorer(Similarity similarity, int minNrShouldMatch) {
/*  40 */     super(similarity);
/*  41 */     this.minNrShouldMatch = minNrShouldMatch;
/*     */   }
/*     */ 
/*     */   
/*     */   static final class SubScorer
/*     */   {
/*     */     public Scorer scorer;
/*     */     public boolean done;
/*     */     public boolean required = false;
/*     */     public boolean prohibited = false;
/*     */     public HitCollector collector;
/*     */     public SubScorer next;
/*     */     
/*     */     public SubScorer(Scorer scorer, boolean required, boolean prohibited, HitCollector collector, SubScorer next) throws IOException {
/*  55 */       this.scorer = scorer;
/*  56 */       this.done = !scorer.next();
/*  57 */       this.required = required;
/*  58 */       this.prohibited = prohibited;
/*  59 */       this.collector = collector;
/*  60 */       this.next = next;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   final void add(Scorer scorer, boolean required, boolean prohibited) throws IOException {
/*  66 */     int mask = 0;
/*  67 */     if (required || prohibited) {
/*  68 */       if (this.nextMask == 0) {
/*  69 */         throw new IndexOutOfBoundsException(""More than 32 required/prohibited clauses in query."");
/*     */       }
/*  71 */       mask = this.nextMask;
/*  72 */       this.nextMask <<= 1;
/*     */     } else {
/*  74 */       mask = 0;
/*     */     } 
/*  76 */     if (!prohibited) {
/*  77 */       this.maxCoord++;
/*     */     }
/*  79 */     if (prohibited) {
/*  80 */       this.prohibitedMask |= mask;
/*  81 */     } else if (required) {
/*  82 */       this.requiredMask |= mask;
/*     */     } 
/*  84 */     this.scorers = new SubScorer(scorer, required, prohibited, this.bucketTable.newCollector(mask), this.scorers);
/*     */   }
/*     */ 
/*     */   
/*     */   private final void computeCoordFactors() {
/*  89 */     this.coordFactors = new float[this.maxCoord];
/*  90 */     for (int i = 0; i < this.maxCoord; i++) {
/*  91 */       this.coordFactors[i] = getSimilarity().coord(i, this.maxCoord - 1);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/*  98 */     next();
/*  99 */     score(hc, 2147483647);
/*     */   }
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/*     */     boolean more;
/* 103 */     if (this.coordFactors == null) {
/* 104 */       computeCoordFactors();
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     do {
/* 110 */       this.bucketTable.first = null;
/*     */       
/* 112 */       while (this.current != null) {
/*     */ 
/*     */         
/* 115 */         if ((this.current.bits & this.prohibitedMask) == 0 && (this.current.bits & this.requiredMask) == this.requiredMask) {
/*     */ 
/*     */           
/* 118 */           if (this.current.doc >= max) {
/* 119 */             Bucket tmp = this.current;
/* 120 */             this.current = this.current.next;
/* 121 */             tmp.next = this.bucketTable.first;
/* 122 */             this.bucketTable.first = tmp;
/*     */             
/*     */             continue;
/*     */           } 
/* 126 */           if (this.current.coord >= this.minNrShouldMatch) {
/* 127 */             hc.collect(this.current.doc, this.current.score * this.coordFactors[this.current.coord]);
/*     */           }
/*     */         } 
/*     */         
/* 131 */         this.current = this.current.next;
/*     */       } 
/*     */       
/* 134 */       if (this.bucketTable.first != null) {
/* 135 */         this.current = this.bucketTable.first;
/* 136 */         this.bucketTable.first = this.current.next;
/* 137 */         return true;
/*     */       } 
/*     */ 
/*     */       
/* 141 */       more = false;
/* 142 */       this.end += 2048;
/* 143 */       for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 144 */         if (!sub.done) {
/* 145 */           sub.done = !sub.scorer.score(sub.collector, this.end);
/* 146 */           if (!sub.done)
/* 147 */             more = true; 
/*     */         } 
/*     */       } 
/* 150 */       this.current = this.bucketTable.first;
/*     */     }
/* 152 */     while (this.current != null || more);
/*     */     
/* 154 */     return false;
/*     */   }
/*     */   
/* 157 */   public int doc() { return this.current.doc; }
/*     */   
/*     */   public boolean next() throws IOException {
/*     */     boolean more;
/*     */     do {
/* 162 */       while (this.bucketTable.first != null) {
/* 163 */         this.current = this.bucketTable.first;
/* 164 */         this.bucketTable.first = this.current.next;
/*     */ 
/*     */         
/* 167 */         if ((this.current.bits & this.prohibitedMask) == 0 && (this.current.bits & this.requiredMask) == this.requiredMask && this.current.coord >= this.minNrShouldMatch)
/*     */         {
/*     */           
/* 170 */           return true;
/*     */         }
/*     */       } 
/*     */ 
/*     */       
/* 175 */       more = false;
/* 176 */       this.end += 2048;
/* 177 */       for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 178 */         Scorer scorer = sub.scorer;
/* 179 */         while (!sub.done && scorer.doc() < this.end) {
/* 180 */           sub.collector.collect(scorer.doc(), scorer.score());
/* 181 */           sub.done = !scorer.next();
/*     */         } 
/* 183 */         if (!sub.done) {
/* 184 */           more = true;
/*     */         }
/*     */       } 
/* 187 */     } while (this.bucketTable.first != null || more);
/*     */     
/* 189 */     return false;
/*     */   }
/*     */   
/*     */   public float score() {
/* 193 */     if (this.coordFactors == null)
/* 194 */       computeCoordFactors(); 
/* 195 */     return this.current.score * this.coordFactors[this.current.coord];
/*     */   }
/*     */   
/*     */   static final class Bucket {
/* 199 */     int doc = -1;
/*     */     
/*     */     float score;
/*     */     int bits;
/*     */     int coord;
/*     */     Bucket next;
/*     */   }
/*     */   
/*     */   static final class BucketTable
/*     */   {
/*     */     public static final int SIZE = 2048;
/*     */     public static final int MASK = 2047;
/* 211 */     final BooleanScorer.Bucket[] buckets = new BooleanScorer.Bucket[2048];
/* 212 */     BooleanScorer.Bucket first = null;
/*     */ 
/*     */ 
/*     */     
/* 216 */     public final int size() { return 2048; }
/*     */ 
/*     */     
/* 219 */     public HitCollector newCollector(int mask) { return new BooleanScorer.Collector(mask, this); }
/*     */   }
/*     */   
/*     */   static final class Collector extends HitCollector {
/*     */     private BooleanScorer.BucketTable bucketTable;
/*     */     private int mask;
/*     */     
/*     */     public Collector(int mask, BooleanScorer.BucketTable bucketTable) {
/* 227 */       this.mask = mask;
/* 228 */       this.bucketTable = bucketTable;
/*     */     }
/*     */     public final void collect(int doc, float score) {
/* 231 */       BooleanScorer.BucketTable table = this.bucketTable;
/* 232 */       int i = doc & 0x7FF;
/* 233 */       BooleanScorer.Bucket bucket = table.buckets[i];
/* 234 */       if (bucket == null) {
/* 235 */         table.buckets[i] = bucket = new BooleanScorer.Bucket();
/*     */       }
/* 237 */       if (bucket.doc != doc) {
/* 238 */         bucket.doc = doc;
/* 239 */         bucket.score = score;
/* 240 */         bucket.bits = this.mask;
/* 241 */         bucket.coord = 1;
/*     */         
/* 243 */         bucket.next = table.first;
/* 244 */         table.first = bucket;
/*     */       } else {
/* 246 */         bucket.score += score;
/* 247 */         bucket.bits |= this.mask;
/* 248 */         bucket.coord++;
/*     */       } 
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 254 */   public boolean skipTo(int target) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/* 258 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 262 */     StringBuffer buffer = new StringBuffer();
/* 263 */     buffer.append(""boolean("");
/* 264 */     for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 265 */       buffer.append(sub.scorer.toString());
/* 266 */       buffer.append("" "");
/*     */     } 
/* 268 */     buffer.append("")"");
/* 269 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\BooleanScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanScorer2,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class BooleanScorer2
/*     */   extends Scorer
/*     */ {
/*  31 */   private ArrayList requiredScorers = new ArrayList();
/*  32 */   private ArrayList optionalScorers = new ArrayList();
/*  33 */   private ArrayList prohibitedScorers = new ArrayList();
/*     */   private final Coordinator coordinator;
/*     */   
/*  36 */   private class Coordinator { int maxCoord = 0;
/*     */     
/*  38 */     private float[] coordFactors = null; int nrMatchers;
/*     */     
/*     */     void init() {
/*  41 */       this.coordFactors = new float[this.maxCoord + 1];
/*  42 */       Similarity sim = BooleanScorer2.this.getSimilarity();
/*  43 */       for (int i = 0; i <= this.maxCoord; i++) {
/*  44 */         this.coordFactors[i] = sim.coord(i, this.maxCoord);
/*     */       }
/*     */     }
/*     */ 
/*     */     
/*     */     private final BooleanScorer2 this$0;
/*     */     
/*  51 */     void initDoc() { this.nrMatchers = 0; }
/*     */ 
/*     */ 
/*     */     
/*  55 */     float coordFactor() { return this.coordFactors[this.nrMatchers]; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     private Coordinator() {} }
/*     */ 
/*     */ 
/*     */   
/*  64 */   private Scorer countingSumScorer = null;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int minNrShouldMatch;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean allowDocsOutOfOrder;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BooleanScorer2(Similarity similarity, int minNrShouldMatch, boolean allowDocsOutOfOrder) {
/*  86 */     super(similarity);
/*  87 */     if (minNrShouldMatch < 0) {
/*  88 */       throw new IllegalArgumentException(""Minimum number of optional scorers should not be negative"");
/*     */     }
/*  90 */     this.coordinator = new Coordinator();
/*  91 */     this.minNrShouldMatch = minNrShouldMatch;
/*  92 */     this.allowDocsOutOfOrder = allowDocsOutOfOrder;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public BooleanScorer2(Similarity similarity, int minNrShouldMatch) { this(similarity, minNrShouldMatch, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public BooleanScorer2(Similarity similarity) { this(similarity, 0, false); }
/*     */ 
/*     */   
/*     */   public void add(Scorer scorer, boolean required, boolean prohibited) {
/* 119 */     if (!prohibited) {
/* 120 */       this.coordinator.maxCoord++;
/*     */     }
/*     */     
/* 123 */     if (required) {
/* 124 */       if (prohibited) {
/* 125 */         throw new IllegalArgumentException(""scorer cannot be required and prohibited"");
/*     */       }
/* 127 */       this.requiredScorers.add(scorer);
/* 128 */     } else if (prohibited) {
/* 129 */       this.prohibitedScorers.add(scorer);
/*     */     } else {
/* 131 */       this.optionalScorers.add(scorer);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void initCountingSumScorer() throws IOException {
/* 143 */     this.coordinator.init();
/* 144 */     this.countingSumScorer = makeCountingSumScorer();
/*     */   }
/*     */   
/*     */   private class SingleMatchScorer
/*     */     extends Scorer {
/*     */     private Scorer scorer;
/* 150 */     private int lastScoredDoc = -1; private final BooleanScorer2 this$0;
/*     */     
/*     */     SingleMatchScorer(Scorer scorer) {
/* 153 */       super(scorer.getSimilarity());
/* 154 */       this.scorer = scorer;
/*     */     }
/*     */     public float score() throws IOException {
/* 157 */       if (doc() >= this.lastScoredDoc) {
/* 158 */         this.lastScoredDoc = doc();
/* 159 */         BooleanScorer2.this.coordinator.nrMatchers++;
/*     */       } 
/* 161 */       return this.scorer.score();
/*     */     }
/*     */     
/* 164 */     public int doc() { return this.scorer.doc(); }
/*     */ 
/*     */     
/* 167 */     public boolean next() throws IOException { return this.scorer.next(); }
/*     */ 
/*     */     
/* 170 */     public boolean skipTo(int docNr) throws IOException { return this.scorer.skipTo(docNr); }
/*     */ 
/*     */     
/* 173 */     public Explanation explain(int docNr) throws IOException { return this.scorer.explain(docNr); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer countingDisjunctionSumScorer(List scorers, int minNrShouldMatch) {
/* 181 */     return new DisjunctionSumScorer(scorers, minNrShouldMatch) {
/* 182 */         private int lastScoredDoc = -1;
/*     */         public float score() throws IOException {
/* 184 */           if (doc() >= this.lastScoredDoc) {
/* 185 */             this.lastScoredDoc = doc();
/* 186 */             BooleanScorer2.this.coordinator.nrMatchers += this.nrMatchers;
/*     */           } 
/* 188 */           return super.score();
/*     */         }
/*     */         private final BooleanScorer2 this$0;
/*     */       };
/*     */   }
/* 193 */   private static Similarity defaultSimilarity = new DefaultSimilarity();
/*     */ 
/*     */   
/*     */   private Scorer countingConjunctionSumScorer(List requiredScorers) throws IOException {
/* 197 */     final int requiredNrMatchers = requiredScorers.size();
/* 198 */     return new ConjunctionScorer(defaultSimilarity, requiredScorers) {
/* 199 */         private int lastScoredDoc = -1; private final int val$requiredNrMatchers; private final BooleanScorer2 this$0;
/*     */         
/*     */         public float score() throws IOException {
/* 202 */           if (doc() >= this.lastScoredDoc) {
/* 203 */             this.lastScoredDoc = doc();
/* 204 */             BooleanScorer2.this.coordinator.nrMatchers += requiredNrMatchers;
/*     */           } 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 210 */           return super.score();
/*     */         }
/*     */       };
/*     */   }
/*     */ 
/*     */   
/* 216 */   private Scorer dualConjunctionSumScorer(Scorer req1, Scorer req2) throws IOException { return new ConjunctionScorer(defaultSimilarity, new Scorer[] { req1, req2 }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 227 */   private Scorer makeCountingSumScorer() throws IOException { return (this.requiredScorers.size() == 0) ? makeCountingSumScorerNoReq() : makeCountingSumScorerSomeReq(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer makeCountingSumScorerNoReq() throws IOException {
/* 233 */     if (this.optionalScorers.size() == 0) {
/* 234 */       return new NonMatchingScorer();
/*     */     }
/*     */     
/* 237 */     int nrOptRequired = (this.minNrShouldMatch < 1) ? 1 : this.minNrShouldMatch;
/* 238 */     if (this.optionalScorers.size() < nrOptRequired) {
/* 239 */       return new NonMatchingScorer();
/*     */     }
/* 241 */     Scorer requiredCountingSumScorer = (this.optionalScorers.size() > nrOptRequired) ? countingDisjunctionSumScorer(this.optionalScorers, nrOptRequired) : ((this.optionalScorers.size() == 1) ? new SingleMatchScorer(this.optionalScorers.get(0)) : countingConjunctionSumScorer(this.optionalScorers));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 248 */     return addProhibitedScorers(requiredCountingSumScorer);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer makeCountingSumScorerSomeReq() throws IOException {
/* 254 */     if (this.optionalScorers.size() < this.minNrShouldMatch)
/* 255 */       return new NonMatchingScorer(); 
/* 256 */     if (this.optionalScorers.size() == this.minNrShouldMatch) {
/* 257 */       ArrayList allReq = new ArrayList(this.requiredScorers);
/* 258 */       allReq.addAll(this.optionalScorers);
/* 259 */       return addProhibitedScorers(countingConjunctionSumScorer(allReq));
/*     */     } 
/* 261 */     Scorer requiredCountingSumScorer = (this.requiredScorers.size() == 1) ? new SingleMatchScorer(this.requiredScorers.get(0)) : countingConjunctionSumScorer(this.requiredScorers);
/*     */ 
/*     */ 
/*     */     
/* 265 */     if (this.minNrShouldMatch > 0) {
/* 266 */       return addProhibitedScorers(dualConjunctionSumScorer(requiredCountingSumScorer, countingDisjunctionSumScorer(this.optionalScorers, this.minNrShouldMatch)));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 273 */     return new ReqOptSumScorer(addProhibitedScorers(requiredCountingSumScorer), (this.optionalScorers.size() == 1) ? new SingleMatchScorer(this.optionalScorers.get(0)) : countingDisjunctionSumScorer(this.optionalScorers, 1));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 288 */   private Scorer addProhibitedScorers(Scorer requiredCountingSumScorer) { return (this.prohibitedScorers.size() == 0) ? requiredCountingSumScorer : new ReqExclScorer(requiredCountingSumScorer, (this.prohibitedScorers.size() == 1) ? this.prohibitedScorers.get(0) : new DisjunctionSumScorer(this.prohibitedScorers)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/* 302 */     if (this.allowDocsOutOfOrder && this.requiredScorers.size() == 0 && this.prohibitedScorers.size() < 32) {
/*     */ 
/*     */       
/* 305 */       BooleanScorer bs = new BooleanScorer(getSimilarity(), this.minNrShouldMatch);
/* 306 */       Iterator si = this.optionalScorers.iterator();
/* 307 */       while (si.hasNext()) {
/* 308 */         bs.add(si.next(), false, false);
/*     */       }
/* 310 */       si = this.prohibitedScorers.iterator();
/* 311 */       while (si.hasNext()) {
/* 312 */         bs.add(si.next(), false, true);
/*     */       }
/* 314 */       bs.score(hc);
/*     */     } else {
/* 316 */       if (this.countingSumScorer == null) {
/* 317 */         initCountingSumScorer();
/*     */       }
/* 319 */       while (this.countingSumScorer.next()) {
/* 320 */         hc.collect(this.countingSumScorer.doc(), score());
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 335 */     int docNr = this.countingSumScorer.doc();
/* 336 */     while (docNr < max) {
/* 337 */       hc.collect(docNr, score());
/* 338 */       if (!this.countingSumScorer.next()) {
/* 339 */         return false;
/*     */       }
/* 341 */       docNr = this.countingSumScorer.doc();
/*     */     } 
/* 343 */     return true;
/*     */   }
/*     */   
/* 346 */   public int doc() { return this.countingSumScorer.doc(); }
/*     */   
/*     */   public boolean next() throws IOException {
/* 349 */     if (this.countingSumScorer == null) {
/* 350 */       initCountingSumScorer();
/*     */     }
/* 352 */     return this.countingSumScorer.next();
/*     */   }
/*     */   
/*     */   public float score() throws IOException {
/* 356 */     this.coordinator.initDoc();
/* 357 */     float sum = this.countingSumScorer.score();
/* 358 */     return sum * this.coordinator.coordFactor();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 370 */     if (this.countingSumScorer == null) {
/* 371 */       initCountingSumScorer();
/*     */     }
/* 373 */     return this.countingSumScorer.skipTo(target);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 382 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\BooleanScorer2.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.CachingSpanFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import java.util.Map;
/*    */ import java.util.WeakHashMap;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CachingSpanFilter
/*    */   extends SpanFilter
/*    */ {
/*    */   protected SpanFilter filter;
/*    */   protected transient Map cache;
/*    */   
/* 43 */   public CachingSpanFilter(SpanFilter filter) { this.filter = filter; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 50 */     SpanFilterResult result = getCachedResult(reader);
/* 51 */     return (result != null) ? result.getBits() : null;
/*    */   }
/*    */   
/*    */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
/* 55 */     SpanFilterResult result = getCachedResult(reader);
/* 56 */     return (result != null) ? result.getDocIdSet() : null;
/*    */   }
/*    */   
/*    */   private SpanFilterResult getCachedResult(IndexReader reader) throws IOException {
/* 60 */     SpanFilterResult result = null;
/* 61 */     if (this.cache == null) {
/* 62 */       this.cache = new WeakHashMap();
/*    */     }
/*    */     
/* 65 */     synchronized (this.cache) {
/* 66 */       result = (SpanFilterResult)this.cache.get(reader);
/* 67 */       if (result == null) {
/* 68 */         result = this.filter.bitSpans(reader);
/* 69 */         this.cache.put(reader, result);
/*    */       } 
/*    */     } 
/* 72 */     return result;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 77 */   public SpanFilterResult bitSpans(IndexReader reader) throws IOException { return getCachedResult(reader); }
/*    */ 
/*    */ 
/*    */   
/* 81 */   public String toString() { return ""CachingSpanFilter("" + this.filter + "")""; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 85 */     if (!(o instanceof CachingSpanFilter)) return false; 
/* 86 */     return this.filter.equals(((CachingSpanFilter)o).filter);
/*    */   }
/*    */ 
/*    */   
/* 90 */   public int hashCode() { return this.filter.hashCode() ^ 0x1117BF25; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\CachingSpanFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.CachingWrapperFilter,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import java.util.Map;
/*     */ import java.util.WeakHashMap;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class CachingWrapperFilter
/*     */   extends Filter
/*     */ {
/*     */   protected Filter filter;
/*     */   protected transient Map cache;
/*     */   
/*  43 */   public CachingWrapperFilter(Filter filter) { this.filter = filter; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BitSet bits(IndexReader reader) throws IOException {
/*  50 */     if (this.cache == null) {
/*  51 */       this.cache = new WeakHashMap();
/*     */     }
/*     */     
/*  54 */     synchronized (this.cache) {
/*  55 */       BitSet cached = (BitSet)this.cache.get(reader);
/*  56 */       if (cached != null) {
/*  57 */         return cached;
/*     */       }
/*     */     } 
/*     */     
/*  61 */     BitSet bits = this.filter.bits(reader);
/*     */     
/*  63 */     synchronized (this.cache) {
/*  64 */       this.cache.put(reader, bits);
/*     */     } 
/*     */     
/*  67 */     return bits;
/*     */   }
/*     */   
/*     */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
/*  71 */     if (this.cache == null) {
/*  72 */       this.cache = new WeakHashMap();
/*     */     }
/*     */     
/*  75 */     synchronized (this.cache) {
/*  76 */       DocIdSet cached = (DocIdSet)this.cache.get(reader);
/*  77 */       if (cached != null) {
/*  78 */         return cached;
/*     */       }
/*     */     } 
/*     */     
/*  82 */     DocIdSet docIdSet = this.filter.getDocIdSet(reader);
/*     */     
/*  84 */     synchronized (this.cache) {
/*  85 */       this.cache.put(reader, docIdSet);
/*     */     } 
/*     */     
/*  88 */     return docIdSet;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  93 */   public String toString() { return ""CachingWrapperFilter("" + this.filter + "")""; }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*  97 */     if (!(o instanceof CachingWrapperFilter)) return false; 
/*  98 */     return this.filter.equals(((CachingWrapperFilter)o).filter);
/*     */   }
/*     */ 
/*     */   
/* 102 */   public int hashCode() { return this.filter.hashCode() ^ 0x1117BF25; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\CachingWrapperFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ComplexExplanation,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ComplexExplanation
/*    */   extends Explanation
/*    */ {
/*    */   private Boolean match;
/*    */   
/*    */   public ComplexExplanation() {}
/*    */   
/*    */   public ComplexExplanation(boolean match, float value, String description) {
/* 32 */     super(value, description);
/* 33 */     this.match = Boolean.valueOf(match);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 40 */   public Boolean getMatch() { return this.match; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 45 */   public void setMatch(Boolean match) { this.match = match; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean isMatch() {
/* 56 */     Boolean m = getMatch();
/* 57 */     return (null != m) ? m.booleanValue() : super.isMatch();
/*    */   }
/*    */   
/*    */   protected String getSummary() {
/* 61 */     if (null == getMatch()) {
/* 62 */       return super.getSummary();
/*    */     }
/* 64 */     return getValue() + "" = "" + (isMatch() ? ""(MATCH) "" : ""(NON-MATCH) "") + getDescription();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ComplexExplanation.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConjunctionScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Collection;
/*     */ import java.util.Comparator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class ConjunctionScorer
/*     */   extends Scorer
/*     */ {
/*     */   private final Scorer[] scorers;
/*     */   private boolean firstTime = true;
/*     */   private boolean more;
/*     */   private final float coord;
/*  32 */   private int lastDoc = -1;
/*     */ 
/*     */   
/*  35 */   public ConjunctionScorer(Similarity similarity, Collection scorers) throws IOException { this(similarity, (Scorer[])scorers.toArray((Object[])new Scorer[scorers.size()])); }
/*     */ 
/*     */   
/*     */   public ConjunctionScorer(Similarity similarity, Scorer[] scorers) throws IOException {
/*  39 */     super(similarity);
/*  40 */     this.scorers = scorers;
/*  41 */     this.coord = getSimilarity().coord(this.scorers.length, this.scorers.length);
/*     */   }
/*     */   
/*  44 */   public int doc() { return this.lastDoc; }
/*     */   
/*     */   public boolean next() throws IOException {
/*  47 */     if (this.firstTime)
/*  48 */       return init(0); 
/*  49 */     if (this.more)
/*  50 */       this.more = this.scorers[this.scorers.length - 1].next(); 
/*  51 */     return doNext();
/*     */   }
/*     */   
/*     */   private boolean doNext() throws IOException {
/*  55 */     int first = 0;
/*  56 */     Scorer lastScorer = this.scorers[this.scorers.length - 1];
/*     */     Scorer firstScorer;
/*  58 */     while (this.more && (firstScorer = this.scorers[first]).doc() < (this.lastDoc = lastScorer.doc())) {
/*  59 */       this.more = firstScorer.skipTo(this.lastDoc);
/*  60 */       lastScorer = firstScorer;
/*  61 */       first = (first == this.scorers.length - 1) ? 0 : (first + 1);
/*     */     } 
/*  63 */     return this.more;
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  67 */     if (this.firstTime)
/*  68 */       return init(target); 
/*  69 */     if (this.more)
/*  70 */       this.more = this.scorers[this.scorers.length - 1].skipTo(target); 
/*  71 */     return doNext();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean init(int target) throws IOException {
/*  77 */     this.firstTime = false;
/*  78 */     this.more = (this.scorers.length > 1);
/*  79 */     for (int i = 0; i < this.scorers.length; i++) {
/*  80 */       this.more = (target == 0) ? this.scorers[i].next() : this.scorers[i].skipTo(target);
/*  81 */       if (!this.more) {
/*  82 */         return false;
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  90 */     Arrays.sort(this.scorers, new Comparator()
/*     */         {
/*  92 */           public int compare(Object o1, Object o2) { return ((Scorer)o1).doc() - ((Scorer)o2).doc(); }
/*     */           
/*     */           private final ConjunctionScorer this$0;
/*     */         });
/*  96 */     doNext();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 104 */     int end = this.scorers.length - 1;
/* 105 */     for (int i = 0; i < end >> 1; i++) {
/* 106 */       Scorer tmp = this.scorers[i];
/* 107 */       this.scorers[i] = this.scorers[end - i - 1];
/* 108 */       this.scorers[end - i - 1] = tmp;
/*     */     } 
/*     */     
/* 111 */     return this.more;
/*     */   }
/*     */   
/*     */   public float score() throws IOException {
/* 115 */     float sum = 0.0F;
/* 116 */     for (int i = 0; i < this.scorers.length; i++) {
/* 117 */       sum += this.scorers[i].score();
/*     */     }
/* 119 */     return sum * this.coord;
/*     */   }
/*     */ 
/*     */   
/* 123 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ConjunctionScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConstantScoreQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ConstantScoreQuery
/*     */   extends Query
/*     */ {
/*     */   protected final Filter filter;
/*     */   
/*  36 */   public ConstantScoreQuery(Filter filter) { this.filter = filter; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  41 */   public Filter getFilter() { return this.filter; }
/*     */ 
/*     */ 
/*     */   
/*  45 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   protected class ConstantWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final ConstantScoreQuery this$0;
/*     */     
/*  59 */     public ConstantWeight(Searcher searcher) { this.similarity = ConstantScoreQuery.this.getSimilarity(searcher); }
/*     */ 
/*     */ 
/*     */     
/*  63 */     public Query getQuery() { return ConstantScoreQuery.this; }
/*     */ 
/*     */ 
/*     */     
/*  67 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/*  71 */       this.queryWeight = ConstantScoreQuery.this.getBoost();
/*  72 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float norm) {
/*  76 */       this.queryNorm = norm;
/*  77 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */     
/*  81 */     public Scorer scorer(IndexReader reader) throws IOException { return new ConstantScoreQuery.ConstantScorer(this.similarity, reader, this); }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  86 */       ConstantScoreQuery.ConstantScorer cs = (ConstantScoreQuery.ConstantScorer)scorer(reader);
/*  87 */       boolean exists = (cs.docIdSetIterator.skipTo(doc) && cs.docIdSetIterator.doc() == doc);
/*     */       
/*  89 */       ComplexExplanation result = new ComplexExplanation();
/*     */       
/*  91 */       if (exists) {
/*  92 */         result.setDescription(""ConstantScoreQuery("" + ConstantScoreQuery.this.filter + ""), product of:"");
/*     */         
/*  94 */         result.setValue(this.queryWeight);
/*  95 */         result.setMatch(Boolean.TRUE);
/*  96 */         result.addDetail(new Explanation(ConstantScoreQuery.this.getBoost(), ""boost""));
/*  97 */         result.addDetail(new Explanation(this.queryNorm, ""queryNorm""));
/*     */       } else {
/*  99 */         result.setDescription(""ConstantScoreQuery("" + ConstantScoreQuery.this.filter + "") doesn't match id "" + doc);
/*     */         
/* 101 */         result.setValue(0.0F);
/* 102 */         result.setMatch(Boolean.FALSE);
/*     */       } 
/* 104 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   protected class ConstantScorer extends Scorer {
/*     */     final DocIdSetIterator docIdSetIterator;
/*     */     final float theScore;
/* 111 */     int doc = -1;
/*     */     
/*     */     public ConstantScorer(Similarity similarity, IndexReader reader, Weight w) throws IOException {
/* 114 */       super(similarity);
/* 115 */       this.theScore = w.getValue();
/* 116 */       this.docIdSetIterator = ConstantScoreQuery.this.filter.getDocIdSet(reader).iterator();
/*     */     }
/*     */     private final ConstantScoreQuery this$0;
/*     */     
/* 120 */     public boolean next() throws IOException { return this.docIdSetIterator.next(); }
/*     */ 
/*     */ 
/*     */     
/* 124 */     public int doc() { return this.docIdSetIterator.doc(); }
/*     */ 
/*     */ 
/*     */     
/* 128 */     public float score() throws IOException { return this.theScore; }
/*     */ 
/*     */ 
/*     */     
/* 132 */     public boolean skipTo(int target) throws IOException { return this.docIdSetIterator.skipTo(target); }
/*     */ 
/*     */ 
/*     */     
/* 136 */     public Explanation explain(int doc) throws IOException { throw new UnsupportedOperationException(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 142 */   protected Weight createWeight(Searcher searcher) { return new ConstantWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 149 */   public String toString(String field) { return ""ConstantScore("" + this.filter.toString() + ((getBoost() == 1.0D) ? "")"" : (""^"" + getBoost())); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 155 */     if (this == o) return true; 
/* 156 */     if (!(o instanceof ConstantScoreQuery)) return false; 
/* 157 */     ConstantScoreQuery other = (ConstantScoreQuery)o;
/* 158 */     return (getBoost() == other.getBoost() && this.filter.equals(other.filter));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 164 */   public int hashCode() { return this.filter.hashCode() + Float.floatToIntBits(getBoost()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ConstantScoreQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConstantScoreRangeQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.text.Collator;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ConstantScoreRangeQuery
/*     */   extends Query
/*     */ {
/*     */   private final String fieldName;
/*     */   private final String lowerVal;
/*     */   private final String upperVal;
/*     */   private final boolean includeLower;
/*     */   private final boolean includeUpper;
/*     */   private Collator collator;
/*     */   
/*     */   public ConstantScoreRangeQuery(String fieldName, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
/*  53 */     if (lowerVal == null) {
/*  54 */       includeLower = true;
/*  55 */     } else if (includeLower && lowerVal.equals("""")) {
/*  56 */       lowerVal = null;
/*     */     } 
/*  58 */     if (upperVal == null) {
/*  59 */       includeUpper = true;
/*     */     }
/*     */ 
/*     */     
/*  63 */     this.fieldName = fieldName.intern();
/*  64 */     this.lowerVal = lowerVal;
/*  65 */     this.upperVal = upperVal;
/*  66 */     this.includeLower = includeLower;
/*  67 */     this.includeUpper = includeUpper;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public ConstantScoreRangeQuery(String fieldName, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper, Collator collator) {
/*  74 */     this(fieldName, lowerVal, upperVal, includeLower, includeUpper);
/*  75 */     this.collator = collator;
/*     */   }
/*     */ 
/*     */   
/*  79 */   public String getField() { return this.fieldName; }
/*     */   
/*  81 */   public String getLowerVal() { return this.lowerVal; }
/*     */   
/*  83 */   public String getUpperVal() { return this.upperVal; }
/*     */   
/*  85 */   public boolean includesLower() { return this.includeLower; }
/*     */   
/*  87 */   public boolean includesUpper() { return this.includeUpper; }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  91 */     RangeFilter rangeFilt = new RangeFilter(this.fieldName, (this.lowerVal != null) ? this.lowerVal : """", this.upperVal, (this.lowerVal == """") ? false : this.includeLower, (this.upperVal == null) ? false : this.includeUpper, this.collator);
/*     */ 
/*     */ 
/*     */     
/*  95 */     Query q = new ConstantScoreQuery(rangeFilt);
/*  96 */     q.setBoost(getBoost());
/*  97 */     return q;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 103 */     StringBuffer buffer = new StringBuffer();
/* 104 */     if (!getField().equals(field)) {
/*     */       
/* 106 */       buffer.append(getField());
/* 107 */       buffer.append("":"");
/*     */     } 
/* 109 */     buffer.append(this.includeLower ? 91 : 123);
/* 110 */     buffer.append((this.lowerVal != null) ? this.lowerVal : ""*"");
/* 111 */     buffer.append("" TO "");
/* 112 */     buffer.append((this.upperVal != null) ? this.upperVal : ""*"");
/* 113 */     buffer.append(this.includeUpper ? 93 : 125);
/* 114 */     if (getBoost() != 1.0F) {
/*     */       
/* 116 */       buffer.append(""^"");
/* 117 */       buffer.append(Float.toString(getBoost()));
/*     */     } 
/* 119 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 124 */     if (this == o) return true; 
/* 125 */     if (!(o instanceof ConstantScoreRangeQuery)) return false; 
/* 126 */     ConstantScoreRangeQuery other = (ConstantScoreRangeQuery)o;
/*     */     
/* 128 */     if (this.fieldName != other.fieldName || this.includeLower != other.includeLower || this.includeUpper != other.includeUpper || (this.collator != null && !this.collator.equals(other.collator)))
/*     */     {
/*     */ 
/*     */       
/* 132 */       return false; } 
/* 133 */     if ((this.lowerVal != null) ? !this.lowerVal.equals(other.lowerVal) : (other.lowerVal != null)) return false; 
/* 134 */     if ((this.upperVal != null) ? !this.upperVal.equals(other.upperVal) : (other.upperVal != null)) return false; 
/* 135 */     return (getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 140 */     int h = Float.floatToIntBits(getBoost()) ^ this.fieldName.hashCode();
/*     */     
/* 142 */     h ^= (this.lowerVal != null) ? this.lowerVal.hashCode() : -1772448166;
/*     */ 
/*     */     
/* 145 */     h ^= h << 17 | h >>> 16;
/* 146 */     h ^= (this.upperVal != null) ? this.upperVal.hashCode() : 1516853865;
/* 147 */     h ^= (this.includeLower ? 1716885930 : 0) ^ (this.includeUpper ? -1716890266 : 0);
/*     */     
/* 149 */     h ^= (this.collator != null) ? this.collator.hashCode() : 0;
/* 150 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ConstantScoreRangeQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DefaultSimilarity,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DefaultSimilarity
/*    */   extends Similarity
/*    */ {
/* 24 */   public float lengthNorm(String fieldName, int numTerms) { return (float)(1.0D / Math.sqrt(numTerms)); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 29 */   public float queryNorm(float sumOfSquaredWeights) { return (float)(1.0D / Math.sqrt(sumOfSquaredWeights)); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 34 */   public float tf(float freq) { return (float)Math.sqrt(freq); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 39 */   public float sloppyFreq(int distance) { return 1.0F / (distance + 1); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   public float idf(int docFreq, int numDocs) { return (float)(Math.log(numDocs / (docFreq + 1)) + 1.0D); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 49 */   public float coord(int overlap, int maxOverlap) { return overlap / maxOverlap; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\DefaultSimilarity.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionMaxQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DisjunctionMaxQuery
/*     */   extends Query
/*     */ {
/*  44 */   private ArrayList disjuncts = new ArrayList();
/*     */ 
/*     */   
/*  47 */   private float tieBreakerMultiplier = 0.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   public DisjunctionMaxQuery(float tieBreakerMultiplier) { this.tieBreakerMultiplier = tieBreakerMultiplier; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DisjunctionMaxQuery(Collection disjuncts, float tieBreakerMultiplier) {
/*  65 */     this.tieBreakerMultiplier = tieBreakerMultiplier;
/*  66 */     add(disjuncts);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  73 */   public void add(Query query) { this.disjuncts.add(query); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   public void add(Collection disjuncts) { this.disjuncts.addAll(disjuncts); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public Iterator iterator() { return this.disjuncts.iterator(); }
/*     */ 
/*     */   
/*     */   private class DisjunctionMaxWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*  92 */     private ArrayList weights = new ArrayList();
/*     */     private final DisjunctionMaxQuery this$0;
/*     */     
/*     */     public DisjunctionMaxWeight(Searcher searcher) throws IOException {
/*  96 */       this.similarity = searcher.getSimilarity();
/*  97 */       for (int i = 0; i < DisjunctionMaxQuery.this.disjuncts.size(); i++) {
/*  98 */         this.weights.add(((Query)DisjunctionMaxQuery.this.disjuncts.get(i)).createWeight(searcher));
/*     */       }
/*     */     }
/*     */     
/* 102 */     public Query getQuery() { return DisjunctionMaxQuery.this; }
/*     */ 
/*     */     
/* 105 */     public float getValue() { return DisjunctionMaxQuery.this.getBoost(); }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 109 */       float max = 0.0F, sum = 0.0F;
/* 110 */       for (int i = 0; i < this.weights.size(); i++) {
/* 111 */         float sub = ((Weight)this.weights.get(i)).sumOfSquaredWeights();
/* 112 */         sum += sub;
/* 113 */         max = Math.max(max, sub);
/*     */       } 
/* 115 */       return ((sum - max) * DisjunctionMaxQuery.this.tieBreakerMultiplier * DisjunctionMaxQuery.this.tieBreakerMultiplier + max) * DisjunctionMaxQuery.this.getBoost() * DisjunctionMaxQuery.this.getBoost();
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 120 */       norm *= DisjunctionMaxQuery.this.getBoost();
/* 121 */       for (int i = 0; i < this.weights.size(); i++) {
/* 122 */         ((Weight)this.weights.get(i)).normalize(norm);
/*     */       }
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 127 */       DisjunctionMaxScorer result = new DisjunctionMaxScorer(DisjunctionMaxQuery.this.tieBreakerMultiplier, this.similarity);
/* 128 */       for (int i = 0; i < this.weights.size(); i++) {
/* 129 */         Weight w = this.weights.get(i);
/* 130 */         Scorer subScorer = w.scorer(reader);
/* 131 */         if (subScorer == null) return null; 
/* 132 */         result.add(subScorer);
/*     */       } 
/* 134 */       return result;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 139 */       if (DisjunctionMaxQuery.this.disjuncts.size() == 1) return ((Weight)this.weights.get(0)).explain(reader, doc); 
/* 140 */       ComplexExplanation result = new ComplexExplanation();
/* 141 */       float max = 0.0F, sum = 0.0F;
/* 142 */       result.setDescription((DisjunctionMaxQuery.this.tieBreakerMultiplier == 0.0F) ? ""max of:"" : (""max plus "" + DisjunctionMaxQuery.this.tieBreakerMultiplier + "" times others of:""));
/* 143 */       for (int i = 0; i < this.weights.size(); i++) {
/* 144 */         Explanation e = ((Weight)this.weights.get(i)).explain(reader, doc);
/* 145 */         if (e.isMatch()) {
/* 146 */           result.setMatch(Boolean.TRUE);
/* 147 */           result.addDetail(e);
/* 148 */           sum += e.getValue();
/* 149 */           max = Math.max(max, e.getValue());
/*     */         } 
/*     */       } 
/* 152 */       result.setValue(max + (sum - max) * DisjunctionMaxQuery.this.tieBreakerMultiplier);
/* 153 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   protected Weight createWeight(Searcher searcher) throws IOException { return new DisjunctionMaxWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 167 */     if (this.disjuncts.size() == 1) {
/* 168 */       Query singleton = this.disjuncts.get(0);
/* 169 */       Query result = singleton.rewrite(reader);
/* 170 */       if (getBoost() != 1.0F) {
/* 171 */         if (result == singleton) result = (Query)result.clone(); 
/* 172 */         result.setBoost(getBoost() * result.getBoost());
/*     */       } 
/* 174 */       return result;
/*     */     } 
/* 176 */     DisjunctionMaxQuery clone = null;
/* 177 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 178 */       Query clause = this.disjuncts.get(i);
/* 179 */       Query rewrite = clause.rewrite(reader);
/* 180 */       if (rewrite != clause) {
/* 181 */         if (clone == null) clone = (DisjunctionMaxQuery)clone(); 
/* 182 */         clone.disjuncts.set(i, rewrite);
/*     */       } 
/*     */     } 
/* 185 */     if (clone != null) return clone; 
/* 186 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 192 */     DisjunctionMaxQuery clone = (DisjunctionMaxQuery)super.clone();
/* 193 */     clone.disjuncts = (ArrayList)this.disjuncts.clone();
/* 194 */     return clone;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 200 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 201 */       ((Query)this.disjuncts.get(i)).extractTerms(terms);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 211 */     StringBuffer buffer = new StringBuffer();
/* 212 */     buffer.append(""("");
/* 213 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 214 */       Query subquery = this.disjuncts.get(i);
/* 215 */       if (subquery instanceof BooleanQuery) {
/* 216 */         buffer.append(""("");
/* 217 */         buffer.append(subquery.toString(field));
/* 218 */         buffer.append("")"");
/*     */       } else {
/* 220 */         buffer.append(subquery.toString(field));
/* 221 */       }  if (i != this.disjuncts.size() - 1) buffer.append("" | ""); 
/*     */     } 
/* 223 */     buffer.append("")"");
/* 224 */     if (this.tieBreakerMultiplier != 0.0F) {
/* 225 */       buffer.append(""~"");
/* 226 */       buffer.append(this.tieBreakerMultiplier);
/*     */     } 
/* 228 */     if (getBoost() != 1.0D) {
/* 229 */       buffer.append(""^"");
/* 230 */       buffer.append(getBoost());
/*     */     } 
/* 232 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 240 */     if (!(o instanceof DisjunctionMaxQuery)) return false; 
/* 241 */     DisjunctionMaxQuery other = (DisjunctionMaxQuery)o;
/* 242 */     return (getBoost() == other.getBoost() && this.tieBreakerMultiplier == other.tieBreakerMultiplier && this.disjuncts.equals(other.disjuncts));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 251 */   public int hashCode() { return Float.floatToIntBits(getBoost()) + Float.floatToIntBits(this.tieBreakerMultiplier) + this.disjuncts.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\DisjunctionMaxQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionMaxScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DisjunctionMaxScorer
/*     */   extends Scorer
/*     */ {
/*  31 */   private ArrayList subScorers = new ArrayList();
/*     */ 
/*     */   
/*     */   private float tieBreakerMultiplier;
/*     */ 
/*     */   
/*     */   private boolean more = false;
/*     */   
/*     */   private boolean firstTime = true;
/*     */ 
/*     */   
/*     */   public DisjunctionMaxScorer(float tieBreakerMultiplier, Similarity similarity) {
/*  43 */     super(similarity);
/*  44 */     this.tieBreakerMultiplier = tieBreakerMultiplier;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Scorer scorer) throws IOException {
/*  51 */     if (scorer.next()) {
/*  52 */       this.subScorers.add(scorer);
/*  53 */       this.more = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/*  61 */     if (!this.more) return false; 
/*  62 */     if (this.firstTime) {
/*  63 */       heapify();
/*  64 */       this.firstTime = false;
/*  65 */       return true;
/*     */     } 
/*     */     
/*  68 */     int lastdoc = ((Scorer)this.subScorers.get(0)).doc();
/*     */     do {
/*  70 */       if (((Scorer)this.subScorers.get(0)).next()) {
/*  71 */         heapAdjust(0);
/*     */       } else {
/*  73 */         heapRemoveRoot();
/*  74 */         if (this.subScorers.isEmpty()) return this.more = false; 
/*     */       } 
/*  76 */     } while (((Scorer)this.subScorers.get(0)).doc() == lastdoc);
/*  77 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   public int doc() { return ((Scorer)this.subScorers.get(0)).doc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float score() throws IOException {
/*  91 */     int doc = ((Scorer)this.subScorers.get(0)).doc();
/*  92 */     float[] sum = { ((Scorer)this.subScorers.get(0)).score() }, max = { sum[0] };
/*  93 */     int size = this.subScorers.size();
/*  94 */     scoreAll(1, size, doc, sum, max);
/*  95 */     scoreAll(2, size, doc, sum, max);
/*  96 */     return max[0] + (sum[0] - max[0]) * this.tieBreakerMultiplier;
/*     */   }
/*     */ 
/*     */   
/*     */   private void scoreAll(int root, int size, int doc, float[] sum, float[] max) throws IOException {
/* 101 */     if (root < size && ((Scorer)this.subScorers.get(root)).doc() == doc) {
/* 102 */       float sub = ((Scorer)this.subScorers.get(root)).score();
/* 103 */       sum[0] = sum[0] + sub;
/* 104 */       max[0] = Math.max(max[0], sub);
/* 105 */       scoreAll((root << 1) + 1, size, doc, sum, max);
/* 106 */       scoreAll((root << 1) + 2, size, doc, sum, max);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 115 */     if (this.firstTime) {
/* 116 */       if (!this.more) return false; 
/* 117 */       heapify();
/* 118 */       this.firstTime = false;
/*     */     } 
/*     */     
/* 121 */     while (this.subScorers.size() > 0 && ((Scorer)this.subScorers.get(0)).doc() < target) {
/* 122 */       if (((Scorer)this.subScorers.get(0)).skipTo(target)) {
/* 123 */         heapAdjust(0); continue;
/*     */       } 
/* 125 */       heapRemoveRoot();
/*     */     } 
/* 127 */     if (this.subScorers.size() == 0)
/* 128 */       return this.more = false; 
/* 129 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 137 */   public Explanation explain(int doc) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void heapify() {
/* 142 */     int size = this.subScorers.size();
/* 143 */     for (int i = (size >> 1) - 1; i >= 0; i--) {
/* 144 */       heapAdjust(i);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void heapAdjust(int root) {
/* 151 */     Scorer scorer = this.subScorers.get(root);
/* 152 */     int doc = scorer.doc();
/* 153 */     int i = root, size = this.subScorers.size();
/* 154 */     while (i <= (size >> 1) - 1) {
/* 155 */       int lchild = (i << 1) + 1;
/* 156 */       Scorer lscorer = this.subScorers.get(lchild);
/* 157 */       int ldoc = lscorer.doc();
/* 158 */       int rdoc = Integer.MAX_VALUE, rchild = (i << 1) + 2;
/* 159 */       Scorer rscorer = null;
/* 160 */       if (rchild < size) {
/* 161 */         rscorer = this.subScorers.get(rchild);
/* 162 */         rdoc = rscorer.doc();
/*     */       } 
/* 164 */       if (ldoc < doc) {
/* 165 */         if (rdoc < ldoc) {
/* 166 */           this.subScorers.set(i, rscorer);
/* 167 */           this.subScorers.set(rchild, scorer);
/* 168 */           i = rchild; continue;
/*     */         } 
/* 170 */         this.subScorers.set(i, lscorer);
/* 171 */         this.subScorers.set(lchild, scorer);
/* 172 */         i = lchild; continue;
/*     */       } 
/* 174 */       if (rdoc < doc) {
/* 175 */         this.subScorers.set(i, rscorer);
/* 176 */         this.subScorers.set(rchild, scorer);
/* 177 */         i = rchild;
/*     */         continue;
/*     */       } 
/*     */       return;
/*     */     } 
/*     */   }
/*     */   private void heapRemoveRoot() {
/* 184 */     int size = this.subScorers.size();
/* 185 */     if (size == 1) {
/* 186 */       this.subScorers.remove(0);
/*     */     } else {
/* 188 */       this.subScorers.set(0, this.subScorers.get(size - 1));
/* 189 */       this.subScorers.remove(size - 1);
/* 190 */       heapAdjust(0);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\DisjunctionMaxScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionSumScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.util.ScorerDocQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DisjunctionSumScorer
/*     */   extends Scorer
/*     */ {
/*     */   private final int nrScorers;
/*     */   protected final List subScorers;
/*     */   private final int minimumNrMatchers;
/*  52 */   private ScorerDocQueue scorerDocQueue = null;
/*  53 */   private int queueSize = -1;
/*     */ 
/*     */   
/*  56 */   private int currentDoc = -1;
/*     */ 
/*     */   
/*  59 */   protected int nrMatchers = -1;
/*     */   
/*  61 */   private float currentScore = NaNF;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DisjunctionSumScorer(List subScorers, int minimumNrMatchers) {
/*  74 */     super(null);
/*     */     
/*  76 */     this.nrScorers = subScorers.size();
/*     */     
/*  78 */     if (minimumNrMatchers <= 0) {
/*  79 */       throw new IllegalArgumentException(""Minimum nr of matchers must be positive"");
/*     */     }
/*  81 */     if (this.nrScorers <= 1) {
/*  82 */       throw new IllegalArgumentException(""There must be at least 2 subScorers"");
/*     */     }
/*     */     
/*  85 */     this.minimumNrMatchers = minimumNrMatchers;
/*  86 */     this.subScorers = subScorers;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  93 */   public DisjunctionSumScorer(List subScorers) { this(subScorers, 1); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void initScorerDocQueue() throws IOException {
/* 100 */     Iterator si = this.subScorers.iterator();
/* 101 */     this.scorerDocQueue = new ScorerDocQueue(this.nrScorers);
/* 102 */     this.queueSize = 0;
/* 103 */     while (si.hasNext()) {
/* 104 */       Scorer se = si.next();
/* 105 */       if (se.next() && 
/* 106 */         this.scorerDocQueue.insert(se)) {
/* 107 */         this.queueSize++;
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/* 119 */     while (next()) {
/* 120 */       hc.collect(this.currentDoc, this.currentScore);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 133 */     while (this.currentDoc < max) {
/* 134 */       hc.collect(this.currentDoc, this.currentScore);
/* 135 */       if (!next()) {
/* 136 */         return false;
/*     */       }
/*     */     } 
/* 139 */     return true;
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/* 143 */     if (this.scorerDocQueue == null) {
/* 144 */       initScorerDocQueue();
/*     */     }
/* 146 */     return (this.scorerDocQueue.size() >= this.minimumNrMatchers && advanceAfterCurrent());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean advanceAfterCurrent() throws IOException {
/*     */     do {
/* 171 */       this.currentDoc = this.scorerDocQueue.topDoc();
/* 172 */       this.currentScore = this.scorerDocQueue.topScore();
/* 173 */       this.nrMatchers = 1;
/*     */       
/* 175 */       while (this.scorerDocQueue.topNextAndAdjustElsePop() || 
/* 176 */         --this.queueSize != 0) {
/*     */ 
/*     */ 
/*     */         
/* 180 */         if (this.scorerDocQueue.topDoc() != this.currentDoc) {
/*     */           break;
/*     */         }
/* 183 */         this.currentScore += this.scorerDocQueue.topScore();
/* 184 */         this.nrMatchers++;
/*     */       } 
/*     */       
/* 187 */       if (this.nrMatchers >= this.minimumNrMatchers)
/* 188 */         return true; 
/* 189 */     } while (this.queueSize >= this.minimumNrMatchers);
/* 190 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 198 */   public float score() throws IOException { return this.currentScore; }
/*     */   
/* 200 */   public int doc() { return this.currentDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 206 */   public int nrMatchers() { return this.nrMatchers; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 217 */     if (this.scorerDocQueue == null) {
/* 218 */       initScorerDocQueue();
/*     */     }
/* 220 */     if (this.queueSize < this.minimumNrMatchers) {
/* 221 */       return false;
/*     */     }
/* 223 */     if (target <= this.currentDoc) {
/* 224 */       return true;
/*     */     }
/*     */     do {
/* 227 */       if (this.scorerDocQueue.topDoc() >= target)
/* 228 */         return advanceAfterCurrent(); 
/* 229 */     } while (this.scorerDocQueue.topSkipToAndAdjustElsePop(target) || 
/* 230 */       --this.queueSize >= this.minimumNrMatchers);
/* 231 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 239 */     Explanation res = new Explanation();
/* 240 */     Iterator ssi = this.subScorers.iterator();
/* 241 */     float sumScore = 0.0F;
/* 242 */     int nrMatches = 0;
/* 243 */     while (ssi.hasNext()) {
/* 244 */       Explanation es = ((Scorer)ssi.next()).explain(doc);
/* 245 */       if (es.getValue() > 0.0F) {
/* 246 */         sumScore += es.getValue();
/* 247 */         nrMatches++;
/*     */       } 
/* 249 */       res.addDetail(es);
/*     */     } 
/* 251 */     if (this.nrMatchers >= this.minimumNrMatchers) {
/* 252 */       res.setValue(sumScore);
/* 253 */       res.setDescription(""sum over at least "" + this.minimumNrMatchers + "" of "" + this.subScorers.size() + "":"");
/*     */     } else {
/*     */       
/* 256 */       res.setValue(0.0F);
/* 257 */       res.setDescription(nrMatches + "" match(es) but at least "" + this.minimumNrMatchers + "" of "" + this.subScorers.size() + "" needed"");
/*     */     } 
/*     */ 
/*     */     
/* 261 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\DisjunctionSumScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DocIdSet,"package org.apache.lucene.search;
public abstract class DocIdSet {
  public abstract DocIdSetIterator iterator();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\DocIdSet.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DocIdSetIterator,"package org.apache.lucene.search;
import java.io.IOException;
public abstract class DocIdSetIterator {
  public abstract int doc();
  public abstract boolean next() throws IOException;
  public abstract boolean skipTo(int paramInt) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\DocIdSetIterator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ExactPhraseScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class ExactPhraseScorer
/*    */   extends PhraseScorer
/*    */ {
/* 27 */   ExactPhraseScorer(Weight weight, TermPositions[] tps, int[] offsets, Similarity similarity, byte[] norms) { super(weight, tps, offsets, similarity, norms); }
/*    */ 
/*    */ 
/*    */   
/*    */   protected final float phraseFreq() throws IOException {
/* 32 */     this.pq.clear();
/* 33 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 34 */       pp.firstPosition();
/* 35 */       this.pq.put(pp);
/*    */     } 
/* 37 */     pqToList();
/*    */ 
/*    */ 
/*    */     
/* 41 */     int freq = 0;
/*    */     do {
/* 43 */       while (this.first.position < this.last.position) {
/*    */         do {
/* 45 */           if (!this.first.nextPosition())
/* 46 */             return freq; 
/* 47 */         } while (this.first.position < this.last.position);
/* 48 */         firstToLast();
/*    */       } 
/* 50 */       freq++;
/* 51 */     } while (this.last.nextPosition());
/*    */     
/* 53 */     return freq;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ExactPhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Explanation,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.ArrayList;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Explanation
/*     */   implements Serializable
/*     */ {
/*     */   private float value;
/*     */   private String description;
/*     */   private ArrayList details;
/*     */   
/*     */   public Explanation() {}
/*     */   
/*     */   public Explanation(float value, String description) {
/*  31 */     this.value = value;
/*  32 */     this.description = description;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  44 */   public boolean isMatch() { return (0.0F < getValue()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public float getValue() { return this.value; }
/*     */   
/*  52 */   public void setValue(float value) { this.value = value; }
/*     */ 
/*     */   
/*  55 */   public String getDescription() { return this.description; }
/*     */ 
/*     */   
/*  58 */   public void setDescription(String description) { this.description = description; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  66 */   protected String getSummary() { return getValue() + "" = "" + getDescription(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation[] getDetails() {
/*  71 */     if (this.details == null)
/*  72 */       return null; 
/*  73 */     return (Explanation[])this.details.toArray((Object[])new Explanation[0]);
/*     */   }
/*     */ 
/*     */   
/*     */   public void addDetail(Explanation detail) {
/*  78 */     if (this.details == null)
/*  79 */       this.details = new ArrayList(); 
/*  80 */     this.details.add(detail);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  85 */   public String toString() { return toString(0); }
/*     */   
/*     */   protected String toString(int depth) {
/*  88 */     StringBuffer buffer = new StringBuffer();
/*  89 */     for (int i = 0; i < depth; i++) {
/*  90 */       buffer.append(""  "");
/*     */     }
/*  92 */     buffer.append(getSummary());
/*  93 */     buffer.append(""\n"");
/*     */     
/*  95 */     Explanation[] details = getDetails();
/*  96 */     if (details != null) {
/*  97 */       for (int i = 0; i < details.length; i++) {
/*  98 */         buffer.append(details[i].toString(depth + 1));
/*     */       }
/*     */     }
/*     */     
/* 102 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toHtml() {
/* 108 */     StringBuffer buffer = new StringBuffer();
/* 109 */     buffer.append(""<ul>\n"");
/*     */     
/* 111 */     buffer.append(""<li>"");
/* 112 */     buffer.append(getSummary());
/* 113 */     buffer.append(""<br />\n"");
/*     */     
/* 115 */     Explanation[] details = getDetails();
/* 116 */     if (details != null) {
/* 117 */       for (int i = 0; i < details.length; i++) {
/* 118 */         buffer.append(details[i].toHtml());
/*     */       }
/*     */     }
/*     */     
/* 122 */     buffer.append(""</li>\n"");
/* 123 */     buffer.append(""</ul>\n"");
/*     */     
/* 125 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Explanation.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ExtendedFieldCache,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface ExtendedFieldCache
/*    */   extends FieldCache
/*    */ {
/* 44 */   public static final ExtendedFieldCache EXT_DEFAULT = new ExtendedFieldCacheImpl();
/*    */   
/*    */   long[] getLongs(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   long[] getLongs(IndexReader paramIndexReader, String paramString, LongParser paramLongParser) throws IOException;
/*    */   
/*    */   double[] getDoubles(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   double[] getDoubles(IndexReader paramIndexReader, String paramString, DoubleParser paramDoubleParser) throws IOException;
/*    */   
/*    */   public static interface DoubleParser {
/*    */     double parseDouble(String param1String);
/*    */   }
/*    */   
/*    */   public static interface LongParser {
/*    */     long parseLong(String param1String);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ExtendedFieldCache.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ExtendedFieldCacheImpl,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class ExtendedFieldCacheImpl
/*     */   extends FieldCacheImpl
/*     */   implements ExtendedFieldCache
/*     */ {
/*  33 */   private static final ExtendedFieldCache.LongParser LONG_PARSER = new ExtendedFieldCache.LongParser()
/*     */     {
/*  35 */       public long parseLong(String value) { return Long.parseLong(value); }
/*     */     };
/*     */ 
/*     */   
/*  39 */   private static final ExtendedFieldCache.DoubleParser DOUBLE_PARSER = new ExtendedFieldCache.DoubleParser()
/*     */     {
/*  41 */       public double parseDouble(String value) { return Double.parseDouble(value); }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  47 */   public long[] getLongs(IndexReader reader, String field) throws IOException { return getLongs(reader, field, LONG_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  53 */   public long[] getLongs(IndexReader reader, String field, ExtendedFieldCache.LongParser parser) throws IOException { return (long[])this.longsCache.get(reader, new FieldCacheImpl.Entry(field, parser)); }
/*     */ 
/*     */   
/*  56 */   FieldCacheImpl.Cache longsCache = new FieldCacheImpl.Cache() {
/*     */       private final ExtendedFieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/*  60 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/*  61 */         String field = entry.field;
/*  62 */         ExtendedFieldCache.LongParser parser = (ExtendedFieldCache.LongParser)entry.custom;
/*  63 */         long[] retArray = new long[reader.maxDoc()];
/*  64 */         TermDocs termDocs = reader.termDocs();
/*  65 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/*  68 */             Term term = termEnum.term();
/*  69 */             if (term == null || term.field() != field)
/*  70 */               break;  long termval = parser.parseLong(term.text());
/*  71 */             termDocs.seek(termEnum);
/*  72 */             while (termDocs.next()) {
/*  73 */               retArray[termDocs.doc()] = termval;
/*     */             }
/*  75 */           } while (termEnum.next());
/*     */         } finally {
/*  77 */           termDocs.close();
/*  78 */           termEnum.close();
/*     */         } 
/*  80 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   public double[] getDoubles(IndexReader reader, String field) throws IOException { return getDoubles(reader, field, DOUBLE_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  93 */   public double[] getDoubles(IndexReader reader, String field, ExtendedFieldCache.DoubleParser parser) throws IOException { return (double[])this.doublesCache.get(reader, new FieldCacheImpl.Entry(field, parser)); }
/*     */ 
/*     */   
/*  96 */   FieldCacheImpl.Cache doublesCache = new FieldCacheImpl.Cache() {
/*     */       private final ExtendedFieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 100 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 101 */         String field = entry.field;
/* 102 */         ExtendedFieldCache.DoubleParser parser = (ExtendedFieldCache.DoubleParser)entry.custom;
/* 103 */         double[] retArray = new double[reader.maxDoc()];
/* 104 */         TermDocs termDocs = reader.termDocs();
/* 105 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/* 108 */             Term term = termEnum.term();
/* 109 */             if (term == null || term.field() != field)
/* 110 */               break;  double termval = parser.parseDouble(term.text());
/* 111 */             termDocs.seek(termEnum);
/* 112 */             while (termDocs.next()) {
/* 113 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 115 */           } while (termEnum.next());
/*     */         } finally {
/* 117 */           termDocs.close();
/* 118 */           termEnum.close();
/*     */         } 
/* 120 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 127 */   public Object getAuto(IndexReader reader, String field) throws IOException { return this.autoCache.get(reader, field); }
/*     */ 
/*     */   
/* 130 */   FieldCacheImpl.Cache autoCache = new FieldCacheImpl.Cache() {
/*     */       private final ExtendedFieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object fieldKey) throws IOException {
/* 134 */         String field = ((String)fieldKey).intern();
/* 135 */         TermEnum enumerator = reader.terms(new Term(field));
/*     */         try {
/* 137 */           Term term = enumerator.term();
/* 138 */           if (term == null) {
/* 139 */             throw new RuntimeException(""no terms in field "" + field + "" - cannot determine sort type"");
/*     */           }
/* 141 */           Object ret = null;
/* 142 */           if (term.field() == field) {
/* 143 */             String termtext = term.text().trim();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/*     */             try {
/* 157 */               Integer.parseInt(termtext);
/* 158 */               ret = ExtendedFieldCacheImpl.this.getInts(reader, field);
/* 159 */             } catch (NumberFormatException nfe1) {
/*     */               try {
/* 161 */                 Long.parseLong(termtext);
/* 162 */                 ret = ExtendedFieldCacheImpl.this.getLongs(reader, field);
/* 163 */               } catch (NumberFormatException nfe2) {
/*     */                 try {
/* 165 */                   Float.parseFloat(termtext);
/* 166 */                   ret = ExtendedFieldCacheImpl.this.getFloats(reader, field);
/* 167 */                 } catch (NumberFormatException nfe3) {
/* 168 */                   ret = ExtendedFieldCacheImpl.this.getStringIndex(reader, field);
/*     */                 } 
/*     */               } 
/*     */             } 
/*     */           } else {
/* 173 */             throw new RuntimeException(""field \"""" + field + ""\"" does not appear to be indexed"");
/*     */           } 
/* 175 */           return ret;
/*     */         } finally {
/* 177 */           enumerator.close();
/*     */         } 
/*     */       }
/*     */     };
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ExtendedFieldCacheImpl.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldCache,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface FieldCache
/*    */ {
/*    */   public static final int STRING_INDEX = -1;
/*    */   
/*    */   public static interface FloatParser
/*    */   {
/*    */     float parseFloat(String param1String);
/*    */   }
/*    */   
/*    */   public static interface IntParser
/*    */   {
/*    */     int parseInt(String param1String);
/*    */   }
/*    */   
/*    */   public static interface ShortParser
/*    */   {
/*    */     short parseShort(String param1String);
/*    */   }
/*    */   
/*    */   public static interface ByteParser
/*    */   {
/*    */     byte parseByte(String param1String);
/*    */   }
/*    */   
/*    */   public static class StringIndex
/*    */   {
/*    */     public final String[] lookup;
/*    */     public final int[] order;
/*    */     
/*    */     public StringIndex(int[] values, String[] lookup) {
/* 50 */       this.order = values;
/* 51 */       this.lookup = lookup;
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 88 */   public static final FieldCache DEFAULT = new FieldCacheImpl();
/*    */   
/*    */   byte[] getBytes(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   byte[] getBytes(IndexReader paramIndexReader, String paramString, ByteParser paramByteParser) throws IOException;
/*    */   
/*    */   short[] getShorts(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   short[] getShorts(IndexReader paramIndexReader, String paramString, ShortParser paramShortParser) throws IOException;
/*    */   
/*    */   int[] getInts(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   int[] getInts(IndexReader paramIndexReader, String paramString, IntParser paramIntParser) throws IOException;
/*    */   
/*    */   float[] getFloats(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   float[] getFloats(IndexReader paramIndexReader, String paramString, FloatParser paramFloatParser) throws IOException;
/*    */   
/*    */   String[] getStrings(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   StringIndex getStringIndex(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   Object getAuto(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   Comparable[] getCustom(IndexReader paramIndexReader, String paramString, SortComparator paramSortComparator) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FieldCache.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldCacheImpl,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import java.util.Locale;
/*     */ import java.util.Map;
/*     */ import java.util.WeakHashMap;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FieldCacheImpl
/*     */   implements FieldCache
/*     */ {
/*     */   static abstract class Cache
/*     */   {
/*  45 */     private final Map readerCache = new WeakHashMap();
/*     */ 
/*     */     
/*     */     protected abstract Object createValue(IndexReader param1IndexReader, Object param1Object) throws IOException;
/*     */     
/*     */     public Object get(IndexReader reader, Object key) throws IOException {
/*     */       Object value;
/*     */       Map innerCache;
/*  53 */       synchronized (this.readerCache) {
/*  54 */         innerCache = (Map)this.readerCache.get(reader);
/*  55 */         if (innerCache == null) {
/*  56 */           innerCache = new HashMap();
/*  57 */           this.readerCache.put(reader, innerCache);
/*  58 */           value = null;
/*     */         } else {
/*  60 */           value = innerCache.get(key);
/*     */         } 
/*  62 */         if (value == null) {
/*  63 */           value = new FieldCacheImpl.CreationPlaceholder();
/*  64 */           innerCache.put(key, value);
/*     */         } 
/*     */       } 
/*  67 */       if (value instanceof FieldCacheImpl.CreationPlaceholder) {
/*  68 */         synchronized (value) {
/*  69 */           FieldCacheImpl.CreationPlaceholder progress = (FieldCacheImpl.CreationPlaceholder)value;
/*  70 */           if (progress.value == null) {
/*  71 */             progress.value = createValue(reader, key);
/*  72 */             synchronized (this.readerCache) {
/*  73 */               innerCache.put(key, progress.value);
/*     */             } 
/*     */           } 
/*  76 */           return progress.value;
/*     */         } 
/*     */       }
/*  79 */       return value;
/*     */     }
/*     */   }
/*     */   
/*     */   static final class CreationPlaceholder
/*     */   {
/*     */     Object value;
/*     */   }
/*     */   
/*     */   static class Entry
/*     */   {
/*     */     final String field;
/*     */     final int type;
/*     */     final Object custom;
/*     */     final Locale locale;
/*     */     
/*     */     Entry(String field, int type, Locale locale) {
/*  96 */       this.field = field.intern();
/*  97 */       this.type = type;
/*  98 */       this.custom = null;
/*  99 */       this.locale = locale;
/*     */     }
/*     */ 
/*     */     
/*     */     Entry(String field, Object custom) {
/* 104 */       this.field = field.intern();
/* 105 */       this.type = 9;
/* 106 */       this.custom = custom;
/* 107 */       this.locale = null;
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean equals(Object o) {
/* 112 */       if (o instanceof Entry) {
/* 113 */         Entry other = (Entry)o;
/* 114 */         if (other.field == this.field && other.type == this.type && (
/* 115 */           (other.locale == null) ? (this.locale == null) : other.locale.equals(this.locale))) {
/* 116 */           if (other.custom == null) {
/* 117 */             if (this.custom == null) return true; 
/* 118 */           } else if (other.custom.equals(this.custom)) {
/* 119 */             return true;
/*     */           } 
/*     */         }
/*     */       } 
/*     */       
/* 124 */       return false;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 129 */     public int hashCode() { return this.field.hashCode() ^ this.type ^ ((this.custom == null) ? 0 : this.custom.hashCode()) ^ ((this.locale == null) ? 0 : this.locale.hashCode()); }
/*     */   }
/*     */ 
/*     */   
/* 133 */   private static final FieldCache.ByteParser BYTE_PARSER = new FieldCache.ByteParser()
/*     */     {
/* 135 */       public byte parseByte(String value) { return Byte.parseByte(value); }
/*     */     };
/*     */ 
/*     */   
/* 139 */   private static final FieldCache.ShortParser SHORT_PARSER = new FieldCache.ShortParser()
/*     */     {
/* 141 */       public short parseShort(String value) { return Short.parseShort(value); }
/*     */     };
/*     */ 
/*     */   
/* 145 */   private static final FieldCache.IntParser INT_PARSER = new FieldCache.IntParser()
/*     */     {
/* 147 */       public int parseInt(String value) { return Integer.parseInt(value); }
/*     */     };
/*     */ 
/*     */ 
/*     */   
/* 152 */   private static final FieldCache.FloatParser FLOAT_PARSER = new FieldCache.FloatParser()
/*     */     {
/* 154 */       public float parseFloat(String value) { return Float.parseFloat(value); }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public byte[] getBytes(IndexReader reader, String field) throws IOException { return getBytes(reader, field, BYTE_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 166 */   public byte[] getBytes(IndexReader reader, String field, FieldCache.ByteParser parser) throws IOException { return (byte[])this.bytesCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 169 */   Cache bytesCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 173 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 174 */         String field = entry.field;
/* 175 */         FieldCache.ByteParser parser = (FieldCache.ByteParser)entry.custom;
/* 176 */         byte[] retArray = new byte[reader.maxDoc()];
/* 177 */         TermDocs termDocs = reader.termDocs();
/* 178 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/* 181 */             Term term = termEnum.term();
/* 182 */             if (term == null || term.field() != field)
/* 183 */               break;  byte termval = parser.parseByte(term.text());
/* 184 */             termDocs.seek(termEnum);
/* 185 */             while (termDocs.next()) {
/* 186 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 188 */           } while (termEnum.next());
/*     */         } finally {
/* 190 */           termDocs.close();
/* 191 */           termEnum.close();
/*     */         } 
/* 193 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */   
/* 199 */   public short[] getShorts(IndexReader reader, String field) throws IOException { return getShorts(reader, field, SHORT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 205 */   public short[] getShorts(IndexReader reader, String field, FieldCache.ShortParser parser) throws IOException { return (short[])this.shortsCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 208 */   Cache shortsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 212 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 213 */         String field = entry.field;
/* 214 */         FieldCache.ShortParser parser = (FieldCache.ShortParser)entry.custom;
/* 215 */         short[] retArray = new short[reader.maxDoc()];
/* 216 */         TermDocs termDocs = reader.termDocs();
/* 217 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/* 220 */             Term term = termEnum.term();
/* 221 */             if (term == null || term.field() != field)
/* 222 */               break;  short termval = parser.parseShort(term.text());
/* 223 */             termDocs.seek(termEnum);
/* 224 */             while (termDocs.next()) {
/* 225 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 227 */           } while (termEnum.next());
/*     */         } finally {
/* 229 */           termDocs.close();
/* 230 */           termEnum.close();
/*     */         } 
/* 232 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */   
/* 238 */   public int[] getInts(IndexReader reader, String field) throws IOException { return getInts(reader, field, INT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 244 */   public int[] getInts(IndexReader reader, String field, FieldCache.IntParser parser) throws IOException { return (int[])this.intsCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 247 */   Cache intsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 251 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 252 */         String field = entry.field;
/* 253 */         FieldCache.IntParser parser = (FieldCache.IntParser)entry.custom;
/* 254 */         int[] retArray = new int[reader.maxDoc()];
/* 255 */         TermDocs termDocs = reader.termDocs();
/* 256 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/* 259 */             Term term = termEnum.term();
/* 260 */             if (term == null || term.field() != field)
/* 261 */               break;  int termval = parser.parseInt(term.text());
/* 262 */             termDocs.seek(termEnum);
/* 263 */             while (termDocs.next()) {
/* 264 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 266 */           } while (termEnum.next());
/*     */         } finally {
/* 268 */           termDocs.close();
/* 269 */           termEnum.close();
/*     */         } 
/* 271 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 279 */   public float[] getFloats(IndexReader reader, String field) throws IOException { return getFloats(reader, field, FLOAT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 285 */   public float[] getFloats(IndexReader reader, String field, FieldCache.FloatParser parser) throws IOException { return (float[])this.floatsCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 288 */   Cache floatsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 292 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 293 */         String field = entry.field;
/* 294 */         FieldCache.FloatParser parser = (FieldCache.FloatParser)entry.custom;
/* 295 */         float[] retArray = new float[reader.maxDoc()];
/* 296 */         TermDocs termDocs = reader.termDocs();
/* 297 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/* 300 */             Term term = termEnum.term();
/* 301 */             if (term == null || term.field() != field)
/* 302 */               break;  float termval = parser.parseFloat(term.text());
/* 303 */             termDocs.seek(termEnum);
/* 304 */             while (termDocs.next()) {
/* 305 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 307 */           } while (termEnum.next());
/*     */         } finally {
/* 309 */           termDocs.close();
/* 310 */           termEnum.close();
/*     */         } 
/* 312 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 319 */   public String[] getStrings(IndexReader reader, String field) throws IOException { return (String[])this.stringsCache.get(reader, field); }
/*     */ 
/*     */   
/* 322 */   Cache stringsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object fieldKey) throws IOException {
/* 326 */         String field = ((String)fieldKey).intern();
/* 327 */         String[] retArray = new String[reader.maxDoc()];
/* 328 */         TermDocs termDocs = reader.termDocs();
/* 329 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/* 332 */             Term term = termEnum.term();
/* 333 */             if (term == null || term.field() != field)
/* 334 */               break;  String termval = term.text();
/* 335 */             termDocs.seek(termEnum);
/* 336 */             while (termDocs.next()) {
/* 337 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 339 */           } while (termEnum.next());
/*     */         } finally {
/* 341 */           termDocs.close();
/* 342 */           termEnum.close();
/*     */         } 
/* 344 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 351 */   public FieldCache.StringIndex getStringIndex(IndexReader reader, String field) throws IOException { return (FieldCache.StringIndex)this.stringsIndexCache.get(reader, field); }
/*     */ 
/*     */   
/* 354 */   Cache stringsIndexCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object fieldKey) throws IOException {
/* 358 */         String field = ((String)fieldKey).intern();
/* 359 */         int[] retArray = new int[reader.maxDoc()];
/* 360 */         String[] mterms = new String[reader.maxDoc() + 1];
/* 361 */         TermDocs termDocs = reader.termDocs();
/* 362 */         TermEnum termEnum = reader.terms(new Term(field));
/* 363 */         int t = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 369 */         mterms[t++] = null;
/*     */         
/*     */         try {
/*     */           do {
/* 373 */             Term term = termEnum.term();
/* 374 */             if (term == null || term.field() != field) {
/*     */               break;
/*     */             }
/*     */             
/* 378 */             if (t >= mterms.length) throw new RuntimeException(""there are more terms than documents in field \"""" + field + ""\"", but it's impossible to sort on "" + ""tokenized fields"");
/*     */ 
/*     */             
/* 381 */             mterms[t] = term.text();
/*     */             
/* 383 */             termDocs.seek(termEnum);
/* 384 */             while (termDocs.next()) {
/* 385 */               retArray[termDocs.doc()] = t;
/*     */             }
/*     */             
/* 388 */             t++;
/* 389 */           } while (termEnum.next());
/*     */         } finally {
/* 391 */           termDocs.close();
/* 392 */           termEnum.close();
/*     */         } 
/*     */         
/* 395 */         if (t == 0) {
/*     */ 
/*     */           
/* 398 */           mterms = new String[1];
/* 399 */         } else if (t < mterms.length) {
/*     */ 
/*     */           
/* 402 */           String[] terms = new String[t];
/* 403 */           System.arraycopy(mterms, 0, terms, 0, t);
/* 404 */           mterms = terms;
/*     */         } 
/*     */         
/* 407 */         FieldCache.StringIndex value = new FieldCache.StringIndex(retArray, mterms);
/* 408 */         return value;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 425 */   public Object getAuto(IndexReader reader, String field) throws IOException { return this.autoCache.get(reader, field); }
/*     */ 
/*     */   
/* 428 */   Cache autoCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object fieldKey) throws IOException {
/* 432 */         String field = ((String)fieldKey).intern();
/* 433 */         TermEnum enumerator = reader.terms(new Term(field));
/*     */         try {
/* 435 */           Term term = enumerator.term();
/* 436 */           if (term == null) {
/* 437 */             throw new RuntimeException(""no terms in field "" + field + "" - cannot determine sort type"");
/*     */           }
/* 439 */           Object ret = null;
/* 440 */           if (term.field() == field) {
/* 441 */             String termtext = term.text().trim();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/*     */             try {
/* 455 */               Integer.parseInt(termtext);
/* 456 */               ret = FieldCacheImpl.this.getInts(reader, field);
/* 457 */             } catch (NumberFormatException nfe1) {
/*     */               try {
/* 459 */                 Float.parseFloat(termtext);
/* 460 */                 ret = FieldCacheImpl.this.getFloats(reader, field);
/* 461 */               } catch (NumberFormatException nfe3) {
/* 462 */                 ret = FieldCacheImpl.this.getStringIndex(reader, field);
/*     */               } 
/*     */             } 
/*     */           } else {
/* 466 */             throw new RuntimeException(""field \"""" + field + ""\"" does not appear to be indexed"");
/*     */           } 
/* 468 */           return ret;
/*     */         } finally {
/* 470 */           enumerator.close();
/*     */         } 
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 478 */   public Comparable[] getCustom(IndexReader reader, String field, SortComparator comparator) throws IOException { return (Comparable[])this.customCache.get(reader, new Entry(field, comparator)); }
/*     */ 
/*     */   
/* 481 */   Cache customCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 485 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 486 */         String field = entry.field;
/* 487 */         SortComparator comparator = (SortComparator)entry.custom;
/* 488 */         Comparable[] retArray = new Comparable[reader.maxDoc()];
/* 489 */         TermDocs termDocs = reader.termDocs();
/* 490 */         TermEnum termEnum = reader.terms(new Term(field));
/*     */         try {
/*     */           do {
/* 493 */             Term term = termEnum.term();
/* 494 */             if (term == null || term.field() != field)
/* 495 */               break;  Comparable termval = comparator.getComparable(term.text());
/* 496 */             termDocs.seek(termEnum);
/* 497 */             while (termDocs.next()) {
/* 498 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 500 */           } while (termEnum.next());
/*     */         } finally {
/* 502 */           termDocs.close();
/* 503 */           termEnum.close();
/*     */         } 
/* 505 */         return retArray;
/*     */       }
/*     */     };
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FieldCacheImpl.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldDoc,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FieldDoc
/*    */   extends ScoreDoc
/*    */ {
/*    */   public Comparable[] fields;
/*    */   
/* 55 */   public FieldDoc(int doc, float score) { super(doc, score); }
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldDoc(int doc, float score, Comparable[] fields) {
/* 60 */     super(doc, score);
/* 61 */     this.fields = fields;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FieldDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldDocSortedHitQueue,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.text.Collator;
/*     */ import java.util.Locale;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FieldDocSortedHitQueue
/*     */   extends PriorityQueue
/*     */ {
/*     */   volatile SortField[] fields;
/*     */   volatile Collator[] collators;
/*     */   
/*     */   FieldDocSortedHitQueue(SortField[] fields, int size) {
/*  52 */     this.fields = fields;
/*  53 */     this.collators = hasCollators(fields);
/*  54 */     initialize(size);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   synchronized void setFields(SortField[] fields) {
/*  67 */     if (this.fields == null) {
/*  68 */       this.fields = fields;
/*  69 */       this.collators = hasCollators(fields);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   SortField[] getFields() { return this.fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Collator[] hasCollators(SortField[] fields) {
/*  86 */     if (fields == null) return null; 
/*  87 */     Collator[] ret = new Collator[fields.length];
/*  88 */     for (int i = 0; i < fields.length; i++) {
/*  89 */       Locale locale = fields[i].getLocale();
/*  90 */       if (locale != null)
/*  91 */         ret[i] = Collator.getInstance(locale); 
/*     */     } 
/*  93 */     return ret;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final boolean lessThan(Object a, Object b) {
/* 104 */     FieldDoc docA = (FieldDoc)a;
/* 105 */     FieldDoc docB = (FieldDoc)b;
/* 106 */     int n = this.fields.length;
/* 107 */     int c = 0;
/* 108 */     for (int i = 0; i < n && c == 0; i++) {
/* 109 */       double d2; long l2; int i2, i2; String s2; float f2, r2; int i2; float r1, f1; int i1; String s1; int i1; long l1; int i1; double d1; int type = this.fields[i].getType();
/* 110 */       switch (type) {
/*     */         case 0:
/* 112 */           r1 = ((Float)docA.fields[i]).floatValue();
/* 113 */           r2 = ((Float)docB.fields[i]).floatValue();
/* 114 */           if (r1 > r2) c = -1; 
/* 115 */           if (r1 < r2) c = 1;
/*     */           
/*     */           break;
/*     */         case 1:
/*     */         case 4:
/* 120 */           i1 = ((Integer)docA.fields[i]).intValue();
/* 121 */           i2 = ((Integer)docB.fields[i]).intValue();
/* 122 */           if (i1 < i2) c = -1; 
/* 123 */           if (i1 > i2) c = 1;
/*     */           
/*     */           break;
/*     */         case 6:
/* 127 */           l1 = ((Long)docA.fields[i]).longValue();
/* 128 */           l2 = ((Long)docB.fields[i]).longValue();
/* 129 */           if (l1 < l2) c = -1; 
/* 130 */           if (l1 > l2) c = 1;
/*     */           
/*     */           break;
/*     */         case 3:
/* 134 */           s1 = (String)docA.fields[i];
/* 135 */           s2 = (String)docB.fields[i];
/*     */ 
/*     */ 
/*     */           
/* 139 */           if (s1 == null) { c = (s2 == null) ? 0 : -1; break; }
/* 140 */            if (s2 == null) { c = 1; break; }
/* 141 */            if (this.fields[i].getLocale() == null) {
/* 142 */             c = s1.compareTo(s2); break;
/*     */           } 
/* 144 */           c = this.collators[i].compare(s1, s2);
/*     */           break;
/*     */ 
/*     */         
/*     */         case 5:
/* 149 */           f1 = ((Float)docA.fields[i]).floatValue();
/* 150 */           f2 = ((Float)docB.fields[i]).floatValue();
/* 151 */           if (f1 < f2) c = -1; 
/* 152 */           if (f1 > f2) c = 1;
/*     */           
/*     */           break;
/*     */         case 7:
/* 156 */           d1 = ((Double)docA.fields[i]).doubleValue();
/* 157 */           d2 = ((Double)docB.fields[i]).doubleValue();
/* 158 */           if (d1 < d2) c = -1; 
/* 159 */           if (d1 > d2) c = 1;
/*     */           
/*     */           break;
/*     */         case 10:
/* 163 */           i1 = ((Byte)docA.fields[i]).byteValue();
/* 164 */           i2 = ((Byte)docB.fields[i]).byteValue();
/* 165 */           if (i1 < i2) c = -1; 
/* 166 */           if (i1 > i2) c = 1;
/*     */           
/*     */           break;
/*     */         case 8:
/* 170 */           i1 = ((Short)docA.fields[i]).shortValue();
/* 171 */           i2 = ((Short)docB.fields[i]).shortValue();
/* 172 */           if (i1 < i2) c = -1; 
/* 173 */           if (i1 > i2) c = 1;
/*     */           
/*     */           break;
/*     */         case 9:
/* 177 */           c = docA.fields[i].compareTo(docB.fields[i]);
/*     */           break;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*     */         case 2:
/* 185 */           throw new RuntimeException(""FieldDocSortedHitQueue cannot use an AUTO SortField"");
/*     */         
/*     */         default:
/* 188 */           throw new RuntimeException(""invalid SortField type: "" + type);
/*     */       } 
/*     */       
/* 191 */       if (this.fields[i].getReverse()) {
/* 192 */         c = -c;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 197 */     if (c == 0) {
/* 198 */       return (docA.doc > docB.doc);
/*     */     }
/* 200 */     return (c > 0);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FieldDocSortedHitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldSortedHitQueue,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.text.Collator;
/*     */ import java.util.Locale;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FieldSortedHitQueue
/*     */   extends PriorityQueue
/*     */ {
/*     */   protected ScoreDocComparator[] comparators;
/*     */   protected SortField[] fields;
/*     */   
/*     */   public FieldSortedHitQueue(IndexReader reader, SortField[] fields, int size) throws IOException {
/*  50 */     int n = fields.length;
/*  51 */     this.comparators = new ScoreDocComparator[n];
/*  52 */     this.fields = new SortField[n];
/*  53 */     for (int i = 0; i < n; i++) {
/*  54 */       String fieldname = fields[i].getField();
/*  55 */       this.comparators[i] = getCachedComparator(reader, fieldname, fields[i].getType(), fields[i].getLocale(), fields[i].getFactory());
/*     */       
/*  57 */       if (this.comparators[i].sortType() == 3) {
/*  58 */         this.fields[i] = new SortField(fieldname, fields[i].getLocale(), fields[i].getReverse());
/*     */       } else {
/*  60 */         this.fields[i] = new SortField(fieldname, this.comparators[i].sortType(), fields[i].getReverse());
/*     */       } 
/*     */     } 
/*  63 */     initialize(size);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  74 */   protected float maxscore = Float.NEGATIVE_INFINITY;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  79 */   public float getMaxScore() { return this.maxscore; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   private final void updateMaxScore(FieldDoc fdoc) { this.maxscore = Math.max(this.maxscore, fdoc.score); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean insert(FieldDoc fdoc) {
/*  91 */     updateMaxScore(fdoc);
/*  92 */     return super.insert(fdoc);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  99 */   public boolean insert(Object fdoc) { return insert((FieldDoc)fdoc); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object insertWithOverflow(Object element) {
/* 106 */     updateMaxScore((FieldDoc)element);
/* 107 */     return super.insertWithOverflow(element);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean lessThan(Object a, Object b) {
/* 117 */     ScoreDoc docA = (ScoreDoc)a;
/* 118 */     ScoreDoc docB = (ScoreDoc)b;
/*     */ 
/*     */     
/* 121 */     int n = this.comparators.length;
/* 122 */     int c = 0;
/* 123 */     for (int i = 0; i < n && c == 0; i++) {
/* 124 */       c = (this.fields[i]).reverse ? this.comparators[i].compare(docB, docA) : this.comparators[i].compare(docA, docB);
/*     */     }
/*     */ 
/*     */     
/* 128 */     if (c == 0)
/* 129 */       return (docA.doc > docB.doc); 
/* 130 */     return (c > 0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldDoc fillFields(FieldDoc doc) {
/* 145 */     int n = this.comparators.length;
/* 146 */     Comparable[] fields = new Comparable[n];
/* 147 */     for (int i = 0; i < n; i++)
/* 148 */       fields[i] = this.comparators[i].sortValue(doc); 
/* 149 */     doc.fields = fields;
/*     */     
/* 151 */     return doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 157 */   SortField[] getFields() { return this.fields; }
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator getCachedComparator(IndexReader reader, String field, int type, Locale locale, SortComparatorSource factory) throws IOException {
/* 162 */     if (type == 1) return ScoreDocComparator.INDEXORDER; 
/* 163 */     if (type == 0) return ScoreDocComparator.RELEVANCE; 
/* 164 */     FieldCacheImpl.Entry entry = (factory != null) ? new FieldCacheImpl.Entry(field, factory) : new FieldCacheImpl.Entry(field, type, locale);
/*     */ 
/*     */     
/* 167 */     return (ScoreDocComparator)Comparators.get(reader, entry);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 172 */   static final FieldCacheImpl.Cache Comparators = new FieldCacheImpl.Cache()
/*     */     {
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/*     */         ScoreDocComparator comparator;
/* 176 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 177 */         String fieldname = entry.field;
/* 178 */         int type = entry.type;
/* 179 */         Locale locale = entry.locale;
/* 180 */         SortComparatorSource factory = (SortComparatorSource)entry.custom;
/*     */         
/* 182 */         switch (type) {
/*     */           case 2:
/* 184 */             comparator = FieldSortedHitQueue.comparatorAuto(reader, fieldname);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 214 */             return comparator;case 4: comparator = FieldSortedHitQueue.comparatorInt(reader, fieldname); return comparator;case 5: comparator = FieldSortedHitQueue.comparatorFloat(reader, fieldname); return comparator;case 6: comparator = FieldSortedHitQueue.comparatorLong(reader, fieldname); return comparator;case 7: comparator = FieldSortedHitQueue.comparatorDouble(reader, fieldname); return comparator;case 8: comparator = FieldSortedHitQueue.comparatorShort(reader, fieldname); return comparator;case 10: comparator = FieldSortedHitQueue.comparatorByte(reader, fieldname); return comparator;case 3: if (locale != null) { comparator = FieldSortedHitQueue.comparatorStringLocale(reader, fieldname, locale); } else { comparator = FieldSortedHitQueue.comparatorString(reader, fieldname); }  return comparator;case 9: comparator = factory.newComparator(reader, fieldname); return comparator;
/*     */         } 
/*     */         throw new RuntimeException(""unknown field type: "" + type);
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorByte(IndexReader reader, String fieldname) throws IOException {
/* 227 */     String field = fieldname.intern();
/* 228 */     final byte[] fieldOrder = FieldCache.DEFAULT.getBytes(reader, field);
/* 229 */     return new ScoreDocComparator() { private final byte[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 232 */           int fi = fieldOrder[i.doc];
/* 233 */           int fj = fieldOrder[j.doc];
/* 234 */           if (fi < fj) return -1; 
/* 235 */           if (fi > fj) return 1; 
/* 236 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 240 */         public Comparable sortValue(ScoreDoc i) { return new Byte(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 244 */         public int sortType() { return 4; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorShort(IndexReader reader, String fieldname) throws IOException {
/* 258 */     String field = fieldname.intern();
/* 259 */     final short[] fieldOrder = FieldCache.DEFAULT.getShorts(reader, field);
/* 260 */     return new ScoreDocComparator() { private final short[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 263 */           int fi = fieldOrder[i.doc];
/* 264 */           int fj = fieldOrder[j.doc];
/* 265 */           if (fi < fj) return -1; 
/* 266 */           if (fi > fj) return 1; 
/* 267 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 271 */         public Comparable sortValue(ScoreDoc i) { return new Short(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 275 */         public int sortType() { return 8; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorInt(IndexReader reader, String fieldname) throws IOException {
/* 289 */     String field = fieldname.intern();
/* 290 */     final int[] fieldOrder = FieldCache.DEFAULT.getInts(reader, field);
/* 291 */     return new ScoreDocComparator() { private final int[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 294 */           int fi = fieldOrder[i.doc];
/* 295 */           int fj = fieldOrder[j.doc];
/* 296 */           if (fi < fj) return -1; 
/* 297 */           if (fi > fj) return 1; 
/* 298 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 302 */         public Comparable sortValue(ScoreDoc i) { return new Integer(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 306 */         public int sortType() { return 4; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorLong(IndexReader reader, String fieldname) throws IOException {
/* 320 */     String field = fieldname.intern();
/* 321 */     final long[] fieldOrder = ExtendedFieldCache.EXT_DEFAULT.getLongs(reader, field);
/* 322 */     return new ScoreDocComparator() { private final long[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 325 */           long li = fieldOrder[i.doc];
/* 326 */           long lj = fieldOrder[j.doc];
/* 327 */           if (li < lj) return -1; 
/* 328 */           if (li > lj) return 1; 
/* 329 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 333 */         public Comparable sortValue(ScoreDoc i) { return new Long(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 337 */         public int sortType() { return 6; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorFloat(IndexReader reader, String fieldname) throws IOException {
/* 352 */     String field = fieldname.intern();
/* 353 */     final float[] fieldOrder = FieldCache.DEFAULT.getFloats(reader, field);
/* 354 */     return new ScoreDocComparator() { private final float[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 357 */           float fi = fieldOrder[i.doc];
/* 358 */           float fj = fieldOrder[j.doc];
/* 359 */           if (fi < fj) return -1; 
/* 360 */           if (fi > fj) return 1; 
/* 361 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 365 */         public Comparable sortValue(ScoreDoc i) { return new Float(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 369 */         public int sortType() { return 5; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorDouble(IndexReader reader, String fieldname) throws IOException {
/* 383 */     String field = fieldname.intern();
/* 384 */     final double[] fieldOrder = ExtendedFieldCache.EXT_DEFAULT.getDoubles(reader, field);
/* 385 */     return new ScoreDocComparator() { private final double[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 388 */           double di = fieldOrder[i.doc];
/* 389 */           double dj = fieldOrder[j.doc];
/* 390 */           if (di < dj) return -1; 
/* 391 */           if (di > dj) return 1; 
/* 392 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 396 */         public Comparable sortValue(ScoreDoc i) { return new Double(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 400 */         public int sortType() { return 7; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorString(IndexReader reader, String fieldname) throws IOException {
/* 414 */     String field = fieldname.intern();
/* 415 */     final FieldCache.StringIndex index = FieldCache.DEFAULT.getStringIndex(reader, field);
/* 416 */     return new ScoreDocComparator() { private final FieldCache.StringIndex val$index;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 419 */           int fi = index.order[i.doc];
/* 420 */           int fj = index.order[j.doc];
/* 421 */           if (fi < fj) return -1; 
/* 422 */           if (fi > fj) return 1; 
/* 423 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 427 */         public Comparable sortValue(ScoreDoc i) { return index.lookup[index.order[i.doc]]; }
/*     */ 
/*     */ 
/*     */         
/* 431 */         public int sortType() { return 3; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorStringLocale(IndexReader reader, String fieldname, Locale locale) throws IOException {
/* 445 */     final Collator collator = Collator.getInstance(locale);
/* 446 */     String field = fieldname.intern();
/* 447 */     final String[] index = FieldCache.DEFAULT.getStrings(reader, field);
/* 448 */     return new ScoreDocComparator() { private final String[] val$index; private final Collator val$collator;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 451 */           String is = index[i.doc];
/* 452 */           String js = index[j.doc];
/* 453 */           if (is == js)
/* 454 */             return 0; 
/* 455 */           if (is == null)
/* 456 */             return -1; 
/* 457 */           if (js == null) {
/* 458 */             return 1;
/*     */           }
/* 460 */           return collator.compare(is, js);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 465 */         public Comparable sortValue(ScoreDoc i) { return index[i.doc]; }
/*     */ 
/*     */ 
/*     */         
/* 469 */         public int sortType() { return 3; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorAuto(IndexReader reader, String fieldname) throws IOException {
/* 486 */     String field = fieldname.intern();
/* 487 */     Object lookupArray = ExtendedFieldCache.EXT_DEFAULT.getAuto(reader, field);
/* 488 */     if (lookupArray instanceof FieldCache.StringIndex)
/* 489 */       return comparatorString(reader, field); 
/* 490 */     if (lookupArray instanceof int[])
/* 491 */       return comparatorInt(reader, field); 
/* 492 */     if (lookupArray instanceof long[])
/* 493 */       return comparatorLong(reader, field); 
/* 494 */     if (lookupArray instanceof float[])
/* 495 */       return comparatorFloat(reader, field); 
/* 496 */     if (lookupArray instanceof String[]) {
/* 497 */       return comparatorString(reader, field);
/*     */     }
/* 499 */     throw new RuntimeException(""unknown data type in field '"" + field + ""'"");
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FieldSortedHitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Filter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Serializable;
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.util.DocIdBitSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Filter
/*    */   implements Serializable
/*    */ {
/* 40 */   public BitSet bits(IndexReader reader) throws IOException { return null; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 49 */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException { return (DocIdSet)new DocIdBitSet(bits(reader)); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Filter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilteredQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilteredQuery
/*     */   extends Query
/*     */ {
/*     */   Query query;
/*     */   Filter filter;
/*     */   
/*     */   public FilteredQuery(Query query, Filter filter) {
/*  53 */     this.query = query;
/*  54 */     this.filter = filter;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Weight createWeight(Searcher searcher) throws IOException {
/*  64 */     final Weight weight = this.query.createWeight(searcher);
/*  65 */     final Similarity similarity = this.query.getSimilarity(searcher);
/*  66 */     return new Weight() { private float value; private final Weight val$weight;
/*     */         private final Similarity val$similarity;
/*     */         private final FilteredQuery this$0;
/*     */         
/*  70 */         public float getValue() { return this.value; }
/*     */         
/*  72 */         public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights() * FilteredQuery.this.getBoost() * FilteredQuery.this.getBoost(); }
/*     */         
/*     */         public void normalize(float v) {
/*  75 */           weight.normalize(v);
/*  76 */           this.value = weight.getValue() * FilteredQuery.this.getBoost();
/*     */         }
/*     */         public Explanation explain(IndexReader ir, int i) throws IOException {
/*  79 */           Explanation inner = weight.explain(ir, i);
/*  80 */           if (FilteredQuery.this.getBoost() != 1.0F) {
/*  81 */             Explanation preBoost = inner;
/*  82 */             inner = new Explanation(inner.getValue() * FilteredQuery.this.getBoost(), ""product of:"");
/*  83 */             inner.addDetail(new Explanation(FilteredQuery.this.getBoost(), ""boost""));
/*  84 */             inner.addDetail(preBoost);
/*     */           } 
/*  86 */           Filter f = FilteredQuery.this.filter;
/*  87 */           DocIdSetIterator docIdSetIterator = f.getDocIdSet(ir).iterator();
/*  88 */           if (docIdSetIterator.skipTo(i) && docIdSetIterator.doc() == i) {
/*  89 */             return inner;
/*     */           }
/*  91 */           Explanation result = new Explanation(0.0F, ""failure to match filter: "" + f.toString());
/*     */           
/*  93 */           result.addDetail(inner);
/*  94 */           return result;
/*     */         }
/*     */ 
/*     */ 
/*     */         
/*  99 */         public Query getQuery() { return FilteredQuery.this; }
/*     */ 
/*     */         
/*     */         public Scorer scorer(IndexReader indexReader) throws IOException {
/* 103 */           final Scorer scorer = weight.scorer(indexReader);
/* 104 */           final DocIdSetIterator docIdSetIterator = FilteredQuery.this.filter.getDocIdSet(indexReader).iterator();
/*     */           
/* 106 */           return new Scorer(similarity) { private final Scorer val$scorer;
/*     */               
/*     */               private boolean advanceToCommon() throws IOException {
/* 109 */                 while (scorer.doc() != docIdSetIterator.doc()) {
/* 110 */                   if (scorer.doc() < docIdSetIterator.doc()) {
/* 111 */                     if (!scorer.skipTo(docIdSetIterator.doc()))
/* 112 */                       return false;  continue;
/*     */                   } 
/* 114 */                   if (!docIdSetIterator.skipTo(scorer.doc())) {
/* 115 */                     return false;
/*     */                   }
/*     */                 } 
/* 118 */                 return true;
/*     */               }
/*     */               private final DocIdSetIterator val$docIdSetIterator; private final FilteredQuery.null this$1;
/*     */               
/* 122 */               public boolean next() throws IOException { return (docIdSetIterator.next() && scorer.next() && advanceToCommon()); }
/*     */ 
/*     */               
/* 125 */               public int doc() { return scorer.doc(); }
/*     */ 
/*     */               
/* 128 */               public boolean skipTo(int i) throws IOException { return (docIdSetIterator.skipTo(i) && scorer.skipTo(docIdSetIterator.doc()) && advanceToCommon()); }
/*     */ 
/*     */ 
/*     */ 
/*     */               
/* 133 */               public float score() throws IOException { return FilteredQuery.null.access$000(FilteredQuery.null.this).getBoost() * scorer.score(); }
/*     */ 
/*     */               
/*     */               public Explanation explain(int i) throws IOException {
/* 137 */                 Explanation exp = scorer.explain(i);
/*     */                 
/* 139 */                 if (docIdSetIterator.skipTo(i) && docIdSetIterator.doc() == i) {
/* 140 */                   exp.setDescription(""allowed by filter: "" + exp.getDescription());
/* 141 */                   exp.setValue(FilteredQuery.null.access$000(FilteredQuery.null.this).getBoost() * exp.getValue());
/*     */                 } else {
/* 143 */                   exp.setDescription(""removed by filter: "" + exp.getDescription());
/* 144 */                   exp.setValue(0.0F);
/*     */                 } 
/* 146 */                 return exp;
/*     */               } }
/*     */             ;
/*     */         } }
/*     */       ;
/*     */   }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 155 */     Query rewritten = this.query.rewrite(reader);
/* 156 */     if (rewritten != this.query) {
/* 157 */       FilteredQuery clone = (FilteredQuery)clone();
/* 158 */       clone.query = rewritten;
/* 159 */       return clone;
/*     */     } 
/* 161 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 166 */   public Query getQuery() { return this.query; }
/*     */ 
/*     */ 
/*     */   
/* 170 */   public Filter getFilter() { return this.filter; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 175 */   public void extractTerms(Set terms) { getQuery().extractTerms(terms); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String s) {
/* 180 */     StringBuffer buffer = new StringBuffer();
/* 181 */     buffer.append(""filtered("");
/* 182 */     buffer.append(this.query.toString(s));
/* 183 */     buffer.append("")->"");
/* 184 */     buffer.append(this.filter);
/* 185 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 186 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 191 */     if (o instanceof FilteredQuery) {
/* 192 */       FilteredQuery fq = (FilteredQuery)o;
/* 193 */       return (this.query.equals(fq.query) && this.filter.equals(fq.filter) && getBoost() == fq.getBoost());
/*     */     } 
/* 195 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 200 */   public int hashCode() { return this.query.hashCode() ^ this.filter.hashCode() + Float.floatToRawIntBits(getBoost()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FilteredQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilteredTermEnum,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.index.TermEnum;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class FilteredTermEnum
/*    */   extends TermEnum
/*    */ {
/* 29 */   private Term currentTerm = null;
/* 30 */   private TermEnum actualEnum = null;
/*    */ 
/*    */ 
/*    */   
/*    */   protected abstract boolean termCompare(Term paramTerm);
/*    */ 
/*    */   
/*    */   public abstract float difference();
/*    */ 
/*    */   
/*    */   protected abstract boolean endEnum();
/*    */ 
/*    */   
/*    */   protected void setEnum(TermEnum actualEnum) throws IOException {
/* 44 */     this.actualEnum = actualEnum;
/*    */     
/* 46 */     Term term = actualEnum.term();
/* 47 */     if (term != null && termCompare(term))
/* 48 */     { this.currentTerm = term; }
/* 49 */     else { next(); }
/*    */   
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int docFreq() {
/* 57 */     if (this.actualEnum == null) return -1; 
/* 58 */     return this.actualEnum.docFreq();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean next() throws IOException {
/* 63 */     if (this.actualEnum == null) return false; 
/* 64 */     this.currentTerm = null;
/* 65 */     while (this.currentTerm == null) {
/* 66 */       if (endEnum()) return false; 
/* 67 */       if (this.actualEnum.next()) {
/* 68 */         Term term = this.actualEnum.term();
/* 69 */         if (termCompare(term)) {
/* 70 */           this.currentTerm = term;
/* 71 */           return true;
/*    */         }  continue;
/*    */       } 
/* 74 */       return false;
/*    */     } 
/* 76 */     this.currentTerm = null;
/* 77 */     return false;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 83 */   public Term term() { return this.currentTerm; }
/*    */ 
/*    */ 
/*    */   
/*    */   public void close() throws IOException {
/* 88 */     this.actualEnum.close();
/* 89 */     this.currentTerm = null;
/* 90 */     this.actualEnum = null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FilteredTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilterManager,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.util.Comparator;
/*     */ import java.util.Date;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ import java.util.TreeSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilterManager
/*     */ {
/*     */   protected static FilterManager manager;
/*     */   protected static final int DEFAULT_CACHE_CLEAN_SIZE = 100;
/*     */   protected static final long DEFAULT_CACHE_SLEEP_TIME = 600000L;
/*     */   protected Map cache;
/*     */   protected int cacheCleanSize;
/*     */   protected long cleanSleepTime;
/*     */   protected FilterCleaner filterCleaner;
/*     */   
/*     */   public static synchronized FilterManager getInstance() {
/*  58 */     if (manager == null) {
/*  59 */       manager = new FilterManager();
/*     */     }
/*  61 */     return manager;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected FilterManager() {
/*  68 */     this.cache = new HashMap();
/*  69 */     this.cacheCleanSize = 100;
/*  70 */     this.cleanSleepTime = 600000L;
/*     */     
/*  72 */     this.filterCleaner = new FilterCleaner();
/*  73 */     Thread fcThread = new Thread(this.filterCleaner);
/*     */     
/*  75 */     fcThread.setDaemon(true);
/*  76 */     fcThread.start();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   public void setCacheSize(int cacheCleanSize) { this.cacheCleanSize = cacheCleanSize; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  92 */   public void setCleanThreadSleepTime(long cleanSleepTime) { this.cleanSleepTime = cleanSleepTime; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Filter getFilter(Filter filter) {
/* 104 */     synchronized (this.cache) {
/* 105 */       FilterItem fi = null;
/* 106 */       fi = (FilterItem)this.cache.get(new Integer(filter.hashCode()));
/* 107 */       if (fi != null) {
/* 108 */         fi.timestamp = (new Date()).getTime();
/* 109 */         return fi.filter;
/*     */       } 
/* 111 */       this.cache.put(new Integer(filter.hashCode()), new FilterItem(filter));
/* 112 */       return filter;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   protected class FilterItem
/*     */   {
/*     */     public Filter filter;
/*     */     
/*     */     public long timestamp;
/*     */     
/*     */     private final FilterManager this$0;
/*     */     
/*     */     public FilterItem(Filter filter) {
/* 126 */       this.filter = filter;
/* 127 */       this.timestamp = (new Date()).getTime();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected class FilterCleaner
/*     */     implements Runnable
/*     */   {
/*     */     private boolean running = true;
/*     */ 
/*     */ 
/*     */     
/*     */     private TreeSet sortedFilterItems;
/*     */ 
/*     */ 
/*     */     
/*     */     private final FilterManager this$0;
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public FilterCleaner() {
/* 152 */       this.sortedFilterItems = new TreeSet(new Comparator() { private final FilterManager val$this$0;
/*     */             public int compare(Object a, Object b) {
/* 154 */               if (a instanceof Map.Entry && b instanceof Map.Entry) {
/* 155 */                 FilterManager.FilterItem fia = (FilterManager.FilterItem)((Map.Entry)a).getValue();
/* 156 */                 FilterManager.FilterItem fib = (FilterManager.FilterItem)((Map.Entry)b).getValue();
/* 157 */                 if (fia.timestamp == fib.timestamp) {
/* 158 */                   return 0;
/*     */                 }
/*     */                 
/* 161 */                 if (fia.timestamp < fib.timestamp) {
/* 162 */                   return -1;
/*     */                 }
/*     */                 
/* 165 */                 return 1;
/*     */               } 
/* 167 */               throw new ClassCastException(""Objects are not Map.Entry"");
/*     */             }
/*     */             private final FilterManager.FilterCleaner this$1; }
/*     */         );
/*     */     }
/*     */     
/*     */     public void run() {
/* 174 */       while (this.running) {
/*     */ 
/*     */ 
/*     */         
/* 178 */         if (FilterManager.this.cache.size() > FilterManager.this.cacheCleanSize) {
/*     */           
/* 180 */           this.sortedFilterItems.clear();
/* 181 */           synchronized (FilterManager.this.cache) {
/* 182 */             this.sortedFilterItems.addAll(FilterManager.this.cache.entrySet());
/* 183 */             Iterator it = this.sortedFilterItems.iterator();
/* 184 */             int numToDelete = (int)((FilterManager.this.cache.size() - FilterManager.this.cacheCleanSize) * 1.5D);
/* 185 */             int counter = 0;
/*     */             
/* 187 */             while (it.hasNext() && counter++ < numToDelete) {
/* 188 */               Map.Entry entry = it.next();
/* 189 */               FilterManager.this.cache.remove(entry.getKey());
/*     */             } 
/*     */           } 
/*     */           
/* 193 */           this.sortedFilterItems.clear();
/*     */         } 
/*     */         
/*     */         try {
/* 197 */           Thread.sleep(FilterManager.this.cleanSleepTime);
/* 198 */         } catch (InterruptedException e) {}
/*     */       } 
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FilterManager.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FuzzyQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FuzzyQuery
/*     */   extends MultiTermQuery
/*     */ {
/*     */   public static final float defaultMinSimilarity = 0.5F;
/*     */   public static final int defaultPrefixLength = 0;
/*     */   private float minimumSimilarity;
/*     */   private int prefixLength;
/*     */   
/*     */   public FuzzyQuery(Term term, float minimumSimilarity, int prefixLength) throws IllegalArgumentException {
/*  55 */     super(term);
/*     */     
/*  57 */     if (minimumSimilarity >= 1.0F)
/*  58 */       throw new IllegalArgumentException(""minimumSimilarity >= 1""); 
/*  59 */     if (minimumSimilarity < 0.0F)
/*  60 */       throw new IllegalArgumentException(""minimumSimilarity < 0""); 
/*  61 */     if (prefixLength < 0) {
/*  62 */       throw new IllegalArgumentException(""prefixLength < 0"");
/*     */     }
/*  64 */     this.minimumSimilarity = minimumSimilarity;
/*  65 */     this.prefixLength = prefixLength;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  72 */   public FuzzyQuery(Term term, float minimumSimilarity) throws IllegalArgumentException { this(term, minimumSimilarity, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  79 */   public FuzzyQuery(Term term) { this(term, 0.5F, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   public float getMinSimilarity() { return this.minimumSimilarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   public int getPrefixLength() { return this.prefixLength; }
/*     */ 
/*     */ 
/*     */   
/* 100 */   protected FilteredTermEnum getEnum(IndexReader reader) throws IOException { return new FuzzyTermEnum(reader, getTerm(), this.minimumSimilarity, this.prefixLength); }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 104 */     FilteredTermEnum enumerator = getEnum(reader);
/* 105 */     int maxClauseCount = BooleanQuery.getMaxClauseCount();
/* 106 */     ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);
/* 107 */     ScoreTerm reusableST = null;
/*     */     
/*     */     try {
/*     */       do {
/* 111 */         float score = 0.0F;
/* 112 */         Term t = enumerator.term();
/* 113 */         if (t != null) {
/* 114 */           score = enumerator.difference();
/* 115 */           if (reusableST == null) {
/* 116 */             reusableST = new ScoreTerm(t, score);
/* 117 */           } else if (score >= reusableST.score) {
/*     */ 
/*     */ 
/*     */             
/* 121 */             reusableST.score = score;
/* 122 */             reusableST.term = t;
/*     */           } else {
/*     */             continue;
/*     */           } 
/*     */           
/* 127 */           reusableST = (ScoreTerm)stQueue.insertWithOverflow(reusableST);
/*     */         } 
/* 129 */       } while (enumerator.next());
/*     */     } finally {
/* 131 */       enumerator.close();
/*     */     } 
/*     */     
/* 134 */     BooleanQuery query = new BooleanQuery(true);
/* 135 */     int size = stQueue.size();
/* 136 */     for (int i = 0; i < size; i++) {
/* 137 */       ScoreTerm st = (ScoreTerm)stQueue.pop();
/* 138 */       TermQuery tq = new TermQuery(st.term);
/* 139 */       tq.setBoost(getBoost() * st.score);
/* 140 */       query.add(tq, BooleanClause.Occur.SHOULD);
/*     */     } 
/*     */     
/* 143 */     return query;
/*     */   }
/*     */   
/*     */   public String toString(String field) {
/* 147 */     StringBuffer buffer = new StringBuffer();
/* 148 */     Term term = getTerm();
/* 149 */     if (!term.field().equals(field)) {
/* 150 */       buffer.append(term.field());
/* 151 */       buffer.append("":"");
/*     */     } 
/* 153 */     buffer.append(term.text());
/* 154 */     buffer.append('~');
/* 155 */     buffer.append(Float.toString(this.minimumSimilarity));
/* 156 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 157 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   protected static class ScoreTerm {
/*     */     public Term term;
/*     */     public float score;
/*     */     
/*     */     public ScoreTerm(Term term, float score) {
/* 165 */       this.term = term;
/* 166 */       this.score = score;
/*     */     }
/*     */   }
/*     */   
/*     */   protected static class ScoreTermQueue
/*     */     extends PriorityQueue
/*     */   {
/* 173 */     public ScoreTermQueue(int size) { initialize(size); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected boolean lessThan(Object a, Object b) {
/* 180 */       FuzzyQuery.ScoreTerm termA = (FuzzyQuery.ScoreTerm)a;
/* 181 */       FuzzyQuery.ScoreTerm termB = (FuzzyQuery.ScoreTerm)b;
/* 182 */       if (termA.score == termB.score) {
/* 183 */         return (termA.term.compareTo(termB.term) > 0);
/*     */       }
/* 185 */       return (termA.score < termB.score);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 191 */     if (this == o) return true; 
/* 192 */     if (!(o instanceof FuzzyQuery)) return false; 
/* 193 */     if (!super.equals(o)) return false;
/*     */     
/* 195 */     FuzzyQuery fuzzyQuery = (FuzzyQuery)o;
/*     */     
/* 197 */     if (this.minimumSimilarity != fuzzyQuery.minimumSimilarity) return false; 
/* 198 */     if (this.prefixLength != fuzzyQuery.prefixLength) return false;
/*     */     
/* 200 */     return true;
/*     */   }
/*     */   
/*     */   public int hashCode() {
/* 204 */     int result = super.hashCode();
/* 205 */     result = ((29 * result) + this.minimumSimilarity != 0.0F) ? Float.floatToIntBits(this.minimumSimilarity) : 0;
/* 206 */     result = 29 * result + this.prefixLength;
/* 207 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FuzzyQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FuzzyTermEnum,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FuzzyTermEnum
/*     */   extends FilteredTermEnum
/*     */ {
/*     */   private static final int TYPICAL_LONGEST_WORD_IN_INDEX = 19;
/*     */   private int[][] d;
/*     */   private float similarity;
/*     */   private boolean endEnum = false;
/*  47 */   private Term searchTerm = null;
/*     */   
/*     */   private final String field;
/*     */   private final String text;
/*     */   private final String prefix;
/*     */   private final float minimumSimilarity;
/*     */   private final float scale_factor;
/*  54 */   private final int[] maxDistances = new int[19];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public FuzzyTermEnum(IndexReader reader, Term term) throws IOException { this(reader, term, 0.5F, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity) throws IOException { this(reader, term, minSimilarity, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity, int prefixLength) throws IOException {
/* 104 */     if (minSimilarity >= 1.0F)
/* 105 */       throw new IllegalArgumentException(""minimumSimilarity cannot be greater than or equal to 1""); 
/* 106 */     if (minSimilarity < 0.0F)
/* 107 */       throw new IllegalArgumentException(""minimumSimilarity cannot be less than 0""); 
/* 108 */     if (prefixLength < 0) {
/* 109 */       throw new IllegalArgumentException(""prefixLength cannot be less than 0"");
/*     */     }
/* 111 */     this.minimumSimilarity = minSimilarity;
/* 112 */     this.scale_factor = 1.0F / (1.0F - this.minimumSimilarity);
/* 113 */     this.searchTerm = term;
/* 114 */     this.field = this.searchTerm.field();
/*     */ 
/*     */ 
/*     */     
/* 118 */     int fullSearchTermLength = this.searchTerm.text().length();
/* 119 */     int realPrefixLength = (prefixLength > fullSearchTermLength) ? fullSearchTermLength : prefixLength;
/*     */     
/* 121 */     this.text = this.searchTerm.text().substring(realPrefixLength);
/* 122 */     this.prefix = this.searchTerm.text().substring(0, realPrefixLength);
/*     */     
/* 124 */     initializeMaxDistances();
/* 125 */     this.d = initDistanceArray();
/*     */     
/* 127 */     setEnum(reader.terms(new Term(this.searchTerm.field(), this.prefix)));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final boolean termCompare(Term term) {
/* 135 */     if (this.field == term.field() && term.text().startsWith(this.prefix)) {
/* 136 */       String target = term.text().substring(this.prefix.length());
/* 137 */       this.similarity = similarity(target);
/* 138 */       return (this.similarity > this.minimumSimilarity);
/*     */     } 
/* 140 */     this.endEnum = true;
/* 141 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 145 */   public final float difference() { return (this.similarity - this.minimumSimilarity) * this.scale_factor; }
/*     */ 
/*     */ 
/*     */   
/* 149 */   public final boolean endEnum() { return this.endEnum; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final int min(int a, int b, int c) {
/* 160 */     int t = (a < b) ? a : b;
/* 161 */     return (t < c) ? t : c;
/*     */   }
/*     */ 
/*     */   
/* 165 */   private final int[][] initDistanceArray() { return new int[this.text.length() + 1][19]; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final synchronized float similarity(String target) {
/* 206 */     int m = target.length();
/* 207 */     int n = this.text.length();
/* 208 */     if (n == 0)
/*     */     {
/*     */       
/* 211 */       return (this.prefix.length() == 0) ? 0.0F : (1.0F - m / this.prefix.length());
/*     */     }
/* 213 */     if (m == 0) {
/* 214 */       return (this.prefix.length() == 0) ? 0.0F : (1.0F - n / this.prefix.length());
/*     */     }
/*     */     
/* 217 */     int maxDistance = getMaxDistance(m);
/*     */     
/* 219 */     if (maxDistance < Math.abs(m - n))
/*     */     {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 227 */       return 0.0F;
/*     */     }
/*     */ 
/*     */     
/* 231 */     if ((this.d[0]).length <= m) {
/* 232 */       growDistanceArray(m);
/*     */     }
/*     */ 
/*     */     
/* 236 */     for (int i = 0; i <= n; ) { this.d[i][0] = i; i++; }
/* 237 */      for (int j = 0; j <= m; ) { this.d[0][j] = j; j++; }
/*     */ 
/*     */     
/* 240 */     for (int i = 1; i <= n; i++) {
/* 241 */       int bestPossibleEditDistance = m;
/* 242 */       char s_i = this.text.charAt(i - 1);
/* 243 */       for (int j = 1; j <= m; j++) {
/* 244 */         if (s_i != target.charAt(j - 1)) {
/* 245 */           this.d[i][j] = min(this.d[i - 1][j], this.d[i][j - 1], this.d[i - 1][j - 1]) + 1;
/*     */         } else {
/*     */           
/* 248 */           this.d[i][j] = min(this.d[i - 1][j] + 1, this.d[i][j - 1] + 1, this.d[i - 1][j - 1]);
/*     */         } 
/* 250 */         bestPossibleEditDistance = Math.min(bestPossibleEditDistance, this.d[i][j]);
/*     */       } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 257 */       if (i > maxDistance && bestPossibleEditDistance > maxDistance)
/*     */       {
/*     */         
/* 260 */         return 0.0F;
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 269 */     return 1.0F - this.d[n][m] / (this.prefix.length() + Math.min(n, m));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void growDistanceArray(int m) {
/* 277 */     for (int i = 0; i < this.d.length; i++) {
/* 278 */       this.d[i] = new int[m + 1];
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 290 */   private final int getMaxDistance(int m) { return (m < this.maxDistances.length) ? this.maxDistances[m] : calculateMaxDistance(m); }
/*     */ 
/*     */   
/*     */   private void initializeMaxDistances() {
/* 294 */     for (int i = 0; i < this.maxDistances.length; i++) {
/* 295 */       this.maxDistances[i] = calculateMaxDistance(i);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 300 */   private int calculateMaxDistance(int m) { return (int)((1.0F - this.minimumSimilarity) * (Math.min(this.text.length(), m) + this.prefix.length())); }
/*     */ 
/*     */ 
/*     */   
/* 304 */   public void close() throws IOException { super.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\FuzzyTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Hit,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Hit
/*     */   implements Serializable
/*     */ {
/*  33 */   private Document doc = null;
/*     */   
/*     */   private boolean resolved = false;
/*     */   
/*  37 */   private Hits hits = null;
/*     */ 
/*     */ 
/*     */   
/*     */   private int hitNumber;
/*     */ 
/*     */ 
/*     */   
/*     */   Hit(Hits hits, int hitNumber) {
/*  46 */     this.hits = hits;
/*  47 */     this.hitNumber = hitNumber;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Document getDocument() throws CorruptIndexException, IOException {
/*  58 */     if (!this.resolved) fetchTheHit(); 
/*  59 */     return this.doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public float getScore() throws IOException { return this.hits.score(this.hitNumber); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   public int getId() throws IOException { return this.hits.id(this.hitNumber); }
/*     */ 
/*     */   
/*     */   private void fetchTheHit() throws CorruptIndexException, IOException {
/*  81 */     this.doc = this.hits.doc(this.hitNumber);
/*  82 */     this.resolved = true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public float getBoost() throws CorruptIndexException, IOException { return getDocument().getBoost(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public String get(String name) throws CorruptIndexException, IOException { return getDocument().get(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString() {
/* 116 */     StringBuffer buffer = new StringBuffer();
/* 117 */     buffer.append(""Hit<"");
/* 118 */     buffer.append(this.hits.toString());
/* 119 */     buffer.append("" ["");
/* 120 */     buffer.append(this.hitNumber);
/* 121 */     buffer.append(""] "");
/* 122 */     if (this.resolved) {
/* 123 */       buffer.append(""resolved"");
/*     */     } else {
/* 125 */       buffer.append(""unresolved"");
/*     */     } 
/* 127 */     buffer.append("">"");
/* 128 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Hit.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitCollector,"package org.apache.lucene.search;
public abstract class HitCollector {
  public abstract void collect(int paramInt, float paramFloat);
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\HitCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitDoc,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import org.apache.lucene.document.Document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class HitDoc
/*     */ {
/*     */   float score;
/*     */   int id;
/* 267 */   Document doc = null;
/*     */   
/*     */   HitDoc next;
/*     */   HitDoc prev;
/*     */   
/*     */   HitDoc(float s, int i) {
/* 273 */     this.score = s;
/* 274 */     this.id = i;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\HitDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitIterator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.util.Iterator;
/*    */ import java.util.NoSuchElementException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class HitIterator
/*    */   implements Iterator
/*    */ {
/*    */   private Hits hits;
/* 32 */   private int hitNumber = 0;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 38 */   HitIterator(Hits hits) { this.hits = hits; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 45 */   public boolean hasNext() { return (this.hitNumber < this.hits.length()); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Object next() {
/* 54 */     if (this.hitNumber == this.hits.length()) {
/* 55 */       throw new NoSuchElementException();
/*    */     }
/* 57 */     Object next = new Hit(this.hits, this.hitNumber);
/* 58 */     this.hitNumber++;
/* 59 */     return next;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 68 */   public void remove() { throw new UnsupportedOperationException(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 75 */   public int length() { return this.hits.length(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\HitIterator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitQueue,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class HitQueue
/*    */   extends PriorityQueue
/*    */ {
/* 24 */   HitQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object a, Object b) {
/* 28 */     ScoreDoc hitA = (ScoreDoc)a;
/* 29 */     ScoreDoc hitB = (ScoreDoc)b;
/* 30 */     if (hitA.score == hitB.score) {
/* 31 */       return (hitA.doc > hitB.doc);
/*    */     }
/* 33 */     return (hitA.score < hitB.score);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\HitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Hits,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ConcurrentModificationException;
/*     */ import java.util.Iterator;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Hits
/*     */ {
/*     */   private Weight weight;
/*     */   private Searcher searcher;
/*  58 */   private Filter filter = null;
/*  59 */   private Sort sort = null;
/*     */   
/*     */   private int length;
/*  62 */   private Vector hitDocs = new Vector();
/*     */   
/*     */   private HitDoc first;
/*     */   private HitDoc last;
/*  66 */   private int numDocs = 0;
/*  67 */   private int maxDocs = 200;
/*     */   
/*     */   private int nDeletions;
/*     */   private int lengthAtStart;
/*  71 */   private int nDeletedHits = 0;
/*     */   
/*     */   boolean debugCheckedForDeletions = false;
/*     */   
/*     */   Hits(Searcher s, Query q, Filter f) throws IOException {
/*  76 */     this.weight = q.weight(s);
/*  77 */     this.searcher = s;
/*  78 */     this.filter = f;
/*  79 */     this.nDeletions = countDeletions(s);
/*  80 */     getMoreDocs(50);
/*  81 */     this.lengthAtStart = this.length;
/*     */   }
/*     */   
/*     */   Hits(Searcher s, Query q, Filter f, Sort o) throws IOException {
/*  85 */     this.weight = q.weight(s);
/*  86 */     this.searcher = s;
/*  87 */     this.filter = f;
/*  88 */     this.sort = o;
/*  89 */     this.nDeletions = countDeletions(s);
/*  90 */     getMoreDocs(50);
/*  91 */     this.lengthAtStart = this.length;
/*     */   }
/*     */ 
/*     */   
/*     */   private int countDeletions(Searcher s) throws IOException {
/*  96 */     int cnt = -1;
/*  97 */     if (s instanceof IndexSearcher) {
/*  98 */       cnt = s.maxDoc() - ((IndexSearcher)s).getIndexReader().numDocs();
/*     */     }
/* 100 */     return cnt;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void getMoreDocs(int min) throws IOException {
/* 108 */     if (this.hitDocs.size() > min) {
/* 109 */       min = this.hitDocs.size();
/*     */     }
/*     */     
/* 112 */     int n = min * 2;
/* 113 */     TopDocs topDocs = (this.sort == null) ? this.searcher.search(this.weight, this.filter, n) : this.searcher.search(this.weight, this.filter, n, this.sort);
/*     */     
/* 115 */     this.length = topDocs.totalHits;
/* 116 */     ScoreDoc[] scoreDocs = topDocs.scoreDocs;
/*     */     
/* 118 */     float scoreNorm = 1.0F;
/*     */     
/* 120 */     if (this.length > 0 && topDocs.getMaxScore() > 1.0F) {
/* 121 */       scoreNorm = 1.0F / topDocs.getMaxScore();
/*     */     }
/*     */     
/* 124 */     int start = this.hitDocs.size() - this.nDeletedHits;
/*     */ 
/*     */     
/* 127 */     int nDels2 = countDeletions(this.searcher);
/* 128 */     this.debugCheckedForDeletions = false;
/* 129 */     if (this.nDeletions < 0 || nDels2 > this.nDeletions) {
/*     */       
/* 131 */       this.nDeletedHits = 0;
/* 132 */       this.debugCheckedForDeletions = true;
/* 133 */       int i2 = 0;
/* 134 */       for (int i1 = 0; i1 < this.hitDocs.size() && i2 < scoreDocs.length; i1++) {
/* 135 */         int id1 = ((HitDoc)this.hitDocs.get(i1)).id;
/* 136 */         int id2 = (scoreDocs[i2]).doc;
/* 137 */         if (id1 == id2) {
/* 138 */           i2++;
/*     */         } else {
/* 140 */           this.nDeletedHits++;
/*     */         } 
/*     */       } 
/* 143 */       start = i2;
/*     */     } 
/*     */     
/* 146 */     int end = (scoreDocs.length < this.length) ? scoreDocs.length : this.length;
/* 147 */     this.length += this.nDeletedHits;
/* 148 */     for (int i = start; i < end; i++) {
/* 149 */       this.hitDocs.addElement(new HitDoc((scoreDocs[i]).score * scoreNorm, (scoreDocs[i]).doc));
/*     */     }
/*     */ 
/*     */     
/* 153 */     this.nDeletions = nDels2;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 158 */   public final int length() { return this.length; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Document doc(int n) throws CorruptIndexException, IOException {
/* 168 */     HitDoc hitDoc = hitDoc(n);
/*     */ 
/*     */     
/* 171 */     remove(hitDoc);
/* 172 */     addToFront(hitDoc);
/* 173 */     if (this.numDocs > this.maxDocs) {
/* 174 */       HitDoc oldLast = this.last;
/* 175 */       remove(this.last);
/* 176 */       oldLast.doc = null;
/*     */     } 
/*     */     
/* 179 */     if (hitDoc.doc == null) {
/* 180 */       hitDoc.doc = this.searcher.doc(hitDoc.id);
/*     */     }
/*     */     
/* 183 */     return hitDoc.doc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 188 */   public final float score(int n) throws IOException { return (hitDoc(n)).score; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   public final int id(int n) throws IOException { return (hitDoc(n)).id; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 210 */   public Iterator iterator() { return new HitIterator(this); }
/*     */ 
/*     */   
/*     */   private final HitDoc hitDoc(int n) throws IOException {
/* 214 */     if (n >= this.lengthAtStart) {
/* 215 */       throw new IndexOutOfBoundsException(""Not a valid hit number: "" + n);
/*     */     }
/*     */     
/* 218 */     if (n >= this.hitDocs.size()) {
/* 219 */       getMoreDocs(n);
/*     */     }
/*     */     
/* 222 */     if (n >= this.length) {
/* 223 */       throw new ConcurrentModificationException(""Not a valid hit number: "" + n);
/*     */     }
/*     */     
/* 226 */     return this.hitDocs.elementAt(n);
/*     */   }
/*     */   
/*     */   private final void addToFront(HitDoc hitDoc) {
/* 230 */     if (this.first == null) {
/* 231 */       this.last = hitDoc;
/*     */     } else {
/* 233 */       this.first.prev = hitDoc;
/*     */     } 
/*     */     
/* 236 */     hitDoc.next = this.first;
/* 237 */     this.first = hitDoc;
/* 238 */     hitDoc.prev = null;
/*     */     
/* 240 */     this.numDocs++;
/*     */   }
/*     */   
/*     */   private final void remove(HitDoc hitDoc) {
/* 244 */     if (hitDoc.doc == null) {
/*     */       return;
/*     */     }
/*     */     
/* 248 */     if (hitDoc.next == null) {
/* 249 */       this.last = hitDoc.prev;
/*     */     } else {
/* 251 */       hitDoc.next.prev = hitDoc.prev;
/*     */     } 
/*     */     
/* 254 */     if (hitDoc.prev == null) {
/* 255 */       this.first = hitDoc.next;
/*     */     } else {
/* 257 */       hitDoc.prev.next = hitDoc.next;
/*     */     } 
/*     */     
/* 260 */     this.numDocs--;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Hits.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.IdGenerator,"package org.apache.lucene.search;
import java.io.IOException;
import org.apache.lucene.index.IndexReader;
interface IdGenerator {
  void generate(IndexReader paramIndexReader) throws IOException;
  void handleDoc(int paramInt);
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\IdGenerator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.IndexSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IndexSearcher
/*     */   extends Searcher
/*     */ {
/*     */   IndexReader reader;
/*     */   private boolean closeReader;
/*     */   
/*  47 */   public IndexSearcher(String path) throws CorruptIndexException, IOException { this(IndexReader.open(path), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public IndexSearcher(Directory directory) throws CorruptIndexException, IOException { this(IndexReader.open(directory), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public IndexSearcher(IndexReader r) { this(r, false); }
/*     */ 
/*     */   
/*     */   private IndexSearcher(IndexReader r, boolean closeReader) {
/*  64 */     this.reader = r;
/*  65 */     this.closeReader = closeReader;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  70 */   public IndexReader getIndexReader() { return this.reader; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/*  80 */     if (this.closeReader) {
/*  81 */       this.reader.close();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*  86 */   public int docFreq(Term term) throws IOException { return this.reader.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  91 */   public Document doc(int i) throws CorruptIndexException, IOException { return this.reader.document(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   public Document doc(int i, FieldSelector fieldSelector) throws CorruptIndexException, IOException { return this.reader.document(i, fieldSelector); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int maxDoc() throws IOException { return this.reader.maxDoc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/* 108 */     if (nDocs <= 0) {
/* 109 */       throw new IllegalArgumentException(""nDocs must be > 0"");
/*     */     }
/* 111 */     TopDocCollector collector = new TopDocCollector(nDocs);
/* 112 */     search(weight, filter, collector);
/* 113 */     return collector.topDocs();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int nDocs, Sort sort) throws IOException {
/* 121 */     TopFieldDocCollector collector = new TopFieldDocCollector(this.reader, sort, nDocs);
/*     */     
/* 123 */     search(weight, filter, collector);
/* 124 */     return (TopFieldDocs)collector.topDocs();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, HitCollector results) throws IOException {
/* 131 */     Scorer scorer = weight.scorer(this.reader);
/* 132 */     if (scorer == null) {
/*     */       return;
/*     */     }
/* 135 */     if (filter == null) {
/* 136 */       scorer.score(results);
/*     */       
/*     */       return;
/*     */     } 
/* 140 */     DocIdSetIterator filterDocIdIterator = filter.getDocIdSet(this.reader).iterator();
/*     */     
/* 142 */     boolean more = (filterDocIdIterator.next() && scorer.skipTo(filterDocIdIterator.doc()));
/*     */     
/* 144 */     while (more) {
/* 145 */       int filterDocId = filterDocIdIterator.doc();
/* 146 */       if (filterDocId > scorer.doc() && !scorer.skipTo(filterDocId)) {
/* 147 */         more = false; continue;
/*     */       } 
/* 149 */       int scorerDocId = scorer.doc();
/* 150 */       if (scorerDocId == filterDocId) {
/* 151 */         results.collect(scorerDocId, scorer.score());
/* 152 */         more = filterDocIdIterator.next(); continue;
/*     */       } 
/* 154 */       more = filterDocIdIterator.skipTo(scorerDocId);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(Query original) throws IOException {
/* 161 */     Query query = original;
/* 162 */     for (Query rewrittenQuery = query.rewrite(this.reader); rewrittenQuery != query; 
/* 163 */       rewrittenQuery = query.rewrite(this.reader)) {
/* 164 */       query = rewrittenQuery;
/*     */     }
/* 166 */     return query;
/*     */   }
/*     */ 
/*     */   
/* 170 */   public Explanation explain(Weight weight, int doc) throws IOException { return weight.explain(this.reader, doc); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\IndexSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MatchAllDocsQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MatchAllDocsQuery
/*     */   extends Query
/*     */ {
/*     */   private class MatchAllScorer
/*     */     extends Scorer
/*     */   {
/*     */     final IndexReader reader;
/*     */     int id;
/*     */     final int maxId;
/*     */     final float score;
/*     */     private final MatchAllDocsQuery this$0;
/*     */     
/*     */     MatchAllScorer(IndexReader reader, Similarity similarity, Weight w) {
/*  48 */       super(similarity);
/*  49 */       this.reader = reader;
/*  50 */       this.id = -1;
/*  51 */       this.maxId = reader.maxDoc() - 1;
/*  52 */       this.score = w.getValue();
/*     */     }
/*     */ 
/*     */     
/*  56 */     public Explanation explain(int doc) { return null; }
/*     */ 
/*     */ 
/*     */     
/*  60 */     public int doc() { return this.id; }
/*     */ 
/*     */     
/*     */     public boolean next() {
/*  64 */       while (this.id < this.maxId) {
/*  65 */         this.id++;
/*  66 */         if (!this.reader.isDeleted(this.id)) {
/*  67 */           return true;
/*     */         }
/*     */       } 
/*  70 */       return false;
/*     */     }
/*     */ 
/*     */     
/*  74 */     public float score() { return this.score; }
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) {
/*  78 */       this.id = target - 1;
/*  79 */       return next();
/*     */     }
/*     */   }
/*     */   
/*     */   private class MatchAllDocsWeight
/*     */     implements Weight {
/*     */     private Similarity similarity;
/*     */     private float queryWeight;
/*     */     private float queryNorm;
/*     */     private final MatchAllDocsQuery this$0;
/*     */     
/*  90 */     public MatchAllDocsWeight(Searcher searcher) { this.similarity = searcher.getSimilarity(); }
/*     */ 
/*     */ 
/*     */     
/*  94 */     public String toString() { return ""weight("" + MatchAllDocsQuery.this + "")""; }
/*     */ 
/*     */ 
/*     */     
/*  98 */     public Query getQuery() { return MatchAllDocsQuery.this; }
/*     */ 
/*     */ 
/*     */     
/* 102 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 106 */       this.queryWeight = MatchAllDocsQuery.this.getBoost();
/* 107 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 111 */       this.queryNorm = queryNorm;
/* 112 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */     
/* 116 */     public Scorer scorer(IndexReader reader) { return new MatchAllDocsQuery.MatchAllScorer(reader, this.similarity, this); }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) {
/* 121 */       Explanation queryExpl = new ComplexExplanation(true, getValue(), ""MatchAllDocsQuery, product of:"");
/*     */       
/* 123 */       if (MatchAllDocsQuery.this.getBoost() != 1.0F) {
/* 124 */         queryExpl.addDetail(new Explanation(MatchAllDocsQuery.this.getBoost(), ""boost""));
/*     */       }
/* 126 */       queryExpl.addDetail(new Explanation(this.queryNorm, ""queryNorm""));
/*     */       
/* 128 */       return queryExpl;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 133 */   protected Weight createWeight(Searcher searcher) { return new MatchAllDocsWeight(searcher); }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 140 */     StringBuffer buffer = new StringBuffer();
/* 141 */     buffer.append(""MatchAllDocsQuery"");
/* 142 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 143 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public boolean equals(Object o) {
/* 147 */     if (!(o instanceof MatchAllDocsQuery))
/* 148 */       return false; 
/* 149 */     MatchAllDocsQuery other = (MatchAllDocsQuery)o;
/* 150 */     return (getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */   
/* 154 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ 0x1AA71190; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\MatchAllDocsQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiPhraseQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collections;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.MultipleTermPositions;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiPhraseQuery
/*     */   extends Query
/*     */ {
/*     */   private String field;
/*  42 */   private ArrayList termArrays = new ArrayList();
/*  43 */   private ArrayList positions = new ArrayList();
/*     */   
/*  45 */   private int slop = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public void setSlop(int s) { this.slop = s; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public void add(Term term) { add(new Term[] { term }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term[] terms) {
/*  68 */     int position = 0;
/*  69 */     if (this.positions.size() > 0) {
/*  70 */       position = ((Integer)this.positions.get(this.positions.size() - 1)).intValue() + 1;
/*     */     }
/*  72 */     add(terms, position);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term[] terms, int position) {
/*  83 */     if (this.termArrays.size() == 0) {
/*  84 */       this.field = terms[0].field();
/*     */     }
/*  86 */     for (int i = 0; i < terms.length; i++) {
/*  87 */       if (terms[i].field() != this.field) {
/*  88 */         throw new IllegalArgumentException(""All phrase terms must be in the same field ("" + this.field + ""): "" + terms[i]);
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/*  94 */     this.termArrays.add(terms);
/*  95 */     this.positions.add(new Integer(position));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   public List getTermArrays() { return Collections.unmodifiableList(this.termArrays); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] getPositions() {
/* 110 */     int[] result = new int[this.positions.size()];
/* 111 */     for (int i = 0; i < this.positions.size(); i++)
/* 112 */       result[i] = ((Integer)this.positions.get(i)).intValue(); 
/* 113 */     return result;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 118 */     for (Iterator iter = this.termArrays.iterator(); iter.hasNext(); ) {
/* 119 */       Term[] arr = iter.next();
/* 120 */       for (int i = 0; i < arr.length; i++)
/* 121 */         terms.add(arr[i]); 
/*     */     } 
/*     */   }
/*     */   
/*     */   private class MultiPhraseWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final MultiPhraseQuery this$0;
/*     */     
/*     */     public MultiPhraseWeight(Searcher searcher) throws IOException {
/* 136 */       this.similarity = MultiPhraseQuery.this.getSimilarity(searcher);
/*     */ 
/*     */       
/* 139 */       Iterator i = MultiPhraseQuery.this.termArrays.iterator();
/* 140 */       while (i.hasNext()) {
/* 141 */         Term[] terms = i.next();
/* 142 */         for (int j = 0; j < terms.length; j++) {
/* 143 */           this.idf += MultiPhraseQuery.this.getSimilarity(searcher).idf(terms[j], searcher);
/*     */         }
/*     */       } 
/*     */     }
/*     */     
/* 148 */     public Query getQuery() { return MultiPhraseQuery.this; }
/* 149 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 152 */       this.queryWeight = this.idf * MultiPhraseQuery.this.getBoost();
/* 153 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 157 */       this.queryNorm = queryNorm;
/* 158 */       this.queryWeight *= queryNorm;
/* 159 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 163 */       if (MultiPhraseQuery.this.termArrays.size() == 0) {
/* 164 */         return null;
/*     */       }
/* 166 */       TermPositions[] tps = new TermPositions[MultiPhraseQuery.this.termArrays.size()];
/* 167 */       for (int i = 0; i < tps.length; i++) {
/* 168 */         Object p; Term[] terms = MultiPhraseQuery.this.termArrays.get(i);
/*     */ 
/*     */         
/* 171 */         if (terms.length > 1) {
/* 172 */           p = new MultipleTermPositions(reader, terms);
/*     */         } else {
/* 174 */           p = reader.termPositions(terms[0]);
/*     */         } 
/* 176 */         if (p == null) {
/* 177 */           return null;
/*     */         }
/* 179 */         tps[i] = (TermPositions)p;
/*     */       } 
/*     */       
/* 182 */       if (MultiPhraseQuery.this.slop == 0) {
/* 183 */         return new ExactPhraseScorer(this, tps, MultiPhraseQuery.this.getPositions(), this.similarity, reader.norms(MultiPhraseQuery.this.field));
/*     */       }
/*     */       
/* 186 */       return new SloppyPhraseScorer(this, tps, MultiPhraseQuery.this.getPositions(), this.similarity, MultiPhraseQuery.this.slop, reader.norms(MultiPhraseQuery.this.field));
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 192 */       ComplexExplanation result = new ComplexExplanation();
/* 193 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/* 195 */       Explanation idfExpl = new Explanation(this.idf, ""idf("" + getQuery() + "")"");
/*     */ 
/*     */       
/* 198 */       Explanation queryExpl = new Explanation();
/* 199 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/* 201 */       Explanation boostExpl = new Explanation(MultiPhraseQuery.this.getBoost(), ""boost"");
/* 202 */       if (MultiPhraseQuery.this.getBoost() != 1.0F) {
/* 203 */         queryExpl.addDetail(boostExpl);
/*     */       }
/* 205 */       queryExpl.addDetail(idfExpl);
/*     */       
/* 207 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 208 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/* 210 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 214 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 217 */       ComplexExplanation fieldExpl = new ComplexExplanation();
/* 218 */       fieldExpl.setDescription(""fieldWeight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 221 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 222 */       fieldExpl.addDetail(tfExpl);
/* 223 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 225 */       Explanation fieldNormExpl = new Explanation();
/* 226 */       byte[] fieldNorms = reader.norms(MultiPhraseQuery.this.field);
/* 227 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 229 */       fieldNormExpl.setValue(fieldNorm);
/* 230 */       fieldNormExpl.setDescription(""fieldNorm(field="" + MultiPhraseQuery.this.field + "", doc="" + doc + "")"");
/* 231 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 233 */       fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
/* 234 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 238 */       result.addDetail(fieldExpl);
/* 239 */       result.setMatch(fieldExpl.getMatch());
/*     */ 
/*     */       
/* 242 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 244 */       if (queryExpl.getValue() == 1.0F) {
/* 245 */         return fieldExpl;
/*     */       }
/* 247 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) {
/* 252 */     if (this.termArrays.size() == 1) {
/* 253 */       Term[] terms = this.termArrays.get(0);
/* 254 */       BooleanQuery boq = new BooleanQuery(true);
/* 255 */       for (int i = 0; i < terms.length; i++) {
/* 256 */         boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
/*     */       }
/* 258 */       boq.setBoost(getBoost());
/* 259 */       return boq;
/*     */     } 
/* 261 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 266 */   protected Weight createWeight(Searcher searcher) throws IOException { return new MultiPhraseWeight(searcher); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final String toString(String f) {
/* 271 */     StringBuffer buffer = new StringBuffer();
/* 272 */     if (!this.field.equals(f)) {
/* 273 */       buffer.append(this.field);
/* 274 */       buffer.append("":"");
/*     */     } 
/*     */     
/* 277 */     buffer.append(""\"""");
/* 278 */     Iterator i = this.termArrays.iterator();
/* 279 */     while (i.hasNext()) {
/* 280 */       Term[] terms = i.next();
/* 281 */       if (terms.length > 1) {
/* 282 */         buffer.append(""("");
/* 283 */         for (int j = 0; j < terms.length; j++) {
/* 284 */           buffer.append(terms[j].text());
/* 285 */           if (j < terms.length - 1)
/* 286 */             buffer.append("" ""); 
/*     */         } 
/* 288 */         buffer.append("")"");
/*     */       } else {
/* 290 */         buffer.append(terms[0].text());
/*     */       } 
/* 292 */       if (i.hasNext())
/* 293 */         buffer.append("" ""); 
/*     */     } 
/* 295 */     buffer.append(""\"""");
/*     */     
/* 297 */     if (this.slop != 0) {
/* 298 */       buffer.append(""~"");
/* 299 */       buffer.append(this.slop);
/*     */     } 
/*     */     
/* 302 */     buffer.append(ToStringUtils.boost(getBoost()));
/*     */     
/* 304 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 310 */     if (!(o instanceof MultiPhraseQuery)) return false; 
/* 311 */     MultiPhraseQuery other = (MultiPhraseQuery)o;
/* 312 */     return (getBoost() == other.getBoost() && this.slop == other.slop && this.termArrays.equals(other.termArrays) && this.positions.equals(other.positions));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 320 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.slop ^ this.termArrays.hashCode() ^ this.positions.hashCode() ^ 0x4AC65113; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\MultiPhraseQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiSearcher
/*     */   extends Searcher
/*     */ {
/*     */   private Searchable[] searchables;
/*     */   private int[] starts;
/*     */   
/*     */   private static class CachedDfSource
/*     */     extends Searcher
/*     */   {
/*     */     private Map dfMap;
/*     */     private int maxDoc;
/*     */     
/*     */     public CachedDfSource(Map dfMap, int maxDoc, Similarity similarity) {
/*  47 */       this.dfMap = dfMap;
/*  48 */       this.maxDoc = maxDoc;
/*  49 */       setSimilarity(similarity);
/*     */     }
/*     */     
/*     */     public int docFreq(Term term) {
/*     */       int df;
/*     */       try {
/*  55 */         df = ((Integer)this.dfMap.get(term)).intValue();
/*  56 */       } catch (NullPointerException e) {
/*  57 */         throw new IllegalArgumentException(""df for term "" + term.text() + "" not available"");
/*     */       } 
/*     */       
/*  60 */       return df;
/*     */     }
/*     */     
/*     */     public int[] docFreqs(Term[] terms) {
/*  64 */       int[] result = new int[terms.length];
/*  65 */       for (int i = 0; i < terms.length; i++) {
/*  66 */         result[i] = docFreq(terms[i]);
/*     */       }
/*  68 */       return result;
/*     */     }
/*     */ 
/*     */     
/*  72 */     public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  80 */     public Query rewrite(Query query) { return query; }
/*     */ 
/*     */ 
/*     */     
/*  84 */     public void close() { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  88 */     public Document doc(int i) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  92 */     public Document doc(int i, FieldSelector fieldSelector) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  96 */     public Explanation explain(Weight weight, int doc) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/* 100 */     public void search(Weight weight, Filter filter, HitCollector results) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/* 104 */     public TopDocs search(Weight weight, Filter filter, int n) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/* 108 */     public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) { throw new UnsupportedOperationException(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   private int maxDoc = 0;
/*     */ 
/*     */   
/*     */   public MultiSearcher(Searchable[] searchables) throws IOException {
/* 119 */     this.searchables = searchables;
/*     */     
/* 121 */     this.starts = new int[searchables.length + 1];
/* 122 */     for (int i = 0; i < searchables.length; i++) {
/* 123 */       this.starts[i] = this.maxDoc;
/* 124 */       this.maxDoc += searchables[i].maxDoc();
/*     */     } 
/* 126 */     this.starts[searchables.length] = this.maxDoc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 131 */   public Searchable[] getSearchables() { return this.searchables; }
/*     */ 
/*     */ 
/*     */   
/* 135 */   protected int[] getStarts() { return this.starts; }
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 140 */     for (int i = 0; i < this.searchables.length; i++)
/* 141 */       this.searchables[i].close(); 
/*     */   }
/*     */   
/*     */   public int docFreq(Term term) throws IOException {
/* 145 */     int docFreq = 0;
/* 146 */     for (int i = 0; i < this.searchables.length; i++)
/* 147 */       docFreq += this.searchables[i].docFreq(term); 
/* 148 */     return docFreq;
/*     */   }
/*     */ 
/*     */   
/*     */   public Document doc(int n) throws CorruptIndexException, IOException {
/* 153 */     int i = subSearcher(n);
/* 154 */     return this.searchables[i].doc(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */   
/*     */   public Document doc(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 159 */     int i = subSearcher(n);
/* 160 */     return this.searchables[i].doc(n - this.starts[i], fieldSelector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int subSearcher(int n) {
/* 167 */     int lo = 0;
/* 168 */     int hi = this.searchables.length - 1;
/*     */     
/* 170 */     while (hi >= lo) {
/* 171 */       int mid = lo + hi >> 1;
/* 172 */       int midValue = this.starts[mid];
/* 173 */       if (n < midValue) {
/* 174 */         hi = mid - 1; continue;
/* 175 */       }  if (n > midValue) {
/* 176 */         lo = mid + 1; continue;
/*     */       } 
/* 178 */       while (mid + 1 < this.searchables.length && this.starts[mid + 1] == midValue) {
/* 179 */         mid++;
/*     */       }
/* 181 */       return mid;
/*     */     } 
/*     */     
/* 184 */     return hi;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 190 */   public int subDoc(int n) { return n - this.starts[subSearcher(n)]; }
/*     */ 
/*     */ 
/*     */   
/* 194 */   public int maxDoc() throws IOException { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/* 200 */     HitQueue hq = new HitQueue(nDocs);
/* 201 */     int totalHits = 0;
/*     */     
/* 203 */     for (int i = 0; i < this.searchables.length; i++) {
/* 204 */       TopDocs docs = this.searchables[i].search(weight, filter, nDocs);
/* 205 */       totalHits += docs.totalHits;
/* 206 */       ScoreDoc[] scoreDocs = docs.scoreDocs;
/* 207 */       for (int j = 0; j < scoreDocs.length; j++) {
/* 208 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 209 */         scoreDoc.doc += this.starts[i];
/* 210 */         if (!hq.insert(scoreDoc)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 215 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 216 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 217 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 219 */     float maxScore = (totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*     */     
/* 221 */     return new TopDocs(totalHits, scoreDocs, maxScore);
/*     */   }
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) throws IOException {
/* 226 */     FieldDocSortedHitQueue hq = null;
/* 227 */     int totalHits = 0;
/*     */     
/* 229 */     float maxScore = Float.NEGATIVE_INFINITY;
/*     */     
/* 231 */     for (int i = 0; i < this.searchables.length; i++) {
/* 232 */       TopFieldDocs docs = this.searchables[i].search(weight, filter, n, sort);
/*     */       
/* 234 */       if (hq == null) hq = new FieldDocSortedHitQueue(docs.fields, n); 
/* 235 */       totalHits += docs.totalHits;
/* 236 */       maxScore = Math.max(maxScore, docs.getMaxScore());
/* 237 */       ScoreDoc[] scoreDocs = docs.scoreDocs;
/* 238 */       for (int j = 0; j < scoreDocs.length; j++) {
/* 239 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 240 */         scoreDoc.doc += this.starts[i];
/* 241 */         if (!hq.insert(scoreDoc)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 246 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 247 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 248 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 250 */     return new TopFieldDocs(totalHits, scoreDocs, hq.getFields(), maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 257 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 259 */       final int start = this.starts[i];
/*     */       
/* 261 */       this.searchables[i].search(weight, filter, new HitCollector() { private final HitCollector val$results;
/*     */             
/* 263 */             public void collect(int doc, float score) { results.collect(doc + start, score); }
/*     */             private final int val$start;
/*     */             private final MultiSearcher this$0; }
/*     */         );
/*     */     } 
/*     */   }
/*     */   
/*     */   public Query rewrite(Query original) throws IOException {
/* 271 */     Query[] queries = new Query[this.searchables.length];
/* 272 */     for (int i = 0; i < this.searchables.length; i++) {
/* 273 */       queries[i] = this.searchables[i].rewrite(original);
/*     */     }
/* 275 */     return queries[0].combine(queries);
/*     */   }
/*     */   
/*     */   public Explanation explain(Weight weight, int doc) throws IOException {
/* 279 */     int i = subSearcher(doc);
/* 280 */     return this.searchables[i].explain(weight, doc - this.starts[i]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Weight createWeight(Query original) throws IOException {
/* 300 */     Query rewrittenQuery = rewrite(original);
/*     */ 
/*     */     
/* 303 */     Set terms = new HashSet();
/* 304 */     rewrittenQuery.extractTerms(terms);
/*     */ 
/*     */     
/* 307 */     Term[] allTermsArray = new Term[terms.size()];
/* 308 */     terms.toArray((Object[])allTermsArray);
/* 309 */     int[] aggregatedDfs = new int[terms.size()];
/* 310 */     for (int i = 0; i < this.searchables.length; i++) {
/* 311 */       int[] dfs = this.searchables[i].docFreqs(allTermsArray);
/* 312 */       for (int j = 0; j < aggregatedDfs.length; j++) {
/* 313 */         aggregatedDfs[j] = aggregatedDfs[j] + dfs[j];
/*     */       }
/*     */     } 
/*     */     
/* 317 */     HashMap dfMap = new HashMap();
/* 318 */     for (int i = 0; i < allTermsArray.length; i++) {
/* 319 */       dfMap.put(allTermsArray[i], new Integer(aggregatedDfs[i]));
/*     */     }
/*     */ 
/*     */     
/* 323 */     int numDocs = maxDoc();
/* 324 */     CachedDfSource cacheSim = new CachedDfSource(dfMap, numDocs, getSimilarity());
/*     */     
/* 326 */     return rewrittenQuery.weight(cacheSim);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\MultiSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiSearcherThread,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiSearcherThread
/*     */   extends Thread
/*     */ {
/*     */   private Searchable searchable;
/*     */   private Weight weight;
/*     */   private Filter filter;
/*     */   private int nDocs;
/*     */   private TopDocs docs;
/*     */   private int i;
/*     */   private PriorityQueue hq;
/*     */   private int[] starts;
/*     */   private IOException ioe;
/*     */   private Sort sort;
/*     */   
/*     */   public MultiSearcherThread(Searchable searchable, Weight weight, Filter filter, int nDocs, HitQueue hq, int i, int[] starts, String name) {
/* 217 */     super(name);
/* 218 */     this.searchable = searchable;
/* 219 */     this.weight = weight;
/* 220 */     this.filter = filter;
/* 221 */     this.nDocs = nDocs;
/* 222 */     this.hq = hq;
/* 223 */     this.i = i;
/* 224 */     this.starts = starts;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultiSearcherThread(Searchable searchable, Weight weight, Filter filter, int nDocs, FieldDocSortedHitQueue hq, Sort sort, int i, int[] starts, String name) {
/* 237 */     super(name);
/* 238 */     this.searchable = searchable;
/* 239 */     this.weight = weight;
/* 240 */     this.filter = filter;
/* 241 */     this.nDocs = nDocs;
/* 242 */     this.hq = hq;
/* 243 */     this.i = i;
/* 244 */     this.starts = starts;
/* 245 */     this.sort = sort;
/*     */   }
/*     */   
/*     */   public void run() {
/*     */     try {
/* 250 */       this.docs = (this.sort == null) ? this.searchable.search(this.weight, this.filter, this.nDocs) : this.searchable.search(this.weight, this.filter, this.nDocs, this.sort);
/*     */ 
/*     */     
/*     */     }
/* 254 */     catch (IOException ioe) {
/* 255 */       this.ioe = ioe;
/*     */     } 
/* 257 */     if (this.ioe == null) {
/*     */ 
/*     */ 
/*     */       
/* 261 */       if (this.sort != null) {
/* 262 */         ((FieldDocSortedHitQueue)this.hq).setFields(((TopFieldDocs)this.docs).fields);
/*     */       }
/* 264 */       ScoreDoc[] scoreDocs = this.docs.scoreDocs;
/* 265 */       int j = 0;
/* 266 */       for (; j < scoreDocs.length; 
/* 267 */         j++) {
/* 268 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 269 */         scoreDoc.doc += this.starts[this.i];
/*     */         
/* 271 */         synchronized (this.hq) {
/* 272 */           if (!this.hq.insert(scoreDoc)) {
/*     */             break;
/*     */           }
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/* 280 */   public int hits() { return this.docs.totalHits; }
/*     */ 
/*     */ 
/*     */   
/* 284 */   public float getMaxScore() { return this.docs.getMaxScore(); }
/*     */ 
/*     */ 
/*     */   
/* 288 */   public IOException getIOException() { return this.ioe; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\MultiSearcherThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiTermQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class MultiTermQuery
/*    */   extends Query
/*    */ {
/*    */   private Term term;
/*    */   
/* 44 */   public MultiTermQuery(Term term) { this.term = term; }
/*    */ 
/*    */ 
/*    */   
/* 48 */   public Term getTerm() { return this.term; }
/*    */ 
/*    */   
/*    */   protected abstract FilteredTermEnum getEnum(IndexReader paramIndexReader) throws IOException;
/*    */ 
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 55 */     FilteredTermEnum enumerator = getEnum(reader);
/* 56 */     BooleanQuery query = new BooleanQuery(true);
/*    */     try {
/*    */       do {
/* 59 */         Term t = enumerator.term();
/* 60 */         if (t == null)
/* 61 */           continue;  TermQuery tq = new TermQuery(t);
/* 62 */         tq.setBoost(getBoost() * enumerator.difference());
/* 63 */         query.add(tq, BooleanClause.Occur.SHOULD);
/*    */       }
/* 65 */       while (enumerator.next());
/*    */     } finally {
/* 67 */       enumerator.close();
/*    */     } 
/* 69 */     return query;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 74 */     StringBuffer buffer = new StringBuffer();
/* 75 */     if (!this.term.field().equals(field)) {
/* 76 */       buffer.append(this.term.field());
/* 77 */       buffer.append("":"");
/*    */     } 
/* 79 */     buffer.append(this.term.text());
/* 80 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 81 */     return buffer.toString();
/*    */   }
/*    */   
/*    */   public boolean equals(Object o) {
/* 85 */     if (this == o) return true; 
/* 86 */     if (!(o instanceof MultiTermQuery)) return false;
/*    */     
/* 88 */     MultiTermQuery multiTermQuery = (MultiTermQuery)o;
/*    */     
/* 90 */     if (!this.term.equals(multiTermQuery.term)) return false;
/*    */     
/* 92 */     return (getBoost() == multiTermQuery.getBoost());
/*    */   }
/*    */ 
/*    */   
/* 96 */   public int hashCode() { return this.term.hashCode() + Float.floatToRawIntBits(getBoost()); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\MultiTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.NonMatchingScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class NonMatchingScorer
/*    */   extends Scorer
/*    */ {
/* 24 */   public NonMatchingScorer() { super(null); }
/*    */   
/* 26 */   public int doc() { throw new UnsupportedOperationException(); }
/*    */   
/* 28 */   public boolean next() throws IOException { return false; }
/*    */   
/* 30 */   public float score() { throw new UnsupportedOperationException(); }
/*    */   
/* 32 */   public boolean skipTo(int target) { return false; }
/*    */   
/*    */   public Explanation explain(int doc) {
/* 35 */     Explanation e = new Explanation();
/* 36 */     e.setDescription(""No document matches."");
/* 37 */     return e;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\NonMatchingScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ParallelMultiSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParallelMultiSearcher
/*     */   extends MultiSearcher
/*     */ {
/*     */   private Searchable[] searchables;
/*     */   private int[] starts;
/*     */   
/*     */   public ParallelMultiSearcher(Searchable[] searchables) throws IOException {
/*  37 */     super(searchables);
/*  38 */     this.searchables = searchables;
/*  39 */     this.starts = getStarts();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  46 */   public int docFreq(Term term) throws IOException { return super.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/*  56 */     HitQueue hq = new HitQueue(nDocs);
/*  57 */     int totalHits = 0;
/*  58 */     MultiSearcherThread[] msta = new MultiSearcherThread[this.searchables.length];
/*     */     
/*  60 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/*  62 */       msta[i] = new MultiSearcherThread(this.searchables[i], weight, filter, nDocs, hq, i, this.starts, ""MultiSearcher thread #"" + (i + 1));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  72 */       msta[i].start();
/*     */     } 
/*     */     
/*  75 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       try {
/*  77 */         msta[i].join();
/*  78 */       } catch (InterruptedException ie) {}
/*     */ 
/*     */       
/*  81 */       IOException ioe = msta[i].getIOException();
/*  82 */       if (ioe == null) {
/*  83 */         totalHits += msta[i].hits();
/*     */       } else {
/*     */         
/*  86 */         throw ioe;
/*     */       } 
/*     */     } 
/*     */     
/*  90 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/*  91 */     for (int i = hq.size() - 1; i >= 0; i--) {
/*  92 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/*  94 */     float maxScore = (totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*     */     
/*  96 */     return new TopDocs(totalHits, scoreDocs, maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int nDocs, Sort sort) throws IOException {
/* 107 */     FieldDocSortedHitQueue hq = new FieldDocSortedHitQueue(null, nDocs);
/* 108 */     int totalHits = 0;
/* 109 */     MultiSearcherThread[] msta = new MultiSearcherThread[this.searchables.length];
/* 110 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 112 */       msta[i] = new MultiSearcherThread(this.searchables[i], weight, filter, nDocs, hq, sort, i, this.starts, ""MultiSearcher thread #"" + (i + 1));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 123 */       msta[i].start();
/*     */     } 
/*     */     
/* 126 */     float maxScore = Float.NEGATIVE_INFINITY;
/*     */     
/* 128 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       try {
/* 130 */         msta[i].join();
/* 131 */       } catch (InterruptedException ie) {}
/*     */ 
/*     */       
/* 134 */       IOException ioe = msta[i].getIOException();
/* 135 */       if (ioe == null) {
/* 136 */         totalHits += msta[i].hits();
/* 137 */         maxScore = Math.max(maxScore, msta[i].getMaxScore());
/*     */       } else {
/*     */         
/* 140 */         throw ioe;
/*     */       } 
/*     */     } 
/*     */     
/* 144 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 145 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 146 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 148 */     return new TopFieldDocs(totalHits, scoreDocs, hq.getFields(), maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 169 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 171 */       final int start = this.starts[i];
/*     */       
/* 173 */       this.searchables[i].search(weight, filter, new HitCollector()
/*     */           {
/* 175 */             public void collect(int doc, float score) { results.collect(doc + start, score); }
/*     */ 
/*     */             
/*     */             private final HitCollector val$results;
/*     */             
/*     */             private final int val$start;
/*     */             
/*     */             private final ParallelMultiSearcher this$0;
/*     */           });
/*     */     } 
/*     */   }
/*     */   
/* 187 */   public Query rewrite(Query original) throws IOException { return super.rewrite(original); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ParallelMultiSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhrasePositions,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class PhrasePositions
/*    */ {
/*    */   int doc;
/*    */   int position;
/*    */   int count;
/*    */   int offset;
/*    */   TermPositions tp;
/*    */   PhrasePositions next;
/*    */   boolean repeats;
/*    */   
/*    */   PhrasePositions(TermPositions t, int o) {
/* 36 */     this.tp = t;
/* 37 */     this.offset = o;
/*    */   }
/*    */   
/*    */   final boolean next() throws IOException {
/* 41 */     if (!this.tp.next()) {
/* 42 */       this.tp.close();
/* 43 */       this.doc = Integer.MAX_VALUE;
/* 44 */       return false;
/*    */     } 
/* 46 */     this.doc = this.tp.doc();
/* 47 */     this.position = 0;
/* 48 */     return true;
/*    */   }
/*    */   
/*    */   final boolean skipTo(int target) throws IOException {
/* 52 */     if (!this.tp.skipTo(target)) {
/* 53 */       this.tp.close();
/* 54 */       this.doc = Integer.MAX_VALUE;
/* 55 */       return false;
/*    */     } 
/* 57 */     this.doc = this.tp.doc();
/* 58 */     this.position = 0;
/* 59 */     return true;
/*    */   }
/*    */ 
/*    */   
/*    */   final void firstPosition() throws IOException {
/* 64 */     this.count = this.tp.freq();
/* 65 */     nextPosition();
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   final boolean nextPosition() throws IOException {
/* 75 */     if (this.count-- > 0) {
/* 76 */       this.position = this.tp.nextPosition() - this.offset;
/* 77 */       return true;
/*    */     } 
/* 79 */     return false;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\PhrasePositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class PhraseQuery
/*     */   extends Query
/*     */ {
/*     */   private String field;
/*  36 */   private ArrayList terms = new ArrayList(4);
/*  37 */   private ArrayList positions = new ArrayList(4);
/*  38 */   private int maxPosition = 0;
/*  39 */   private int slop = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  58 */   public void setSlop(int s) { this.slop = s; }
/*     */   
/*  60 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term term) {
/*  67 */     int position = 0;
/*  68 */     if (this.positions.size() > 0) {
/*  69 */       position = ((Integer)this.positions.get(this.positions.size() - 1)).intValue() + 1;
/*     */     }
/*  71 */     add(term, position);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term term, int position) {
/*  84 */     if (this.terms.size() == 0) {
/*  85 */       this.field = term.field();
/*  86 */     } else if (term.field() != this.field) {
/*  87 */       throw new IllegalArgumentException(""All phrase terms must be in the same field: "" + term);
/*     */     } 
/*  89 */     this.terms.add(term);
/*  90 */     this.positions.add(new Integer(position));
/*  91 */     if (position > this.maxPosition) this.maxPosition = position;
/*     */   
/*     */   }
/*     */ 
/*     */   
/*  96 */   public Term[] getTerms() { return (Term[])this.terms.toArray((Object[])new Term[0]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] getPositions() {
/* 103 */     int[] result = new int[this.positions.size()];
/* 104 */     for (int i = 0; i < this.positions.size(); i++)
/* 105 */       result[i] = ((Integer)this.positions.get(i)).intValue(); 
/* 106 */     return result;
/*     */   }
/*     */   
/*     */   private class PhraseWeight implements Weight {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final PhraseQuery this$0;
/*     */     
/*     */     public PhraseWeight(Searcher searcher) throws IOException {
/* 118 */       this.similarity = PhraseQuery.this.getSimilarity(searcher);
/*     */       
/* 120 */       this.idf = this.similarity.idf(PhraseQuery.this.terms, searcher);
/*     */     }
/*     */     
/* 123 */     public String toString() { return ""weight("" + PhraseQuery.this + "")""; }
/*     */     
/* 125 */     public Query getQuery() { return PhraseQuery.this; }
/* 126 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 129 */       this.queryWeight = this.idf * PhraseQuery.this.getBoost();
/* 130 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 134 */       this.queryNorm = queryNorm;
/* 135 */       this.queryWeight *= queryNorm;
/* 136 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 140 */       if (PhraseQuery.this.terms.size() == 0) {
/* 141 */         return null;
/*     */       }
/* 143 */       TermPositions[] tps = new TermPositions[PhraseQuery.this.terms.size()];
/* 144 */       for (int i = 0; i < PhraseQuery.this.terms.size(); i++) {
/* 145 */         TermPositions p = reader.termPositions(PhraseQuery.this.terms.get(i));
/* 146 */         if (p == null)
/* 147 */           return null; 
/* 148 */         tps[i] = p;
/*     */       } 
/*     */       
/* 151 */       if (PhraseQuery.this.slop == 0) {
/* 152 */         return new ExactPhraseScorer(this, tps, PhraseQuery.this.getPositions(), this.similarity, reader.norms(PhraseQuery.this.field));
/*     */       }
/*     */       
/* 155 */       return new SloppyPhraseScorer(this, tps, PhraseQuery.this.getPositions(), this.similarity, PhraseQuery.this.slop, reader.norms(PhraseQuery.this.field));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 164 */       Explanation result = new Explanation();
/* 165 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/* 167 */       StringBuffer docFreqs = new StringBuffer();
/* 168 */       StringBuffer query = new StringBuffer();
/* 169 */       query.append('""');
/* 170 */       for (int i = 0; i < PhraseQuery.this.terms.size(); i++) {
/* 171 */         if (i != 0) {
/* 172 */           docFreqs.append("" "");
/* 173 */           query.append("" "");
/*     */         } 
/*     */         
/* 176 */         Term term = PhraseQuery.this.terms.get(i);
/*     */         
/* 178 */         docFreqs.append(term.text());
/* 179 */         docFreqs.append(""="");
/* 180 */         docFreqs.append(reader.docFreq(term));
/*     */         
/* 182 */         query.append(term.text());
/*     */       } 
/* 184 */       query.append('""');
/*     */       
/* 186 */       Explanation idfExpl = new Explanation(this.idf, ""idf("" + PhraseQuery.this.field + "": "" + docFreqs + "")"");
/*     */ 
/*     */ 
/*     */       
/* 190 */       Explanation queryExpl = new Explanation();
/* 191 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/* 193 */       Explanation boostExpl = new Explanation(PhraseQuery.this.getBoost(), ""boost"");
/* 194 */       if (PhraseQuery.this.getBoost() != 1.0F)
/* 195 */         queryExpl.addDetail(boostExpl); 
/* 196 */       queryExpl.addDetail(idfExpl);
/*     */       
/* 198 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 199 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/* 201 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 205 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 208 */       Explanation fieldExpl = new Explanation();
/* 209 */       fieldExpl.setDescription(""fieldWeight("" + PhraseQuery.this.field + "":"" + query + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 212 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 213 */       fieldExpl.addDetail(tfExpl);
/* 214 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 216 */       Explanation fieldNormExpl = new Explanation();
/* 217 */       byte[] fieldNorms = reader.norms(PhraseQuery.this.field);
/* 218 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 220 */       fieldNormExpl.setValue(fieldNorm);
/* 221 */       fieldNormExpl.setDescription(""fieldNorm(field="" + PhraseQuery.this.field + "", doc="" + doc + "")"");
/* 222 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 224 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 228 */       result.addDetail(fieldExpl);
/*     */ 
/*     */       
/* 231 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 233 */       if (queryExpl.getValue() == 1.0F) {
/* 234 */         return fieldExpl;
/*     */       }
/* 236 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   protected Weight createWeight(Searcher searcher) throws IOException {
/* 241 */     if (this.terms.size() == 1) {
/* 242 */       Term term = this.terms.get(0);
/* 243 */       Query termQuery = new TermQuery(term);
/* 244 */       termQuery.setBoost(getBoost());
/* 245 */       return termQuery.createWeight(searcher);
/*     */     } 
/* 247 */     return new PhraseWeight(searcher);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 254 */   public void extractTerms(Set queryTerms) { queryTerms.addAll(this.terms); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String f) {
/* 259 */     StringBuffer buffer = new StringBuffer();
/* 260 */     if (this.field != null && !this.field.equals(f)) {
/* 261 */       buffer.append(this.field);
/* 262 */       buffer.append("":"");
/*     */     } 
/*     */     
/* 265 */     buffer.append(""\"""");
/* 266 */     String[] pieces = new String[this.maxPosition + 1];
/* 267 */     for (int i = 0; i < this.terms.size(); i++) {
/* 268 */       int pos = ((Integer)this.positions.get(i)).intValue();
/* 269 */       String s = pieces[pos];
/* 270 */       if (s == null) {
/* 271 */         s = ((Term)this.terms.get(i)).text();
/*     */       } else {
/* 273 */         s = s + ""|"" + ((Term)this.terms.get(i)).text();
/*     */       } 
/* 275 */       pieces[pos] = s;
/*     */     } 
/* 277 */     for (int i = 0; i < pieces.length; i++) {
/* 278 */       if (i > 0) {
/* 279 */         buffer.append(' ');
/*     */       }
/* 281 */       String s = pieces[i];
/* 282 */       if (s == null) {
/* 283 */         buffer.append('?');
/*     */       } else {
/* 285 */         buffer.append(s);
/*     */       } 
/*     */     } 
/* 288 */     buffer.append(""\"""");
/*     */     
/* 290 */     if (this.slop != 0) {
/* 291 */       buffer.append(""~"");
/* 292 */       buffer.append(this.slop);
/*     */     } 
/*     */     
/* 295 */     buffer.append(ToStringUtils.boost(getBoost()));
/*     */     
/* 297 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 302 */     if (!(o instanceof PhraseQuery))
/* 303 */       return false; 
/* 304 */     PhraseQuery other = (PhraseQuery)o;
/* 305 */     return (getBoost() == other.getBoost() && this.slop == other.slop && this.terms.equals(other.terms) && this.positions.equals(other.positions));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 313 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.slop ^ this.terms.hashCode() ^ this.positions.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\PhraseQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseQueue,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class PhraseQueue
/*    */   extends PriorityQueue
/*    */ {
/* 24 */   PhraseQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object o1, Object o2) {
/* 28 */     PhrasePositions pp1 = (PhrasePositions)o1;
/* 29 */     PhrasePositions pp2 = (PhrasePositions)o2;
/* 30 */     if (pp1.doc == pp2.doc) {
/* 31 */       if (pp1.position == pp2.position)
/*    */       {
/*    */         
/* 34 */         return (pp1.offset < pp2.offset);
/*    */       }
/* 36 */       return (pp1.position < pp2.position);
/*    */     } 
/* 38 */     return (pp1.doc < pp2.doc);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\PhraseQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class PhraseScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Weight weight;
/*     */   protected byte[] norms;
/*     */   protected float value;
/*     */   private boolean firstTime = true;
/*     */   private boolean more = true;
/*     */   protected PhraseQueue pq;
/*     */   protected PhrasePositions first;
/*     */   protected PhrasePositions last;
/*     */   private float freq;
/*     */   
/*     */   PhraseScorer(Weight weight, TermPositions[] tps, int[] offsets, Similarity similarity, byte[] norms) {
/*  49 */     super(similarity);
/*  50 */     this.norms = norms;
/*  51 */     this.weight = weight;
/*  52 */     this.value = weight.getValue();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  59 */     for (int i = 0; i < tps.length; i++) {
/*  60 */       PhrasePositions pp = new PhrasePositions(tps[i], offsets[i]);
/*  61 */       if (this.last != null) {
/*  62 */         this.last.next = pp;
/*     */       } else {
/*  64 */         this.first = pp;
/*  65 */       }  this.last = pp;
/*     */     } 
/*     */     
/*  68 */     this.pq = new PhraseQueue(tps.length);
/*     */   }
/*     */ 
/*     */   
/*  72 */   public int doc() { return this.first.doc; }
/*     */   
/*     */   public boolean next() throws IOException {
/*  75 */     if (this.firstTime) {
/*  76 */       init();
/*  77 */       this.firstTime = false;
/*  78 */     } else if (this.more) {
/*  79 */       this.more = this.last.next();
/*     */     } 
/*  81 */     return doNext();
/*     */   }
/*     */ 
/*     */   
/*     */   private boolean doNext() throws IOException {
/*  86 */     while (this.more) {
/*  87 */       while (this.more && this.first.doc < this.last.doc) {
/*  88 */         this.more = this.first.skipTo(this.last.doc);
/*  89 */         firstToLast();
/*     */       } 
/*     */       
/*  92 */       if (this.more) {
/*     */         
/*  94 */         this.freq = phraseFreq();
/*  95 */         if (this.freq == 0.0F) {
/*  96 */           this.more = this.last.next(); continue;
/*     */         } 
/*  98 */         return true;
/*     */       } 
/*     */     } 
/* 101 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public float score() throws IOException {
/* 106 */     float raw = getSimilarity().tf(this.freq) * this.value;
/* 107 */     return raw * Similarity.decodeNorm(this.norms[this.first.doc]);
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 111 */     this.firstTime = false;
/* 112 */     for (PhrasePositions pp = this.first; this.more && pp != null; pp = pp.next) {
/* 113 */       this.more = pp.skipTo(target);
/*     */     }
/* 115 */     if (this.more)
/* 116 */       sort(); 
/* 117 */     return doNext();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract float phraseFreq() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void init() throws IOException {
/* 130 */     for (PhrasePositions pp = this.first; this.more && pp != null; pp = pp.next)
/* 131 */       this.more = pp.next(); 
/* 132 */     if (this.more)
/* 133 */       sort(); 
/*     */   }
/*     */   
/*     */   private void sort() {
/* 137 */     this.pq.clear();
/* 138 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next)
/* 139 */       this.pq.put(pp); 
/* 140 */     pqToList();
/*     */   }
/*     */   
/*     */   protected final void pqToList() {
/* 144 */     this.last = this.first = null;
/* 145 */     while (this.pq.top() != null) {
/* 146 */       PhrasePositions pp = (PhrasePositions)this.pq.pop();
/* 147 */       if (this.last != null) {
/* 148 */         this.last.next = pp;
/*     */       } else {
/* 150 */         this.first = pp;
/* 151 */       }  this.last = pp;
/* 152 */       pp.next = null;
/*     */     } 
/*     */   }
/*     */   
/*     */   protected final void firstToLast() {
/* 157 */     this.last.next = this.first;
/* 158 */     this.last = this.first;
/* 159 */     this.first = this.first.next;
/* 160 */     this.last.next = null;
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 164 */     Explanation tfExplanation = new Explanation();
/*     */     
/* 166 */     while (next() && doc() < doc);
/*     */     
/* 168 */     float phraseFreq = (doc() == doc) ? this.freq : 0.0F;
/* 169 */     tfExplanation.setValue(getSimilarity().tf(phraseFreq));
/* 170 */     tfExplanation.setDescription(""tf(phraseFreq="" + phraseFreq + "")"");
/*     */     
/* 172 */     return tfExplanation;
/*     */   }
/*     */   
/* 175 */   public String toString() { return ""scorer("" + this.weight + "")""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\PhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PrefixFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.util.OpenBitSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PrefixFilter
/*    */   extends Filter
/*    */ {
/*    */   protected final Term prefix;
/*    */   
/* 38 */   public PrefixFilter(Term prefix) { this.prefix = prefix; }
/*    */ 
/*    */   
/* 41 */   public Term getPrefix() { return this.prefix; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 47 */     final BitSet bitSet = new BitSet(reader.maxDoc());
/* 48 */     (new PrefixGenerator(this.prefix) { private final BitSet val$bitSet;
/*    */         
/* 50 */         public void handleDoc(int doc) { bitSet.set(doc); }
/*    */         private final PrefixFilter this$0; }
/*    */       ).generate(reader);
/* 53 */     return bitSet;
/*    */   }
/*    */   
/*    */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
/* 57 */     final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());
/* 58 */     (new PrefixGenerator(this.prefix) { private final OpenBitSet val$bitSet; private final PrefixFilter this$0;
/*    */         
/* 60 */         public void handleDoc(int doc) { bitSet.set(doc); }
/*    */          }
/*    */       ).generate(reader);
/* 63 */     return (DocIdSet)bitSet;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString() {
/* 68 */     StringBuffer buffer = new StringBuffer();
/* 69 */     buffer.append(""PrefixFilter("");
/* 70 */     buffer.append(this.prefix.toString());
/* 71 */     buffer.append("")"");
/* 72 */     return buffer.toString();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\PrefixFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PrefixGenerator,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class PrefixGenerator
/*     */   implements IdGenerator
/*     */ {
/*     */   protected final Term prefix;
/*     */   
/*  89 */   PrefixGenerator(Term prefix) { this.prefix = prefix; }
/*     */ 
/*     */   
/*     */   public void generate(IndexReader reader) throws IOException {
/*  93 */     TermEnum enumerator = reader.terms(this.prefix);
/*  94 */     TermDocs termDocs = reader.termDocs();
/*     */ 
/*     */ 
/*     */     
/*  98 */     try { String prefixText = this.prefix.text();
/*  99 */       String prefixField = this.prefix.field();
/*     */       while (true)
/* 101 */       { Term term = enumerator.term();
/* 102 */         if (term != null && term.text().startsWith(prefixText) && term.field() == prefixField)
/*     */         
/*     */         { 
/*     */           
/* 106 */           termDocs.seek(term);
/* 107 */           while (termDocs.next()) {
/* 108 */             handleDoc(termDocs.doc());
/*     */           }
/*     */ 
/*     */ 
/*     */           
/* 113 */           if (!enumerator.next())
/*     */             break;  continue; }  break; }  }
/* 115 */     finally { termDocs.close();
/* 116 */       enumerator.close(); }
/*     */   
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\PrefixGenerator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PrefixQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.index.TermEnum;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PrefixQuery
/*    */   extends Query
/*    */ {
/*    */   private Term prefix;
/*    */   
/* 34 */   public PrefixQuery(Term prefix) { this.prefix = prefix; }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public Term getPrefix() { return this.prefix; }
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 41 */     BooleanQuery query = new BooleanQuery(true);
/* 42 */     TermEnum enumerator = reader.terms(this.prefix);
/*    */     
/* 44 */     try { String prefixText = this.prefix.text();
/* 45 */       String prefixField = this.prefix.field();
/*    */       while (true)
/* 47 */       { Term term = enumerator.term();
/* 48 */         if (term != null && term.text().startsWith(prefixText) && term.field() == prefixField)
/*    */         
/*    */         { 
/*    */           
/* 52 */           TermQuery tq = new TermQuery(term);
/* 53 */           tq.setBoost(getBoost());
/* 54 */           query.add(tq, BooleanClause.Occur.SHOULD);
/*    */ 
/*    */ 
/*    */ 
/*    */           
/* 59 */           if (!enumerator.next())
/*    */             break;  continue; }  break; }  }
/* 61 */     finally { enumerator.close(); }
/*    */     
/* 63 */     return query;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 68 */     StringBuffer buffer = new StringBuffer();
/* 69 */     if (!this.prefix.field().equals(field)) {
/* 70 */       buffer.append(this.prefix.field());
/* 71 */       buffer.append("":"");
/*    */     } 
/* 73 */     buffer.append(this.prefix.text());
/* 74 */     buffer.append('*');
/* 75 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 76 */     return buffer.toString();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 81 */     if (!(o instanceof PrefixQuery))
/* 82 */       return false; 
/* 83 */     PrefixQuery other = (PrefixQuery)o;
/* 84 */     return (getBoost() == other.getBoost() && this.prefix.equals(other.prefix));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 90 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.prefix.hashCode() ^ 0x6634D93C; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\PrefixQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Query,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Query
/*     */   implements Serializable, Cloneable
/*     */ {
/*  48 */   private float boost = 1.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  54 */   public void setBoost(float b) { this.boost = b; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract String toString(String paramString);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   public String toString() { return toString(""""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  88 */   protected Weight createWeight(Searcher searcher) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Weight weight(Searcher searcher) throws IOException {
/*  94 */     Query query = searcher.rewrite(this);
/*  95 */     Weight weight = query.createWeight(searcher);
/*  96 */     float sum = weight.sumOfSquaredWeights();
/*  97 */     float norm = getSimilarity(searcher).queryNorm(sum);
/*  98 */     weight.normalize(norm);
/*  99 */     return weight;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Query combine(Query[] queries) {
/* 122 */     HashSet uniques = new HashSet();
/* 123 */     for (int i = 0; i < queries.length; i++) {
/* 124 */       Query query = queries[i];
/* 125 */       BooleanClause[] clauses = null;
/*     */       
/* 127 */       boolean splittable = query instanceof BooleanQuery;
/* 128 */       if (splittable) {
/* 129 */         BooleanQuery bq = (BooleanQuery)query;
/* 130 */         splittable = bq.isCoordDisabled();
/* 131 */         clauses = bq.getClauses();
/* 132 */         for (int j = 0; splittable && j < clauses.length; j++) {
/* 133 */           splittable = (clauses[j].getOccur() == BooleanClause.Occur.SHOULD);
/*     */         }
/*     */       } 
/* 136 */       if (splittable) {
/* 137 */         for (int j = 0; j < clauses.length; j++) {
/* 138 */           uniques.add(clauses[j].getQuery());
/*     */         }
/*     */       } else {
/* 141 */         uniques.add(query);
/*     */       } 
/*     */     } 
/*     */     
/* 145 */     if (uniques.size() == 1) {
/* 146 */       return uniques.iterator().next();
/*     */     }
/* 148 */     Iterator it = uniques.iterator();
/* 149 */     BooleanQuery result = new BooleanQuery(true);
/* 150 */     while (it.hasNext())
/* 151 */       result.add(it.next(), BooleanClause.Occur.SHOULD); 
/* 152 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 163 */   public void extractTerms(Set terms) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query mergeBooleanQueries(Query[] queries) {
/* 173 */     HashSet allClauses = new HashSet();
/* 174 */     for (int i = 0; i < queries.length; i++) {
/* 175 */       BooleanClause[] clauses = ((BooleanQuery)queries[i]).getClauses();
/* 176 */       for (int j = 0; j < clauses.length; j++) {
/* 177 */         allClauses.add(clauses[j]);
/*     */       }
/*     */     } 
/*     */     
/* 181 */     boolean coordDisabled = (queries.length == 0) ? false : ((BooleanQuery)queries[0]).isCoordDisabled();
/*     */     
/* 183 */     BooleanQuery result = new BooleanQuery(coordDisabled);
/* 184 */     Iterator i = allClauses.iterator();
/* 185 */     while (i.hasNext()) {
/* 186 */       result.add(i.next());
/*     */     }
/* 188 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   public Similarity getSimilarity(Searcher searcher) { return searcher.getSimilarity(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/*     */     try {
/* 202 */       return super.clone();
/* 203 */     } catch (CloneNotSupportedException e) {
/* 204 */       throw new RuntimeException(""Clone not supported: "" + e.getMessage());
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Query.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueryFilter
/*    */   extends CachingWrapperFilter
/*    */ {
/* 34 */   public QueryFilter(Query query) { super(new QueryWrapperFilter(query)); }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public boolean equals(Object o) { return super.equals(o); }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public int hashCode() { return super.hashCode() ^ 0x923F64B9; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\QueryFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryTermVector,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.StringReader;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Arrays;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.index.TermFreqVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class QueryTermVector
/*     */   implements TermFreqVector
/*     */ {
/*  39 */   private String[] terms = new String[0];
/*  40 */   private int[] termFreqs = new int[0];
/*     */   
/*  42 */   public String getField() { return null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public QueryTermVector(String[] queryTerms) { processTerms(queryTerms); }
/*     */ 
/*     */   
/*     */   public QueryTermVector(String queryString, Analyzer analyzer) {
/*  54 */     if (analyzer != null) {
/*     */       
/*  56 */       TokenStream stream = analyzer.tokenStream("""", new StringReader(queryString));
/*  57 */       if (stream != null) {
/*     */         
/*  59 */         List terms = new ArrayList();
/*     */         try {
/*  61 */           Token reusableToken = new Token();
/*  62 */           for (Token nextToken = stream.next(reusableToken); nextToken != null; nextToken = stream.next(reusableToken)) {
/*  63 */             terms.add(nextToken.term());
/*     */           }
/*  65 */           processTerms(terms.toArray(new String[terms.size()]));
/*  66 */         } catch (IOException e) {}
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void processTerms(String[] queryTerms) {
/*  73 */     if (queryTerms != null) {
/*  74 */       Arrays.sort((Object[])queryTerms);
/*  75 */       Map tmpSet = new HashMap(queryTerms.length);
/*     */       
/*  77 */       List tmpList = new ArrayList(queryTerms.length);
/*  78 */       List tmpFreqs = new ArrayList(queryTerms.length);
/*  79 */       int j = 0;
/*  80 */       for (int i = 0; i < queryTerms.length; i++) {
/*  81 */         String term = queryTerms[i];
/*  82 */         Integer position = (Integer)tmpSet.get(term);
/*  83 */         if (position == null) {
/*  84 */           tmpSet.put(term, new Integer(j++));
/*  85 */           tmpList.add(term);
/*  86 */           tmpFreqs.add(new Integer(1));
/*     */         } else {
/*     */           
/*  89 */           Integer integer = tmpFreqs.get(position.intValue());
/*  90 */           tmpFreqs.set(position.intValue(), new Integer(integer.intValue() + 1));
/*     */         } 
/*     */       } 
/*  93 */       this.terms = tmpList.toArray(this.terms);
/*     */       
/*  95 */       this.termFreqs = new int[tmpFreqs.size()];
/*  96 */       int i = 0;
/*  97 */       for (Iterator iter = tmpFreqs.iterator(); iter.hasNext(); ) {
/*  98 */         Integer integer = iter.next();
/*  99 */         this.termFreqs[i++] = integer.intValue();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public final String toString() {
/* 105 */     StringBuffer sb = new StringBuffer();
/* 106 */     sb.append('{');
/* 107 */     for (int i = 0; i < this.terms.length; i++) {
/* 108 */       if (i > 0) sb.append("", ""); 
/* 109 */       sb.append(this.terms[i]).append('/').append(this.termFreqs[i]);
/*     */     } 
/* 111 */     sb.append('}');
/* 112 */     return sb.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 117 */   public int size() { return this.terms.length; }
/*     */ 
/*     */ 
/*     */   
/* 121 */   public String[] getTerms() { return this.terms; }
/*     */ 
/*     */ 
/*     */   
/* 125 */   public int[] getTermFrequencies() { return this.termFreqs; }
/*     */ 
/*     */   
/*     */   public int indexOf(String term) {
/* 129 */     int res = Arrays.binarySearch((Object[])this.terms, term);
/* 130 */     return (res >= 0) ? res : -1;
/*     */   }
/*     */   
/*     */   public int[] indexesOf(String[] terms, int start, int len) {
/* 134 */     int[] res = new int[len];
/*     */     
/* 136 */     for (int i = 0; i < len; i++) {
/* 137 */       res[i] = indexOf(terms[i]);
/*     */     }
/* 139 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\QueryTermVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryWrapperFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.util.OpenBitSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueryWrapperFilter
/*    */   extends Filter
/*    */ {
/*    */   private Query query;
/*    */   
/* 45 */   public QueryWrapperFilter(Query query) { this.query = query; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 52 */     final BitSet bits = new BitSet(reader.maxDoc());
/*    */     
/* 54 */     (new IndexSearcher(reader)).search(this.query, new HitCollector() { private final BitSet val$bits;
/*    */           
/* 56 */           public final void collect(int doc, float score) { bits.set(doc); }
/*    */           private final QueryWrapperFilter this$0; }
/*    */       );
/* 59 */     return bits;
/*    */   }
/*    */   
/*    */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
/* 63 */     final OpenBitSet bits = new OpenBitSet(reader.maxDoc());
/*    */     
/* 65 */     (new IndexSearcher(reader)).search(this.query, new HitCollector() { private final OpenBitSet val$bits; private final QueryWrapperFilter this$0;
/*    */           
/* 67 */           public final void collect(int doc, float score) { bits.set(doc); }
/*    */            }
/*    */       );
/* 70 */     return (DocIdSet)bits;
/*    */   }
/*    */ 
/*    */   
/* 74 */   public String toString() { return ""QueryWrapperFilter("" + this.query + "")""; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 78 */     if (!(o instanceof QueryWrapperFilter))
/* 79 */       return false; 
/* 80 */     return this.query.equals(((QueryWrapperFilter)o).query);
/*    */   }
/*    */ 
/*    */   
/* 84 */   public int hashCode() { return this.query.hashCode() ^ 0x923F64B9; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\QueryWrapperFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RangeFilter,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.text.Collator;
/*     */ import java.util.BitSet;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ import org.apache.lucene.util.OpenBitSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RangeFilter
/*     */   extends Filter
/*     */ {
/*     */   private String fieldName;
/*     */   private String lowerTerm;
/*     */   private String upperTerm;
/*     */   private boolean includeLower;
/*     */   private boolean includeUpper;
/*     */   private Collator collator;
/*     */   
/*     */   public RangeFilter(String fieldName, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
/*  60 */     this.fieldName = fieldName;
/*  61 */     this.lowerTerm = lowerTerm;
/*  62 */     this.upperTerm = upperTerm;
/*  63 */     this.includeLower = includeLower;
/*  64 */     this.includeUpper = includeUpper;
/*     */     
/*  66 */     if (null == lowerTerm && null == upperTerm) {
/*  67 */       throw new IllegalArgumentException(""At least one value must be non-null"");
/*     */     }
/*     */     
/*  70 */     if (includeLower && null == lowerTerm) {
/*  71 */       throw new IllegalArgumentException(""The lower bound must be non-null to be inclusive"");
/*     */     }
/*     */     
/*  74 */     if (includeUpper && null == upperTerm) {
/*  75 */       throw new IllegalArgumentException(""The upper bound must be non-null to be inclusive"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RangeFilter(String fieldName, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper, Collator collator) {
/* 100 */     this(fieldName, lowerTerm, upperTerm, includeLower, includeUpper);
/* 101 */     this.collator = collator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public static RangeFilter Less(String fieldName, String upperTerm) { return new RangeFilter(fieldName, null, upperTerm, false, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 117 */   public static RangeFilter More(String fieldName, String lowerTerm) { return new RangeFilter(fieldName, lowerTerm, null, true, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BitSet bits(IndexReader reader) throws IOException {
/* 127 */     BitSet bits = new BitSet(reader.maxDoc());
/* 128 */     TermEnum enumerator = (null != this.lowerTerm && this.collator == null) ? reader.terms(new Term(this.fieldName, this.lowerTerm)) : reader.terms(new Term(this.fieldName));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 135 */       if (enumerator.term() == null) {
/* 136 */         return bits;
/*     */       }
/*     */       
/* 139 */       TermDocs termDocs = reader.termDocs();
/*     */       
/* 141 */       try { if (this.collator != null) {
/*     */           do {
/* 143 */             Term term = enumerator.term();
/* 144 */             if (term == null || !term.field().equals(this.fieldName) || (
/* 145 */               this.lowerTerm != null && (this.includeLower ? (this.collator.compare(term.text(), this.lowerTerm) >= 0) : (this.collator.compare(term.text(), this.lowerTerm) > 0))) || (this.upperTerm != null && (this.includeUpper ? (this.collator.compare(term.text(), this.upperTerm) <= 0) : (this.collator.compare(term.text(), this.upperTerm) < 0)))) {
/*     */               continue;
/*     */             }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 154 */             termDocs.seek(enumerator.term());
/* 155 */             while (termDocs.next()) {
/* 156 */               bits.set(termDocs.doc());
/*     */             
/*     */             }
/*     */           
/*     */           }
/* 161 */           while (enumerator.next());
/*     */         } else {
/* 163 */           boolean checkLower = false;
/* 164 */           if (!this.includeLower) {
/* 165 */             checkLower = true;
/*     */           }
/*     */           while (true)
/* 168 */           { Term term = enumerator.term();
/* 169 */             if (term != null && term.field().equals(this.fieldName))
/* 170 */             { if (!checkLower || null == this.lowerTerm || term.text().compareTo(this.lowerTerm) > 0) {
/* 171 */                 checkLower = false;
/* 172 */                 if (this.upperTerm != null) {
/* 173 */                   int compare = this.upperTerm.compareTo(term.text());
/*     */ 
/*     */                   
/* 176 */                   if (compare < 0 || (!this.includeUpper && compare == 0)) {
/*     */                     break;
/*     */                   }
/*     */                 } 
/*     */ 
/*     */ 
/*     */                 
/* 183 */                 termDocs.seek(enumerator.term());
/* 184 */                 while (termDocs.next()) {
/* 185 */                   bits.set(termDocs.doc());
/*     */                 }
/*     */               } 
/*     */ 
/*     */ 
/*     */ 
/*     */               
/* 192 */               if (!enumerator.next())
/*     */                 break;  continue; }  break; } 
/*     */         }  }
/* 195 */       finally { termDocs.close(); }
/*     */     
/*     */     } finally {
/* 198 */       enumerator.close();
/*     */     } 
/*     */     
/* 201 */     return bits;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
/* 209 */     OpenBitSet bits = new OpenBitSet(reader.maxDoc());
/*     */     
/* 211 */     TermEnum enumerator = (null != this.lowerTerm && this.collator == null) ? reader.terms(new Term(this.fieldName, this.lowerTerm)) : reader.terms(new Term(this.fieldName));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 218 */       if (enumerator.term() == null) {
/* 219 */         return (DocIdSet)bits;
/*     */       }
/*     */       
/* 222 */       TermDocs termDocs = reader.termDocs();
/*     */ 
/*     */       
/* 225 */       try { if (this.collator != null) {
/*     */           do {
/* 227 */             Term term = enumerator.term();
/* 228 */             if (term == null || !term.field().equals(this.fieldName) || (
/* 229 */               this.lowerTerm != null && (this.includeLower ? (this.collator.compare(term.text(), this.lowerTerm) >= 0) : (this.collator.compare(term.text(), this.lowerTerm) > 0))) || (this.upperTerm != null && (this.includeUpper ? (this.collator.compare(term.text(), this.upperTerm) <= 0) : (this.collator.compare(term.text(), this.upperTerm) < 0)))) {
/*     */               continue;
/*     */             }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 238 */             termDocs.seek(enumerator.term());
/* 239 */             while (termDocs.next()) {
/* 240 */               bits.set(termDocs.doc());
/*     */             
/*     */             }
/*     */           
/*     */           }
/* 245 */           while (enumerator.next());
/*     */         } else {
/* 247 */           boolean checkLower = false;
/* 248 */           if (!this.includeLower) {
/* 249 */             checkLower = true;
/*     */           }
/*     */           while (true) {
/* 252 */             Term term = enumerator.term();
/* 253 */             if (term != null && term.field().equals(this.fieldName))
/* 254 */             { if (!checkLower || null == this.lowerTerm || term.text().compareTo(this.lowerTerm) > 0) {
/* 255 */                 checkLower = false;
/* 256 */                 if (this.upperTerm != null) {
/* 257 */                   int compare = this.upperTerm.compareTo(term.text());
/*     */ 
/*     */                   
/* 260 */                   if (compare < 0 || (!this.includeUpper && compare == 0)) {
/*     */                     break;
/*     */                   }
/*     */                 } 
/*     */ 
/*     */ 
/*     */                 
/* 267 */                 termDocs.seek(enumerator.term());
/* 268 */                 while (termDocs.next()) {
/* 269 */                   bits.set(termDocs.doc());
/*     */                 }
/*     */               } 
/*     */ 
/*     */ 
/*     */ 
/*     */               
/* 276 */               if (!enumerator.next())
/*     */                 break;  continue; }  break;
/*     */           } 
/*     */         }  }
/* 280 */       finally { termDocs.close(); }
/*     */     
/*     */     } finally {
/* 283 */       enumerator.close();
/*     */     } 
/*     */     
/* 286 */     return (DocIdSet)bits;
/*     */   }
/*     */   
/*     */   public String toString() {
/* 290 */     StringBuffer buffer = new StringBuffer();
/* 291 */     buffer.append(this.fieldName);
/* 292 */     buffer.append("":"");
/* 293 */     buffer.append(this.includeLower ? ""["" : ""{"");
/* 294 */     if (null != this.lowerTerm) {
/* 295 */       buffer.append(this.lowerTerm);
/*     */     }
/* 297 */     buffer.append(""-"");
/* 298 */     if (null != this.upperTerm) {
/* 299 */       buffer.append(this.upperTerm);
/*     */     }
/* 301 */     buffer.append(this.includeUpper ? ""]"" : ""}"");
/* 302 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 307 */     if (this == o) return true; 
/* 308 */     if (!(o instanceof RangeFilter)) return false; 
/* 309 */     RangeFilter other = (RangeFilter)o;
/*     */     
/* 311 */     if (!this.fieldName.equals(other.fieldName) || this.includeLower != other.includeLower || this.includeUpper != other.includeUpper || (this.collator != null && !this.collator.equals(other.collator)))
/*     */     {
/*     */ 
/*     */       
/* 315 */       return false; } 
/* 316 */     if ((this.lowerTerm != null) ? !this.lowerTerm.equals(other.lowerTerm) : (other.lowerTerm != null)) return false; 
/* 317 */     if ((this.upperTerm != null) ? !this.upperTerm.equals(other.upperTerm) : (other.upperTerm != null)) return false; 
/* 318 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 323 */     int h = this.fieldName.hashCode();
/* 324 */     h ^= (this.lowerTerm != null) ? this.lowerTerm.hashCode() : -1225987966;
/* 325 */     h = h << 1 | h >>> 31;
/* 326 */     h ^= (this.upperTerm != null) ? this.upperTerm.hashCode() : -1849769278;
/* 327 */     h ^= (this.includeLower ? -729499341 : 0) ^ (this.includeUpper ? 1793336236 : 0);
/*     */     
/* 329 */     h ^= (this.collator != null) ? this.collator.hashCode() : 0;
/* 330 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\RangeFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RangeQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.text.Collator;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RangeQuery
/*     */   extends Query
/*     */ {
/*     */   private Term lowerTerm;
/*     */   private Term upperTerm;
/*     */   private boolean inclusive;
/*     */   private Collator collator;
/*     */   
/*     */   public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
/*  65 */     if (lowerTerm == null && upperTerm == null)
/*     */     {
/*  67 */       throw new IllegalArgumentException(""At least one term must be non-null"");
/*     */     }
/*  69 */     if (lowerTerm != null && upperTerm != null && lowerTerm.field() != upperTerm.field())
/*     */     {
/*  71 */       throw new IllegalArgumentException(""Both terms must be for the same field"");
/*     */     }
/*     */ 
/*     */     
/*  75 */     if (lowerTerm != null) {
/*  76 */       this.lowerTerm = lowerTerm;
/*     */     } else {
/*     */       
/*  79 */       this.lowerTerm = new Term(upperTerm.field());
/*     */     } 
/*     */     
/*  82 */     this.upperTerm = upperTerm;
/*  83 */     this.inclusive = inclusive;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive, Collator collator) {
/* 113 */     this(lowerTerm, upperTerm, inclusive);
/* 114 */     this.collator = collator;
/*     */   }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 119 */     BooleanQuery query = new BooleanQuery(true);
/* 120 */     String testField = getField();
/* 121 */     if (this.collator != null) {
/* 122 */       TermEnum enumerator = reader.terms(new Term(testField, """"));
/* 123 */       String lowerTermText = (this.lowerTerm != null) ? this.lowerTerm.text() : null;
/* 124 */       String upperTermText = (this.upperTerm != null) ? this.upperTerm.text() : null;
/*     */       
/*     */       try {
/*     */         do {
/* 128 */           Term term = enumerator.term();
/* 129 */           if (term == null || term.field() != testField || (
/* 130 */             lowerTermText != null && (this.inclusive ? (this.collator.compare(term.text(), lowerTermText) >= 0) : (this.collator.compare(term.text(), lowerTermText) > 0))) || (upperTermText != null && (this.inclusive ? (this.collator.compare(term.text(), upperTermText) <= 0) : (this.collator.compare(term.text(), upperTermText) < 0)))) {
/*     */             continue;
/*     */           }
/*     */ 
/*     */ 
/*     */           
/* 136 */           addTermToQuery(term, query);
/*     */ 
/*     */         
/*     */         }
/* 140 */         while (enumerator.next());
/*     */       } finally {
/*     */         
/* 143 */         enumerator.close();
/*     */       } 
/*     */     } else {
/*     */       
/* 147 */       TermEnum enumerator = reader.terms(this.lowerTerm);
/*     */ 
/*     */ 
/*     */       
/* 151 */       try { boolean checkLower = false;
/* 152 */         if (!this.inclusive) {
/* 153 */           checkLower = true;
/*     */         }
/*     */         while (true) {
/* 156 */           Term term = enumerator.term();
/* 157 */           if (term != null && term.field() == testField)
/* 158 */           { if (!checkLower || term.text().compareTo(this.lowerTerm.text()) > 0) {
/* 159 */               checkLower = false;
/* 160 */               if (this.upperTerm != null) {
/* 161 */                 int compare = this.upperTerm.text().compareTo(term.text());
/*     */ 
/*     */                 
/* 164 */                 if (compare < 0 || (!this.inclusive && compare == 0))
/*     */                   break; 
/*     */               } 
/* 167 */               addTermToQuery(term, query);
/*     */             } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 174 */             if (!enumerator.next())
/*     */               break;  continue; }  break;
/*     */         }  }
/* 177 */       finally { enumerator.close(); }
/*     */     
/*     */     } 
/* 180 */     return query;
/*     */   }
/*     */   
/*     */   private void addTermToQuery(Term term, BooleanQuery query) {
/* 184 */     TermQuery tq = new TermQuery(term);
/* 185 */     tq.setBoost(getBoost());
/* 186 */     query.add(tq, BooleanClause.Occur.SHOULD);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 191 */   public String getField() { return (this.lowerTerm != null) ? this.lowerTerm.field() : this.upperTerm.field(); }
/*     */ 
/*     */ 
/*     */   
/* 195 */   public Term getLowerTerm() { return this.lowerTerm; }
/*     */ 
/*     */   
/* 198 */   public Term getUpperTerm() { return this.upperTerm; }
/*     */ 
/*     */   
/* 201 */   public boolean isInclusive() { return this.inclusive; }
/*     */ 
/*     */   
/* 204 */   public Collator getCollator() { return this.collator; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 210 */     StringBuffer buffer = new StringBuffer();
/* 211 */     if (!getField().equals(field)) {
/*     */       
/* 213 */       buffer.append(getField());
/* 214 */       buffer.append("":"");
/*     */     } 
/* 216 */     buffer.append(this.inclusive ? ""["" : ""{"");
/* 217 */     buffer.append((this.lowerTerm != null) ? this.lowerTerm.text() : ""null"");
/* 218 */     buffer.append("" TO "");
/* 219 */     buffer.append((this.upperTerm != null) ? this.upperTerm.text() : ""null"");
/* 220 */     buffer.append(this.inclusive ? ""]"" : ""}"");
/* 221 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 222 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 227 */     if (this == o) return true; 
/* 228 */     if (!(o instanceof RangeQuery)) return false;
/*     */     
/* 230 */     RangeQuery other = (RangeQuery)o;
/* 231 */     if (getBoost() != other.getBoost()) return false; 
/* 232 */     if (this.inclusive != other.inclusive) return false; 
/* 233 */     if (this.collator != null && !this.collator.equals(other.collator)) {
/* 234 */       return false;
/*     */     }
/*     */     
/* 237 */     if ((this.lowerTerm != null) ? !this.lowerTerm.equals(other.lowerTerm) : (other.lowerTerm != null)) return false; 
/* 238 */     if ((this.upperTerm != null) ? !this.upperTerm.equals(other.upperTerm) : (other.upperTerm != null)) return false; 
/* 239 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 244 */     int h = Float.floatToIntBits(getBoost());
/* 245 */     h ^= (this.lowerTerm != null) ? this.lowerTerm.hashCode() : 0;
/*     */ 
/*     */     
/* 248 */     h ^= h << 25 | h >>> 8;
/* 249 */     h ^= (this.upperTerm != null) ? this.upperTerm.hashCode() : 0;
/* 250 */     h ^= this.inclusive ? 658696010 : 0;
/* 251 */     h ^= (this.collator != null) ? this.collator.hashCode() : 0;
/* 252 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\RangeQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteCachingWrapperFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RemoteCachingWrapperFilter
/*    */   extends Filter
/*    */ {
/*    */   protected Filter filter;
/*    */   
/* 44 */   public RemoteCachingWrapperFilter(Filter filter) { this.filter = filter; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 55 */     Filter cachedFilter = FilterManager.getInstance().getFilter(this.filter);
/* 56 */     return cachedFilter.bits(reader);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
/* 66 */     Filter cachedFilter = FilterManager.getInstance().getFilter(this.filter);
/* 67 */     return cachedFilter.getDocIdSet(reader);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\RemoteCachingWrapperFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteSearchable,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.rmi.Naming;
/*     */ import java.rmi.RMISecurityManager;
/*     */ import java.rmi.RemoteException;
/*     */ import java.rmi.server.UnicastRemoteObject;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RemoteSearchable
/*     */   extends UnicastRemoteObject
/*     */   implements Searchable
/*     */ {
/*     */   private Searchable local;
/*     */   
/*  45 */   public RemoteSearchable(Searchable local) throws RemoteException { this.local = local; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  51 */   public void search(Weight weight, Filter filter, HitCollector results) throws IOException { this.local.search(weight, filter, results); }
/*     */ 
/*     */ 
/*     */   
/*  55 */   public void close() throws IOException { this.local.close(); }
/*     */ 
/*     */ 
/*     */   
/*  59 */   public int docFreq(Term term) throws IOException { return this.local.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   public int[] docFreqs(Term[] terms) throws IOException { return this.local.docFreqs(terms); }
/*     */ 
/*     */ 
/*     */   
/*  68 */   public int maxDoc() throws IOException { return this.local.maxDoc(); }
/*     */ 
/*     */ 
/*     */   
/*  72 */   public TopDocs search(Weight weight, Filter filter, int n) throws IOException { return this.local.search(weight, filter, n); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  78 */   public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) throws IOException { return this.local.search(weight, filter, n, sort); }
/*     */ 
/*     */ 
/*     */   
/*  82 */   public Document doc(int i) throws CorruptIndexException, IOException { return this.local.doc(i); }
/*     */ 
/*     */ 
/*     */   
/*  86 */   public Document doc(int i, FieldSelector fieldSelector) throws CorruptIndexException, IOException { return this.local.doc(i, fieldSelector); }
/*     */ 
/*     */ 
/*     */   
/*  90 */   public Query rewrite(Query original) throws IOException { return this.local.rewrite(original); }
/*     */ 
/*     */ 
/*     */   
/*  94 */   public Explanation explain(Weight weight, int doc) throws IOException { return this.local.explain(weight, doc); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) throws Exception {
/* 100 */     String indexName = null;
/*     */     
/* 102 */     if (args != null && args.length == 1) {
/* 103 */       indexName = args[0];
/*     */     }
/* 105 */     if (indexName == null) {
/* 106 */       System.out.println(""Usage: org.apache.lucene.search.RemoteSearchable <index>"");
/*     */       
/*     */       return;
/*     */     } 
/*     */     
/* 111 */     if (System.getSecurityManager() == null) {
/* 112 */       System.setSecurityManager(new RMISecurityManager());
/*     */     }
/*     */     
/* 115 */     Searchable local = new IndexSearcher(indexName);
/* 116 */     RemoteSearchable impl = new RemoteSearchable(local);
/*     */ 
/*     */     
/* 119 */     Naming.rebind(""//localhost/Searchable"", impl);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\RemoteSearchable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteSearchable_Stub,"package org.apache.lucene.search;
import java.io.IOException;
import java.lang.reflect.Method;
import java.rmi.Remote;
import java.rmi.UnexpectedException;
import java.rmi.server.RemoteRef;
import java.rmi.server.RemoteStub;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.FieldSelector;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.Term;
public final class RemoteSearchable_Stub extends RemoteStub implements Searchable, Remote {
  private static final long serialVersionUID = 2L;
  private static Method $method_close_0;
  private static Method $method_doc_1;
  private static Method $method_doc_2;
  private static Method $method_docFreq_3;
  private static Method $method_docFreqs_4;
  private static Method $method_explain_5;
  private static Method $method_maxDoc_6;
  private static Method $method_rewrite_7;
  private static Method $method_search_8;
  private static Method $method_search_9;
  private static Method $method_search_10;
  static Class array$Lorg$apache$lucene$index$Term;
  static  {
    try {
      $method_close_0 = Searchable.class.getMethod(""close"", new Class[0]);
      $method_doc_1 = Searchable.class.getMethod(""doc"", new Class[] { int.class });
      $method_doc_2 = Searchable.class.getMethod(""doc"", new Class[] { int.class, FieldSelector.class });
      $method_docFreq_3 = Searchable.class.getMethod(""docFreq"", new Class[] { Term.class });
      $method_docFreqs_4 = Searchable.class.getMethod(""docFreqs"", new Class[] { (array$Lorg$apache$lucene$index$Term != null) ? array$Lorg$apache$lucene$index$Term : (array$Lorg$apache$lucene$index$Term = class$(""[Lorg.apache.lucene.index.Term;"")) });
      $method_explain_5 = Searchable.class.getMethod(""explain"", new Class[] { Weight.class, int.class });
      $method_maxDoc_6 = Searchable.class.getMethod(""maxDoc"", new Class[0]);
      $method_rewrite_7 = Searchable.class.getMethod(""rewrite"", new Class[] { Query.class });
      $method_search_8 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, int.class });
      $method_search_9 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, int.class, Sort.class });
      $method_search_10 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, HitCollector.class });
    } catch (NoSuchMethodException noSuchMethodException) {
      throw new NoSuchMethodError(""stub class initialization failed"");
    } 
  }
  public RemoteSearchable_Stub(RemoteRef paramRemoteRef) { super(paramRemoteRef); }
  public void close() throws IOException {
    try {
      this.ref.invoke(this, $method_close_0, null, -4742752445160157748L);
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Document doc(int paramInt) throws IOException, CorruptIndexException {
    try {
      Object object = this.ref.invoke(this, $method_doc_1, new Object[] { new Integer(paramInt) }, -3205250690722925732L);
      return (Document)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Document doc(int paramInt, FieldSelector paramFieldSelector) throws IOException, CorruptIndexException {
    try {
      Object object = this.ref.invoke(this, $method_doc_2, new Object[] { new Integer(paramInt), paramFieldSelector }, 7307006286330810481L);
      return (Document)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int docFreq(Term paramTerm) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_docFreq_3, new Object[] { paramTerm }, -7822449680410044026L);
      return ((Integer)object).intValue();
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int[] docFreqs(Term[] paramArrayOfTerm) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_docFreqs_4, new Object[] { paramArrayOfTerm }, -6962924314824234139L);
      return (int[])object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Explanation explain(Weight paramWeight, int paramInt) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_explain_5, new Object[] { paramWeight, new Integer(paramInt) }, -5828411204312880318L);
      return (Explanation)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int maxDoc() throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_maxDoc_6, null, -2054052621300804366L);
      return ((Integer)object).intValue();
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Query rewrite(Query paramQuery) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_rewrite_7, new Object[] { paramQuery }, 6327992687997160630L);
      return (Query)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_search_8, new Object[] { paramWeight, paramFilter, new Integer(paramInt) }, -851074451725023257L);
      return (TopDocs)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_search_9, new Object[] { paramWeight, paramFilter, new Integer(paramInt), paramSort }, 587843085215608570L);
      return (TopFieldDocs)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException {
    try {
      this.ref.invoke(this, $method_search_10, new Object[] { paramWeight, paramFilter, paramHitCollector }, -5970991905374566433L);
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\RemoteSearchable_Stub.class
 * Java compiler version: 1 (45.3)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ReqExclScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ReqExclScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Scorer reqScorer;
/*     */   private Scorer exclScorer;
/*     */   private boolean firstTime;
/*     */   
/*     */   public ReqExclScorer(Scorer reqScorer, Scorer exclScorer) {
/*  38 */     super(null);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  43 */     this.firstTime = true;
/*     */     this.reqScorer = reqScorer;
/*     */     this.exclScorer = exclScorer; } public boolean next() throws IOException {
/*  46 */     if (this.firstTime) {
/*  47 */       if (!this.exclScorer.next()) {
/*  48 */         this.exclScorer = null;
/*     */       }
/*  50 */       this.firstTime = false;
/*     */     } 
/*  52 */     if (this.reqScorer == null) {
/*  53 */       return false;
/*     */     }
/*  55 */     if (!this.reqScorer.next()) {
/*  56 */       this.reqScorer = null;
/*  57 */       return false;
/*     */     } 
/*  59 */     if (this.exclScorer == null) {
/*  60 */       return true;
/*     */     }
/*  62 */     return toNonExcluded();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean toNonExcluded() throws IOException {
/*  77 */     int exclDoc = this.exclScorer.doc();
/*     */     do {
/*  79 */       int reqDoc = this.reqScorer.doc();
/*  80 */       if (reqDoc < exclDoc)
/*  81 */         return true; 
/*  82 */       if (reqDoc <= exclDoc)
/*  83 */         continue;  if (!this.exclScorer.skipTo(reqDoc)) {
/*  84 */         this.exclScorer = null;
/*  85 */         return true;
/*     */       } 
/*  87 */       exclDoc = this.exclScorer.doc();
/*  88 */       if (exclDoc > reqDoc) {
/*  89 */         return true;
/*     */       }
/*     */     }
/*  92 */     while (this.reqScorer.next());
/*  93 */     this.reqScorer = null;
/*  94 */     return false;
/*     */   }
/*     */ 
/*     */   
/*  98 */   public int doc() { return this.reqScorer.doc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public float score() throws IOException { return this.reqScorer.score(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 116 */     if (this.firstTime) {
/* 117 */       this.firstTime = false;
/* 118 */       if (!this.exclScorer.skipTo(target)) {
/* 119 */         this.exclScorer = null;
/*     */       }
/*     */     } 
/* 122 */     if (this.reqScorer == null) {
/* 123 */       return false;
/*     */     }
/* 125 */     if (this.exclScorer == null) {
/* 126 */       return this.reqScorer.skipTo(target);
/*     */     }
/* 128 */     if (!this.reqScorer.skipTo(target)) {
/* 129 */       this.reqScorer = null;
/* 130 */       return false;
/*     */     } 
/* 132 */     return toNonExcluded();
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 136 */     Explanation res = new Explanation();
/* 137 */     if (this.exclScorer.skipTo(doc) && this.exclScorer.doc() == doc) {
/* 138 */       res.setDescription(""excluded"");
/*     */     } else {
/* 140 */       res.setDescription(""not excluded"");
/* 141 */       res.addDetail(this.reqScorer.explain(doc));
/*     */     } 
/* 143 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ReqExclScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ReqOptSumScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ReqOptSumScorer
/*    */   extends Scorer
/*    */ {
/*    */   private Scorer reqScorer;
/*    */   private Scorer optScorer;
/*    */   private boolean firstTimeOptScorer;
/*    */   
/*    */   public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer) {
/* 41 */     super(null);
/*    */ 
/*    */ 
/*    */ 
/*    */     
/* 46 */     this.firstTimeOptScorer = true;
/*    */     this.reqScorer = reqScorer;
/*    */     this.optScorer = optScorer;
/* 49 */   } public boolean next() throws IOException { return this.reqScorer.next(); }
/*    */ 
/*    */ 
/*    */   
/* 53 */   public boolean skipTo(int target) throws IOException { return this.reqScorer.skipTo(target); }
/*    */ 
/*    */ 
/*    */   
/* 57 */   public int doc() { return this.reqScorer.doc(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public float score() throws IOException {
/* 66 */     int curDoc = this.reqScorer.doc();
/* 67 */     float reqScore = this.reqScorer.score();
/* 68 */     if (this.firstTimeOptScorer)
/* 69 */     { this.firstTimeOptScorer = false;
/* 70 */       if (!this.optScorer.skipTo(curDoc)) {
/* 71 */         this.optScorer = null;
/* 72 */         return reqScore;
/*    */       }  }
/* 74 */     else { if (this.optScorer == null)
/* 75 */         return reqScore; 
/* 76 */       if (this.optScorer.doc() < curDoc && !this.optScorer.skipTo(curDoc)) {
/* 77 */         this.optScorer = null;
/* 78 */         return reqScore;
/*    */       }  }
/*    */     
/* 81 */     return (this.optScorer.doc() == curDoc) ? (reqScore + this.optScorer.score()) : reqScore;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Explanation explain(int doc) throws IOException {
/* 91 */     Explanation res = new Explanation();
/* 92 */     res.setDescription(""required, optional"");
/* 93 */     res.addDetail(this.reqScorer.explain(doc));
/* 94 */     res.addDetail(this.optScorer.explain(doc));
/* 95 */     return res;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ReqOptSumScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ScoreDoc,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ScoreDoc
/*    */   implements Serializable
/*    */ {
/*    */   public float score;
/*    */   public int doc;
/*    */   
/*    */   public ScoreDoc(int doc, float score) {
/* 33 */     this.doc = doc;
/* 34 */     this.score = score;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ScoreDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ScoreDocComparator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface ScoreDocComparator
/*    */ {
/* 32 */   public static final ScoreDocComparator RELEVANCE = new ScoreDocComparator() {
/*    */       public int compare(ScoreDoc i, ScoreDoc j) {
/* 34 */         if (i.score > j.score) return -1; 
/* 35 */         if (i.score < j.score) return 1; 
/* 36 */         return 0;
/*    */       }
/*    */       
/* 39 */       public Comparable sortValue(ScoreDoc i) { return new Float(i.score); }
/*    */ 
/*    */       
/* 42 */       public int sortType() { return 0; }
/*    */     };
/*    */ 
/*    */ 
/*    */   
/* 47 */   public static final ScoreDocComparator INDEXORDER = new ScoreDocComparator() {
/*    */       public int compare(ScoreDoc i, ScoreDoc j) {
/* 49 */         if (i.doc < j.doc) return -1; 
/* 50 */         if (i.doc > j.doc) return 1; 
/* 51 */         return 0;
/*    */       }
/*    */       
/* 54 */       public Comparable sortValue(ScoreDoc i) { return new Integer(i.doc); }
/*    */ 
/*    */       
/* 57 */       public int sortType() { return 1; }
/*    */     };
/*    */   
/*    */   int compare(ScoreDoc paramScoreDoc1, ScoreDoc paramScoreDoc2);
/*    */   
/*    */   Comparable sortValue(ScoreDoc paramScoreDoc);
/*    */   
/*    */   int sortType();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\ScoreDocComparator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Scorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Scorer
/*    */   extends DocIdSetIterator
/*    */ {
/*    */   private Similarity similarity;
/*    */   
/* 43 */   protected Scorer(Similarity similarity) { this.similarity = similarity; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public Similarity getSimilarity() { return this.similarity; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void score(HitCollector hc) throws IOException {
/* 57 */     while (next()) {
/* 58 */       hc.collect(doc(), score());
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 71 */     while (doc() < max) {
/* 72 */       hc.collect(doc(), score());
/* 73 */       if (!next())
/* 74 */         return false; 
/*    */     } 
/* 76 */     return true;
/*    */   }
/*    */   
/*    */   public abstract float score() throws IOException;
/*    */   
/*    */   public abstract Explanation explain(int paramInt) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Scorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Searchable,"package org.apache.lucene.search;
import java.io.IOException;
import java.rmi.Remote;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.FieldSelector;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.Term;
public interface Searchable extends Remote {
  void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException;
  void close() throws IOException;
  int docFreq(Term paramTerm) throws IOException;
  int[] docFreqs(Term[] paramArrayOfTerm) throws IOException;
  int maxDoc() throws IOException;
  TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException;
  Document doc(int paramInt) throws CorruptIndexException, IOException;
  Document doc(int paramInt, FieldSelector paramFieldSelector) throws CorruptIndexException, IOException;
  Query rewrite(Query paramQuery) throws IOException;
  Explanation explain(Weight paramWeight, int paramInt) throws IOException;
  TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Searchable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Searcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Searcher
/*     */   implements Searchable
/*     */ {
/*  40 */   public final Hits search(Query query) throws IOException { return search(query, (Filter)null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public Hits search(Query query, Filter filter) throws IOException { return new Hits(this, query, filter); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  61 */   public Hits search(Query query, Sort sort) throws IOException { return new Hits(this, query, null, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  72 */   public Hits search(Query query, Filter filter, Sort sort) throws IOException { return new Hits(this, query, filter, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public TopFieldDocs search(Query query, Filter filter, int n, Sort sort) throws IOException { return search(createWeight(query), filter, n, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 105 */   public void search(Query query, HitCollector results) throws IOException { search(query, (Filter)null, results); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public void search(Query query, Filter filter, HitCollector results) throws IOException { search(createWeight(query), filter, results); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 136 */   public TopDocs search(Query query, Filter filter, int n) throws IOException { return search(createWeight(query), filter, n); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 146 */   public TopDocs search(Query query, int n) throws IOException { return search(query, null, n); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 158 */   public Explanation explain(Query query, int doc) throws IOException { return explain(createWeight(query), doc); }
/*     */ 
/*     */ 
/*     */   
/* 162 */   private Similarity similarity = Similarity.getDefault();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 169 */   public void setSimilarity(Similarity similarity) { this.similarity = similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 177 */   public Similarity getSimilarity() { return this.similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 185 */   protected Weight createWeight(Query query) throws IOException { return query.weight(this); }
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] docFreqs(Term[] terms) throws IOException {
/* 190 */     int[] result = new int[terms.length];
/* 191 */     for (int i = 0; i < terms.length; i++) {
/* 192 */       result[i] = docFreq(terms[i]);
/*     */     }
/* 194 */     return result;
/*     */   }
/*     */   
/*     */   public abstract void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException;
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */   
/*     */   public abstract int docFreq(Term paramTerm) throws IOException;
/*     */   
/*     */   public abstract int maxDoc() throws IOException;
/*     */   
/*     */   public abstract TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException;
/*     */   
/*     */   public abstract Document doc(int paramInt) throws CorruptIndexException, IOException;
/*     */   
/*     */   public abstract Query rewrite(Query paramQuery) throws IOException;
/*     */   
/*     */   public abstract Explanation explain(Weight paramWeight, int paramInt) throws IOException;
/*     */   
/*     */   public abstract TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Searcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Similarity,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.util.SmallFloat;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Similarity
/*     */   implements Serializable
/*     */ {
/* 290 */   private static Similarity defaultImpl = new DefaultSimilarity();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 299 */   public static void setDefault(Similarity similarity) { defaultImpl = similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 311 */   public static Similarity getDefault() { return defaultImpl; }
/*     */ 
/*     */ 
/*     */   
/* 315 */   private static final float[] NORM_TABLE = new float[256];
/*     */   
/*     */   static  {
/* 318 */     for (int i = 0; i < 256; i++) {
/* 319 */       NORM_TABLE[i] = SmallFloat.byte315ToFloat((byte)i);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 326 */   public static float decodeNorm(byte b) { return NORM_TABLE[b & 0xFF]; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 333 */   public static float[] getNormDecoder() { return NORM_TABLE; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 388 */   public static byte encodeNorm(float f) { return SmallFloat.floatToByte315(f); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 408 */   public float tf(int freq) { return tf(freq); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 457 */   public float idf(Term term, Searcher searcher) throws IOException { return idf(searcher.docFreq(term), searcher.maxDoc()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float idf(Collection terms, Searcher searcher) throws IOException {
/* 470 */     float idf = 0.0F;
/* 471 */     Iterator i = terms.iterator();
/* 472 */     while (i.hasNext()) {
/* 473 */       idf += idf(i.next(), searcher);
/*     */     }
/* 475 */     return idf;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 524 */   public float scorePayload(String fieldName, byte[] payload, int offset, int length) { return 1.0F; }
/*     */   
/*     */   public abstract float lengthNorm(String paramString, int paramInt);
/*     */   
/*     */   public abstract float queryNorm(float paramFloat);
/*     */   
/*     */   public abstract float sloppyFreq(int paramInt);
/*     */   
/*     */   public abstract float tf(float paramFloat);
/*     */   
/*     */   public abstract float idf(int paramInt1, int paramInt2);
/*     */   
/*     */   public abstract float coord(int paramInt1, int paramInt2);
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Similarity.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SimilarityDelegator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SimilarityDelegator
/*    */   extends Similarity
/*    */ {
/*    */   private Similarity delegee;
/*    */   
/* 32 */   public SimilarityDelegator(Similarity delegee) { this.delegee = delegee; }
/*    */ 
/*    */ 
/*    */   
/* 36 */   public float lengthNorm(String fieldName, int numTerms) { return this.delegee.lengthNorm(fieldName, numTerms); }
/*    */ 
/*    */ 
/*    */   
/* 40 */   public float queryNorm(float sumOfSquaredWeights) { return this.delegee.queryNorm(sumOfSquaredWeights); }
/*    */ 
/*    */ 
/*    */   
/* 44 */   public float tf(float freq) { return this.delegee.tf(freq); }
/*    */ 
/*    */ 
/*    */   
/* 48 */   public float sloppyFreq(int distance) { return this.delegee.sloppyFreq(distance); }
/*    */ 
/*    */ 
/*    */   
/* 52 */   public float idf(int docFreq, int numDocs) { return this.delegee.idf(docFreq, numDocs); }
/*    */ 
/*    */ 
/*    */   
/* 56 */   public float coord(int overlap, int maxOverlap) { return this.delegee.coord(overlap, maxOverlap); }
/*    */ 
/*    */ 
/*    */   
/* 60 */   public float scorePayload(String fieldName, byte[] payload, int offset, int length) { return this.delegee.scorePayload(fieldName, payload, offset, length); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SimilarityDelegator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SloppyPhraseScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SloppyPhraseScorer
/*     */   extends PhraseScorer
/*     */ {
/*     */   private int slop;
/*     */   private PhrasePositions[] repeats;
/*     */   private PhrasePositions[] tmpPos;
/*     */   private boolean checkedRepeats;
/*     */   
/*     */   SloppyPhraseScorer(Weight weight, TermPositions[] tps, int[] offsets, Similarity similarity, int slop, byte[] norms) {
/*  33 */     super(weight, tps, offsets, similarity, norms);
/*  34 */     this.slop = slop;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final float phraseFreq() throws IOException {
/*  56 */     int end = initPhrasePositions();
/*     */     
/*  58 */     float freq = 0.0F;
/*  59 */     boolean done = (end < 0);
/*  60 */     while (!done) {
/*  61 */       PhrasePositions pp = (PhrasePositions)this.pq.pop();
/*  62 */       int start = pp.position;
/*  63 */       int next = ((PhrasePositions)this.pq.top()).position;
/*     */       
/*  65 */       boolean tpsDiffer = true; int pos;
/*  66 */       for (pos = start; pos <= next || !tpsDiffer; pos = pp.position) {
/*  67 */         if (pos <= next && tpsDiffer)
/*  68 */           start = pos; 
/*  69 */         if (!pp.nextPosition()) {
/*  70 */           done = true;
/*     */           break;
/*     */         } 
/*  73 */         PhrasePositions pp2 = null;
/*  74 */         tpsDiffer = (!pp.repeats || (pp2 = termPositionsDiffer(pp)) == null);
/*  75 */         if (pp2 != null && pp2 != pp) {
/*  76 */           pp = flip(pp, pp2);
/*     */         }
/*     */       } 
/*     */       
/*  80 */       int matchLength = end - start;
/*  81 */       if (matchLength <= this.slop) {
/*  82 */         freq += getSimilarity().sloppyFreq(matchLength);
/*     */       }
/*  84 */       if (pp.position > end)
/*  85 */         end = pp.position; 
/*  86 */       this.pq.put(pp);
/*     */     } 
/*     */     
/*  89 */     return freq;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private PhrasePositions flip(PhrasePositions pp, PhrasePositions pp2) {
/*  96 */     int n = 0;
/*     */     
/*     */     PhrasePositions pp3;
/*  99 */     while ((pp3 = (PhrasePositions)this.pq.pop()) != pp2) {
/* 100 */       this.tmpPos[n++] = pp3;
/*     */     }
/*     */     
/* 103 */     for (; --n >= 0; n--) {
/* 104 */       this.pq.insert(this.tmpPos[n]);
/*     */     }
/*     */     
/* 107 */     this.pq.put(pp);
/* 108 */     return pp2;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private int initPhrasePositions() throws IOException {
/* 126 */     int end = 0;
/*     */ 
/*     */     
/* 129 */     if (this.checkedRepeats && this.repeats == null) {
/*     */       
/* 131 */       this.pq.clear();
/* 132 */       for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 133 */         pp.firstPosition();
/* 134 */         if (pp.position > end)
/* 135 */           end = pp.position; 
/* 136 */         this.pq.put(pp);
/*     */       } 
/* 138 */       return end;
/*     */     } 
/*     */ 
/*     */     
/* 142 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 143 */       pp.firstPosition();
/*     */     }
/*     */     
/* 146 */     if (!this.checkedRepeats) {
/* 147 */       this.checkedRepeats = true;
/*     */       
/* 149 */       HashMap m = null;
/* 150 */       for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 151 */         int tpPos = pp.position + pp.offset;
/* 152 */         for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {
/* 153 */           int tpPos2 = pp2.position + pp2.offset;
/* 154 */           if (tpPos2 == tpPos) {
/* 155 */             if (m == null)
/* 156 */               m = new HashMap(); 
/* 157 */             pp.repeats = true;
/* 158 */             pp2.repeats = true;
/* 159 */             m.put(pp, null);
/* 160 */             m.put(pp2, null);
/*     */           } 
/*     */         } 
/*     */       } 
/* 164 */       if (m != null) {
/* 165 */         this.repeats = (PhrasePositions[])m.keySet().toArray((Object[])new PhrasePositions[0]);
/*     */       }
/*     */     } 
/*     */     
/* 169 */     if (this.repeats != null) {
/* 170 */       for (int i = 0; i < this.repeats.length; i++) {
/* 171 */         PhrasePositions pp = this.repeats[i];
/*     */         PhrasePositions pp2;
/* 173 */         while ((pp2 = termPositionsDiffer(pp)) != null) {
/* 174 */           if (!pp2.nextPosition()) {
/* 175 */             return -1;
/*     */           }
/*     */         } 
/*     */       } 
/*     */     }
/*     */     
/* 181 */     this.pq.clear();
/* 182 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 183 */       if (pp.position > end)
/* 184 */         end = pp.position; 
/* 185 */       this.pq.put(pp);
/*     */     } 
/*     */     
/* 188 */     if (this.repeats != null) {
/* 189 */       this.tmpPos = new PhrasePositions[this.pq.size()];
/*     */     }
/* 191 */     return end;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private PhrasePositions termPositionsDiffer(PhrasePositions pp) {
/* 205 */     int tpPos = pp.position + pp.offset;
/* 206 */     for (int i = 0; i < this.repeats.length; i++) {
/* 207 */       PhrasePositions pp2 = this.repeats[i];
/* 208 */       if (pp2 != pp) {
/*     */         
/* 210 */         int tpPos2 = pp2.position + pp2.offset;
/* 211 */         if (tpPos2 == tpPos)
/* 212 */           return (pp.offset > pp2.offset) ? pp : pp2; 
/*     */       } 
/* 214 */     }  return null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SloppyPhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Sort,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Sort
/*     */   implements Serializable
/*     */ {
/* 109 */   public static final Sort RELEVANCE = new Sort();
/*     */ 
/*     */   
/* 112 */   public static final Sort INDEXORDER = new Sort(SortField.FIELD_DOC);
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   SortField[] fields;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 123 */   public Sort() { this(new SortField[] { SortField.FIELD_SCORE, SortField.FIELD_DOC }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 134 */   public Sort(String field) { setSort(field, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public Sort(String field, boolean reverse) { setSort(field, reverse); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public Sort(String[] fields) { setSort(fields); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public Sort(SortField field) { setSort(field); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 165 */   public Sort(SortField[] fields) { setSort(fields); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 173 */   public final void setSort(String field) { setSort(field, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setSort(String field, boolean reverse) {
/* 181 */     SortField[] nfields = { new SortField(field, 2, reverse), SortField.FIELD_DOC };
/*     */     
/* 183 */     this.fields = nfields;
/*     */   }
/*     */ 
/*     */   
/*     */   public void setSort(String[] fieldnames) {
/* 188 */     int n = fieldnames.length;
/* 189 */     SortField[] nfields = new SortField[n];
/* 190 */     for (int i = 0; i < n; i++) {
/* 191 */       nfields[i] = new SortField(fieldnames[i], 2);
/*     */     }
/* 193 */     this.fields = nfields;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 198 */   public void setSort(SortField field) { this.fields = new SortField[] { field }; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 203 */   public void setSort(SortField[] fields) { this.fields = fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 211 */   public SortField[] getSort() { return this.fields; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 215 */     StringBuffer buffer = new StringBuffer();
/*     */     
/* 217 */     for (int i = 0; i < this.fields.length; i++) {
/* 218 */       buffer.append(this.fields[i].toString());
/* 219 */       if (i + 1 < this.fields.length) {
/* 220 */         buffer.append(',');
/*     */       }
/*     */     } 
/* 223 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Sort.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortComparator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class SortComparator
/*    */   implements SortComparatorSource
/*    */ {
/*    */   public ScoreDocComparator newComparator(IndexReader reader, String fieldname) throws IOException {
/* 48 */     String field = fieldname.intern();
/* 49 */     final Comparable[] cachedValues = FieldCache.DEFAULT.getCustom(reader, field, this);
/*    */     
/* 51 */     return new ScoreDocComparator() {
/*    */         private final Comparable[] val$cachedValues;
/*    */         
/* 54 */         public int compare(ScoreDoc i, ScoreDoc j) { return cachedValues[i.doc].compareTo(cachedValues[j.doc]); }
/*    */         
/*    */         private final SortComparator this$0;
/*    */         
/* 58 */         public Comparable sortValue(ScoreDoc i) { return cachedValues[i.doc]; }
/*    */ 
/*    */ 
/*    */         
/* 62 */         public int sortType() { return 9; }
/*    */       };
/*    */   }
/*    */   
/*    */   protected abstract Comparable getComparable(String paramString);
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SortComparator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortComparatorSource,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import org.apache.lucene.index.IndexReader;
public interface SortComparatorSource extends Serializable {
  ScoreDocComparator newComparator(IndexReader paramIndexReader, String paramString) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SortComparatorSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortField,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.Locale;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SortField
/*     */   implements Serializable
/*     */ {
/*     */   public static final int SCORE = 0;
/*     */   public static final int DOC = 1;
/*     */   public static final int AUTO = 2;
/*     */   public static final int STRING = 3;
/*     */   public static final int INT = 4;
/*     */   public static final int FLOAT = 5;
/*     */   public static final int LONG = 6;
/*     */   public static final int DOUBLE = 7;
/*     */   public static final int SHORT = 8;
/*     */   public static final int CUSTOM = 9;
/*     */   public static final int BYTE = 10;
/*  91 */   public static final SortField FIELD_SCORE = new SortField(null, 0);
/*     */ 
/*     */   
/*  94 */   public static final SortField FIELD_DOC = new SortField(null, 1);
/*     */   
/*     */   private String field;
/*     */   
/*  98 */   private int type = 2;
/*     */ 
/*     */   
/*     */   private Locale locale;
/*     */   
/*     */   boolean reverse = false;
/*     */   
/*     */   private SortComparatorSource factory;
/*     */ 
/*     */   
/* 108 */   public SortField(String field) { this.field = field.intern(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, boolean reverse) {
/* 117 */     this.field = field.intern();
/* 118 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, int type) {
/* 128 */     this.field = (field != null) ? field.intern() : field;
/* 129 */     this.type = type;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, int type, boolean reverse) {
/* 140 */     this.field = (field != null) ? field.intern() : field;
/* 141 */     this.type = type;
/* 142 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, Locale locale) {
/* 151 */     this.field = field.intern();
/* 152 */     this.type = 3;
/* 153 */     this.locale = locale;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, Locale locale, boolean reverse) {
/* 162 */     this.field = field.intern();
/* 163 */     this.type = 3;
/* 164 */     this.locale = locale;
/* 165 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, SortComparatorSource comparator) {
/* 173 */     this.field = (field != null) ? field.intern() : field;
/* 174 */     this.type = 9;
/* 175 */     this.factory = comparator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, SortComparatorSource comparator, boolean reverse) {
/* 184 */     this.field = (field != null) ? field.intern() : field;
/* 185 */     this.type = 9;
/* 186 */     this.reverse = reverse;
/* 187 */     this.factory = comparator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 195 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 202 */   public int getType() { return this.type; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 210 */   public Locale getLocale() { return this.locale; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 217 */   public boolean getReverse() { return this.reverse; }
/*     */ 
/*     */ 
/*     */   
/* 221 */   public SortComparatorSource getFactory() { return this.factory; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 225 */     StringBuffer buffer = new StringBuffer();
/* 226 */     switch (this.type) { case 0:
/* 227 */         buffer.append(""<score>"");
/*     */         break;
/*     */       case 1:
/* 230 */         buffer.append(""<doc>"");
/*     */         break;
/*     */       
/*     */       case 9:
/* 234 */         buffer.append(""<custom:\"""").append(this.field).append(""\"": "").append(this.factory).append('>');
/*     */         break;
/*     */       
/*     */       default:
/* 238 */         buffer.append('""').append(this.field).append('""');
/*     */         break; }
/*     */ 
/*     */     
/* 242 */     if (this.locale != null) buffer.append('(').append(this.locale).append(')'); 
/* 243 */     if (this.reverse) buffer.append('!');
/*     */     
/* 245 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SortField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SpanFilter,"package org.apache.lucene.search;
import java.io.IOException;
import org.apache.lucene.index.IndexReader;
public abstract class SpanFilter extends Filter {
  public abstract SpanFilterResult bitSpans(IndexReader paramIndexReader) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SpanFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SpanFilterResult,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.util.ArrayList;
/*     */ import java.util.BitSet;
/*     */ import java.util.List;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanFilterResult
/*     */ {
/*     */   private BitSet bits;
/*     */   private DocIdSet docIdSet;
/*     */   private List positions;
/*     */   
/*     */   public SpanFilterResult(BitSet bits, List positions) {
/*  44 */     this.bits = bits;
/*  45 */     this.positions = positions;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SpanFilterResult(DocIdSet docIdSet, List positions) {
/*  54 */     this.docIdSet = docIdSet;
/*  55 */     this.positions = positions;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   public List getPositions() { return this.positions; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  71 */   public BitSet getBits() { return this.bits; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public DocIdSet getDocIdSet() { return this.docIdSet; }
/*     */ 
/*     */   
/*     */   public static class PositionInfo
/*     */   {
/*     */     private int doc;
/*     */     private List positions;
/*     */     
/*     */     public PositionInfo(int doc) {
/*  85 */       this.doc = doc;
/*  86 */       this.positions = new ArrayList();
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*  91 */     public void addPosition(int start, int end) { this.positions.add(new SpanFilterResult.StartEnd(start, end)); }
/*     */ 
/*     */ 
/*     */     
/*  95 */     public int getDoc() { return this.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 103 */     public List getPositions() { return this.positions; }
/*     */   }
/*     */ 
/*     */   
/*     */   public static class StartEnd
/*     */   {
/*     */     private int start;
/*     */     
/*     */     private int end;
/*     */     
/*     */     public StartEnd(int start, int end) {
/* 114 */       this.start = start;
/* 115 */       this.end = end;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 123 */     public int getEnd() { return this.end; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 131 */     public int getStart() { return this.start; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SpanFilterResult.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SpanQueryFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.ArrayList;
/*    */ import java.util.List;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.spans.SpanQuery;
/*    */ import org.apache.lucene.search.spans.Spans;
/*    */ import org.apache.lucene.util.OpenBitSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SpanQueryFilter
/*    */   extends SpanFilter
/*    */ {
/*    */   protected SpanQuery query;
/*    */   
/*    */   protected SpanQueryFilter() {}
/*    */   
/* 54 */   public SpanQueryFilter(SpanQuery query) { this.query = query; }
/*    */ 
/*    */   
/*    */   public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
/* 58 */     SpanFilterResult result = bitSpans(reader);
/* 59 */     return result.getDocIdSet();
/*    */   }
/*    */ 
/*    */   
/*    */   public SpanFilterResult bitSpans(IndexReader reader) throws IOException {
/* 64 */     OpenBitSet bits = new OpenBitSet(reader.maxDoc());
/* 65 */     Spans spans = this.query.getSpans(reader);
/* 66 */     List tmp = new ArrayList(20);
/* 67 */     int currentDoc = -1;
/* 68 */     SpanFilterResult.PositionInfo currentInfo = null;
/* 69 */     while (spans.next()) {
/*    */       
/* 71 */       int doc = spans.doc();
/* 72 */       bits.set(doc);
/* 73 */       if (currentDoc != doc) {
/*    */         
/* 75 */         currentInfo = new SpanFilterResult.PositionInfo(doc);
/* 76 */         tmp.add(currentInfo);
/* 77 */         currentDoc = doc;
/*    */       } 
/* 79 */       currentInfo.addPosition(spans.start(), spans.end());
/*    */     } 
/* 81 */     return new SpanFilterResult((DocIdSet)bits, tmp);
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 86 */   public SpanQuery getQuery() { return this.query; }
/*    */ 
/*    */ 
/*    */   
/* 90 */   public String toString() { return ""QueryWrapperFilter("" + this.query + "")""; }
/*    */ 
/*    */ 
/*    */   
/* 94 */   public boolean equals(Object o) { return (o instanceof SpanQueryFilter && this.query.equals(((SpanQueryFilter)o).query)); }
/*    */ 
/*    */ 
/*    */   
/* 98 */   public int hashCode() { return this.query.hashCode() ^ 0x923F64B9; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\SpanQueryFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TermQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TermQuery
/*     */   extends Query
/*     */ {
/*     */   private Term term;
/*     */   
/*     */   private class TermWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final TermQuery this$0;
/*     */     
/*     */     public TermWeight(Searcher searcher) throws IOException {
/*  43 */       this.similarity = TermQuery.this.getSimilarity(searcher);
/*  44 */       this.idf = this.similarity.idf(TermQuery.this.term, searcher);
/*     */     }
/*     */     
/*  47 */     public String toString() { return ""weight("" + TermQuery.this + "")""; }
/*     */     
/*  49 */     public Query getQuery() { return TermQuery.this; }
/*  50 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/*  53 */       this.queryWeight = this.idf * TermQuery.this.getBoost();
/*  54 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/*  58 */       this.queryNorm = queryNorm;
/*  59 */       this.queryWeight *= queryNorm;
/*  60 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/*  64 */       TermDocs termDocs = reader.termDocs(TermQuery.this.term);
/*     */       
/*  66 */       if (termDocs == null) {
/*  67 */         return null;
/*     */       }
/*  69 */       return new TermScorer(this, termDocs, this.similarity, reader.norms(TermQuery.this.term.field()));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  76 */       ComplexExplanation result = new ComplexExplanation();
/*  77 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/*  79 */       Explanation idfExpl = new Explanation(this.idf, ""idf(docFreq="" + reader.docFreq(TermQuery.this.term) + "", numDocs="" + reader.numDocs() + "")"");
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  84 */       Explanation queryExpl = new Explanation();
/*  85 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/*  87 */       Explanation boostExpl = new Explanation(TermQuery.this.getBoost(), ""boost"");
/*  88 */       if (TermQuery.this.getBoost() != 1.0F)
/*  89 */         queryExpl.addDetail(boostExpl); 
/*  90 */       queryExpl.addDetail(idfExpl);
/*     */       
/*  92 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/*  93 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/*  95 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/*  99 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 102 */       String field = TermQuery.this.term.field();
/* 103 */       ComplexExplanation fieldExpl = new ComplexExplanation();
/* 104 */       fieldExpl.setDescription(""fieldWeight("" + TermQuery.this.term + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 107 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 108 */       fieldExpl.addDetail(tfExpl);
/* 109 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 111 */       Explanation fieldNormExpl = new Explanation();
/* 112 */       byte[] fieldNorms = reader.norms(field);
/* 113 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 115 */       fieldNormExpl.setValue(fieldNorm);
/* 116 */       fieldNormExpl.setDescription(""fieldNorm(field="" + field + "", doc="" + doc + "")"");
/* 117 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 119 */       fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
/* 120 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 124 */       result.addDetail(fieldExpl);
/* 125 */       result.setMatch(fieldExpl.getMatch());
/*     */ 
/*     */       
/* 128 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 130 */       if (queryExpl.getValue() == 1.0F) {
/* 131 */         return fieldExpl;
/*     */       }
/* 133 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 139 */   public TermQuery(Term t) { this.term = t; }
/*     */ 
/*     */ 
/*     */   
/* 143 */   public Term getTerm() { return this.term; }
/*     */ 
/*     */   
/* 146 */   protected Weight createWeight(Searcher searcher) throws IOException { return new TermWeight(searcher); }
/*     */ 
/*     */ 
/*     */   
/* 150 */   public void extractTerms(Set terms) { terms.add(getTerm()); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 155 */     StringBuffer buffer = new StringBuffer();
/* 156 */     if (!this.term.field().equals(field)) {
/* 157 */       buffer.append(this.term.field());
/* 158 */       buffer.append("":"");
/*     */     } 
/* 160 */     buffer.append(this.term.text());
/* 161 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 162 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 167 */     if (!(o instanceof TermQuery))
/* 168 */       return false; 
/* 169 */     TermQuery other = (TermQuery)o;
/* 170 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 176 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.term.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\TermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TermScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Weight weight;
/*     */   private TermDocs termDocs;
/*     */   private byte[] norms;
/*     */   private float weightValue;
/*     */   private int doc;
/*  33 */   private final int[] docs = new int[32];
/*  34 */   private final int[] freqs = new int[32];
/*     */   
/*     */   private int pointer;
/*     */   private int pointerMax;
/*     */   private static final int SCORE_CACHE_SIZE = 32;
/*  39 */   private float[] scoreCache = new float[32];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermScorer(Weight weight, TermDocs td, Similarity similarity, byte[] norms) {
/*  49 */     super(similarity);
/*  50 */     this.weight = weight;
/*  51 */     this.termDocs = td;
/*  52 */     this.norms = norms;
/*  53 */     this.weightValue = weight.getValue();
/*     */     
/*  55 */     for (int i = 0; i < 32; i++)
/*  56 */       this.scoreCache[i] = getSimilarity().tf(i) * this.weightValue; 
/*     */   }
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/*  60 */     next();
/*  61 */     score(hc, 2147483647);
/*     */   }
/*     */   
/*     */   protected boolean score(HitCollector c, int end) throws IOException {
/*  65 */     Similarity similarity = getSimilarity();
/*  66 */     float[] normDecoder = Similarity.getNormDecoder();
/*  67 */     while (this.doc < end) {
/*  68 */       int f = this.freqs[this.pointer];
/*  69 */       float score = (f < 32) ? this.scoreCache[f] : (similarity.tf(f) * this.weightValue);
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  74 */       score *= normDecoder[this.norms[this.doc] & 0xFF];
/*     */       
/*  76 */       c.collect(this.doc, score);
/*     */       
/*  78 */       if (++this.pointer >= this.pointerMax) {
/*  79 */         this.pointerMax = this.termDocs.read(this.docs, this.freqs);
/*  80 */         if (this.pointerMax != 0) {
/*  81 */           this.pointer = 0;
/*     */         } else {
/*  83 */           this.termDocs.close();
/*  84 */           this.doc = Integer.MAX_VALUE;
/*  85 */           return false;
/*     */         } 
/*     */       } 
/*  88 */       this.doc = this.docs[this.pointer];
/*     */     } 
/*  90 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/* 104 */     this.pointer++;
/* 105 */     if (this.pointer >= this.pointerMax) {
/* 106 */       this.pointerMax = this.termDocs.read(this.docs, this.freqs);
/* 107 */       if (this.pointerMax != 0) {
/* 108 */         this.pointer = 0;
/*     */       } else {
/* 110 */         this.termDocs.close();
/* 111 */         this.doc = Integer.MAX_VALUE;
/* 112 */         return false;
/*     */       } 
/*     */     } 
/* 115 */     this.doc = this.docs[this.pointer];
/* 116 */     return true;
/*     */   }
/*     */   
/*     */   public float score() {
/* 120 */     int f = this.freqs[this.pointer];
/* 121 */     float raw = (f < 32) ? this.scoreCache[f] : (getSimilarity().tf(f) * this.weightValue);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 126 */     return raw * Similarity.decodeNorm(this.norms[this.doc]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 137 */     this.pointer++; for (; this.pointer < this.pointerMax; this.pointer++) {
/* 138 */       if (this.docs[this.pointer] >= target) {
/* 139 */         this.doc = this.docs[this.pointer];
/* 140 */         return true;
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 145 */     boolean result = this.termDocs.skipTo(target);
/* 146 */     if (result) {
/* 147 */       this.pointerMax = 1;
/* 148 */       this.pointer = 0;
/* 149 */       this.docs[this.pointer] = this.doc = this.termDocs.doc();
/* 150 */       this.freqs[this.pointer] = this.termDocs.freq();
/*     */     } else {
/* 152 */       this.doc = Integer.MAX_VALUE;
/*     */     } 
/* 154 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 163 */     TermQuery query = (TermQuery)this.weight.getQuery();
/* 164 */     Explanation tfExplanation = new Explanation();
/* 165 */     int tf = 0;
/* 166 */     while (this.pointer < this.pointerMax) {
/* 167 */       if (this.docs[this.pointer] == doc)
/* 168 */         tf = this.freqs[this.pointer]; 
/* 169 */       this.pointer++;
/*     */     } 
/* 171 */     if (tf == 0 && 
/* 172 */       this.termDocs.skipTo(doc))
/*     */     {
/* 174 */       if (this.termDocs.doc() == doc)
/*     */       {
/* 176 */         tf = this.termDocs.freq();
/*     */       }
/*     */     }
/*     */     
/* 180 */     this.termDocs.close();
/* 181 */     tfExplanation.setValue(getSimilarity().tf(tf));
/* 182 */     tfExplanation.setDescription(""tf(termFreq("" + query.getTerm() + "")="" + tf + "")"");
/*     */     
/* 184 */     return tfExplanation;
/*     */   }
/*     */ 
/*     */   
/* 188 */   public String toString() { return ""scorer("" + this.weight + "")""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\TermScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TimeLimitedCollector,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TimeLimitedCollector
/*     */   extends HitCollector
/*     */ {
/*     */   public static final int DEFAULT_RESOLUTION = 20;
/*     */   public boolean DEFAULT_GREEDY = false;
/*  40 */   private static long resolution = 20L;
/*     */   
/*  42 */   private boolean greedy = this.DEFAULT_GREEDY;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static class TimerThread
/*     */     extends Thread
/*     */   {
/*  56 */     private volatile long time = 0L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     private TimerThread() {
/*  65 */       super(""TimeLimitedCollector timer thread"");
/*  66 */       setDaemon(true);
/*     */     }
/*     */     
/*     */     public void run() {
/*  70 */       boolean interrupted = false;
/*     */       
/*     */       try {
/*     */         while (true) {
/*  74 */           this.time += resolution;
/*     */           try {
/*  76 */             Thread.sleep(resolution);
/*  77 */           } catch (InterruptedException e) {
/*  78 */             interrupted = true;
/*     */           } 
/*     */         } 
/*     */       } finally {
/*     */         
/*  83 */         if (interrupted) {
/*  84 */           Thread.currentThread().interrupt();
/*     */         }
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  93 */     public long getMilliseconds() { return this.time; }
/*     */   }
/*     */ 
/*     */   
/*     */   public static class TimeExceededException
/*     */     extends RuntimeException
/*     */   {
/*     */     private long timeAllowed;
/*     */     private long timeElapsed;
/*     */     private int lastDocCollected;
/*     */     
/*     */     private TimeExceededException(long timeAllowed, long timeElapsed, int lastDocCollected) {
/* 105 */       super(""Elapsed time: "" + timeElapsed + ""Exceeded allowed search time: "" + timeAllowed + "" ms."");
/* 106 */       this.timeAllowed = timeAllowed;
/* 107 */       this.timeElapsed = timeElapsed;
/* 108 */       this.lastDocCollected = lastDocCollected;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 114 */     public long getTimeAllowed() { return this.timeAllowed; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 120 */     public long getTimeElapsed() { return this.timeElapsed; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 126 */     public int getLastDocCollected() { return this.lastDocCollected; }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 133 */   private static final TimerThread TIMER_THREAD = new TimerThread();
/*     */   
/*     */   static  {
/* 136 */     TIMER_THREAD.start();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private final long t0;
/*     */   
/*     */   private final long timeout;
/*     */   
/*     */   private final HitCollector hc;
/*     */ 
/*     */   
/*     */   public TimeLimitedCollector(HitCollector hc, long timeAllowed) {
/* 149 */     this.hc = hc;
/* 150 */     this.t0 = TIMER_THREAD.getMilliseconds();
/* 151 */     this.timeout = this.t0 + timeAllowed;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void collect(int doc, float score) {
/* 160 */     long time = TIMER_THREAD.getMilliseconds();
/* 161 */     if (this.timeout < time) {
/* 162 */       if (this.greedy)
/*     */       {
/* 164 */         this.hc.collect(doc, score);
/*     */       }
/*     */       
/* 167 */       throw new TimeExceededException(this.timeout - this.t0, time - this.t0, doc);
/*     */     } 
/*     */     
/* 170 */     this.hc.collect(doc, score);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 178 */   public static long getResolution() { return resolution; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   public static void setResolution(long newResolution) { resolution = Math.max(newResolution, 5L); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 208 */   public boolean isGreedy() { return this.greedy; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 217 */   public void setGreedy(boolean greedy) { this.greedy = greedy; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\TimeLimitedCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopDocCollector,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopDocCollector
/*    */   extends HitCollector
/*    */ {
/*    */   private ScoreDoc reusableSD;
/*    */   protected int totalHits;
/*    */   protected PriorityQueue hq;
/*    */   
/* 44 */   public TopDocCollector(int numHits) { this(new HitQueue(numHits)); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 51 */   TopDocCollector(int numHits, PriorityQueue hq) { this.hq = hq; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 58 */   protected TopDocCollector(PriorityQueue hq) { this.hq = hq; }
/*    */ 
/*    */ 
/*    */   
/*    */   public void collect(int doc, float score) {
/* 63 */     if (score > 0.0F) {
/* 64 */       this.totalHits++;
/* 65 */       if (this.reusableSD == null) {
/* 66 */         this.reusableSD = new ScoreDoc(doc, score);
/* 67 */       } else if (score >= this.reusableSD.score) {
/*    */ 
/*    */ 
/*    */         
/* 71 */         this.reusableSD.doc = doc;
/* 72 */         this.reusableSD.score = score;
/*    */       } else {
/*    */         return;
/*    */       } 
/* 76 */       this.reusableSD = (ScoreDoc)this.hq.insertWithOverflow(this.reusableSD);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 81 */   public int getTotalHits() { return this.totalHits; }
/*    */ 
/*    */   
/*    */   public TopDocs topDocs() {
/* 85 */     ScoreDoc[] scoreDocs = new ScoreDoc[this.hq.size()];
/* 86 */     for (int i = this.hq.size() - 1; i >= 0; i--) {
/* 87 */       scoreDocs[i] = (ScoreDoc)this.hq.pop();
/*    */     }
/* 89 */     float maxScore = (this.totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*    */ 
/*    */ 
/*    */     
/* 93 */     return new TopDocs(this.totalHits, scoreDocs, maxScore);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\TopDocCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopDocs,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopDocs
/*    */   implements Serializable
/*    */ {
/*    */   public int totalHits;
/*    */   public ScoreDoc[] scoreDocs;
/*    */   private float maxScore;
/*    */   
/* 34 */   public float getMaxScore() { return this.maxScore; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 39 */   public void setMaxScore(float maxScore) { this.maxScore = maxScore; }
/*    */ 
/*    */ 
/*    */   
/*    */   public TopDocs(int totalHits, ScoreDoc[] scoreDocs, float maxScore) {
/* 44 */     this.totalHits = totalHits;
/* 45 */     this.scoreDocs = scoreDocs;
/* 46 */     this.maxScore = maxScore;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\TopDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopFieldDocCollector,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopFieldDocCollector
/*    */   extends TopDocCollector
/*    */ {
/*    */   private FieldDoc reusableFD;
/*    */   
/* 43 */   public TopFieldDocCollector(IndexReader reader, Sort sort, int numHits) throws IOException { super(new FieldSortedHitQueue(reader, sort.fields, numHits)); }
/*    */ 
/*    */ 
/*    */   
/*    */   public void collect(int doc, float score) {
/* 48 */     if (score > 0.0F) {
/* 49 */       this.totalHits++;
/* 50 */       if (this.reusableFD == null) {
/* 51 */         this.reusableFD = new FieldDoc(doc, score);
/*    */ 
/*    */       
/*    */       }
/*    */       else {
/*    */ 
/*    */         
/* 58 */         this.reusableFD.score = score;
/* 59 */         this.reusableFD.doc = doc;
/*    */       } 
/* 61 */       this.reusableFD = (FieldDoc)this.hq.insertWithOverflow(this.reusableFD);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/*    */   public TopDocs topDocs() {
/* 67 */     FieldSortedHitQueue fshq = (FieldSortedHitQueue)this.hq;
/* 68 */     ScoreDoc[] scoreDocs = new ScoreDoc[fshq.size()];
/* 69 */     for (int i = fshq.size() - 1; i >= 0; i--) {
/* 70 */       scoreDocs[i] = fshq.fillFields((FieldDoc)fshq.pop());
/*    */     }
/* 72 */     return new TopFieldDocs(this.totalHits, scoreDocs, fshq.getFields(), fshq.getMaxScore());
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\TopFieldDocCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopFieldDocs,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopFieldDocs
/*    */   extends TopDocs
/*    */ {
/*    */   public SortField[] fields;
/*    */   
/*    */   TopFieldDocs(int totalHits, ScoreDoc[] scoreDocs, SortField[] fields, float maxScore) {
/* 43 */     super(totalHits, scoreDocs, maxScore);
/* 44 */     this.fields = fields;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\TopFieldDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Weight,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import org.apache.lucene.index.IndexReader;
public interface Weight extends Serializable {
  Query getQuery();
  float getValue();
  float sumOfSquaredWeights() throws IOException;
  void normalize(float paramFloat);
  Scorer scorer(IndexReader paramIndexReader) throws IOException;
  Explanation explain(IndexReader paramIndexReader, int paramInt) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\Weight.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.WildcardQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class WildcardQuery
/*    */   extends MultiTermQuery
/*    */ {
/*    */   private boolean termContainsWildcard;
/*    */   
/*    */   public WildcardQuery(Term term) {
/* 37 */     super(term);
/* 38 */     this.termContainsWildcard = (term.text().indexOf('*') != -1 || term.text().indexOf('?') != -1);
/*    */   }
/*    */ 
/*    */   
/* 42 */   protected FilteredTermEnum getEnum(IndexReader reader) throws IOException { return new WildcardTermEnum(reader, getTerm()); }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 46 */     if (o instanceof WildcardQuery) {
/* 47 */       return super.equals(o);
/*    */     }
/* 49 */     return false;
/*    */   }
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 53 */     if (this.termContainsWildcard) {
/* 54 */       return super.rewrite(reader);
/*    */     }
/*    */     
/* 57 */     return new TermQuery(getTerm());
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\WildcardQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.WildcardTermEnum,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class WildcardTermEnum
/*     */   extends FilteredTermEnum
/*     */ {
/*     */   Term searchTerm;
/*  36 */   String field = """";
/*  37 */   String text = """";
/*  38 */   String pre = """";
/*  39 */   int preLen = 0;
/*     */ 
/*     */   
/*     */   boolean endEnum = false;
/*     */ 
/*     */   
/*     */   public static final char WILDCARD_STRING = '*';
/*     */ 
/*     */   
/*     */   public static final char WILDCARD_CHAR = '?';
/*     */ 
/*     */   
/*     */   public WildcardTermEnum(IndexReader reader, Term term) throws IOException {
/*  52 */     this.searchTerm = term;
/*  53 */     this.field = this.searchTerm.field();
/*  54 */     this.text = this.searchTerm.text();
/*     */     
/*  56 */     int sidx = this.text.indexOf('*');
/*  57 */     int cidx = this.text.indexOf('?');
/*  58 */     int idx = sidx;
/*  59 */     if (idx == -1) {
/*  60 */       idx = cidx;
/*     */     }
/*  62 */     else if (cidx >= 0) {
/*  63 */       idx = Math.min(idx, cidx);
/*     */     } 
/*     */     
/*  66 */     this.pre = this.searchTerm.text().substring(0, idx);
/*  67 */     this.preLen = this.pre.length();
/*  68 */     this.text = this.text.substring(this.preLen);
/*  69 */     setEnum(reader.terms(new Term(this.searchTerm.field(), this.pre)));
/*     */   }
/*     */   
/*     */   protected final boolean termCompare(Term term) {
/*  73 */     if (this.field == term.field()) {
/*  74 */       String searchText = term.text();
/*  75 */       if (searchText.startsWith(this.pre)) {
/*  76 */         return wildcardEquals(this.text, 0, searchText, this.preLen);
/*     */       }
/*     */     } 
/*  79 */     this.endEnum = true;
/*  80 */     return false;
/*     */   }
/*     */ 
/*     */   
/*  84 */   public final float difference() { return 1.0F; }
/*     */ 
/*     */ 
/*     */   
/*  88 */   public final boolean endEnum() { return this.endEnum; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final boolean wildcardEquals(String pattern, int patternIdx, String string, int stringIdx) {
/* 106 */     int p = patternIdx;
/*     */     
/* 108 */     for (int s = stringIdx;; p++, s++) {
/*     */ 
/*     */       
/* 111 */       boolean sEnd = (s >= string.length());
/*     */       
/* 113 */       boolean pEnd = (p >= pattern.length());
/*     */ 
/*     */       
/* 116 */       if (sEnd) {
/*     */ 
/*     */         
/* 119 */         boolean justWildcardsLeft = true;
/*     */ 
/*     */         
/* 122 */         int wildcardSearchPos = p;
/*     */ 
/*     */         
/* 125 */         while (wildcardSearchPos < pattern.length() && justWildcardsLeft) {
/*     */ 
/*     */           
/* 128 */           char wildchar = pattern.charAt(wildcardSearchPos);
/*     */ 
/*     */ 
/*     */           
/* 132 */           if (wildchar != '?' && wildchar != '*') {
/*     */             
/* 134 */             justWildcardsLeft = false;
/*     */             
/*     */             continue;
/*     */           } 
/*     */           
/* 139 */           if (wildchar == '?') {
/* 140 */             return false;
/*     */           }
/*     */ 
/*     */           
/* 144 */           wildcardSearchPos++;
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 150 */         if (justWildcardsLeft)
/*     */         {
/* 152 */           return true;
/*     */         }
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 158 */       if (sEnd || pEnd) {
/*     */         break;
/*     */       }
/*     */ 
/*     */ 
/*     */       
/* 164 */       if (pattern.charAt(p) != '?') {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 170 */         if (pattern.charAt(p) == '*') {
/*     */ 
/*     */           
/* 173 */           p++;
/*     */           
/* 175 */           for (int i = string.length(); i >= s; i--) {
/*     */             
/* 177 */             if (wildcardEquals(pattern, p, string, i))
/*     */             {
/* 179 */               return true;
/*     */             }
/*     */           } 
/*     */           break;
/*     */         } 
/* 184 */         if (pattern.charAt(p) != string.charAt(s)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 189 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 194 */     super.close();
/* 195 */     this.searchTerm = null;
/* 196 */     this.field = null;
/* 197 */     this.text = null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\WildcardTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ByteFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ByteFieldSource
/*     */   extends FieldCacheSource
/*     */ {
/*     */   private FieldCache.ByteParser parser;
/*     */   
/*  47 */   public ByteFieldSource(String field) { this(field, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public ByteFieldSource(String field, FieldCache.ByteParser parser) {
/*  54 */     super(field);
/*  55 */     this.parser = parser;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  60 */   public String description() { return ""byte("" + super.description() + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/*  65 */     final byte[] arr = (this.parser == null) ? cache.getBytes(reader, field) : cache.getBytes(reader, field, this.parser);
/*     */ 
/*     */     
/*  68 */     return new DocValues() {
/*     */         private final byte[] val$arr;
/*     */         
/*  71 */         public float floatVal(int doc) { return arr[doc]; }
/*     */         
/*     */         private final ByteFieldSource this$0;
/*     */         
/*  75 */         public int intVal(int doc) { return arr[doc]; }
/*     */ 
/*     */ 
/*     */         
/*  79 */         public String toString(int doc) { return ByteFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  83 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/*  90 */     if (o.getClass() != ByteFieldSource.class) {
/*  91 */       return false;
/*     */     }
/*  93 */     ByteFieldSource other = (ByteFieldSource)o;
/*  94 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Byte.class.hashCode() : this.parser.getClass().hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\ByteFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.CustomScoreQuery,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.ComplexExplanation;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class CustomScoreQuery
/*     */   extends Query
/*     */ {
/*     */   private Query subQuery;
/*     */   private ValueSourceQuery[] valSrcQueries;
/*     */   private boolean strict = false;
/*     */   
/*  59 */   public CustomScoreQuery(Query subQuery) { this(subQuery, new ValueSourceQuery[0]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  71 */   public CustomScoreQuery(Query subQuery, ValueSourceQuery valSrcQuery) { this(subQuery, (valSrcQuery != null) ? new ValueSourceQuery[1] : new ValueSourceQuery[0]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public CustomScoreQuery(Query subQuery, ValueSourceQuery[] valSrcQueries) {
/*  85 */     this.subQuery = subQuery;
/*  86 */     this.valSrcQueries = (valSrcQueries != null) ? valSrcQueries : new ValueSourceQuery[0];
/*     */     
/*  88 */     if (subQuery == null) throw new IllegalArgumentException(""<subquery> must not be null!"");
/*     */   
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  93 */     this.subQuery = this.subQuery.rewrite(reader);
/*  94 */     for (int i = 0; i < this.valSrcQueries.length; i++) {
/*  95 */       this.valSrcQueries[i] = (ValueSourceQuery)this.valSrcQueries[i].rewrite(reader);
/*     */     }
/*  97 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 102 */     this.subQuery.extractTerms(terms);
/* 103 */     for (int i = 0; i < this.valSrcQueries.length; i++) {
/* 104 */       this.valSrcQueries[i].extractTerms(terms);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 110 */     CustomScoreQuery clone = (CustomScoreQuery)super.clone();
/* 111 */     clone.subQuery = (Query)this.subQuery.clone();
/* 112 */     clone.valSrcQueries = new ValueSourceQuery[this.valSrcQueries.length];
/* 113 */     for (int i = 0; i < this.valSrcQueries.length; i++) {
/* 114 */       clone.valSrcQueries[i] = (ValueSourceQuery)this.valSrcQueries[i].clone();
/*     */     }
/* 116 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 121 */     StringBuffer sb = (new StringBuffer(name())).append(""("");
/* 122 */     sb.append(this.subQuery.toString(field));
/* 123 */     for (int i = 0; i < this.valSrcQueries.length; i++) {
/* 124 */       sb.append("", "").append(this.valSrcQueries[i].toString(field));
/*     */     }
/* 126 */     sb.append("")"");
/* 127 */     sb.append(this.strict ? "" STRICT"" : """");
/* 128 */     return sb.toString() + ToStringUtils.boost(getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 133 */     if (getClass() != o.getClass()) {
/* 134 */       return false;
/*     */     }
/* 136 */     CustomScoreQuery other = (CustomScoreQuery)o;
/* 137 */     if (getBoost() != other.getBoost() || !this.subQuery.equals(other.subQuery) || this.valSrcQueries.length != other.valSrcQueries.length)
/*     */     {
/*     */       
/* 140 */       return false;
/*     */     }
/* 142 */     for (int i = 0; i < this.valSrcQueries.length; i++) {
/* 143 */       if (!this.valSrcQueries[i].equals(other.valSrcQueries[i])) {
/* 144 */         return false;
/*     */       }
/*     */     } 
/* 147 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 152 */     int valSrcHash = 0;
/* 153 */     for (int i = 0; i < this.valSrcQueries.length; i++) {
/* 154 */       valSrcHash += this.valSrcQueries[i].hashCode();
/*     */     }
/* 156 */     return getClass().hashCode() + this.subQuery.hashCode() + valSrcHash ^ Float.floatToIntBits(getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float customScore(int doc, float subQueryScore, float[] valSrcScores) {
/* 183 */     if (valSrcScores.length == 1) {
/* 184 */       return customScore(doc, subQueryScore, valSrcScores[0]);
/*     */     }
/* 186 */     if (valSrcScores.length == 0) {
/* 187 */       return customScore(doc, subQueryScore, 1.0F);
/*     */     }
/* 189 */     float score = subQueryScore;
/* 190 */     for (int i = 0; i < valSrcScores.length; i++) {
/* 191 */       score *= valSrcScores[i];
/*     */     }
/* 193 */     return score;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 217 */   public float customScore(int doc, float subQueryScore, float valSrcScore) { return subQueryScore * valSrcScore; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation[] valSrcExpls) {
/* 232 */     if (valSrcExpls.length == 1) {
/* 233 */       return customExplain(doc, subQueryExpl, valSrcExpls[0]);
/*     */     }
/* 235 */     if (valSrcExpls.length == 0) {
/* 236 */       return subQueryExpl;
/*     */     }
/* 238 */     float valSrcScore = 1.0F;
/* 239 */     for (int i = 0; i < valSrcExpls.length; i++) {
/* 240 */       valSrcScore *= valSrcExpls[i].getValue();
/*     */     }
/* 242 */     Explanation exp = new Explanation(valSrcScore * subQueryExpl.getValue(), ""custom score: product of:"");
/* 243 */     exp.addDetail(subQueryExpl);
/* 244 */     for (int i = 0; i < valSrcExpls.length; i++) {
/* 245 */       exp.addDetail(valSrcExpls[i]);
/*     */     }
/* 247 */     return exp;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
/* 262 */     float valSrcScore = 1.0F;
/* 263 */     if (valSrcExpl != null) {
/* 264 */       valSrcScore *= valSrcExpl.getValue();
/*     */     }
/* 266 */     Explanation exp = new Explanation(valSrcScore * subQueryExpl.getValue(), ""custom score: product of:"");
/* 267 */     exp.addDetail(subQueryExpl);
/* 268 */     exp.addDetail(valSrcExpl);
/* 269 */     return exp;
/*     */   }
/*     */   
/*     */   private class CustomWeight
/*     */     implements Weight {
/*     */     Similarity similarity;
/*     */     Weight subQueryWeight;
/*     */     Weight[] valSrcWeights;
/*     */     boolean qStrict;
/*     */     private final CustomScoreQuery this$0;
/*     */     
/*     */     public CustomWeight(Searcher searcher) throws IOException {
/* 281 */       this.similarity = CustomScoreQuery.this.getSimilarity(searcher);
/* 282 */       this.subQueryWeight = CustomScoreQuery.this.subQuery.weight(searcher);
/* 283 */       this.subQueryWeight = CustomScoreQuery.this.subQuery.weight(searcher);
/* 284 */       this.valSrcWeights = new Weight[CustomScoreQuery.this.valSrcQueries.length];
/* 285 */       for (int i = 0; i < CustomScoreQuery.this.valSrcQueries.length; i++) {
/* 286 */         this.valSrcWeights[i] = CustomScoreQuery.this.valSrcQueries[i].createWeight(searcher);
/*     */       }
/* 288 */       this.qStrict = CustomScoreQuery.this.strict;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 293 */     public Query getQuery() { return CustomScoreQuery.this; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 298 */     public float getValue() { return CustomScoreQuery.this.getBoost(); }
/*     */ 
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 303 */       float sum = this.subQueryWeight.sumOfSquaredWeights();
/* 304 */       for (int i = 0; i < this.valSrcWeights.length; i++) {
/* 305 */         if (this.qStrict) {
/* 306 */           this.valSrcWeights[i].sumOfSquaredWeights();
/*     */         } else {
/* 308 */           sum += this.valSrcWeights[i].sumOfSquaredWeights();
/*     */         } 
/*     */       } 
/* 311 */       sum *= CustomScoreQuery.this.getBoost() * CustomScoreQuery.this.getBoost();
/* 312 */       return sum;
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 317 */       norm *= CustomScoreQuery.this.getBoost();
/* 318 */       this.subQueryWeight.normalize(norm);
/* 319 */       for (int i = 0; i < this.valSrcWeights.length; i++) {
/* 320 */         if (this.qStrict) {
/* 321 */           this.valSrcWeights[i].normalize(1.0F);
/*     */         } else {
/* 323 */           this.valSrcWeights[i].normalize(norm);
/*     */         } 
/*     */       } 
/*     */     }
/*     */ 
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 330 */       Scorer subQueryScorer = this.subQueryWeight.scorer(reader);
/* 331 */       Scorer[] valSrcScorers = new Scorer[this.valSrcWeights.length];
/* 332 */       for (int i = 0; i < valSrcScorers.length; i++) {
/* 333 */         valSrcScorers[i] = this.valSrcWeights[i].scorer(reader);
/*     */       }
/* 335 */       return new CustomScoreQuery.CustomScorer(this.similarity, reader, this, subQueryScorer, valSrcScorers);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 340 */     public Explanation explain(IndexReader reader, int doc) throws IOException { return scorer(reader).explain(doc); }
/*     */   }
/*     */ 
/*     */   
/*     */   private class CustomScorer
/*     */     extends Scorer
/*     */   {
/*     */     private final CustomScoreQuery.CustomWeight weight;
/*     */     
/*     */     private final float qWeight;
/*     */     
/*     */     private Scorer subQueryScorer;
/*     */     
/*     */     private Scorer[] valSrcScorers;
/*     */     
/*     */     private IndexReader reader;
/*     */     
/*     */     private float[] vScores;
/*     */     private final CustomScoreQuery this$0;
/*     */     
/*     */     private CustomScorer(Similarity similarity, IndexReader reader, CustomScoreQuery.CustomWeight w, Scorer subQueryScorer, Scorer[] valSrcScorers) throws IOException {
/* 361 */       super(similarity);
/* 362 */       this.weight = w;
/* 363 */       this.qWeight = w.getValue();
/* 364 */       this.subQueryScorer = subQueryScorer;
/* 365 */       this.valSrcScorers = valSrcScorers;
/* 366 */       this.reader = reader;
/* 367 */       this.vScores = new float[valSrcScorers.length];
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/* 372 */       boolean hasNext = this.subQueryScorer.next();
/* 373 */       if (hasNext) {
/* 374 */         for (int i = 0; i < this.valSrcScorers.length; i++) {
/* 375 */           this.valSrcScorers[i].skipTo(this.subQueryScorer.doc());
/*     */         }
/*     */       }
/* 378 */       return hasNext;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 383 */     public int doc() { return this.subQueryScorer.doc(); }
/*     */ 
/*     */ 
/*     */     
/*     */     public float score() throws IOException {
/* 388 */       for (int i = 0; i < this.valSrcScorers.length; i++) {
/* 389 */         this.vScores[i] = this.valSrcScorers[i].score();
/*     */       }
/* 391 */       return this.qWeight * CustomScoreQuery.this.customScore(this.subQueryScorer.doc(), this.subQueryScorer.score(), this.vScores);
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 396 */       boolean hasNext = this.subQueryScorer.skipTo(target);
/* 397 */       if (hasNext) {
/* 398 */         for (int i = 0; i < this.valSrcScorers.length; i++) {
/* 399 */           this.valSrcScorers[i].skipTo(this.subQueryScorer.doc());
/*     */         }
/*     */       }
/* 402 */       return hasNext;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(int doc) throws IOException {
/* 407 */       Explanation subQueryExpl = this.weight.subQueryWeight.explain(this.reader, doc);
/* 408 */       if (!subQueryExpl.isMatch()) {
/* 409 */         return subQueryExpl;
/*     */       }
/*     */       
/* 412 */       Explanation[] valSrcExpls = new Explanation[this.valSrcScorers.length];
/* 413 */       for (int i = 0; i < this.valSrcScorers.length; i++) {
/* 414 */         valSrcExpls[i] = this.valSrcScorers[i].explain(doc);
/*     */       }
/* 416 */       Explanation customExp = CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpls);
/* 417 */       float sc = this.qWeight * customExp.getValue();
/* 418 */       ComplexExplanation complexExplanation = new ComplexExplanation(true, sc, CustomScoreQuery.this.toString() + "", product of:"");
/*     */       
/* 420 */       complexExplanation.addDetail(customExp);
/* 421 */       complexExplanation.addDetail(new Explanation(this.qWeight, ""queryBoost""));
/* 422 */       return (Explanation)complexExplanation;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 428 */   protected Weight createWeight(Searcher searcher) throws IOException { return new CustomWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 441 */   public boolean isStrict() { return this.strict; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 450 */   public void setStrict(boolean strict) { this.strict = strict; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 457 */   public String name() { return ""custom""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\CustomScoreQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.DocValues,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import org.apache.lucene.search.Explanation;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class DocValues
/*     */ {
/*     */   private float minVal;
/*     */   private float maxVal;
/*     */   private float avgVal;
/*     */   
/*     */   public abstract float floatVal(int paramInt);
/*     */   
/*  58 */   public int intVal(int doc) { return (int)floatVal(doc); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  67 */   public long longVal(int doc) { return (long)floatVal(doc); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public double doubleVal(int doc) { return floatVal(doc); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public String strVal(int doc) { return Float.toString(floatVal(doc)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract String toString(int paramInt);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public Explanation explain(int doc) { return new Explanation(floatVal(doc), toString(doc)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 113 */   Object getInnerArray() { throw new UnsupportedOperationException(""this optional method is for test purposes only""); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean computed = false;
/*     */ 
/*     */ 
/*     */   
/*     */   private void compute() {
/* 123 */     if (this.computed) {
/*     */       return;
/*     */     }
/* 126 */     this.minVal = Float.MAX_VALUE;
/* 127 */     this.maxVal = 0.0F;
/* 128 */     float sum = 0.0F;
/* 129 */     int n = 0;
/*     */     while (true) {
/*     */       float val;
/*     */       try {
/* 133 */         val = floatVal(n);
/* 134 */       } catch (ArrayIndexOutOfBoundsException e) {
/*     */         break;
/*     */       } 
/* 137 */       sum += val;
/* 138 */       this.minVal = Math.min(this.minVal, val);
/* 139 */       this.maxVal = Math.max(this.maxVal, val);
/*     */     } 
/* 141 */     this.avgVal = sum / n;
/* 142 */     this.computed = true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float getMinValue() {
/* 149 */     compute();
/* 150 */     return this.minVal;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float getMaxValue() {
/* 158 */     compute();
/* 159 */     return this.maxVal;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float getAverageValue() {
/* 166 */     compute();
/* 167 */     return this.avgVal;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\DocValues.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.FieldCacheSource,"/*    */ package org.apache.lucene.search.function;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.FieldCache;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class FieldCacheSource
/*    */   extends ValueSource
/*    */ {
/*    */   private String field;
/*    */   
/* 50 */   public FieldCacheSource(String field) { this.field = field; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 55 */   public final DocValues getValues(IndexReader reader) throws IOException { return getCachedFieldValues(FieldCache.DEFAULT, this.field, reader); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 60 */   public String description() { return this.field; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public abstract DocValues getCachedFieldValues(FieldCache paramFieldCache, String paramString, IndexReader paramIndexReader) throws IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public final boolean equals(Object o) {
/* 73 */     if (!(o instanceof FieldCacheSource)) {
/* 74 */       return false;
/*    */     }
/* 76 */     FieldCacheSource other = (FieldCacheSource)o;
/* 77 */     return (this.field.equals(other.field) && cachedFieldSourceEquals(other));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 84 */   public final int hashCode() { return this.field.hashCode() + cachedFieldSourceHashCode(); }
/*    */   
/*    */   public abstract boolean cachedFieldSourceEquals(FieldCacheSource paramFieldCacheSource);
/*    */   
/*    */   public abstract int cachedFieldSourceHashCode();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\FieldCacheSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.FieldScoreQuery,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FieldScoreQuery
/*     */   extends ValueSourceQuery
/*     */ {
/*     */   public static class Type
/*     */   {
/*  77 */     public static final Type BYTE = new Type(""byte"");
/*     */ 
/*     */     
/*  80 */     public static final Type SHORT = new Type(""short"");
/*     */ 
/*     */     
/*  83 */     public static final Type INT = new Type(""int"");
/*     */ 
/*     */     
/*  86 */     public static final Type FLOAT = new Type(""float"");
/*     */     
/*     */     private String typeName;
/*     */     
/*  90 */     private Type(String name) { this.typeName = name; }
/*     */ 
/*     */ 
/*     */     
/*  94 */     public String toString() { return getClass().getName() + ""::"" + this.typeName; }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public FieldScoreQuery(String field, Type type) { super(getValueSource(field, type)); }
/*     */ 
/*     */ 
/*     */   
/*     */   private static ValueSource getValueSource(String field, Type type) {
/* 112 */     if (type == Type.BYTE) {
/* 113 */       return new ByteFieldSource(field);
/*     */     }
/* 115 */     if (type == Type.SHORT) {
/* 116 */       return new ShortFieldSource(field);
/*     */     }
/* 118 */     if (type == Type.INT) {
/* 119 */       return new IntFieldSource(field);
/*     */     }
/* 121 */     if (type == Type.FLOAT) {
/* 122 */       return new FloatFieldSource(field);
/*     */     }
/* 124 */     throw new IllegalArgumentException(type + "" is not a known Field Score Query Type!"");
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\FieldScoreQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.FloatFieldSource,"/*    */ package org.apache.lucene.search.function;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.FieldCache;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FloatFieldSource
/*    */   extends FieldCacheSource
/*    */ {
/*    */   private FieldCache.FloatParser parser;
/*    */   
/* 48 */   public FloatFieldSource(String field) { this(field, null); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FloatFieldSource(String field, FieldCache.FloatParser parser) {
/* 55 */     super(field);
/* 56 */     this.parser = parser;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 61 */   public String description() { return ""float("" + super.description() + ')'; }
/*    */ 
/*    */ 
/*    */   
/*    */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/* 66 */     final float[] arr = (this.parser == null) ? cache.getFloats(reader, field) : cache.getFloats(reader, field, this.parser);
/*    */ 
/*    */     
/* 69 */     return new DocValues() {
/*    */         private final float[] val$arr;
/*    */         
/* 72 */         public float floatVal(int doc) { return arr[doc]; }
/*    */         
/*    */         private final FloatFieldSource this$0;
/*    */         
/* 76 */         public String toString(int doc) { return FloatFieldSource.this.description() + '=' + arr[doc]; }
/*    */ 
/*    */ 
/*    */         
/* 80 */         Object getInnerArray() { return arr; }
/*    */       };
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/* 87 */     if (o.getClass() != FloatFieldSource.class) {
/* 88 */       return false;
/*    */     }
/* 90 */     FloatFieldSource other = (FloatFieldSource)o;
/* 91 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 98 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Float.class.hashCode() : this.parser.getClass().hashCode(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\FloatFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.IntFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IntFieldSource
/*     */   extends FieldCacheSource
/*     */ {
/*     */   private FieldCache.IntParser parser;
/*     */   
/*  49 */   public IntFieldSource(String field) { this(field, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IntFieldSource(String field, FieldCache.IntParser parser) {
/*  56 */     super(field);
/*  57 */     this.parser = parser;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  62 */   public String description() { return ""int("" + super.description() + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/*  67 */     final int[] arr = (this.parser == null) ? cache.getInts(reader, field) : cache.getInts(reader, field, this.parser);
/*     */ 
/*     */     
/*  70 */     return new DocValues() {
/*     */         private final int[] val$arr;
/*     */         
/*  73 */         public float floatVal(int doc) { return arr[doc]; }
/*     */         
/*     */         private final IntFieldSource this$0;
/*     */         
/*  77 */         public int intVal(int doc) { return arr[doc]; }
/*     */ 
/*     */ 
/*     */         
/*  81 */         public String toString(int doc) { return IntFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  85 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/*  92 */     if (o.getClass() != IntFieldSource.class) {
/*  93 */       return false;
/*     */     }
/*  95 */     IntFieldSource other = (IntFieldSource)o;
/*  96 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Integer.class.hashCode() : this.parser.getClass().hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\IntFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.OrdFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class OrdFieldSource
/*     */   extends ValueSource
/*     */ {
/*     */   protected String field;
/*     */   
/*  57 */   public OrdFieldSource(String field) { this.field = field; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  62 */   public String description() { return ""ord("" + this.field + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getValues(IndexReader reader) throws IOException {
/*  67 */     final int[] arr = (FieldCache.DEFAULT.getStringIndex(reader, this.field)).order;
/*  68 */     return new DocValues() {
/*     */         private final int[] val$arr;
/*     */         
/*  71 */         public float floatVal(int doc) { return arr[doc]; }
/*     */ 
/*     */         
/*     */         private final OrdFieldSource this$0;
/*     */         
/*  76 */         public String strVal(int doc) { return Integer.toString(arr[doc]); }
/*     */ 
/*     */ 
/*     */         
/*  80 */         public String toString(int doc) { return OrdFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  84 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*  91 */     if (o.getClass() != OrdFieldSource.class) return false; 
/*  92 */     OrdFieldSource other = (OrdFieldSource)o;
/*  93 */     return this.field.equals(other.field);
/*     */   }
/*     */   
/*  96 */   private static final int hcode = OrdFieldSource.class.hashCode();
/*     */ 
/*     */ 
/*     */   
/* 100 */   public int hashCode() { return hcode + this.field.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\OrdFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ReverseOrdFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ReverseOrdFieldSource
/*     */   extends ValueSource
/*     */ {
/*     */   public String field;
/*     */   
/*  58 */   public ReverseOrdFieldSource(String field) { this.field = field; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  63 */   public String description() { return ""rord("" + this.field + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getValues(IndexReader reader) throws IOException {
/*  68 */     FieldCache.StringIndex sindex = FieldCache.DEFAULT.getStringIndex(reader, this.field);
/*     */     
/*  70 */     final int[] arr = sindex.order;
/*  71 */     final int end = sindex.lookup.length;
/*     */     
/*  73 */     return new DocValues() {
/*     */         private final int val$end;
/*     */         
/*  76 */         public float floatVal(int doc) { return (end - arr[doc]); }
/*     */         
/*     */         private final int[] val$arr;
/*     */         
/*  80 */         public int intVal(int doc) { return end - arr[doc]; }
/*     */ 
/*     */         
/*     */         private final ReverseOrdFieldSource this$0;
/*     */         
/*  85 */         public String strVal(int doc) { return Integer.toString(intVal(doc)); }
/*     */ 
/*     */ 
/*     */         
/*  89 */         public String toString(int doc) { return ReverseOrdFieldSource.this.description() + '=' + strVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  93 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 100 */     if (o.getClass() != ReverseOrdFieldSource.class) return false; 
/* 101 */     ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
/* 102 */     return this.field.equals(other.field);
/*     */   }
/*     */   
/* 105 */   private static final int hcode = ReverseOrdFieldSource.class.hashCode();
/*     */ 
/*     */ 
/*     */   
/* 109 */   public int hashCode() { return hcode + this.field.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\ReverseOrdFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ShortFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ShortFieldSource
/*     */   extends FieldCacheSource
/*     */ {
/*     */   private FieldCache.ShortParser parser;
/*     */   
/*  47 */   public ShortFieldSource(String field) { this(field, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public ShortFieldSource(String field, FieldCache.ShortParser parser) {
/*  54 */     super(field);
/*  55 */     this.parser = parser;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  60 */   public String description() { return ""short("" + super.description() + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/*  65 */     final short[] arr = (this.parser == null) ? cache.getShorts(reader, field) : cache.getShorts(reader, field, this.parser);
/*     */ 
/*     */     
/*  68 */     return new DocValues() {
/*     */         private final short[] val$arr;
/*     */         
/*  71 */         public float floatVal(int doc) { return arr[doc]; }
/*     */         
/*     */         private final ShortFieldSource this$0;
/*     */         
/*  75 */         public int intVal(int doc) { return arr[doc]; }
/*     */ 
/*     */ 
/*     */         
/*  79 */         public String toString(int doc) { return ShortFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  83 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/*  90 */     if (o.getClass() != ShortFieldSource.class) {
/*  91 */       return false;
/*     */     }
/*  93 */     ShortFieldSource other = (ShortFieldSource)o;
/*  94 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Short.class.hashCode() : this.parser.getClass().hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\ShortFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ValueSource,"/*    */ package org.apache.lucene.search.function;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Serializable;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class ValueSource
/*    */   implements Serializable
/*    */ {
/*    */   public abstract DocValues getValues(IndexReader paramIndexReader) throws IOException;
/*    */   
/*    */   public abstract String description();
/*    */   
/* 58 */   public String toString() { return description(); }
/*    */   
/*    */   public abstract boolean equals(Object paramObject);
/*    */   
/*    */   public abstract int hashCode();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\ValueSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ValueSourceQuery,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.ComplexExplanation;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ValueSourceQuery
/*     */   extends Query
/*     */ {
/*     */   ValueSource valSrc;
/*     */   
/*  49 */   public ValueSourceQuery(ValueSource valSrc) { this.valSrc = valSrc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  54 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   private class ValueSourceWeight
/*     */     implements Weight
/*     */   {
/*     */     Similarity similarity;
/*     */     float queryNorm;
/*     */     float queryWeight;
/*     */     private final ValueSourceQuery this$0;
/*     */     
/*  68 */     public ValueSourceWeight(Searcher searcher) { this.similarity = ValueSourceQuery.this.getSimilarity(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  73 */     public Query getQuery() { return ValueSourceQuery.this; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  78 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/*  83 */       this.queryWeight = ValueSourceQuery.this.getBoost();
/*  84 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/*  89 */       this.queryNorm = norm;
/*  90 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*  95 */     public Scorer scorer(IndexReader reader) throws IOException { return new ValueSourceQuery.ValueSourceScorer(this.similarity, reader, this); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 100 */     public Explanation explain(IndexReader reader, int doc) throws IOException { return scorer(reader).explain(doc); }
/*     */   }
/*     */ 
/*     */   
/*     */   private class ValueSourceScorer
/*     */     extends Scorer
/*     */   {
/*     */     private final IndexReader reader;
/*     */     
/*     */     private final ValueSourceQuery.ValueSourceWeight weight;
/*     */     
/*     */     private final int maxDoc;
/*     */     
/*     */     private final float qWeight;
/*     */     
/* 115 */     private int doc = -1;
/*     */     private final DocValues vals;
/*     */     private final ValueSourceQuery this$0;
/*     */     
/*     */     private ValueSourceScorer(Similarity similarity, IndexReader reader, ValueSourceQuery.ValueSourceWeight w) throws IOException {
/* 120 */       super(similarity);
/* 121 */       this.weight = w;
/* 122 */       this.qWeight = w.getValue();
/* 123 */       this.reader = reader;
/* 124 */       this.maxDoc = reader.maxDoc();
/*     */       
/* 126 */       this.vals = ValueSourceQuery.this.valSrc.getValues(reader);
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/*     */       while (true) {
/* 132 */         this.doc++;
/* 133 */         if (this.doc >= this.maxDoc) {
/* 134 */           return false;
/*     */         }
/* 136 */         if (this.reader.isDeleted(this.doc))
/*     */           continue;  break;
/*     */       } 
/* 139 */       return true;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 146 */     public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 151 */     public float score() throws IOException { return this.qWeight * this.vals.floatVal(this.doc); }
/*     */ 
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 156 */       this.doc = target - 1;
/* 157 */       return next();
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(int doc) throws IOException {
/* 162 */       float sc = this.qWeight * this.vals.floatVal(doc);
/*     */       
/* 164 */       ComplexExplanation complexExplanation = new ComplexExplanation(true, sc, ValueSourceQuery.this.toString() + "", product of:"");
/*     */ 
/*     */       
/* 167 */       complexExplanation.addDetail(this.vals.explain(doc));
/* 168 */       complexExplanation.addDetail(new Explanation(ValueSourceQuery.this.getBoost(), ""boost""));
/* 169 */       complexExplanation.addDetail(new Explanation(this.weight.queryNorm, ""queryNorm""));
/* 170 */       return (Explanation)complexExplanation;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 176 */   protected Weight createWeight(Searcher searcher) { return new ValueSourceWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 181 */   public String toString(String field) { return this.valSrc.toString() + ToStringUtils.boost(getBoost()); }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 186 */     if (getClass() != o.getClass()) {
/* 187 */       return false;
/*     */     }
/* 189 */     ValueSourceQuery other = (ValueSourceQuery)o;
/* 190 */     return (getBoost() == other.getBoost() && this.valSrc.equals(other.valSrc));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   public int hashCode() { return getClass().hashCode() + this.valSrc.hashCode() ^ Float.floatToIntBits(getBoost()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\function\ValueSourceQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.payloads.BoostingTermQuery,"/*     */ package org.apache.lucene.search.payloads;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.search.ComplexExplanation;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ import org.apache.lucene.search.spans.SpanQuery;
/*     */ import org.apache.lucene.search.spans.SpanScorer;
/*     */ import org.apache.lucene.search.spans.SpanTermQuery;
/*     */ import org.apache.lucene.search.spans.SpanWeight;
/*     */ import org.apache.lucene.search.spans.Spans;
/*     */ import org.apache.lucene.search.spans.TermSpans;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BoostingTermQuery
/*     */   extends SpanTermQuery
/*     */ {
/*  46 */   public BoostingTermQuery(Term term) { super(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  51 */   protected Weight createWeight(Searcher searcher) throws IOException { return new BoostingTermWeight(this, searcher); }
/*     */   
/*     */   protected class BoostingTermWeight
/*     */     extends SpanWeight
/*     */     implements Weight {
/*     */     private final BoostingTermQuery this$0;
/*     */     
/*  58 */     public BoostingTermWeight(BoostingTermQuery query, Searcher searcher) throws IOException { super((SpanQuery)query, searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  65 */     public Scorer scorer(IndexReader reader) throws IOException { return (Scorer)new BoostingSpanScorer((TermSpans)this.query.getSpans(reader), this, this.similarity, reader.norms(this.query.getField())); }
/*     */ 
/*     */ 
/*     */     
/*     */     protected class BoostingSpanScorer
/*     */       extends SpanScorer
/*     */     {
/*  72 */       byte[] payload = new byte[256];
/*     */       private TermPositions positions;
/*     */       protected float payloadScore;
/*     */       private int payloadsSeen;
/*     */       private final BoostingTermQuery.BoostingTermWeight this$1;
/*     */       
/*     */       public BoostingSpanScorer(TermSpans spans, Weight weight, Similarity similarity, byte[] norms) throws IOException {
/*  79 */         super((Spans)spans, weight, similarity, norms);
/*  80 */         this.positions = spans.getPositions();
/*     */       }
/*     */ 
/*     */       
/*     */       protected boolean setFreqCurrentDoc() throws IOException {
/*  85 */         if (!this.more) {
/*  86 */           return false;
/*     */         }
/*  88 */         this.doc = this.spans.doc();
/*  89 */         this.freq = 0.0F;
/*  90 */         this.payloadScore = 0.0F;
/*  91 */         this.payloadsSeen = 0;
/*  92 */         Similarity similarity1 = getSimilarity();
/*  93 */         while (this.more && this.doc == this.spans.doc()) {
/*  94 */           int matchLength = this.spans.end() - this.spans.start();
/*     */           
/*  96 */           this.freq += similarity1.sloppyFreq(matchLength);
/*  97 */           processPayload(similarity1);
/*     */           
/*  99 */           this.more = this.spans.next();
/*     */         } 
/* 101 */         return (this.more || this.freq != 0.0F);
/*     */       }
/*     */ 
/*     */       
/*     */       protected void processPayload(Similarity similarity) throws IOException {
/* 106 */         if (this.positions.isPayloadAvailable()) {
/* 107 */           this.payload = this.positions.getPayload(this.payload, 0);
/* 108 */           this.payloadScore += similarity.scorePayload((BoostingTermQuery.BoostingTermWeight.access$000(BoostingTermQuery.BoostingTermWeight.this)).term.field(), this.payload, 0, this.positions.getPayloadLength());
/* 109 */           this.payloadsSeen++;
/*     */         } 
/*     */       }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 119 */       public float score() throws IOException { return super.score() * ((this.payloadsSeen > 0) ? (this.payloadScore / this.payloadsSeen) : 1.0F); }
/*     */ 
/*     */ 
/*     */       
/*     */       public Explanation explain(int doc) throws IOException {
/* 124 */         ComplexExplanation result = new ComplexExplanation();
/* 125 */         Explanation nonPayloadExpl = super.explain(doc);
/* 126 */         result.addDetail(nonPayloadExpl);
/*     */ 
/*     */         
/* 129 */         Explanation payloadBoost = new Explanation();
/* 130 */         result.addDetail(payloadBoost);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 137 */         float avgPayloadScore = (this.payloadsSeen > 0) ? (this.payloadScore / this.payloadsSeen) : 1.0F;
/* 138 */         payloadBoost.setValue(avgPayloadScore);
/*     */         
/* 140 */         payloadBoost.setDescription(""scorePayload(...)"");
/* 141 */         result.setValue(nonPayloadExpl.getValue() * avgPayloadScore);
/* 142 */         result.setDescription(""btq, product of:"");
/* 143 */         result.setMatch((nonPayloadExpl.getValue() == 0.0F) ? Boolean.FALSE : Boolean.TRUE);
/* 144 */         return (Explanation)result;
/*     */       }
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 152 */     if (!(o instanceof BoostingTermQuery))
/* 153 */       return false; 
/* 154 */     BoostingTermQuery other = (BoostingTermQuery)o;
/* 155 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\payloads\BoostingTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.payloads.PayloadSpanUtil,"/*     */ package org.apache.lucene.search.payloads;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.search.BooleanClause;
/*     */ import org.apache.lucene.search.BooleanQuery;
/*     */ import org.apache.lucene.search.DisjunctionMaxQuery;
/*     */ import org.apache.lucene.search.FilteredQuery;
/*     */ import org.apache.lucene.search.MultiPhraseQuery;
/*     */ import org.apache.lucene.search.PhraseQuery;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.TermQuery;
/*     */ import org.apache.lucene.search.spans.PayloadSpans;
/*     */ import org.apache.lucene.search.spans.SpanNearQuery;
/*     */ import org.apache.lucene.search.spans.SpanOrQuery;
/*     */ import org.apache.lucene.search.spans.SpanQuery;
/*     */ import org.apache.lucene.search.spans.SpanTermQuery;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class PayloadSpanUtil
/*     */ {
/*     */   private IndexReader reader;
/*     */   
/*  62 */   public PayloadSpanUtil(IndexReader reader) { this.reader = reader; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getPayloadsForQuery(Query query) throws IOException {
/*  73 */     Collection payloads = new ArrayList();
/*  74 */     queryToSpanQuery(query, payloads);
/*  75 */     return payloads;
/*     */   }
/*     */ 
/*     */   
/*     */   private void queryToSpanQuery(Query query, Collection payloads) throws IOException {
/*  80 */     if (query instanceof BooleanQuery) {
/*  81 */       BooleanClause[] queryClauses = ((BooleanQuery)query).getClauses();
/*     */       
/*  83 */       for (int i = 0; i < queryClauses.length; i++) {
/*  84 */         if (!queryClauses[i].isProhibited()) {
/*  85 */           queryToSpanQuery(queryClauses[i].getQuery(), payloads);
/*     */         }
/*     */       }
/*     */     
/*  89 */     } else if (query instanceof PhraseQuery) {
/*  90 */       Term[] phraseQueryTerms = ((PhraseQuery)query).getTerms();
/*  91 */       SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];
/*  92 */       for (int i = 0; i < phraseQueryTerms.length; i++) {
/*  93 */         clauses[i] = (SpanQuery)new SpanTermQuery(phraseQueryTerms[i]);
/*     */       }
/*     */       
/*  96 */       int slop = ((PhraseQuery)query).getSlop();
/*  97 */       boolean inorder = false;
/*     */       
/*  99 */       if (slop == 0) {
/* 100 */         inorder = true;
/*     */       }
/*     */       
/* 103 */       SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);
/* 104 */       sp.setBoost(query.getBoost());
/* 105 */       getPayloads(payloads, (SpanQuery)sp);
/* 106 */     } else if (query instanceof TermQuery) {
/* 107 */       SpanTermQuery stq = new SpanTermQuery(((TermQuery)query).getTerm());
/* 108 */       stq.setBoost(query.getBoost());
/* 109 */       getPayloads(payloads, (SpanQuery)stq);
/* 110 */     } else if (query instanceof SpanQuery) {
/* 111 */       getPayloads(payloads, (SpanQuery)query);
/* 112 */     } else if (query instanceof FilteredQuery) {
/* 113 */       queryToSpanQuery(((FilteredQuery)query).getQuery(), payloads);
/* 114 */     } else if (query instanceof DisjunctionMaxQuery) {
/*     */       
/* 116 */       Iterator iterator = ((DisjunctionMaxQuery)query).iterator();
/* 117 */       while (iterator.hasNext()) {
/* 118 */         queryToSpanQuery(iterator.next(), payloads);
/*     */       }
/*     */     }
/* 121 */     else if (query instanceof MultiPhraseQuery) {
/* 122 */       MultiPhraseQuery mpq = (MultiPhraseQuery)query;
/* 123 */       List termArrays = mpq.getTermArrays();
/* 124 */       int[] positions = mpq.getPositions();
/* 125 */       if (positions.length > 0) {
/*     */         
/* 127 */         int maxPosition = positions[positions.length - 1];
/* 128 */         for (int i = 0; i < positions.length - 1; i++) {
/* 129 */           if (positions[i] > maxPosition) {
/* 130 */             maxPosition = positions[i];
/*     */           }
/*     */         } 
/*     */         
/* 134 */         List[] disjunctLists = new List[maxPosition + 1];
/* 135 */         int distinctPositions = 0;
/*     */         
/* 137 */         for (int i = 0; i < termArrays.size(); i++) {
/* 138 */           Term[] termArray = termArrays.get(i);
/* 139 */           List disjuncts = disjunctLists[positions[i]];
/* 140 */           if (disjuncts == null) {
/* 141 */             disjuncts = disjunctLists[positions[i]] = new ArrayList(termArray.length);
/*     */             
/* 143 */             distinctPositions++;
/*     */           } 
/* 145 */           for (int j = 0; j < termArray.length; j++) {
/* 146 */             disjuncts.add(new SpanTermQuery(termArray[j]));
/*     */           }
/*     */         } 
/*     */         
/* 150 */         int positionGaps = 0;
/* 151 */         int position = 0;
/* 152 */         SpanQuery[] clauses = new SpanQuery[distinctPositions];
/* 153 */         for (int i = 0; i < disjunctLists.length; i++) {
/* 154 */           List disjuncts = disjunctLists[i];
/* 155 */           if (disjuncts != null) {
/* 156 */             clauses[position++] = (SpanQuery)new SpanOrQuery((SpanQuery[])disjuncts.toArray((Object[])new SpanQuery[disjuncts.size()]));
/*     */           } else {
/*     */             
/* 159 */             positionGaps++;
/*     */           } 
/*     */         } 
/*     */         
/* 163 */         int slop = mpq.getSlop();
/* 164 */         boolean inorder = (slop == 0);
/*     */         
/* 166 */         SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);
/*     */         
/* 168 */         sp.setBoost(query.getBoost());
/* 169 */         getPayloads(payloads, (SpanQuery)sp);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void getPayloads(Collection payloads, SpanQuery query) throws IOException {
/* 176 */     PayloadSpans spans = query.getPayloadSpans(this.reader);
/*     */     
/* 178 */     while (spans.next() == true) {
/* 179 */       if (spans.isPayloadAvailable()) {
/* 180 */         Collection payload = spans.getPayload();
/* 181 */         Iterator it = payload.iterator();
/* 182 */         while (it.hasNext()) {
/* 183 */           byte[] bytes = it.next();
/* 184 */           payloads.add(bytes);
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\payloads\PayloadSpanUtil.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.NearSpansOrdered,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Collection;
/*     */ import java.util.Comparator;
/*     */ import java.util.LinkedList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class NearSpansOrdered
/*     */   implements PayloadSpans
/*     */ {
/*     */   private final int allowedSlop;
/*     */   private boolean firstTime = true;
/*     */   private boolean more = false;
/*     */   private final PayloadSpans[] subSpans;
/*     */   private boolean inSameDoc = false;
/*  58 */   private int matchDoc = -1;
/*  59 */   private int matchStart = -1;
/*  60 */   private int matchEnd = -1;
/*     */   private List matchPayload;
/*     */   private final PayloadSpans[] subSpansByDoc;
/*     */   
/*  64 */   private final Comparator spanDocComparator = new Comparator()
/*     */     {
/*  66 */       public int compare(Object o1, Object o2) { return ((Spans)o1).doc() - ((Spans)o2).doc(); }
/*     */       private final NearSpansOrdered this$0;
/*     */     };
/*     */   
/*     */   private SpanNearQuery query;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public NearSpansOrdered(SpanNearQuery spanNearQuery, IndexReader reader) throws IOException {
/*  74 */     if ((spanNearQuery.getClauses()).length < 2) {
/*  75 */       throw new IllegalArgumentException(""Less than 2 clauses: "" + spanNearQuery);
/*     */     }
/*     */     
/*  78 */     this.allowedSlop = spanNearQuery.getSlop();
/*  79 */     SpanQuery[] clauses = spanNearQuery.getClauses();
/*  80 */     this.subSpans = new PayloadSpans[clauses.length];
/*  81 */     this.matchPayload = new LinkedList();
/*  82 */     this.subSpansByDoc = new PayloadSpans[clauses.length];
/*  83 */     for (int i = 0; i < clauses.length; i++) {
/*  84 */       this.subSpans[i] = clauses[i].getPayloadSpans(reader);
/*  85 */       this.subSpansByDoc[i] = this.subSpans[i];
/*     */     } 
/*  87 */     this.query = spanNearQuery;
/*     */   }
/*     */ 
/*     */   
/*  91 */   public int doc() { return this.matchDoc; }
/*     */ 
/*     */   
/*  94 */   public int start() { return this.matchStart; }
/*     */ 
/*     */   
/*  97 */   public int end() { return this.matchEnd; }
/*     */ 
/*     */ 
/*     */   
/* 101 */   public Collection getPayload() throws IOException { return this.matchPayload; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public boolean isPayloadAvailable() { return !this.matchPayload.isEmpty(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/* 111 */     if (this.firstTime) {
/* 112 */       this.firstTime = false;
/* 113 */       for (int i = 0; i < this.subSpans.length; i++) {
/* 114 */         if (!this.subSpans[i].next()) {
/* 115 */           this.more = false;
/* 116 */           return false;
/*     */         } 
/*     */       } 
/* 119 */       this.more = true;
/*     */     } 
/* 121 */     this.matchPayload.clear();
/* 122 */     return advanceAfterOrdered();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 127 */     if (this.firstTime) {
/* 128 */       this.firstTime = false;
/* 129 */       for (int i = 0; i < this.subSpans.length; i++) {
/* 130 */         if (!this.subSpans[i].skipTo(target)) {
/* 131 */           this.more = false;
/* 132 */           return false;
/*     */         } 
/*     */       } 
/* 135 */       this.more = true;
/* 136 */     } else if (this.more && this.subSpans[0].doc() < target) {
/* 137 */       if (this.subSpans[0].skipTo(target)) {
/* 138 */         this.inSameDoc = false;
/*     */       } else {
/* 140 */         this.more = false;
/* 141 */         return false;
/*     */       } 
/*     */     } 
/* 144 */     this.matchPayload.clear();
/* 145 */     return advanceAfterOrdered();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean advanceAfterOrdered() throws IOException {
/* 153 */     while (this.more && (this.inSameDoc || toSameDoc())) {
/* 154 */       if (stretchToOrder() && shrinkToAfterShortestMatch()) {
/* 155 */         return true;
/*     */       }
/*     */     } 
/* 158 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean toSameDoc() throws IOException {
/* 164 */     Arrays.sort(this.subSpansByDoc, this.spanDocComparator);
/* 165 */     int firstIndex = 0;
/* 166 */     int maxDoc = this.subSpansByDoc[this.subSpansByDoc.length - 1].doc();
/* 167 */     while (this.subSpansByDoc[firstIndex].doc() != maxDoc) {
/* 168 */       if (!this.subSpansByDoc[firstIndex].skipTo(maxDoc)) {
/* 169 */         this.more = false;
/* 170 */         this.inSameDoc = false;
/* 171 */         return false;
/*     */       } 
/* 173 */       maxDoc = this.subSpansByDoc[firstIndex].doc();
/* 174 */       if (++firstIndex == this.subSpansByDoc.length) {
/* 175 */         firstIndex = 0;
/*     */       }
/*     */     } 
/* 178 */     for (int i = 0; i < this.subSpansByDoc.length; i++)
/*     */     {
/* 180 */       assert this.subSpansByDoc[i].doc() == maxDoc : "" NearSpansOrdered.toSameDoc() spans "" + this.subSpansByDoc[false] + ""\n at doc "" + this.subSpansByDoc[i].doc() + "", but should be at "" + maxDoc;
/*     */     }
/*     */ 
/*     */     
/* 184 */     this.inSameDoc = true;
/* 185 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static final boolean docSpansOrdered(Spans spans1, Spans spans2) {
/* 196 */     assert spans1.doc() == spans2.doc() : ""doc1 "" + spans1.doc() + "" != doc2 "" + spans2.doc();
/* 197 */     int start1 = spans1.start();
/* 198 */     int start2 = spans2.start();
/*     */     
/* 200 */     return (start1 == start2) ? ((spans1.end() < spans2.end())) : ((start1 < start2));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 207 */   private static final boolean docSpansOrdered(int start1, int end1, int start2, int end2) { return (start1 == start2) ? ((end1 < end2)) : ((start1 < start2)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean stretchToOrder() throws IOException {
/* 214 */     this.matchDoc = this.subSpans[0].doc();
/* 215 */     for (int i = 1; this.inSameDoc && i < this.subSpans.length; i++) {
/* 216 */       while (!docSpansOrdered(this.subSpans[i - 1], this.subSpans[i])) {
/* 217 */         if (!this.subSpans[i].next()) {
/* 218 */           this.inSameDoc = false;
/* 219 */           this.more = false; break;
/*     */         } 
/* 221 */         if (this.matchDoc != this.subSpans[i].doc()) {
/* 222 */           this.inSameDoc = false;
/*     */           break;
/*     */         } 
/*     */       } 
/*     */     } 
/* 227 */     return this.inSameDoc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean shrinkToAfterShortestMatch() throws IOException {
/* 235 */     this.matchStart = this.subSpans[this.subSpans.length - 1].start();
/* 236 */     this.matchEnd = this.subSpans[this.subSpans.length - 1].end();
/* 237 */     if (this.subSpans[this.subSpans.length - 1].isPayloadAvailable()) {
/* 238 */       this.matchPayload.addAll(this.subSpans[this.subSpans.length - 1].getPayload());
/*     */     }
/* 240 */     int matchSlop = 0;
/* 241 */     int lastStart = this.matchStart;
/* 242 */     int lastEnd = this.matchEnd;
/* 243 */     for (int i = this.subSpans.length - 2; i >= 0; i--) {
/* 244 */       PayloadSpans prevSpans = this.subSpans[i];
/*     */       
/* 246 */       if (this.subSpans[i].isPayloadAvailable()) {
/* 247 */         this.matchPayload.addAll(0, this.subSpans[i].getPayload());
/*     */       }
/*     */       
/* 250 */       int prevStart = prevSpans.start();
/* 251 */       int prevEnd = prevSpans.end();
/*     */       while (true) {
/* 253 */         if (!prevSpans.next()) {
/* 254 */           this.inSameDoc = false;
/* 255 */           this.more = false; break;
/*     */         } 
/* 257 */         if (this.matchDoc != prevSpans.doc()) {
/* 258 */           this.inSameDoc = false;
/*     */           break;
/*     */         } 
/* 261 */         int ppStart = prevSpans.start();
/* 262 */         int ppEnd = prevSpans.end();
/* 263 */         if (!docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {
/*     */           break;
/*     */         }
/* 266 */         prevStart = ppStart;
/* 267 */         prevEnd = ppEnd;
/*     */       } 
/*     */ 
/*     */       
/* 271 */       assert prevStart <= this.matchStart;
/* 272 */       if (this.matchStart > prevEnd) {
/* 273 */         matchSlop += this.matchStart - prevEnd;
/*     */       }
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 279 */       this.matchStart = prevStart;
/* 280 */       lastStart = prevStart;
/* 281 */       lastEnd = prevEnd;
/*     */     } 
/* 283 */     return (matchSlop <= this.allowedSlop);
/*     */   }
/*     */ 
/*     */   
/* 287 */   public String toString() { return getClass().getName() + ""("" + this.query.toString() + "")@"" + (this.firstTime ? ""START"" : (this.more ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\NearSpansOrdered.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.NearSpansUnordered,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashSet;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class NearSpansUnordered
/*     */   implements PayloadSpans
/*     */ {
/*     */   private SpanNearQuery query;
/*  33 */   private List ordered = new ArrayList();
/*     */   
/*     */   private int slop;
/*     */   private SpansCell first;
/*     */   private SpansCell last;
/*     */   private int totalLength;
/*     */   private CellQueue queue;
/*     */   private SpansCell max;
/*     */   private boolean more = true;
/*     */   private boolean firstTime = true;
/*     */   
/*     */   private class CellQueue
/*     */     extends PriorityQueue
/*     */   {
/*     */     private final NearSpansUnordered this$0;
/*     */     
/*  49 */     public CellQueue(int size) { initialize(size); }
/*     */ 
/*     */     
/*     */     protected final boolean lessThan(Object o1, Object o2) {
/*  53 */       NearSpansUnordered.SpansCell spans1 = (NearSpansUnordered.SpansCell)o1;
/*  54 */       NearSpansUnordered.SpansCell spans2 = (NearSpansUnordered.SpansCell)o2;
/*  55 */       if (spans1.doc() == spans2.doc()) {
/*  56 */         return NearSpansOrdered.docSpansOrdered(spans1, spans2);
/*     */       }
/*  58 */       return (spans1.doc() < spans2.doc());
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private class SpansCell
/*     */     implements PayloadSpans
/*     */   {
/*     */     private PayloadSpans spans;
/*     */     private SpansCell next;
/*  68 */     private int length = -1;
/*     */     private int index;
/*     */     
/*     */     public SpansCell(PayloadSpans spans, int index) {
/*  72 */       this.spans = spans;
/*  73 */       this.index = index;
/*     */     }
/*     */     private final NearSpansUnordered this$0;
/*     */     
/*  77 */     public boolean next() throws IOException { return adjust(this.spans.next()); }
/*     */ 
/*     */ 
/*     */     
/*  81 */     public boolean skipTo(int target) throws IOException { return adjust(this.spans.skipTo(target)); }
/*     */ 
/*     */     
/*     */     private boolean adjust(boolean condition) {
/*  85 */       if (this.length != -1) {
/*  86 */         NearSpansUnordered.this.totalLength -= this.length;
/*     */       }
/*  88 */       if (condition) {
/*  89 */         this.length = end() - start();
/*  90 */         NearSpansUnordered.this.totalLength += this.length;
/*     */         
/*  92 */         if (NearSpansUnordered.this.max == null || doc() > NearSpansUnordered.this.max.doc() || (doc() == NearSpansUnordered.this.max.doc() && end() > NearSpansUnordered.this.max.end()))
/*     */         {
/*  94 */           NearSpansUnordered.this.max = this;
/*     */         }
/*     */       } 
/*  97 */       NearSpansUnordered.this.more = condition;
/*  98 */       return condition;
/*     */     }
/*     */     
/* 101 */     public int doc() { return this.spans.doc(); }
/* 102 */     public int start() { return this.spans.start(); }
/* 103 */     public int end() { return this.spans.end(); }
/*     */ 
/*     */     
/* 106 */     public Collection getPayload() throws IOException { return new ArrayList(this.spans.getPayload()); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 111 */     public boolean isPayloadAvailable() { return this.spans.isPayloadAvailable(); }
/*     */ 
/*     */     
/* 114 */     public String toString() { return this.spans.toString() + ""#"" + this.index; }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public NearSpansUnordered(SpanNearQuery query, IndexReader reader) throws IOException {
/* 120 */     this.query = query;
/* 121 */     this.slop = query.getSlop();
/*     */     
/* 123 */     SpanQuery[] clauses = query.getClauses();
/* 124 */     this.queue = new CellQueue(clauses.length);
/* 125 */     for (int i = 0; i < clauses.length; i++) {
/* 126 */       SpansCell cell = new SpansCell(clauses[i].getPayloadSpans(reader), i);
/*     */       
/* 128 */       this.ordered.add(cell);
/*     */     } 
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/* 133 */     if (this.firstTime) {
/* 134 */       initList(true);
/* 135 */       listToQueue();
/* 136 */       this.firstTime = false;
/* 137 */     } else if (this.more) {
/* 138 */       if (min().next()) {
/* 139 */         this.queue.adjustTop();
/*     */       } else {
/* 141 */         this.more = false;
/*     */       } 
/*     */     } 
/*     */     
/* 145 */     while (this.more) {
/*     */       
/* 147 */       boolean queueStale = false;
/*     */       
/* 149 */       if (min().doc() != this.max.doc()) {
/* 150 */         queueToList();
/* 151 */         queueStale = true;
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 156 */       while (this.more && this.first.doc() < this.last.doc()) {
/* 157 */         this.more = this.first.skipTo(this.last.doc());
/* 158 */         firstToLast();
/* 159 */         queueStale = true;
/*     */       } 
/*     */       
/* 162 */       if (!this.more) return false;
/*     */ 
/*     */ 
/*     */       
/* 166 */       if (queueStale) {
/* 167 */         listToQueue();
/* 168 */         queueStale = false;
/*     */       } 
/*     */       
/* 171 */       if (atMatch()) {
/* 172 */         return true;
/*     */       }
/*     */       
/* 175 */       this.more = min().next();
/* 176 */       if (this.more) {
/* 177 */         this.queue.adjustTop();
/*     */       }
/*     */     } 
/* 180 */     return false;
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 184 */     if (this.firstTime) {
/* 185 */       initList(false);
/* 186 */       for (SpansCell cell = this.first; this.more && cell != null; cell = cell.next) {
/* 187 */         this.more = cell.skipTo(target);
/*     */       }
/* 189 */       if (this.more) {
/* 190 */         listToQueue();
/*     */       }
/* 192 */       this.firstTime = false;
/*     */     } else {
/* 194 */       while (this.more && min().doc() < target) {
/* 195 */         if (min().skipTo(target)) {
/* 196 */           this.queue.adjustTop(); continue;
/*     */         } 
/* 198 */         this.more = false;
/*     */       } 
/*     */     } 
/*     */     
/* 202 */     return (this.more && (atMatch() || next()));
/*     */   }
/*     */   
/* 205 */   private SpansCell min() { return (SpansCell)this.queue.top(); }
/*     */   
/* 207 */   public int doc() { return min().doc(); }
/* 208 */   public int start() { return min().start(); }
/* 209 */   public int end() { return this.max.end(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getPayload() throws IOException {
/* 218 */     Set matchPayload = new HashSet();
/* 219 */     for (SpansCell cell = this.first; cell != null; cell = cell.next) {
/* 220 */       if (cell.isPayloadAvailable()) {
/* 221 */         matchPayload.addAll(cell.getPayload());
/*     */       }
/*     */     } 
/* 224 */     return matchPayload;
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean isPayloadAvailable() {
/* 229 */     SpansCell pointer = min();
/* 230 */     while (pointer != null) {
/* 231 */       if (pointer.isPayloadAvailable()) {
/* 232 */         return true;
/*     */       }
/* 234 */       pointer = pointer.next;
/*     */     } 
/*     */     
/* 237 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 241 */   public String toString() { return getClass().getName() + ""("" + this.query.toString() + "")@"" + (this.firstTime ? ""START"" : (this.more ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void initList(boolean next) throws IOException {
/* 246 */     for (int i = 0; this.more && i < this.ordered.size(); i++) {
/* 247 */       SpansCell cell = this.ordered.get(i);
/* 248 */       if (next)
/* 249 */         this.more = cell.next(); 
/* 250 */       if (this.more) {
/* 251 */         addToList(cell);
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   private void addToList(SpansCell cell) throws IOException {
/* 257 */     if (this.last != null) {
/* 258 */       this.last.next = cell;
/*     */     } else {
/* 260 */       this.first = cell;
/* 261 */     }  this.last = cell;
/* 262 */     cell.next = null;
/*     */   }
/*     */   
/*     */   private void firstToLast() {
/* 266 */     this.last.next = this.first;
/* 267 */     this.last = this.first;
/* 268 */     this.first = this.first.next;
/* 269 */     this.last.next = null;
/*     */   }
/*     */   
/*     */   private void queueToList() throws IOException {
/* 273 */     this.last = this.first = null;
/* 274 */     while (this.queue.top() != null) {
/* 275 */       addToList((SpansCell)this.queue.pop());
/*     */     }
/*     */   }
/*     */   
/*     */   private void listToQueue() {
/* 280 */     this.queue.clear();
/* 281 */     for (SpansCell cell = this.first; cell != null; cell = cell.next) {
/* 282 */       this.queue.put(cell);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 287 */   private boolean atMatch() { return (min().doc() == this.max.doc() && this.max.end() - min().start() - this.totalLength <= this.slop); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\NearSpansUnordered.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.PayloadSpans,"package org.apache.lucene.search.spans;
import java.io.IOException;
import java.util.Collection;
public interface PayloadSpans extends Spans {
  Collection getPayload() throws IOException;
  boolean isPayloadAvailable();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\PayloadSpans.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanFirstQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanFirstQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private SpanQuery match;
/*     */   private int end;
/*     */   
/*     */   public SpanFirstQuery(SpanQuery match, int end) {
/*  38 */     this.match = match;
/*  39 */     this.end = end;
/*     */   }
/*     */ 
/*     */   
/*  43 */   public SpanQuery getMatch() { return this.match; }
/*     */ 
/*     */   
/*  46 */   public int getEnd() { return this.end; }
/*     */   
/*  48 */   public String getField() { return this.match.getField(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  54 */   public Collection getTerms() { return this.match.getTerms(); }
/*     */   
/*     */   public String toString(String field) {
/*  57 */     StringBuffer buffer = new StringBuffer();
/*  58 */     buffer.append(""spanFirst("");
/*  59 */     buffer.append(this.match.toString(field));
/*  60 */     buffer.append("", "");
/*  61 */     buffer.append(this.end);
/*  62 */     buffer.append("")"");
/*  63 */     buffer.append(ToStringUtils.boost(getBoost()));
/*  64 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*  68 */   public void extractTerms(Set terms) { this.match.extractTerms(terms); }
/*     */ 
/*     */ 
/*     */   
/*  72 */   public PayloadSpans getPayloadSpans(IndexReader reader) throws IOException { return (PayloadSpans)getSpans(reader); }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/*  76 */     return new PayloadSpans() {
/*  77 */         private PayloadSpans spans = SpanFirstQuery.this.match.getPayloadSpans(reader); private final IndexReader val$reader;
/*     */         
/*     */         public boolean next() throws IOException {
/*  80 */           while (this.spans.next()) {
/*  81 */             if (end() <= SpanFirstQuery.this.end)
/*  82 */               return true; 
/*     */           } 
/*  84 */           return false;
/*     */         }
/*     */         private final SpanFirstQuery this$0;
/*     */         public boolean skipTo(int target) throws IOException {
/*  88 */           if (!this.spans.skipTo(target)) {
/*  89 */             return false;
/*     */           }
/*  91 */           return (this.spans.end() <= SpanFirstQuery.this.end || next());
/*     */         }
/*     */ 
/*     */         
/*  95 */         public int doc() { return this.spans.doc(); }
/*  96 */         public int start() { return this.spans.start(); }
/*  97 */         public int end() { return this.spans.end(); }
/*     */ 
/*     */         
/*     */         public Collection getPayload() throws IOException {
/* 101 */           ArrayList result = null;
/* 102 */           if (this.spans.isPayloadAvailable()) {
/* 103 */             result = new ArrayList(this.spans.getPayload());
/*     */           }
/* 105 */           return result;
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 110 */         public boolean isPayloadAvailable() { return this.spans.isPayloadAvailable(); }
/*     */ 
/*     */ 
/*     */         
/* 114 */         public String toString() { return ""spans("" + SpanFirstQuery.this.toString() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 121 */     SpanFirstQuery clone = null;
/*     */     
/* 123 */     SpanQuery rewritten = (SpanQuery)this.match.rewrite(reader);
/* 124 */     if (rewritten != this.match) {
/* 125 */       clone = (SpanFirstQuery)clone();
/* 126 */       clone.match = rewritten;
/*     */     } 
/*     */     
/* 129 */     if (clone != null) {
/* 130 */       return clone;
/*     */     }
/* 132 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 137 */     if (this == o) return true; 
/* 138 */     if (!(o instanceof SpanFirstQuery)) return false;
/*     */     
/* 140 */     SpanFirstQuery other = (SpanFirstQuery)o;
/* 141 */     return (this.end == other.end && this.match.equals(other.match) && getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 147 */     int h = this.match.hashCode();
/* 148 */     h ^= h << 8 | h >>> 25;
/* 149 */     h ^= Float.floatToRawIntBits(getBoost()) ^ this.end;
/* 150 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanFirstQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanNearQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanNearQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private List clauses;
/*     */   private int slop;
/*     */   private boolean inOrder;
/*     */   private String field;
/*     */   
/*     */   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder) {
/*  50 */     this.clauses = new ArrayList(clauses.length);
/*  51 */     for (int i = 0; i < clauses.length; i++) {
/*  52 */       SpanQuery clause = clauses[i];
/*  53 */       if (i == 0) {
/*  54 */         this.field = clause.getField();
/*  55 */       } else if (!clause.getField().equals(this.field)) {
/*  56 */         throw new IllegalArgumentException(""Clauses must have same field."");
/*     */       } 
/*  58 */       this.clauses.add(clause);
/*     */     } 
/*     */     
/*  61 */     this.slop = slop;
/*  62 */     this.inOrder = inOrder;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  67 */   public SpanQuery[] getClauses() { return (SpanQuery[])this.clauses.toArray((Object[])new SpanQuery[this.clauses.size()]); }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */   
/*  74 */   public boolean isInOrder() { return this.inOrder; }
/*     */   
/*  76 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getTerms() {
/*  83 */     Collection terms = new ArrayList();
/*  84 */     Iterator i = this.clauses.iterator();
/*  85 */     while (i.hasNext()) {
/*  86 */       SpanQuery clause = i.next();
/*  87 */       terms.addAll(clause.getTerms());
/*     */     } 
/*  89 */     return terms;
/*     */   }
/*     */   
/*     */   public void extractTerms(Set terms) {
/*  93 */     Iterator i = this.clauses.iterator();
/*  94 */     while (i.hasNext()) {
/*  95 */       SpanQuery clause = i.next();
/*  96 */       clause.extractTerms(terms);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 102 */     StringBuffer buffer = new StringBuffer();
/* 103 */     buffer.append(""spanNear(["");
/* 104 */     Iterator i = this.clauses.iterator();
/* 105 */     while (i.hasNext()) {
/* 106 */       SpanQuery clause = i.next();
/* 107 */       buffer.append(clause.toString(field));
/* 108 */       if (i.hasNext()) {
/* 109 */         buffer.append("", "");
/*     */       }
/*     */     } 
/* 112 */     buffer.append(""], "");
/* 113 */     buffer.append(this.slop);
/* 114 */     buffer.append("", "");
/* 115 */     buffer.append(this.inOrder);
/* 116 */     buffer.append("")"");
/* 117 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 118 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public Spans getSpans(IndexReader reader) throws IOException {
/* 122 */     if (this.clauses.size() == 0) {
/* 123 */       return (new SpanOrQuery(getClauses())).getPayloadSpans(reader);
/*     */     }
/* 125 */     if (this.clauses.size() == 1) {
/* 126 */       return ((SpanQuery)this.clauses.get(0)).getPayloadSpans(reader);
/*     */     }
/* 128 */     return this.inOrder ? new NearSpansOrdered(this, reader) : new NearSpansUnordered(this, reader);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 134 */   public PayloadSpans getPayloadSpans(IndexReader reader) throws IOException { return (PayloadSpans)getSpans(reader); }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 138 */     SpanNearQuery clone = null;
/* 139 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 140 */       SpanQuery c = this.clauses.get(i);
/* 141 */       SpanQuery query = (SpanQuery)c.rewrite(reader);
/* 142 */       if (query != c) {
/* 143 */         if (clone == null)
/* 144 */           clone = (SpanNearQuery)clone(); 
/* 145 */         clone.clauses.set(i, query);
/*     */       } 
/*     */     } 
/* 148 */     if (clone != null) {
/* 149 */       return clone;
/*     */     }
/* 151 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 157 */     if (this == o) return true; 
/* 158 */     if (!(o instanceof SpanNearQuery)) return false;
/*     */     
/* 160 */     SpanNearQuery spanNearQuery = (SpanNearQuery)o;
/*     */     
/* 162 */     if (this.inOrder != spanNearQuery.inOrder) return false; 
/* 163 */     if (this.slop != spanNearQuery.slop) return false; 
/* 164 */     if (!this.clauses.equals(spanNearQuery.clauses)) return false;
/*     */     
/* 166 */     return (getBoost() == spanNearQuery.getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 171 */     int result = this.clauses.hashCode();
/*     */ 
/*     */ 
/*     */     
/* 175 */     result ^= result << 14 | result >>> 19;
/* 176 */     result += Float.floatToRawIntBits(getBoost());
/* 177 */     result += this.slop;
/* 178 */     result ^= this.inOrder ? -1716530243 : 0;
/* 179 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanNearQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanNotQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanNotQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private SpanQuery include;
/*     */   private SpanQuery exclude;
/*     */   
/*     */   public SpanNotQuery(SpanQuery include, SpanQuery exclude) {
/*  37 */     this.include = include;
/*  38 */     this.exclude = exclude;
/*     */     
/*  40 */     if (!include.getField().equals(exclude.getField())) {
/*  41 */       throw new IllegalArgumentException(""Clauses must have same field."");
/*     */     }
/*     */   }
/*     */   
/*  45 */   public SpanQuery getInclude() { return this.include; }
/*     */ 
/*     */   
/*  48 */   public SpanQuery getExclude() { return this.exclude; }
/*     */   
/*  50 */   public String getField() { return this.include.getField(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   public Collection getTerms() { return this.include.getTerms(); }
/*     */   
/*  58 */   public void extractTerms(Set terms) { this.include.extractTerms(terms); }
/*     */   
/*     */   public String toString(String field) {
/*  61 */     StringBuffer buffer = new StringBuffer();
/*  62 */     buffer.append(""spanNot("");
/*  63 */     buffer.append(this.include.toString(field));
/*  64 */     buffer.append("", "");
/*  65 */     buffer.append(this.exclude.toString(field));
/*  66 */     buffer.append("")"");
/*  67 */     buffer.append(ToStringUtils.boost(getBoost()));
/*  68 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/*  73 */     return new PayloadSpans() {
/*  74 */         private PayloadSpans includeSpans = SpanNotQuery.this.include.getPayloadSpans(reader);
/*     */         
/*     */         private boolean moreInclude = true;
/*  77 */         private Spans excludeSpans = SpanNotQuery.this.exclude.getSpans(reader);
/*  78 */         private boolean moreExclude = this.excludeSpans.next(); private final IndexReader val$reader;
/*     */         
/*     */         public boolean next() throws IOException {
/*  81 */           if (this.moreInclude) {
/*  82 */             this.moreInclude = this.includeSpans.next();
/*     */           }
/*  84 */           while (this.moreInclude && this.moreExclude) {
/*     */             
/*  86 */             if (this.includeSpans.doc() > this.excludeSpans.doc()) {
/*  87 */               this.moreExclude = this.excludeSpans.skipTo(this.includeSpans.doc());
/*     */             }
/*     */ 
/*     */             
/*  91 */             while (this.moreExclude && this.includeSpans.doc() == this.excludeSpans.doc() && this.excludeSpans.end() <= this.includeSpans.start()) {
/*  92 */               this.moreExclude = this.excludeSpans.next();
/*     */             }
/*     */             
/*  95 */             if (!this.moreExclude || this.includeSpans.doc() != this.excludeSpans.doc() || this.includeSpans.end() <= this.excludeSpans.start()) {
/*     */               break;
/*     */             }
/*     */ 
/*     */             
/* 100 */             this.moreInclude = this.includeSpans.next();
/*     */           } 
/* 102 */           return this.moreInclude;
/*     */         }
/*     */         private final SpanNotQuery this$0;
/*     */         public boolean skipTo(int target) throws IOException {
/* 106 */           if (this.moreInclude) {
/* 107 */             this.moreInclude = this.includeSpans.skipTo(target);
/*     */           }
/* 109 */           if (!this.moreInclude) {
/* 110 */             return false;
/*     */           }
/* 112 */           if (this.moreExclude && this.includeSpans.doc() > this.excludeSpans.doc())
/*     */           {
/* 114 */             this.moreExclude = this.excludeSpans.skipTo(this.includeSpans.doc());
/*     */           }
/*     */ 
/*     */           
/* 118 */           while (this.moreExclude && this.includeSpans.doc() == this.excludeSpans.doc() && this.excludeSpans.end() <= this.includeSpans.start()) {
/* 119 */             this.moreExclude = this.excludeSpans.next();
/*     */           }
/*     */           
/* 122 */           if (!this.moreExclude || this.includeSpans.doc() != this.excludeSpans.doc() || this.includeSpans.end() <= this.excludeSpans.start())
/*     */           {
/*     */             
/* 125 */             return true;
/*     */           }
/* 127 */           return next();
/*     */         }
/*     */         
/* 130 */         public int doc() { return this.includeSpans.doc(); }
/* 131 */         public int start() { return this.includeSpans.start(); }
/* 132 */         public int end() { return this.includeSpans.end(); }
/*     */ 
/*     */         
/*     */         public Collection getPayload() throws IOException {
/* 136 */           ArrayList result = null;
/* 137 */           if (this.includeSpans.isPayloadAvailable()) {
/* 138 */             result = new ArrayList(this.includeSpans.getPayload());
/*     */           }
/* 140 */           return result;
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 145 */         public boolean isPayloadAvailable() { return this.includeSpans.isPayloadAvailable(); }
/*     */ 
/*     */ 
/*     */         
/* 149 */         public String toString() { return ""spans("" + SpanNotQuery.this.toString() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 156 */   public PayloadSpans getPayloadSpans(IndexReader reader) throws IOException { return (PayloadSpans)getSpans(reader); }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 160 */     SpanNotQuery clone = null;
/*     */     
/* 162 */     SpanQuery rewrittenInclude = (SpanQuery)this.include.rewrite(reader);
/* 163 */     if (rewrittenInclude != this.include) {
/* 164 */       clone = (SpanNotQuery)clone();
/* 165 */       clone.include = rewrittenInclude;
/*     */     } 
/* 167 */     SpanQuery rewrittenExclude = (SpanQuery)this.exclude.rewrite(reader);
/* 168 */     if (rewrittenExclude != this.exclude) {
/* 169 */       if (clone == null) clone = (SpanNotQuery)clone(); 
/* 170 */       clone.exclude = rewrittenExclude;
/*     */     } 
/*     */     
/* 173 */     if (clone != null) {
/* 174 */       return clone;
/*     */     }
/* 176 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 182 */     if (this == o) return true; 
/* 183 */     if (!(o instanceof SpanNotQuery)) return false;
/*     */     
/* 185 */     SpanNotQuery other = (SpanNotQuery)o;
/* 186 */     return (this.include.equals(other.include) && this.exclude.equals(other.exclude) && getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 192 */     int h = this.include.hashCode();
/* 193 */     h = h << 1 | h >>> 31;
/* 194 */     h ^= this.exclude.hashCode();
/* 195 */     h = h << 1 | h >>> 31;
/* 196 */     h ^= Float.floatToRawIntBits(getBoost());
/* 197 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanNotQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanOrQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanOrQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private List clauses;
/*     */   private String field;
/*     */   
/*     */   public SpanOrQuery(SpanQuery[] clauses) {
/*  42 */     this.clauses = new ArrayList(clauses.length);
/*  43 */     for (int i = 0; i < clauses.length; i++) {
/*  44 */       SpanQuery clause = clauses[i];
/*  45 */       if (i == 0) {
/*  46 */         this.field = clause.getField();
/*  47 */       } else if (!clause.getField().equals(this.field)) {
/*  48 */         throw new IllegalArgumentException(""Clauses must have same field."");
/*     */       } 
/*  50 */       this.clauses.add(clause);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  56 */   public SpanQuery[] getClauses() { return (SpanQuery[])this.clauses.toArray((Object[])new SpanQuery[this.clauses.size()]); }
/*     */ 
/*     */   
/*  59 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getTerms() {
/*  66 */     Collection terms = new ArrayList();
/*  67 */     Iterator i = this.clauses.iterator();
/*  68 */     while (i.hasNext()) {
/*  69 */       SpanQuery clause = i.next();
/*  70 */       terms.addAll(clause.getTerms());
/*     */     } 
/*  72 */     return terms;
/*     */   }
/*     */   
/*     */   public void extractTerms(Set terms) {
/*  76 */     Iterator i = this.clauses.iterator();
/*  77 */     while (i.hasNext()) {
/*  78 */       SpanQuery clause = i.next();
/*  79 */       clause.extractTerms(terms);
/*     */     } 
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  84 */     SpanOrQuery clone = null;
/*  85 */     for (int i = 0; i < this.clauses.size(); i++) {
/*  86 */       SpanQuery c = this.clauses.get(i);
/*  87 */       SpanQuery query = (SpanQuery)c.rewrite(reader);
/*  88 */       if (query != c) {
/*  89 */         if (clone == null)
/*  90 */           clone = (SpanOrQuery)clone(); 
/*  91 */         clone.clauses.set(i, query);
/*     */       } 
/*     */     } 
/*  94 */     if (clone != null) {
/*  95 */       return clone;
/*     */     }
/*  97 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 102 */     StringBuffer buffer = new StringBuffer();
/* 103 */     buffer.append(""spanOr(["");
/* 104 */     Iterator i = this.clauses.iterator();
/* 105 */     while (i.hasNext()) {
/* 106 */       SpanQuery clause = i.next();
/* 107 */       buffer.append(clause.toString(field));
/* 108 */       if (i.hasNext()) {
/* 109 */         buffer.append("", "");
/*     */       }
/*     */     } 
/* 112 */     buffer.append(""])"");
/* 113 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 114 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public boolean equals(Object o) {
/* 118 */     if (this == o) return true; 
/* 119 */     if (o == null || getClass() != o.getClass()) return false;
/*     */     
/* 121 */     SpanOrQuery that = (SpanOrQuery)o;
/*     */     
/* 123 */     if (!this.clauses.equals(that.clauses)) return false; 
/* 124 */     if (!this.field.equals(that.field)) return false;
/*     */     
/* 126 */     return (getBoost() == that.getBoost());
/*     */   }
/*     */   
/*     */   public int hashCode() {
/* 130 */     int h = this.clauses.hashCode();
/* 131 */     h ^= h << 10 | h >>> 23;
/* 132 */     h ^= Float.floatToRawIntBits(getBoost());
/* 133 */     return h;
/*     */   }
/*     */   
/*     */   private class SpanQueue extends PriorityQueue {
/*     */     private final SpanOrQuery this$0;
/*     */     
/* 139 */     public SpanQueue(int size) { initialize(size); }
/*     */ 
/*     */     
/*     */     protected final boolean lessThan(Object o1, Object o2) {
/* 143 */       Spans spans1 = (Spans)o1;
/* 144 */       Spans spans2 = (Spans)o2;
/* 145 */       if (spans1.doc() == spans2.doc()) {
/* 146 */         if (spans1.start() == spans2.start()) {
/* 147 */           return (spans1.end() < spans2.end());
/*     */         }
/* 149 */         return (spans1.start() < spans2.start());
/*     */       } 
/*     */       
/* 152 */       return (spans1.doc() < spans2.doc());
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 158 */   public PayloadSpans getPayloadSpans(IndexReader reader) throws IOException { return (PayloadSpans)getSpans(reader); }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/* 162 */     if (this.clauses.size() == 1) {
/* 163 */       return ((SpanQuery)this.clauses.get(0)).getPayloadSpans(reader);
/*     */     }
/* 165 */     return new PayloadSpans() {
/* 166 */         private SpanOrQuery.SpanQueue queue = null; private final IndexReader val$reader;
/*     */         
/*     */         private boolean initSpanQueue(int target) throws IOException {
/* 169 */           this.queue = new SpanOrQuery.SpanQueue(SpanOrQuery.this.clauses.size());
/* 170 */           Iterator i = SpanOrQuery.this.clauses.iterator();
/* 171 */           while (i.hasNext()) {
/* 172 */             PayloadSpans spans = ((SpanQuery)i.next()).getPayloadSpans(reader);
/* 173 */             if ((target == -1 && spans.next()) || (target != -1 && spans.skipTo(target)))
/*     */             {
/* 175 */               this.queue.put(spans);
/*     */             }
/*     */           } 
/* 178 */           return (this.queue.size() != 0);
/*     */         }
/*     */         private final SpanOrQuery this$0;
/*     */         public boolean next() throws IOException {
/* 182 */           if (this.queue == null) {
/* 183 */             return initSpanQueue(-1);
/*     */           }
/*     */           
/* 186 */           if (this.queue.size() == 0) {
/* 187 */             return false;
/*     */           }
/*     */           
/* 190 */           if (top().next()) {
/* 191 */             this.queue.adjustTop();
/* 192 */             return true;
/*     */           } 
/*     */           
/* 195 */           this.queue.pop();
/* 196 */           return (this.queue.size() != 0);
/*     */         }
/*     */         
/* 199 */         private PayloadSpans top() { return (PayloadSpans)this.queue.top(); }
/*     */         
/*     */         public boolean skipTo(int target) throws IOException {
/* 202 */           if (this.queue == null) {
/* 203 */             return initSpanQueue(target);
/*     */           }
/*     */           
/* 206 */           while (this.queue.size() != 0 && top().doc() < target) {
/* 207 */             if (top().skipTo(target)) {
/* 208 */               this.queue.adjustTop(); continue;
/*     */             } 
/* 210 */             this.queue.pop();
/*     */           } 
/*     */ 
/*     */           
/* 214 */           return (this.queue.size() != 0);
/*     */         }
/*     */         
/* 217 */         public int doc() { return top().doc(); }
/* 218 */         public int start() { return top().start(); }
/* 219 */         public int end() { return top().end(); }
/*     */ 
/*     */         
/*     */         public Collection getPayload() throws IOException {
/* 223 */           ArrayList result = null;
/* 224 */           PayloadSpans theTop = top();
/* 225 */           if (theTop != null && theTop.isPayloadAvailable()) {
/* 226 */             result = new ArrayList(theTop.getPayload());
/*     */           }
/* 228 */           return result;
/*     */         }
/*     */ 
/*     */         
/*     */         public boolean isPayloadAvailable() {
/* 233 */           PayloadSpans top = top();
/* 234 */           return (top != null && top.isPayloadAvailable());
/*     */         }
/*     */ 
/*     */         
/* 238 */         public String toString() { return ""spans("" + SpanOrQuery.this + "")@"" + ((this.queue == null) ? ""START"" : ((this.queue.size() > 0) ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanOrQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanQuery,"/*    */ package org.apache.lucene.search.spans;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Collection;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.Query;
/*    */ import org.apache.lucene.search.Searcher;
/*    */ import org.apache.lucene.search.Weight;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class SpanQuery
/*    */   extends Query
/*    */ {
/*    */   public abstract Spans getSpans(IndexReader paramIndexReader) throws IOException;
/*    */   
/* 48 */   public PayloadSpans getPayloadSpans(IndexReader reader) throws IOException { return null; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public abstract String getField();
/*    */ 
/*    */ 
/*    */   
/*    */   public abstract Collection getTerms();
/*    */ 
/*    */ 
/*    */   
/* 61 */   protected Weight createWeight(Searcher searcher) throws IOException { return new SpanWeight(this, searcher); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.Spans,"package org.apache.lucene.search.spans;
import java.io.IOException;
public interface Spans {
  boolean next() throws IOException;
  boolean skipTo(int paramInt) throws IOException;
  int doc();
  int start();
  int end();
}
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\Spans.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanScorer,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanScorer
/*     */   extends Scorer
/*     */ {
/*     */   protected Spans spans;
/*     */   protected Weight weight;
/*     */   protected byte[] norms;
/*     */   protected float value;
/*     */   protected boolean firstTime = true;
/*     */   protected boolean more = true;
/*     */   protected int doc;
/*     */   protected float freq;
/*     */   
/*     */   protected SpanScorer(Spans spans, Weight weight, Similarity similarity, byte[] norms) throws IOException {
/*  44 */     super(similarity);
/*  45 */     this.spans = spans;
/*  46 */     this.norms = norms;
/*  47 */     this.weight = weight;
/*  48 */     this.value = weight.getValue();
/*  49 */     this.doc = -1;
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/*  53 */     if (this.firstTime) {
/*  54 */       this.more = this.spans.next();
/*  55 */       this.firstTime = false;
/*     */     } 
/*  57 */     return setFreqCurrentDoc();
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  61 */     if (this.firstTime) {
/*  62 */       this.more = this.spans.skipTo(target);
/*  63 */       this.firstTime = false;
/*     */     } 
/*  65 */     if (!this.more) {
/*  66 */       return false;
/*     */     }
/*  68 */     if (this.spans.doc() < target) {
/*  69 */       this.more = this.spans.skipTo(target);
/*     */     }
/*  71 */     return setFreqCurrentDoc();
/*     */   }
/*     */   
/*     */   protected boolean setFreqCurrentDoc() throws IOException {
/*  75 */     if (!this.more) {
/*  76 */       return false;
/*     */     }
/*  78 */     this.doc = this.spans.doc();
/*  79 */     this.freq = 0.0F;
/*     */     do {
/*  81 */       int matchLength = this.spans.end() - this.spans.start();
/*  82 */       this.freq += getSimilarity().sloppyFreq(matchLength);
/*  83 */       this.more = this.spans.next();
/*  84 */     } while (this.more && this.doc == this.spans.doc());
/*  85 */     return true;
/*     */   }
/*     */   
/*  88 */   public int doc() { return this.doc; }
/*     */   
/*     */   public float score() throws IOException {
/*  91 */     float raw = getSimilarity().tf(this.freq) * this.value;
/*  92 */     return raw * Similarity.decodeNorm(this.norms[this.doc]);
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/*  96 */     Explanation tfExplanation = new Explanation();
/*     */     
/*  98 */     skipTo(doc);
/*     */     
/* 100 */     float phraseFreq = (doc() == doc) ? this.freq : 0.0F;
/* 101 */     tfExplanation.setValue(getSimilarity().tf(phraseFreq));
/* 102 */     tfExplanation.setDescription(""tf(phraseFreq="" + phraseFreq + "")"");
/*     */     
/* 104 */     return tfExplanation;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanTermQuery,"/*    */ package org.apache.lucene.search.spans;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.ArrayList;
/*    */ import java.util.Collection;
/*    */ import java.util.Set;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SpanTermQuery
/*    */   extends SpanQuery
/*    */ {
/*    */   protected Term term;
/*    */   
/* 34 */   public SpanTermQuery(Term term) { this.term = term; }
/*    */ 
/*    */   
/* 37 */   public Term getTerm() { return this.term; }
/*    */   
/* 39 */   public String getField() { return this.term.field(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Collection getTerms() {
/* 46 */     Collection terms = new ArrayList();
/* 47 */     terms.add(this.term);
/* 48 */     return terms;
/*    */   }
/*    */   
/* 51 */   public void extractTerms(Set terms) { terms.add(this.term); }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 55 */     StringBuffer buffer = new StringBuffer();
/* 56 */     if (this.term.field().equals(field)) {
/* 57 */       buffer.append(this.term.text());
/*    */     } else {
/* 59 */       buffer.append(this.term.toString());
/* 60 */     }  buffer.append(ToStringUtils.boost(getBoost()));
/* 61 */     return buffer.toString();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 66 */     if (!(o instanceof SpanTermQuery))
/* 67 */       return false; 
/* 68 */     SpanTermQuery other = (SpanTermQuery)o;
/* 69 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 75 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.term.hashCode() ^ 0xD23FE494; }
/*    */ 
/*    */ 
/*    */   
/* 79 */   public Spans getSpans(IndexReader reader) throws IOException { return new TermSpans(reader.termPositions(this.term), this.term); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 84 */   public PayloadSpans getPayloadSpans(IndexReader reader) throws IOException { return (PayloadSpans)getSpans(reader); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanWeight,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.search.ComplexExplanation;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanWeight
/*     */   implements Weight
/*     */ {
/*     */   protected Similarity similarity;
/*     */   protected float value;
/*     */   protected float idf;
/*     */   protected float queryNorm;
/*     */   protected float queryWeight;
/*     */   protected Set terms;
/*     */   protected SpanQuery query;
/*     */   
/*     */   public SpanWeight(SpanQuery query, Searcher searcher) throws IOException {
/*  44 */     this.similarity = query.getSimilarity(searcher);
/*  45 */     this.query = query;
/*  46 */     this.terms = new HashSet();
/*  47 */     query.extractTerms(this.terms);
/*     */     
/*  49 */     this.idf = this.query.getSimilarity(searcher).idf(this.terms, searcher);
/*     */   }
/*     */   
/*  52 */   public Query getQuery() { return this.query; }
/*  53 */   public float getValue() { return this.value; }
/*     */   
/*     */   public float sumOfSquaredWeights() throws IOException {
/*  56 */     this.queryWeight = this.idf * this.query.getBoost();
/*  57 */     return this.queryWeight * this.queryWeight;
/*     */   }
/*     */   
/*     */   public void normalize(float queryNorm) {
/*  61 */     this.queryNorm = queryNorm;
/*  62 */     this.queryWeight *= queryNorm;
/*  63 */     this.value = this.queryWeight * this.idf;
/*     */   }
/*     */ 
/*     */   
/*  67 */   public Scorer scorer(IndexReader reader) throws IOException { return new SpanScorer(this.query.getSpans(reader), this, this.similarity, reader.norms(this.query.getField())); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  75 */     ComplexExplanation result = new ComplexExplanation();
/*  76 */     result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*  77 */     String field = ((SpanQuery)getQuery()).getField();
/*     */     
/*  79 */     StringBuffer docFreqs = new StringBuffer();
/*  80 */     Iterator i = this.terms.iterator();
/*  81 */     while (i.hasNext()) {
/*  82 */       Term term = i.next();
/*  83 */       docFreqs.append(term.text());
/*  84 */       docFreqs.append(""="");
/*  85 */       docFreqs.append(reader.docFreq(term));
/*     */       
/*  87 */       if (i.hasNext()) {
/*  88 */         docFreqs.append("" "");
/*     */       }
/*     */     } 
/*     */     
/*  92 */     Explanation idfExpl = new Explanation(this.idf, ""idf("" + field + "": "" + docFreqs + "")"");
/*     */ 
/*     */ 
/*     */     
/*  96 */     Explanation queryExpl = new Explanation();
/*  97 */     queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */     
/*  99 */     Explanation boostExpl = new Explanation(getQuery().getBoost(), ""boost"");
/* 100 */     if (getQuery().getBoost() != 1.0F)
/* 101 */       queryExpl.addDetail(boostExpl); 
/* 102 */     queryExpl.addDetail(idfExpl);
/*     */     
/* 104 */     Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 105 */     queryExpl.addDetail(queryNormExpl);
/*     */     
/* 107 */     queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */     
/* 111 */     result.addDetail(queryExpl);
/*     */ 
/*     */     
/* 114 */     ComplexExplanation fieldExpl = new ComplexExplanation();
/* 115 */     fieldExpl.setDescription(""fieldWeight("" + field + "":"" + this.query.toString(field) + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */     
/* 118 */     Explanation tfExpl = scorer(reader).explain(doc);
/* 119 */     fieldExpl.addDetail(tfExpl);
/* 120 */     fieldExpl.addDetail(idfExpl);
/*     */     
/* 122 */     Explanation fieldNormExpl = new Explanation();
/* 123 */     byte[] fieldNorms = reader.norms(field);
/* 124 */     float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */     
/* 126 */     fieldNormExpl.setValue(fieldNorm);
/* 127 */     fieldNormExpl.setDescription(""fieldNorm(field="" + field + "", doc="" + doc + "")"");
/* 128 */     fieldExpl.addDetail(fieldNormExpl);
/*     */     
/* 130 */     fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
/* 131 */     fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */     
/* 135 */     result.addDetail((Explanation)fieldExpl);
/* 136 */     result.setMatch(fieldExpl.getMatch());
/*     */ 
/*     */     
/* 139 */     result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */     
/* 141 */     if (queryExpl.getValue() == 1.0F) {
/* 142 */       return (Explanation)fieldExpl;
/*     */     }
/* 144 */     return (Explanation)result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\SpanWeight.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.TermSpans,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Collections;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TermSpans
/*     */   implements PayloadSpans
/*     */ {
/*     */   protected TermPositions positions;
/*     */   protected Term term;
/*     */   protected int doc;
/*     */   protected int freq;
/*     */   protected int count;
/*     */   protected int position;
/*     */   
/*     */   public TermSpans(TermPositions positions, Term term) throws IOException {
/*  41 */     this.positions = positions;
/*  42 */     this.term = term;
/*  43 */     this.doc = -1;
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/*  47 */     if (this.count == this.freq) {
/*  48 */       if (!this.positions.next()) {
/*  49 */         this.doc = Integer.MAX_VALUE;
/*  50 */         return false;
/*     */       } 
/*  52 */       this.doc = this.positions.doc();
/*  53 */       this.freq = this.positions.freq();
/*  54 */       this.count = 0;
/*     */     } 
/*  56 */     this.position = this.positions.nextPosition();
/*  57 */     this.count++;
/*  58 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  63 */     if (this.doc >= target) {
/*  64 */       return true;
/*     */     }
/*     */     
/*  67 */     if (!this.positions.skipTo(target)) {
/*  68 */       this.doc = Integer.MAX_VALUE;
/*  69 */       return false;
/*     */     } 
/*     */     
/*  72 */     this.doc = this.positions.doc();
/*  73 */     this.freq = this.positions.freq();
/*  74 */     this.count = 0;
/*     */     
/*  76 */     this.position = this.positions.nextPosition();
/*  77 */     this.count++;
/*     */     
/*  79 */     return true;
/*     */   }
/*     */ 
/*     */   
/*  83 */   public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */   
/*  87 */   public int start() { return this.position; }
/*     */ 
/*     */ 
/*     */   
/*  91 */   public int end() { return this.position + 1; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getPayload() throws IOException {
/*  96 */     byte[] bytes = new byte[this.positions.getPayloadLength()];
/*  97 */     bytes = this.positions.getPayload(bytes, 0);
/*  98 */     return Collections.singletonList(bytes);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 103 */   public boolean isPayloadAvailable() { return this.positions.isPayloadAvailable(); }
/*     */ 
/*     */ 
/*     */   
/* 107 */   public String toString() { return ""spans("" + this.term.toString() + "")@"" + ((this.doc == -1) ? ""START"" : ((this.doc == Integer.MAX_VALUE) ? ""END"" : (this.doc + ""-"" + this.position))); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 113 */   public TermPositions getPositions() { return this.positions; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\search\spans\TermSpans.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.AlreadyClosedException,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class AlreadyClosedException
/*    */   extends IllegalStateException
/*    */ {
/* 26 */   public AlreadyClosedException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\AlreadyClosedException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.BufferedIndexInput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class BufferedIndexInput
/*     */   extends IndexInput
/*     */ {
/*     */   public static final int BUFFER_SIZE = 1024;
/*  28 */   private int bufferSize = 1024;
/*     */   
/*     */   protected byte[] buffer;
/*     */   
/*  32 */   private long bufferStart = 0L;
/*  33 */   private int bufferLength = 0;
/*  34 */   private int bufferPosition = 0;
/*     */   
/*     */   public byte readByte() throws IOException {
/*  37 */     if (this.bufferPosition >= this.bufferLength)
/*  38 */       refill(); 
/*  39 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */ 
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public BufferedIndexInput(int bufferSize) {
/*  46 */     checkBufferSize(bufferSize);
/*  47 */     this.bufferSize = bufferSize;
/*     */   }
/*     */ 
/*     */   
/*     */   public void setBufferSize(int newSize) {
/*  52 */     assert this.buffer == null || this.bufferSize == this.buffer.length : ""buffer="" + this.buffer + "" bufferSize="" + this.bufferSize + "" buffer.length="" + ((this.buffer != null) ? this.buffer.length : false);
/*  53 */     if (newSize != this.bufferSize) {
/*  54 */       checkBufferSize(newSize);
/*  55 */       this.bufferSize = newSize;
/*  56 */       if (this.buffer != null) {
/*     */         int numToCopy;
/*     */ 
/*     */         
/*  60 */         byte[] newBuffer = new byte[newSize];
/*  61 */         int leftInBuffer = this.bufferLength - this.bufferPosition;
/*     */         
/*  63 */         if (leftInBuffer > newSize) {
/*  64 */           numToCopy = newSize;
/*     */         } else {
/*  66 */           numToCopy = leftInBuffer;
/*  67 */         }  System.arraycopy(this.buffer, this.bufferPosition, newBuffer, 0, numToCopy);
/*  68 */         this.bufferStart += this.bufferPosition;
/*  69 */         this.bufferPosition = 0;
/*  70 */         this.bufferLength = numToCopy;
/*  71 */         newBuffer(newBuffer);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  78 */   protected void newBuffer(byte[] newBuffer) { this.buffer = newBuffer; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  83 */   public int getBufferSize() { return this.bufferSize; }
/*     */ 
/*     */   
/*     */   private void checkBufferSize(int bufferSize) {
/*  87 */     if (bufferSize <= 0) {
/*  88 */       throw new IllegalArgumentException(""bufferSize must be greater than 0 (got "" + bufferSize + "")"");
/*     */     }
/*     */   }
/*     */   
/*  92 */   public void readBytes(byte[] b, int offset, int len) throws IOException { readBytes(b, offset, len, true); }
/*     */ 
/*     */ 
/*     */   
/*     */   public void readBytes(byte[] b, int offset, int len, boolean useBuffer) throws IOException {
/*  97 */     if (len <= this.bufferLength - this.bufferPosition) {
/*     */       
/*  99 */       if (len > 0)
/* 100 */         System.arraycopy(this.buffer, this.bufferPosition, b, offset, len); 
/* 101 */       this.bufferPosition += len;
/*     */     } else {
/*     */       
/* 104 */       int available = this.bufferLength - this.bufferPosition;
/* 105 */       if (available > 0) {
/* 106 */         System.arraycopy(this.buffer, this.bufferPosition, b, offset, available);
/* 107 */         offset += available;
/* 108 */         len -= available;
/* 109 */         this.bufferPosition += available;
/*     */       } 
/*     */       
/* 112 */       if (useBuffer && len < this.bufferSize) {
/*     */ 
/*     */ 
/*     */         
/* 116 */         refill();
/* 117 */         if (this.bufferLength < len) {
/*     */           
/* 119 */           System.arraycopy(this.buffer, 0, b, offset, this.bufferLength);
/* 120 */           throw new IOException(""read past EOF"");
/*     */         } 
/* 122 */         System.arraycopy(this.buffer, 0, b, offset, len);
/* 123 */         this.bufferPosition = len;
/*     */ 
/*     */ 
/*     */       
/*     */       }
/*     */       else {
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 133 */         long after = this.bufferStart + this.bufferPosition + len;
/* 134 */         if (after > length())
/* 135 */           throw new IOException(""read past EOF""); 
/* 136 */         readInternal(b, offset, len);
/* 137 */         this.bufferStart = after;
/* 138 */         this.bufferPosition = 0;
/* 139 */         this.bufferLength = 0;
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void refill() throws IOException {
/* 145 */     long start = this.bufferStart + this.bufferPosition;
/* 146 */     long end = start + this.bufferSize;
/* 147 */     if (end > length())
/* 148 */       end = length(); 
/* 149 */     int newLength = (int)(end - start);
/* 150 */     if (newLength <= 0) {
/* 151 */       throw new IOException(""read past EOF"");
/*     */     }
/* 153 */     if (this.buffer == null) {
/* 154 */       newBuffer(new byte[this.bufferSize]);
/* 155 */       seekInternal(this.bufferStart);
/*     */     } 
/* 157 */     readInternal(this.buffer, 0, newLength);
/* 158 */     this.bufferLength = newLength;
/* 159 */     this.bufferStart = start;
/* 160 */     this.bufferPosition = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 172 */   public long getFilePointer() { return this.bufferStart + this.bufferPosition; }
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 175 */     if (pos >= this.bufferStart && pos < this.bufferStart + this.bufferLength) {
/* 176 */       this.bufferPosition = (int)(pos - this.bufferStart);
/*     */     } else {
/* 178 */       this.bufferStart = pos;
/* 179 */       this.bufferPosition = 0;
/* 180 */       this.bufferLength = 0;
/* 181 */       seekInternal(pos);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 192 */     BufferedIndexInput clone = (BufferedIndexInput)super.clone();
/*     */     
/* 194 */     clone.buffer = null;
/* 195 */     clone.bufferLength = 0;
/* 196 */     clone.bufferPosition = 0;
/* 197 */     clone.bufferStart = getFilePointer();
/*     */     
/* 199 */     return clone;
/*     */   }
/*     */   
/*     */   public BufferedIndexInput() {}
/*     */   
/*     */   protected abstract void readInternal(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */   
/*     */   protected abstract void seekInternal(long paramLong) throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\BufferedIndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.BufferedIndexOutput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class BufferedIndexOutput
/*     */   extends IndexOutput
/*     */ {
/*     */   static final int BUFFER_SIZE = 16384;
/*  26 */   private final byte[] buffer = new byte[16384];
/*  27 */   private long bufferStart = 0L;
/*  28 */   private int bufferPosition = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeByte(byte b) throws IOException {
/*  34 */     if (this.bufferPosition >= 16384)
/*  35 */       flush(); 
/*  36 */     this.buffer[this.bufferPosition++] = b;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeBytes(byte[] b, int offset, int length) throws IOException {
/*  45 */     int bytesLeft = 16384 - this.bufferPosition;
/*     */     
/*  47 */     if (bytesLeft >= length) {
/*     */       
/*  49 */       System.arraycopy(b, offset, this.buffer, this.bufferPosition, length);
/*  50 */       this.bufferPosition += length;
/*     */       
/*  52 */       if (16384 - this.bufferPosition == 0) {
/*  53 */         flush();
/*     */       }
/*     */     }
/*  56 */     else if (length > 16384) {
/*     */       
/*  58 */       if (this.bufferPosition > 0) {
/*  59 */         flush();
/*     */       }
/*  61 */       flushBuffer(b, offset, length);
/*  62 */       this.bufferStart += length;
/*     */     } else {
/*     */       
/*  65 */       int pos = 0;
/*     */       
/*  67 */       while (pos < length) {
/*  68 */         int pieceLength = (length - pos < bytesLeft) ? (length - pos) : bytesLeft;
/*  69 */         System.arraycopy(b, pos + offset, this.buffer, this.bufferPosition, pieceLength);
/*  70 */         pos += pieceLength;
/*  71 */         this.bufferPosition += pieceLength;
/*     */         
/*  73 */         bytesLeft = 16384 - this.bufferPosition;
/*  74 */         if (bytesLeft == 0) {
/*  75 */           flush();
/*  76 */           bytesLeft = 16384;
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush() throws IOException {
/*  85 */     flushBuffer(this.buffer, this.bufferPosition);
/*  86 */     this.bufferStart += this.bufferPosition;
/*  87 */     this.bufferPosition = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   private void flushBuffer(byte[] b, int len) throws IOException { flushBuffer(b, 0, len); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void flushBuffer(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public void close() throws IOException { flush(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 117 */   public long getFilePointer() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 124 */     flush();
/* 125 */     this.bufferStart = pos;
/*     */   }
/*     */   
/*     */   public abstract long length() throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\BufferedIndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.ChecksumIndexInput,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.zip.CRC32;
/*    */ import java.util.zip.Checksum;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ChecksumIndexInput
/*    */   extends IndexInput
/*    */ {
/*    */   IndexInput main;
/*    */   Checksum digest;
/*    */   
/*    */   public ChecksumIndexInput(IndexInput main) {
/* 31 */     this.main = main;
/* 32 */     this.digest = new CRC32();
/*    */   }
/*    */   
/*    */   public byte readByte() throws IOException {
/* 36 */     byte b = this.main.readByte();
/* 37 */     this.digest.update(b);
/* 38 */     return b;
/*    */   }
/*    */ 
/*    */   
/*    */   public void readBytes(byte[] b, int offset, int len) throws IOException {
/* 43 */     this.main.readBytes(b, offset, len);
/* 44 */     this.digest.update(b, offset, len);
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 49 */   public long getChecksum() { return this.digest.getValue(); }
/*    */ 
/*    */ 
/*    */   
/* 53 */   public void close() throws IOException { this.main.close(); }
/*    */ 
/*    */ 
/*    */   
/* 57 */   public long getFilePointer() { return this.main.getFilePointer(); }
/*    */ 
/*    */ 
/*    */   
/* 61 */   public void seek(long pos) { throw new RuntimeException(""not allowed""); }
/*    */ 
/*    */ 
/*    */   
/* 65 */   public long length() { return this.main.length(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\ChecksumIndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.ChecksumIndexOutput,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.zip.CRC32;
/*    */ import java.util.zip.Checksum;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ChecksumIndexOutput
/*    */   extends IndexOutput
/*    */ {
/*    */   IndexOutput main;
/*    */   Checksum digest;
/*    */   
/*    */   public ChecksumIndexOutput(IndexOutput main) {
/* 31 */     this.main = main;
/* 32 */     this.digest = new CRC32();
/*    */   }
/*    */   
/*    */   public void writeByte(byte b) throws IOException {
/* 36 */     this.digest.update(b);
/* 37 */     this.main.writeByte(b);
/*    */   }
/*    */   
/*    */   public void writeBytes(byte[] b, int offset, int length) throws IOException {
/* 41 */     this.digest.update(b, offset, length);
/* 42 */     this.main.writeBytes(b, offset, length);
/*    */   }
/*    */ 
/*    */   
/* 46 */   public long getChecksum() { return this.digest.getValue(); }
/*    */ 
/*    */ 
/*    */   
/* 50 */   public void flush() throws IOException { this.main.flush(); }
/*    */ 
/*    */ 
/*    */   
/* 54 */   public void close() throws IOException { this.main.close(); }
/*    */ 
/*    */ 
/*    */   
/* 58 */   public long getFilePointer() { return this.main.getFilePointer(); }
/*    */ 
/*    */ 
/*    */   
/* 62 */   public void seek(long pos) { throw new RuntimeException(""not allowed""); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void prepareCommit() throws IOException {
/* 72 */     long checksum = getChecksum();
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */     
/* 78 */     long pos = this.main.getFilePointer();
/* 79 */     this.main.writeLong(checksum - 1L);
/* 80 */     this.main.flush();
/* 81 */     this.main.seek(pos);
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 86 */   public void finishCommit() throws IOException { this.main.writeLong(getChecksum()); }
/*    */ 
/*    */ 
/*    */   
/* 90 */   public long length() throws IOException { return this.main.length(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\ChecksumIndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.Directory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Directory
/*     */ {
/*     */   volatile boolean isOpen = true;
/*     */   protected LockFactory lockFactory;
/*     */   
/*     */   public abstract String[] list() throws IOException;
/*     */   
/*     */   public abstract boolean fileExists(String paramString) throws IOException;
/*     */   
/*     */   public abstract long fileModified(String paramString) throws IOException;
/*     */   
/*     */   public abstract void touchFile(String paramString) throws IOException;
/*     */   
/*     */   public abstract void deleteFile(String paramString) throws IOException;
/*     */   
/*     */   public abstract void renameFile(String paramString1, String paramString2) throws IOException;
/*     */   
/*     */   public abstract long fileLength(String paramString) throws IOException;
/*     */   
/*     */   public abstract IndexOutput createOutput(String paramString) throws IOException;
/*     */   
/*     */   public void sync(String name) throws IOException {}
/*     */   
/*     */   public abstract IndexInput openInput(String paramString) throws IOException;
/*     */   
/* 105 */   public IndexInput openInput(String name, int bufferSize) throws IOException { return openInput(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 112 */   public Lock makeLock(String name) { return this.lockFactory.makeLock(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void clearLock(String name) throws IOException {
/* 121 */     if (this.lockFactory != null) {
/* 122 */       this.lockFactory.clearLock(name);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setLockFactory(LockFactory lockFactory) {
/* 140 */     this.lockFactory = lockFactory;
/* 141 */     lockFactory.setLockPrefix(getLockID());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 151 */   public LockFactory getLockFactory() { return this.lockFactory; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 163 */   public String getLockID() { return toString(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void copy(Directory src, Directory dest, boolean closeDirSrc) throws IOException {
/* 177 */     String[] files = src.list();
/*     */     
/* 179 */     if (files == null) {
/* 180 */       throw new IOException(""cannot read directory "" + src + "": list() returned null"");
/*     */     }
/* 182 */     byte[] buf = new byte[16384];
/* 183 */     for (int i = 0; i < files.length; i++) {
/* 184 */       IndexOutput os = null;
/* 185 */       IndexInput is = null;
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 211 */     if (closeDirSrc) {
/* 212 */       src.close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   protected final void ensureOpen() throws AlreadyClosedException {
/* 219 */     if (!this.isOpen)
/* 220 */       throw new AlreadyClosedException(""this Directory is closed""); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\Directory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.FSDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileInputStream;
/*     */ import java.io.FileOutputStream;
/*     */ import java.io.FilenameFilter;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.io.OutputStream;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.security.MessageDigest;
/*     */ import java.security.NoSuchAlgorithmException;
/*     */ import java.util.HashMap;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.index.IndexFileNameFilter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FSDirectory
/*     */   extends Directory
/*     */ {
/*  61 */   private static final Map DIRECTORIES = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static boolean disableLocks = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  74 */   public static void setDisableLocks(boolean doDisableLocks) { disableLocks = doDisableLocks; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  82 */   public static boolean getDisableLocks() { return disableLocks; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  99 */   public static final String LOCK_DIR = System.getProperty(""org.apache.lucene.lockDir"", System.getProperty(""java.io.tmpdir""));
/*     */   private static Class IMPL;
/*     */   private static MessageDigest DIGESTER;
/*     */   
/*     */   static 
/*     */   {
/*     */     try {
/* 106 */       String name = System.getProperty(""org.apache.lucene.FSDirectory.class"", FSDirectory.class.getName());
/*     */ 
/*     */       
/* 109 */       IMPL = Class.forName(name);
/* 110 */     } catch (ClassNotFoundException e) {
/* 111 */       throw new RuntimeException(""cannot load FSDirectory class: "" + e.toString(), e);
/* 112 */     } catch (SecurityException se) {
/*     */       try {
/* 114 */         IMPL = Class.forName(FSDirectory.class.getName());
/* 115 */       } catch (ClassNotFoundException e) {
/* 116 */         throw new RuntimeException(""cannot load default FSDirectory class: "" + e.toString(), e);
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 125 */       DIGESTER = MessageDigest.getInstance(""MD5"");
/* 126 */     } catch (NoSuchAlgorithmException e) {
/* 127 */       throw new RuntimeException(e.toString(), e);
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 494 */     HEX_DIGITS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; }
/*     */   private byte[] buffer = null;
/*     */   public static FSDirectory getDirectory(String path) throws IOException { return getDirectory(new File(path), null); }
/*     */   public static FSDirectory getDirectory(String path, LockFactory lockFactory) throws IOException { return getDirectory(new File(path), lockFactory); }
/*     */   public static FSDirectory getDirectory(File file) throws IOException { return getDirectory(file, null); } public static FSDirectory getDirectory(File file, LockFactory lockFactory) throws IOException { FSDirectory dir; file = new File(file.getCanonicalPath()); if (file.exists() && !file.isDirectory())
/*     */       throw new IOException(file + "" not a directory"");  if (!file.exists() && !file.mkdirs())
/*     */       throw new IOException(""Cannot create directory: "" + file);  synchronized (DIRECTORIES) { dir = (FSDirectory)DIRECTORIES.get(file); if (dir == null) { try { dir = IMPL.newInstance(); } catch (Exception e) { throw new RuntimeException(""cannot load FSDirectory class: "" + e.toString(), e); }
/*     */          dir.init(file, lockFactory); DIRECTORIES.put(file, dir); }
/*     */       else if (lockFactory != null && lockFactory != dir.getLockFactory()) { throw new IOException(""Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it""); }
/*     */        }
/*     */      synchronized (dir) { dir.refCount++; }
/*     */      return dir; } public static FSDirectory getDirectory(String path, boolean create) throws IOException { return getDirectory(new File(path), create); } public static FSDirectory getDirectory(File file, boolean create) throws IOException { FSDirectory dir = getDirectory(file, null); if (create)
/*     */       dir.create();  return dir; } private void create() throws IOException { if (this.directory.exists()) { String[] files = this.directory.list((FilenameFilter)IndexFileNameFilter.getFilter()); if (files == null)
/*     */         throw new IOException(""cannot read directory "" + this.directory.getAbsolutePath() + "": list() returned null"");  for (int i = 0; i < files.length; i++) { File file = new File(this.directory, files[i]); if (!file.delete())
/*     */           throw new IOException(""Cannot delete "" + file);  }
/*     */        }
/*     */      this.lockFactory.clearLock(""write.lock""); } private File directory = null; private int refCount; private static final char[] HEX_DIGITS; private void init(File path, LockFactory lockFactory) throws IOException { this.directory = path; boolean doClearLockID = false; if (lockFactory == null)
/*     */       if (disableLocks) { lockFactory = NoLockFactory.getNoLockFactory(); }
/*     */       else { String lockClassName = System.getProperty(""org.apache.lucene.store.FSDirectoryLockFactoryClass""); if (lockClassName != null && !lockClassName.equals("""")) { Class c; try { c = Class.forName(lockClassName); }
/*     */           catch (ClassNotFoundException e) { throw new IOException(""unable to find LockClass "" + lockClassName); }
/*     */            try { lockFactory = (LockFactory)c.newInstance(); }
/*     */           catch (IllegalAccessException e) { throw new IOException(""IllegalAccessException when instantiating LockClass "" + lockClassName); }
/*     */           catch (InstantiationException e) { throw new IOException(""InstantiationException when instantiating LockClass "" + lockClassName); }
/*     */           catch (ClassCastException e) { throw new IOException(""unable to cast LockClass "" + lockClassName + "" instance to a LockFactory""); }
/*     */            if (lockFactory instanceof NativeFSLockFactory) { ((NativeFSLockFactory)lockFactory).setLockDir(path); }
/*     */           else if (lockFactory instanceof SimpleFSLockFactory) { ((SimpleFSLockFactory)lockFactory).setLockDir(path); }
/*     */            }
/*     */         else { lockFactory = new SimpleFSLockFactory(path); doClearLockID = true; }
/*     */          }
/*     */         setLockFactory(lockFactory); if (doClearLockID)
/* 524 */       lockFactory.setLockPrefix(null);  } public synchronized void close() { if (this.isOpen && --this.refCount <= 0)
/* 525 */     { this.isOpen = false;
/* 526 */       synchronized (DIRECTORIES)
/* 527 */       { DIRECTORIES.remove(this.directory); }  }  }
/*     */   public String[] list() { ensureOpen(); return this.directory.list((FilenameFilter)IndexFileNameFilter.getFilter()); }
/*     */   public boolean fileExists(String name) { ensureOpen(); File file = new File(this.directory, name); return file.exists(); }
/*     */   public long fileModified(String name) { ensureOpen(); File file = new File(this.directory, name); return file.lastModified(); }
/*     */   public static long fileModified(File directory, String name) { File file = new File(directory, name); return file.lastModified(); }
/*     */   public void touchFile(String name) { ensureOpen(); File file = new File(this.directory, name); file.setLastModified(System.currentTimeMillis()); }
/*     */   public long fileLength(String name) { ensureOpen(); File file = new File(this.directory, name); return file.length(); } public void deleteFile(String name) throws IOException { ensureOpen(); File file = new File(this.directory, name); if (!file.delete()) throw new IOException(""Cannot delete "" + file);  } public synchronized void renameFile(String from, String to) throws IOException { ensureOpen(); File old = new File(this.directory, from); File nu = new File(this.directory, to); if (nu.exists() && !nu.delete()) throw new IOException(""Cannot delete "" + nu);  if (!old.renameTo(nu)) { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(old); out = new FileOutputStream(nu); if (this.buffer == null) this.buffer = new byte[1024];  int len; while ((len = in.read(this.buffer)) >= 0) out.write(this.buffer, 0, len);  old.delete(); } catch (IOException ioe) { IOException newExc = new IOException(""Cannot rename "" + old + "" to "" + nu); newExc.initCause(ioe); throw newExc; } finally { try { if (in != null) try { in.close(); } catch (IOException e) { throw new RuntimeException(""Cannot close input stream: "" + e.toString(), e); }   } finally { if (out != null) try { out.close(); } catch (IOException e) { throw new RuntimeException(""Cannot close output stream: "" + e.toString(), e); }   }  }  }  } public IndexOutput createOutput(String name) throws IOException { ensureOpen(); File file = new File(this.directory, name); if (file.exists() && !file.delete()) throw new IOException(""Cannot overwrite: "" + file);  return new FSIndexOutput(file); } public void sync(String name) throws IOException { ensureOpen(); File fullFile = new File(this.directory, name); boolean success = false; int retryCount = 0; IOException exc = null; while (!success && retryCount < 5) { retryCount++; RandomAccessFile file = null; try { try { file = new RandomAccessFile(fullFile, ""rw""); file.getFD().sync(); success = true; } finally { if (file != null) file.close();  }  } catch (IOException ioe) { if (exc == null) exc = ioe;  try { Thread.sleep(5L); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }  }  }  if (!success) throw exc;  } public IndexInput openInput(String name) throws IOException { ensureOpen(); return openInput(name, 1024); } public IndexInput openInput(String name, int bufferSize) throws IOException { ensureOpen(); return new FSIndexInput(new File(this.directory, name), bufferSize); } public String getLockID() { // Byte code:
/*     */     //   0: aload_0
/*     */     //   1: invokevirtual ensureOpen : ()V
/*     */     //   4: aload_0
/*     */     //   5: getfield directory : Ljava/io/File;
/*     */     //   8: invokevirtual getCanonicalPath : ()Ljava/lang/String;
/*     */     //   11: astore_1
/*     */     //   12: goto -> 29
/*     */     //   15: astore_2
/*     */     //   16: new java/lang/RuntimeException
/*     */     //   19: dup
/*     */     //   20: aload_2
/*     */     //   21: invokevirtual toString : ()Ljava/lang/String;
/*     */     //   24: aload_2
/*     */     //   25: invokespecial <init> : (Ljava/lang/String;Ljava/lang/Throwable;)V
/*     */     //   28: athrow
/*     */     //   29: getstatic org/apache/lucene/store/FSDirectory.DIGESTER : Ljava/security/MessageDigest;
/*     */     //   32: dup
/*     */     //   33: astore_3
/*     */     //   34: monitorenter
/*     */     //   35: getstatic org/apache/lucene/store/FSDirectory.DIGESTER : Ljava/security/MessageDigest;
/*     */     //   38: aload_1
/*     */     //   39: invokevirtual getBytes : ()[B
/*     */     //   42: invokevirtual digest : ([B)[B
/*     */     //   45: astore_2
/*     */     //   46: aload_3
/*     */     //   47: monitorexit
/*     */     //   48: goto -> 58
/*     */     //   51: astore #4
/*     */     //   53: aload_3
/*     */     //   54: monitorexit
/*     */     //   55: aload #4
/*     */     //   57: athrow
/*     */     //   58: new java/lang/StringBuffer
/*     */     //   61: dup
/*     */     //   62: invokespecial <init> : ()V
/*     */     //   65: astore_3
/*     */     //   66: aload_3
/*     */     //   67: ldc 'lucene-'
/*     */     //   69: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
/*     */     //   72: pop
/*     */     //   73: iconst_0
/*     */     //   74: istore #4
/*     */     //   76: iload #4
/*     */     //   78: aload_2
/*     */     //   79: arraylength
/*     */     //   80: if_icmpge -> 125
/*     */     //   83: aload_2
/*     */     //   84: iload #4
/*     */     //   86: baload
/*     */     //   87: istore #5
/*     */     //   89: aload_3
/*     */     //   90: getstatic org/apache/lucene/store/FSDirectory.HEX_DIGITS : [C
/*     */     //   93: iload #5
/*     */     //   95: iconst_4
/*     */     //   96: ishr
/*     */     //   97: bipush #15
/*     */     //   99: iand
/*     */     //   100: caload
/*     */     //   101: invokevirtual append : (C)Ljava/lang/StringBuffer;
/*     */     //   104: pop
/*     */     //   105: aload_3
/*     */     //   106: getstatic org/apache/lucene/store/FSDirectory.HEX_DIGITS : [C
/*     */     //   109: iload #5
/*     */     //   111: bipush #15
/*     */     //   113: iand
/*     */     //   114: caload
/*     */     //   115: invokevirtual append : (C)Ljava/lang/StringBuffer;
/*     */     //   118: pop
/*     */     //   119: iinc #4, 1
/*     */     //   122: goto -> 76
/*     */     //   125: aload_3
/*     */     //   126: invokevirtual toString : ()Ljava/lang/String;
/*     */     //   129: areturn
/*     */     // Line number table:
/*     */     //   Java source line number -> byte code offset
/*     */     //   #499	-> 0
/*     */     //   #502	-> 4
/*     */     //   #505	-> 12
/*     */     //   #503	-> 15
/*     */     //   #504	-> 16
/*     */     //   #508	-> 29
/*     */     //   #509	-> 35
/*     */     //   #510	-> 46
/*     */     //   #511	-> 58
/*     */     //   #512	-> 66
/*     */     //   #513	-> 73
/*     */     //   #514	-> 83
/*     */     //   #515	-> 89
/*     */     //   #516	-> 105
/*     */     //   #513	-> 119
/*     */     //   #519	-> 125
/*     */     // Local variable table:
/*     */     //   start	length	slot	name	descriptor
/*     */     //   16	13	2	e	Ljava/io/IOException;
/*     */     //   89	30	5	b	I
/*     */     //   76	49	4	i	I
/*     */     //   0	130	0	this	Lorg/apache/lucene/store/FSDirectory;
/*     */     //   12	118	1	dirName	Ljava/lang/String;
/*     */     //   46	84	2	digest	[B
/*     */     //   66	64	3	buf	Ljava/lang/StringBuffer;
/*     */     // Exception table:
/*     */     //   from	to	target	type
/*     */     //   4	12	15	java/io/IOException
/*     */     //   35	48	51	finally
/* 533 */     //   51	55	51	finally } public File getFile() { ensureOpen();
/* 534 */     return this.directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 539 */   public String toString() { return getClass().getName() + ""@"" + this.directory; }
/*     */   
/*     */   protected static class FSIndexInput
/*     */     extends BufferedIndexInput {
/*     */     protected final Descriptor file;
/*     */     boolean isClone;
/*     */     
/*     */     protected static class Descriptor extends RandomAccessFile {
/*     */       protected volatile boolean isOpen;
/*     */       long position;
/*     */       final long length;
/*     */       
/*     */       public Descriptor(File file, String mode) throws IOException {
/* 552 */         super(file, mode);
/* 553 */         this.isOpen = true;
/* 554 */         this.length = length();
/*     */       }
/*     */       
/*     */       public void close() throws IOException {
/* 558 */         if (this.isOpen) {
/* 559 */           this.isOpen = false;
/* 560 */           super.close();
/*     */         } 
/*     */       }
/*     */       
/*     */       protected void finalize() throws Throwable {
/*     */         try {
/* 566 */           close();
/*     */         } finally {
/* 568 */           super.finalize();
/*     */         } 
/*     */       }
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 577 */     public FSIndexInput(File path) throws IOException { this(path, 1024); }
/*     */ 
/*     */     
/*     */     public FSIndexInput(File path, int bufferSize) throws IOException {
/* 581 */       super(bufferSize);
/* 582 */       this.file = new Descriptor(path, ""r"");
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     protected void readInternal(byte[] b, int offset, int len) throws IOException {
/* 588 */       synchronized (this.file) {
/* 589 */         long position = getFilePointer();
/* 590 */         if (position != this.file.position) {
/* 591 */           this.file.seek(position);
/* 592 */           this.file.position = position;
/*     */         } 
/* 594 */         int total = 0;
/*     */         do {
/* 596 */           int i = this.file.read(b, offset + total, len - total);
/* 597 */           if (i == -1)
/* 598 */             throw new IOException(""read past EOF""); 
/* 599 */           this.file.position += i;
/* 600 */           total += i;
/* 601 */         } while (total < len);
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 607 */     public void close() throws IOException { if (!this.isClone) this.file.close();
/*     */        }
/*     */ 
/*     */     
/*     */     protected void seekInternal(long position) {}
/*     */ 
/*     */     
/* 614 */     public long length() { return this.file.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/* 618 */       FSIndexInput clone = (FSIndexInput)super.clone();
/* 619 */       clone.isClone = true;
/* 620 */       return clone;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 627 */     boolean isFDValid() throws IOException { return this.file.getFD().valid(); }
/*     */   }
/*     */   
/*     */   protected static class FSIndexOutput
/*     */     extends BufferedIndexOutput {
/* 632 */     RandomAccessFile file = null;
/*     */ 
/*     */     
/*     */     private volatile boolean isOpen;
/*     */ 
/*     */     
/*     */     public FSIndexOutput(File path) throws IOException {
/* 639 */       this.file = new RandomAccessFile(path, ""rw"");
/* 640 */       this.isOpen = true;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 645 */     public void flushBuffer(byte[] b, int offset, int size) throws IOException { this.file.write(b, offset, size); }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {
/* 649 */       if (this.isOpen) {
/* 650 */         boolean success = false;
/*     */         try {
/* 652 */           super.close();
/* 653 */           success = true;
/*     */         } finally {
/* 655 */           this.isOpen = false;
/* 656 */           if (!success) {
/*     */             try {
/* 658 */               this.file.close();
/* 659 */             } catch (Throwable t) {}
/*     */           }
/*     */           else {
/*     */             
/* 663 */             this.file.close();
/*     */           } 
/*     */         } 
/*     */       } 
/*     */     }
/*     */     
/*     */     public void seek(long pos) throws IOException {
/* 670 */       super.seek(pos);
/* 671 */       this.file.seek(pos);
/*     */     }
/*     */     
/* 674 */     public long length() throws IOException { return this.file.length(); }
/*     */ 
/*     */     
/* 677 */     public void setLength(long length) throws IOException { this.file.setLength(length); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\FSDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.IndexInput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexInput
/*     */   implements Cloneable
/*     */ {
/*     */   private byte[] bytes;
/*     */   private char[] chars;
/*     */   private boolean preUTF8Strings;
/*     */   
/*     */   public abstract byte readByte() throws IOException;
/*     */   
/*     */   public abstract void readBytes(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */   
/*  61 */   public void readBytes(byte[] b, int offset, int len, boolean useBuffer) throws IOException { readBytes(b, offset, len); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public int readInt() throws IOException { return (readByte() & 0xFF) << 24 | (readByte() & 0xFF) << 16 | (readByte() & 0xFF) << 8 | readByte() & 0xFF; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int readVInt() throws IOException {
/*  78 */     byte b = readByte();
/*  79 */     int i = b & Byte.MAX_VALUE;
/*  80 */     for (int shift = 7; (b & 0x80) != 0; shift += 7) {
/*  81 */       b = readByte();
/*  82 */       i |= (b & Byte.MAX_VALUE) << shift;
/*     */     } 
/*  84 */     return i;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  91 */   public long readLong() throws IOException { return readInt() << 32L | readInt() & 0xFFFFFFFFL; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long readVLong() throws IOException {
/*  98 */     byte b = readByte();
/*  99 */     long i = (b & Byte.MAX_VALUE);
/* 100 */     for (int shift = 7; (b & 0x80) != 0; shift += 7) {
/* 101 */       b = readByte();
/* 102 */       i |= (b & 0x7FL) << shift;
/*     */     } 
/* 104 */     return i;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 112 */   public void setModifiedUTF8StringsMode() { this.preUTF8Strings = true; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String readString() throws IOException {
/* 119 */     if (this.preUTF8Strings)
/* 120 */       return readModifiedUTF8String(); 
/* 121 */     int length = readVInt();
/* 122 */     if (this.bytes == null || length > this.bytes.length)
/* 123 */       this.bytes = new byte[(int)(length * 1.25D)]; 
/* 124 */     readBytes(this.bytes, 0, length);
/* 125 */     return new String(this.bytes, 0, length, ""UTF-8"");
/*     */   }
/*     */   
/*     */   private String readModifiedUTF8String() throws IOException {
/* 129 */     int length = readVInt();
/* 130 */     if (this.chars == null || length > this.chars.length)
/* 131 */       this.chars = new char[length]; 
/* 132 */     readChars(this.chars, 0, length);
/* 133 */     return new String(this.chars, 0, length);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void readChars(char[] buffer, int start, int length) throws IOException {
/* 148 */     int end = start + length;
/* 149 */     for (int i = start; i < end; i++) {
/* 150 */       byte b = readByte();
/* 151 */       if ((b & 0x80) == 0) {
/* 152 */         buffer[i] = (char)(b & Byte.MAX_VALUE);
/* 153 */       } else if ((b & 0xE0) != 224) {
/* 154 */         buffer[i] = (char)((b & 0x1F) << 6 | readByte() & 0x3F);
/*     */       } else {
/*     */         
/* 157 */         buffer[i] = (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | readByte() & 0x3F);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void skipChars(int length) throws IOException {
/* 175 */     for (int i = 0; i < length; i++) {
/* 176 */       byte b = readByte();
/* 177 */       if ((b & 0x80) != 0)
/*     */       {
/*     */         
/* 180 */         if ((b & 0xE0) != 224) {
/* 181 */           readByte();
/*     */         } else {
/*     */           
/* 184 */           readByte();
/* 185 */           readByte();
/*     */         } 
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract long getFilePointer();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void seek(long paramLong) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract long length();
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 218 */     IndexInput clone = null;
/*     */     try {
/* 220 */       clone = (IndexInput)super.clone();
/* 221 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 223 */     clone.bytes = null;
/* 224 */     clone.chars = null;
/*     */     
/* 226 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\IndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.IndexOutput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.util.UnicodeUtil;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexOutput
/*     */ {
/*  30 */   private UnicodeUtil.UTF8Result utf8Result = new UnicodeUtil.UTF8Result();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void writeByte(byte paramByte) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  43 */   public void writeBytes(byte[] b, int length) throws IOException { writeBytes(b, 0, length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void writeBytes(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeInt(int i) throws IOException {
/*  58 */     writeByte((byte)(i >> 24));
/*  59 */     writeByte((byte)(i >> 16));
/*  60 */     writeByte((byte)(i >> 8));
/*  61 */     writeByte((byte)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeVInt(int i) throws IOException {
/*  70 */     while ((i & 0xFFFFFF80) != 0) {
/*  71 */       writeByte((byte)(i & 0x7F | 0x80));
/*  72 */       i >>>= 7;
/*     */     } 
/*  74 */     writeByte((byte)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeLong(long i) throws IOException {
/*  81 */     writeInt((int)(i >> 32L));
/*  82 */     writeInt((int)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeVLong(long i) throws IOException {
/*  91 */     while ((i & 0xFFFFFFFFFFFFFF80L) != 0L) {
/*  92 */       writeByte((byte)(int)(i & 0x7FL | 0x80L));
/*  93 */       i >>>= 7L;
/*     */     } 
/*  95 */     writeByte((byte)(int)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeString(String s) throws IOException {
/* 102 */     UnicodeUtil.UTF16toUTF8(s, 0, s.length(), this.utf8Result);
/* 103 */     writeVInt(this.utf8Result.length);
/* 104 */     writeBytes(this.utf8Result.result, 0, this.utf8Result.length);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeChars(String s, int start, int length) throws IOException {
/* 117 */     int end = start + length;
/* 118 */     for (int i = start; i < end; i++) {
/* 119 */       int code = s.charAt(i);
/* 120 */       if (code >= 1 && code <= 127) {
/* 121 */         writeByte((byte)code);
/* 122 */       } else if ((code >= 128 && code <= 2047) || code == 0) {
/* 123 */         writeByte((byte)(0xC0 | code >> 6));
/* 124 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } else {
/* 126 */         writeByte((byte)(0xE0 | code >>> 12));
/* 127 */         writeByte((byte)(0x80 | code >> 6 & 0x3F));
/* 128 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeChars(char[] s, int start, int length) throws IOException {
/* 142 */     int end = start + length;
/* 143 */     for (int i = start; i < end; i++) {
/* 144 */       int code = s[i];
/* 145 */       if (code >= 1 && code <= 127) {
/* 146 */         writeByte((byte)code);
/* 147 */       } else if ((code >= 128 && code <= 2047) || code == 0) {
/* 148 */         writeByte((byte)(0xC0 | code >> 6));
/* 149 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } else {
/* 151 */         writeByte((byte)(0xE0 | code >>> 12));
/* 152 */         writeByte((byte)(0x80 | code >> 6 & 0x3F));
/* 153 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/* 158 */   private static int COPY_BUFFER_SIZE = 16384;
/*     */   
/*     */   private byte[] copyBuffer;
/*     */   
/*     */   public void copyBytes(IndexInput input, long numBytes) throws IOException {
/* 163 */     long left = numBytes;
/* 164 */     if (this.copyBuffer == null)
/* 165 */       this.copyBuffer = new byte[COPY_BUFFER_SIZE]; 
/* 166 */     while (left > 0L) {
/*     */       int toCopy;
/* 168 */       if (left > COPY_BUFFER_SIZE) {
/* 169 */         toCopy = COPY_BUFFER_SIZE;
/*     */       } else {
/* 171 */         toCopy = (int)left;
/* 172 */       }  input.readBytes(this.copyBuffer, 0, toCopy);
/* 173 */       writeBytes(this.copyBuffer, 0, toCopy);
/* 174 */       left -= toCopy;
/*     */     } 
/*     */   }
/*     */   
/*     */   public abstract void flush() throws IOException;
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */   
/*     */   public abstract long getFilePointer();
/*     */   
/*     */   public abstract void seek(long paramLong) throws IOException;
/*     */   
/*     */   public abstract long length() throws IOException;
/*     */   
/*     */   public void setLength(long length) throws IOException {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\IndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.Lock,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Lock
/*     */ {
/*  39 */   public static long LOCK_POLL_INTERVAL = 1000L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final long LOCK_OBTAIN_WAIT_FOREVER = -1L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Throwable failureReason;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract boolean obtain() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {
/*  72 */     this.failureReason = null;
/*  73 */     boolean locked = obtain();
/*  74 */     if (lockWaitTimeout < 0L && lockWaitTimeout != -1L) {
/*  75 */       throw new IllegalArgumentException(""lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got "" + lockWaitTimeout + "")"");
/*     */     }
/*  77 */     long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;
/*  78 */     long sleepCount = 0L;
/*  79 */     while (!locked) {
/*  80 */       if (lockWaitTimeout != -1L && sleepCount++ >= maxSleepCount) {
/*  81 */         String reason = ""Lock obtain timed out: "" + toString();
/*  82 */         if (this.failureReason != null) {
/*  83 */           reason = reason + "": "" + this.failureReason;
/*     */         }
/*  85 */         LockObtainFailedException e = new LockObtainFailedException(reason);
/*  86 */         if (this.failureReason != null) {
/*  87 */           e.initCause(this.failureReason);
/*     */         }
/*  89 */         throw e;
/*     */       } 
/*     */       try {
/*  92 */         Thread.sleep(LOCK_POLL_INTERVAL);
/*  93 */       } catch (InterruptedException e) {
/*  94 */         throw new IOException(e.toString());
/*     */       } 
/*  96 */       locked = obtain();
/*     */     } 
/*  98 */     return locked;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void release() throws IOException;
/*     */ 
/*     */   
/*     */   public abstract boolean isLocked();
/*     */ 
/*     */   
/*     */   public static abstract class With
/*     */   {
/*     */     private Lock lock;
/*     */     
/*     */     private long lockWaitTimeout;
/*     */ 
/*     */     
/*     */     public With(Lock lock, long lockWaitTimeout) {
/* 117 */       this.lock = lock;
/* 118 */       this.lockWaitTimeout = lockWaitTimeout;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected abstract Object doBody() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Object run() throws LockObtainFailedException, IOException {
/* 133 */       boolean locked = false;
/*     */       try {
/* 135 */         locked = this.lock.obtain(this.lockWaitTimeout);
/* 136 */         return doBody();
/*     */       } finally {
/* 138 */         if (locked)
/* 139 */           this.lock.release(); 
/*     */       } 
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\Lock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.LockFactory,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class LockFactory
/*    */ {
/* 38 */   protected String lockPrefix = """";
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 51 */   public void setLockPrefix(String lockPrefix) { this.lockPrefix = lockPrefix; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 58 */   public String getLockPrefix() { return this.lockPrefix; }
/*    */   
/*    */   public abstract Lock makeLock(String paramString);
/*    */   
/*    */   public abstract void clearLock(String paramString) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\LockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.LockObtainFailedException,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LockObtainFailedException
/*    */   extends IOException
/*    */ {
/* 31 */   public LockObtainFailedException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\LockObtainFailedException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.LockReleaseFailedException,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LockReleaseFailedException
/*    */   extends IOException
/*    */ {
/* 29 */   public LockReleaseFailedException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\LockReleaseFailedException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.LockStressTest,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class LockStressTest
/*     */ {
/*     */   public static void main(String[] args) throws Exception {
/*     */     Object lockFactory;
/*     */     Class c;
/*  36 */     if (args.length != 6) {
/*  37 */       System.out.println(""\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\n\n  myID = int from 0 .. 255 (should be unique for test process)\n  verifierHostOrIP = host name or IP address where LockVerifyServer is running\n  verifierPort = port that LockVerifyServer is listening on\n  lockFactoryClassName = primary LockFactory class that we will use\n  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\n  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\n\nYou should run multiple instances of this process, each with its own\nunique ID, and each pointing to the same lock directory, to verify\nthat locking is working correctly.\n\nMake sure you are first running LockVerifyServer.\n\n"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  52 */       System.exit(1);
/*     */     } 
/*     */     
/*  55 */     int myID = Integer.parseInt(args[0]);
/*     */     
/*  57 */     if (myID < 0 || myID > 255) {
/*  58 */       System.out.println(""myID must be a unique int 0..255"");
/*  59 */       System.exit(1);
/*     */     } 
/*     */     
/*  62 */     String verifierHost = args[1];
/*  63 */     int verifierPort = Integer.parseInt(args[2]);
/*  64 */     String lockFactoryClassName = args[3];
/*  65 */     String lockDirName = args[4];
/*  66 */     int sleepTimeMS = Integer.parseInt(args[5]);
/*     */ 
/*     */     
/*     */     try {
/*  70 */       c = Class.forName(lockFactoryClassName);
/*  71 */     } catch (ClassNotFoundException e) {
/*  72 */       throw new IOException(""unable to find LockClass "" + lockFactoryClassName);
/*     */     } 
/*     */ 
/*     */     
/*     */     try {
/*  77 */       lockFactory = c.newInstance();
/*  78 */     } catch (IllegalAccessException e) {
/*  79 */       throw new IOException(""IllegalAccessException when instantiating LockClass "" + lockFactoryClassName);
/*  80 */     } catch (InstantiationException e) {
/*  81 */       throw new IOException(""InstantiationException when instantiating LockClass "" + lockFactoryClassName);
/*  82 */     } catch (ClassCastException e) {
/*  83 */       throw new IOException(""unable to cast LockClass "" + lockFactoryClassName + "" instance to a LockFactory"");
/*     */     } 
/*     */     
/*  86 */     File lockDir = new File(lockDirName);
/*     */     
/*  88 */     if (lockFactory instanceof NativeFSLockFactory) {
/*  89 */       ((NativeFSLockFactory)lockFactory).setLockDir(lockDir);
/*  90 */     } else if (lockFactory instanceof SimpleFSLockFactory) {
/*  91 */       ((SimpleFSLockFactory)lockFactory).setLockDir(lockDir);
/*     */     } 
/*     */     
/*  94 */     lockFactory.setLockPrefix(""test"");
/*     */     
/*  96 */     LockFactory verifyLF = new VerifyingLockFactory((byte)myID, (LockFactory)lockFactory, verifierHost, verifierPort);
/*     */     
/*  98 */     Lock l = verifyLF.makeLock(""test.lock"");
/*     */ 
/*     */     
/*     */     while (true) {
/* 102 */       boolean obtained = false;
/*     */       
/*     */       try {
/* 105 */         obtained = l.obtain(10L);
/* 106 */       } catch (LockObtainFailedException e) {
/* 107 */         System.out.print(""x"");
/*     */       } 
/*     */       
/* 110 */       if (obtained) {
/* 111 */         System.out.print(""l"");
/* 112 */         l.release();
/*     */       } 
/* 114 */       Thread.sleep(sleepTimeMS);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\LockStressTest.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.LockVerifyServer,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.InputStream;
/*    */ import java.io.OutputStream;
/*    */ import java.net.ServerSocket;
/*    */ import java.net.Socket;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LockVerifyServer
/*    */ {
/* 39 */   private static String getTime(long startTime) { return ""["" + ((System.currentTimeMillis() - startTime) / 1000L) + ""s] ""; }
/*    */ 
/*    */ 
/*    */   
/*    */   public static void main(String[] args) throws IOException {
/* 44 */     if (args.length != 1) {
/* 45 */       System.out.println(""\nUsage: java org.apache.lucene.store.LockVerifyServer port\n"");
/* 46 */       System.exit(1);
/*    */     } 
/*    */     
/* 49 */     int port = Integer.parseInt(args[0]);
/*    */     
/* 51 */     ServerSocket s = new ServerSocket(port);
/* 52 */     s.setReuseAddress(true);
/* 53 */     System.out.println(""\nReady on port "" + port + ""..."");
/*    */     
/* 55 */     int lockedID = 0;
/* 56 */     long startTime = System.currentTimeMillis();
/*    */     
/*    */     while (true) {
/* 59 */       Socket cs = s.accept();
/* 60 */       OutputStream out = cs.getOutputStream();
/* 61 */       InputStream in = cs.getInputStream();
/*    */       
/* 63 */       int id = in.read();
/* 64 */       int command = in.read();
/*    */       
/* 66 */       boolean err = false;
/*    */       
/* 68 */       if (command == 1) {
/*    */         
/* 70 */         if (lockedID != 0) {
/* 71 */           err = true;
/* 72 */           System.out.println(getTime(startTime) + "" ERROR: id "" + id + "" got lock, but "" + lockedID + "" already holds the lock"");
/*    */         } 
/* 74 */         lockedID = id;
/* 75 */       } else if (command == 0) {
/* 76 */         if (lockedID != id) {
/* 77 */           err = true;
/* 78 */           System.out.println(getTime(startTime) + "" ERROR: id "" + id + "" released the lock, but "" + lockedID + "" is the one holding the lock"");
/*    */         } 
/* 80 */         lockedID = 0;
/*    */       } else {
/* 82 */         throw new RuntimeException(""unrecognized command "" + command);
/*    */       } 
/* 84 */       System.out.print(""."");
/*    */       
/* 86 */       if (err) {
/* 87 */         out.write(1);
/*    */       } else {
/* 89 */         out.write(0);
/*    */       } 
/* 91 */       out.close();
/* 92 */       in.close();
/* 93 */       cs.close();
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\LockVerifyServer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.MMapDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.nio.ByteBuffer;
/*     */ import java.nio.channels.FileChannel;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MMapDirectory
/*     */   extends FSDirectory
/*     */ {
/*     */   private static class MMapIndexInput
/*     */     extends IndexInput
/*     */   {
/*     */     private ByteBuffer buffer;
/*     */     private final long length;
/*     */     
/*     */     private MMapIndexInput(RandomAccessFile raf) throws IOException {
/*  42 */       this.length = raf.length();
/*  43 */       this.buffer = raf.getChannel().map(FileChannel.MapMode.READ_ONLY, 0L, this.length);
/*     */     }
/*     */ 
/*     */     
/*  47 */     public byte readByte() throws IOException { return this.buffer.get(); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  52 */     public void readBytes(byte[] b, int offset, int len) throws IOException { this.buffer.get(b, offset, len); }
/*     */ 
/*     */ 
/*     */     
/*  56 */     public long getFilePointer() { return this.buffer.position(); }
/*     */ 
/*     */ 
/*     */     
/*  60 */     public void seek(long pos) throws IOException { this.buffer.position((int)pos); }
/*     */ 
/*     */ 
/*     */     
/*  64 */     public long length() { return this.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/*  68 */       MMapIndexInput clone = (MMapIndexInput)super.clone();
/*  69 */       clone.buffer = this.buffer.duplicate();
/*  70 */       return clone;
/*     */     }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {}
/*     */   }
/*     */ 
/*     */   
/*     */   private static class MultiMMapIndexInput
/*     */     extends IndexInput
/*     */   {
/*     */     private ByteBuffer[] buffers;
/*     */     
/*     */     private int[] bufSizes;
/*     */     
/*     */     private final long length;
/*     */     private int curBufIndex;
/*     */     private final int maxBufSize;
/*     */     private ByteBuffer curBuf;
/*     */     private int curAvail;
/*     */     
/*     */     public MultiMMapIndexInput(RandomAccessFile raf, int maxBufSize) throws IOException {
/*  92 */       this.length = raf.length();
/*  93 */       this.maxBufSize = maxBufSize;
/*     */       
/*  95 */       if (maxBufSize <= 0) {
/*  96 */         throw new IllegalArgumentException(""Non positive maxBufSize: "" + maxBufSize);
/*     */       }
/*     */       
/*  99 */       if (this.length / maxBufSize > 2147483647L) {
/* 100 */         throw new IllegalArgumentException(""RandomAccessFile too big for maximum buffer size: "" + raf.toString());
/*     */       }
/*     */ 
/*     */       
/* 104 */       int nrBuffers = (int)(this.length / maxBufSize);
/* 105 */       if ((nrBuffers * maxBufSize) < this.length) nrBuffers++;
/*     */       
/* 107 */       this.buffers = new ByteBuffer[nrBuffers];
/* 108 */       this.bufSizes = new int[nrBuffers];
/*     */       
/* 110 */       long bufferStart = 0L;
/* 111 */       FileChannel rafc = raf.getChannel();
/* 112 */       for (int bufNr = 0; bufNr < nrBuffers; bufNr++) {
/* 113 */         int bufSize = (this.length > bufferStart + maxBufSize) ? maxBufSize : (int)(this.length - bufferStart);
/*     */ 
/*     */         
/* 116 */         this.buffers[bufNr] = rafc.map(FileChannel.MapMode.READ_ONLY, bufferStart, bufSize);
/* 117 */         this.bufSizes[bufNr] = bufSize;
/* 118 */         bufferStart += bufSize;
/*     */       } 
/* 120 */       seek(0L);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     public byte readByte() throws IOException {
/* 126 */       if (this.curAvail == 0) {
/* 127 */         this.curBufIndex++;
/* 128 */         this.curBuf = this.buffers[this.curBufIndex];
/* 129 */         this.curBuf.position(0);
/* 130 */         this.curAvail = this.bufSizes[this.curBufIndex];
/*     */       } 
/* 132 */       this.curAvail--;
/* 133 */       return this.curBuf.get();
/*     */     }
/*     */     
/*     */     public void readBytes(byte[] b, int offset, int len) throws IOException {
/* 137 */       while (len > this.curAvail) {
/* 138 */         this.curBuf.get(b, offset, this.curAvail);
/* 139 */         len -= this.curAvail;
/* 140 */         offset += this.curAvail;
/* 141 */         this.curBufIndex++;
/* 142 */         this.curBuf = this.buffers[this.curBufIndex];
/* 143 */         this.curBuf.position(0);
/* 144 */         this.curAvail = this.bufSizes[this.curBufIndex];
/*     */       } 
/* 146 */       this.curBuf.get(b, offset, len);
/* 147 */       this.curAvail -= len;
/*     */     }
/*     */ 
/*     */     
/* 151 */     public long getFilePointer() { return this.curBufIndex * this.maxBufSize + this.curBuf.position(); }
/*     */ 
/*     */     
/*     */     public void seek(long pos) throws IOException {
/* 155 */       this.curBufIndex = (int)(pos / this.maxBufSize);
/* 156 */       this.curBuf = this.buffers[this.curBufIndex];
/* 157 */       int bufOffset = (int)(pos - (this.curBufIndex * this.maxBufSize));
/* 158 */       this.curBuf.position(bufOffset);
/* 159 */       this.curAvail = this.bufSizes[this.curBufIndex] - bufOffset;
/*     */     }
/*     */ 
/*     */     
/* 163 */     public long length() { return this.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/* 167 */       MultiMMapIndexInput clone = (MultiMMapIndexInput)super.clone();
/* 168 */       clone.buffers = new ByteBuffer[this.buffers.length];
/*     */ 
/*     */ 
/*     */       
/* 172 */       for (int bufNr = 0; bufNr < this.buffers.length; bufNr++) {
/* 173 */         clone.buffers[bufNr] = this.buffers[bufNr].duplicate();
/*     */       }
/*     */       try {
/* 176 */         clone.seek(getFilePointer());
/* 177 */       } catch (IOException ioe) {
/* 178 */         RuntimeException newException = new RuntimeException(ioe);
/* 179 */         newException.initCause(ioe);
/* 180 */         throw newException;
/*     */       } 
/* 182 */       return clone;
/*     */     }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {}
/*     */   }
/* 188 */   private final int MAX_BBUF = Integer.MAX_VALUE;
/*     */   
/*     */   public IndexInput openInput(String name) throws IOException {
/* 191 */     File f = new File(getFile(), name);
/* 192 */     RandomAccessFile raf = new RandomAccessFile(f, ""r"");
/*     */     try {
/* 194 */       return (IndexInput)((raf.length() <= 2147483647L) ? new MMapIndexInput(raf) : new MultiMMapIndexInput(raf, 2147483647));
/*     */     }
/*     */     finally {
/*     */       
/* 198 */       raf.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 203 */   public IndexInput openInput(String name, int bufferSize) throws IOException { return openInput(name); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\MMapDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NativeFSLock,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.nio.channels.FileChannel;
/*     */ import java.nio.channels.FileLock;
/*     */ import java.util.HashSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class NativeFSLock
/*     */   extends Lock
/*     */ {
/*     */   private RandomAccessFile f;
/*     */   private FileChannel channel;
/*     */   private FileLock lock;
/*     */   private File path;
/*     */   private File lockDir;
/* 184 */   private static HashSet LOCK_HELD = new HashSet();
/*     */   
/*     */   public NativeFSLock(File lockDir, String lockFileName) {
/* 187 */     this.lockDir = lockDir;
/* 188 */     this.path = new File(lockDir, lockFileName);
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized boolean obtain() throws IOException {
/* 193 */     if (isLocked())
/*     */     {
/* 195 */       return false;
/*     */     }
/*     */ 
/*     */     
/* 199 */     if (!this.lockDir.exists()) {
/* 200 */       if (!this.lockDir.mkdirs()) {
/* 201 */         throw new IOException(""Cannot create directory: "" + this.lockDir.getAbsolutePath());
/*     */       }
/* 203 */     } else if (!this.lockDir.isDirectory()) {
/* 204 */       throw new IOException(""Found regular file where directory expected: "" + this.lockDir.getAbsolutePath());
/*     */     } 
/*     */ 
/*     */     
/* 208 */     String canonicalPath = this.path.getCanonicalPath();
/*     */     
/* 210 */     boolean markedHeld = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 217 */       synchronized (LOCK_HELD) {
/* 218 */         if (LOCK_HELD.contains(canonicalPath))
/*     */         {
/* 220 */           return false;
/*     */         }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 226 */         LOCK_HELD.add(canonicalPath);
/* 227 */         markedHeld = true;
/*     */       } 
/*     */ 
/*     */       
/*     */       try {
/* 232 */         this.f = new RandomAccessFile(this.path, ""rw"");
/* 233 */       } catch (IOException e) {
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 238 */         this.failureReason = e;
/* 239 */         this.f = null;
/*     */       } 
/*     */       
/* 242 */       if (this.f != null) {
/*     */         try {
/* 244 */           this.channel = this.f.getChannel();
/*     */           try {
/* 246 */             this.lock = this.channel.tryLock();
/* 247 */           } catch (IOException e) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 257 */             this.failureReason = e;
/*     */           } finally {
/* 259 */             if (this.lock == null) {
/*     */               try {
/* 261 */                 this.channel.close();
/*     */               } finally {
/* 263 */                 this.channel = null;
/*     */               } 
/*     */             }
/*     */           } 
/*     */         } finally {
/* 268 */           if (this.channel == null) {
/*     */             try {
/* 270 */               this.f.close();
/*     */             } finally {
/* 272 */               this.f = null;
/*     */             } 
/*     */           }
/*     */         } 
/*     */       }
/*     */     } finally {
/*     */       
/* 279 */       if (markedHeld && !isLocked()) {
/* 280 */         synchronized (LOCK_HELD) {
/* 281 */           if (LOCK_HELD.contains(canonicalPath)) {
/* 282 */             LOCK_HELD.remove(canonicalPath);
/*     */           }
/*     */         } 
/*     */       }
/*     */     } 
/* 287 */     return isLocked();
/*     */   }
/*     */   
/*     */   public synchronized void release() throws IOException {
/* 291 */     if (isLocked()) {
/*     */       try {
/* 293 */         this.lock.release();
/*     */       } finally {
/* 295 */         this.lock = null;
/*     */         try {
/* 297 */           this.channel.close();
/*     */         } finally {
/* 299 */           this.channel = null;
/*     */           try {
/* 301 */             this.f.close();
/*     */           } finally {
/* 303 */             this.f = null;
/* 304 */             synchronized (LOCK_HELD) {
/* 305 */               LOCK_HELD.remove(this.path.getCanonicalPath());
/*     */             } 
/*     */           } 
/*     */         } 
/*     */       } 
/* 310 */       if (!this.path.delete()) {
/* 311 */         throw new LockReleaseFailedException(""failed to delete "" + this.path);
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/* 316 */   public synchronized boolean isLocked() { return (this.lock != null); }
/*     */ 
/*     */ 
/*     */   
/* 320 */   public String toString() { return ""NativeFSLock@"" + this.path; }
/*     */ 
/*     */   
/*     */   public void finalize() throws Throwable {
/*     */     try {
/* 325 */       if (isLocked()) {
/* 326 */         release();
/*     */       }
/*     */     } finally {
/* 329 */       super.finalize();
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\NativeFSLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NativeFSLockFactory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.util.Random;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class NativeFSLockFactory
/*     */   extends LockFactory
/*     */ {
/*     */   private File lockDir;
/*     */   
/*     */   private void acquireTestLock() throws IOException {
/*  75 */     String randomLockName = ""lucene-"" + Long.toString((new Random()).nextInt(), 36) + ""-test.lock"";
/*     */     
/*  77 */     Lock l = makeLock(randomLockName);
/*     */     try {
/*  79 */       l.obtain();
/*  80 */     } catch (IOException e) {
/*  81 */       IOException e2 = new IOException(""Failed to acquire random test lock; please verify filesystem for lock directory '"" + this.lockDir + ""' supports locking"");
/*  82 */       e2.initCause(e);
/*  83 */       throw e2;
/*     */     } 
/*     */     
/*  86 */     l.release();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   NativeFSLockFactory() throws IOException { this((File)null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public NativeFSLockFactory(String lockDirName) throws IOException { this(new File(lockDirName)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 117 */   public NativeFSLockFactory(File lockDir) throws IOException { setLockDir(lockDir); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setLockDir(File lockDir) throws IOException {
/* 127 */     this.lockDir = lockDir;
/* 128 */     if (lockDir != null) {
/*     */       
/* 130 */       if (!lockDir.exists()) {
/* 131 */         if (!lockDir.mkdirs()) {
/* 132 */           throw new IOException(""Cannot create directory: "" + lockDir.getAbsolutePath());
/*     */         }
/* 134 */       } else if (!lockDir.isDirectory()) {
/* 135 */         throw new IOException(""Found regular file where directory expected: "" + lockDir.getAbsolutePath());
/*     */       } 
/*     */ 
/*     */       
/* 139 */       acquireTestLock();
/*     */     } 
/*     */   }
/*     */   
/*     */   public synchronized Lock makeLock(String lockName) {
/* 144 */     if (this.lockPrefix != null)
/* 145 */       lockName = this.lockPrefix + ""-n-"" + lockName; 
/* 146 */     return new NativeFSLock(this.lockDir, lockName);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void clearLock(String lockName) throws IOException {
/* 154 */     if (this.lockDir.exists()) {
/* 155 */       if (this.lockPrefix != null) {
/* 156 */         lockName = this.lockPrefix + ""-n-"" + lockName;
/*     */       }
/* 158 */       File lockFile = new File(this.lockDir, lockName);
/* 159 */       if (lockFile.exists() && !lockFile.delete())
/* 160 */         throw new IOException(""Cannot delete "" + lockFile); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\NativeFSLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NIOFSDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.nio.ByteBuffer;
/*     */ import java.nio.channels.FileChannel;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class NIOFSDirectory
/*     */   extends FSDirectory
/*     */ {
/*     */   static Class class$org$apache$lucene$store$NIOFSDirectory;
/*     */   
/*     */   public IndexInput openInput(String name, int bufferSize) throws IOException {
/*  48 */     ensureOpen();
/*  49 */     return new NIOFSIndexInput(new File(getFile(), name), bufferSize);
/*     */   }
/*     */   static Class class$(String x0) { 
/*  52 */     try { return Class.forName(x0); } catch (ClassNotFoundException x1) { throw (new NoClassDefFoundError()).initCause(x1); }
/*     */      }
/*     */   
/*     */   private static class NIOFSIndexInput extends FSDirectory.FSIndexInput { private ByteBuffer byteBuf;
/*     */     private byte[] otherBuffer;
/*     */     private ByteBuffer otherByteBuf;
/*     */     final FileChannel channel;
/*     */     static final boolean $assertionsDisabled;
/*     */     
/*     */     public NIOFSIndexInput(File path, int bufferSize) throws IOException {
/*  62 */       super(path, bufferSize);
/*  63 */       this.channel = this.file.getChannel();
/*     */     }
/*     */     
/*     */     protected void newBuffer(byte[] newBuffer) {
/*  67 */       super.newBuffer(newBuffer);
/*  68 */       this.byteBuf = ByteBuffer.wrap(newBuffer);
/*     */     }
/*     */     
/*     */     public void close() throws IOException {
/*  72 */       if (!this.isClone && this.file.isOpen) {
/*     */         
/*     */         try {
/*  75 */           this.channel.close();
/*     */         } finally {
/*  77 */           this.file.close();
/*     */         } 
/*     */       }
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected void readInternal(byte[] b, int offset, int len) throws IOException {
/*     */       ByteBuffer bb;
/*  87 */       if (b == this.buffer && 0 == offset) {
/*     */         
/*  89 */         assert this.byteBuf != null;
/*  90 */         this.byteBuf.clear();
/*  91 */         this.byteBuf.limit(len);
/*  92 */         bb = this.byteBuf;
/*     */       }
/*  94 */       else if (offset == 0) {
/*  95 */         if (this.otherBuffer != b) {
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 100 */           this.otherBuffer = b;
/* 101 */           this.otherByteBuf = ByteBuffer.wrap(b);
/*     */         } else {
/* 103 */           this.otherByteBuf.clear();
/* 104 */         }  this.otherByteBuf.limit(len);
/* 105 */         bb = this.otherByteBuf;
/*     */       } else {
/*     */         
/* 108 */         bb = ByteBuffer.wrap(b, offset, len);
/*     */       } 
/*     */       
/* 111 */       long pos = getFilePointer();
/* 112 */       while (bb.hasRemaining()) {
/* 113 */         int i = this.channel.read(bb, pos);
/* 114 */         if (i == -1)
/* 115 */           throw new IOException(""read past EOF""); 
/* 116 */         pos += i;
/*     */       } 
/*     */     } }
/*     */ 
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\NIOFSDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NoLock,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class NoLock
/*    */   extends Lock
/*    */ {
/* 50 */   public boolean obtain() throws IOException { return true; }
/*    */ 
/*    */ 
/*    */   
/*    */   public void release() {}
/*    */ 
/*    */   
/* 57 */   public boolean isLocked() { return false; }
/*    */ 
/*    */ 
/*    */   
/* 61 */   public String toString() { return ""NoLock""; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\NoLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NoLockFactory,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoLockFactory
/*    */   extends LockFactory
/*    */ {
/* 34 */   private static NoLock singletonLock = new NoLock();
/* 35 */   private static NoLockFactory singleton = new NoLockFactory();
/*    */ 
/*    */   
/* 38 */   public static NoLockFactory getNoLockFactory() { return singleton; }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Lock makeLock(String lockName) { return singletonLock; }
/*    */   
/*    */   public void clearLock(String lockName) {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\NoLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileNotFoundException;
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RAMDirectory
/*     */   extends Directory
/*     */   implements Serializable
/*     */ {
/*     */   private static final long serialVersionUID = 1L;
/*  39 */   HashMap fileMap = new HashMap();
/*  40 */   long sizeInBytes = 0L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  48 */   public RAMDirectory() { setLockFactory(new SingleInstanceLockFactory()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public RAMDirectory(Directory dir) throws IOException { this(dir, false); }
/*     */ 
/*     */   
/*     */   private RAMDirectory(Directory dir, boolean closeDir) throws IOException {
/*  72 */     this();
/*  73 */     Directory.copy(dir, this, closeDir);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   public RAMDirectory(File dir) throws IOException { this(FSDirectory.getDirectory(dir), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public RAMDirectory(String dir) throws IOException { this(FSDirectory.getDirectory(dir), true); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized String[] list() {
/* 100 */     ensureOpen();
/* 101 */     Set fileNames = this.fileMap.keySet();
/* 102 */     String[] result = new String[fileNames.size()];
/* 103 */     int i = 0;
/* 104 */     Iterator it = fileNames.iterator();
/* 105 */     while (it.hasNext())
/* 106 */       result[i++] = it.next(); 
/* 107 */     return result;
/*     */   }
/*     */   
/*     */   public final boolean fileExists(String name) {
/*     */     RAMFile file;
/* 112 */     ensureOpen();
/*     */     
/* 114 */     synchronized (this) {
/* 115 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 117 */     return (file != null);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final long fileModified(String name) throws IOException {
/*     */     RAMFile file;
/* 124 */     ensureOpen();
/*     */     
/* 126 */     synchronized (this) {
/* 127 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 129 */     if (file == null)
/* 130 */       throw new FileNotFoundException(name); 
/* 131 */     return file.getLastModified();
/*     */   }
/*     */ 
/*     */   
/*     */   public void touchFile(String name) throws IOException {
/*     */     long ts2;
/*     */     RAMFile file;
/* 138 */     ensureOpen();
/*     */     
/* 140 */     synchronized (this) {
/* 141 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 143 */     if (file == null) {
/* 144 */       throw new FileNotFoundException(name);
/*     */     }
/* 146 */     long ts1 = System.currentTimeMillis();
/*     */     do {
/*     */       try {
/* 149 */         Thread.sleep(0L, 1);
/* 150 */       } catch (InterruptedException e) {}
/* 151 */       ts2 = System.currentTimeMillis();
/* 152 */     } while (ts1 == ts2);
/*     */     
/* 154 */     file.setLastModified(ts2);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final long fileLength(String name) throws IOException {
/*     */     RAMFile file;
/* 161 */     ensureOpen();
/*     */     
/* 163 */     synchronized (this) {
/* 164 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 166 */     if (file == null)
/* 167 */       throw new FileNotFoundException(name); 
/* 168 */     return file.getLength();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized long sizeInBytes() {
/* 175 */     ensureOpen();
/* 176 */     return this.sizeInBytes;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void deleteFile(String name) throws IOException {
/* 183 */     ensureOpen();
/* 184 */     RAMFile file = (RAMFile)this.fileMap.get(name);
/* 185 */     if (file != null) {
/* 186 */       this.fileMap.remove(name);
/* 187 */       file.directory = null;
/* 188 */       this.sizeInBytes -= file.sizeInBytes;
/*     */     } else {
/* 190 */       throw new FileNotFoundException(name);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void renameFile(String from, String to) throws IOException {
/* 198 */     ensureOpen();
/* 199 */     RAMFile fromFile = (RAMFile)this.fileMap.get(from);
/* 200 */     if (fromFile == null)
/* 201 */       throw new FileNotFoundException(from); 
/* 202 */     RAMFile toFile = (RAMFile)this.fileMap.get(to);
/* 203 */     if (toFile != null) {
/* 204 */       this.sizeInBytes -= toFile.sizeInBytes;
/* 205 */       toFile.directory = null;
/*     */     } 
/* 207 */     this.fileMap.remove(from);
/* 208 */     this.fileMap.put(to, fromFile);
/*     */   }
/*     */ 
/*     */   
/*     */   public IndexOutput createOutput(String name) throws IOException {
/* 213 */     ensureOpen();
/* 214 */     RAMFile file = new RAMFile(this);
/* 215 */     synchronized (this) {
/* 216 */       RAMFile existing = (RAMFile)this.fileMap.get(name);
/* 217 */       if (existing != null) {
/* 218 */         this.sizeInBytes -= existing.sizeInBytes;
/* 219 */         existing.directory = null;
/*     */       } 
/* 221 */       this.fileMap.put(name, file);
/*     */     } 
/* 223 */     return new RAMOutputStream(file);
/*     */   }
/*     */   
/*     */   public IndexInput openInput(String name) throws IOException {
/*     */     RAMFile file;
/* 228 */     ensureOpen();
/*     */     
/* 230 */     synchronized (this) {
/* 231 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 233 */     if (file == null)
/* 234 */       throw new FileNotFoundException(name); 
/* 235 */     return new RAMInputStream(file);
/*     */   }
/*     */ 
/*     */   
/*     */   public void close() {
/* 240 */     this.isOpen = false;
/* 241 */     this.fileMap = null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\RAMDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMFile,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ import java.util.ArrayList;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class RAMFile
/*    */   implements Serializable
/*    */ {
/*    */   private static final long serialVersionUID = 1L;
/* 27 */   private ArrayList buffers = new ArrayList();
/*    */   
/*    */   long length;
/*    */   
/*    */   RAMDirectory directory;
/*    */   long sizeInBytes;
/* 33 */   private long lastModified = System.currentTimeMillis();
/*    */ 
/*    */   
/*    */   RAMFile() {}
/*    */ 
/*    */   
/* 39 */   RAMFile(RAMDirectory directory) { this.directory = directory; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   synchronized long getLength() { return this.length; }
/*    */ 
/*    */ 
/*    */   
/* 48 */   synchronized void setLength(long length) { this.length = length; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 53 */   synchronized long getLastModified() { return this.lastModified; }
/*    */ 
/*    */ 
/*    */   
/* 57 */   synchronized void setLastModified(long lastModified) { this.lastModified = lastModified; }
/*    */ 
/*    */   
/*    */   final synchronized byte[] addBuffer(int size) {
/* 61 */     byte[] buffer = newBuffer(size);
/* 62 */     if (this.directory != null) {
/* 63 */       synchronized (this.directory) {
/* 64 */         this.buffers.add(buffer);
/* 65 */         this.directory.sizeInBytes += size;
/* 66 */         this.sizeInBytes += size;
/*    */       } 
/*    */     } else {
/* 69 */       this.buffers.add(buffer);
/* 70 */     }  return buffer;
/*    */   }
/*    */ 
/*    */   
/* 74 */   final synchronized byte[] getBuffer(int index) { return this.buffers.get(index); }
/*    */ 
/*    */ 
/*    */   
/* 78 */   final synchronized int numBuffers() { return this.buffers.size(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 88 */   byte[] newBuffer(int size) { return new byte[size]; }
/*    */ 
/*    */ 
/*    */   
/*    */   long getSizeInBytes() {
/* 93 */     synchronized (this.directory) {
/* 94 */       return this.sizeInBytes;
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\RAMFile.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMInputStream,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class RAMInputStream
/*     */   extends IndexInput
/*     */   implements Cloneable
/*     */ {
/*     */   static final int BUFFER_SIZE = 1024;
/*     */   private RAMFile file;
/*     */   private long length;
/*     */   private byte[] currentBuffer;
/*     */   private int currentBufferIndex;
/*     */   private int bufferPosition;
/*     */   private long bufferStart;
/*     */   private int bufferLength;
/*     */   
/*     */   RAMInputStream(RAMFile f) throws IOException {
/*  42 */     this.file = f;
/*  43 */     this.length = this.file.length;
/*  44 */     if (this.length / 1024L >= 2147483647L) {
/*  45 */       throw new IOException(""Too large RAMFile! "" + this.length);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*  50 */     this.currentBufferIndex = -1;
/*  51 */     this.currentBuffer = null;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() {}
/*     */ 
/*     */   
/*  59 */   public long length() { return this.length; }
/*     */ 
/*     */   
/*     */   public byte readByte() throws IOException {
/*  63 */     if (this.bufferPosition >= this.bufferLength) {
/*  64 */       this.currentBufferIndex++;
/*  65 */       switchCurrentBuffer(true);
/*     */     } 
/*  67 */     return this.currentBuffer[this.bufferPosition++];
/*     */   }
/*     */   
/*     */   public void readBytes(byte[] b, int offset, int len) throws IOException {
/*  71 */     while (len > 0) {
/*  72 */       if (this.bufferPosition >= this.bufferLength) {
/*  73 */         this.currentBufferIndex++;
/*  74 */         switchCurrentBuffer(true);
/*     */       } 
/*     */       
/*  77 */       int remainInBuffer = this.bufferLength - this.bufferPosition;
/*  78 */       int bytesToCopy = (len < remainInBuffer) ? len : remainInBuffer;
/*  79 */       System.arraycopy(this.currentBuffer, this.bufferPosition, b, offset, bytesToCopy);
/*  80 */       offset += bytesToCopy;
/*  81 */       len -= bytesToCopy;
/*  82 */       this.bufferPosition += bytesToCopy;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void switchCurrentBuffer(boolean enforceEOF) throws IOException {
/*  87 */     if (this.currentBufferIndex >= this.file.numBuffers()) {
/*     */       
/*  89 */       if (enforceEOF) {
/*  90 */         throw new IOException(""Read past EOF"");
/*     */       }
/*     */       
/*  93 */       this.currentBufferIndex--;
/*  94 */       this.bufferPosition = 1024;
/*     */     } else {
/*     */       
/*  97 */       this.currentBuffer = this.file.getBuffer(this.currentBufferIndex);
/*  98 */       this.bufferPosition = 0;
/*  99 */       this.bufferStart = 1024L * this.currentBufferIndex;
/* 100 */       long buflen = this.length - this.bufferStart;
/* 101 */       this.bufferLength = (buflen > 1024L) ? 1024 : (int)buflen;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 106 */   public long getFilePointer() { return (this.currentBufferIndex < 0) ? 0L : (this.bufferStart + this.bufferPosition); }
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 110 */     if (this.currentBuffer == null || pos < this.bufferStart || pos >= this.bufferStart + 1024L) {
/* 111 */       this.currentBufferIndex = (int)(pos / 1024L);
/* 112 */       switchCurrentBuffer(false);
/*     */     } 
/* 114 */     this.bufferPosition = (int)(pos % 1024L);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\RAMInputStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMOutputStream,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RAMOutputStream
/*     */   extends IndexOutput
/*     */ {
/*     */   static final int BUFFER_SIZE = 1024;
/*     */   private RAMFile file;
/*     */   private byte[] currentBuffer;
/*     */   private int currentBufferIndex;
/*     */   private int bufferPosition;
/*     */   private long bufferStart;
/*     */   private int bufferLength;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*  42 */   public RAMOutputStream() { this(new RAMFile()); }
/*     */ 
/*     */   
/*     */   RAMOutputStream(RAMFile f) {
/*  46 */     this.file = f;
/*     */ 
/*     */ 
/*     */     
/*  50 */     this.currentBufferIndex = -1;
/*  51 */     this.currentBuffer = null;
/*     */   }
/*     */ 
/*     */   
/*     */   public void writeTo(IndexOutput out) throws IOException {
/*  56 */     flush();
/*  57 */     long end = this.file.length;
/*  58 */     long pos = 0L;
/*  59 */     int buffer = 0;
/*  60 */     while (pos < end) {
/*  61 */       int length = 1024;
/*  62 */       long nextPos = pos + length;
/*  63 */       if (nextPos > end) {
/*  64 */         length = (int)(end - pos);
/*     */       }
/*  66 */       out.writeBytes(this.file.getBuffer(buffer++), length);
/*  67 */       pos = nextPos;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public void reset() {
/*     */     try {
/*  74 */       seek(0L);
/*  75 */     } catch (IOException e) {
/*  76 */       throw new RuntimeException(e.toString());
/*     */     } 
/*     */     
/*  79 */     this.file.setLength(0L);
/*     */   }
/*     */ 
/*     */   
/*  83 */   public void close() throws IOException { flush(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/*  89 */     setFileLength();
/*  90 */     if (pos < this.bufferStart || pos >= this.bufferStart + this.bufferLength) {
/*  91 */       this.currentBufferIndex = (int)(pos / 1024L);
/*  92 */       switchCurrentBuffer();
/*     */     } 
/*     */     
/*  95 */     this.bufferPosition = (int)(pos % 1024L);
/*     */   }
/*     */ 
/*     */   
/*  99 */   public long length() { return this.file.length; }
/*     */ 
/*     */   
/*     */   public void writeByte(byte b) throws IOException {
/* 103 */     if (this.bufferPosition == this.bufferLength) {
/* 104 */       this.currentBufferIndex++;
/* 105 */       switchCurrentBuffer();
/*     */     } 
/* 107 */     this.currentBuffer[this.bufferPosition++] = b;
/*     */   }
/*     */   
/*     */   public void writeBytes(byte[] b, int offset, int len) throws IOException {
/* 111 */     assert b != null;
/* 112 */     while (len > 0) {
/* 113 */       if (this.bufferPosition == this.bufferLength) {
/* 114 */         this.currentBufferIndex++;
/* 115 */         switchCurrentBuffer();
/*     */       } 
/*     */       
/* 118 */       int remainInBuffer = this.currentBuffer.length - this.bufferPosition;
/* 119 */       int bytesToCopy = (len < remainInBuffer) ? len : remainInBuffer;
/* 120 */       System.arraycopy(b, offset, this.currentBuffer, this.bufferPosition, bytesToCopy);
/* 121 */       offset += bytesToCopy;
/* 122 */       len -= bytesToCopy;
/* 123 */       this.bufferPosition += bytesToCopy;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void switchCurrentBuffer() throws IOException {
/* 128 */     if (this.currentBufferIndex == this.file.numBuffers()) {
/* 129 */       this.currentBuffer = this.file.addBuffer(1024);
/*     */     } else {
/* 131 */       this.currentBuffer = this.file.getBuffer(this.currentBufferIndex);
/*     */     } 
/* 133 */     this.bufferPosition = 0;
/* 134 */     this.bufferStart = 1024L * this.currentBufferIndex;
/* 135 */     this.bufferLength = this.currentBuffer.length;
/*     */   }
/*     */   
/*     */   private void setFileLength() {
/* 139 */     long pointer = this.bufferStart + this.bufferPosition;
/* 140 */     if (pointer > this.file.length) {
/* 141 */       this.file.setLength(pointer);
/*     */     }
/*     */   }
/*     */   
/*     */   public void flush() throws IOException {
/* 146 */     this.file.setLastModified(System.currentTimeMillis());
/* 147 */     setFileLength();
/*     */   }
/*     */ 
/*     */   
/* 151 */   public long getFilePointer() { return (this.currentBufferIndex < 0) ? 0L : (this.bufferStart + this.bufferPosition); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 156 */   public long sizeInBytes() { return (this.file.numBuffers() * 1024); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\RAMOutputStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SimpleFSLock,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SimpleFSLock
/*     */   extends Lock
/*     */ {
/*     */   File lockFile;
/*     */   File lockDir;
/*     */   
/*     */   public SimpleFSLock(File lockDir, String lockFileName) {
/* 129 */     this.lockDir = lockDir;
/* 130 */     this.lockFile = new File(lockDir, lockFileName);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean obtain() throws IOException {
/* 136 */     if (!this.lockDir.exists()) {
/* 137 */       if (!this.lockDir.mkdirs()) {
/* 138 */         throw new IOException(""Cannot create directory: "" + this.lockDir.getAbsolutePath());
/*     */       }
/* 140 */     } else if (!this.lockDir.isDirectory()) {
/* 141 */       throw new IOException(""Found regular file where directory expected: "" + this.lockDir.getAbsolutePath());
/*     */     } 
/*     */     
/* 144 */     return this.lockFile.createNewFile();
/*     */   }
/*     */   
/*     */   public void release() throws LockReleaseFailedException {
/* 148 */     if (this.lockFile.exists() && !this.lockFile.delete()) {
/* 149 */       throw new LockReleaseFailedException(""failed to delete "" + this.lockFile);
/*     */     }
/*     */   }
/*     */   
/* 153 */   public boolean isLocked() { return this.lockFile.exists(); }
/*     */ 
/*     */ 
/*     */   
/* 157 */   public String toString() { return ""SimpleFSLock@"" + this.lockFile; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\SimpleFSLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SimpleFSLockFactory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SimpleFSLockFactory
/*     */   extends LockFactory
/*     */ {
/*     */   private File lockDir;
/*     */   
/*  73 */   SimpleFSLockFactory() throws IOException { this((File)null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  81 */   public SimpleFSLockFactory(File lockDir) throws IOException { setLockDir(lockDir); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SimpleFSLockFactory(String lockDirName) throws IOException {
/*  89 */     this.lockDir = new File(lockDirName);
/*  90 */     setLockDir(this.lockDir);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 100 */   void setLockDir(File lockDir) throws IOException { this.lockDir = lockDir; }
/*     */ 
/*     */   
/*     */   public Lock makeLock(String lockName) {
/* 104 */     if (this.lockPrefix != null) {
/* 105 */       lockName = this.lockPrefix + ""-"" + lockName;
/*     */     }
/* 107 */     return new SimpleFSLock(this.lockDir, lockName);
/*     */   }
/*     */   
/*     */   public void clearLock(String lockName) throws IOException {
/* 111 */     if (this.lockDir.exists()) {
/* 112 */       if (this.lockPrefix != null) {
/* 113 */         lockName = this.lockPrefix + ""-"" + lockName;
/*     */       }
/* 115 */       File lockFile = new File(this.lockDir, lockName);
/* 116 */       if (lockFile.exists() && !lockFile.delete())
/* 117 */         throw new IOException(""Cannot delete "" + lockFile); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\SimpleFSLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SingleInstanceLock,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.HashSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class SingleInstanceLock
/*    */   extends Lock
/*    */ {
/*    */   String lockName;
/*    */   private HashSet locks;
/*    */   
/*    */   public SingleInstanceLock(HashSet locks, String lockName) {
/* 60 */     this.locks = locks;
/* 61 */     this.lockName = lockName;
/*    */   }
/*    */   
/*    */   public boolean obtain() throws IOException {
/* 65 */     synchronized (this.locks) {
/* 66 */       return this.locks.add(this.lockName);
/*    */     } 
/*    */   }
/*    */   
/*    */   public void release() {
/* 71 */     synchronized (this.locks) {
/* 72 */       this.locks.remove(this.lockName);
/*    */     } 
/*    */   }
/*    */   
/*    */   public boolean isLocked() {
/* 77 */     synchronized (this.locks) {
/* 78 */       return this.locks.contains(this.lockName);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 83 */   public String toString() { return ""SingleInstanceLock: "" + this.lockName; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\SingleInstanceLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SingleInstanceLockFactory,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.HashSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SingleInstanceLockFactory
/*    */   extends LockFactory
/*    */ {
/* 36 */   private HashSet locks = new HashSet();
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Lock makeLock(String lockName) { return new SingleInstanceLock(this.locks, lockName); }
/*    */ 
/*    */   
/*    */   public void clearLock(String lockName) throws IOException {
/* 46 */     synchronized (this.locks) {
/* 47 */       if (this.locks.contains(lockName))
/* 48 */         this.locks.remove(lockName); 
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\SingleInstanceLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.VerifyingLockFactory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.io.OutputStream;
/*     */ import java.net.Socket;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class VerifyingLockFactory
/*     */   extends LockFactory
/*     */ {
/*     */   LockFactory lf;
/*     */   byte id;
/*     */   String host;
/*     */   int port;
/*     */   
/*     */   private class CheckedLock
/*     */     extends Lock
/*     */   {
/*     */     private Lock lock;
/*     */     private final VerifyingLockFactory this$0;
/*     */     
/*  50 */     public CheckedLock(Lock lock) { this.lock = lock; }
/*     */ 
/*     */     
/*     */     private void verify(byte message) {
/*     */       try {
/*  55 */         Socket s = new Socket(VerifyingLockFactory.this.host, VerifyingLockFactory.this.port);
/*  56 */         OutputStream out = s.getOutputStream();
/*  57 */         out.write(VerifyingLockFactory.this.id);
/*  58 */         out.write(message);
/*  59 */         InputStream in = s.getInputStream();
/*  60 */         int result = in.read();
/*  61 */         in.close();
/*  62 */         out.close();
/*  63 */         s.close();
/*  64 */         if (result != 0)
/*  65 */           throw new RuntimeException(""lock was double acquired""); 
/*  66 */       } catch (Exception e) {
/*  67 */         throw new RuntimeException(e);
/*     */       } 
/*     */     }
/*     */ 
/*     */     
/*     */     public synchronized boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {
/*  73 */       boolean obtained = this.lock.obtain(lockWaitTimeout);
/*  74 */       if (obtained)
/*  75 */         verify((byte)1); 
/*  76 */       return obtained;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*  81 */     public synchronized boolean obtain() throws LockObtainFailedException, IOException { return this.lock.obtain(); }
/*     */ 
/*     */ 
/*     */     
/*  85 */     public synchronized boolean isLocked() { return this.lock.isLocked(); }
/*     */ 
/*     */     
/*     */     public synchronized void release() throws IOException {
/*  89 */       if (isLocked()) {
/*  90 */         verify((byte)0);
/*  91 */         this.lock.release();
/*     */       } 
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public VerifyingLockFactory(byte id, LockFactory lf, String host, int port) throws IOException {
/* 105 */     this.id = id;
/* 106 */     this.lf = lf;
/* 107 */     this.host = host;
/* 108 */     this.port = port;
/*     */   }
/*     */ 
/*     */   
/* 112 */   public synchronized Lock makeLock(String lockName) { return new CheckedLock(this.lf.makeLock(lockName)); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 117 */   public synchronized void clearLock(String lockName) throws IOException { this.lf.clearLock(lockName); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucene\store\VerifyingLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.ArrayUtil,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class ArrayUtil
/*     */ {
/*  30 */   public static int getNextSize(int targetSize) { return (targetSize >> 3) + ((targetSize < 9) ? 3 : 6) + targetSize; }
/*     */ 
/*     */   
/*     */   public static int getShrinkSize(int currentSize, int targetSize) {
/*  34 */     int newSize = getNextSize(targetSize);
/*     */ 
/*     */ 
/*     */     
/*  38 */     if (newSize < currentSize / 2) {
/*  39 */       return newSize;
/*     */     }
/*  41 */     return currentSize;
/*     */   }
/*     */   
/*     */   public static int[] grow(int[] array, int minSize) {
/*  45 */     if (array.length < minSize) {
/*  46 */       int[] newArray = new int[getNextSize(minSize)];
/*  47 */       System.arraycopy(array, 0, newArray, 0, array.length);
/*  48 */       return newArray;
/*     */     } 
/*  50 */     return array;
/*     */   }
/*     */ 
/*     */   
/*  54 */   public static int[] grow(int[] array) { return grow(array, 1 + array.length); }
/*     */ 
/*     */   
/*     */   public static int[] shrink(int[] array, int targetSize) {
/*  58 */     int newSize = getShrinkSize(array.length, targetSize);
/*  59 */     if (newSize != array.length) {
/*  60 */       int[] newArray = new int[newSize];
/*  61 */       System.arraycopy(array, 0, newArray, 0, newSize);
/*  62 */       return newArray;
/*     */     } 
/*  64 */     return array;
/*     */   }
/*     */   
/*     */   public static long[] grow(long[] array, int minSize) {
/*  68 */     if (array.length < minSize) {
/*  69 */       long[] newArray = new long[getNextSize(minSize)];
/*  70 */       System.arraycopy(array, 0, newArray, 0, array.length);
/*  71 */       return newArray;
/*     */     } 
/*  73 */     return array;
/*     */   }
/*     */ 
/*     */   
/*  77 */   public static long[] grow(long[] array) { return grow(array, 1 + array.length); }
/*     */ 
/*     */   
/*     */   public static long[] shrink(long[] array, int targetSize) {
/*  81 */     int newSize = getShrinkSize(array.length, targetSize);
/*  82 */     if (newSize != array.length) {
/*  83 */       long[] newArray = new long[newSize];
/*  84 */       System.arraycopy(array, 0, newArray, 0, newSize);
/*  85 */       return newArray;
/*     */     } 
/*  87 */     return array;
/*     */   }
/*     */   
/*     */   public static byte[] grow(byte[] array, int minSize) {
/*  91 */     if (array.length < minSize) {
/*  92 */       byte[] newArray = new byte[getNextSize(minSize)];
/*  93 */       System.arraycopy(array, 0, newArray, 0, array.length);
/*  94 */       return newArray;
/*     */     } 
/*  96 */     return array;
/*     */   }
/*     */ 
/*     */   
/* 100 */   public static byte[] grow(byte[] array) { return grow(array, 1 + array.length); }
/*     */ 
/*     */   
/*     */   public static byte[] shrink(byte[] array, int targetSize) {
/* 104 */     int newSize = getShrinkSize(array.length, targetSize);
/* 105 */     if (newSize != array.length) {
/* 106 */       byte[] newArray = new byte[newSize];
/* 107 */       System.arraycopy(array, 0, newArray, 0, newSize);
/* 108 */       return newArray;
/*     */     } 
/* 110 */     return array;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public static int hashCode(char[] array, int start, int end) {
/* 116 */     int code = 0;
/* 117 */     for (int i = end - 1; i >= start; i--)
/* 118 */       code = code * 31 + array[i]; 
/* 119 */     return code;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public static int hashCode(byte[] array, int start, int end) {
/* 125 */     int code = 0;
/* 126 */     for (int i = end - 1; i >= start; i--)
/* 127 */       code = code * 31 + array[i]; 
/* 128 */     return code;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\ArrayUtil.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.BitUtil,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BitUtil
/*     */ {
/*     */   public static int pop(long x) {
/*  42 */     x -= x >>> 1L & 0x5555555555555555L;
/*  43 */     x = (x & 0x3333333333333333L) + (x >>> 2L & 0x3333333333333333L);
/*  44 */     x = x + (x >>> 4L) & 0xF0F0F0F0F0F0F0FL;
/*  45 */     x += x >>> 8L;
/*  46 */     x += x >>> 16L;
/*  47 */     x += x >>> 32L;
/*  48 */     return (int)x & 0x7F;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long pop_array(long[] A, int wordOffset, int numWords) {
/*  67 */     int n = wordOffset + numWords;
/*  68 */     long tot = 0L, tot8 = 0L;
/*  69 */     long ones = 0L, twos = 0L, fours = 0L;
/*     */     
/*     */     int i;
/*  72 */     for (i = wordOffset; i <= n - 8; i += 8) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  83 */       long b = A[i], c = A[i + 1];
/*  84 */       long u = ones ^ b;
/*  85 */       long twosA = ones & b | u & c;
/*  86 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/*  90 */       long b = A[i + 2], c = A[i + 3];
/*  91 */       long u = ones ^ b;
/*  92 */       long twosB = ones & b | u & c;
/*  93 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/*  97 */       long u = twos ^ twosA;
/*  98 */       long foursA = twos & twosA | u & twosB;
/*  99 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */       
/* 103 */       long b = A[i + 4], c = A[i + 5];
/* 104 */       long u = ones ^ b;
/* 105 */       twosA = ones & b | u & c;
/* 106 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 110 */       long b = A[i + 6], c = A[i + 7];
/* 111 */       long u = ones ^ b;
/* 112 */       twosB = ones & b | u & c;
/* 113 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 117 */       long u = twos ^ twosA;
/* 118 */       long foursB = twos & twosA | u & twosB;
/* 119 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 124 */       long u = fours ^ foursA;
/* 125 */       long eights = fours & foursA | u & foursB;
/* 126 */       fours = u ^ foursB;
/*     */       
/* 128 */       tot8 += pop(eights);
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 137 */     if (i <= n - 4) {
/*     */ 
/*     */       
/* 140 */       long b = A[i], c = A[i + 1];
/* 141 */       long u = ones ^ b;
/* 142 */       long twosA = ones & b | u & c;
/* 143 */       ones = u ^ c;
/*     */ 
/*     */       
/* 146 */       long b = A[i + 2], c = A[i + 3];
/* 147 */       long u = ones ^ b;
/* 148 */       long twosB = ones & b | u & c;
/* 149 */       ones = u ^ c;
/*     */ 
/*     */       
/* 152 */       long u = twos ^ twosA;
/* 153 */       long foursA = twos & twosA | u & twosB;
/* 154 */       twos = u ^ twosB;
/*     */       
/* 156 */       long eights = fours & foursA;
/* 157 */       fours ^= foursA;
/*     */       
/* 159 */       tot8 += pop(eights);
/* 160 */       i += 4;
/*     */     } 
/*     */     
/* 163 */     if (i <= n - 2) {
/* 164 */       long b = A[i], c = A[i + 1];
/* 165 */       long u = ones ^ b;
/* 166 */       long twosA = ones & b | u & c;
/* 167 */       ones = u ^ c;
/*     */       
/* 169 */       long foursA = twos & twosA;
/* 170 */       twos ^= twosA;
/*     */       
/* 172 */       long eights = fours & foursA;
/* 173 */       fours ^= foursA;
/*     */       
/* 175 */       tot8 += pop(eights);
/* 176 */       i += 2;
/*     */     } 
/*     */     
/* 179 */     if (i < n) {
/* 180 */       tot += pop(A[i]);
/*     */     }
/*     */     
/* 183 */     tot += ((pop(fours) << 2) + (pop(twos) << 1) + pop(ones)) + (tot8 << 3L);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 188 */     return tot;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long pop_intersect(long[] A, long[] B, int wordOffset, int numWords) {
/* 196 */     int n = wordOffset + numWords;
/* 197 */     long tot = 0L, tot8 = 0L;
/* 198 */     long ones = 0L, twos = 0L, fours = 0L;
/*     */     
/*     */     int i;
/* 201 */     for (i = wordOffset; i <= n - 8; i += 8) {
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 206 */       long b = A[i] & B[i], c = A[i + 1] & B[i + 1];
/* 207 */       long u = ones ^ b;
/* 208 */       long twosA = ones & b | u & c;
/* 209 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 213 */       long b = A[i + 2] & B[i + 2], c = A[i + 3] & B[i + 3];
/* 214 */       long u = ones ^ b;
/* 215 */       long twosB = ones & b | u & c;
/* 216 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 220 */       long u = twos ^ twosA;
/* 221 */       long foursA = twos & twosA | u & twosB;
/* 222 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */       
/* 226 */       long b = A[i + 4] & B[i + 4], c = A[i + 5] & B[i + 5];
/* 227 */       long u = ones ^ b;
/* 228 */       twosA = ones & b | u & c;
/* 229 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 233 */       long b = A[i + 6] & B[i + 6], c = A[i + 7] & B[i + 7];
/* 234 */       long u = ones ^ b;
/* 235 */       twosB = ones & b | u & c;
/* 236 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 240 */       long u = twos ^ twosA;
/* 241 */       long foursB = twos & twosA | u & twosB;
/* 242 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 247 */       long u = fours ^ foursA;
/* 248 */       long eights = fours & foursA | u & foursB;
/* 249 */       fours = u ^ foursB;
/*     */       
/* 251 */       tot8 += pop(eights);
/*     */     } 
/*     */ 
/*     */     
/* 255 */     if (i <= n - 4) {
/*     */ 
/*     */       
/* 258 */       long b = A[i] & B[i], c = A[i + 1] & B[i + 1];
/* 259 */       long u = ones ^ b;
/* 260 */       long twosA = ones & b | u & c;
/* 261 */       ones = u ^ c;
/*     */ 
/*     */       
/* 264 */       long b = A[i + 2] & B[i + 2], c = A[i + 3] & B[i + 3];
/* 265 */       long u = ones ^ b;
/* 266 */       long twosB = ones & b | u & c;
/* 267 */       ones = u ^ c;
/*     */ 
/*     */       
/* 270 */       long u = twos ^ twosA;
/* 271 */       long foursA = twos & twosA | u & twosB;
/* 272 */       twos = u ^ twosB;
/*     */       
/* 274 */       long eights = fours & foursA;
/* 275 */       fours ^= foursA;
/*     */       
/* 277 */       tot8 += pop(eights);
/* 278 */       i += 4;
/*     */     } 
/*     */     
/* 281 */     if (i <= n - 2) {
/* 282 */       long b = A[i] & B[i], c = A[i + 1] & B[i + 1];
/* 283 */       long u = ones ^ b;
/* 284 */       long twosA = ones & b | u & c;
/* 285 */       ones = u ^ c;
/*     */       
/* 287 */       long foursA = twos & twosA;
/* 288 */       twos ^= twosA;
/*     */       
/* 290 */       long eights = fours & foursA;
/* 291 */       fours ^= foursA;
/*     */       
/* 293 */       tot8 += pop(eights);
/* 294 */       i += 2;
/*     */     } 
/*     */     
/* 297 */     if (i < n) {
/* 298 */       tot += pop(A[i] & B[i]);
/*     */     }
/*     */     
/* 301 */     tot += ((pop(fours) << 2) + (pop(twos) << 1) + pop(ones)) + (tot8 << 3L);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 306 */     return tot;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long pop_union(long[] A, long[] B, int wordOffset, int numWords) {
/* 314 */     int n = wordOffset + numWords;
/* 315 */     long tot = 0L, tot8 = 0L;
/* 316 */     long ones = 0L, twos = 0L, fours = 0L;
/*     */     
/*     */     int i;
/* 319 */     for (i = wordOffset; i <= n - 8; i += 8) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 330 */       long b = A[i] | B[i], c = A[i + 1] | B[i + 1];
/* 331 */       long u = ones ^ b;
/* 332 */       long twosA = ones & b | u & c;
/* 333 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 337 */       long b = A[i + 2] | B[i + 2], c = A[i + 3] | B[i + 3];
/* 338 */       long u = ones ^ b;
/* 339 */       long twosB = ones & b | u & c;
/* 340 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 344 */       long u = twos ^ twosA;
/* 345 */       long foursA = twos & twosA | u & twosB;
/* 346 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */       
/* 350 */       long b = A[i + 4] | B[i + 4], c = A[i + 5] | B[i + 5];
/* 351 */       long u = ones ^ b;
/* 352 */       twosA = ones & b | u & c;
/* 353 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 357 */       long b = A[i + 6] | B[i + 6], c = A[i + 7] | B[i + 7];
/* 358 */       long u = ones ^ b;
/* 359 */       twosB = ones & b | u & c;
/* 360 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 364 */       long u = twos ^ twosA;
/* 365 */       long foursB = twos & twosA | u & twosB;
/* 366 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 371 */       long u = fours ^ foursA;
/* 372 */       long eights = fours & foursA | u & foursB;
/* 373 */       fours = u ^ foursB;
/*     */       
/* 375 */       tot8 += pop(eights);
/*     */     } 
/*     */ 
/*     */     
/* 379 */     if (i <= n - 4) {
/*     */ 
/*     */       
/* 382 */       long b = A[i] | B[i], c = A[i + 1] | B[i + 1];
/* 383 */       long u = ones ^ b;
/* 384 */       long twosA = ones & b | u & c;
/* 385 */       ones = u ^ c;
/*     */ 
/*     */       
/* 388 */       long b = A[i + 2] | B[i + 2], c = A[i + 3] | B[i + 3];
/* 389 */       long u = ones ^ b;
/* 390 */       long twosB = ones & b | u & c;
/* 391 */       ones = u ^ c;
/*     */ 
/*     */       
/* 394 */       long u = twos ^ twosA;
/* 395 */       long foursA = twos & twosA | u & twosB;
/* 396 */       twos = u ^ twosB;
/*     */       
/* 398 */       long eights = fours & foursA;
/* 399 */       fours ^= foursA;
/*     */       
/* 401 */       tot8 += pop(eights);
/* 402 */       i += 4;
/*     */     } 
/*     */     
/* 405 */     if (i <= n - 2) {
/* 406 */       long b = A[i] | B[i], c = A[i + 1] | B[i + 1];
/* 407 */       long u = ones ^ b;
/* 408 */       long twosA = ones & b | u & c;
/* 409 */       ones = u ^ c;
/*     */       
/* 411 */       long foursA = twos & twosA;
/* 412 */       twos ^= twosA;
/*     */       
/* 414 */       long eights = fours & foursA;
/* 415 */       fours ^= foursA;
/*     */       
/* 417 */       tot8 += pop(eights);
/* 418 */       i += 2;
/*     */     } 
/*     */     
/* 421 */     if (i < n) {
/* 422 */       tot += pop(A[i] | B[i]);
/*     */     }
/*     */     
/* 425 */     tot += ((pop(fours) << 2) + (pop(twos) << 1) + pop(ones)) + (tot8 << 3L);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 430 */     return tot;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long pop_andnot(long[] A, long[] B, int wordOffset, int numWords) {
/* 438 */     int n = wordOffset + numWords;
/* 439 */     long tot = 0L, tot8 = 0L;
/* 440 */     long ones = 0L, twos = 0L, fours = 0L;
/*     */     
/*     */     int i;
/* 443 */     for (i = wordOffset; i <= n - 8; i += 8) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 454 */       long b = A[i] & (B[i] ^ 0xFFFFFFFFFFFFFFFFL), c = A[i + 1] & (B[i + 1] ^ 0xFFFFFFFFFFFFFFFFL);
/* 455 */       long u = ones ^ b;
/* 456 */       long twosA = ones & b | u & c;
/* 457 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 461 */       long b = A[i + 2] & (B[i + 2] ^ 0xFFFFFFFFFFFFFFFFL), c = A[i + 3] & (B[i + 3] ^ 0xFFFFFFFFFFFFFFFFL);
/* 462 */       long u = ones ^ b;
/* 463 */       long twosB = ones & b | u & c;
/* 464 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 468 */       long u = twos ^ twosA;
/* 469 */       long foursA = twos & twosA | u & twosB;
/* 470 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */       
/* 474 */       long b = A[i + 4] & (B[i + 4] ^ 0xFFFFFFFFFFFFFFFFL), c = A[i + 5] & (B[i + 5] ^ 0xFFFFFFFFFFFFFFFFL);
/* 475 */       long u = ones ^ b;
/* 476 */       twosA = ones & b | u & c;
/* 477 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 481 */       long b = A[i + 6] & (B[i + 6] ^ 0xFFFFFFFFFFFFFFFFL), c = A[i + 7] & (B[i + 7] ^ 0xFFFFFFFFFFFFFFFFL);
/* 482 */       long u = ones ^ b;
/* 483 */       twosB = ones & b | u & c;
/* 484 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 488 */       long u = twos ^ twosA;
/* 489 */       long foursB = twos & twosA | u & twosB;
/* 490 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 495 */       long u = fours ^ foursA;
/* 496 */       long eights = fours & foursA | u & foursB;
/* 497 */       fours = u ^ foursB;
/*     */       
/* 499 */       tot8 += pop(eights);
/*     */     } 
/*     */ 
/*     */     
/* 503 */     if (i <= n - 4) {
/*     */ 
/*     */       
/* 506 */       long b = A[i] & (B[i] ^ 0xFFFFFFFFFFFFFFFFL), c = A[i + 1] & (B[i + 1] ^ 0xFFFFFFFFFFFFFFFFL);
/* 507 */       long u = ones ^ b;
/* 508 */       long twosA = ones & b | u & c;
/* 509 */       ones = u ^ c;
/*     */ 
/*     */       
/* 512 */       long b = A[i + 2] & (B[i + 2] ^ 0xFFFFFFFFFFFFFFFFL), c = A[i + 3] & (B[i + 3] ^ 0xFFFFFFFFFFFFFFFFL);
/* 513 */       long u = ones ^ b;
/* 514 */       long twosB = ones & b | u & c;
/* 515 */       ones = u ^ c;
/*     */ 
/*     */       
/* 518 */       long u = twos ^ twosA;
/* 519 */       long foursA = twos & twosA | u & twosB;
/* 520 */       twos = u ^ twosB;
/*     */       
/* 522 */       long eights = fours & foursA;
/* 523 */       fours ^= foursA;
/*     */       
/* 525 */       tot8 += pop(eights);
/* 526 */       i += 4;
/*     */     } 
/*     */     
/* 529 */     if (i <= n - 2) {
/* 530 */       long b = A[i] & (B[i] ^ 0xFFFFFFFFFFFFFFFFL), c = A[i + 1] & (B[i + 1] ^ 0xFFFFFFFFFFFFFFFFL);
/* 531 */       long u = ones ^ b;
/* 532 */       long twosA = ones & b | u & c;
/* 533 */       ones = u ^ c;
/*     */       
/* 535 */       long foursA = twos & twosA;
/* 536 */       twos ^= twosA;
/*     */       
/* 538 */       long eights = fours & foursA;
/* 539 */       fours ^= foursA;
/*     */       
/* 541 */       tot8 += pop(eights);
/* 542 */       i += 2;
/*     */     } 
/*     */     
/* 545 */     if (i < n) {
/* 546 */       tot += pop(A[i] & (B[i] ^ 0xFFFFFFFFFFFFFFFFL));
/*     */     }
/*     */     
/* 549 */     tot += ((pop(fours) << 2) + (pop(twos) << 1) + pop(ones)) + (tot8 << 3L);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 554 */     return tot;
/*     */   }
/*     */   
/*     */   public static long pop_xor(long[] A, long[] B, int wordOffset, int numWords) {
/* 558 */     int n = wordOffset + numWords;
/* 559 */     long tot = 0L, tot8 = 0L;
/* 560 */     long ones = 0L, twos = 0L, fours = 0L;
/*     */     
/*     */     int i;
/* 563 */     for (i = wordOffset; i <= n - 8; i += 8) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 574 */       long b = A[i] ^ B[i], c = A[i + 1] ^ B[i + 1];
/* 575 */       long u = ones ^ b;
/* 576 */       long twosA = ones & b | u & c;
/* 577 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 581 */       long b = A[i + 2] ^ B[i + 2], c = A[i + 3] ^ B[i + 3];
/* 582 */       long u = ones ^ b;
/* 583 */       long twosB = ones & b | u & c;
/* 584 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 588 */       long u = twos ^ twosA;
/* 589 */       long foursA = twos & twosA | u & twosB;
/* 590 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */       
/* 594 */       long b = A[i + 4] ^ B[i + 4], c = A[i + 5] ^ B[i + 5];
/* 595 */       long u = ones ^ b;
/* 596 */       twosA = ones & b | u & c;
/* 597 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 601 */       long b = A[i + 6] ^ B[i + 6], c = A[i + 7] ^ B[i + 7];
/* 602 */       long u = ones ^ b;
/* 603 */       twosB = ones & b | u & c;
/* 604 */       ones = u ^ c;
/*     */ 
/*     */ 
/*     */       
/* 608 */       long u = twos ^ twosA;
/* 609 */       long foursB = twos & twosA | u & twosB;
/* 610 */       twos = u ^ twosB;
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 615 */       long u = fours ^ foursA;
/* 616 */       long eights = fours & foursA | u & foursB;
/* 617 */       fours = u ^ foursB;
/*     */       
/* 619 */       tot8 += pop(eights);
/*     */     } 
/*     */ 
/*     */     
/* 623 */     if (i <= n - 4) {
/*     */ 
/*     */       
/* 626 */       long b = A[i] ^ B[i], c = A[i + 1] ^ B[i + 1];
/* 627 */       long u = ones ^ b;
/* 628 */       long twosA = ones & b | u & c;
/* 629 */       ones = u ^ c;
/*     */ 
/*     */       
/* 632 */       long b = A[i + 2] ^ B[i + 2], c = A[i + 3] ^ B[i + 3];
/* 633 */       long u = ones ^ b;
/* 634 */       long twosB = ones & b | u & c;
/* 635 */       ones = u ^ c;
/*     */ 
/*     */       
/* 638 */       long u = twos ^ twosA;
/* 639 */       long foursA = twos & twosA | u & twosB;
/* 640 */       twos = u ^ twosB;
/*     */       
/* 642 */       long eights = fours & foursA;
/* 643 */       fours ^= foursA;
/*     */       
/* 645 */       tot8 += pop(eights);
/* 646 */       i += 4;
/*     */     } 
/*     */     
/* 649 */     if (i <= n - 2) {
/* 650 */       long b = A[i] ^ B[i], c = A[i + 1] ^ B[i + 1];
/* 651 */       long u = ones ^ b;
/* 652 */       long twosA = ones & b | u & c;
/* 653 */       ones = u ^ c;
/*     */       
/* 655 */       long foursA = twos & twosA;
/* 656 */       twos ^= twosA;
/*     */       
/* 658 */       long eights = fours & foursA;
/* 659 */       fours ^= foursA;
/*     */       
/* 661 */       tot8 += pop(eights);
/* 662 */       i += 2;
/*     */     } 
/*     */     
/* 665 */     if (i < n) {
/* 666 */       tot += pop(A[i] ^ B[i]);
/*     */     }
/*     */     
/* 669 */     tot += ((pop(fours) << 2) + (pop(twos) << 1) + pop(ones)) + (tot8 << 3L);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 674 */     return tot;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 688 */   public static final byte[] ntzTable = new byte[] { 8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static int ntz(long val) {
/* 704 */     int lower = (int)val;
/* 705 */     int lowByte = lower & 0xFF;
/* 706 */     if (lowByte != 0) return ntzTable[lowByte];
/*     */     
/* 708 */     if (lower != 0) {
/* 709 */       lowByte = lower >>> 8 & 0xFF;
/* 710 */       if (lowByte != 0) return ntzTable[lowByte] + 8; 
/* 711 */       lowByte = lower >>> 16 & 0xFF;
/* 712 */       if (lowByte != 0) return ntzTable[lowByte] + 16;
/*     */ 
/*     */       
/* 715 */       return ntzTable[lower >>> 24] + 24;
/*     */     } 
/*     */     
/* 718 */     int upper = (int)(val >> 32L);
/* 719 */     lowByte = upper & 0xFF;
/* 720 */     if (lowByte != 0) return ntzTable[lowByte] + 32; 
/* 721 */     lowByte = upper >>> 8 & 0xFF;
/* 722 */     if (lowByte != 0) return ntzTable[lowByte] + 40; 
/* 723 */     lowByte = upper >>> 16 & 0xFF;
/* 724 */     if (lowByte != 0) return ntzTable[lowByte] + 48;
/*     */ 
/*     */     
/* 727 */     return ntzTable[upper >>> 24] + 56;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static int ntz2(long x) {
/* 736 */     int n = 0;
/* 737 */     int y = (int)x;
/* 738 */     if (y == 0) { n += 32; y = (int)(x >>> 32L); }
/* 739 */      if ((y & 0xFFFF) == 0) { n += 16; y >>>= 16; }
/* 740 */      if ((y & 0xFF) == 0) { n += 8; y >>>= 8; }
/* 741 */      return ntzTable[y & 0xFF] + n;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static int ntz3(long x) {
/* 751 */     int n = 1;
/*     */ 
/*     */     
/* 754 */     int y = (int)x;
/* 755 */     if (y == 0) { n += 32; y = (int)(x >>> 32L); }
/* 756 */      if ((y & 0xFFFF) == 0) { n += 16; y >>>= 16; }
/* 757 */      if ((y & 0xFF) == 0) { n += 8; y >>>= 8; }
/* 758 */      if ((y & 0xF) == 0) { n += 4; y >>>= 4; }
/* 759 */      if ((y & 0x3) == 0) { n += 2; y >>>= 2; }
/* 760 */      return n - (y & 0x1);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 766 */   public static boolean isPowerOfTwo(int v) { return ((v & v - 1) == 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 771 */   public static boolean isPowerOfTwo(long v) { return ((v & v - 1L) == 0L); }
/*     */ 
/*     */ 
/*     */   
/*     */   public static int nextHighestPowerOfTwo(int v) {
/* 776 */     v--;
/* 777 */     v |= v >> 1;
/* 778 */     v |= v >> 2;
/* 779 */     v |= v >> 4;
/* 780 */     v |= v >> 8;
/* 781 */     v |= v >> 16;
/* 782 */     v++;
/* 783 */     return v;
/*     */   }
/*     */ 
/*     */   
/*     */   public static long nextHighestPowerOfTwo(long v) {
/* 788 */     v--;
/* 789 */     v |= v >> 1L;
/* 790 */     v |= v >> 2L;
/* 791 */     v |= v >> 4L;
/* 792 */     v |= v >> 8L;
/* 793 */     v |= v >> 16L;
/* 794 */     v |= v >> 32L;
/* 795 */     v++;
/* 796 */     return v;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\BitUtil.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.BitVector,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class BitVector
/*     */ {
/*     */   private byte[] bits;
/*     */   private int size;
/*  42 */   private int count = -1;
/*     */ 
/*     */   
/*     */   public BitVector(int n) {
/*  46 */     this.size = n;
/*  47 */     this.bits = new byte[(this.size >> 3) + 1];
/*     */   }
/*     */ 
/*     */   
/*     */   public final void set(int bit) {
/*  52 */     if (bit >= this.size) {
/*  53 */       throw new ArrayIndexOutOfBoundsException(bit);
/*     */     }
/*  55 */     this.bits[bit >> 3] = (byte)(this.bits[bit >> 3] | 1 << (bit & 0x7));
/*  56 */     this.count = -1;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean getAndSet(int bit) {
/*  62 */     if (bit >= this.size) {
/*  63 */       throw new ArrayIndexOutOfBoundsException(bit);
/*     */     }
/*  65 */     int pos = bit >> 3;
/*  66 */     int v = this.bits[pos];
/*  67 */     int flag = 1 << (bit & 0x7);
/*  68 */     if ((flag & v) != 0) {
/*  69 */       return true;
/*     */     }
/*  71 */     this.bits[pos] = (byte)(v | flag);
/*  72 */     if (this.count != -1)
/*  73 */       this.count++; 
/*  74 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void clear(int bit) {
/*  80 */     if (bit >= this.size) {
/*  81 */       throw new ArrayIndexOutOfBoundsException(bit);
/*     */     }
/*  83 */     this.bits[bit >> 3] = (byte)(this.bits[bit >> 3] & (1 << (bit & 0x7) ^ 0xFFFFFFFF));
/*  84 */     this.count = -1;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean get(int bit) {
/*  90 */     if (bit >= this.size) {
/*  91 */       throw new ArrayIndexOutOfBoundsException(bit);
/*     */     }
/*  93 */     return ((this.bits[bit >> 3] & 1 << (bit & 0x7)) != 0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  99 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int count() {
/* 107 */     if (this.count == -1) {
/* 108 */       int c = 0;
/* 109 */       int end = this.bits.length;
/* 110 */       for (int i = 0; i < end; i++)
/* 111 */         c += BYTE_COUNTS[this.bits[i] & 0xFF]; 
/* 112 */       this.count = c;
/*     */     } 
/* 114 */     return this.count;
/*     */   }
/*     */   
/* 117 */   private static final byte[] BYTE_COUNTS = new byte[] { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void write(Directory d, String name) throws IOException {
/* 141 */     IndexOutput output = d.createOutput(name);
/*     */     try {
/* 143 */       if (isSparse()) {
/* 144 */         writeDgaps(output);
/*     */       } else {
/* 146 */         writeBits(output);
/*     */       } 
/*     */     } finally {
/* 149 */       output.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void writeBits(IndexOutput output) throws IOException {
/* 155 */     output.writeInt(size());
/* 156 */     output.writeInt(count());
/* 157 */     output.writeBytes(this.bits, this.bits.length);
/*     */   }
/*     */ 
/*     */   
/*     */   private void writeDgaps(IndexOutput output) throws IOException {
/* 162 */     output.writeInt(-1);
/* 163 */     output.writeInt(size());
/* 164 */     output.writeInt(count());
/* 165 */     int last = 0;
/* 166 */     int n = count();
/* 167 */     int m = this.bits.length;
/* 168 */     for (int i = 0; i < m && n > 0; i++) {
/* 169 */       if (this.bits[i] != 0) {
/* 170 */         output.writeVInt(i - last);
/* 171 */         output.writeByte(this.bits[i]);
/* 172 */         last = i;
/* 173 */         n -= BYTE_COUNTS[this.bits[i] & 0xFF];
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean isSparse() {
/* 187 */     int factor = 10;
/* 188 */     if (this.bits.length < 128) return (factor * (4 + 16 * count()) < size()); 
/* 189 */     if (this.bits.length < 16384) return (factor * (4 + 24 * count()) < size()); 
/* 190 */     if (this.bits.length < 2097152) return (factor * (4 + 32 * count()) < size()); 
/* 191 */     if (this.bits.length < 268435456) return (factor * (4 + 40 * count()) < size()); 
/* 192 */     return (factor * (4 + 48 * count()) < size());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BitVector(Directory d, String name) throws IOException {
/* 199 */     IndexInput input = d.openInput(name);
/*     */     try {
/* 201 */       this.size = input.readInt();
/* 202 */       if (this.size == -1) {
/* 203 */         readDgaps(input);
/*     */       } else {
/* 205 */         readBits(input);
/*     */       } 
/*     */     } finally {
/* 208 */       input.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void readBits(IndexInput input) throws IOException {
/* 214 */     this.count = input.readInt();
/* 215 */     this.bits = new byte[(this.size >> 3) + 1];
/* 216 */     input.readBytes(this.bits, 0, this.bits.length);
/*     */   }
/*     */ 
/*     */   
/*     */   private void readDgaps(IndexInput input) throws IOException {
/* 221 */     this.size = input.readInt();
/* 222 */     this.count = input.readInt();
/* 223 */     this.bits = new byte[(this.size >> 3) + 1];
/* 224 */     int last = 0;
/* 225 */     int n = count();
/* 226 */     while (n > 0) {
/* 227 */       last += input.readVInt();
/* 228 */       this.bits[last] = input.readByte();
/* 229 */       n -= BYTE_COUNTS[this.bits[last] & 0xFF];
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\BitVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.CloseableThreadLocal,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ import java.lang.ref.WeakReference;
/*    */ import java.util.HashMap;
/*    */ import java.util.Iterator;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CloseableThreadLocal
/*    */ {
/* 47 */   private ThreadLocal t = new ThreadLocal();
/*    */   
/* 49 */   private Map hardRefs = new HashMap();
/*    */   static final boolean $assertionsDisabled;
/*    */   
/* 52 */   protected Object initialValue() { return null; }
/*    */ 
/*    */   
/*    */   public Object get() {
/* 56 */     WeakReference weakRef = this.t.get();
/* 57 */     if (weakRef == null) {
/* 58 */       Object iv = initialValue();
/* 59 */       if (iv != null) {
/* 60 */         set(iv);
/* 61 */         return iv;
/*    */       } 
/* 63 */       return null;
/*    */     } 
/* 65 */     Object v = weakRef.get();
/*    */ 
/*    */     
/* 68 */     assert v != null;
/* 69 */     return v;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public void set(Object object) {
/* 75 */     this.t.set(new WeakReference(object));
/*    */     
/* 77 */     synchronized (this.hardRefs) {
/* 78 */       this.hardRefs.put(Thread.currentThread(), object);
/*    */ 
/*    */       
/* 81 */       Iterator it = this.hardRefs.keySet().iterator();
/* 82 */       while (it.hasNext()) {
/* 83 */         Thread t = it.next();
/* 84 */         if (!t.isAlive()) {
/* 85 */           it.remove();
/*    */         }
/*    */       } 
/*    */     } 
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public void close() {
/* 94 */     this.hardRefs = null;
/* 95 */     this.t = null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\CloseableThreadLocal.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.Constants,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class Constants
/*    */ {
/* 31 */   public static final String JAVA_VERSION = System.getProperty(""java.version"");
/*    */   
/* 33 */   public static final boolean JAVA_1_1 = JAVA_VERSION.startsWith(""1.1."");
/*    */   
/* 35 */   public static final boolean JAVA_1_2 = JAVA_VERSION.startsWith(""1.2."");
/*    */   
/* 37 */   public static final boolean JAVA_1_3 = JAVA_VERSION.startsWith(""1.3."");
/*    */ 
/*    */   
/* 40 */   public static final String OS_NAME = System.getProperty(""os.name"");
/*    */   
/* 42 */   public static final boolean LINUX = OS_NAME.startsWith(""Linux"");
/*    */   
/* 44 */   public static final boolean WINDOWS = OS_NAME.startsWith(""Windows"");
/*    */   
/* 46 */   public static final boolean SUN_OS = OS_NAME.startsWith(""SunOS"");
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\Constants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.DocIdBitSet,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.search.DocIdSet;
/*    */ import org.apache.lucene.search.DocIdSetIterator;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DocIdBitSet
/*    */   extends DocIdSet
/*    */ {
/*    */   private BitSet bitSet;
/*    */   static Class class$org$apache$lucene$util$DocIdBitSet;
/*    */   
/* 30 */   public DocIdBitSet(BitSet bitSet) { this.bitSet = bitSet; }
/*    */ 
/*    */ 
/*    */   
/* 34 */   public DocIdSetIterator iterator() { return new DocIdBitSetIterator(this.bitSet); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   public BitSet getBitSet() { return this.bitSet; }
/*    */   
/*    */   static Class class$(String x0) { 
/* 44 */     try { return Class.forName(x0); } catch (ClassNotFoundException x1) { throw (new NoClassDefFoundError()).initCause(x1); }
/*    */      }
/*    */   private static class DocIdBitSetIterator extends DocIdSetIterator { private int docId;
/*    */     
/*    */     DocIdBitSetIterator(BitSet bitSet) {
/* 49 */       this.bitSet = bitSet;
/* 50 */       this.docId = -1;
/*    */     }
/*    */     private BitSet bitSet; static final boolean $assertionsDisabled;
/*    */     public int doc() {
/* 54 */       assert this.docId != -1;
/* 55 */       return this.docId;
/*    */     }
/*    */ 
/*    */ 
/*    */     
/* 60 */     public boolean next() { return checkNextDocId(this.bitSet.nextSetBit(this.docId + 1)); }
/*    */ 
/*    */ 
/*    */     
/* 64 */     public boolean skipTo(int skipDocNr) { return checkNextDocId(this.bitSet.nextSetBit(skipDocNr)); }
/*    */ 
/*    */     
/*    */     private boolean checkNextDocId(int d) {
/* 68 */       if (d == -1) {
/* 69 */         this.docId = Integer.MAX_VALUE;
/* 70 */         return false;
/*    */       } 
/* 72 */       this.docId = d;
/* 73 */       return true;
/*    */     } }
/*    */ 
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\DocIdBitSet.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.OpenBitSet,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.search.DocIdSet;
/*     */ import org.apache.lucene.search.DocIdSetIterator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class OpenBitSet
/*     */   extends DocIdSet
/*     */   implements Cloneable, Serializable
/*     */ {
/*     */   protected long[] bits;
/*     */   protected int wlen;
/*     */   
/*     */   public OpenBitSet(long numBits) {
/*  89 */     this.bits = new long[bits2words(numBits)];
/*  90 */     this.wlen = this.bits.length;
/*     */   }
/*     */ 
/*     */   
/*  94 */   public OpenBitSet() { this(64L); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public OpenBitSet(long[] bits, int numWords) {
/* 111 */     this.bits = bits;
/* 112 */     this.wlen = numWords;
/*     */   }
/*     */ 
/*     */   
/* 116 */   public DocIdSetIterator iterator() { return new OpenBitSetIterator(this.bits, this.wlen); }
/*     */ 
/*     */ 
/*     */   
/* 120 */   public long capacity() { return (this.bits.length << 6); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 127 */   public long size() { return capacity(); }
/*     */ 
/*     */ 
/*     */   
/* 131 */   public boolean isEmpty() { return (cardinality() == 0L); }
/*     */ 
/*     */   
/* 134 */   public long[] getBits() { return this.bits; }
/*     */ 
/*     */   
/* 137 */   public void setBits(long[] bits) { this.bits = bits; }
/*     */ 
/*     */   
/* 140 */   public int getNumWords() { return this.wlen; }
/*     */ 
/*     */   
/* 143 */   public void setNumWords(int nWords) { this.wlen = nWords; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean get(int index) {
/* 149 */     int i = index >> 6;
/*     */ 
/*     */     
/* 152 */     if (i >= this.bits.length) return false;
/*     */     
/* 154 */     int bit = index & 0x3F;
/* 155 */     long bitmask = 1L << bit;
/* 156 */     return ((this.bits[i] & bitmask) != 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean fastGet(int index) {
/* 164 */     int i = index >> 6;
/*     */ 
/*     */     
/* 167 */     int bit = index & 0x3F;
/* 168 */     long bitmask = 1L << bit;
/* 169 */     return ((this.bits[i] & bitmask) != 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean get(long index) {
/* 177 */     int i = (int)(index >> 6L);
/* 178 */     if (i >= this.bits.length) return false; 
/* 179 */     int bit = (int)index & 0x3F;
/* 180 */     long bitmask = 1L << bit;
/* 181 */     return ((this.bits[i] & bitmask) != 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean fastGet(long index) {
/* 188 */     int i = (int)(index >> 6L);
/* 189 */     int bit = (int)index & 0x3F;
/* 190 */     long bitmask = 1L << bit;
/* 191 */     return ((this.bits[i] & bitmask) != 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getBit(int index) {
/* 211 */     int i = index >> 6;
/* 212 */     int bit = index & 0x3F;
/* 213 */     return (int)(this.bits[i] >>> bit) & 0x1;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void set(long index) {
/* 228 */     int wordNum = expandingWordNum(index);
/* 229 */     int bit = (int)index & 0x3F;
/* 230 */     long bitmask = 1L << bit;
/* 231 */     this.bits[wordNum] = this.bits[wordNum] | bitmask;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void fastSet(int index) {
/* 239 */     int wordNum = index >> 6;
/* 240 */     int bit = index & 0x3F;
/* 241 */     long bitmask = 1L << bit;
/* 242 */     this.bits[wordNum] = this.bits[wordNum] | bitmask;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void fastSet(long index) {
/* 249 */     int wordNum = (int)(index >> 6L);
/* 250 */     int bit = (int)index & 0x3F;
/* 251 */     long bitmask = 1L << bit;
/* 252 */     this.bits[wordNum] = this.bits[wordNum] | bitmask;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void set(long startIndex, long endIndex) {
/* 261 */     if (endIndex <= startIndex)
/*     */       return; 
/* 263 */     int startWord = (int)(startIndex >> 6L);
/*     */ 
/*     */ 
/*     */     
/* 267 */     int endWord = expandingWordNum(endIndex - 1L);
/*     */     
/* 269 */     long startmask = -1L << (int)startIndex;
/* 270 */     long endmask = -1L >>> (int)-endIndex;
/*     */     
/* 272 */     if (startWord == endWord) {
/* 273 */       this.bits[startWord] = this.bits[startWord] | startmask & endmask;
/*     */       
/*     */       return;
/*     */     } 
/* 277 */     this.bits[startWord] = this.bits[startWord] | startmask;
/* 278 */     Arrays.fill(this.bits, startWord + 1, endWord, -1L);
/* 279 */     this.bits[endWord] = this.bits[endWord] | endmask;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   protected int expandingWordNum(long index) {
/* 285 */     int wordNum = (int)(index >> 6L);
/* 286 */     if (wordNum >= this.wlen) {
/* 287 */       ensureCapacity(index + 1L);
/* 288 */       this.wlen = wordNum + 1;
/*     */     } 
/* 290 */     return wordNum;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void fastClear(int index) {
/* 298 */     int wordNum = index >> 6;
/* 299 */     int bit = index & 0x3F;
/* 300 */     long bitmask = 1L << bit;
/* 301 */     this.bits[wordNum] = this.bits[wordNum] & (bitmask ^ 0xFFFFFFFFFFFFFFFFL);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void fastClear(long index) {
/* 315 */     int wordNum = (int)(index >> 6L);
/* 316 */     int bit = (int)index & 0x3F;
/* 317 */     long bitmask = 1L << bit;
/* 318 */     this.bits[wordNum] = this.bits[wordNum] & (bitmask ^ 0xFFFFFFFFFFFFFFFFL);
/*     */   }
/*     */ 
/*     */   
/*     */   public void clear(long index) {
/* 323 */     int wordNum = (int)(index >> 6L);
/* 324 */     if (wordNum >= this.wlen)
/* 325 */       return;  int bit = (int)index & 0x3F;
/* 326 */     long bitmask = 1L << bit;
/* 327 */     this.bits[wordNum] = this.bits[wordNum] & (bitmask ^ 0xFFFFFFFFFFFFFFFFL);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void clear(long startIndex, long endIndex) {
/* 336 */     if (endIndex <= startIndex)
/*     */       return; 
/* 338 */     int startWord = (int)(startIndex >> 6L);
/* 339 */     if (startWord >= this.wlen) {
/*     */       return;
/*     */     }
/*     */     
/* 343 */     int endWord = (int)(endIndex - 1L >> 6L);
/*     */     
/* 345 */     long startmask = -1L << (int)startIndex;
/* 346 */     long endmask = -1L >>> (int)-endIndex;
/*     */ 
/*     */     
/* 349 */     startmask ^= 0xFFFFFFFFFFFFFFFFL;
/* 350 */     endmask ^= 0xFFFFFFFFFFFFFFFFL;
/*     */     
/* 352 */     if (startWord == endWord) {
/* 353 */       this.bits[startWord] = this.bits[startWord] & (startmask | endmask);
/*     */       
/*     */       return;
/*     */     } 
/* 357 */     this.bits[startWord] = this.bits[startWord] & startmask;
/*     */     
/* 359 */     int middle = Math.min(this.wlen, endWord);
/* 360 */     Arrays.fill(this.bits, startWord + 1, middle, 0L);
/* 361 */     if (endWord < this.wlen) {
/* 362 */       this.bits[endWord] = this.bits[endWord] & endmask;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean getAndSet(int index) {
/* 372 */     int wordNum = index >> 6;
/* 373 */     int bit = index & 0x3F;
/* 374 */     long bitmask = 1L << bit;
/* 375 */     boolean val = ((this.bits[wordNum] & bitmask) != 0L);
/* 376 */     this.bits[wordNum] = this.bits[wordNum] | bitmask;
/* 377 */     return val;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean getAndSet(long index) {
/* 384 */     int wordNum = (int)(index >> 6L);
/* 385 */     int bit = (int)index & 0x3F;
/* 386 */     long bitmask = 1L << bit;
/* 387 */     boolean val = ((this.bits[wordNum] & bitmask) != 0L);
/* 388 */     this.bits[wordNum] = this.bits[wordNum] | bitmask;
/* 389 */     return val;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void fastFlip(int index) {
/* 396 */     int wordNum = index >> 6;
/* 397 */     int bit = index & 0x3F;
/* 398 */     long bitmask = 1L << bit;
/* 399 */     this.bits[wordNum] = this.bits[wordNum] ^ bitmask;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void fastFlip(long index) {
/* 406 */     int wordNum = (int)(index >> 6L);
/* 407 */     int bit = (int)index & 0x3F;
/* 408 */     long bitmask = 1L << bit;
/* 409 */     this.bits[wordNum] = this.bits[wordNum] ^ bitmask;
/*     */   }
/*     */ 
/*     */   
/*     */   public void flip(long index) {
/* 414 */     int wordNum = expandingWordNum(index);
/* 415 */     int bit = (int)index & 0x3F;
/* 416 */     long bitmask = 1L << bit;
/* 417 */     this.bits[wordNum] = this.bits[wordNum] ^ bitmask;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean flipAndGet(int index) {
/* 424 */     int wordNum = index >> 6;
/* 425 */     int bit = index & 0x3F;
/* 426 */     long bitmask = 1L << bit;
/* 427 */     this.bits[wordNum] = this.bits[wordNum] ^ bitmask;
/* 428 */     return ((this.bits[wordNum] & bitmask) != 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean flipAndGet(long index) {
/* 435 */     int wordNum = (int)(index >> 6L);
/* 436 */     int bit = (int)index & 0x3F;
/* 437 */     long bitmask = 1L << bit;
/* 438 */     this.bits[wordNum] = this.bits[wordNum] ^ bitmask;
/* 439 */     return ((this.bits[wordNum] & bitmask) != 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void flip(long startIndex, long endIndex) {
/* 448 */     if (endIndex <= startIndex)
/* 449 */       return;  int oldlen = this.wlen;
/* 450 */     int startWord = (int)(startIndex >> 6L);
/*     */ 
/*     */ 
/*     */     
/* 454 */     int endWord = expandingWordNum(endIndex - 1L);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 463 */     long startmask = -1L << (int)startIndex;
/* 464 */     long endmask = -1L >>> (int)-endIndex;
/*     */     
/* 466 */     if (startWord == endWord) {
/* 467 */       this.bits[startWord] = this.bits[startWord] ^ startmask & endmask;
/*     */       
/*     */       return;
/*     */     } 
/* 471 */     this.bits[startWord] = this.bits[startWord] ^ startmask;
/*     */     
/* 473 */     for (int i = startWord + 1; i < endWord; i++) {
/* 474 */       this.bits[i] = this.bits[i] ^ 0xFFFFFFFFFFFFFFFFL;
/*     */     }
/*     */     
/* 477 */     this.bits[endWord] = this.bits[endWord] ^ endmask;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 506 */   public long cardinality() { return BitUtil.pop_array(this.bits, 0, this.wlen); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 513 */   public static long intersectionCount(OpenBitSet a, OpenBitSet b) { return BitUtil.pop_intersect(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long unionCount(OpenBitSet a, OpenBitSet b) {
/* 520 */     long tot = BitUtil.pop_union(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen));
/* 521 */     if (a.wlen < b.wlen) {
/* 522 */       tot += BitUtil.pop_array(b.bits, a.wlen, b.wlen - a.wlen);
/* 523 */     } else if (a.wlen > b.wlen) {
/* 524 */       tot += BitUtil.pop_array(a.bits, b.wlen, a.wlen - b.wlen);
/*     */     } 
/* 526 */     return tot;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long andNotCount(OpenBitSet a, OpenBitSet b) {
/* 534 */     long tot = BitUtil.pop_andnot(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen));
/* 535 */     if (a.wlen > b.wlen) {
/* 536 */       tot += BitUtil.pop_array(a.bits, b.wlen, a.wlen - b.wlen);
/*     */     }
/* 538 */     return tot;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long xorCount(OpenBitSet a, OpenBitSet b) {
/* 545 */     long tot = BitUtil.pop_xor(a.bits, b.bits, 0, Math.min(a.wlen, b.wlen));
/* 546 */     if (a.wlen < b.wlen) {
/* 547 */       tot += BitUtil.pop_array(b.bits, a.wlen, b.wlen - a.wlen);
/* 548 */     } else if (a.wlen > b.wlen) {
/* 549 */       tot += BitUtil.pop_array(a.bits, b.wlen, a.wlen - b.wlen);
/*     */     } 
/* 551 */     return tot;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int nextSetBit(int index) {
/* 559 */     int i = index >> 6;
/* 560 */     if (i >= this.wlen) return -1; 
/* 561 */     int subIndex = index & 0x3F;
/* 562 */     long word = this.bits[i] >> subIndex;
/*     */     
/* 564 */     if (word != 0L) {
/* 565 */       return (i << 6) + subIndex + BitUtil.ntz(word);
/*     */     }
/*     */     
/* 568 */     while (++i < this.wlen) {
/* 569 */       word = this.bits[i];
/* 570 */       if (word != 0L) return (i << 6) + BitUtil.ntz(word);
/*     */     
/*     */     } 
/* 573 */     return -1;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long nextSetBit(long index) {
/* 580 */     int i = (int)(index >>> 6L);
/* 581 */     if (i >= this.wlen) return -1L; 
/* 582 */     int subIndex = (int)index & 0x3F;
/* 583 */     long word = this.bits[i] >>> subIndex;
/*     */     
/* 585 */     if (word != 0L) {
/* 586 */       return (i << 6L) + (subIndex + BitUtil.ntz(word));
/*     */     }
/*     */     
/* 589 */     while (++i < this.wlen) {
/* 590 */       word = this.bits[i];
/* 591 */       if (word != 0L) return (i << 6L) + BitUtil.ntz(word);
/*     */     
/*     */     } 
/* 594 */     return -1L;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/*     */     try {
/* 602 */       OpenBitSet obs = (OpenBitSet)super.clone();
/* 603 */       obs.bits = (long[])obs.bits.clone();
/* 604 */       return obs;
/* 605 */     } catch (CloneNotSupportedException e) {
/* 606 */       throw new RuntimeException(e);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public void intersect(OpenBitSet other) {
/* 612 */     int newLen = Math.min(this.wlen, other.wlen);
/* 613 */     long[] thisArr = this.bits;
/* 614 */     long[] otherArr = other.bits;
/*     */     
/* 616 */     int pos = newLen;
/* 617 */     while (--pos >= 0) {
/* 618 */       thisArr[pos] = thisArr[pos] & otherArr[pos];
/*     */     }
/* 620 */     if (this.wlen > newLen)
/*     */     {
/* 622 */       Arrays.fill(this.bits, newLen, this.wlen, 0L);
/*     */     }
/* 624 */     this.wlen = newLen;
/*     */   }
/*     */ 
/*     */   
/*     */   public void union(OpenBitSet other) {
/* 629 */     int newLen = Math.max(this.wlen, other.wlen);
/* 630 */     ensureCapacityWords(newLen);
/*     */     
/* 632 */     long[] thisArr = this.bits;
/* 633 */     long[] otherArr = other.bits;
/* 634 */     int pos = Math.min(this.wlen, other.wlen);
/* 635 */     while (--pos >= 0) {
/* 636 */       thisArr[pos] = thisArr[pos] | otherArr[pos];
/*     */     }
/* 638 */     if (this.wlen < newLen) {
/* 639 */       System.arraycopy(otherArr, this.wlen, thisArr, this.wlen, newLen - this.wlen);
/*     */     }
/* 641 */     this.wlen = newLen;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void remove(OpenBitSet other) {
/* 647 */     int idx = Math.min(this.wlen, other.wlen);
/* 648 */     long[] thisArr = this.bits;
/* 649 */     long[] otherArr = other.bits;
/* 650 */     while (--idx >= 0) {
/* 651 */       thisArr[idx] = thisArr[idx] & (otherArr[idx] ^ 0xFFFFFFFFFFFFFFFFL);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public void xor(OpenBitSet other) {
/* 657 */     int newLen = Math.max(this.wlen, other.wlen);
/* 658 */     ensureCapacityWords(newLen);
/*     */     
/* 660 */     long[] thisArr = this.bits;
/* 661 */     long[] otherArr = other.bits;
/* 662 */     int pos = Math.min(this.wlen, other.wlen);
/* 663 */     while (--pos >= 0) {
/* 664 */       thisArr[pos] = thisArr[pos] ^ otherArr[pos];
/*     */     }
/* 666 */     if (this.wlen < newLen) {
/* 667 */       System.arraycopy(otherArr, this.wlen, thisArr, this.wlen, newLen - this.wlen);
/*     */     }
/* 669 */     this.wlen = newLen;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 677 */   public void and(OpenBitSet other) { intersect(other); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 682 */   public void or(OpenBitSet other) { union(other); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 687 */   public void andNot(OpenBitSet other) { remove(other); }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean intersects(OpenBitSet other) {
/* 692 */     int pos = Math.min(this.wlen, other.wlen);
/* 693 */     long[] thisArr = this.bits;
/* 694 */     long[] otherArr = other.bits;
/* 695 */     while (--pos >= 0) {
/* 696 */       if ((thisArr[pos] & otherArr[pos]) != 0L) return true; 
/*     */     } 
/* 698 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void ensureCapacityWords(int numWords) {
/* 707 */     if (this.bits.length < numWords) {
/* 708 */       long[] newBits = new long[numWords];
/* 709 */       System.arraycopy(this.bits, 0, newBits, 0, this.wlen);
/* 710 */       this.bits = newBits;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 718 */   public void ensureCapacity(long numBits) { ensureCapacityWords(bits2words(numBits)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void trimTrailingZeros() {
/* 725 */     int idx = this.wlen - 1;
/* 726 */     for (; idx >= 0 && this.bits[idx] == 0L; idx--);
/* 727 */     this.wlen = idx + 1;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 732 */   public static int bits2words(long numBits) { return (int)((numBits - 1L >>> 6L) + 1L); }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*     */     OpenBitSet a;
/* 738 */     if (this == o) return true; 
/* 739 */     if (!(o instanceof OpenBitSet)) return false;
/*     */     
/* 741 */     OpenBitSet b = (OpenBitSet)o;
/*     */     
/* 743 */     if (b.wlen > this.wlen) {
/* 744 */       a = b; b = this;
/*     */     } else {
/* 746 */       a = this;
/*     */     } 
/*     */ 
/*     */     
/* 750 */     for (int i = a.wlen - 1; i >= b.wlen; i--) {
/* 751 */       if (a.bits[i] != 0L) return false;
/*     */     
/*     */     } 
/* 754 */     for (int i = b.wlen - 1; i >= 0; i--) {
/* 755 */       if (a.bits[i] != b.bits[i]) return false;
/*     */     
/*     */     } 
/* 758 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 763 */     long h = -1737092556L;
/* 764 */     for (int i = this.bits.length; --i >= 0; ) {
/* 765 */       h ^= this.bits[i];
/* 766 */       h = h << 1L | h >>> 63L;
/*     */     } 
/* 768 */     return (int)(h >> 32L ^ h);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\OpenBitSet.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.OpenBitSetDISI,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.search.DocIdSetIterator;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class OpenBitSetDISI
/*    */   extends OpenBitSet
/*    */ {
/*    */   static final boolean $assertionsDisabled;
/*    */   
/*    */   public OpenBitSetDISI(DocIdSetIterator disi, int maxSize) throws IOException {
/* 31 */     super(maxSize);
/* 32 */     inPlaceOr(disi);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 40 */   public OpenBitSetDISI(int maxSize) { super(maxSize); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void inPlaceOr(DocIdSetIterator disi) throws IOException {
/* 50 */     while (disi.next() && disi.doc() < size()) {
/* 51 */       fastSet(disi.doc());
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void inPlaceAnd(DocIdSetIterator disi) throws IOException {
/* 62 */     int index = nextSetBit(0);
/* 63 */     int lastNotCleared = -1;
/* 64 */     while (index != -1 && disi.skipTo(index)) {
/* 65 */       while (index != -1 && index < disi.doc()) {
/* 66 */         fastClear(index);
/* 67 */         index = nextSetBit(index + 1);
/*    */       } 
/* 69 */       if (index == disi.doc()) {
/* 70 */         lastNotCleared = index;
/* 71 */         index++;
/*    */       } 
/* 73 */       assert index == -1 || index > disi.doc();
/*    */     } 
/* 75 */     clear((lastNotCleared + 1), size());
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void inPlaceNot(DocIdSetIterator disi) throws IOException {
/* 85 */     while (disi.next() && disi.doc() < size()) {
/* 86 */       fastClear(disi.doc());
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void inPlaceXor(DocIdSetIterator disi) throws IOException {
/* 97 */     while (disi.next() && disi.doc() < size())
/* 98 */       fastFlip(disi.doc()); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\OpenBitSetDISI.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.OpenBitSetIterator,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import org.apache.lucene.search.DocIdSetIterator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class OpenBitSetIterator
/*     */   extends DocIdSetIterator
/*     */ {
/*  37 */   protected static final int[] bitlist = new int[] { 0, 1, 2, 33, 3, 49, 50, 801, 4, 65, 66, 1057, 67, 1073, 1074, 17185, 5, 81, 82, 1313, 83, 1329, 1330, 21281, 84, 1345, 1346, 21537, 1347, 21553, 21554, 344865, 6, 97, 98, 1569, 99, 1585, 1586, 25377, 100, 1601, 1602, 25633, 1603, 25649, 25650, 410401, 101, 1617, 1618, 25889, 1619, 25905, 25906, 414497, 1620, 25921, 25922, 414753, 25923, 414769, 414770, 6636321, 7, 113, 114, 1825, 115, 1841, 1842, 29473, 116, 1857, 1858, 29729, 1859, 29745, 29746, 475937, 117, 1873, 1874, 29985, 1875, 30001, 30002, 480033, 1876, 30017, 30018, 480289, 30019, 480305, 480306, 7684897, 118, 1889, 1890, 30241, 1891, 30257, 30258, 484129, 1892, 30273, 30274, 484385, 30275, 484401, 484402, 7750433, 1893, 30289, 30290, 484641, 30291, 484657, 484658, 7754529, 30292, 484673, 484674, 7754785, 484675, 7754801, 7754802, 124076833, 8, 129, 130, 2081, 131, 2097, 2098, 33569, 132, 2113, 2114, 33825, 2115, 33841, 33842, 541473, 133, 2129, 2130, 34081, 2131, 34097, 34098, 545569, 2132, 34113, 34114, 545825, 34115, 545841, 545842, 8733473, 134, 2145, 2146, 34337, 2147, 34353, 34354, 549665, 2148, 34369, 34370, 549921, 34371, 549937, 549938, 8799009, 2149, 34385, 34386, 550177, 34387, 550193, 550194, 8803105, 34388, 550209, 550210, 8803361, 550211, 8803377, 8803378, 140854049, 135, 2161, 2162, 34593, 2163, 34609, 34610, 553761, 2164, 34625, 34626, 554017, 34627, 554033, 554034, 8864545, 2165, 34641, 34642, 554273, 34643, 554289, 554290, 8868641, 34644, 554305, 554306, 8868897, 554307, 8868913, 8868914, 141902625, 2166, 34657, 34658, 554529, 34659, 554545, 554546, 8872737, 34660, 554561, 554562, 8872993, 554563, 8873009, 8873010, 141968161, 34661, 554577, 554578, 8873249, 554579, 8873265, 8873266, 141972257, 554580, 8873281, 8873282, 141972513, 8873283, 141972529, 141972530, -2023406815 };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final long[] arr;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int words;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  62 */   private int i = -1;
/*     */   
/*     */   private long word;
/*     */   private int wordShift;
/*     */   private int indexArray;
/*     */   private int curDocId;
/*     */   
/*  69 */   public OpenBitSetIterator(OpenBitSet obs) { this(obs.getBits(), obs.getNumWords()); }
/*     */ 
/*     */   
/*     */   public OpenBitSetIterator(long[] bits, int numWords) {
/*  73 */     this.arr = bits;
/*  74 */     this.words = numWords;
/*     */   }
/*     */ 
/*     */   
/*     */   private void shift() {
/*  79 */     if ((int)this.word == 0) { this.wordShift += 32; this.word >>>= 32L; }
/*  80 */      if ((this.word & 0xFFFFL) == 0L) { this.wordShift += 16; this.word >>>= 16L; }
/*  81 */      if ((this.word & 0xFFL) == 0L) { this.wordShift += 8; this.word >>>= 8L; }
/*  82 */      this.indexArray = bitlist[(int)this.word & 0xFF];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() {
/* 108 */     if (this.indexArray == 0) {
/* 109 */       if (this.word != 0L) {
/* 110 */         this.word >>>= 8L;
/* 111 */         this.wordShift += 8;
/*     */       } 
/*     */       
/* 114 */       while (this.word == 0L) {
/* 115 */         if (++this.i >= this.words) {
/* 116 */           this.curDocId = -1;
/* 117 */           return false;
/*     */         } 
/* 119 */         this.word = this.arr[this.i];
/* 120 */         this.wordShift = -1;
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 125 */       shift();
/*     */     } 
/*     */     
/* 128 */     int bitIndex = (this.indexArray & 0xF) + this.wordShift;
/* 129 */     this.indexArray >>>= 4;
/*     */ 
/*     */     
/* 132 */     this.curDocId = (this.i << 6) + bitIndex;
/* 133 */     return true;
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) {
/* 137 */     this.indexArray = 0;
/* 138 */     this.i = target >> 6;
/* 139 */     if (this.i >= this.words) {
/* 140 */       this.word = 0L;
/* 141 */       this.curDocId = -1;
/* 142 */       return false;
/*     */     } 
/* 144 */     this.wordShift = target & 0x3F;
/* 145 */     this.word = this.arr[this.i] >>> this.wordShift;
/* 146 */     if (this.word != 0L) {
/* 147 */       this.wordShift--;
/*     */     } else {
/* 149 */       while (this.word == 0L) {
/* 150 */         if (++this.i >= this.words) {
/* 151 */           this.curDocId = -1;
/* 152 */           return false;
/*     */         } 
/* 154 */         this.word = this.arr[this.i];
/*     */       } 
/* 156 */       this.wordShift = -1;
/*     */     } 
/*     */     
/* 159 */     shift();
/*     */     
/* 161 */     int bitIndex = (this.indexArray & 0xF) + this.wordShift;
/* 162 */     this.indexArray >>>= 4;
/*     */ 
/*     */     
/* 165 */     this.curDocId = (this.i << 6) + bitIndex;
/* 166 */     return true;
/*     */   }
/*     */ 
/*     */   
/* 170 */   public int doc() { return this.curDocId; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\OpenBitSetIterator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.Parameter,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ import java.io.ObjectStreamException;
/*    */ import java.io.Serializable;
/*    */ import java.io.StreamCorruptedException;
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Parameter
/*    */   implements Serializable
/*    */ {
/* 31 */   static Map allParameters = new HashMap();
/*    */ 
/*    */   
/*    */   private String name;
/*    */ 
/*    */   
/*    */   private Parameter() {}
/*    */ 
/*    */   
/*    */   protected Parameter(String name) {
/* 41 */     this.name = name;
/* 42 */     String key = makeKey(name);
/*    */     
/* 44 */     if (allParameters.containsKey(key)) {
/* 45 */       throw new IllegalArgumentException(""Parameter name "" + key + "" already used!"");
/*    */     }
/* 47 */     allParameters.put(key, this);
/*    */   }
/*    */ 
/*    */   
/* 51 */   private String makeKey(String name) { return getClass() + "" "" + name; }
/*    */ 
/*    */ 
/*    */   
/* 55 */   public String toString() { return this.name; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected Object readResolve() throws ObjectStreamException {
/* 66 */     Object par = allParameters.get(makeKey(this.name));
/*    */     
/* 68 */     if (par == null) {
/* 69 */       throw new StreamCorruptedException(""Unknown parameter value: "" + this.name);
/*    */     }
/* 71 */     return par;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\Parameter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.PriorityQueue,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class PriorityQueue
/*     */ {
/*     */   private int size;
/*     */   private int maxSize;
/*     */   protected Object[] heap;
/*     */   
/*     */   protected abstract boolean lessThan(Object paramObject1, Object paramObject2);
/*     */   
/*     */   protected final void initialize(int maxSize) {
/*     */     int heapSize;
/*  34 */     this.size = 0;
/*     */     
/*  36 */     if (0 == maxSize) {
/*     */       
/*  38 */       heapSize = 2;
/*     */     } else {
/*  40 */       heapSize = maxSize + 1;
/*  41 */     }  this.heap = new Object[heapSize];
/*  42 */     this.maxSize = maxSize;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void put(Object element) {
/*  51 */     this.size++;
/*  52 */     this.heap[this.size] = element;
/*  53 */     upHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  63 */   public boolean insert(Object element) { return (insertWithOverflow(element) != element); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object insertWithOverflow(Object element) {
/*  77 */     if (this.size < this.maxSize) {
/*  78 */       put(element);
/*  79 */       return null;
/*  80 */     }  if (this.size > 0 && !lessThan(element, this.heap[1])) {
/*  81 */       Object ret = this.heap[1];
/*  82 */       this.heap[1] = element;
/*  83 */       adjustTop();
/*  84 */       return ret;
/*     */     } 
/*  86 */     return element;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public final Object top() { return this.heap[1]; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Object pop() {
/* 101 */     if (this.size > 0) {
/* 102 */       Object result = this.heap[1];
/* 103 */       this.heap[1] = this.heap[this.size];
/* 104 */       this.heap[this.size] = null;
/* 105 */       this.size--;
/* 106 */       downHeap();
/* 107 */       return result;
/*     */     } 
/* 109 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 120 */   public final void adjustTop() { downHeap(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 125 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void clear() {
/* 130 */     for (int i = 0; i <= this.size; i++)
/* 131 */       this.heap[i] = null; 
/* 132 */     this.size = 0;
/*     */   }
/*     */   
/*     */   private final void upHeap() {
/* 136 */     int i = this.size;
/* 137 */     Object node = this.heap[i];
/* 138 */     int j = i >>> 1;
/* 139 */     while (j > 0 && lessThan(node, this.heap[j])) {
/* 140 */       this.heap[i] = this.heap[j];
/* 141 */       i = j;
/* 142 */       j >>>= 1;
/*     */     } 
/* 144 */     this.heap[i] = node;
/*     */   }
/*     */   
/*     */   private final void downHeap() {
/* 148 */     int i = 1;
/* 149 */     Object node = this.heap[i];
/* 150 */     int j = i << 1;
/* 151 */     int k = j + 1;
/* 152 */     if (k <= this.size && lessThan(this.heap[k], this.heap[j])) {
/* 153 */       j = k;
/*     */     }
/* 155 */     while (j <= this.size && lessThan(this.heap[j], node)) {
/* 156 */       this.heap[i] = this.heap[j];
/* 157 */       i = j;
/* 158 */       j = i << 1;
/* 159 */       k = j + 1;
/* 160 */       if (k <= this.size && lessThan(this.heap[k], this.heap[j])) {
/* 161 */         j = k;
/*     */       }
/*     */     } 
/* 164 */     this.heap[i] = node;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\PriorityQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.ScorerDocQueue,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ScorerDocQueue
/*     */ {
/*     */   private final HeapedScorerDoc[] heap;
/*     */   private final int maxSize;
/*     */   private int size;
/*     */   private HeapedScorerDoc topHSD;
/*     */   
/*     */   private class HeapedScorerDoc
/*     */   {
/*     */     Scorer scorer;
/*     */     int doc;
/*     */     private final ScorerDocQueue this$0;
/*     */     
/*  38 */     HeapedScorerDoc(Scorer s) { this(s, s.doc()); }
/*     */     
/*     */     HeapedScorerDoc(Scorer scorer, int doc) {
/*  41 */       this.scorer = scorer;
/*  42 */       this.doc = doc;
/*     */     }
/*     */     
/*  45 */     void adjust() { this.doc = this.scorer.doc(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public ScorerDocQueue(int maxSize) {
/*  53 */     this.size = 0;
/*  54 */     int heapSize = maxSize + 1;
/*  55 */     this.heap = new HeapedScorerDoc[heapSize];
/*  56 */     this.maxSize = maxSize;
/*  57 */     this.topHSD = this.heap[1];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void put(Scorer scorer) {
/*  66 */     this.size++;
/*  67 */     this.heap[this.size] = new HeapedScorerDoc(scorer);
/*  68 */     upHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean insert(Scorer scorer) {
/*  78 */     if (this.size < this.maxSize) {
/*  79 */       put(scorer);
/*  80 */       return true;
/*     */     } 
/*  82 */     int docNr = scorer.doc();
/*  83 */     if (this.size > 0 && docNr >= this.topHSD.doc) {
/*  84 */       this.heap[1] = new HeapedScorerDoc(scorer, docNr);
/*  85 */       downHeap();
/*  86 */       return true;
/*     */     } 
/*  88 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   public final Scorer top() { return this.topHSD.scorer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public final int topDoc() { return this.topHSD.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 112 */   public final float topScore() throws IOException { return this.topHSD.scorer.score(); }
/*     */ 
/*     */ 
/*     */   
/* 116 */   public final boolean topNextAndAdjustElsePop() throws IOException { return checkAdjustElsePop(this.topHSD.scorer.next()); }
/*     */ 
/*     */ 
/*     */   
/* 120 */   public final boolean topSkipToAndAdjustElsePop(int target) throws IOException { return checkAdjustElsePop(this.topHSD.scorer.skipTo(target)); }
/*     */ 
/*     */   
/*     */   private boolean checkAdjustElsePop(boolean cond) {
/* 124 */     if (cond) {
/* 125 */       this.topHSD.doc = this.topHSD.scorer.doc();
/*     */     } else {
/* 127 */       this.heap[1] = this.heap[this.size];
/* 128 */       this.heap[this.size] = null;
/* 129 */       this.size--;
/*     */     } 
/* 131 */     downHeap();
/* 132 */     return cond;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Scorer pop() {
/* 141 */     Scorer result = this.topHSD.scorer;
/* 142 */     popNoResult();
/* 143 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void popNoResult() {
/* 150 */     this.heap[1] = this.heap[this.size];
/* 151 */     this.heap[this.size] = null;
/* 152 */     this.size--;
/* 153 */     downHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void adjustTop() {
/* 165 */     this.topHSD.adjust();
/* 166 */     downHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 171 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void clear() {
/* 176 */     for (int i = 0; i <= this.size; i++) {
/* 177 */       this.heap[i] = null;
/*     */     }
/* 179 */     this.size = 0;
/*     */   }
/*     */   
/*     */   private final void upHeap() {
/* 183 */     int i = this.size;
/* 184 */     HeapedScorerDoc node = this.heap[i];
/* 185 */     int j = i >>> 1;
/* 186 */     while (j > 0 && node.doc < (this.heap[j]).doc) {
/* 187 */       this.heap[i] = this.heap[j];
/* 188 */       i = j;
/* 189 */       j >>>= 1;
/*     */     } 
/* 191 */     this.heap[i] = node;
/* 192 */     this.topHSD = this.heap[1];
/*     */   }
/*     */   
/*     */   private final void downHeap() {
/* 196 */     int i = 1;
/* 197 */     HeapedScorerDoc node = this.heap[i];
/* 198 */     int j = i << 1;
/* 199 */     int k = j + 1;
/* 200 */     if (k <= this.size && (this.heap[k]).doc < (this.heap[j]).doc) {
/* 201 */       j = k;
/*     */     }
/* 203 */     while (j <= this.size && (this.heap[j]).doc < node.doc) {
/* 204 */       this.heap[i] = this.heap[j];
/* 205 */       i = j;
/* 206 */       j = i << 1;
/* 207 */       k = j + 1;
/* 208 */       if (k <= this.size && (this.heap[k]).doc < (this.heap[j]).doc) {
/* 209 */         j = k;
/*     */       }
/*     */     } 
/* 212 */     this.heap[i] = node;
/* 213 */     this.topHSD = this.heap[1];
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\ScorerDocQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.SmallFloat,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SmallFloat
/*     */ {
/*     */   public static byte floatToByte(float f, int numMantissaBits, int zeroExp) {
/*  39 */     int fzero = 63 - zeroExp << numMantissaBits;
/*  40 */     int bits = Float.floatToRawIntBits(f);
/*  41 */     int smallfloat = bits >> 24 - numMantissaBits;
/*  42 */     if (smallfloat < fzero) {
/*  43 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/*     */     
/*  46 */     if (smallfloat >= fzero + 256) {
/*  47 */       return -1;
/*     */     }
/*  49 */     return (byte)(smallfloat - fzero);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byteToFloat(byte b, int numMantissaBits, int zeroExp) {
/*  57 */     if (b == 0) return 0.0F; 
/*  58 */     int bits = (b & 0xFF) << 24 - numMantissaBits;
/*  59 */     bits += 63 - zeroExp << 24;
/*  60 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static byte floatToByte315(float f) {
/*  76 */     int bits = Float.floatToRawIntBits(f);
/*  77 */     int smallfloat = bits >> 21;
/*  78 */     if (smallfloat < 384) {
/*  79 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/*  81 */     if (smallfloat >= 640) {
/*  82 */       return -1;
/*     */     }
/*  84 */     return (byte)(smallfloat - 384);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byte315ToFloat(byte b) {
/*  91 */     if (b == 0) return 0.0F; 
/*  92 */     int bits = (b & 0xFF) << 21;
/*  93 */     bits += 805306368;
/*  94 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static byte floatToByte52(float f) {
/* 104 */     int bits = Float.floatToRawIntBits(f);
/* 105 */     int smallfloat = bits >> 19;
/* 106 */     if (smallfloat < 1952) {
/* 107 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/* 109 */     if (smallfloat >= 2208) {
/* 110 */       return -1;
/*     */     }
/* 112 */     return (byte)(smallfloat - 1952);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byte52ToFloat(byte b) {
/* 119 */     if (b == 0) return 0.0F; 
/* 120 */     int bits = (b & 0xFF) << 19;
/* 121 */     bits += 1023410176;
/* 122 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\SmallFloat.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.SortedVIntList,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import org.apache.lucene.search.DocIdSet;
/*     */ import org.apache.lucene.search.DocIdSetIterator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SortedVIntList
/*     */   extends DocIdSet
/*     */ {
/*     */   static final int BITS2VINTLIST_SIZE = 8;
/*     */   private int size;
/*     */   private byte[] bytes;
/*     */   private int lastBytePos;
/*     */   private static final int VB1 = 127;
/*     */   private static final int BIT_SHIFT = 7;
/*     */   
/*  49 */   public SortedVIntList(int[] sortedInts) { this(sortedInts, sortedInts.length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortedVIntList(int[] sortedInts, int inputSize) {
/*  58 */     SortedVIntListBuilder builder = new SortedVIntListBuilder();
/*  59 */     for (int i = 0; i < inputSize; i++) {
/*  60 */       builder.addInt(sortedInts[i]);
/*     */     }
/*  62 */     builder.done();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortedVIntList(BitSet bits) {
/*  70 */     SortedVIntListBuilder builder = new SortedVIntListBuilder();
/*  71 */     int nextInt = bits.nextSetBit(0);
/*  72 */     while (nextInt != -1) {
/*  73 */       builder.addInt(nextInt);
/*  74 */       nextInt = bits.nextSetBit(nextInt + 1);
/*     */     } 
/*  76 */     builder.done();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortedVIntList(OpenBitSet bits) {
/*  84 */     SortedVIntListBuilder builder = new SortedVIntListBuilder();
/*  85 */     int nextInt = bits.nextSetBit(0);
/*  86 */     while (nextInt != -1) {
/*  87 */       builder.addInt(nextInt);
/*  88 */       nextInt = bits.nextSetBit(nextInt + 1);
/*     */     } 
/*  90 */     builder.done();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortedVIntList(DocIdSetIterator docIdSetIterator) throws IOException {
/* 101 */     SortedVIntListBuilder builder = new SortedVIntListBuilder();
/* 102 */     while (docIdSetIterator.next()) {
/* 103 */       builder.addInt(docIdSetIterator.doc());
/*     */     }
/* 105 */     builder.done();
/*     */   }
/*     */   
/*     */   private class SortedVIntListBuilder
/*     */   {
/* 110 */     private int lastInt = 0;
/*     */     
/*     */     SortedVIntListBuilder() {
/* 113 */       SortedVIntList.this.initBytes();
/* 114 */       this.lastInt = 0;
/*     */     }
/*     */     private final SortedVIntList this$0;
/*     */     void addInt(int nextInt) {
/* 118 */       int diff = nextInt - this.lastInt;
/* 119 */       if (diff < 0) {
/* 120 */         throw new IllegalArgumentException(""Input not sorted or first element negative."");
/*     */       }
/*     */ 
/*     */       
/* 124 */       if (SortedVIntList.this.lastBytePos + 5 > SortedVIntList.this.bytes.length)
/*     */       {
/* 126 */         SortedVIntList.this.resizeBytes(SortedVIntList.this.bytes.length * 2 + 5);
/*     */       }
/*     */ 
/*     */       
/* 130 */       while ((diff & 0xFFFFFF80) != 0) {
/* 131 */         SortedVIntList.this.bytes[SortedVIntList.this.lastBytePos++] = (byte)(diff & 0x7F | 0xFFFFFF80);
/* 132 */         diff >>>= 7;
/*     */       } 
/* 134 */       SortedVIntList.this.bytes[SortedVIntList.this.lastBytePos++] = (byte)diff;
/* 135 */       SortedVIntList.this.size++;
/* 136 */       this.lastInt = nextInt;
/*     */     }
/*     */ 
/*     */     
/* 140 */     void done() { SortedVIntList.this.resizeBytes(SortedVIntList.this.lastBytePos); }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void initBytes() {
/* 146 */     this.size = 0;
/* 147 */     this.bytes = new byte[128];
/* 148 */     this.lastBytePos = 0;
/*     */   }
/*     */   
/*     */   private void resizeBytes(int newSize) {
/* 152 */     if (newSize != this.bytes.length) {
/* 153 */       byte[] newBytes = new byte[newSize];
/* 154 */       System.arraycopy(this.bytes, 0, newBytes, 0, this.lastBytePos);
/* 155 */       this.bytes = newBytes;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 161 */   private final int MAX_BYTES_PER_INT = 5;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 167 */   public int size() { return this.size; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 174 */   public int getByteSize() { return this.bytes.length; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DocIdSetIterator iterator() {
/* 181 */     return new DocIdSetIterator() {
/* 182 */         int bytePos = 0;
/* 183 */         int lastInt = 0;
/*     */         private final SortedVIntList this$0;
/*     */         
/*     */         private void advance() {
/* 187 */           byte b = SortedVIntList.this.bytes[this.bytePos++];
/* 188 */           this.lastInt += b & Byte.MAX_VALUE;
/* 189 */           for (int s = 7; (b & Byte.MIN_VALUE) != 0; s += 7) {
/* 190 */             b = SortedVIntList.this.bytes[this.bytePos++];
/* 191 */             this.lastInt += (b & Byte.MAX_VALUE) << s;
/*     */           } 
/*     */         }
/*     */         
/* 195 */         public int doc() { return this.lastInt; }
/*     */         
/*     */         public boolean next() {
/* 198 */           if (this.bytePos >= SortedVIntList.this.lastBytePos) {
/* 199 */             return false;
/*     */           }
/* 201 */           advance();
/* 202 */           return true;
/*     */         }
/*     */ 
/*     */         
/*     */         public boolean skipTo(int docNr) {
/* 207 */           while (this.bytePos < SortedVIntList.this.lastBytePos) {
/* 208 */             advance();
/* 209 */             if (this.lastInt >= docNr) {
/* 210 */               return true;
/*     */             }
/*     */           } 
/* 213 */           return false;
/*     */         }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\SortedVIntList.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.StringHelper,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class StringHelper
/*    */ {
/*    */   public static final int bytesDifference(byte[] bytes1, int len1, byte[] bytes2, int len2) {
/* 37 */     int len = (len1 < len2) ? len1 : len2;
/* 38 */     for (int i = 0; i < len; i++) {
/* 39 */       if (bytes1[i] != bytes2[i])
/* 40 */         return i; 
/* 41 */     }  return len;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static final int stringDifference(String s1, String s2) {
/* 53 */     int len1 = s1.length();
/* 54 */     int len2 = s2.length();
/* 55 */     int len = (len1 < len2) ? len1 : len2;
/* 56 */     for (int i = 0; i < len; i++) {
/* 57 */       if (s1.charAt(i) != s2.charAt(i)) {
/* 58 */         return i;
/*    */       }
/*    */     } 
/* 61 */     return len;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\StringHelper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.ToStringUtils,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ToStringUtils
/*    */ {
/*    */   public static String boost(float boost) {
/* 23 */     if (boost != 1.0F)
/* 24 */       return ""^"" + Float.toString(boost); 
/* 25 */     return """";
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\ToStringUtils.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.UnicodeUtil,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class UnicodeUtil
/*     */ {
/*     */   public static final int UNI_SUR_HIGH_START = 55296;
/*     */   public static final int UNI_SUR_HIGH_END = 56319;
/*     */   public static final int UNI_SUR_LOW_START = 56320;
/*     */   public static final int UNI_SUR_LOW_END = 57343;
/*     */   public static final int UNI_REPLACEMENT_CHAR = 65533;
/*     */   private static final long UNI_MAX_BMP = 65535L;
/*     */   private static final int HALF_BASE = 65536;
/*     */   private static final long HALF_SHIFT = 10L;
/*     */   private static final long HALF_MASK = 1023L;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public static final class UTF8Result
/*     */   {
/*  76 */     public byte[] result = new byte[10];
/*     */     public int length;
/*     */     
/*     */     public void setLength(int newLength) {
/*  80 */       if (this.result.length < newLength) {
/*  81 */         byte[] newArray = new byte[(int)(1.5D * newLength)];
/*  82 */         System.arraycopy(this.result, 0, newArray, 0, this.length);
/*  83 */         this.result = newArray;
/*     */       } 
/*  85 */       this.length = newLength;
/*     */     }
/*     */   }
/*     */   
/*     */   public static final class UTF16Result {
/*  90 */     public char[] result = new char[10];
/*  91 */     public int[] offsets = new int[10];
/*     */     public int length;
/*     */     
/*     */     public void setLength(int newLength) {
/*  95 */       if (this.result.length < newLength) {
/*  96 */         char[] newArray = new char[(int)(1.5D * newLength)];
/*  97 */         System.arraycopy(this.result, 0, newArray, 0, this.length);
/*  98 */         this.result = newArray;
/*     */       } 
/* 100 */       this.length = newLength;
/*     */     }
/*     */     
/*     */     public void copyText(UTF16Result other) {
/* 104 */       setLength(other.length);
/* 105 */       System.arraycopy(other.result, 0, this.result, 0, this.length);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void UTF16toUTF8(char[] source, int offset, UTF8Result result) {
/* 114 */     int upto = 0;
/* 115 */     int i = offset;
/* 116 */     byte[] out = result.result;
/*     */ 
/*     */     
/*     */     while (true) {
/* 120 */       int code = source[i++];
/*     */       
/* 122 */       if (upto + 4 > out.length) {
/* 123 */         byte[] newOut = new byte[2 * out.length];
/* 124 */         assert newOut.length >= upto + 4;
/* 125 */         System.arraycopy(out, 0, newOut, 0, upto);
/* 126 */         result.result = out = newOut;
/*     */       } 
/* 128 */       if (code < 128) {
/* 129 */         out[upto++] = (byte)code; continue;
/* 130 */       }  if (code < 2048) {
/* 131 */         out[upto++] = (byte)(0xC0 | code >> 6);
/* 132 */         out[upto++] = (byte)(0x80 | code & 0x3F); continue;
/* 133 */       }  if (code < 55296 || code > 57343) {
/* 134 */         if (code == 65535) {
/*     */           break;
/*     */         }
/* 137 */         out[upto++] = (byte)(0xE0 | code >> 12);
/* 138 */         out[upto++] = (byte)(0x80 | code >> 6 & 0x3F);
/* 139 */         out[upto++] = (byte)(0x80 | code & 0x3F);
/*     */         
/*     */         continue;
/*     */       } 
/* 143 */       if (code < 56320 && source[i] != Character.MAX_VALUE) {
/* 144 */         int utf32 = source[i];
/*     */         
/* 146 */         if (utf32 >= 56320 && utf32 <= 57343) {
/* 147 */           utf32 = (code - 55232 << 10) + (utf32 & 0x3FF);
/* 148 */           i++;
/* 149 */           out[upto++] = (byte)(0xF0 | utf32 >> 18);
/* 150 */           out[upto++] = (byte)(0x80 | utf32 >> 12 & 0x3F);
/* 151 */           out[upto++] = (byte)(0x80 | utf32 >> 6 & 0x3F);
/* 152 */           out[upto++] = (byte)(0x80 | utf32 & 0x3F);
/*     */           
/*     */           continue;
/*     */         } 
/*     */       } 
/*     */       
/* 158 */       out[upto++] = -17;
/* 159 */       out[upto++] = -65;
/* 160 */       out[upto++] = -67;
/*     */     } 
/*     */ 
/*     */     
/* 164 */     result.length = upto;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void UTF16toUTF8(char[] source, int offset, int length, UTF8Result result) {
/* 172 */     int upto = 0;
/* 173 */     int i = offset;
/* 174 */     int end = offset + length;
/* 175 */     byte[] out = result.result;
/*     */     
/* 177 */     while (i < end) {
/*     */       
/* 179 */       int code = source[i++];
/*     */       
/* 181 */       if (upto + 4 > out.length) {
/* 182 */         byte[] newOut = new byte[2 * out.length];
/* 183 */         assert newOut.length >= upto + 4;
/* 184 */         System.arraycopy(out, 0, newOut, 0, upto);
/* 185 */         result.result = out = newOut;
/*     */       } 
/* 187 */       if (code < 128) {
/* 188 */         out[upto++] = (byte)code; continue;
/* 189 */       }  if (code < 2048) {
/* 190 */         out[upto++] = (byte)(0xC0 | code >> 6);
/* 191 */         out[upto++] = (byte)(0x80 | code & 0x3F); continue;
/* 192 */       }  if (code < 55296 || code > 57343) {
/* 193 */         out[upto++] = (byte)(0xE0 | code >> 12);
/* 194 */         out[upto++] = (byte)(0x80 | code >> 6 & 0x3F);
/* 195 */         out[upto++] = (byte)(0x80 | code & 0x3F);
/*     */         
/*     */         continue;
/*     */       } 
/* 199 */       if (code < 56320 && i < end && source[i] != Character.MAX_VALUE) {
/* 200 */         int utf32 = source[i];
/*     */         
/* 202 */         if (utf32 >= 56320 && utf32 <= 57343) {
/* 203 */           utf32 = (code - 55232 << 10) + (utf32 & 0x3FF);
/* 204 */           i++;
/* 205 */           out[upto++] = (byte)(0xF0 | utf32 >> 18);
/* 206 */           out[upto++] = (byte)(0x80 | utf32 >> 12 & 0x3F);
/* 207 */           out[upto++] = (byte)(0x80 | utf32 >> 6 & 0x3F);
/* 208 */           out[upto++] = (byte)(0x80 | utf32 & 0x3F);
/*     */           
/*     */           continue;
/*     */         } 
/*     */       } 
/*     */       
/* 214 */       out[upto++] = -17;
/* 215 */       out[upto++] = -65;
/* 216 */       out[upto++] = -67;
/*     */     } 
/*     */ 
/*     */     
/* 220 */     result.length = upto;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void UTF16toUTF8(String s, int offset, int length, UTF8Result result) {
/* 227 */     int end = offset + length;
/*     */     
/* 229 */     byte[] out = result.result;
/*     */     
/* 231 */     int upto = 0;
/* 232 */     for (int i = offset; i < end; i++) {
/* 233 */       int code = s.charAt(i);
/*     */       
/* 235 */       if (upto + 4 > out.length) {
/* 236 */         byte[] newOut = new byte[2 * out.length];
/* 237 */         assert newOut.length >= upto + 4;
/* 238 */         System.arraycopy(out, 0, newOut, 0, upto);
/* 239 */         result.result = out = newOut;
/*     */       } 
/* 241 */       if (code < 128) {
/* 242 */         out[upto++] = (byte)code; continue;
/* 243 */       }  if (code < 2048) {
/* 244 */         out[upto++] = (byte)(0xC0 | code >> 6);
/* 245 */         out[upto++] = (byte)(0x80 | code & 0x3F); continue;
/* 246 */       }  if (code < 55296 || code > 57343) {
/* 247 */         out[upto++] = (byte)(0xE0 | code >> 12);
/* 248 */         out[upto++] = (byte)(0x80 | code >> 6 & 0x3F);
/* 249 */         out[upto++] = (byte)(0x80 | code & 0x3F);
/*     */         
/*     */         continue;
/*     */       } 
/* 253 */       if (code < 56320 && i < end - 1) {
/* 254 */         int utf32 = s.charAt(i + 1);
/*     */         
/* 256 */         if (utf32 >= 56320 && utf32 <= 57343) {
/* 257 */           utf32 = (code - 55232 << 10) + (utf32 & 0x3FF);
/* 258 */           i++;
/* 259 */           out[upto++] = (byte)(0xF0 | utf32 >> 18);
/* 260 */           out[upto++] = (byte)(0x80 | utf32 >> 12 & 0x3F);
/* 261 */           out[upto++] = (byte)(0x80 | utf32 >> 6 & 0x3F);
/* 262 */           out[upto++] = (byte)(0x80 | utf32 & 0x3F);
/*     */           
/*     */           continue;
/*     */         } 
/*     */       } 
/*     */       
/* 268 */       out[upto++] = -17;
/* 269 */       out[upto++] = -65;
/* 270 */       out[upto++] = -67;
/*     */       
/*     */       continue;
/*     */     } 
/* 274 */     result.length = upto;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void UTF8toUTF16(byte[] utf8, int offset, int length, UTF16Result result) {
/* 283 */     int end = offset + length;
/* 284 */     char[] out = result.result;
/* 285 */     if (result.offsets.length <= end) {
/* 286 */       int[] newOffsets = new int[2 * end];
/* 287 */       System.arraycopy(result.offsets, 0, newOffsets, 0, result.offsets.length);
/* 288 */       result.offsets = newOffsets;
/*     */     } 
/* 290 */     int[] offsets = result.offsets;
/*     */ 
/*     */ 
/*     */     
/* 294 */     int upto = offset;
/* 295 */     while (offsets[upto] == -1) {
/* 296 */       upto--;
/*     */     }
/* 298 */     int outUpto = offsets[upto];
/*     */ 
/*     */     
/* 301 */     if (outUpto + length >= out.length) {
/* 302 */       char[] newOut = new char[2 * (outUpto + length)];
/* 303 */       System.arraycopy(out, 0, newOut, 0, outUpto);
/* 304 */       result.result = out = newOut;
/*     */     } 
/*     */     
/* 307 */     while (upto < end) {
/*     */       
/* 309 */       int ch, b = utf8[upto] & 0xFF;
/*     */ 
/*     */       
/* 312 */       offsets[upto++] = outUpto;
/*     */       
/* 314 */       if (b < 192) {
/* 315 */         assert b < 128;
/* 316 */         ch = b;
/* 317 */       } else if (b < 224) {
/* 318 */         ch = ((b & 0x1F) << 6) + (utf8[upto] & 0x3F);
/* 319 */         offsets[upto++] = -1;
/* 320 */       } else if (b < 240) {
/* 321 */         ch = ((b & 0xF) << 12) + ((utf8[upto] & 0x3F) << 6) + (utf8[upto + 1] & 0x3F);
/* 322 */         offsets[upto++] = -1;
/* 323 */         offsets[upto++] = -1;
/*     */       } else {
/* 325 */         assert b < 248;
/* 326 */         ch = ((b & 0x7) << 18) + ((utf8[upto] & 0x3F) << 12) + ((utf8[upto + 1] & 0x3F) << 6) + (utf8[upto + 2] & 0x3F);
/* 327 */         offsets[upto++] = -1;
/* 328 */         offsets[upto++] = -1;
/* 329 */         offsets[upto++] = -1;
/*     */       } 
/*     */       
/* 332 */       if (ch <= 65535L) {
/*     */         
/* 334 */         out[outUpto++] = (char)ch;
/*     */         continue;
/*     */       } 
/* 337 */       int chHalf = ch - 65536;
/* 338 */       out[outUpto++] = (char)((chHalf >> 10) + 55296);
/* 339 */       out[outUpto++] = (char)(int)((chHalf & 0x3FFL) + 56320L);
/*     */     } 
/*     */ 
/*     */     
/* 343 */     offsets[upto] = outUpto;
/* 344 */     result.length = outUpto;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\UnicodeUtil.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.cache.Cache,"/*    */ package org.apache.lucene.util.cache;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Cache
/*    */ {
/*    */   static class SynchronizedCache
/*    */     extends Cache
/*    */   {
/*    */     Object mutex;
/*    */     Cache cache;
/*    */     
/*    */     SynchronizedCache(Cache cache) {
/* 35 */       this.cache = cache;
/* 36 */       this.mutex = this;
/*    */     }
/*    */     
/*    */     SynchronizedCache(Cache cache, Object mutex) {
/* 40 */       this.cache = cache;
/* 41 */       this.mutex = mutex;
/*    */     }
/*    */ 
/*    */     
/* 45 */     public void put(Object key, Object value) { synchronized (this.mutex) { this.cache.put(key, value); }
/*    */        }
/*    */ 
/*    */     
/* 49 */     public Object get(Object key) { synchronized (this.mutex) { return this.cache.get(key); }
/*    */        }
/*    */ 
/*    */     
/* 53 */     public boolean containsKey(Object key) { synchronized (this.mutex) { return this.cache.containsKey(key); }
/*    */        }
/*    */ 
/*    */     
/* 57 */     public void close() { synchronized (this.mutex) { this.cache.close(); }
/*    */        }
/*    */ 
/*    */     
/* 61 */     Cache getSynchronizedCache() { return this; }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 71 */   public static Cache synchronizedCache(Cache cache) { return cache.getSynchronizedCache(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 82 */   Cache getSynchronizedCache() { return new SynchronizedCache(this); }
/*    */   
/*    */   public abstract void put(Object paramObject1, Object paramObject2);
/*    */   
/*    */   public abstract Object get(Object paramObject);
/*    */   
/*    */   public abstract boolean containsKey(Object paramObject);
/*    */   
/*    */   public abstract void close();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\cache\Cache.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.cache.SimpleLRUCache,"/*    */ package org.apache.lucene.util.cache;
/*    */ 
/*    */ import java.util.LinkedHashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SimpleLRUCache
/*    */   extends SimpleMapCache
/*    */ {
/*    */   private static final float LOADFACTOR = 0.75F;
/*    */   private int cacheSize;
/*    */   
/*    */   public SimpleLRUCache(int cacheSize) {
/* 38 */     super(null);
/* 39 */     this.cacheSize = cacheSize;
/* 40 */     int capacity = (int)Math.ceil((cacheSize / 0.75F)) + 1;
/*    */     
/* 42 */     this.map = new LinkedHashMap(capacity, 0.75F, true)
/*    */       {
/* 44 */         protected boolean removeEldestEntry(Map.Entry eldest) { return (size() > SimpleLRUCache.this.cacheSize); }
/*    */         
/*    */         private final SimpleLRUCache this$0;
/*    */       };
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\cache\SimpleLRUCache.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.cache.SimpleMapCache,"/*    */ package org.apache.lucene.util.cache;
/*    */ 
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ import java.util.Set;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SimpleMapCache
/*    */   extends Cache
/*    */ {
/*    */   Map map;
/*    */   
/* 33 */   public SimpleMapCache() { this(new HashMap()); }
/*    */ 
/*    */ 
/*    */   
/* 37 */   public SimpleMapCache(Map map) { this.map = map; }
/*    */ 
/*    */ 
/*    */   
/* 41 */   public Object get(Object key) { return this.map.get(key); }
/*    */ 
/*    */ 
/*    */   
/* 45 */   public void put(Object key, Object value) { this.map.put(key, value); }
/*    */ 
/*    */ 
/*    */   
/*    */   public void close() {}
/*    */ 
/*    */ 
/*    */   
/* 53 */   public boolean containsKey(Object key) { return this.map.containsKey(key); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 60 */   public Set keySet() { return this.map.keySet(); }
/*    */ 
/*    */ 
/*    */   
/* 64 */   Cache getSynchronizedCache() { return new SynchronizedSimpleMapCache(this); }
/*    */   
/*    */   private static class SynchronizedSimpleMapCache
/*    */     extends SimpleMapCache {
/*    */     Object mutex;
/*    */     SimpleMapCache cache;
/*    */     
/*    */     SynchronizedSimpleMapCache(SimpleMapCache cache) {
/* 72 */       this.cache = cache;
/* 73 */       this.mutex = this;
/*    */     }
/*    */ 
/*    */     
/* 77 */     public void put(Object key, Object value) { synchronized (this.mutex) { this.cache.put(key, value); }
/*    */        }
/*    */ 
/*    */     
/* 81 */     public Object get(Object key) { synchronized (this.mutex) { return this.cache.get(key); }
/*    */        }
/*    */ 
/*    */     
/* 85 */     public boolean containsKey(Object key) { synchronized (this.mutex) { return this.cache.containsKey(key); }
/*    */        }
/*    */ 
/*    */     
/* 89 */     public void close() { synchronized (this.mutex) { this.cache.close(); }
/*    */        }
/*    */ 
/*    */     
/* 93 */     public Set keySet() { synchronized (this.mutex) { return this.cache.keySet(); }
/*    */        }
/*    */ 
/*    */     
/* 97 */     Cache getSynchronizedCache() { return this; }
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.4.0.jar!\org\apache\lucen\\util\cache\SimpleMapCache.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
