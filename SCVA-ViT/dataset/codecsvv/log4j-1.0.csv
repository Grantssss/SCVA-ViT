metric_name,file
org.apache.log4j.Appender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;
/**
   This interface 
Implement this interface for your own strategies for printing log
   statements. 
   @author Ceki G&uuml;lc&uuml;
*/
public interface Appender {
  /**
     Add a filter to the end of the filter list.
     @since 0.9.0
   */
  void addFilter(Filter newFilter);
  /**
     Clear the list of filters by removing all the filters in it.
     @since 0.9.0
   */
  public
  void clearFilters();
  /**
     Release any resources allocated within the appender such as file
     handles, network connections, etc.
     <p>It is a programming error to append to a closed appender.
     @since 0.8.4
  */
  public
  void close();
  /**
     Log in Appender specific way.  */
  public
  void doAppend(LoggingEvent event);
  /**
     Get the name of this appender. The name uniquely identifies the
     appender.  */
  public
  String getName();
  /**
     Set the {@link ErrorHandler} for this appender.
     @ since 0.9.0
   */
  public
  void setErrorHandler(ErrorHandler errorHandler);
  /**
     Set the {@link Layout} for this appender.
     @since 0.8.1
  */
  public
  void setLayout(Layout layout);
  /**
     Set the name of this appender. The name is used by other
     components to identify this appender.
     @since 0.8.1
  */
  public
  void setName(String name);
  /**
     Configurators call this method to determine if the appender
    requires a layout. If this method returns <code>true</code>,
    meaning that layout is required, then the configurator will
    configure an layout using the configuration information at its
    disposal.  If this method returns <code>false</code>, meaning that
    a layout is not required, then layout configuration will be
    skipped even if there is available layout configuration
    information at the disposal of the configurator..
     <p>In the rather exceptional case, where the appender
     implementation admits a layout but can also work without it, then
     the appender should return <code>true</code>.
     @since 0.8.4 */
  public
  boolean requiresLayout();
}
"
org.apache.log4j.AppenderSkeleton,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OnlyOnceErrorHandler;
import org.apache.log4j.helpers.LogLog;
/** 
   Abstract super-class of the other appenders in the package.
   This class provides threashold filtering 
   @since 0.8.1
   @author Ceki G&uuml;lc&uuml;
 */
public abstract class AppenderSkeleton implements Appender, OptionHandler {
  /** The layout variable does not need to be set if the appender
      implementation has its own layout. */
  protected Layout layout;
  /** Appenders are named. */
  protected String name;
  /**
     There is no priority threshold filtering by default.  */
  protected Priority threshold;
  /** 
      It is assumed and enforced that errorHandler is never null.
  */
  protected ErrorHandler errorHandler = new OnlyOnceErrorHandler();
  /** The first filter in the filter chain. Set to <code>null</code>
      initially. */
  protected Filter headFilter;
  /** The last filter in the filter chain. */
  protected Filter tailFilter;
  /**
     Is this appender closed? 
   */
  protected boolean closed = false;
  /**
     The variable <code>emittedWarning</code> lets us remember whether
     we already emitted a warning to <code>System.err.</code>  */
  //  protected boolean emittedWarning = false;
  /**
     A string constant used in naming the option for setting the
     threshold for the appender. See also {@link #setThreshold
     setThreshold} method. Current value of this string constant is
     <b>Threshold</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String THRESHOLD_OPTION = ""Threshold"";
  /**
     Derived appenders should override this method if option structure
     requires it.  */
  public
  void activateOptions() {
  }
  /**
     Add a filter to end of the filter list.
     @since 0.9.0
   */
  public
  void addFilter(Filter newFilter) {
    if(headFilter == null) {
      headFilter = tailFilter = newFilter;
    } else {
      tailFilter.next = newFilter;
      tailFilter = newFilter;    
    }
  }
  /**
     Subclasses of <code>AppenderSkeleton</code> should imlement this
     method to perform actual logging. See also {@link #doAppend
     AppenderSkeleton.doAppend} method.
     @since 0.9.0
  */
  abstract
  protected
  void append(LoggingEvent event);
  /**
     Clear the filters chain.
     @since 0.9.0 */
  public
  void clearFilters() {
    headFilter = tailFilter = null;
  }
  /**
     Finalize this appender by calling the imlenentation's
     <code>close</code> method.
     @since 0.8.4
  */
  public
  void finalize() {
    // An appender might be closed then garbage collected. There is no
    // point in closing twice.
    if(this.closed) 
      return;
    LogLog.debug(""Finalizing appender named [""+name+""]."");
    close();
  }
  /** 
      Return the currently set {@link ErrorHandler} for this
      Appender.  
      @since 0.9.0 */
  public
  ErrorHandler getErrorHandler() {
    return this.errorHandler;
  }
  /** 
      Return the first filter in the filter chain for this
      Appender. The return value may be <code>null</code> if no is
      filter is set.
  */
  public
  final
  Filter getFirstFilter() {
    return headFilter;
  }
  /**
     Returns the name of this FileAppender.
   */
  public
  final
  String getName() {
    return this.name;
  }
  /**
     Returns the string array {{@link #THRESHOLD_OPTION}}.
     <p>Configurable Appenders must override this method to return the
     additional options they accept.  */
  public
  String[] getOptionStrings() {
    return new String[] {THRESHOLD_OPTION};
  }
  /**
     Check whether the message priority is below the appender's
     threshold. Ig there is no threshold set, then the return value is
     always <code>true</code>.
  */
  public
  boolean isAsSevereAsThreshold(Priority priority) {
    return ((threshold == null) || priority.isGreaterOrEqual(threshold));
  }
  /**
     This method performs threshold checks and invokes filters before
     delegating actual logging to the sub-classes specific {@link
     AppenderSkeleton#append} method.
   */
  public
  synchronized 
  void doAppend(LoggingEvent event) {
    if(closed) {
      LogLog.error(""Attempted to append to closed appender named [""+name+""]."");
    }
    if(!isAsSevereAsThreshold(event.priority)) {
      return;
    }
    Filter f = this.headFilter;
    FILTER_LOOP:
    while(f != null) {
      switch(f.decide(event)) {
      case Filter.DENY: return;
      case Filter.ACCEPT: break FILTER_LOOP;
      case Filter.NEUTRAL: f = f.next;
      }
    }
    this.append(event);    
  }
  /** 
      Set the {@link ErrorHandler} for this Appender.
      @since 0.9.0
  */
  public
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // We do not throw exception here since the cause is probably a
      // bad config file.
      LogLog.error(
              ""It is forbidden to set a null ErrorHandler. Ignoring directive."");
    } else {
      this.errorHandler = eh;
    }
  }
  /**
     Set the layout for this appender. Note that some appenders have
     their own (fixed) layouts or do not use one. For example, the
     {@link org.apache.log4j.net.SocketAppender} ignores the layout set
     here. 
  */
  public
  void setLayout(Layout layout) {
    this.layout = layout;
  }
  /**
     Set the name of this Appender.
   */
  public
  void setName(String name) {
    this.name = name;
  }
  /**
     Configurable Appenders should override this method if they admit
     additional options.
     All classes derived from {@link AppenderSkeleton} admit the
     <b>Threshold</b> option, that is the value of the string constant
     {@link #THRESHOLD_OPTION}.
     See {@link #setThreshold} method for the meaning of this option.
  */
  public
  void setOption(String key, String value) {
    if(key.equalsIgnoreCase(THRESHOLD_OPTION)) {
      threshold = Priority.toPriority(value);
    }
  }
  /**
     Set the threshold priority. All log events with lower priority
     than the threshold priority are ignored by the appender.
     @since 0.8.3 */
  public
  void setThreshold(Priority threshold) {
    this.threshold = threshold;
  }
}
"
org.apache.log4j.AsyncAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.Category;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.BoundedFIFO;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.LogLog;
import java.util.Enumeration;
/**
   The AsyncAppender lets users log events asynchronously. It uses a
   bounded buffer to store logging events.
   <p>The AsyncAppender will collect the events sent to it and then
   dispatch them to all the appenders that are attached to it. You can
   attach multiple appenders to an AsyncAppender.
   <p>The AsyncAppender uses a separate thread to serve the events in
   its bounded buffer. 
   <p>Refer to the results in {@link org.apache.log4j.performance.Logging}
   for the impact of using this appender.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public class AsyncAppender extends AppenderSkeleton 
                                            implements AppenderAttachable {
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  
     <p>Note that all option keys are case sensitive.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  static final int BUFFER_SIZE = 128;
  //static Category cat = Category.getInstance(AsyncAppender.class.getName());
  BoundedFIFO bf = new BoundedFIFO(BUFFER_SIZE);
  AppenderAttachableImpl aai;
  Dispatcher dispatcher;
  boolean locationInfo = false;
  public
  AsyncAppender() {
    aai = new AppenderAttachableImpl();
    dispatcher = new Dispatcher(bf, aai);
    dispatcher.start();
  }
  synchronized  
  public 
  void addAppender(Appender newAppender) {
    aai.addAppender(newAppender);
  }
  public
  void append(LoggingEvent event) {
    // Set the NDC and thread name for the calling thread as these
    // LoggingEvent fields were not set at event creation time.
    event.getNDC();
    event.getThreadName();
    if(locationInfo) {
      event.setLocationInformation();	
    }
    synchronized(bf) {
      if(bf.isFull()) {
	try {
	  //cat.debug(""Waiting for free space in buffer."");
	  bf.wait();
	} catch(InterruptedException e) {
	  LogLog.error(""AsyncAppender cannot be interrupted."", e);
	}
      }
      //cat.debug(""About to put new event in buffer."");      
      bf.put(event);
      if(bf.wasEmpty()) {
	//cat.debug(""Notifying dispatcher to process events."");
	bf.notify();
      }
    }
  }
  /**
     Close this <code>AsyncAppender</code> by interrupting the
     dispatcher thread which will process all pending events before
     exiting. */
  public 
  void close() {
    //cat.info(""Closing appender [""+name+""]."");
    closed = true;
    dispatcher.interrupt();
    try {
      dispatcher.join();
    } catch(InterruptedException e) {
      LogLog.error(""Got an InterruptedException while waiting for the ""+
		   ""dispatcher to finish."", e);
    }
    dispatcher = null;
    bf = null;
  }
  public
  Enumeration getAllAppenders() {
    return aai.getAllAppenders();
  }
  public
  Appender getAppender(String name) {
    return aai.getAppender(name);
  }
 /**
     Retuns the option names for this component in addition in
     addition to the options of its super class {@link
     AppenderSkeleton}.  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {LOCATION_INFO_OPTION});
  }
  /**
     The <code>AsyncAppender</code> does not require a layout. Hence,
     this method always returns <code>false</code>. */
  public 
  boolean requiresLayout() {
    return false;
  }
  synchronized
  public
  void removeAllAppenders() {
    aai.removeAllAppenders();
  }
  synchronized
  public
  void removeAppender(Appender appender) {
   aai.removeAppender(appender);
  }
  synchronized
  public
  void removeAppender(String name) {
    aai.removeAppender(name);
  }
 /**
     Set SMTPAppender specific options.
     <p>On top of the options of the super class {@link
     AppenderSkeleton}, the only recognized options is
     <b>LocationInfo</b>.
     <p>The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the appender and layout will ultimately log the event are
     likely to log the wrong location information (if present in the
     log format).
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
 */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);
    if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
  }
}
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
class Dispatcher extends Thread {
  BoundedFIFO bf;
  AppenderAttachableImpl aai;
  Dispatcher(BoundedFIFO bf, AppenderAttachableImpl aai) {
    this.bf = bf;
    this.aai = aai;
    // set the dispatcher priority to lowest possible value
    this.setPriority(Thread.MIN_PRIORITY);
    // set the dispatcher priority to MIN_PRIORITY plus or minus 2
    // depending on the direction of MIN to MAX_PRIORITY.
    //+ (Thread.MAX_PRIORITY > Thread.MIN_PRIORITY ? 1 : -1)*2);
  }
  /**
     The dispatching strategy is to wait until there are events in the
     buffer to process. After having processed an event, we release
     the monitor (variable bf) so that new events can be placed in the
     buffer, instead of keeping the monitor and processing remaning
     events in the buffer. 
    <p>Other approaches might yield better results.
  */
  public
  void run() {
    //Category cat = Category.getInstance(Dispatcher.class.getName());
    LoggingEvent event;
    while(true) {
      synchronized(bf) {
	if(bf.length() == 0) {
	  // exit loop if we are interrupted but only if the the
	  // buffer is empty.
	  if(interrupted()) { 
	    //cat.info(""Exiting."");
	    return;
	  }
	  try {
	    //cat.debug(""Waiting for new event to dispatch."");
	    bf.wait();
	  } catch(InterruptedException e) {
	    //cat.info(""Dispatcher interrupted."");
	    break;
	  }
	}
	//cat.debug(""About to get new event."");
	event = bf.get();
	if(bf.wasFull()) {
	  //cat.debug(""Notifiying AsyncAppender about freed space."");
	  bf.notify();
	}
      } // synchronized
      if(aai != null)
	aai.appendLoopOnAppenders(event);
    } // while
  }
}
"
org.apache.log4j.BasicConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contibutors: ""Luke Blanshard"" <Luke@quiq.com>
//              ""Mark DONSZELMANN"" <Mark.Donszelmann@cern.ch>
//              ""Muly Oved"" <mulyoved@hotmail.com>
package org.apache.log4j;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.util.Enumeration;
/**
   Use this class to quickly configure the package.
   <p>For file based configuration see {@link
   PropertyConfigurator}. For XML based configuration see {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}.
   @since 0.8.1
   @author Ceki G&uuml;lc&uuml; */
public class BasicConfigurator {
  /**
     Setting the system property <b>log4j.disableOverride</b> to
     ""true"" or any other value than ""false"" overrides the effects of
     all methods {@link #disable}, {@link #disableAll}, {@link
     #disableDebug} and {@link #disableInfo}. Thus, enabling normal
     evaluation of logging requests, i.e. according to the <a
     href=""../../manual.html#selectionRule"">Basic Selection Rule</a>.
     <p><code>DISABLE_OVERRIDE_KEY</code> is the name of the constant
     holding the string value <b>log4j.disableOverride</b>.
     @since 0.8.5 */ 
     public static final String DISABLE_OVERRIDE_KEY = ""log4j.disableOverride"";
  /**
     Special priority value signifying inherited behaviour. The
     current value of this string constant is <b>inherited</b>.
  */
  public static final String INHERITED = ""inherited"";
  // This variable will be set to true if some configuration file sets
  // log4j.shippedCodeFlagOverride or an equivalent variable to true
  // (or any other valeu than false).
  // protected static boolean SCFOverride = false;
  // Check if value of(DISABLE_OVERRIDE_KEY) system property is set.
  // If it is set to ""true"" or any value other than ""false"", then set
  // static variable Category.disable to Category.DISABLE_OVERRIDE.
  static {
    String override = null;
    String propertyName = DISABLE_OVERRIDE_KEY;    
    try {
      override=System.getProperty(propertyName, override);
    } catch(SecurityException e) {
      LogLog.debug(""Could not read system property \""""+
		   propertyName+""\""."", e);
    }
    if(override != null) {
      if(OptionConverter.toBoolean(override, true)) {
	LogLog.debug(""Overriding disable. Non-null system property "" + 
		     DISABLE_OVERRIDE_KEY + ""=["" + override +""]."");
	Category.disable = Category.DISABLE_OVERRIDE;
      }
    }
  }
  protected BasicConfigurator() {
  }
  /**
     Used by subclasses to add a renderer to the default hieararchy.
   */
  protected
  void addRenderer(String renderedClassName, String renderingClassName) {
    LogLog.debug(""Rendering class: [""+renderingClassName+""], Rendered class: [""+
		 renderedClassName+""]."");
    ObjectRenderer renderer = (ObjectRenderer) 
             OptionConverter.instantiateByClassName(renderingClassName, 
						    ObjectRenderer.class,
						    null);
    if(renderer == null) {
      LogLog.error(""Could not isntantiate renderer [""+renderingClassName+""]."");
      return;
    } else {
      try {
	Class renderedClass = Class.forName(renderedClassName);
	Category.defaultHierarchy.rendererMap.put(renderedClass, renderer);
      } catch(ClassNotFoundException e) {
	LogLog.error(""Could not find class [""+renderedClassName+""]."", e);
      }
    }
  }
  /**
     Add a {@link FileAppender} that uses {@link PatternLayout} using
     the {@link PatternLayout#TTCC_CONVERSION_PATTERN} and prints to
     <code>System.out</code> to the root category.  */
  static
  public
  void configure() {
    Category root = Category.getRoot();
    root.addAppender(new FileAppender(
	new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN), System.out));
  }
  /**
     Add <code>appender</code> to the root category.
     @param appender The appender to add to the root category.
  */
  static
  public
  void configure(Appender appender) {
    Category root = Category.getRoot();
    root.addAppender(appender);
  }
/**
     Disable all logging requests of priority <em>equal to or
     below</em> the priority parameter <code>p</code>, regardless of
     the request category. Logging requests of higher priority then
     the priority of <code>p</code> remain unaffected.
     <p>Nevertheless, if the {@link #DISABLE_OVERRIDE_KEY} system
     property is set to ""true"" or any value other than ""false"", then
     logging requests are evaluated as usual, i.e. according to the <a
     href=""../../manual.html#selectionRule"">Basic Selection Rule</a>.
     <p>The ""disable"" family of methods are there for speed. They
     allow printing methods such as debug, info, etc. to return
     immediately after an interger comparison without walking the
     category hierarchy. In most modern computers an integer
     comparison is measured in nanoseconds where as a category walk is
     measured in units of microseconds.
     <p>Other configurators define alternate ways of overriding the
     disable override flag. See {@link PropertyConfigurator} and
     {@link org.apache.log4j.xml.DOMConfigurator}.
     @since 0.8.5 */
  static 
  public
  void disable(Priority p) {
    if(Category.disable != Category.DISABLE_OVERRIDE) {
      Category.disable = p.level;
    }
  }
  /**
     Disable all logging requests regardless of category and priority.
     This method is equivalent to calling {@link #disable} with the
     argument {@link Priority#FATAL}, the highest possible priority.
     @since 0.8.5 */
  static 
  public
  void disableAll() {
    disable(Priority.FATAL);
  }
  /**
     Disable all logging requests of priority DEBUG regardless of
     category.  Invoking this method is equivalent to calling {@link
     #disable} with the argument {@link Priority#DEBUG}.
     @since 0.8.5 */
  static 
  public
  void disableDebug() {
    disable(Priority.DEBUG);
  }
  /**
     Disable all logging requests of priority INFO and below
     regardless of category. Note that DEBUG messages are also
     disabled.  
     <p>Invoking this method is equivalent to calling {@link #disable}
     with the argument {@link Priority#INFO}.
     @since 0.8.5 */
  static 
  public
  void disableInfo() {
    disable(Priority.INFO);
  }  
  /**
     Undoes the effect of calling any of {@link #disable}, {@link
     #disableAll}, {@link #disableDebug} and {@link #disableInfo}
     methods. More precisely, invoking this method sets the Category
     class internal variable called <code>disable</code> to its
     default ""off"" value.
     @since 0.8.5 */
  static 
  public
  void enableAll() {
    Category.disable = Category.DISABLE_OFF;
  }
  /**
     This method is equivalent to the {@link #disableInfo} method.
     @deprecated
     @since 0.8.0 */
  public
  static
  void flagAsShippedCode() {
    disableInfo();
  }
  /**
     Override the shipped code flag if the <code>override</code>
     parameter is not null.
     <p>If <code>override</code> is null then there is nothing to do.
     Otherwise, set Category.shippedCode to false if override has a
     value other than ""false"".     
  */
  protected
  static
  void overrideAsNeeded(String override) {
    // If override is defined, any value other than false will be
    // interpreted as true.    
    if(override != null) {
      LogLog.debug(""Handling non-null disable override directive: \""""+
		   override +""\""."");
      if(OptionConverter.toBoolean(override, true)) {
	LogLog.debug(""Overriding all disable methods."");
	Category.disable = Category.DISABLE_OVERRIDE;
      }
    }
  }
  /**
     Reset the configuration to its default.  This removes all
     appenders from all categories, sets the priority of all non-root
     categories to <code>null</code>, their additivity flad to
     <code>true</code> and sets the priority of the root category to
     {@link Priority#DEBUG DEBUG}.  Moreover, message disabling is set
     its default ""off"" value.
     <p>This method should be used sparingly and with care as it will
     block all logging until it is completed.</p>
     @since version 0.8.5 */
  public
  static
  void resetConfiguration() {
    Category.defaultHierarchy.getRoot().setPriority(Priority.DEBUG);
    Category.defaultHierarchy.root.setResourceBundle(null);
    Category.disable =  Category.DISABLE_OFF;
    // the synchronization is needed to prevent JDK 1.2.x hashtable
    // surprises
    synchronized(Category.defaultHierarchy.ht) {    
      Category.defaultHierarchy.shutdown(); // nested locks are OK    
      Enumeration cats = Category.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.setPriority(null);
	c.setAdditivity(true);
	c.setResourceBundle(null);
      }
    }
    Category.defaultHierarchy.rendererMap.clear();
  }
}
"
org.apache.log4j.Category,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contibutors: Alex Blewitt <Alex.Blewitt@ioshq.com>
//              Markus Oestreicher <oes@zurich.ibm.com>
//              Frank Hoering <fhr@zurich.ibm.com>
//              Nelson Minar <nelson@media.mit.edu>
//              Jim Cakalic <jim_cakalic@na.biomerieux.com>
//              Avy Sharell <asharell@club-internet.fr>
//              Ciaran Treanor <ciaran@xelector.com>
//              Jeff Turner <jeff@socialchange.net.au>
//              Horwitz, Michael <MHorwitz@siemens.co.za>
package org.apache.log4j;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.NullEnumeration;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
import java.util.Enumeration;
import java.util.Vector;
import java.util.MissingResourceException;
import java.text.MessageFormat;
import java.util.ResourceBundle;
import java.net.URL;
import java.net.MalformedURLException;
/**
  This is the central class in the log4j package. One of the distintive
  features of log4j are hierarchal categories and their evaluation.
  <p>See the <a href=""../../manual.html"">user manual</a> for an
  introduction on this class.
  @author Ceki G&uuml;lc&uuml;
  @author Anders Kristensen 
  */
public class Category implements AppenderAttachable {
  // DISABLE_OFF should be set to a value lower than all possible
  // priorities.
  static final int DISABLE_OFF = -1;
  static final int DISABLE_OVERRIDE = -21;
  private static String DEFAULT_FQN = ""org.apache.log4j.Category"";
  protected static String instanceFQN;
  // Don't disable any priority level by default.
  protected static int disable = Category.DISABLE_OFF;
  static boolean emittedNoAppenderWarning = false;
  static boolean emittedNoResourceBundleWarning = false;  
  // default is a language reserved term, we exceptionally prefix with
  // an undescore.
  static 
  public 
  final Hierarchy defaultHierarchy = new Hierarchy(new 
						   RootCategory(Priority.DEBUG));
  protected ResourceBundle resourceBundle;
  // Categories need to know what Hierarchy they are in
  protected Hierarchy myContext;
  /**
     This string constant is set to <b>log4j.properties</b> the name
     of the file that will be searched by default in classpath. If the
     file can be found, then it is fed to the {@link
     PropertyConfigurator}.
     See also {@link #DEFAULT_CONFIGURATION_KEY} for a more general
     alternative.
     @since 0.8.5 */
     static public final String DEFAULT_CONFIGURATION_FILE = ""log4j.properties"";
  /**
     This String constant is set to <b>log4j.configuration</b>. 
     <p>It corresponds to name of the system property which, if set,
     specifies the name of the resource containing the properties file
     or {@link URL} with which log4j should configure itself. 
     <p>Setting the <b>log4j.configuration</b> system property
     overrides the default search for the file
     <b>log4j.properties</b>.
     <p>Note that property keys are case sensitive.  
     @since 1.0 */
     static final public String DEFAULT_CONFIGURATION_KEY=""log4j.configuration"";
  /**
      Setting the system property <b>log4j.defaultInitOverride</b> to
      ""true"" or any other value than ""false"" will skip default
      configuration from the <code>log4j.properties</code> file.
     The current value of the DEFAULT_INIT_OVERRIDE_KEY string
     constant is <b>log4j.defaultInitOverride</b>.
     <p>Note that property keys are case sensitive.  
     @since 0.8.5 */
  public static final String DEFAULT_INIT_OVERRIDE_KEY = 
                                                 ""log4j.defaultInitOverride"";
  /** Search for the properties file log4j.properties in the CLASSPATH.  */
  static {
    String override = null;
    try {
      override=System.getProperty(DEFAULT_INIT_OVERRIDE_KEY, override);
    } catch(SecurityException e) {
      LogLog.debug(""Could not read system property \""""+
		   	   DEFAULT_INIT_OVERRIDE_KEY +""\""."", e);
    }
    // if there is no default init override, them get the resource
    // specified by the user or the default config file.
    if(override == null || ""false"".equalsIgnoreCase(override)) {
      String resource = System.getProperty(DEFAULT_CONFIGURATION_KEY, 
					   DEFAULT_CONFIGURATION_FILE);
      URL url = null;
      try {
	url = new URL(resource);
      } catch (MalformedURLException ex) {
	// so, resource is not a URL:
	// attempt to get the resource in the most generic way:
	url = Category.class.getResource(resource);
	if(url == null) {
	  // if that doen't work, then try again in a slightly
	  // different way
	  ClassLoader loader = Category.class.getClassLoader();
	  if(loader != null) {
	    url = loader.getResource(resource);	  
	  }
	}	
      }	
      // If we have a non-null url, then delegate the rest of the
      // configuration to the OptionConverter.selectAndConfigure
      // method.
      if(url != null) {
	OptionConverter.selectAndConfigure(url);
      } else {
	LogLog.debug(""Could not find resource: [""+resource+""]."");
      }
    }  
  } 
  /**
     The name of this category.
  */
  protected String   name;  
  /**
     The assigned priority of this category.  The
     <code>priority</code> variable need not be assined a value in
     which case it is inherited form the hierarchy.  */
  protected Priority priority;
  /**
     The parent of this category. All categories have at least one
     ancestor which is the root category. */
  protected Category parent;
  AppenderAttachableImpl aai;
  /** Additivity is set to true by default, that is children inherit
      the appenders of their ancestors by default. If this variable is
      set to <code>false</code> then the appenders found in the
      ancestors of this category are not used. However, the children
      of this category will inherit its appenders, unless the children
      have their additivity flag set to <code>false</code> too. See
      the user manual for more details. */
  protected boolean additive = true;
  /**
     This constructor created a new <code>Category</code> instance and
     sets its name.
     <p>It is intended to be used by sub-classes only. You should not
     create categories directly.
     @param name The name of the category.  */
  protected 
  Category(String name) {
    this.name = name;
    this.instanceFQN = DEFAULT_FQN;
  }
  /**
     Add <code>newAppender</code> to the list of appenders of this
     Category instance.
     <p>If <code>newAppender</code> is already in the list of
     appenders, then it won't be added again.
  */
  synchronized  
  public 
  void addAppender(Appender newAppender) {
    if(aai == null) {
      aai = new AppenderAttachableImpl();
    }
    aai.addAppender(newAppender);
  }
  /**
     If <code>assertion</code> parameter is <code>false</code>, then
     logs <code>msg</code> as an {@link #error(Object) error} statement.
     @param assertion 
     @param msg The message to print if <code>assertion</code> is
     false.
     @since 0.8.1 */
  public
  void assert(boolean assertion, String msg) {
    if(!assertion)
      this.error(msg);
  }
  /**
     Call the appenders in the hierrachy starting at
     <code>this</code>.  If no appenders could be found, emit a
     warning.
     <p>This method always calls all the appenders inherited form the
     hierarchy circumventing any evaluation of whether to log or not
     to log the particular log request.
     @param LoggingEvent the event to log.  */
  public
  void callAppenders(LoggingEvent event) {
    int writes = 0;
    for(Category c = this; c != null; c=c.parent) {
      // Protected against simultaneous call to addAppender, removeAppender,...
      synchronized(c) {
	if(c.aai != null) {
	  writes += c.aai.appendLoopOnAppenders(event);
	}
	if(!c.additive) {
	  break;
	}
      }
    }
    // No appenders in hierarchy, warn user only once.
    if(!Category.emittedNoAppenderWarning && writes == 0) {
      LogLog.error(""No appenders could be found for category ("" +
		    this.getName() + "")."");
      LogLog.error(""Please initialize the log4j system properly."");
      emittedNoAppenderWarning = true;
    }
  }
  /**
     Close all attached appenders implementing the AppenderAttachable
     interface.  
     @since 1.0
  */
  synchronized
  void closeNestedAppenders() {
    Enumeration enum = this.getAllAppenders();
    if(enum != null) {
      while(enum.hasMoreElements()) {
	Appender a = (Appender) enum.nextElement();
	if(a instanceof AppenderAttachable) {
	  a.close();
	}
      }
    }
  }
  /** 
    Log a message object with the {@link Priority#DEBUG DEBUG} priority.
    <p>This method first checks if this category is <code>DEBUG</code>
    enabled by comparing the priority of this category with the {@link
    Priority#DEBUG DEBUG} priority. If this category is
    <code>DEBUG</code> enabled, then it converts the message object
    (passed as parameter) to a string by invoking the appropriate
    {@link ObjectRenderer}. It then proceeds to call all the
    registered appenders in this category and also higher in the
    hierarchy depending on the value of the additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the <code>Throwable</code> but no
    stack trace. To print a stack trace use the {@link #error(Object,
    Throwable)} form instead.
    @param message the message object to log. */
  public
  void debug(Object message) {
    if(disable >=  Priority.DEBUG_INT) 
      return;    
    if(Priority.DEBUG.isGreaterOrEqual(this.getChainedPriority())) {
      forcedLog(instanceFQN, Priority.DEBUG, message, null);
    }
  }
  /** 
   Log a message object with the <code>DEBUG</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #debug(Object)} form for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */    
  public
  void debug(Object message, Throwable t) {
    if(disable >=  Priority.DEBUG_INT) 
      return;   
    if(Priority.DEBUG.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(instanceFQN, Priority.DEBUG, message, t);
  }
  //public
  //void dump() {
  //  System.out.println(""Category "" + name + "" dump -----"");
  //  for(Category c = this; c != null; c=c.parent)
  //	System.out.println(""(""+c.name+"", ""+c.priority+"") ->"");
  //  System.out.println(""---------------------------"");
  //
  //}
  /** 
    Log a message object with the {@link Priority#ERROR ERROR} priority.
    <p>This method first checks if this category is <code>ERROR</code>
    enabled by comparing the priority of this category with {@link
    Priority#ERROR ERROR} priority. If this category is
    <code>ERROR</code> enabled, then it converts the message object
    passed as parameter to a string by invoking the appropriate {@link
    ObjectRenderer}. It proceeds to call all the registered appenders
    in this category and also higher in the hierarchy depending on
    the value of the additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the <code>Throwable</code> but no
    stack trace. To print a stack trace use the {@link #error(Object,
    Throwable)} form instead.
    @param message the message object to log */
  public
  void error(Object message) {
    if(disable >=  Priority.ERROR_INT) return;
    if(this.isEnabledFor(Priority.ERROR))
      forcedLog(instanceFQN, Priority.ERROR, message, null);
  }
  /** 
   Log a message object with the <code>ERROR</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #error(Object)} form for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */  
  public
  void error(Object message, Throwable t) {
    if(disable >=  Priority.ERROR_INT) return;
    if(this.isEnabledFor(Priority.ERROR))
      forcedLog(instanceFQN, Priority.ERROR, message, t);
  }
  /**
     If the named category exists (in the default hierarchy) then it
     returns a reference to the category, otherwise it returns
     <code>null</code>.
     <p>Contributed by Ciaran Treanor -  ciaran@xelector.com
     @version version 0.8.5 */
  public
  static
  Category exists(String name) {    
    return defaultHierarchy.exists(name);
  }
  /** 
    Log a message object with the {@link Priority#FATAL FATAL} priority.
    <p>This method first checks if this category is <code>FATAL</code>
    enabled by comparing the priority of this category with {@link
    Priority#FATAL FATAL} priority. If the category is <code>FATAL</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate {@link ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hierarchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #fatal(Object, Throwable)} form
    instead. 
    @param message the message object to log */
  public
  void fatal(Object message) {
    if(disable >=  Priority.FATAL_INT) return;    
    if(Priority.FATAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(instanceFQN, Priority.FATAL, message, null);
  }
  /** 
   Log a message object with the <code>FATAL</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #fatal(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void fatal(Object message, Throwable t) {
    if(disable >=  Priority.FATAL_INT) return;   
    if(Priority.FATAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(instanceFQN, Priority.FATAL, message, t);
  }
  /**
     This method renders the <code>message</code> passed as a
     oaraneter and logs immediately without further checks.  */
  protected
  void forcedLog(String fqn, Priority priority, Object message, Throwable t) {
    String s;
    if(message instanceof String) {
      s = (String) message;
    } else {
      s = myContext.rendererMap.findAndRender(message);
    }
    callAppenders(new LoggingEvent(fqn, this, priority, s, t));
  }
  /**
     Get the additivity flag for this Category instance.  
  */
  public
  boolean getAdditivity() {
    return additive;
  }
  /**
     Get the appenders contained in this category as an
     Enumeration. If there are no appenders in this category
     <code>null</code> is returned.
     @return Enumeration An enumeration of the appenders in this category.  
  */
  public
  Enumeration getAllAppenders() {
    if(aai == null)
      return NullEnumeration.getInstance();
    else 
      return aai.getAllAppenders();
  }
  /**
     Look for the appender named as <code>name</code>.
     <p>Return the appender with that name if in the list. Return null
     otherwise.  
  */
  public
  Appender getAppender(String name) {
     if(aai == null || name == null)
      return null;
     return aai.getAppender(name);
  }
  /**
     Starting from this category, search the category hierarchy for a
     non-null priority and return it. Otherwise, return the priority of the
     root category.
     <p>The Category class is designed so that this method executes as
     quickly as possible.
   */
  public 
  Priority getChainedPriority() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.priority != null) 
	return c.priority;
    }
    return null; // If reached will cause an NullPointerException.
  }
  /**
     Returns all the currently defined categories in the default
     hierarchy as an {@link java.util.Enumeration Enumeration}.
     <p>The root category is <em>not</em> included in the returned
     {@link Enumeration}.     
  */
  public
  static
  Enumeration getCurrentCategories() {
    // The accumlation in v is necessary because not all elements in
    // HierarchyMaintainer.ht are Category objects as there might be some
    // ProvisionNodes as well.       
    Vector v = new Vector(defaultHierarchy.ht.size());
    Enumeration elems = defaultHierarchy.ht.elements();
    while(elems.hasMoreElements()) {
      Object o = elems.nextElement();
      if(o instanceof Category) {
	v.addElement(o);
      }
    }
    return v.elements();
  }
  /**
     Return the default Hierarchy instance.
     @since 1.0
   */
  public 
  static 
  Hierarchy getDefaultHierarchy() {
    return defaultHierarchy;
  }
 /**
     Retrieve a category with named as the <code>name</code>
     parameter. If the named category already exists, then the
     existing instance will be reutrned. Otherwise, a new instance is
     created. 
     By default, categories do not have a set priority but inherit
     it from the hierarchy. This is one of the central features of
     log4j.
     @param name The name of the category to retrieve.  */
  public
  static
  Category getInstance(String name) {
    return defaultHierarchy.getInstance(name);
  }	
 /**
    Shorthand for <code>getInstance(clazz.getName())</code>.
    @param clazz The name of <code>clazz</code> will be used as the
    name of the category to retrieve.  See {@link
    #getInstance(String)} for more detailed information.
    @since 1.0 */
  public
  static
  Category getInstance(Class clazz) {
    return getInstance(clazz.getName());
  }	
  /**
     Like {@link #getInstance(String)} except that the type of category
     instantiated depends on the type returned by the {@link
     CategoryFactory#makeNewCategoryInstance} method of the
     <code>factory</code> parameter.
     <p>This method is intended to be used by sub-classes.
     @param name The name of the category to retrieve.
     @param factory A {@link CategoryFactory} implementation that will
     actually create a new Instance.
     @since 0.8.5 */
  public
  static
  Category getInstance(String name, CategoryFactory factory) {
    return defaultHierarchy.getInstance(name, factory);
  }	
  /**
     Return the category name.  */
  public
  final
  String getName() {
    return name;
  }
  /**
     Returns the assigned {@link Priority}, if any, for this Category.  
     @return Priority - the assigned Priority, can be <code>null</code>.
  */
  final
  public
  Priority getPriority() {
    return this.priority;
  }
  /**
     Return the root of the default category hierrachy.
     <p>The root category is always instantiated and available. It's
     name is ""root"".
     <p>Nevertheless, calling {@link #getInstance
     Category.getInstance(""root"")} does not retrieve the root category 
     but a category just under root named ""root"".
   */
  final
  public
  static
  Category getRoot() {
    return defaultHierarchy.getRoot();
  }
  /**
     Return the {@link ResourceBundle} for this category.
     <p>This method walks the hierarchy to find the appropriate
     resource bundle.
     <p>In case there is no bundle in the hierarchy then
     <code>null</code> is returned.
     @since 0.9.0 */
  public
  ResourceBundle getResourceBundle() {
    for(Category c = this; c != null; c=c.parent) {
      if(c.resourceBundle != null) 
	return c.resourceBundle;
    }
    // It might be the case that there is no resource bundle 
    return null;
  }
  protected
  String getResourceBundleString(String key) {
    ResourceBundle rb = getResourceBundle();
    // This is one of the rare cases where we can use logging in order
    // to report errors from within log4j.
    if(rb == null) {
      if(!emittedNoResourceBundleWarning) {
	error(""No resource bundle has been set for category ""+name);
	emittedNoResourceBundleWarning = true;
      }
      return null;
    }
    else {
      try {
	return rb.getString(key);
      }
      catch(MissingResourceException mre) {
	error(""No resource is associated with key \""""+key+""\""."");
	return null;
      }
    }
  }
  /** 
    Log a message object with the {@link Priority#INFO INFO} priority.
    <p>This method first checks if this category is <code>INFO</code>
    enabled by comparing the priority of this category with {@link
    Priority#INFO INFO} priority. If the category is <code>INFO</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate {@link ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hierarchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #info(Object, Throwable)} form
    instead. 
    @param message the message object to log */
  public
  void info(Object message) {
    if(disable >=  Priority.INFO_INT) return;    
    if(Priority.INFO.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(instanceFQN, Priority.INFO, message, null);
  }
  /** 
   Log a message object with the <code>INFO</code> priority including
   the stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #info(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void info(Object message, Throwable t) {
    if(disable >=  Priority.INFO_INT) return;   
    if(Priority.INFO.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(instanceFQN, Priority.INFO, message, t);
  }
  /**
     Check whether this category is enabled for the <code>DEBUG</code>
     priority.
     <p> This function is intended to lessen the computational cost of
     disabled log debug statements.
     <p> For some <code>cat</code> Category object, when you write,
     <pre>
       cat.debug(""This is entry number: "" + i );
     </pre>
     <p>You incur the cost constructing the message, concatenatiion in
     this case, regardless of whether the message is logged or not.
     <p>If you are worried about speed, then you should write
     <pre>
       if(cat.isDebugEnabled()) {
         cat.debug(""This is entry number: "" + i );
       }
     </pre>
     <p>This way you will not incur the cost of parameter construction
     if debugging is disabled for <code>cat</code>. On the other hand,
     if the <code>cat</code> is debug enabled, you will incur the cost
     of evaluating whether the category is debug enabled twice. Once
     in <code>isDebugEnabled</code> and once in the
     <code>debug</code>.  This is an insignificant overhead since
     evaluating a category takes about 1% of the time it takes to
     actually log.
     @return boolean - <code>true</code> if this category is debug
     enabled, <code>false</code> otherwise.
   */
  public
  boolean isDebugEnabled() {
    if(disable >=  Priority.DEBUG_INT)
      return false;   
    return Priority.DEBUG.isGreaterOrEqual(this.getChainedPriority());
  }
  /**
     Check whether this category is enabled for a given {@link
     Priority} passed as parameter.
     See also {@link #isDebugEnabled}.
     @return boolean True if this category is enabled for <code>priority</code>.
  */
  public
  boolean isEnabledFor(Priority priority) {
    if(disable >= priority.level) {
      return false;
    }
    return priority.isGreaterOrEqual(this.getChainedPriority());
  }
  /**
    Check whether this category is enabled for the info priority.
    See also {@link #isDebugEnabled}.
    @return boolean - <code>true</code> if this category is enabled
    for priority info, <code>false</code> otherwise.
  */
  public
  boolean isInfoEnabled() {
    if(disable >= Priority.INFO_INT)
      return false;   
    return Priority.INFO.isGreaterOrEqual(this.getChainedPriority());
  }
  /**
     Log a localized message. The user supplied parameter
     <code>key</code> is replaced by its localized version from the
     resource bundle.
     @see #setResourceBundle
     @since 0.8.4 */
  public
  void l7dlog(Priority priority, String key, Throwable t) {
    if(disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      String msg = getResourceBundleString(key);
      // if message corresponding to 'key' could not be found in the
      // resource bundle, then default to 'key'.
      if(msg == null) {
	msg = key;
      }
      callAppenders(new LoggingEvent(instanceFQN, this, priority, msg, t));
    }
  }
  /**
     Log a localized and parameterized message. First, the user
     supplied <code>key</code> is searched in the resource
     bundle. Next, the resulting pattern is formatted using 
     {@link MessageFormat#format(String,Object[])} method with the user
     supplied object array <code>params</code>.
     @since 0.8.4
  */
  public
  void l7dlog(Priority priority, String key,  Object[] params, Throwable t) {
    if(disable >= priority.level) {
      return;
    }    
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      String pattern = getResourceBundleString(key);
      String msg;
      if(pattern == null) 
	msg = key;
      else 
	msg = java.text.MessageFormat.format(pattern, params);
      callAppenders(new LoggingEvent(instanceFQN, this, priority, msg, t));
    }
  }
  /**
     This generic form is intended to be used by wrappers.
   */
  public
  void log(Priority priority, Object message, Throwable t) {
    if(disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) 
      forcedLog(instanceFQN, priority, message, t);
  }
 /**
    This generic form is intended to be used by wrappers.
 */
  public
  void log(Priority priority, Object message) {
    if(disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(instanceFQN, priority, message, null);
  }
  /**
     This is the most generic printing method. It is intended to be
     invoked by wrapper classes.
     @param callerFQN The wrapper class' fully qualified class name.
     @param priority The priority of the logging request.
     @param message The message of the logging request.
     @param t The throwable of the logging request, may be null.
  */
  public
  void log(String callerFQN, Priority priority, Object message, Throwable t) {
    if(disable >= priority.level) {
      return;
    }
    if(priority.isGreaterOrEqual(this.getChainedPriority())) {
      forcedLog(callerFQN, priority, message, t);
    }
  }
  /**
     Remove all previously added appenders from this Category
     instance.
     <p>This is useful when re-reading configuration information.
  */
  synchronized
  public
  void removeAllAppenders() {
    if(aai != null) {
      aai.removeAllAppenders();
      aai = null;
    }
  }
  /**
     Remove the appender passed as parameter form the list of appenders.
     @since 0.8.2
  */
  synchronized
  public
  void removeAppender(Appender appender) {
    if(appender == null || aai == null) 
      return;
    aai.removeAppender(appender);
  }
  /**
     Remove the appender with the name passed as parameter form the
     list of appenders.
     @since 0.8.2 */
  synchronized
  public
  void removeAppender(String name) {
    if(name == null || aai == null) return;
    aai.removeAppender(name);
  }
  /**
     Set the additivity flag for this Category instance.
     @since 0.8.1
   */
  public
  void setAdditivity(boolean additive) {
    this.additive = additive;
  }
  /**
     Only the Hiearchy class can set the hiearchy of a
     category. Default package access is mandatory here.  */
  final
  void setHierarchy(Hierarchy hierarchy) {
    this.myContext = hierarchy;
  }
  /**
     Set the priority of this Category.
     <p>Null values are admitted.
  */
  public
  void setPriority(Priority priority) {
    this.priority = priority;
  }
  /**
     Set the resource bundle to be used with localized logging
     methods {@link #l7dlog(Priority,String,Throwable)} and {@link
     #l7dlog(Priority,String,Object[],Throwable)}.
     @since 0.8.4
   */
  public
  void setResourceBundle(ResourceBundle bundle) {
    resourceBundle = bundle;
  }
  /**
     Calling this method will <em>safely</em> close and remove all
     appenders in all the categories including root contained in the
     default hierachy.
     <p>Some appenders such as {@link org.apache.log4j.net.SocketAppender}
     and {@link AsyncAppender} need to be closed before the
     application exists. Otherwise, pending logging events might be
     lost.
     <p>The <code>shutdown</code> method is careful to close nested
     appenders before closing regular appenders. This is allows
     configurations where a regular appender is attached to a category
     and again to a nested appender.  
     @since 1.0
  */
  public
  static
  void shutdown() {
    defaultHierarchy.shutdown();
  }
  /** 
    Log a message object with the {@link Priority#WARN WARN} priority.
    <p>This method first checks if this category is <code>WARN</code>
    enabled by comparing the priority of this category with {@link
    Priority#WARN WARN} priority. If the category is <code>WARN</code>
    enabled, then it converts the message object passed as parameter
    to a string by invoking the appropriate {@link ObjectRenderer}. It
    proceeds to call all the registered appenders in this category and
    also higher in the hieararchy depending on the value of the
    additivity flag.
    <p><b>WARNING</b> Note that passing a {@link Throwable} to this
    method will print the name of the Throwable but no stack trace. To
    print a stack trace use the {@link #warn(Object, Throwable)} form
    instead.  <p>
    @param message the message object to log.  */
  public
  void warn(Object message) {
    if(this.isEnabledFor(Priority.WARN))
      forcedLog(instanceFQN, Priority.WARN, message, null);
  }
  /** 
   Log a message with the <code>WARN</code> priority including the
   stack trace of the {@link Throwable} <code>t</code> passed as
   parameter.
   <p>See {@link #warn(Object)} for more detailed information.
   @param message the message object to log.
   @param t the exception to log, including its stack trace.  */
  public
  void warn(Object message, Throwable t) {
    if(this.isEnabledFor(Priority.WARN))
      forcedLog(instanceFQN, Priority.WARN, message, t);
  }
}
"
org.apache.log4j.CategoryKey,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
/**
   CategoryKey is heavily used internally to accelerate hash table searches.
   @author Ceki G&uuml;lc&uuml; 
*/
class CategoryKey {
  String   name;  
  int hashCache;
  CategoryKey(String name) {
    this.name = name.intern();
    hashCache = name.hashCode();
  }
  final
  public  
  int hashCode() {
    return hashCache;
  }
  final
  public
  boolean equals(Object rArg) {
    if(this == rArg)
      return true;
    if(rArg != null && CategoryKey.class == rArg.getClass()) 
      return  name == ((CategoryKey)rArg ).name;
    else 
      return false;
  }
}
"
org.apache.log4j.DefaultCategoryFactory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.CategoryFactory;
class DefaultCategoryFactory implements CategoryFactory {
  DefaultCategoryFactory() {
  }    
  public
  Category makeNewCategoryInstance(String name) {
    return new Category(name);
  }    
}
"
org.apache.log4j.FileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.TracerPrintWriter;
// Contibutors: Jens Uwe Pipka <jens.pipka@gmx.de>
/**
   FileAppender appends log events to the console, to a file, to a
   {@link java.io.Writer} or an {@link java.io.OutputStream} depending
   on the user's choice.
   @author Ceki G&uuml;lc&uuml;
   */
public class FileAppender extends AppenderSkeleton {
  /**
     A string constant used in naming the option for setting the
     output file. Current value of this string constant is
     <b>File</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String FILE_OPTION = ""File"";
  /**
     A string constant used in naming the option for immediate
     flushing of the output stream at the end of each append
     operation. Current value of this string constant is
     <b>ImmediateFlush</b>.
     <p>Note that all option keys are case sensitive.
     @since 0.9.1
  */
  public static final String IMMEDIATE_FLUSH_OPTION = ""ImmediateFlush"";
  /**
     A string constant used in naming the option that determines whether 
     the output file will be truncated or appended to. Current value
     of this string constant is <b>Append</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String APPEND_OPTION = ""Append"";
  /** Append to or truncate the file? The default value for this
      variable is <code>true</code>, meaning that by default a
      <code>FileAppender</code> will append to an existing file and
      not truncate it.
      <p>This option is meaningful only if the FileAppender opens the
      file.      
  */
  protected boolean fileAppend = true;
  /**
     Immediate flush means that the undelying writer or stream will be
     flushed at the end of each append operation. Immediate flush is
     slower but ensures that each append request is actually
     written. If <code>immediateFlush</code> is set to
     <code>false</code>, then there is a good chance that the last few
     logs events are not actually written to persistent media when the
     application crashes.
     <p>The <code>immediateFlush</code> variable is set to
     <code>true</code> by default.
     @since 0.9.1 */
  protected boolean immediateFlush = true;
  /**
     This is the {@link QuietWriter quietWriter} where we will write
     to. 
  */
  protected QuietWriter qw;
  /**
     {@link TracerPrintWriter} is specialized in optimized printing
     of stack traces (obtained from throwables) to a Writer. 
  */
  protected TracerPrintWriter tp;
  /**
     The name of the log file. */
  protected String fileName = null;
  /**
     Is the QuietWriter ours or was it created and passed by the user?
  */
  protected boolean qwIsOurs = false;
  /**
     The default constructor does no longer set a default layout nor a
     default output target.  */
  public
  FileAppender() {
  }
  /**
     Instantiate a FileAppender and set the output destination to a
     new {@link OutputStreamWriter} initialized with <code>os</code>
     as its {@link OutputStream}.  */
  public
  FileAppender(Layout layout, OutputStream os) {
    this(layout, new OutputStreamWriter(os));
  }
  /**
     Instantiate a FileAppender and set the output destination to
     <code>writer</code>.
     <p>The <code>writer</code> must have been opened by the user.  */
  public
  FileAppender(Layout layout, Writer writer) {
    this.layout = layout;
    this.setWriter(writer);
  }                    
  /**
    Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the ouput
    destination for this appender.
    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file desginated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  FileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    this.layout = layout;
    this.setFile(filename, append);
  }
  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.
    <p>The file will be appended to.  */
  public
  FileAppender(Layout layout, String filename) throws IOException {
    this(layout, filename, true);
  }
  /**
     If the a value for {@link #FILE_OPTION} is non-null, then {@link
     #setFile} is called with the values of {@link #FILE_OPTION} and
     {@link #APPEND_OPTION}.
     @since 0.8.1 */
  public
  void activateOptions() {    
    if(fileName != null) {
      try {
	setFile(fileName, fileAppend);
      }
      catch(java.io.IOException e) {
	errorHandler.error(""setFile(""+fileName+"",""+fileAppend+"") call failed."",
			   e, ErrorCode.FILE_OPEN_FAILURE);
      }
    }
  }
  /**
     This method called by {@link AppenderSkeleton#doAppend}
     method. 
     <p>If the output stream exists an is writable then write a log
     statement to the output stream. Otherwise, write a single warning
     message to <code>System.err</code>.
     <p>The format of the output will depend on this appender's
     layout.
  */
  public
  void append(LoggingEvent event) {
    // Reminder: the nesting of calls is:
    //
    //    doAppend()
    //      - check threshold
    //      - filter
    //      - append();
    //        - checkEntryConditions();
    //        - subAppend();
    if(!checkEntryConditions()) {
      return;
    }
    subAppend(event);
   } 
  /**
     This method determines if there is a sense in attempting to append.
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.qw == null) {
      errorHandler.error(""No output target set for appender named \""""+ 
			name+""\""."");
      return false;
    }
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named \""""+ name+""\""."");
      return false;
    }
    return true;
  }
  /**
     Will close the stream opened by a previos {@link #setFile}
     call. If the writer is owned by the user it remains untouched.
     @see #setFile
     @see #setWriter
     @since 0.8.4
  */
  public
  void close() {
    this.closed = true;
    reset();
  }
  /**
     Close this.writer if opened by setFile or FileAppend(filename..)
  */
  protected
  void closeWriterIfOurs() {
    if(this.qwIsOurs && this.qw != null) {
      try {
	this.qw.close();
      }
      catch(java.io.IOException e) {
	LogLog.error(""Could not close output stream "" + qw, e);
      }
    }      
  }
  /**
     Retuns the option names for this component, namely the string
     array {{@link #FILE_OPTION}, {@link #APPEND_OPTION}} in addition
     to the options of its super class {@link AppenderSkeleton}.  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {FILE_OPTION, APPEND_OPTION, IMMEDIATE_FLUSH_OPTION});
  }
  /**
     Set the {@link ErrorHandler} for this FileAppender and also the
     undelying {@link QuietWriter} if any. */
  public
  synchronized 
  void setErrorHandler(ErrorHandler eh) {
    this.errorHandler = eh;
    if(this.qwIsOurs && this.qw != null) {
      this.qw.setErrorHandler(eh);
    }    
  }
  /**
    <p>Sets and <i>opens</i> the file where the log output will
    go. The specified file must be writable. 
    <p>If there was already an opened stream opened through this
    method, then the previous stream is closed first. If the stream
    was opened by the user and passed to {@link #setWriter
    setWriter}, then the previous stream remains
    untouched. It is the users responsability to close it.
    @param fileName The path to the log file.
    @param boolean If true will append to fileName. Otherwise will
    truncate fileName.  */
  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    reset();
    this.setQWForFiles(new FileWriter(fileName, append));
    this.tp = new TracerPrintWriter(qw);
    this.fileName = fileName;
    this.qwIsOurs = true;
  }
  /**
    <p>Sets and <i>opens</i> the file where the log output will
    go. The specified file must be writable.
    <p>The open mode (append/truncate) will depend on the value of
    FileAppend option. If undefined, append mode is used.
    @param fileName The name of the log file.
  */
  public
  void setFile(String fileName) throws IOException {    
    this.setFile(fileName, fileAppend);
  }
  /**
     Set FileAppender specific options.
     The recognized options are <b>File</b> and <b>Append</b>,
     i.e. the values of the string constants {@link #FILE_OPTION} and
     respectively {@link #APPEND_OPTION}. The options of the super
     class {@link AppenderSkeleton} are also recognized.
     <p>The <b>File</b> option takes a string value which should be
     one of the strings ""System.out"" or ""System.err"" or the name of a
     file.
     <p>If the option is set to ""System.out"" or ""System.err"" the
     output will go to the corresponding stream. Otherwise, if the
     option is set to the name of a file, then the file will be opened
     and output will go there.
     <p>The <b>Append</b> option takes a boolean value. It is set to
     <code>true</code> by default. If true, then <code>File</code>
     will be opened in append mode by {@link #setFile setFile} (see
     above). Otherwise, {@link #setFile setFile} will open
     <code>File</code> in truncate mode.
     <p>Note: Actual opening of the file is made when {@link
     #activateOptions} is called, not when the options are set.
     @since 0.8.1 */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    if(key.equalsIgnoreCase(FILE_OPTION)) {
      // Trim spaces from both ends. The users probably does not want 
      // trailing spaces in file names.
      value = value.trim();
      if(value.equalsIgnoreCase(""System.out""))
	setWriter(new OutputStreamWriter(System.out));
      else if(value.equalsIgnoreCase(""System.err""))
	setWriter(new OutputStreamWriter(System.err));
      else {
	fileName = value;
      } 
    }
    else if (key.equalsIgnoreCase(APPEND_OPTION)) {
      fileAppend = OptionConverter.toBoolean(value, fileAppend);
    }
    else if (key.equalsIgnoreCase(IMMEDIATE_FLUSH_OPTION)) {
      immediateFlush = OptionConverter.toBoolean(value, immediateFlush);
    }
  }
  /**
    <p>Sets the Writer where the log output will go. The
    specified Writer must be opened by the user and be
    writable.
    <p>If there was already an opened stream opened through the {@link
    #setFile setFile} method, then the previous stream is closed
    first. If the stream was opened by the user and passed to this
    method, then the previous stream remains untouched. It is the
    user's responsability to close it.
    <p><b>WARNING:</b> Logging to an unopened Writer will fail.
    <p>  
    @param Writer An already opened Writer.
    @return Writer The previously attached Writer.
  */
  public
  synchronized
  void setWriter(Writer writer) {
    reset();
    this.qw = new QuietWriter(writer, errorHandler);
    this.tp = new TracerPrintWriter(qw);
    this.qwIsOurs = false;    
  }
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new QuietWriter(writer, errorHandler);
  }
  /**
     Actual writing occurs here.
     <p>Most sub-classes of <code>FileAppender</code> will need to
     override this method.
     @since 0.9.0 */
  protected
  void subAppend(LoggingEvent event) {
    this.qw.write(this.layout.format(event));
    if(layout.ignoresThrowable()) {
      if(event.throwable != null) {
	event.throwable.printStackTrace(this.tp);
      }
      // in case we received this event from a remote client    
      else if (event.throwableInformation != null) { 
	this.qw.write(event.throwableInformation);
      }
    }
    if(this.immediateFlush) {
      this.qw.flush();
    } 
  }
  /**
     The FileAppender requires a layout. Hence, this method returns
     <code>true</code>.
     @since 0.8.4 */
  public
  boolean requiresLayout() {
    return true;
  }
  protected
  void reset() {
     closeWriterIfOurs();
     this.fileName = null;
     this.qw = null;
     this.tp = null;    
  }
}
"
org.apache.log4j.Hierarchy,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// WARNING This class MUST not have a static initiliazer that
// WARNING references the Category or RootCategory classes neither 
// WARNING directly nor indirectly.
// Contributors:
//                Luke Blanshard <luke@quiq.com>
//                Mario Schomburg - IBM Global Services/Germany
package org.apache.log4j;
import java.util.Hashtable;
import java.util.Enumeration;
import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
/**
   This class is specialized in retreiving categories by name and
   also maintaining the category hierarchy.
   <p><em>The casual user should never have to deal with this class
   firectly.</em> In fact, up until version 0.9.0, this class had
   default package access. 
   <p>The structure of the category hierachy is maintained by the
   {@link #getInstance} method. The hierrachy is such that children
   link to their parent but parents do not have any pointers to their
   children. Moreover, categories can be instantiated in any order, in
   particular decendant before ancestor.
   <p>In case a decendant is created before a particular ancestor,
   then it creates a provision node for the ancestor and adds itself
   to the provision node. Other decendants of the same ancestor add
   themselves to the previously created provision node.
   <p>See the code below for further details.
   @author Ceki G&uuml;lc&uuml; 
*/
public class Hierarchy {
  static 
  private
  CategoryFactory defaultFactory = new DefaultCategoryFactory();
  Hashtable ht;
  Category root;
  RendererMap rendererMap; 
  /**
     Create a new Category hierarchy.
     @param root The root of the new hierarchy.
   */
  public
  Hierarchy(Category root) {
    ht = new Hashtable();
    this.root = root;
    this.root.myContext  = this;      
    rendererMap = new RendererMap();
  }
  /**
     Add an object renderer for a specific class.       
   */
  public
  void addRenderer(Class classToRender, ObjectRenderer or) {
    rendererMap.put(classToRender, or);
  }
  /**
     This call will clear all category definitions from the internal
     hashtable. Invoking this method will irrevocably mess up the
     category hiearchy.
     <p>You should <em>really</em> know what you are doing before
     invoking this method.
     @since 0.9.0 */
  public
  void clear() {
    //System.out.println(""\n\nAbout to clear internal hash table."");
    ht.clear();
  }
  /**
     Check if the named category exists in the hirarchy. If so return
     its reference, otherwise returns <code>null</code>.
     @param name The name of the category to search for.
  */
  public
  Category exists(String name) {    
    Object o = ht.get(new CategoryKey(name));
    if(o instanceof Category) {
      return (Category) o;
    } else {
      return null;
    }
  }
  /**
     Return a new category instance named as the first parameter using
     the default factory. 
     <p>If a category of that name already exists, then it will be
     returned.  Otherwise, a new category will be instantiated and
     lthen inked with its existing ancestors as well as children.
     @param name The name of the category to retreive.
 */
  public
  Category getInstance(String name) {
    return getInstance(name, defaultFactory);
  }
 /**
     Return a new category instance named as the first parameter using
     <code>factory</code>.
     <p>If a category of that name already exists, then it will be
     returned.  Otherwise, a new category will be instantiated by the
     <code>factory</code> parameter and linked with its existing
     ancestors as well as children.
     @param name The name of the category to retreive.
     @param factory The factory that will make the new category instance.
 */
  public
  Category getInstance(String name, CategoryFactory factory) {
    //System.out.println(""getInstance(""+name+"") called."");
    CategoryKey key = new CategoryKey(name);    
    // Synchronize to prevent write conflicts. Read conflicts (in
    // getChainedPriority method) are possible only if variable
    // assignments are non-atomic.
    Category category;
    synchronized(ht) {
      Object o = ht.get(key);
      if(o == null) {
	category = factory.makeNewCategoryInstance(name);
	category.setHierarchy(this);
	ht.put(key, category);      
	updateParents(category);
	return category;
      }
      else if(o instanceof Category) {
	return (Category) o;
      }
      else if (o instanceof ProvisionNode) {
	//System.out.println(""(""+name+"") ht.get(this) returned ProvisionNode"");
	category = factory.makeNewCategoryInstance(name);
	ht.put(key, category);
	updateChildren((ProvisionNode) o, category);
	updateParents(category);	
	return category;
      }
      else {
	// It should be impossible to arrive here
	return null;  // but let's keep the compiler happy.
      }
    }
  }
  /**
     Get the renderer map for this hierarchy.
  */
  public
  RendererMap getRendererMap() {
    return rendererMap;
  }
  /**
     Get the root of this hierarchy.
     @since 0.9.0
   */
  public
  Category getRoot() {
    return root;
  }
  /**
     This method loops through all the *potential* parents of
     'cat'. There 3 possible cases:
     1) No entry for the potential parent of 'cat' exists
        We create a ProvisionNode for this potential parent and insert
        'cat' in that provision node.
     2) There entry is of type Category for the potential parent.
        The entry is 'cat's nearest existing parent. We update cat's
        parent field with this entry. We also break from the loop
        because updating our parent's parent is our parent's
        responsibility.
     3) There entry is of type ProvisionNode for this potential parent.
        We add 'cat' to the list of children for this potential parent.
   */
  final
  private
  void updateParents(Category cat) {
    String name = cat.name;
    int length = name.length();
    boolean parentFound = false;
    //System.out.println(""UpdateParents called for "" + name);
    // if name = ""x.y.z"", loop thourgh ""x.y"" and ""x"", but not ""x.y.z""    
    for(int i = name.lastIndexOf('.', length-1); i >= 0; 
	                                 i = name.lastIndexOf('.', i-1))  {
      String substr = name.substring(0, i);
      //System.out.println(""Updating parent : "" + substr);
      CategoryKey key = new CategoryKey(substr); // simple constructor
      Object o = ht.get(key);
      // Create a provision node for a future parent.
      if(o == null) {
	//System.out.println(""No parent ""+substr+"" found. Creating ProvisionNode."");
	ProvisionNode pn = new ProvisionNode(cat);
	ht.put(key, pn);
      }
      else if(o instanceof Category) {
	parentFound = true;
	cat.parent = (Category) o;
	//System.out.println(""Linking "" + cat.name + "" -> "" + ((Category) o).name);
	break;	
      }
      else if(o instanceof ProvisionNode) {
	((ProvisionNode) o).addElement(cat);
      }
      else {
	Exception e = new IllegalStateException(""unexpected object type "" + 
					o.getClass() + "" in ht."");
	e.printStackTrace();			   
      }
    }
    // If we could not find any existing parents, then link with root.
    if(!parentFound) 
      cat.parent = root;
  }
  /** 
      We update the links for all the children that placed themselves
      in the provision node 'pn'. The second argument 'cat' is a
      reference for the newly created Category, parent of all the
      children in 'pn'
      We loop on all the children 'c' in 'pn':
         If the child 'c' has been already linked to a child of
         'cat' then there is no need to update 'c'.
	 Otherwise, we loop until we find the nearest parent of 'c'
	 (not excluding 'c') below 'cat' and nearest to 'cat'.
	 Say 'x' is this category. We set cat's parent field to x's
	 parent and set x's parent field to cat.
  */
  final
  private
  void updateChildren(ProvisionNode pn, Category cat) {
    //System.out.println(""updateChildren called for "" + cat.name);
    final int last = pn.size();
    childLoop:
    for(int i = 0; i < last; i++) {
      Category c = (Category) pn.elementAt(i);
      //System.out.println(""Updating child "" +p.name);
      // Skip this child if it already points to a correct (lower) parent.
      // In pre-0.8.4c versions we skipped this test. As a result, under certain
      // rare circumstances the while loop below would never exit.
      // Thanks to Mario Schomburg from IBM Global Services/Hannover for
      // identifying this problem.
      if(c.parent != null && c.parent.name.startsWith(cat.name)) {
	continue childLoop;
      }
      // Loop until c points to an *existing* category just below 'cat' in the
      // hierarchy.
      while(c.parent != null && c.parent.name.startsWith(cat.name)) {
	c = c.parent;
      }
      //System.out.println(""1-Linking "" + cat.name + "" -> "" +
      //      (p.parent != null ? p.parent.name : ""null""));
      cat.parent = c.parent;
      //System.out.println(""2-Linking "" + p.name + "" -> "" +
      //      cat.name);
      c.parent = cat;      
    }
  }    
  /**
     Shutting down a hiearchy will <em>safely</em> close and remove
     all appenders in all the categories including root.
     <p>Some appenders such as {@link org.apache.log4j.net.SocketAppender}
     and {@link AsyncAppender} need to be closed before the
     application exists. Otherwise, pending logging events might be
     lost.
     <p>The <code>shutdown</code> method is careful to close nested
     appenders before closing regular appenders. This is allows
     configurations where a regular appender is attached to a category
     and again to a nested appender.
     @since 1.0 */
  public 
  void shutdown() {
    Category root = getRoot();    
    // begin by closing nested appenders
    root.closeNestedAppenders();
    synchronized(ht) {
      Enumeration cats = Category.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.closeNestedAppenders();
      }
      // then, remove all appenders
      root.removeAllAppenders();
      cats = Category.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.removeAllAppenders();
      }      
    }
  }
}
"
org.apache.log4j.HTMLLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.io.Writer;
public class HTMLLayout extends Layout {
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  
     <p>Note that all option keys are case sensitive.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  // Print no location info by default
  boolean locationInfo = false;
  public
  void activateOptions() {
  }
  public 
  String format(LoggingEvent event) {
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    sbuf.append(""\r\n\r\n<tr>"");
    sbuf.append(""<td>"");
    sbuf.append(event.timeStamp - event.getStartTime());
    sbuf.append(""</td>\r\n"");
    sbuf.append(""<td>"");
    sbuf.append(event.getThreadName());
    sbuf.append(""</td>\r\n"");
    sbuf.append(""<td>"");
    if(event.priority.isGreaterOrEqual(Priority.WARN)) {
      sbuf.append(""<font color=\""#FF0000\"">"");
      sbuf.append(event.priority);      
      sbuf.append(""</font>"");
    } else {
      sbuf.append(event.priority);      
    }
    sbuf.append(""</td>\r\n"");
    sbuf.append(""<td>"");
    sbuf.append(event.categoryName);
    sbuf.append(""</td>\r\n"");
    sbuf.append(""<td>"");
    sbuf.append(event.getNDC());
    sbuf.append(""</td>\r\n"");
    if(locationInfo) {
      event.setLocationInformation();
      sbuf.append(""<td>"");
      sbuf.append(event.locationInfo.getFileName());
      sbuf.append(':');
      sbuf.append(event.locationInfo.getLineNumber());
      sbuf.append(""</td>\r\n"");
    }
    sbuf.append(""<td>"");
    sbuf.append(event.message);
    sbuf.append(""</td>\r\n"");
    sbuf.append(""</tr>"");
    if(event.throwable != null) {
      sbuf.append(""\r\n<tr><td colspan=\""7\"">"");
      sbuf.append(getThrowableAsHTML(event.throwable));
      sbuf.append(""</td></tr>"");
    }
    return sbuf.toString();
  }
 /**
     Returns the content type output by this layout, i.e ""text/html"".
  */
  public
  String getContentType() {
    return ""text/html"";
  }
  /**
     Returns appropriate HTML headers.
  */
  public
  String getHeader() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""<html><body>\r\n"");
    sbuf.append(""<table border=\""1\"" cellpadding=\""2\"">\r\n<tr>\r\n"");
    sbuf.append(""<th>Time</th><th>Thread</th><th>Priority</th><th>Category</th>"");
    sbuf.append(""<th>NDC</th>"");
    if(locationInfo) {
      sbuf.append(""<th>File:Line</th>"");
    }
    sbuf.append(""<th>Message</th></tr>"");
    return sbuf.toString();
  }
  /**
     Returns the appropriate HTML footers.
  */
  public
  String getFooter() {
    return ""</table></body></html>"";
  }
  public
  String[] getOptionStrings() {
    return new String[] {LOCATION_INFO_OPTION};
  }
  String getThrowableAsHTML(Throwable throwable) {
    if(throwable == null) 
      return null;
    StringWriter sw = new StringWriter();
    HTMLPrintWriter hpw = new HTMLPrintWriter(sw);
    throwable.printStackTrace(hpw);
    return sw.toString();
  }
  public
  boolean ignoresThrowable() {
    return false;
  }
  /**
     Set HTMLLayout specific options.
     <p>The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layoout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output. 
     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
   */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    if (key.equals(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
    }
  }
  /**
     Format exceptions in HTML aware way.
   */
  static class HTMLPrintWriter extends PrintWriter {
    static String TRACE_PREFIX = ""<br>&nbsp;&nbsp;&nbsp;&nbsp;"";
    public
    HTMLPrintWriter(Writer writer) {
      super(writer);
    }
    /**
       Some JDKs use prinln(char[])
     */
    public
    void println(char[] c) {
      write(TRACE_PREFIX);
      this.write(c);
    }
    /**
       Yet others use println(String). Go figure.
    */    
    public
    void println(String s) {
      write(TRACE_PREFIX);
      this.write(s);
    }    
  }
}
"
org.apache.log4j.Layout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
/**
   Extend this abstract class to create your own log layout format.
   @author Ceki G&uuml;lc&uuml;
*/
public abstract class Layout implements OptionHandler {
  // Note that the line.separator property can be looked up even by
  // applets.
  public final static String LINE_SEP = System.getProperty(""line.separator"");
  public final static int LINE_SEP_LEN  = LINE_SEP.length();
  /**
     Implement this method to create your own layout format.
  */
  abstract
  public
  String format(LoggingEvent event);
  /**
     Returns the content type output by this layout. The base class
     returns ""text/plain"". 
  */
  public
  String getContentType() {
    return ""text/plain"";
  }
  /**
     Returns the header for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getHeader() {
    return null;
  }
  /**
     Returns the footer for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getFooter() {
    return null;
  }
  /**
     If the layout handles the throwable object contained within
     {@link LoggingEvent}, then the layout should return
     <code>false</code>. Otherwise, if the layout ignores throwable
     object, then the layout should return <code>true</code>.
     <p>The {@link SimpleLayout}, {@link TTCCLayout}, {@link
     PatternLayout} all return <code>true</code>. The {@link
     org.apache.log4j.xml.XMLLayout} returns <code>false</code>.
     @since version 0.8.4 */
  abstract
  public
  boolean ignoresThrowable();
}
"
org.apache.log4j.NDC,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
//
//      See the LICENCE file for the terms of usage and distribution.
package org.apache.log4j;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Enumeration;
import java.util.Vector;
import org.apache.log4j.helpers.LogLog;
/**
   The NDC class implements <i>nested diagnostic contexts</i> as
   defined by Neil Harrison in the article ""Patterns for Logging
   Diagnostic Messages"" part of the book ""<i>Pattern Languages of
   Program Design 3</i>"" edited by Martin et al.
   <p>A Nested Diagnostic Context, or NDC in short, is an instrument
   to distinguish interleaved log output from different sources. Log
   output is typically interleaved when a server handles multiple
   clients near-simulatanously.
   <p>Interleaved log output can still be meaningful if each log entry
   from different contexts had a distinctive stamp. This is where NDCs
   come into play.
   <p><em><b>Note that NDCs are managed on a per thread
   basis</b></em>. NDC operations such as {@link #push push}, {@link
   #pop}, {@link #clear}, {@link #getDepth} and {@link #setMaxDepth}
   affect the NDC of the <em>current</em> thread only. NDCs of other
   threads remain unaffected.
   <p>For example, a servlet can build a per client request NDC
   consisting the clients host name and other information contained in
   the the request. <em>Cookies</em> are another source of distinctive
   information. To build an NDC one uses the {@link #push push}
   operation. Simply put,
   <p><ul>
     <li>Contexts can be nested.
     <p><li>When entering a context, call <code>NDC.push</code>. As a
     side effect, if there is no nested diagnostic context for the
     current thread, this method will create it.
     <p><li>When leaving a context, call <code>NDC.pop</code>.
   </ul>
   <p>There is no penalty for forgetting to match each
   <code>push</code> operation with a corresponding <code>pop</code>,
   except the obvious mismatch between the real application context
   and the context set in the NDC.
   <p>If configured to do so, {@link PatternLayout} and {@link
   TTCCLayout} instances automatically retrieve the nested diagnostic
   context for the current thread without any user intervention.
   Hence, even if a servlet is serving multiple clients
   simultaneously, the logs emanating from the same code (belonging to
   the same category) can still be distinguished because each client
   request will have a different NDC tag.
   <p>Heavy duty systems should call the {@link #remove} method when
   leaving the run method of a thread. This ensures that the memory
   used by the thread can be freed by the Java garbage collector. In
   version 0.8.5, we have added a meachanism to lazily remove
   references to dead threads. In practice, this means that you can be
   a little sloppy and sometimes forget to call {@link #remove} before
   exiting a thread.
   <p>A thread may inherit the nested diagnostic context of another
   (possibly parent) thread using the {@link #inherit inherit}
   method. A thread may obtain a copy of its NDC with the {@link
   #cloneStack cloneStack} method and pass the reference to any other
   thread, in particular to a child.
   @author Ceki G&uuml;lc&uuml;
   @since log4j v0.7.0
*/
public class NDC {
  // The synchronized keyword is not used in this class. This may seem
  // dangerous, especially since the class will be used by
  // multiple-threads. In particular, all threads share the same
  // hashtable (the ""ht"" variable). This is OK since java hashtables
  // are thread safe. Same goes for Stacks.
  // More importantly, when inheriting diagnostic contexts the child
  // thread is handed a clone of the parent's NDC.  It follows that
  // each thread has its own NDC (i.e. stack).
  static Hashtable ht = new Hashtable();
  static int pushCounter = 0; // the number of times push has been called
                              // after the latest call to lazyRemove
  // The number of times we allow push to be called before we call lazyRemove
  // 5 is a relatively small number. As such, lazyRemove is not called too
  // frequently. We thus avoid the cost of creating an Enumeration too often.
  // The higher this number, the longer is the avarage period for which all
  // logging calls in all threads are blocked.
  static final int REAP_THRESHOLD = 5;
  // No instances allowed.
  private NDC() {}
  /**
     Clear any nested disgnostic information if any. This method is
     useful in cases where the same thread can be potentially used
     over and over in different unrelated contexts.
     <p>This method is equivalent to calling the {@link #setMaxDepth}
     method with a zero <code>maxDepth</code> argument.
     @since 0.8.4c */
  public
  static
  void clear() {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null) 
      stack.setSize(0);    
  }
  /**
     Clone the diagnostic context for the current thread.
     <p>Internally a diagnostic context is represented as a stack.  A
     given thread can supply the stack (i.e. diagnostic context) to a
     child thread so that the child can inherit the parent thread's
     diagnostic context.
     <p>The child thread uses the {@link #inherit inherit} method to
     inherit the parent's diagnostic context.
     @return Stack A clone of the current thread's  diagnostic context.
  */
  public
  static
  Stack cloneStack() {
    Object o = ht.get(Thread.currentThread());
    if(o == null)
      return null;
    else {
      Stack stack = (Stack) o;
      return (Stack) stack.clone();
    }
  }
  /**
     Inherit the diagnostic context of another thread.
     <p>The parent thread can obtain a reference to its diagnostic
     context using the {@link #cloneStack} method.  It should
     communicate this information to its child so that it may inherit
     the parent's diagnostic context.
     <p>The parent's diagnostic context is cloned before being
     inherited. In other words, once inherited, the two diagnostic
     contexts can be managed independently.
     <p>In java, a child thread cannot obtain a reference to its
     parent, unless it is directly handed the reference. Consequently,
     there is no client-transparent way of inheriting diagnostic
     contexts. Do you know any solution to this problem?
     @param stack The diagnostic context of the parent thread.
  */
  public
  static
  void inherit(Stack stack) {
    if(stack != null)
      ht.put(Thread.currentThread(), stack);
  }
  /**
     Used when printing the diagnostic context.
  */
  static
  public
  String get() {
    Stack s = (Stack) ht.get(Thread.currentThread());
    if(s != null && !s.isEmpty()) 
      return ((DiagnosticContext) s.peek()).fullMessage;
    else
      return null;
  }
  /**
     Get the current nesting depth of this diagnostic context.
     @see #setMaxDepth
     @since 0.7.5
   */
  public
  static
  int getDepth() {
    Stack stack = (Stack) ht.get(Thread.currentThread());          
    if(stack == null)
      return 0;
    else
      return stack.size();      
  }
  private
  static
  void lazyRemove() {
    // The synchronization on ht is necessary to prevent JDK 1.2.x from
    // throwing ConcurrentModificationExceptions at us. This sucks BIG-TIME.
    // One solution is to write our own hashtable implementation.
    Vector v;
    synchronized(ht) {
      // Avoid calling clean-up too often.
      if(++pushCounter >= REAP_THRESHOLD) {
	return; // We release the lock ASAP.
      } else {
	pushCounter = 0; // OK let's do some work.
      }
      int misses = 0;
      v = new Vector(); 
      Enumeration enum = ht.keys();
      // We give up after 4 straigt missses. That is 4 consecutive
      // inspected threads in 'ht' that turn out to be alive.
      // The higher the proportion on dead threads in ht, the higher the
      // chances of removal.
      while(enum.hasMoreElements() && (misses <= 4)) {
	Thread t = (Thread) enum.nextElement();
	if(t.isAlive()) {
	  misses++;
	} else {
	  misses = 0;
	  v.addElement(t);
	}
      }
    } // synchronized
    int size = v.size();
    for(int i = 0; i < size; i++) {
      Thread t = (Thread) v.elementAt(i);
      LogLog.debug(""Lazy NDC removal for thread ["" + t.getName() + ""] (""+ 
		   ht.size() + "")."");
      ht.remove(t);
    }
  }
  /**
     Clients should call this method before leaving a diagnostic
     context.
     <p>The returned value is the value that was pushed last. If no
     context is available, then the empty string """" is returned.
     @return String The innermost diagnostic context.
     */
  public
  static
  String pop() {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack != null && !stack.isEmpty()) 
      return ((DiagnosticContext) stack.pop()).message;
    else
      return """";
  }
  /**
     Push new diagnostic context information for the current thread.
     <p>The contents of the <code>message</code> parameter is
     determined solely by the client.  
     @param message The new diagnostic context information.  */
  public
  static
  void push(String message) {
    Thread key = Thread.currentThread();
    Stack stack = (Stack) ht.get(key);
    if(stack == null) {
      DiagnosticContext dc = new DiagnosticContext(message, null);      
      stack = new Stack();
      ht.put(key, stack);
      stack.push(dc);
    } else if (stack.isEmpty()) {
      DiagnosticContext dc = new DiagnosticContext(message, null);            
      stack.push(dc);
    } else {
      DiagnosticContext parent = (DiagnosticContext) stack.peek();
      stack.push(new DiagnosticContext(message, parent));
    }    
  }
  /**
     Remove the diagnostic context for this thread.
     <p>Each thread that created a diagnostic context by calling
     {@link #pop} should call this method before exiting. Otherwise,
     the memory used by the diagnostic context for the <b>thread</b>
     cannot be reclaimed by the VM.
     <p>As this is such an important problem in heavy duty systems and
     because it is difficult to always guarantee that the remove
     mehtod is called before exiting a thread, this method has been
     augmented to lazily remove references to dead threads. In
     practice, this means that you can be a little sloppy and
     occasionally forget to call {@link #remove} before exiting a
     thread.
  */
  static
  public
  void remove() {
    ht.remove(Thread.currentThread());
    // Lazily remove dead-thread references in ht.
    lazyRemove();    
  }
  /**
     Set maximum depth of this diagnostic context. If the current
     depth is smaller or equal to <code>maxDepth</code>, then no
     action is taken.
     <p>This method is a convenient alternative to multiple {@link
     #pop} calls. Moreover, it is often the case that at the end of
     complex call sequences, the depth of the NDC is
     unpredictable. The <code>setMaxDepth</code> method circumvents
     this problem.
     <p>For example, the combination
     <pre>
       void foo() {
       &nbsp;  int depth = NDC.getDepth();
       &nbsp;  ... complex sequence of calls
       &nbsp;  NDC.setMaxDepth(depth);
       }
     </pre>
     ensures that between the entry and exit of foo the depth of the
     diagnostic stack is conserved.
     @see #getDepth
     @since 0.7.5 */
  static
  public
  void setMaxDepth(int maxDepth) {
    Stack stack = (Stack) ht.get(Thread.currentThread());    
    if(stack != null && maxDepth < stack.size()) 
      stack.setSize(maxDepth);
  }
  // =====================================================================
   private static class DiagnosticContext {
    String fullMessage;
    String message;
    DiagnosticContext(String message, DiagnosticContext parent) {
      this.message = message;
      if(parent != null) {
	fullMessage = parent.fullMessage + ' ' + message;
      } else {
	fullMessage = message;
      }
    }
  }
}
"
org.apache.log4j.PatternLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */
package org.apache.log4j;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.NDC;
import org.apache.log4j.helpers.PatternParser;
import org.apache.log4j.helpers.PatternConverter;
import org.apache.log4j.helpers.OptionConverter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.util.Vector;
import java.text.FieldPosition;
// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Anders Kristensen <akristensen@dynamicsoft.com>
/**
   A flexible layout configurable with pattern string.
   <p>The goal of this class is to {@link #format format} a {@link
   LoggingEvent} and return the results as a String. The results
   depend on the <em>conversion pattern</em>.
   <p>The conversion pattern is closely related to the conversion
   pattern of the printf function in C. A conversion pattern is
   composed of literal text and format control expressions called
   <em>conversion specifiers</em>.
   <p><i>You are free to insert any literal text within the conversion
   pattern.</i>
   <p>Each conversion specifier starts with a percent sign (%) and is
   followed by optional <em>format modifiers</em> and a <em>conversion
   character</em>. The conversion character specifies the type of
   data, e.g. category, priority, date, thread name. The format
   modifiers control such things as field width, padding, left and
   right justification. The following is a simple example.
   <p>Let the conversion pattern be <b>""%-5p [%t]: %m%n""</b> and assume
   that the log4j environment was set to use a PatternLayout. Then the
   statements
   <pre>
   Category root = Category.getRoot();
   root.debug(""Message 1"");
   root.warn(""Message 2."");   
   </pre>
   would yield the output
   <pre>
   DEBUG [main]: Message 1
   WARN  [main]: Message 2  
   </pre>
   <p>Note that there is no explicit separator between text and
   conversion specifiers. The pattern parser knows when it has reached
   the end of a conversion specifier when it reads a conversion
   character. In the example above the conversion specifier
   <b>%-5p</b> means the priority of the logging event should be left
   justfied to a with of five characters. 
   The recognized conversion characters are
   <p>
   <table border=1 CELLPADDING=8>
   <th>Conversion Character</th>
   <th>Effect</th>
   <tr>
     <td align=center><b>c</b></td>
     <td>Used to output the category of the logging event. The
     category conversion specifier can be optionally followed by
     <em>precision specifier</em>, that is a decimal constant in
     brackets.
     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the category name will be
     printed. By default the category name is printed in full.
     <p>For example, for the category name ""a.b.c"" the pattern
     <b>%c{2}</b> will output ""b.c"".
     </td>
   </tr>
   <tr>
     <td align=center><b>C</b></td>
     <td>Used to output the fully qualified class name of the caller
     issuing the logging request. This conversion specifier
     can be optionally followed by <em>precision specifier</em>, that
     is a decimal constant in brackets.
     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the class name will be
     printed. By default the class name is output in fullly qualified form.
     <p>For example, for the class name ""org.apache.xyz.SomeClass"", the
     pattern <b>%C{1}</b> will output ""SomeClass"".
     <p><b>WARNING</b> Generating the caller class information is
     slow. Thus, it's use should be avoided unless execution speed is
     not an issue.
     </td>
     </tr>
   <tr> <td align=center><b>d</b></td> <td>Used to output the date of
	 the logging event. The date conversion specifier may be
	 followed by a <em>date format specifier</em> enclosed between
	 braces. For example, <b>%d{HH:mm:ss,SSS}</b> or
	 <b>%d{dd&nbsp;MMM&nbsp;yyyy&nbsp;HH:mm:ss,SSS}</b>.  If no
	 date format specifier is given then ISO8601 format is
	 assumed.
	 <p>The date format specifier admits the same syntax as the
	 time pattern string of the {@link
	 java.text.SimpleDateFormat}. Altough part of the standard
	 JDK, the performance of <code>SimpleDateFormat</code> is
	 quite poor.
	 <p>For better results it is recommended to use the log4j date
	 formatters. These can be specified using one of the strings
	 ""ABSOLUTE"", ""DATE"" and ""ISO8601"" for specifying {@link
	 org.apache.log4j.helpers.AbsoluteTimeDateFormat
	 AbsoluteTimeDateFormat}, {@link
	 org.apache.log4j.helpers.DateTimeDateFormat DateTimeDateFormat}
	 and respectively {@link
	 org.apache.log4j.helpers.ISO8601DateFormat
	 ISO8601DateFormat}. For example, <b>%d{ISO8601}</b> or
	 <b>%d{ABSOLUTE}</b>.
	 <p>These dedicated date formatters perform significantly
	 better than {@link java.text.SimpleDateFormat}.
     </td>
   </tr>
   <tr>
   <td align=center><b>F</b></td>
   <td>Used to output the file name where the logging request was
   issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
   <td align=center><b>l</b></td>
     <td>Used to output location information of the caller which generated
     the logging event. 
     <p>The location information depends on the JVM implementation but
     usually consists of the fully qualified name of the calling
     method followed by the callers source the file name and line
     number between parentheses.
     <p>The location information can be very useful. However, it's
     generation is <em>extremely</em> slow. It's use should be avoided
     unless execution speed is not an issue.
     </td>
   </tr>
   <tr>
   <td align=center><b>L</b></td>
   <td>Used to output the line number from where the logging request
   was issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
     <td align=center><b>m</b></td>
     <td>Used to output the application supplied message associated with 
     the logging event.</td>   
   </tr>
   <tr>
   <td align=center><b>M</b></td>
   <td>Used to output the method name where the logging request was
   issued.
   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.
   </tr>
   <tr>
     <td align=center><b>n</b></td>
     <td>Outputs the platform dependent line separator character or
     characters. 
     <p>This conversion character offers practically the same
     performance as using non-portable line separator strings such as
     ""\n"", or ""\r\n"". Thus, it is the preferred way of specifying a
     line separator.
   </tr>
   <tr>
     <td align=center><b>p</b></td>
     <td>Used to output the priority of the logging event.</td>
   </tr>
   <tr>
     <td align=center><b>r</b></td>
     <td>Used to output the number of milliseconds elapsed since the start
     of the application until the creation of the logging event.</td>
   </tr>  
   <tr>
     <td align=center><b>t</b></td>
     <td>Used to output the name of the thread that generated the
     logging event.</td>
   </tr>
   <tr>
     <td align=center><b>x</b></td>
     <td>Used to output the NDC (nested diagnostic context) associated
     with the thread that generated the logging event.
     </td>     
   </tr>
   <tr>
     <td align=center><b>%</b></td>
     <td>The sequence %% outputs a single percent sign.
     </td>     
   </tr>
   </table>
   <p>By default the relevant infromation is output as is. However,
   with the aid of format modifiers it is possible to change the
   minimum field width, the maximum field width and justification.
   <p>The optional format modifier is placed between the percent sign
   and the conversion character.
   <p>The first optional format modifier is the <em>left justification
   flag</em> which is just the minus (-) character. Then comes the
   optional <em>minimum field width</em> modifier. This is a decimal
   constant that represents the minimum number of characters to
   output. If the data item requires fewer characters, it is padded on
   either the left or the right until the minimum width is
   reached. The default is to pad on the left (right justify) but you
   can specify right padding with the left justification flag. The
   padding character is space. If the data item is larger than the
   minimum field width, the field is expanded to accomodate the
   data. The value is never truncated.
   <p>This behavior can be changed using the <em>maximum field
   width</em> modifier which is desginated by a period followed by a
   decimal constant. If the data item is longer than the maximum
   field, then the extra characters are removed from the
   <em>beginning</em> of the data item and not from the end. For
   example, it the maximum field width is eight and the data item is
   ten characters long, then the first two characters of the data item
   are dropped. This behaviour deviates from the printf function in C
   where truncation is done from the end.
   <p>Below are various format modifier examples for the category
   conversion specifier.
   <p>
   <TABLE BORDER=1 CELLPADDING=8>
   <th>Format modifier
   <th>left justify
   <th>minimim width
   <th>maximum width
   <th>comment
   <tr>
   <td align=center>%20c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>none</td>
   <td>Left pad with spaces if the category name is less than 20
   characters long.
   <tr> <td align=center>%-20c</td> <td align=center>true</td> <td
   align=center>20</td> <td align=center>none</td> <td>Right pad with
   spaces if the category name is less than 20 characters long.
   <tr>
   <td align=center>%.30c</td>
   <td align=center>NA</td>
   <td align=center>none</td>
   <td align=center>30</td>
   <td>Truncate from the beginning if the category name is longer than 30
   characters.
   <tr>
   <td align=center>%20.30c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>30</td>
   <td>Left pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.   
   <tr>
   <td align=center>%-20.30c</td>
   <td align=center>true</td>
   <td align=center>20</td>
   <td align=center>30</td>
   <td>Right pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.   
   </table>
   <p>Below are some examples of conversion patterns.
   <dl>
   <p><dt><b>%r [%t] %-5p %c %x - %m\n</b> 
   <p><dd>This is essentially the TTCC layout.
   <p><dt><b>%-6r [%15.15t] %-5p %30.30c %x - %m\n</b>
   <p><dd>Similar to the TTCC layout except that the rlative time is
   right padded if less than 6 digits, thread name is right padded if
   less than 15 characters and truncated if longer and the category
   name is left padded if shorter than 30 characters and truncated if
   longer.
  </dl>
   <p>The above text is largely inspired from Peter A. Darnell and
   Philip E. Margolis' higly recommended book ""C -- a Software
   Engineering Approach"", ISBN 0-387-97389-3.
   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2 */
public class PatternLayout extends Layout {
   /**
     A string constant used in naming the option for setting the
     layout pattern. Current value of this string constant is
     <b>ConversionPattern</b>.
     <p>Note that the search for all option keys is case sensitive.
  */
  final static public String CONVERSION_PATTERN_OPTION = ""ConversionPattern"";
  /** Default pattern string for log output. Currently set to the
      string <b>""%m\n""</b> which just prints the application supplied
      message. */
  public final static String DEFAULT_CONVERSION_PATTERN =""%m\n"";
  /*
     A string constant used in naming the option for setting the time
     zone for date output. Current value of this string constant is
     <b>TimeZone</b>.
  */
  //final static public String TIMEZONE_OPTION = ""TimeZone"";  
  /** A conversion pattern equivalent to the TTCCCLayout.
      Current value is <b>%r [%t] %p %c %x - %m%n</b>. */  
  public final static String TTCC_CONVERSION_PATTERN
                                             = ""%r [%t] %p %c %x - %m%n"";
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  private PatternConverter head;
  private String timezone;
  /**
     Constructs a PatternLayout using the DEFAULT_LAYOUT_PATTERN.
     The default pattern just produces the application supplied message.
  */
  public PatternLayout() {
    this(DEFAULT_CONVERSION_PATTERN);
  }
  /**
     Constructs a PatternLayout using the supplied conversion pattern.
  */
  public PatternLayout(String pattern) {
    head = createPatternParser((pattern == null) ? DEFAULT_CONVERSION_PATTERN : 
			     pattern).parse();
  }
  /**
     Does not do anything as options become effective immediately. See
     {@link #setOption} method. */
  public
  void activateOptions() {
    // nothing to do.
  }
  /**
    Returns PatternParser used to parse the conversion string. Subclasses
    may override this to return a subclass of PatternParser which recognize
    custom conversion characters.
    @since 0.9.0
  */
  protected PatternParser createPatternParser(String pattern) {
    return new PatternParser(pattern);
  }
  /**
     Produces a formatted string as specified by the conversion pattern.
  */
  public String format(LoggingEvent event) {
    // Reset working stringbuffer
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    PatternConverter c = head;
    while(c != null) {
      c.format(sbuf, event);
      c = c.next;
    }
    return sbuf.toString();
  }
  /**
     Returns the the array of option strings that {@link
     PatternLayout} recognizes. The only recognized option string is
     the value of {@link #CONVERSION_PATTERN_OPTION}.
  */
  public
  String[] getOptionStrings() {
    return new String[] {CONVERSION_PATTERN_OPTION};
  }	
 /**
     The PatternLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
  /**
     Set the conversion pattern.
   */
  public
  void setConversionPattern(String conversionPattern) {
    setOption(CONVERSION_PATTERN_OPTION, conversionPattern);
  }
  /**
     The PatternLayout specific options are:
     <p>
     <dl>
     <dt><b>ConversionPattern</b>
     <p><dd>The value determines the conversion pattern used.
     </dl>
   */
  public
  void setOption(String option, String value) {
    if(value == null)
      return;
    if(option.equalsIgnoreCase(CONVERSION_PATTERN_OPTION)) {
      head = createPatternParser(value).parse();
    }
    //else if(option.equals(TIMEZONE_OPTION)) {
    //try {
    //timezone = OptionConverter.substituteVars(value);
    //}
    //catch(IllegalArgumentException e) {
    //LogLog.error(""Could not substitute variables."" , e);
    //}
    //}
  }
}
"
org.apache.log4j.Priority,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j;
/**
   Defines the minimum set of priorities recognized by the system,
   that is {@link #FATAL}, {@link #ERROR}, {@link #WARN}, {@link
   #INFO} and {@link #DEBUG}.
   <p>The <code>Priority</code> class may be subclassed to define a larger
   priority set.
 */
public class Priority {
  int level;
  String levelStr;
  int syslogEquivalent;
  final static int FATAL_INT = 50000;
  final static int ERROR_INT = 40000;
  final static int WARN_INT  = 30000;
  final static int INFO_INT  = 20000;
  final static int DEBUG_INT = 10000;
  /**
     The <code>FATAL</code> priority designates very severe error
     events that will presumably lead the application to abort.
   */
  final static public Priority FATAL = new Priority(FATAL_INT, ""FATAL"", 0);
  /**
     The <code>ERROR</code> priority designates error events that
     might still allow the application to continue running.  */
  final static public Priority ERROR = new Priority(ERROR_INT, ""ERROR"", 3);
  /**
     The <code>WARN</code> priority designates potentially harmful situations.
  */
  final static public Priority WARN  = new Priority(WARN_INT, ""WARN"",  4);
  /**
     The <code>INFO</code> priority designates informational messages
     that higlight the progress of the application at coarse-grained
     level.  */
  final static public Priority INFO  = new Priority(INFO_INT, ""INFO"",  5);
  /**
     The <code>DEBUG</code> priority designates fine-grained
     informational events that are most useful to debug an
     application.  */
  final static public Priority DEBUG = new Priority(DEBUG_INT, ""DEBUG"", 6);
  /**
     Instantiate a priority object.
   */
  protected
  Priority(int level, String levelStr, int syslogEquivalent) {
    this.level = level;
    this.levelStr = levelStr;
    this.syslogEquivalent = syslogEquivalent;
  }
  /**
     Return the syslog equivalent of this priority as an integer.
   */
  public
  final
  int getSyslogEquivalent() {
    return syslogEquivalent;
  }
  /**
     Returns the string representation of this priority.
   */
  final
  public
  String toString() {
    return levelStr;
  }
  /**
     Returns the integer representation of this priority.
   */
  public
  final
  int toInt() {
    return level;
  }
  /**
     Returns <code>true</code> if this priority has a higher or equal
     priority than the priority passed as argument, <code>false</code>
     otherwise.  
     <p>You should think twice before overriding the default
     implementation of <code>isGreaterOrEqual</code> method.
  */
  public
  boolean isGreaterOrEqual(Priority r) {
    return level >= r.level;
  }
  /**
     Return all possible priorities as an array of Priority objects in
     descending order.  */
  public
  static
  Priority[] getAllPossiblePriorities() {
    return new Priority[] {Priority.FATAL, Priority.ERROR, Priority.WARN, 
			     Priority.INFO, Priority.DEBUG};
  }
  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns {@link #DEBUG}. 
  */
  public
  static
  Priority toPriority(String sArg) {
    return toPriority(sArg, Priority.DEBUG);
  }
  /**
    Convert an integerq passed as argument to a priority. If the
    conversion fails, then this method returns {@link #DEBUG}.      
  */
  public
  static
  Priority toPriority(int val) {
    switch(val) {
    case DEBUG_INT: return DEBUG;
    case INFO_INT: return INFO;
    case WARN_INT: return WARN;
    case ERROR_INT: return ERROR;
    case FATAL_INT: return FATAL;
    default: return DEBUG;
    }
  }
  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns the value of
     <code>defaultPriority</code>.  
  */
  public
  static
  Priority toPriority(String sArg, Priority defaultPriority) {                  
    if(sArg == null)
       return defaultPriority;
    String s = sArg.toUpperCase();
    if(s.equals(""DEBUG"")) return Priority.DEBUG; 
    if(s.equals(""INFO""))  return Priority.INFO;
    if(s.equals(""WARN""))  return Priority.WARN;  
    if(s.equals(""ERROR"")) return Priority.ERROR;
    if(s.equals(""FATAL"")) return Priority.FATAL;
    return defaultPriority;
  }
}
"
org.apache.log4j.PropertyConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
// Contibutors: ""Luke Blanshard"" <Luke@quiq.com>
//              ""Mark DONSZELMANN"" <Mark.Donszelmann@cern.ch>
//              Anders Kristensen <akristensen@dynamicsoft.com>
package org.apache.log4j;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.DefaultCategoryFactory;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.FileWatchdog;
import java.util.NoSuchElementException;
import java.util.Enumeration;
import java.util.Properties;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.Hashtable;
/**
   Extends {@link BasicConfigurator} to provide configuration from an
   external file.  See <b>{@link #doConfigure(String, Hierarchy)}</b> for the
   expected format.
   <p>It is sometimes useful to see how log4j is reading configuration
   files. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable. 
   <P>As of log4j version 0.8.5, at the initialization of the Category
   class, the file <b>log4j.properties</b> will be searched from the
   search path used to load classes. If the file can be found, then it
   will be fed to the {@link
   PropertyConfigurator#configure(java.net.URL)} method.
   <p>The <code>PropertyConfigurator</code> does not handle the
   advanced configuration features supported by the {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator} such as support for
   sub-classing of the Priority class, {@link org.apache.log4j.spi.Filter
   Filters}, custom {@link org.apache.log4j.spi.ErrorHandler ErrorHandlers},
   nested appenders such as the {@link org.apache.log4j.AsyncAppender
   AsyncAppender}, etc.
   <p><em>All option values admit variable substitution.</em> For
   example, if <code>java.home</code> system property is set to
   <code>/home/xyz</code> and the File option is set to the string
   <code>${java.home}/test.log</code>, then File option will be
   interpreted as the string <code>/home/xyz/test.log</code>.
   <p>The value of the substituted variable can be defined as a system
   property or in the configuration file file itself.
   <p>The syntax of variable substituion is similar to that of UNIX
   shells. The string between an opening <b>&quot;${&quot;</b> and
   closing <b>&quot;}&quot;</b> is interpreted as a key. Its value is
   searched in the system properties, and if not founf then in the
   configuration file being parsed.  The corresponding value replaces
   the ${variableName} sequence.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.8.1 */
public class PropertyConfigurator extends BasicConfigurator
           implements Configurator {
  /**
     Used internally to keep track of configured appenders.
   */
  protected Hashtable registry = new Hashtable(11);
  protected CategoryFactory categoryFactory = new DefaultCategoryFactory();
  static final String CATEGORY_PREFIX = ""log4j.category."";
  static final String ADDITIVITY_PREFIX = ""log4j.additivity."";
  static final String ROOT_CATEGORY_PREFIX = ""log4j.rootCategory"";
  static final String APPENDER_PREFIX = ""log4j.appender."";  
  static final String RENDERER_PREFIX = ""log4j.renderer."";
  static final String CATEGORY_FACTORY_KEY = ""log4j.categoryFactory"";
  static final private String INTERNAL_ROOT_NAME = ""root"";
  /**
    Read configuration from a file. The existing configuration is not
    cleared nor reset. If you require a different call, behaviour,
    then call {@link BasicConfigurator#resetConfiguration
    resetConfiguration} method before calling
    <code>doConfigure</code>.
    <p>The configuration file consists of staments in the format
    <code>key=value</code>.
    <h3>Appender configuration</h3>
    <p>Appender configuration syntax is:
    <pre>
    # For appender named <i>appenderName</i>, set its class.
    # Note: The appender name can contain dots.
    log4j.appender.appenderName=fully.qualified.name.of.appender.class
    # Set appender specific options.
    log4j.appender.appenderName.option1=value1  
    ...
    log4j.appender.appenderName.optionN=valueN
    </pre>
    For each named appender you can configure its {@link Layout}. The
    syntax for configuring an appender's layout is:
    <pre>
    log.appender.appenderName.layout=fully.qualified.name.of.layout.class
    log.appender.appenderName.layout.option1=value1
    ....
    log.appender.appenderName.layout.optionN=valueN
    </pre>
    <h3>Configuring categories</h3>
    <p>The syntax for configuring the root category is:
    <pre>
      log4j.rootCategory=[FATAL|ERROR|WARN|INFO|DEBUG], appenderName, appenderName, ...
    </pre>
    <p>This syntax means that one of the strings values ERROR, WARN,
    INFO or DEBUG can be supplied followed by appender names separated
    by commas.
    <p>If one of the optional priority values ERROR, WARN, INFO or
    DEBUG is given, the root priority is set to the corresponding
    priority.  If no priority value is specified, then the root
    priority remains untouched.
    <p>The root category can be assigned multiple appenders.
    <p>Each <i>appenderName</i> (seperated by commas) will be added to
    the root category. The named appender is defined using the
    appender syntax defined above.
    <p>For non-root categories the syntax is almost the same:
    <pre>
    log4j.category.category_name=[INHERITED|FATAL|ERROR|WARN|INFO|DEBUG], appenderName, appenderName, ...
    </pre>
    <p>Thus, one of the usual priority values FATAL, ERROR, WARN,
    INFO, or DEBUG can be optionally specified. For any any of these
    values the named category is assigned the corresponding
    priority. In addition however, the value INHERITED can be
    optionally specified which means that named category should
    inherit its priority from the category hierarchy.
    <p>If no priority value is supplied, then the priority of the
    named category remains untouched.
    <p>By default categories inherit their priority from the
    hierarchy. However, if you set the priority of a category and
    later decide that that category should inherit its priority, then
    you should specify INHERITED as the value for the priority value.
    <p>Similar to the root category syntax, each <i>appenderName</i>
    (seperated by commas) will be attached to the named category.
    <p>See the <a href=""../../manual.html#additivity"">appender
    additivity rule</a> in the user manual for the meaning of the
    <code>additivity</code> flag.
    <p>The user can override any of the {@link
    BasicConfigurator#disable} family of methods by setting the a key
    ""log4j.disableOverride"" to <code>true</code> or any value other
    than false. As in <pre> log4j.disableOverride=true </pre>
    <h3>ObjectRenderers</h3>
    You can customize the way message objects of a given type are
    converted to String before being logged. This is done by
    specifying an {@link org.apache.log4j.or.ObjectRenderer ObjectRenderer}
    for the object type would like to customize.
    <p>The syntax is:
    <pre>
    log4j.renreder.fully.qualified.name.of.rendered.class=fully.qualified.name.of.rendering.class
    </pre>
    As in,
    <pre>
    log4j.renderer.my.Fruit=my.FruitRenderer
    </pre>
    <h3>Class Factories</h3>
    In case you are using your own sub-types of the
    <code>Category</code> class and wish to use configuration files,
    then you <em>must</em> set the <code>categoryFactory</code> for
    the sub-type that you are using.
    <p>The syntax is:
    <pre>
    log4j.categoryFactory=fully.qualified.name.of.categoryFactory.class
    </pre>
    See {@link org.apache.log4j.examples.MyCategory} for an example.
    <h3>Example</h3>
    <p>An example configuration is given below. Other configuration
    file examples are given in {@link org.apache.log4j.examples.Sort}
    class documentation.
    <pre>
    # Set options for appender named ""A1"". 
    # Appender ""A1"" will be a SyslogAppender
    log4j.appender.A1=org.apache.log4j.net.SyslogAppender
    # The syslog daemon resides on www.abc.net
    log4j.appender.A1.SyslogHost=www.abc.net
    # A1's layout is a PatternLayout, using the conversion pattern 
    # <b>%r %-5p %c{2} %M.%L %x - %m\n</b>. Thus, the log output will
    # include # the relative time since the start of the application in
    # milliseconds, followed by the priority of the log request,
    # followed by the two rightmost components of the category name,
    # followed by the callers method name, followed by the line number,
    # the nested disgnostic context and finally the message itself.
    # Refer to the documentation of {@link PatternLayout} for further information
    # on the syntax of the ConversionPattern key.    
    log4j.appender.A1.layout=org.apache.log4j.PatternLayout
    log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %c{2} %M.%L %x - %m\n
    # Set options for appender named ""A2""
    # A2 should be a RollingFileAppender, with maximum file size of 10 MB
    # using at most one backup file. A2's layout is TTCC, using the
    # ISO8061 date format with context printing enabled.    
    log4j.appender.A2=org.apache.log4j.RollingFileAppender
    log4j.appender.A2.MaxFileSize=10MB
    log4j.appender.A2.MaxBackupIndex=1
    log4j.appender.A2.layout=org.apache.log4j.TTCCLayout
    log4j.appender.A2.layout.ContextPrinting=enabled
    log4j.appender.A2.layout.DateFormat=ISO8601
    # Root category set to DEBUG using the A2 appender defined above.
    log4j.rootCategory=DEBUG, A2
    # Category definions:
    # The SECURITY category inherits is priority from root. However, it's output
    # will go to A1 appender defined above. It's additivity is non-cumulative.
    log4j.category.SECURITY=INHERIT, A1
    log4j.additivity.SECURITY=false
    # Only warnings or above will be logged for the category ""SECURITY.access"".
    # Output will go to A1.
    log4j.category.SECURITY.access=WARN
    # The category ""class.of.the.day"" inherits its priority from the
    # category hierrarchy.  Output will go to the appender's of the root
    # category, A2 in this case.
    log4j.category.class.of.the.day=INHERIT
    </pre>
    <p>Refer to the <b>setOption</b> method in each Appender and
    Layout for class specific options.
    <p>Use the <code>#</code> or <code>!</code> characters at the
    beginning of a line for comments.
   <p> 
   @param configFileName The name of the configuration file where the
   configuration information is stored.
  */
  public
  void doConfigure(String configFileName, Hierarchy hierarchy) {
    Properties props = new Properties();
    try {
      FileInputStream istream = new FileInputStream(configFileName);
      props.load(istream);
      istream.close();
    }
    catch (IOException e) {
      LogLog.error(""Could not read configuration file ["" + configFileName+
			 ""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configFileName+""]."");
      return;
    }
    // If we reach here, then the config file is alright.
    doConfigure(props, hierarchy);
  }
  /**
   */
  static
  public 
  void configure(String configFilename) {
    new PropertyConfigurator().doConfigure(configFilename, 
					   Category.defaultHierarchy);
  }
  /**
     Read configuration options from url <code>configURL</code>.
     @since 0.8.2
   */
  public
  static
  void configure(java.net.URL configURL) {
    new PropertyConfigurator().doConfigure(configURL, Category.defaultHierarchy);
  }
  /**
     Read configuration options from <code>properties</code>.
     See {@link #doConfigure(String, Hierarchy)} for the expected format.
  */
  static
  public
  void configure(Properties properties) {
    new PropertyConfigurator().doConfigure(properties, Category.defaultHierarchy);
  }
  /**
     Like {@link #configureAndWatch(String, long)} except that the
     default delay as defined by {@link FileWatchdog#DEFAULT_DELAY} is
     used. 
     @param configFilename A file in key=value format.
  */
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }
  /**
     Read the configuration file <code>configFilename</code> if it
     exists. Moreover, a thread will be created that will periodically
     check if <code>configFilename</code> has been created or
     modified. The period is determined by the <code>delay</code>
     argument. If a change or file creation is detected, then
     <code>configFilename</code> is read to configure log4j.  
      @param configFilename A file in key=value format.
      @param delay The delay in milliseconds to wait between each check.
  */
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    PropertyWatchdog pdog = new PropertyWatchdog(configFilename);
    pdog.setDelay(delay);
    pdog.start();
  }
  /**
     Read configuration options from <code>properties</code>.
     See {@link #doConfigure(String, Hierarchy)} for the expected format.
  */
  public
  void doConfigure(Properties properties, Hierarchy hierarchy) {
    String value = properties.getProperty(LogLog.CONFIG_DEBUG_KEY);
    if(value != null) {
      LogLog.setInternalDebugging(OptionConverter.toBoolean(value, true));
    }
    // Check if the config file overides the shipped code flag.
    String override = properties.getProperty(
                                    BasicConfigurator.DISABLE_OVERRIDE_KEY);
    BasicConfigurator.overrideAsNeeded(override);
    configureRootCategory(properties, hierarchy);
    configureCategoryFactory(properties);
    parseCatsAndRenderers(properties, hierarchy);
    LogLog.debug(""Finished configuring."");    
    // We don't want to hold references to appenders preventing their
    // garbage collection.
    registry.clear();
  }
  /**
     Read configuration options from url <code>configURL</code>.
   */
  public
  void doConfigure(java.net.URL configURL, Hierarchy hierarchy) {
    Properties props = new Properties();
    LogLog.debug(""Reading configuration from URL "" + configURL);
    try {
      props.load(configURL.openStream());
    }
    catch (java.io.IOException e) {
      LogLog.error(""Could not read configuration file from URL ["" + configURL 
		   + ""]."", e);
      LogLog.error(""Ignoring configuration file ["" + configURL +""]."");
      return;
    }
    doConfigure(props, hierarchy);
  }
  // -------------------------------------------------------------------------------
  // Internal stuff
  // -------------------------------------------------------------------------------
  void configureCategoryFactory(Properties props) {
    String factoryClassName = OptionConverter.findAndSubst(CATEGORY_FACTORY_KEY,
							   props);    
    if(factoryClassName != null) {
      LogLog.debug(""Setting category factory to [""+factoryClassName+""]."");
      categoryFactory = (CategoryFactory) 
                  OptionConverter.instantiateByClassName(factoryClassName,
							 CategoryFactory.class, 
							 categoryFactory);
    }
  }
  void configureOptionHandler(OptionHandler oh, String prefix,
			      Properties props) {
    String[] options = oh.getOptionStrings();
    if(options == null) 
      return;
    String value;
    for(int i = 0; i < options.length; i++) {
      value =  OptionConverter.findAndSubst(prefix + options[i], props);
      LogLog.debug(
         ""Option "" + options[i] + ""=["" + (value == null? ""null"" : value)+""]."");
      // Some option handlers assume that null value are not passed to them.
      // So don't remove this check
      if(value != null) {
	oh.setOption(options[i], value);
      }
    }
    oh.activateOptions();
  }
  void configureRootCategory(Properties props, Hierarchy hierarchy) {
    String value = OptionConverter.findAndSubst(ROOT_CATEGORY_PREFIX, props);
    if(value == null) 
      LogLog.debug(""Could not find root category information. Is this OK?"");
    else {
      Category root = hierarchy.getRoot();
      synchronized(root) {
	parseCategory(props, root, ROOT_CATEGORY_PREFIX, INTERNAL_ROOT_NAME, 
		      value);
      }
    }        
  }
  /**
     Parse non-root elements, such non-root categories and renderers.
  */
  protected
  void parseCatsAndRenderers(Properties props, Hierarchy hierarchy) {
    Enumeration enum = props.propertyNames();
    while(enum.hasMoreElements()) {      
      String key = (String) enum.nextElement();
      if(key.startsWith(CATEGORY_PREFIX)) {
	String categoryName = key.substring(CATEGORY_PREFIX.length());	
	String value =  OptionConverter.findAndSubst(key, props);
	Category cat = hierarchy.getInstance(categoryName, categoryFactory);
	synchronized(cat) {
	  parseCategory(props, cat, key, categoryName, value);
	  parseAdditivityForCategory(props, cat, categoryName);
	}
      } else if(key.startsWith(RENDERER_PREFIX)) {
	String renderedClass = key.substring(RENDERER_PREFIX.length());	
	String renderingClass = OptionConverter.findAndSubst(key, props);
	addRenderer(renderedClass, renderingClass);
      }      
    }
  }  
  /**
     Parse the additivity option for a non-root category.
   */
  void parseAdditivityForCategory(Properties props, Category cat,
				  String categoryName) {
    String value = OptionConverter.findAndSubst(ADDITIVITY_PREFIX + categoryName, 
					     props);
    LogLog.debug(""Handling ""+ADDITIVITY_PREFIX + categoryName+""=[""+value+""]"");
    // touch additivity only if necessary	
    if((value != null) && (!value.equals(""""))) {
      boolean additivity = OptionConverter.toBoolean(value, true);
      LogLog.debug(""Setting additivity for \""""+categoryName+""\"" to ""+
		   additivity); 
      cat.setAdditivity(additivity);
    }
  }
  /**
     This method must work for the root category as well.
   */
  void parseCategory(Properties props, Category cat, String optionKey,
		     String catName, String value) {
    LogLog.debug(""Parsing for ["" +catName +""] with value=["" + value+""]."");
    // We must skip over ',' but not white space
    StringTokenizer st = new StringTokenizer(value, "","");
    // If value is not in the form "", appender.."" or """", then we should set
    // the priority of the category.
    if(!(value.startsWith("","") || value.equals(""""))) {
      // just to be on the safe side...
      if(!st.hasMoreTokens())
	return;
      String priorityStr = st.nextToken();
      LogLog.debug(""Priority token is ["" + priorityStr + ""]."");
      // If the priority value is inherited, set category priority value to
      // null. We also check that the user has not specified inherited for the
      // root category.
      if(priorityStr.equalsIgnoreCase(BasicConfigurator.INHERITED) &&
	                              !catName.equals(INTERNAL_ROOT_NAME)) 
	cat.setPriority(null);
      else 
	cat.setPriority(Priority.toPriority(priorityStr));
      LogLog.debug(""Category "" + catName + "" set to "" + cat.getPriority());
    }
    // Remove all existing appenders. They will be reconstructed below.
    cat.removeAllAppenders();
    Appender appender;    
    String appenderName;
    while(st.hasMoreTokens()) {
      appenderName = st.nextToken().trim();
      if(appenderName == null || appenderName.equals("",""))
	continue;
      LogLog.debug(""Parsing appender named \"""" + appenderName +""\""."");
      appender = parseAppender(props, appenderName);
      if(appender != null) {
	cat.addAppender(appender);
      }      
    }          
  }
  Appender parseAppender(Properties props, String appenderName) {
    Appender appender = registryGet(appenderName);
    if((appender != null)) {
      LogLog.debug(""Appender \"""" + appenderName + ""\"" was already parsed."");
      return appender;
    }
    // Appender was not previously initialized.
    String prefix = APPENDER_PREFIX + appenderName;
    String layoutPrefix = prefix + "".layout"";    
    appender = (Appender) OptionConverter.instantiateByKey(props, prefix,
					      org.apache.log4j.Appender.class,
					      null);
    if(appender == null) {
      LogLog.error(
              ""Could not instantiate appender named \"""" + appenderName+""\""."");
      return null;
    }
    appender.setName(appenderName);
    if(appender instanceof OptionHandler) {
      configureOptionHandler((OptionHandler) appender, prefix + ""."", props);
      LogLog.debug(""Parsed \"""" + appenderName +""\"" options."");
      if(appender.requiresLayout()) {
	Layout layout = (Layout) OptionConverter.instantiateByKey(props, 
								  layoutPrefix,
								  Layout.class, 
								  null);
	if(layout != null) {
	  appender.setLayout(layout);
	  LogLog.debug(""Parsing layout options for \"""" + appenderName +""\""."");
	  configureOptionHandler(layout, layoutPrefix + ""."", props);
	  LogLog.debug(""End of parsing for \"""" + appenderName +""\""."");      
	}
      }
    }
    registryPut(appender);
    return appender;
  }
  void  registryPut(Appender appender) {
    registry.put(appender.getName(), appender);
  }
  Appender registryGet(String name) {
    return (Appender) registry.get(name);
  }
}
class PropertyWatchdog extends FileWatchdog {
  PropertyWatchdog(String filename) {
    super(filename);
  }
  /**
     Call {@link PropertyConfigurator#configure(String)} with the
     <code>filename</code> to reconfigure log4j. */
  public
  void doOnChange() {
    new PropertyConfigurator().doConfigure(filename, Category.defaultHierarchy);
  }
}
"
org.apache.log4j.ProvisionNode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.util.Vector;
class ProvisionNode extends Vector {
  ProvisionNode(Category cat) {
    super();
    this.addElement(cat);
  }
}
"
org.apache.log4j.RollingFileAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.File;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.CountingQuietWriter;
import org.apache.log4j.spi.LoggingEvent;
/**
   RollingFileAppender extends FileAppender to backup the log files when 
   they reach a certain size. 
   @author <a HREF=""mailto:heinz.richter@ecmwf.int"">Heinz Richter</a>
   @author Ceki G&uuml;lc&uuml;
*/
public class RollingFileAppender extends FileAppender {
  /**
     A string constant used in naming the option for setting the
     maximum size of the log file. Current value of this string constant is
     <b>MaxFileSize</b>.
   */
  static final public String MAX_FILE_SIZE_OPTION = ""MaxFileSize"";
   /**
     A string constant used in naming the option for setting the the
     number of backup files to retain. Current value of this string
     constant is <b>MaxBackupIndex</b>.  */
  static final public String MAX_BACKUP_INDEX_OPTION = ""MaxBackupIndex"";  
  /**
     The default maximum file size is 10MB. 
  */
  protected long maxFileSize = 10*1024*1024; 
  /**
     There is one backup file by default.
   */
  protected int  maxBackupIndex  = 1;    
  /**
     The default constructor simply calls its {@link
     FileAppender#FileAppender parents constructor}.  */
  public
  RollingFileAppender() {
    super();
  }
 /**
    Instantiate a RollingFileAppender and set the output destination to a
     new {@link OutputStreamWriter} initialized with <code>os</code>
     as its {@link OutputStream}.  
     @deprecated This constructor does not allow to roll files and
     will disappear in the near future.  */
  public
  RollingFileAppender(Layout layout, OutputStream os) {
    super(layout, os);
  }
  /**
     Instantiate a RollingFileAppender and set the output destination
     to <code>writer</code>.
     <p>The <code>writer</code> must have been opened by the user.  
     @deprecated This constructor does not allow to roll files and will
     disappear in the near future.  */
  public
  RollingFileAppender(Layout layout, Writer writer) {
    super(layout, writer);
  }                    
  /**
    Instantiate a RollingFileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the ouput
    destination for this appender.
    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file desginated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  RollingFileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    super(layout, filename, append);
  }
  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.
    <p>The file will be appended to.  */
  public
  RollingFileAppender(Layout layout, String filename) throws IOException {
    super(layout, filename);
  }
  /**
     Retuns the option names for this component, namely {@link
     #MAX_FILE_SIZE_OPTION} and {@link #MAX_BACKUP_INDEX_OPTION} in
     addition to the options of {@link FileAppender#getOptionStrings
     FileAppender}.  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		 new String[] {MAX_FILE_SIZE_OPTION, MAX_BACKUP_INDEX_OPTION});
  }
  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    super.setFile(fileName, append);
    if(append) {
      File f = new File(fileName);
      ((CountingQuietWriter) qw).setCount(f.length());
    }
  }
  /**
     Implemetns the usual roll over behaviour.
     <p>If <code>MaxBackupIndex</code> is positive, then files
     {<code>File.1</code>, ..., <code>File.MaxBackupIndex -1</code>}
     are renamed to {<code>File.2</code>, ..., 
     <code>File.MaxBackupIndex</code>}. Moreover, <code>File</code> is
     renamed <code>File.1</code> and closed. A new <code>File</code> is
     created to receive further log output.
     <p>If <code>MaxBackupIndex</code> is equal to zero, then the
     <code>File</code> is truncated with no backup files created.
   */
  public
  synchronized
  void rollOver() {
    File target;    
    File file;
    // If maxBackups <= 0, then there is no file renaming to be done.
    if(maxBackupIndex > 0) {
      // Delete the oldest file, to keep Windows happy.
      file = new File(fileName + '.' + maxBackupIndex);    
      if (file.exists())
       file.delete();
      // Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
      for (int i = maxBackupIndex - 1; i >= 1; i--) {
	file = new File(fileName + ""."" + i);
	if (file.exists()) {
	  target = new File(fileName + '.' + (i + 1));
	  file.renameTo(target);
	}
      }
      // Rename fileName to fileName.1
      target = new File(fileName + ""."" + 1);
      this.closeWriterIfOurs(); // keep windows happy. 
      file = new File(fileName);
      file.renameTo(target);
    }
    try {
      // This will also close the file. This is OK since multiple
      // close operations are safe.
      this.setFile(fileName, false);
    }
    catch(IOException e) {
      System.err.println(""setFile(""+fileName+"", false) call failed."");
      e.printStackTrace();
    }
  }
  /**
     Set the maximum number of backup files to keep around.
   */
  public
  void setMaxBackupIndex(int maxBackups) {
    this.maxBackupIndex = maxBackups;    
  } 
  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over.     
   */
  public
  void setMaxFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;    
  }
   /**
     Set RollingFileAppender specific options.
     In addition to {@link FileAppender#setOption FileAppender
     options} RollingFileAppender recognizes the options
     <b>MaxFileSize</b> and <b>MaxBackupIndex</b>.
     <p>The <b>MaxFileSize</b> determines the size of log file
     before it is rolled over to backup files. This option takes an
     long integer in the range 0 - 2^63. You can specify the value
     with the suffixes ""KB"", ""MB"" or ""GB"" so that the integer is
     interpreted being expressed respectively in kilobytes, megabytes
     or gigabytes. For example, the value ""10KB"" will be interpreted
     as 10240.
     <p>The <b>MaxBackupIndex</b> option determines how many backup
     files are kept before the oldest being erased. This option takes
     a positive integer value. If set to zero, then there will be no
     backup files and the log file will be truncated when it reaches
     <code>MaxFileSize</code>.
   */
  public
  void setOption(String key, String value) {
    super.setOption(key, value);    
    if(key.equalsIgnoreCase(MAX_FILE_SIZE_OPTION)) {
      maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
    }
    else if(key.equalsIgnoreCase(MAX_BACKUP_INDEX_OPTION)) {
      maxBackupIndex = OptionConverter.toInt(value, maxBackupIndex);
    }
  }
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new CountingQuietWriter(writer, errorHandler);
  }
  /**
     This method differentiates RollingFileAppender from its super
     class.  
     @since 0.9.0
  */
  protected
  void subAppend(LoggingEvent event) {
    super.subAppend(event);
    if((fileName != null) &&
                     ((CountingQuietWriter) qw).getCount() >= maxFileSize) 
      this.rollOver();
   } 
} 
"
org.apache.log4j.SimpleLayout,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j;
import org.apache.log4j.spi.LoggingEvent;
/**
   SimpleLayout consists of the priority of the log statement,
   followed by "" - "" and then the log message itself. For example,
   <pre>
           DEBUG - Hello world
   </pre>
   <p>
   @author Ceki G&uuml;lc&uuml;
   @since version 0.7.0
   <p>{@link PatternLayout} offers a much more powerful alternative.
*/
public class SimpleLayout extends Layout {
  StringBuffer sbuf = new StringBuffer(128);
  public SimpleLayout() {
  }
  public
  void activateOptions() {
  }
  /**
     Return the a log statement in a format consisting of the
     <code>priority</code>, folloed by "" - "" and then the
     <code>message</code>. For example, <pre> INFO - ""A message""
     </pre>
     <p>The <code>category</code> parameter is ignored.
     <p>
     @return A byte array in SimpleLayout format.
    */
  public
  String format(LoggingEvent event) {
    sbuf.setLength(0);
    sbuf.append(event.priority.toString());
    sbuf.append("" - "");
    sbuf.append(event.message);
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }
  public
  String[] getOptionStrings() {
    return new String[0];
  }
/**
     The SimpleLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }  
  public
  void setOption(String option, String value) {
  }
}
"
org.apache.log4j.StressCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j;
import org.apache.log4j.Priority;
import org.apache.log4j.Category;
import java.util.Random;
/*
  Stress test the Category class.
*/
class StressCategory {
  static Priority[] priority = new Priority[] {Priority.DEBUG, 
					       Priority.INFO, 
					       Priority.WARN,
					       Priority.ERROR,
					       Priority.FATAL};
  static Priority defaultPriority = Category.getRoot().getPriority();
  static int LENGTH;
  static String[] names;
  static Category[] cat;
  static CT[] ct;
  static Random random = new Random(10);
  public static void main(String[] args) {
    LENGTH = args.length;
    if(LENGTH == 0) {
      System.err.println( ""Usage: java "" + StressCategory.class.getName() +
			  "" name1 ... nameN\n."");      
      System.exit(1);
    }
    if(LENGTH >= 7) {
      System.err.println(
        ""This stress test suffers from combinatorial explosion.\n""+
        ""Invoking with seven arguments takes about 90 minutes even on fast machines"");
    }
    names = new String[LENGTH];
    for(int i=0; i < LENGTH; i++) {
      names[i] = args[i];
    }    
    cat = new Category[LENGTH];
    ct = new CT[LENGTH]; 
    permute(0); 
    // If did not exit, then passed all tests.
  }
  // Loop through all permutations of names[].
  // On each possible permutation call createLoop
  static
  void permute(int n) {
    if(n == LENGTH)
      createLoop(0);
    else
      for(int i = n; i < LENGTH; i++) {
	swap(names, n, i);
	permute(n+1);
	swap(names, n, i);	
      }
  }
  static
  void swap(String[] names, int i, int j) {
    String t = names[i];
    names[i] = names[j];
    names[j] = t;
  }
  public
  static
  void permutationDump() {
    System.out.print(""Current permutation is - "");
    for(int i = 0; i < LENGTH; i++) {
      System.out.print(names[i] + "" "");
    }
    System.out.println();
  }
  // Loop through all possible 3^n combinations of not instantiating, 
  // instantiating and setting/not setting a priority.
  static
  void createLoop(int n) {
    if(n == LENGTH) {  
      //System.out.println(""..............Creating cat[]..........."");
      for(int i = 0; i < LENGTH; i++) {
	if(ct[i] == null)
	  cat[i] = null;
	else {
	  cat[i] = Category.getInstance(ct[i].catstr);
	  cat[i].setPriority(ct[i].priority);
	}
      }
      test();
      // Clear hash table for next round
      Category.defaultHierarchy.clear();
    }
    else {      
      ct[n]  = null;
      createLoop(n+1);  
      ct[n]  = new CT(names[n], null);
      createLoop(n+1);  
      int r = random.nextInt(); if(r < 0) r = -r;
      ct[n]  = new CT(names[n], priority[r%5]);
      createLoop(n+1);
    }
  }
  static
  void test() {    
    //System.out.println(""++++++++++++TEST called+++++++++++++"");
    //permutationDump();
    //catDump();
    for(int i = 0; i < LENGTH; i++) {
      if(!checkCorrectness(i)) {
	System.out.println(""Failed stress test."");
	permutationDump();
	//Hierarchy._default.fullDump();
	ctDump();
	catDump();
	System.exit(1);
      }
    }
  }
  static
  void ctDump() {
    for(int j = 0; j < LENGTH; j++) {
       if(ct[j] != null) 
	    System.out.println(""ct ["" + j + ""] = (""+ct[j].catstr+"","" + 
			       ct[j].priority + "")"");
       else 
	 System.out.println(""ct ["" + j + ""] = undefined"");
    }
  }
  static
  void catDump() {
    for(int j = 0; j < LENGTH; j++) {
      if(cat[j] != null)
	System.out.println(""cat["" + j + ""] = ("" + cat[j].name + "","" +
			   cat[j].getPriority() + "")"");
      else
	System.out.println(""cat["" + j + ""] = undefined""); 
    }
  }
  //  static
  //void provisionNodesDump() {
  //for (Enumeration e = CategoryFactory.ht.keys(); e.hasMoreElements() ;) {
  //  CategoryKey key = (CategoryKey) e.nextElement();
  //  Object c = CategoryFactory.ht.get(key);
  //  if(c instanceof  ProvisionNode) 
  //((ProvisionNode) c).dump(key.name);
  //}
  //}
  static
  boolean checkCorrectness(int i) {
    CT localCT = ct[i];
    // Can't perform test if category is not instantiated
    if(localCT == null) 
      return true;
    // find expected priority
    Priority expected = getExpectedPrioriy(localCT);
    Priority purported = cat[i].getChainedPriority();
    if(expected != purported) {
      System.out.println(""Expected priority for "" + localCT.catstr + "" is "" +
		       expected);
      System.out.println(""Purported priority for ""+ cat[i].name + "" is ""+purported);
      return false;
    }
    return true;
  }
  static
  Priority getExpectedPrioriy(CT ctParam) {
    Priority priority = ctParam.priority;
    if(priority != null) 
      return priority;
    String catstr = ctParam.catstr;    
    for(int i = catstr.lastIndexOf('.', catstr.length()-1); i >= 0; 
	                              i = catstr.lastIndexOf('.', i-1))  {
      String substr = catstr.substring(0, i);
      // find the priority of ct corresponding to substr
      for(int j = 0; j < LENGTH; j++) {	
	if(ct[j] != null && substr.equals(ct[j].catstr)) {
	  Priority p = ct[j].priority;
	  if(p != null) 
	    return p;	  
	}
      }
    }
    return defaultPriority;
  }
  static class CT {
    public String   catstr;
    public Priority priority;
    CT(String catstr,  Priority priority) {
      this.catstr = catstr;
      this.priority = priority;
    }
  }
}
"
org.apache.log4j.TTCCLayout,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
//      Copyright 2000, Ceki Gulcu. All Rights Reserved.
//      See the LICENCE file for the terms of distribution.
// Contributors: ""Christopher Williams"" <Christopher_Williams@mail.northgrum.com>
package org.apache.log4j;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.DateLayout;
import org.apache.log4j.helpers.RelativeTimeDateFormat;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.helpers.DateTimeDateFormat;
import org.apache.log4j.helpers.ISO8601DateFormat;
import org.apache.log4j.spi.LoggingEvent;
/**
 TTCC layout format consists of time, thread, category and nested
 diagnostic context information, hence the name.
 <p>Each of the four fields can be individually enabled or
 disabled. The time format depends on the <code>DateFormat</code>
 used.
 <p>Here is an example TTCCLayout output with the {@link RelativeTimeDateFormat}.
 <pre>
176 [main] INFO  org.apache.log4j.examples.Sort - Populating an array of 2 elements in reverse order.
225 [main] INFO  org.apache.log4j.examples.SortAlgo - Entered the sort method.
262 [main] DEBUG org.apache.log4j.examples.SortAlgo.OUTER i=1 - Outer loop.
276 [main] DEBUG org.apache.log4j.examples.SortAlgo.SWAP i=1 j=0 - Swapping intArray[0] = 1 and intArray[1] = 0
290 [main] DEBUG org.apache.log4j.examples.SortAlgo.OUTER i=0 - Outer loop.
304 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Dump of interger array:
317 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Element [0] = 0
331 [main] INFO  org.apache.log4j.examples.SortAlgo.DUMP - Element [1] = 1
343 [main] INFO  org.apache.log4j.examples.Sort - The next log statement should be an error message.
346 [main] ERROR org.apache.log4j.examples.SortAlgo.DUMP - Tried to dump an uninitialized array.
        at org.apache.log4j.examples.SortAlgo.dump(SortAlgo.java:58)
        at org.apache.log4j.examples.Sort.main(Sort.java:64)
467 [main] INFO  org.apache.log4j.examples.Sort - Exiting main method.
</pre>
  <p>The first field is the number of milliseconds elapsed since the
  start of the program. The second field is the thread outputting the
  log statement. The third field is the priority, the fourth field is
  the category to which the statement belongs.
  <p>The fifth field (just before the '-') is the nested diagnostic
  context.  Note the nested diagnostic context may be empty as in the
  first two statements. The text after the '-' is the message of the
  statement.
  <p><b>WARNING</b> Do not use the same TTCCLayout instance from
  within different appenders. The TTCCLayout is not thread safe when
  used in his way. However, it is perfectly safe to use a TTCCLayout
  instance from just one appender.
  <p>{@link PatternLayout} offers a much more flexible alternative.
  @author Ceki G&uuml;lc&uuml;
  @author <A HREF=""mailto:heinz.richter@ecmwf.int"">Heinz Richter</a>
*/
public class TTCCLayout extends DateLayout {
  final static public String THREAD_PRINTING_OPTION = ""ThreadPrinting"";
  final static public String CATEGORY_PREFIXING_OPTION = ""CategoryPrefixing"";
  final static public String CONTEXT_PRINTING_OPTION  = ""ContextPrinting"";  
  // Internal representation of options
  private boolean threadPrinting    = true;    
  private boolean categoryPrefixing = true;
  private boolean contextPrinting   = true;
  protected final StringBuffer buf = new StringBuffer(256);   
  /**
     Instantiate a TTCCLayout object with {@link
     RelativeTimeDateFormat} as the date formatter in the local time
     zone.
     @since 0.7.5
  */
  public TTCCLayout() {
    this.setDateFormat(RELATIVE_TIME_DATE_FORMAT, null);
  } 
  /**
     Instantiate a TTCCLayout object using the local time zone. The
     DateFormat used will depend on the <code>dateFormatType</code>.
     <p>This constructor just calls the {@link
     DateLayout#setDateFormat} method.
     */
  public TTCCLayout(String dateFormatType) {
    this.setDateFormat(dateFormatType);
  }
  /**
   In addition to the priority of the statement and message, the
   returned byte array includes time, thread, category and {@link NDC}
   information.
   <p>Time, thread, category and diagnostic context are printed
   depending on options.
    @param category
    @param priority
    @param message
  */
  public
  String format(LoggingEvent event) {
    // Reset buf
    buf.setLength(0);
    dateFormat(buf, event);
    if(this.threadPrinting) {
      buf.append('[');
      buf.append(event.getThreadName());
      buf.append(""] "");
    }
    buf.append(event.priority.toString());
    buf.append(' ');
    if(this.categoryPrefixing) {
      buf.append(event.categoryName);
      buf.append(' ');
    }
    if(this.contextPrinting) {
       event.getNDC();
      if(event.ndc != null) {
	buf.append(event.ndc);
	buf.append(' ');
      }
    }    
    buf.append(""- "");
    buf.append(event.message);
    buf.append(LINE_SEP);    
    return buf.toString();
  }
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
              new String[] {THREAD_PRINTING_OPTION, CATEGORY_PREFIXING_OPTION,
  			    CONTEXT_PRINTING_OPTION});
  }
 /** 
     The TTCCLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.
     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
  /**
    <p>On top of the {@link DateLayout#setOption DateLayout} options
    <code>TTCCLayout</code> specific options are:
    <dl>
    <p><dt><b>ThreadPrinting</b>
    <dd>If set to true, the printed message will include the name of
    the current thread. Is set to true by default.
    <p><dt><b>ContextPrinting</b>
    <dd>If set to true, the printed message will include the nested
    context belonging to current thread. Is set to true by default.
    <p><dt><b>CategoryPrefixing</b>
    <dd>If set to true, the printed message will include the category
    of the satetement as prefix. Is set to true by default.
    </dl> */
  public
  void setOption(String key, String value) {
    super.setOption(key, value);    
    if(key.equalsIgnoreCase(THREAD_PRINTING_OPTION)) 
      threadPrinting = OptionConverter.toBoolean(value, threadPrinting);
    else if(key.equalsIgnoreCase(CATEGORY_PREFIXING_OPTION))
      categoryPrefixing = OptionConverter.toBoolean(value, categoryPrefixing);
    else if(key.equalsIgnoreCase(CONTEXT_PRINTING_OPTION))
      contextPrinting = OptionConverter.toBoolean(value, contextPrinting);
  }
  /**
     Provides an alternate mehtod to setting the
     <code>CategoryPrefixing</code> option. Preferred method to set
     options is through a configuration file.
     <p>See also {@link PropertyConfigurator}.
  */
  public
  void setCategoryPrefixing(boolean categoryPrefixing) {
    this.categoryPrefixing = categoryPrefixing;    
  }
  /**
     Provides an alternate mehtod to setting the
     <code>ThreadPrinting</code> option. Preferred method to set options
     is through the configuration file.
     <p>Seel also {@link PropertyConfigurator}
  */
  public
  void setThreadPrinting(boolean threadPrinting) {
    this.threadPrinting = threadPrinting;    
  }
} 
"
org.apache.log4j.gui.JListView,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.gui;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.Priority;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.spi.LoggingEvent;
import javax.swing.JList;
import javax.swing.AbstractListModel;
import javax.swing.JFrame;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.JScrollPane;
import javax.swing.ListCellRenderer;
import java.awt.Component;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import javax.swing.BoxLayout;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.Container;
import javax.swing.ImageIcon;
import java.awt.Image;
import java.awt.Toolkit;
import java.net.URL;
import java.awt.Rectangle;
public class JListView extends JList {
  static Category cat = Category.getInstance(JListView.class.getName());
  //JListViewModel model;
  PatternLayout layout;
  static LoggingEvent proto = new LoggingEvent(""x"", cat, Priority.ERROR, 
					       ""Message "", new Throwable());
  public
  JListView(JListViewModel model) {
    super(model);
    layout = new PatternLayout(""%r %p %c [%t] -  %m"");
    //this.setModel(model);
    this.setCellRenderer(new MyCellRenderer());
    //    setFixedCellWidth(10);
    //setFixedCellHeight(20);
  }
  public
  void add(LoggingEvent event) {
    ((JListViewModel)getModel()).add(event);
  }
  /*
  public
  Dimension getPreferredSize() {
    System.out.println(""getPreferredSize() called"");
    return super.getPreferredSize();
  }
  public
  int getScrollableUnitIncrement(Rectangle visibleRect, int orientation,
				 int direction) {
    System.out.println(""getScrollableUnitIncrement called with "" + visibleRect +
		       ""orientation: ""+orientation+"", direction: ""+direction);
    return super.getScrollableUnitIncrement(visibleRect, orientation, 
    				    direction);
  }
  public
  int getScrollableBlockIncrement(Rectangle visibleRect, int orientation,
				  int direction) {
    System.out.println(""getScrollableBlockIncrement called with "" + 
		       visibleRect + ""orientation: ""+orientation+
		       "", direction: ""+direction);
    return super.getScrollableBlockIncrement(visibleRect, orientation, 
    				     direction);
  }
  */
  //public
  //boolean getScrollableTracksViewportWidth() {
  //System.out.println(""getScrollableTracksViewportWidth called."");
  //return true;
    //boolean b = super.getScrollableTracksViewportWidth();
    //System.out.println(""result is: ""+b);
    //return b;
  //}
  //public
  //boolean getScrollableTracksViewportHeight() { 
  // System.out.println(""getScrollableTracksViewportHeight called."");
  // return true;
     //boolean b = super.getScrollableTracksViewportHeight();
     //System.out.println(""result is: ""+b);
     //return b;
  //}
  //public 
  //int getFirstVisibleIndex() {
  //int r = getFirstVisibleIndex(); 
  // System.out.println(""----------getFirstVisibleIndex called, result: ""+r);
  //return r;
  //}
  //public
  //Object getPrototypeCellValue() {
  //return proto;
  //}
  static public void main(String[] args) {
    JFrame frame = new JFrame(""JListView test"");
    Container container = frame.getContentPane();
    JListView view = new JListView(new JListViewModel(Integer.parseInt(args[0])));
    JScrollPane sp = new JScrollPane(view);
    sp.setPreferredSize(new Dimension(250, 80));
    container.setLayout(new BoxLayout(container, BoxLayout.X_AXIS));
    //container.add(view);
    container.add(sp);
    JButton b1 = new JButton(""Add 1"");
    JButton b10 = new JButton(""Add 10"");
    JButton b100 = new JButton(""Add 100"");
    JButton b1000 = new JButton(""Add 1000"");
    JButton b10000 = new JButton(""Add 10000"");
    JPanel panel = new JPanel(new GridLayout(0,1));
    container.add(panel);
    panel.add(b1);
    panel.add(b10);
    panel.add(b100);
    panel.add(b1000);
    panel.add(b10000);
    AddAction a1 = new AddAction(view, 1);
    AddAction a10 = new AddAction(view, 10);
    AddAction a100 = new AddAction(view, 100);
    AddAction a1000 = new AddAction(view, 1000);
    AddAction a10000 = new AddAction(view, 10000);
    b1.addActionListener(a1);
    b10.addActionListener(a10);
    b100.addActionListener(a100);
    b1000.addActionListener(a1000);
    b10000.addActionListener(a10000);
    frame.setVisible(true);
    frame.setSize(new Dimension(700,700));
    long before = System.currentTimeMillis();
    int RUN = 1000;
    int i = 0;
    while(i++ < RUN) {      
      LoggingEvent event = new LoggingEvent(""x"", cat, Priority.ERROR, 
					    ""Message ""+i, null);
      event.getThreadName();
      if(i % 10 == 0) {
	event.throwable = new Exception(""hello ""+i);
      }
      view.add(event);
    }
    long after = System.currentTimeMillis();
    System.out.println(""Time taken :""+ ((after-before)*1000/RUN));
  }
  class MyCellRenderer extends JTextArea implements ListCellRenderer {
    Object o = new Object();
    int i = 0;
    final ImageIcon longIcon = new ImageIcon(""RedFlag.gif"");
    public
    MyCellRenderer() {
      System.out.println(""----------------------"");
    }
    public
    int getTabSize()  {
      return 2;
    }
    public Image loadIcon ( String path ) {
    Image img = null;
    try {
      URL url = ClassLoader.getSystemResource(path);
      img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
    } catch (Exception e) {
      System.out.println(""Exception occured: "" + e.getMessage() + 
			 "" - "" + e );   
    }	
    return (img);
  }
    public Component getListCellRendererComponent(JList list,
						Object value, 
						int index, // cell index
						boolean isSelected, 
						boolean cellHasFocus) {
      //      System.out.println(o + "" ============== "" + i++);
      //LogLog.error(""======="", new Exception());
      //setIcon(longIcon);
      if(value instanceof LoggingEvent) {
	LoggingEvent event = (LoggingEvent) value;
	String str = layout.format(event);
	String t = event.getThrowableInformation();
	if(t != null) {
	  setText(str + Layout.LINE_SEP + t);
	} else {	
	  setText(str);
	}
      } else {
	setText(value.toString());
      }
      return this;
    }
  }
}
class JListViewModel extends AbstractListModel {
  CyclicBuffer cb;
  JListViewModel(int size) {
    cb = new CyclicBuffer(size);
  }
  public
  void add(LoggingEvent event) {
    //System.out.println(""JListViewModel.add called"");
    cb.add(event);
    int j = cb.length();
    fireContentsChanged(this, 0, j);
  }
  public
  Object getElementAt(int index) {
    return cb.get(index);
  }
  public
  int getSize() {
    return cb.length();
  }
}
class AddAction implements ActionListener {
  Thread t;
  static int counter = 0;
  public
  AddAction(JListView view, int burst) {
    this.t = new AddThread(view, burst);
    t.start();
  }
  public
  void actionPerformed(ActionEvent e) {
    System.out.println(""Action occured"");
    synchronized(t) {
      t.notify();
    }
  }
  class AddThread extends Thread {
    int burst;
    JListView view;
    Category cat = Category.getInstance(""x"");
    AddThread(JListView view, int burst) {
      super();
      this.burst = burst;
      this.view = view;
      setName(""AddThread""+burst);
    }
    public
    void run() {
      while(true) {
	synchronized(this) {
	  try {
	    this.wait();
	  } catch(Exception e) {
	  }
	}
	for(int i = 0; i < burst; i++) {
	  LoggingEvent event = new LoggingEvent(""x"", cat, Priority.DEBUG, 
						""Message ""+counter, null);
	  event.getThreadName();    
	  if(counter % 50 == 0) {
	    event.throwable = new Exception(""hello ""+counter);
	  }
	  counter++;
	  view.add(event);
	}
      }
    }
  }
}
"
org.apache.log4j.gui.JTableAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.gui;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.Priority;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.spi.LoggingEvent;
import javax.swing.JList;
import javax.swing.AbstractListModel;
import javax.swing.JFrame;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.JScrollPane;
import javax.swing.ListCellRenderer;
import java.awt.Component;
import java.awt.FlowLayout;
import javax.swing.BoxLayout;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.Container;
import javax.swing.ImageIcon;
import java.awt.Image;
import java.awt.Toolkit;
import java.net.URL;
import java.awt.Rectangle;
public class JTableAppender extends JTable {
  static Category cat = Category.getInstance(JTableAppender.class.getName());
  PatternLayout layout;
  public
  JTableAppender() {
    layout = new PatternLayout(""%r %p %c [%t] -  %m"");
    this.setDefaultRenderer(Object.class, new Renderer());
  }
  public
  void add(LoggingEvent event) {
    ((JTableAppenderModel)getModel()).add(event);
  }
  public
  Dimension getPreferredSize() {
    System.out.println(""getPreferredSize() called"");
    return super.getPreferredSize();
  }
  static public void main(String[] args) {
    JFrame frame = new JFrame(""JListView test"");
    Container container = frame.getContentPane();
    JTableAppender appender = new JTableAppender();
    JTableAppenderModel model = new 
                              JTableAppenderModel(Integer.parseInt(args[0]));
    appender.setModel(model);
    //appender.createDefaultColumnsFromModel();    
    JScrollPane sp = new JScrollPane(appender);
    sp.setPreferredSize(new Dimension(250, 80));
    container.setLayout(new BoxLayout(container, BoxLayout.X_AXIS));
    //container.add(view);
    container.add(sp);
    JButton button = new JButton(""ADD"");
    container.add(button);
    button.addActionListener(new JTableAddAction(appender));
    frame.setVisible(true);
    frame.setSize(new Dimension(700,700));
    long before = System.currentTimeMillis();
    int RUN = 10000;
    int i = 0;
    while(i++ < RUN) {      
      LoggingEvent event = new LoggingEvent(""x"", cat, Priority.ERROR, 
					    ""Message ""+i, null);
      event.getThreadName();
      if(i % 10 == 0) {
	event.throwable = new Exception(""hello ""+i);
      }
      appender.add(event);
    }
    long after = System.currentTimeMillis();
    System.out.println(""Time taken :""+ ((after-before)*1000/RUN));
  }
  class Renderer extends JTextArea implements TableCellRenderer {
    Object o = new Object();
    int i = 0;
    public
    Renderer() {
      System.out.println(""Render() called ----------------------"");      
    }
    public Component getTableCellRendererComponent(JTable table,
						   Object value,
						   boolean isSelected,
						   boolean hasFocus,
						   int row,
						   int column) {
      System.out.println(o + "" ============== "" + i++);
      //LogLog.error(""======="", new Exception());
      //setIcon(longIcon);
      if(value instanceof LoggingEvent) {
	LoggingEvent event = (LoggingEvent) value;
	String str = layout.format(event);
	String t = event.getThrowableInformation();
	if(t != null) {
	  System.out.println(""eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"");
	  setText(str + Layout.LINE_SEP + t);
	} else {	
	  setText(str);
	}
      } else {
	setText(value.toString());
      }
      return this;
    }
  }
}
class JTableAppenderModel extends AbstractTableModel {
  CyclicBuffer cb;
  JTableAppenderModel(int size) {
    cb = new CyclicBuffer(size);
  }
  public
  void add(LoggingEvent event) {
    //System.out.println(""JListViewModel.add called"");
    cb.add(event);
    int j = cb.length();
    fireTableDataChanged();
  }
  public 
  int getColumnCount() { 
    return 1; 
  }
  public int getRowCount() { 
    return cb.length();
  }
  //public
  //Class getColumnClass(int index) {
  //  System.out.println(""getColumnClass called "" + index);
  //  return LoggingEvent.class;
  //}
  public 
  Object getValueAt(int row, int col) {
    return cb.get(row);
  }
}
class JTableAddAction implements ActionListener {
  int j;
  JTableAppender appender;
  Category cat = Category.getInstance(""x"");
  public
  JTableAddAction(JTableAppender appender) {
    this.appender = appender;
    j = 0;
  }
  public
  void actionPerformed(ActionEvent e) {
    System.out.println(""Action occured"");
    LoggingEvent event = new LoggingEvent(""x"", cat, Priority.DEBUG, 
					    ""Message ""+j, null);
    if(j % 5 == 0) {
      event.throwable = new Exception(""hello ""+j);
    }
    j++;
    appender.add(event);
  }
}
"
org.apache.log4j.gui.TextPaneAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.gui;
import java.awt.Color;
import java.awt.Image;
import java.awt.Toolkit;
import java.io.*;
import java.net.URL;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Hashtable;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.MutableAttributeSet;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import javax.swing.text.TabSet;
import javax.swing.text.TabStop;
import org.apache.log4j.*;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.Loader;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.TracerPrintWriter;
import org.apache.log4j.helpers.OptionConverter;
/**
 * <b>Experimental</b> TextPaneAppender. <br>
 *
 *
 * Created: Sat Feb 26 18:50:27 2000 <br>
 *
 * @author Sven Reimers
 */
public class TextPaneAppender extends AppenderSkeleton {
  JTextPane textpane;
  StyledDocument doc;
  TracerPrintWriter tp;
  StringWriter sw;
  QuietWriter qw;
  Hashtable attributes;
  Hashtable icons;
  private String label;
  private boolean fancy;
  final String LABEL_OPTION = ""Label"";
  final String COLOR_OPTION_FATAL = ""Color.Emerg"";
  final String COLOR_OPTION_ERROR = ""Color.Error"";
  final String COLOR_OPTION_WARN = ""Color.Warn"";
  final String COLOR_OPTION_INFO = ""Color.Info"";
  final String COLOR_OPTION_DEBUG = ""Color.Debug"";
  final String COLOR_OPTION_BACKGROUND = ""Color.Background"";
  final String FANCY_OPTION = ""Fancy"";
  final String FONT_NAME_OPTION = ""Font.Name"";
  final String FONT_SIZE_OPTION = ""Font.Size"";
  public static Image loadIcon ( String path ) {
    Image img = null;
    try {
      URL url = ClassLoader.getSystemResource(path);
      img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
    } catch (Exception e) {
      System.out.println(""Exception occured: "" + e.getMessage() + 
			 "" - "" + e );   
    }	
    return (img);
  }
  public TextPaneAppender(Layout layout, String name) {
    this();
    this.layout = layout;
    this.name = name;
    setTextPane(new JTextPane());
    createAttributes();
    createIcons();
  }
  public TextPaneAppender() {
    super();
    setTextPane(new JTextPane());
    createAttributes();
    createIcons();
    this.label="""";
    this.sw = new StringWriter();
    this.qw = new QuietWriter(sw, errorHandler);
    this.tp = new TracerPrintWriter(qw);
    this.fancy =true;
  }
  public
  void close() {
  }
  private void createAttributes() {	
    Priority prio[] = Priority.getAllPossiblePriorities();
    attributes = new Hashtable();
    for (int i=0; i<prio.length;i++) {
      MutableAttributeSet att = new SimpleAttributeSet();
      attributes.put(prio[i], att);
      StyleConstants.setFontSize(att,14);
    }
    StyleConstants.setForeground((MutableAttributeSet)attributes.get(Priority.ERROR),Color.red);
    StyleConstants.setForeground((MutableAttributeSet)attributes.get(Priority.WARN),Color.orange);
    StyleConstants.setForeground((MutableAttributeSet)attributes.get(Priority.INFO),Color.gray);
    StyleConstants.setForeground((MutableAttributeSet)attributes.get(Priority.DEBUG),Color.black);
  }
  private void createIcons() {
    Priority prio[] = Priority.getAllPossiblePriorities();
    icons = new Hashtable();
    for (int i=0; i<prio.length;i++) {
      if (prio[i].equals(Priority.FATAL))
	icons.put(prio[i],new ImageIcon(loadIcon(""icons/RedFlag.gif"")));
      if (prio[i].equals(Priority.ERROR))		
	icons.put(prio[i],new ImageIcon(loadIcon(""icons/RedFlag.gif"")));
      if (prio[i].equals(Priority.WARN))		
	icons.put(prio[i],new ImageIcon(loadIcon(""icons/BlueFlag.gif"")));
      if (prio[i].equals(Priority.INFO))		
	icons.put(prio[i],new ImageIcon(loadIcon(""icons/GreenFlag.gif"")));
      if (prio[i].equals(Priority.DEBUG))		
	icons.put(prio[i],new ImageIcon(loadIcon(""icons/GreenFlag.gif"")));
    }
  }
  public void append(LoggingEvent event) {
    String text = this.layout.format(event);
    String trace="""";
    // Print Stacktrace
    // Quick Hack maybe there is a better/faster way?
    if (event.throwable!=null) {
      event.throwable.printStackTrace(tp);
      for (int i=0; i< sw.getBuffer().length(); i++) {
	if (sw.getBuffer().charAt(i)=='\t')
	  sw.getBuffer().replace(i,i+1,""        "");
      }
      trace = sw.toString();
      sw.getBuffer().delete(0,sw.getBuffer().length());
    }
    try {
      if (fancy) {
	textpane.setEditable(true);
	textpane.insertIcon((ImageIcon)icons.get(event.priority));
	textpane.setEditable(false);
      }
      doc.insertString(doc.getLength(),text+trace,
		       (MutableAttributeSet)attributes.get(event.priority));
	}	
    catch (BadLocationException badex) {
      System.err.println(badex);
    }	
    textpane.setCaretPosition(doc.getLength());
  }
  public
  JTextPane getTextPane() {
    return textpane;
  }
  public String getLabel() {
    return label;
  }
  public
  String[] getOptionStrings() {
    return new String[] {LABEL_OPTION, COLOR_OPTION_FATAL, COLOR_OPTION_ERROR,
			   COLOR_OPTION_WARN, COLOR_OPTION_INFO, COLOR_OPTION_DEBUG,
			   COLOR_OPTION_BACKGROUND, FANCY_OPTION,
			   FONT_NAME_OPTION, FONT_SIZE_OPTION};
  }
  private
  Color parseColor (String v) {
    StringTokenizer st = new StringTokenizer(v,"","");
    int val[] = {255,255,255,255};
    int i=0;
    while (st.hasMoreTokens()) {
      val[i]=Integer.parseInt(st.nextToken());
      i++;
    }
    return new Color(val[0],val[1],val[2],val[3]);
  }
  public
  void setLayout(Layout layout) {
    this.layout=layout;
  }
  public
  void setName(String name) {
    this.name = name;
  }
  public
  void setTextPane(JTextPane textpane) {
    this.textpane=textpane;
    textpane.setEditable(false);
    textpane.setBackground(Color.lightGray);
    this.doc=textpane.getStyledDocument();
  }
  private
  void setColor(Priority p, String v) {
    StyleConstants.setForeground(
		      (MutableAttributeSet)attributes.get(p),parseColor(v));	
  }
  private
  void setFontSize(int size) {
    Enumeration e = attributes.elements();
    while (e.hasMoreElements()) {
      StyleConstants.setFontSize((MutableAttributeSet)e.nextElement(),size);
    }
    return;
  }
  private
  void setFontName(String name) {
    Enumeration e = attributes.elements();
    while (e.hasMoreElements()) {
      StyleConstants.setFontFamily((MutableAttributeSet)e.nextElement(),name);
    }
    return;
  }
  public
  void setOption(String option, String value) {
    if (option.equalsIgnoreCase(LABEL_OPTION))
      this.label=value;
    if (option.equalsIgnoreCase(COLOR_OPTION_FATAL))
      setColor(Priority.FATAL,value);
    if (option.equalsIgnoreCase(COLOR_OPTION_ERROR))
      setColor(Priority.ERROR,value);
    if (option.equalsIgnoreCase(COLOR_OPTION_WARN))
      setColor(Priority.WARN,value);
    if (option.equalsIgnoreCase(COLOR_OPTION_INFO))
      setColor(Priority.INFO,value);
    if (option.equalsIgnoreCase(COLOR_OPTION_DEBUG))
      setColor(Priority.DEBUG,value);
    if (option.equalsIgnoreCase(COLOR_OPTION_BACKGROUND))
      textpane.setBackground(parseColor(value));
    if (option.equalsIgnoreCase(FANCY_OPTION))
      fancy = OptionConverter.toBoolean(value, fancy);
    if (option.equalsIgnoreCase(FONT_SIZE_OPTION))
      setFontSize(Integer.parseInt(value));
    if (option.equalsIgnoreCase(FONT_NAME_OPTION))
      setFontName(value);
    return;
  }
  public
  boolean requiresLayout() {
    return true;
  }
} // TextPaneAppender
"
org.apache.log4j.gui.examples.TextPaneAppenderExample,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.gui.examples;
import java.awt.BorderLayout;
import java.awt.event.*;
import javax.swing.*;
import org.apache.log4j.*;
import org.apache.log4j.gui.*;
public class TextPaneAppenderExample implements ActionListener {
    JFrame mainframe;
    ButtonGroup priorities;
    TextPaneAppender tpa;
    Category gui;
    Priority prio[];
    JTabbedPane logview;
    public TextPaneAppenderExample () {
	mainframe = new JFrame(""Testing the TextPaneAppender..."");
	mainframe.setSize(300,300);
	logview = new JTabbedPane();
	createLogger();
	createMenuBar();
	mainframe.setVisible(true);
	mainframe.getContentPane().add(logview);
    }
    public void createLogger() {
	tpa = new TextPaneAppender(new PatternLayout(""%-5p %d [%t]:  %m%n""),""Debug"");
	logview.addTab(""Events ..."",new JScrollPane(tpa.getTextPane()));
	gui = Category.getInstance(this.getClass().getName());
	gui.addAppender(tpa);
    }
    public void createMenuBar() {
	JMenu file = new JMenu(""File"");
	JMenuItem exit = new JMenuItem(""Exit"");
	exit.addActionListener(new ActionListener() {
		public void actionPerformed(ActionEvent ae) {
		    System.exit(0);
		}
	    });
	file.add(exit);
	JMenuBar mb = new JMenuBar();
	mb.add(file);
	JMenu logevent = new JMenu(""LoggingEvents"");
	JMenu selectprio = new JMenu(""Priority"");
	prio = Priority.getAllPossiblePriorities();
	JRadioButtonMenuItem priority[]= new JRadioButtonMenuItem[prio.length];
	priorities = new ButtonGroup();
	for (int i=0; i<prio.length;i++) {
	    if (i==0)
		priority[i] = new JRadioButtonMenuItem(prio[i].toString(),true);
	    else
		priority[i] = new JRadioButtonMenuItem(prio[i].toString());
	    priority[i].setActionCommand(prio[i].toString());
	    selectprio.add(priority[i]);
	    priorities.add(priority[i]);
	}
	logevent.add(selectprio);
	JMenuItem lognow = new JMenuItem(""LogIt!"");
	lognow.addActionListener(this);
	logevent.add(lognow);
	mb.add(logevent);
	mainframe.setJMenuBar(mb);
    }
    public void actionPerformed(ActionEvent ae){
	String logtext = JOptionPane.showInputDialog(""Text to log"");
	if (logtext == null) logtext=""NO Input"";
	int i=0;
	String name = priorities.getSelection().getActionCommand();
	while (!prio[i].toString().equals(name))
	    i=i+1;
	gui.log(prio[i],logtext);
    }
    static public void main(String args[]) {
	TextPaneAppenderExample tpex = new TextPaneAppenderExample();
    }
}
"
org.apache.log4j.helpers.AbsoluteTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.util.Date;
import java.util.Calendar;
import java.util.TimeZone;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
/**
   Formats a {@link Date} in the format ""HH:mm:ss,SSS"" for example,
   ""15:49:37,459"".
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class AbsoluteTimeDateFormat extends DateFormat {
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.AbsoluteTimeDateFormat} in layouts. Current
     value is <b>ABSOLUTE</b>.  */
  public final static String ABS_TIME_DATE_FORMAT = ""ABSOLUTE"";
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.DateTimeDateFormat} in layouts.  Current
     value is <b>DATE</b>.
  */
  public final static String DATE_AND_TIME_DATE_FORMAT = ""DATE"";
  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.ISO8601DateFormat} in layouts. Current
     value is <b>ISO8601</b>.
  */
  public final static String ISO8601_DATE_FORMAT = ""ISO8601"";
  public
  AbsoluteTimeDateFormat() {
    setCalendar(Calendar.getInstance());
  }
  public
  AbsoluteTimeDateFormat(TimeZone timeZone) {
    setCalendar(Calendar.getInstance(timeZone));
  }
  /**
     Appends to <code>sbuf</code> the time in the format
     ""HH:mm:ss,SSS"" for example, ""15:49:37,459""
     @param date the date to format
     @param sbuf the string buffer to write to
     @param fieldPosition remains untouched
    */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    // We use a previously instantiated Date object to avoid the needless
    // creation of temporary objects. This saves a few micro-secs.
    calendar.setTime(date); 
    int hour = calendar.get(Calendar.HOUR_OF_DAY);
    if(hour < 10) {
      sbuf.append('0');
    }
    sbuf.append(hour);
    sbuf.append(':');
    int mins = calendar.get(Calendar.MINUTE);
    if(mins < 10) {
      sbuf.append('0');
    }
    sbuf.append(mins);
    sbuf.append(':');
    int secs = calendar.get(Calendar.SECOND);
    if(secs < 10) {
      sbuf.append('0');
    }
    sbuf.append(secs);
    sbuf.append(',');
    int millis = calendar.get(Calendar.MILLISECOND);
    if(millis < 100) 
      sbuf.append('0');
    if(millis < 10) 
      sbuf.append('0');
    sbuf.append(millis);
    return sbuf;
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.AppenderAttachableImpl,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Appender;
import java.util.Vector;
import java.util.Enumeration;
/**
   A straightforward implementation of the {@link AppenderAttachable}
   interface.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public class AppenderAttachableImpl implements AppenderAttachable {
  /** Array of appenders. */
  protected Vector  appenderList;
  /**
     Attach an appender.
   */
  public
  void addAppender(Appender newAppender) {
    // Null values for newAppender parameter are strictly forbidden.
    if(newAppender == null)
      return;
    if(appenderList == null) {
      appenderList = new Vector(1);
    }
    if(!appenderList.contains(newAppender))
      appenderList.addElement(newAppender);
  }
  /**
     Call the <code>doAppend</code> method on all attached appenders.  */
  public
  int appendLoopOnAppenders(LoggingEvent event) {
    int size = 0;
    Appender appender;
    if(appenderList != null) {
      size = appenderList.size();
      for(int i = 0; i < size; i++) {
	appender = (Appender) appenderList.elementAt(i);
	appender.doAppend(event);
      }
    }    
    return size;
  }
  /**
     Get all attached appenders as an Enumeration. If there are no
     attached appenders <code>null</code> is returned.
     @return Enumeration An enumeration of attached appenders.
   */
  public
  Enumeration getAllAppenders() {
    if(appenderList == null)
      return null;
    else 
      return appenderList.elements();    
  }
  /**
     Look for an attached appender named as <code>name</code>.
     <p>Return the appender with that name if in the list. Return null
     otherwise.  
   */
  public
  Appender getAppender(String name) {
     if(appenderList == null || name == null)
      return null;
     int size = appenderList.size();
     Appender appender;
     for(int i = 0; i < size; i++) {
       appender = (Appender) appenderList.elementAt(i);
       if(name.equals(appender.getName()))
	  return appender;
     }
     return null;    
  }
  /**
     Remove all previously attached appenders.
  */
  public
  void removeAllAppenders() {
    if(appenderList != null) {
      int len = appenderList.size();      
      for(int i = 0; i < len; i++) {
	Appender a = (Appender) appenderList.elementAt(i);
	a.close();
      }
      appenderList.removeAllElements();
      appenderList = null;      
    }
  }
  /**
     Remove the appender passed as parameter form the list of attached
     appenders.  */
  public
  void removeAppender(Appender appender) {
    if(appender == null || appenderList == null) 
      return;
    appenderList.removeElement(appender);    
  }
 /**
    Remove the appender with the name passed as parameter form the
    list of appenders.  
  */
  public
  void removeAppender(String name) {
    if(name == null || appenderList == null) return;
    int size = appenderList.size();
    for(int i = 0; i < size; i++) {
      if(name.equals(((Appender)appenderList.elementAt(i)).getName())) {
	 appenderList.removeElementAt(i);
	 break;
      }
    }
  }
}
"
org.apache.log4j.helpers.BoundedFIFO,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   <code>BoundedFIFO</code> serves as the bounded first-in-first-out
   buffer heavily used by the {@link org.apache.log4j.AsyncAppender}.
   @author Ceki G&uuml;lc&uuml; 
   @since version 0.9.1 */
public class BoundedFIFO {
  LoggingEvent[] buf;
  int numElements = 0;
  int first = 0;
  int next = 0;
  int maxSize;
  /**
     Instantiate a new BoundedFIFO with a maximum size passed as argument.
   */
  public
  BoundedFIFO(int maxSize) {
   if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    buf = new LoggingEvent[maxSize];
  }
  /**
     Get the first element in the buffer. Returns <code>null</code> if
     there are no elements in the buffer.  */
  public
  LoggingEvent get() {
    if(numElements == 0) 
      return null;
    LoggingEvent r = buf[first];
    if(++first == maxSize) {
	first = 0;
    }
    numElements--;    
    return r;    
  }
  /**
     Place a {@link LoggingEvent} in the buffer. If the buffer is full
     then the event is silently dropped. It is the caller's
     responsability to make sure that the buffer has free space.
  */
  public 
  void put(LoggingEvent o) {
    if(numElements != maxSize) {      
      buf[next] = o;    
      if(++next == maxSize) {
	next = 0;
      }
      numElements++;
    }
  }
  /**
     Get the maximum size of the buffer.
   */
  public 
  int getMaxSize() {
    return maxSize;
  }
  /**
     Return <code>true</code> if the buffer is full, i.e. of the
     number of elements in the buffer equals the buffer size. */
  public 
  boolean isFull() {
    return numElements == maxSize;
  }
  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElements;
  } 
  /**
     Returns <code>true</code> if there is just one element in the
     buffer. In other words, if there were no elements before the last
     {@link #put} operation completed.  */
  public
  boolean wasEmpty() {
    return numElements == 1;
  }
  /**
      Returns <code>true</code> if there the number of elements in the
      buffer plus 1 equals the maximum buffer size, returns
      <code>false</code> otherwise. */
  public
  boolean wasFull() {
    return (numElements+1 == maxSize);
  }
}
"
org.apache.log4j.helpers.CountingQuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.File;
import java.io.Writer;
import java.io.FileWriter;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
/**
   Counts the number of bytes written.
   @author Heinz Richter, heinz.richter@frogdot.com
   @since 0.8.1
   */
public class CountingQuietWriter extends QuietWriter {
  protected long count;
  public
  CountingQuietWriter(Writer writer, ErrorHandler eh) {
    super(writer, eh);
  }
  public
  void write(String string) {
    try {
      out.write(string);
      count += string.length();
    }
    catch(IOException e) {
      errorHandler.error(""Write failure."", e, ErrorCode.WRITE_FAILURE);
    }
  }
  public
  long getCount() {
    return count;
  }
  public
  void setCount(long count) {
    this.count = count;
  }
}
"
org.apache.log4j.helpers.CyclicBuffer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   CyclicBuffer is used by other appenders to hold {@link LoggingEvent
   LoggingEvents} for immediate or differed display.
   <p>This buffer gives read access to any element in the buffer not
   just the first or last element.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0
 */
public class CyclicBuffer {
  LoggingEvent[] ea;
  int first; 
  int last; 
  int numElems;
  int maxSize;
  /**
     Instantiate a new CyclicBuffer of at most <code>maxSize</code> events.
     The <code>maxSize</code> argument must a positive integer.
     @param maxSize The maximum number of elements in the buffer.
  */
  public CyclicBuffer(int maxSize) throws IllegalArgumentException {
    if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    ea = new LoggingEvent[maxSize];
    first = 0;
    last = 0;
    numElems = 0;
  }
  /**
     Add an <code>event</code> as the last event in the buffer.
   */
  public
  void add(LoggingEvent event) {    
    ea[last] = event;    
    if(++last == maxSize)
      last = 0;
    if(numElems < maxSize)
      numElems++;
    else if(++first == maxSize)
      first = 0;
  }
  /**
     Get the <i>i</i>th oldest event currently in the buffer. If
     <em>i</em> is outside the range 0 to the number of elements
     currently in the buffer, then <code>null</code> is returned.
  */
  public
  LoggingEvent get(int i) {
    if(i < 0 || i >= numElems)
      return null;
    return ea[(first + i) % maxSize];
  }
  public 
  int getMaxSize() {
    return maxSize;
  }
  public
  LoggingEvent get() {
    LoggingEvent r = null;
    if(numElems > 0) {
      numElems--;
      r = ea[first];
      ea[first] = null;
      if(++first == maxSize)
	first = 0;
    } 
    return r;
  }
  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElems;
  } 
  /**
     Resize the cyclic buffer to <code>newSize</code>.
     @throws IllegalArgumentException if <code>newSize</code> is negative.
   */
  public 
  void resize(int newSize) {
    if(newSize < 0) {
      throw new IllegalArgumentException(""Negative array size [""+newSize+
					 ""] not allowed."");
    }
    if(newSize == numElems)
      return; // nothing to do
    LoggingEvent[] temp = new  LoggingEvent[newSize];
    int loopLen = newSize < numElems ? newSize : numElems;
    for(int i = 0; i < loopLen; i++) {
      temp[i] = ea[first];
      ea[first] = null;
      if(++first == numElems) 
	first = 0;
    }
    ea = temp;
    first = 0;
    numElems = loopLen;
    maxSize = newSize;
  }
}
"
org.apache.log4j.helpers.DateLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.RelativeTimeDateFormat;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.helpers.DateTimeDateFormat;
import org.apache.log4j.helpers.ISO8601DateFormat;
import org.apache.log4j.spi.LoggingEvent;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.text.FieldPosition;
/**
   This abstract layout takes care of all the date related options and
   formatting work.
   @author Ceki G&uuml;lc&uuml;
 */
abstract public class DateLayout extends Layout {
  /**
     String constant designating no time information. Current value of
     this constant is <b>NULL</b>.
  */
  public final static String NULL_DATE_FORMAT = ""NULL"";
  /**
     String constant designating relative time. Current value of
     this constant is <b>RELATIVE</b>.
   */
  public final static String RELATIVE_TIME_DATE_FORMAT = ""RELATIVE"";
  protected FieldPosition pos = new FieldPosition(0);
  final static public String DATE_FORMAT_OPTION = ""DateFormat"";
  final static public String TIMEZONE_OPTION = ""TimeZone"";  
  private String timeZoneID;
  private String dateFormatOption;  
  protected DateFormat dateFormat;
  protected Date date = new Date();
  public
  void activateOptions() {
    setDateFormat(dateFormatOption);
    if(timeZoneID != null && dateFormat != null) {
      dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneID));
    }
  }
  public
  String[] getOptionStrings() {
    return new String[] {DATE_FORMAT_OPTION, TIMEZONE_OPTION};
  }
  public
  void  dateFormat(StringBuffer buf, LoggingEvent event) {
    if(dateFormat != null) {
      date.setTime(event.timeStamp);
      dateFormat.format(date, buf, this.pos);
      buf.append(' ');
    }
  }
  /**
     Sets the {@link DateFormat} used to format time and date in the
     zone determined by <code>timeZone</code>.
   */
  public
  void setDateFormat(DateFormat dateFormat, TimeZone timeZone) {
    this.dateFormat = dateFormat;    
    this.dateFormat.setTimeZone(timeZone);
  }
  public
  void setDateFormat(String dateFormatType) {
    setDateFormat(dateFormatType, TimeZone.getDefault());
  }
  /**
     Sets the DateFormat used to format date and time in the time zone
     determined by <code>timeZone</code> parameter. The {@link DateFormat} used
     will depend on the <code>dateFormatType</code>.
     <p>The recognized types are {@link #NULL_DATE_FORMAT}, {@link
     #RELATIVE_TIME_DATE_FORMAT} {@link
     AbsoluteTimeDateFormat#ABS_TIME_DATE_FORMAT}, {@link
     AbsoluteTimeDateFormat#DATE_AND_TIME_DATE_FORMAT} and {@link
     AbsoluteTimeDateFormat#ISO8601_DATE_FORMAT}. If the
     <code>dateFormatType</code> is not one of the above, then the
     argument is assumed to be a date pattern for {@link
     SimpleDateFormat}.
  */
  public
  void setDateFormat(String dateFormatType, TimeZone timeZone) {
    if(dateFormatType == null) {
      this.dateFormat = null;
      return;
    } 
    if(dateFormatType.equalsIgnoreCase(NULL_DATE_FORMAT)) {
      this.dateFormat = null;
    } else if (dateFormatType.equalsIgnoreCase(RELATIVE_TIME_DATE_FORMAT)) {
      this.dateFormat =  new RelativeTimeDateFormat();
    } else if(dateFormatType.equalsIgnoreCase(
                             AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT)) {
      this.dateFormat =  new AbsoluteTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                        AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT)) {
      this.dateFormat =  new DateTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) {
      this.dateFormat =  new ISO8601DateFormat(timeZone);
    } else {
      this.dateFormat = new SimpleDateFormat(dateFormatType);
      this.dateFormat.setTimeZone(timeZone);
    }
  }
  /**
     <p>The DateLayout specific options are:
    <dl>
    <p><dt><b>DateFormat</b>
    <dd>The value of this option should be either an argument to the
    constructor of {@link SimpleDateFormat} or one of the srings
    ""NULL"", ""RELATIVE"", ""ABSOLUTE"", ""DATE"" or ""ISO8601.
    <p>See also the <b>%d</b> conversion specifier of the {@link
    org.apache.log4j.PatternLayout PatternLayout}.
    <p><dt><b>TimeZoneID</b>
    <dd>A time zone ID string in the format expected by the {@link
    TimeZone#getTimeZone} method.
    </dl>
   */
  public
  void setOption(String option, String value) {
    if(option.equalsIgnoreCase(DATE_FORMAT_OPTION)) {
      dateFormatOption = value.toUpperCase();
    } else if(option.equalsIgnoreCase(TIMEZONE_OPTION)) {
      timeZoneID = value;
    }
  }
}
"
org.apache.log4j.helpers.DateTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;
/**
   Formats a {@link Date} in the format ""dd MMM YYYY HH:mm:ss,SSS"" for example,
   ""06 Nov 1994 15:49:37,459"". 
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class DateTimeDateFormat extends AbsoluteTimeDateFormat {
  String[] shortMonths;
  public
  DateTimeDateFormat() {
    super();
    shortMonths = new DateFormatSymbols().getShortMonths();
  }
  public
  DateTimeDateFormat(TimeZone timeZone) {
    this();
    setCalendar(Calendar.getInstance(timeZone));
  }
  /**
     Appends to <code>sbuf</code> the date in the format ""dd MMM YYYY
     HH:mm:ss,SSS"" for example, ""06 Nov 1994 08:49:37,459"".
     @param sbuf the string buffer to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    calendar.setTime(date);      
    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');        
    sbuf.append(shortMonths[calendar.get(Calendar.MONTH)]);
    sbuf.append(' ');    
    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    sbuf.append(' ');
    return super.format(date, sbuf, fieldPosition);
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.FileWatchdog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */
package org.apache.log4j.helpers;
import java.io.File;
import org.apache.log4j.helpers.LogLog;
/**
   Check every now and then that a certain file has not changed. If it
   has, then call the {@link #doOnChange} method.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public abstract class FileWatchdog extends Thread {
  /**
     The default delay between every file modification check, set to 60
     seconds.  */
  static final public long DEFAULT_DELAY = 60000; 
  /**
     The name of the file to observe  for changes.
   */
  protected String filename;
  /**
     The delay to observe between every check. By default set {@link
     #DEFAULT_DELAY}. */
  protected long delay = DEFAULT_DELAY; 
  File file;
  long lastModif = 0; 
  boolean warnedAlready = false;
  protected
  FileWatchdog(String filename) {
    this.filename = filename;
    file = new File(filename);
    setDaemon(true);
    checkAndConfigure();
  }
  /**
     Set the delay to observe between each check of the file changes.
   */
  public
  void setDelay(long delay) {
    this.delay = delay;
  }
  abstract 
  protected 
  void doOnChange();
  protected
  void checkAndConfigure() {
    if(file.exists()) {
      long l = file.lastModified();
      if(l > lastModif) {
	lastModif = l;
	doOnChange();
	warnedAlready = false;
      }
    } else {
      if(!warnedAlready) {
	LogLog.debug(""[""+filename+""] does not exist."");
	warnedAlready = true;
      }
    }
  }
  public
  void run() {    
    while(!interrupted()) {
      try {
	Thread.currentThread().sleep(delay);
      } catch(InterruptedException e) {
	// no interruption expected
      }
      checkAndConfigure();
    }
  }
}
"
org.apache.log4j.helpers.FormattingInfo,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
/**
   FormattingInfo instances contain the information obtained when parsing
   formatting modifiers in conversion modifiers.
   @author <a href=mailto:jim_cakalic@na.biomerieux.com>Jim Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2   
 */
public class FormattingInfo {
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;
  void reset() {
    min = -1;
    max = 0x7FFFFFFF;
    leftAlign = false;      
  }
  void dump() {
    LogLog.debug(""min=""+min+"", max=""+max+"", leftAlign=""+leftAlign);
  }
}
"
org.apache.log4j.helpers.ISO8601DateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;
// Contributors: Arndt Schoenewald <arndt@ibm23093i821.mc.schoenewald.de>
/**
   Formats a {@link Date} in the format ""YYYY-mm-dd HH:mm:ss,SSS"" for example
   ""1999-11-27 15:49:37,459"".
   <p>Refer to the <a
   href=http://www.cl.cam.ac.uk/~mgk25/iso-time.html>summary of the
   International Standard Date and Time Notation</a> for more
   infromation on this format.
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class ISO8601DateFormat extends AbsoluteTimeDateFormat {
  public
  ISO8601DateFormat() {
  }
  public
  ISO8601DateFormat(TimeZone timeZone) {
    super(timeZone);
  }
  /**
     Appends to <code>sbuf</code> the date in the format ""YYYY-mm-dd 
     HH:mm:ss,SSS"" for example, ""1999-11-27 15:49:37,459"".
     @param sbuf the string buffer to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    calendar.setTime(date);      
    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    String month;
    switch(calendar.get(Calendar.MONTH)) {
    case Calendar.JANUARY: month = ""-01-""; break;      
    case Calendar.FEBRUARY: month = ""-02-"";  break;     
    case Calendar.MARCH: month = ""-03-""; break;      
    case Calendar.APRIL: month = ""-04-"";  break;     
    case Calendar.MAY: month = ""-05-""; break;      
    case Calendar.JUNE: month = ""-06-"";  break;     
    case Calendar.JULY: month = ""-07-""; break;      
    case Calendar.AUGUST: month = ""-08-"";  break;     
    case Calendar.SEPTEMBER: month = ""-09-""; break;      
    case Calendar.OCTOBER: month = ""-10-""; break;      
    case Calendar.NOVEMBER: month = ""-11-"";  break;           
    case Calendar.DECEMBER: month = ""-12-"";  break;
    default: month = ""-NA-""; break;
    }
    sbuf.append(month);
    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');    
    return super.format(date, sbuf, fieldPosition);
  }
  /**
    This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.Loader,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.net.URL;
import java.awt.Image;
import java.awt.Toolkit;
/**
 * Load things from a jar file. 
 * 
 * Created: Thu Dec 16 16:11:05 1999 <br>
 *
 * @author Sven Reimers
 */
public class Loader extends java.lang.Object { 
  public static Image getGIF_Image ( String path ) {
    Image img = null;
    try {
      URL url = ClassLoader.getSystemResource(path);
      System.out.println(url);
      img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
    }
    catch (Exception e) {
      System.out.println(""Exception occured: "" + e.getMessage() + 
			 "" - "" + e );
    }
    return (img);
  }
  public static Image getGIF_Image ( URL url ) {
    Image img = null;
    try {
      System.out.println(url);
      img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
    } catch (Exception e) {
      System.out.println(""Exception occured: "" + e.getMessage() + 
			 "" - "" + e );
    }
    return (img);
  }
  public static URL getHTML_Page ( String path ) {
    URL url = null;
    return (url = ClassLoader.getSystemResource(path));
  }    
}
"
org.apache.log4j.helpers.LogLog,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
/**
   This class used to output log statements from within the log4j package.
   <p>Log4j components cannot make log4j logging calls. However, it is
   sometimes useful for the user to learn about what log4j is
   doing. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable.
   <p>All log4j internal debug calls go to <code>System.out</code>
   where as internal error messages are sent to
   <code>System.err</code>. All internal messages are prepended with
   the string ""log4j: "".
   @since 0.8.2
   @author Ceki G&uuml;lc&uuml;
*/
public class LogLog {
  /**
     Defining this value makes configurators print debug statements to
     <code>System.out</code> while parsing configuration files.
    <p> The value of this string is <b>log4j.configDebug</b>.
    <p>Note that the search for all option names is case sensitive.
  */
  public static final String CONFIG_DEBUG_KEY=""log4j.configDebug"";
  protected static boolean configDebugEnabled = false;  
  private static final String PREFIX = ""log4j: "";
  private static final String ERR_PREFIX = ""log4j:ERROR "";
  static {
    try {
      String key = System.getProperty(CONFIG_DEBUG_KEY);
      if(key != null) 
	configDebugEnabled = OptionConverter.toBoolean(key, true);
    }
    catch(SecurityException e) {
      System.err.println(PREFIX+""Could not read system property \""""+
			 CONFIG_DEBUG_KEY+""\""."");
    }
  }
  /**
     Allows to enable/disable log4j internal logging.
   */
  static
  public
  void setInternalDebugging(boolean enabled) {
    configDebugEnabled = enabled;
  }
  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg) {
    if(configDebugEnabled) {
      System.out.println(PREFIX+msg);
    }
  }
  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg, Throwable t) {
    if(configDebugEnabled) {
      System.out.println(PREFIX+msg);
      if(t != null)
	t.printStackTrace(System.out);
    }
  }
  /**
     This method is used to output log4j internal error
     statements. There is no way for disabling error statements.
     Output goes to <code>System.err</code>.
  */
  public
  static
  void error(String msg) {
    System.err.println(ERR_PREFIX+msg);
  }  
  /**
     This method is used to output log4j internal error
     statements. There is no way for disabling error statements.
     Output goes to <code>System.err</code>.  
  */
  public
  static
  void error(String msg, Throwable t) {
    System.err.println(ERR_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
}
"
org.apache.log4j.helpers.NullEnumeration,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.util.Enumeration;
import java.util.NoSuchElementException;
/**
  An always-empty Enumerator.
  @author Anders Kristensen
  @since version 1.0
 */
public class NullEnumeration implements Enumeration {
  private static final NullEnumeration instance = new NullEnumeration();
  private
  NullEnumeration() {
  }
  public
  static
  NullEnumeration getInstance() {
    return instance;
  }
  public
  boolean hasMoreElements() {
    return false;
  }
  public
  Object nextElement() {
    throw new NoSuchElementException();
  }
}
"
org.apache.log4j.helpers.OnlyOnceErrorHandler,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import  org.apache.log4j.spi.ErrorHandler;
/**
   The <code>OnlyOnceErrorHandler</code> implements log4j's default
   error handling policy which consists of emitting a message for the
   first error in an appender and ignoring all following errors.
   <p>The error message is printed on <code>System.err</code>. 
   <p>This policy aims at a protecting an otherwise working
   application from being flooded with error messages when logging
   fails.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class OnlyOnceErrorHandler implements ErrorHandler {
  final String WARN_PREFIX = ""log4j warning: "";
  final String ERROR_PREFIX = ""log4j error: "";
  boolean firstTime = true;
  /**
     No options to activate.
  */
  public
  void activateOptions() {
  }
  /**
     Prints the message and the stack trace of the exception on
     <code>System.err</code>.  */
  public
  void error(String message, Exception e, int errorCode) { 
    if(firstTime) {
      LogLog.error(message, e);
      firstTime = false;
    }
  }
  /**
     Returns <code>null</code> as <code>OnlyOnceErrorHandler</code>
     has no options.  */
  public
  String[] getOptionStrings() {
    return null;
  }
  /**
     No options to set.
  */
  public
  void setOption(String key, String value) {
  }
  /**
     Print a the error message passed as parameter on
     <code>System.err</code>.  
  */
  public
  void error(String message) {
    if(firstTime) {
      LogLog.error(message);
      firstTime = false;
    }
  }
}
"
org.apache.log4j.helpers.OptionConverter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.util.Properties;
import java.net.URL;
import org.apache.log4j.Category;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.PropertyConfigurator;
// Contributors:   Avy Sharell (sharell@online.fr)
/**
   A convinience class to convert property values to specific types.
   @author Ceki G&uuml;lc&uuml;
   @author Avy Sharell
*/	
public class OptionConverter {
  static String DELIM_START = ""${"";
  static char   DELIM_STOP  = '}';
  static int DELIM_START_LEN = 2;
  static int DELIM_STOP_LEN  = 1;
  static StringBuffer sbuf = new StringBuffer();
  /** OptionConverter is a static class. */
  private OptionConverter() {}
  public
  static
  String[] concatanateArrays(String[] l, String[] r) {
    int len = l.length + r.length;
    String[] a = new String[len];
    System.arraycopy(l, 0, a, 0, l.length);
    System.arraycopy(r, 0, a, l.length, r.length);
    return a;
  }
  public
  static
  String convertSpecialChars(String s) {
    char c;
    int len = s.length();
    StringBuffer sbuf = new StringBuffer(len);
    int i = 0;
    while(i < len) {
      c = s.charAt(i++);
      if (c == '\\') {
	c =  s.charAt(i++);
	if(c == 'n')      c = '\n';
	else if(c == 'r') c = '\r';
	else if(c == 't') c = '\t';
	else if(c == 'f') c = '\f';
	else if(c == '\b') c = '\b';					
	else if(c == '\""') c = '\""';				
	else if(c == '\'') c = '\'';			
	else if(c == '\\') c = '\\';			
      }
      sbuf.append(c);      
    }
    return sbuf.toString();
  }
  public
  static
  Object instantiateByKey(Properties props, String key, Class superClass,
				Object defaultValue) {
    // Get the value of the property in string form
    String className = props.getProperty(key);
    if(className == null) {
      LogLog.error(""Could not find value for key "" + key);
      return defaultValue;
    }
    // Trim className to avoid trailing spaces that cause problems.
    return OptionConverter.instantiateByClassName(className.trim(), superClass,
						  defaultValue);
  }
  /**
     If <code>value</code> is ""true"", then <code>true</code> is
     returned. If <code>value</code> is ""false"", then
     <code>true</code> is returned. Otherwise, <code>default</code> is
     returned.
     <p>Case of value is unimportant.  */
  public
  static
  boolean toBoolean(String value, boolean dEfault) {
    if(value == null)
      return dEfault;
    String trimmedVal = value.trim();
    if(""true"".equalsIgnoreCase(trimmedVal)) 
      return true;
    if(""false"".equalsIgnoreCase(trimmedVal))
      return false;
    return dEfault;
  }
  public
  static
  int toInt(String value, int dEfault) {
    if(value != null) {
      String s = value.trim();
      try {
	return Integer.valueOf(s).intValue();
      }
      catch (NumberFormatException e) {
	 LogLog.error(""["" + s + ""] is not in proper int form."");
	e.printStackTrace();
      }
    }
    return dEfault;
  }
  public
  static
  long toFileSize(String value, long dEfault) {
    if(value == null)
      return dEfault;
    String s = value.trim().toUpperCase();
    long multiplier = 1;
    int index;
    if((index = s.indexOf(""KB"")) != -1) {      
      multiplier = 1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""MB"")) != -1) {
      multiplier = 1024*1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""GB"")) != -1) {
      multiplier = 1024*1024*1024;
      s = s.substring(0, index);
    }    
    if(s != null) {
      try {
	return Long.valueOf(s).longValue() * multiplier;
      }
      catch (NumberFormatException e) {
	LogLog.error(""["" + s + ""] is not in proper int form."");
	LogLog.error(""["" + value + ""] not in expected format."", e);
      }
    }
    return dEfault;
  }
  /**
     Find the value corresponding to <code>key</code> in
     <code>props</code>. Then perform variable substitution on the
     found value.
 */
  public
  static
  String findAndSubst(String key, Properties props) {
    String value = props.getProperty(key);
    if(value == null) 
      return null;      
    try {
      return substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.error(""Bad option value [""+value+""]."", e);
      return value;
    }    
  }
  /**
     Instantiate an object given a class name. Check that the
     <code>className</code> is a subclass of <code>superClass</code>.
   */
  public
  static
  Object instantiateByClassName(String className, Class superClass,
				Object defaultValue) {
    if(className != null) {
      try {
	Class classObj = Class.forName(className);
	if(!superClass.isAssignableFrom(classObj)) 
	  LogLog.error(""A \""""+className+""\"" object is not assignable to a \""""+
		       superClass.getName() + ""\"" object."");
	return classObj.newInstance();
      }
      catch (Exception e) {
	LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      }
    }
    return defaultValue;    
  }
  /**
     Perform variable substitution in string <code>val</code> from the
     values of keys found in the system propeties.
     <p>The variable substitution delimeters are <b>${</b> and <b>}</b>.
     <p>For example, if the system properties contains ""key=value"", then
     the call
     <pre>
     String s = OptionConverter.substituteVars(""Value of key is ${key}."");
     </pre>
     will set the variable <code>s</code> to ""Value of key is value."".
     If no value could be found for the specified key, then the
     <code>props</code> parameter is searched, if the value could not
     be found there, then substitution defaults to the empty string.
     <p>For example, if system propeties contains no value for the key
     ""inexistentKey"", then the call
     <pre>
     String s = OptionConverter.subsVars(""Value of inexistentKey is [${inexistentKey}]"");
     </pre>
     will set <code>s</code> to ""Value of inexistentKey is []""     
     <p>An {@link java.lang.IllegalArgumentException} is thrown if
     <code>val</code> contains a start delimeter ""${"" which is not
     balanced by a stop delimeter ""}"". </p>
     <p><b>Author</b> Avy Sharell</a></p>
     @param val The string on which variable substitution is performed.
     @throws IllegalArgumentException if <code>val</code> is malformed.
  */
  public static
  String substVars(String val, Properties props) throws
                        IllegalArgumentException {
    sbuf.setLength(0);
    int i = 0;
    int j, k;
    while(true) {
      j=val.indexOf(DELIM_START, i);
      if(j == -1) {
	if(i==0)
	  return val;
	else {
	  sbuf.append(val.substring(i, val.length()));
	  return sbuf.toString();
	}
      }
      else {
	sbuf.append(val.substring(i, j));
	k = val.indexOf(DELIM_STOP, j);
	if(k == -1) {
	  throw new IllegalArgumentException('""'+val+
		      ""\"" has no closing brace. Opening brace at position "" + j 
					     + '.');
	}
	else {
	  j += DELIM_START_LEN;
	  String key = val.substring(j, k);
	  // first try in System properties
	  String replacement = System.getProperty(key);
	  // then try props parameter
	  if(replacement == null && props != null) {
	    replacement =  props.getProperty(key);
	  }
	  if(replacement != null) 
	    sbuf.append(replacement);
	  i = k + DELIM_STOP_LEN;	    
	}
      }
    }
  }
  /**
     Configure log4j given a URL. 
     <p> The URL format is important. 
     <p>It's reference part is taken as the class name of the
     configurator class. For example if you invoke your application
     using the command line <pre> java
     -Dlog4j.configuration=file:/temp/myconfig.xyz#com.myCompany.myConfigurator
     </pre>
     then the log4j will be configured by a new instance of
     <code>com.myCompany.myConfigurator</code> using the file referenced
     by <code>file:/temp/myconfig.xyz</code>.
     <p>If the URL has no reference part, then the {@link
     PropertyConfigurator} will parse the URL. However, if the URL
     ends with a "".xml"" extension then the {@link DOMConfigurator} will
     be used to parse the URL.
     @since 1.0 */
  static
  public
  void selectAndConfigure(URL url) {
    String clazz = url.getRef();
    Configurator configurator = null;
    if(clazz != null) {
      LogLog.debug(""Preferred configurator class: "" + clazz);
      configurator = (Configurator) instantiateByClassName(clazz, Configurator.class,
							   null);
      if(configurator == null) {
	LogLog.error(""Could not instantiate configurator [""+clazz+""]."");
	return;
      }
    } else {
      String filename = url.getFile();
      if(filename != null && filename.endsWith("".xml"")) {
	configurator = new DOMConfigurator();
      } else {
	configurator = new PropertyConfigurator();
      }
    }
    configurator.doConfigure(url, Category.defaultHierarchy);
  }
}
"
org.apache.log4j.helpers.PatternConverter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.spi.LoggingEvent;
/**
   <p>PatternConverter is an abtract class that provides the
   formatting functionality that derived classes need.
   <p>Conversion specifiers in a conversion patterns are parsed to
   individual PatternConverters. Each of which is responsible for
   converting a logging event in a converter specific manner.
   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.2
 */
public abstract class PatternConverter {
  public PatternConverter next;
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;
  protected
  PatternConverter() {  }
  protected
  PatternConverter(FormattingInfo fi) {
    min = fi.min;
    max = fi.max;
    leftAlign = fi.leftAlign;
  }
  /**
     Derived pattern converters must override this method in order to
     convert conversion specifiers in the correct way.
  */
  abstract
  protected
  String convert(LoggingEvent event);
  /**
     A template method for formatting in a converter specific way.
   */
  public
  void format(StringBuffer sbuf, LoggingEvent e) {
    String s = convert(e);
    if(s == null) {
      if(0 < min)
	spacePad(sbuf, min);
      return;
    }
    int len = s.length();
    if(len > max)
      sbuf.append(s.substring(len-max));
    else if(len < min) {
      if(leftAlign) {	
	sbuf.append(s);
	spacePad(sbuf, min-len);
      }
      else {
	spacePad(sbuf, min-len);
	sbuf.append(s);
      }
    }
    else
      sbuf.append(s);
  }	
  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32 spaces
  /**
     Fast space padding method.
  */
  public
  void spacePad(StringBuffer sbuf, int length) {
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org.apache.log4j.helpers.PatternParser,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.Layout;
import org.apache.log4j.NDC;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
// Contributors:   Nelson Minar <(nelson@monkey.org>
//                 Igor E. Poteryaev <jah@mail.ru>  
/**
   Most of the work of the {@link org.apache.log4j.PatternLayout} class
   is delegated to the PatternParser class.
   <p>It is this class that parses conversion patterns and creates
   a chained list of {@link OptionConverter OptionConverters}.
   @author <a href=mailto:""cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen       
   @since 0.8.2
*/
public class PatternParser {
  private static final char ESCAPE_CHAR = '%';
  private static final int LITERAL_STATE = 0;
  private static final int CONVERTER_STATE = 1;
  private static final int MINUS_STATE = 2;
  private static final int DOT_STATE = 3;
  private static final int MIN_STATE = 4;
  private static final int MAX_STATE = 5;
  static final int FULL_LOCATION_CONVERTER = 1000;
  static final int METHOD_LOCATION_CONVERTER = 1001;
  static final int CLASS_LOCATION_CONVERTER = 1002;
  static final int LINE_LOCATION_CONVERTER = 1003;
  static final int FILE_LOCATION_CONVERTER = 1004;    
  static final int RELATIVE_TIME_CONVERTER = 2000;
  static final int THREAD_CONVERTER = 2001;
  static final int PRIORITY_CONVERTER = 2002;
  static final int NDC_CONVERTER = 2003;
  static final int MESSAGE_CONVERTER = 2004;
  int state;
  protected StringBuffer currentLiteral = new StringBuffer(32);
  protected int patternLength;
  protected int i;
  PatternConverter head;
  PatternConverter tail;
  protected FormattingInfo formattingInfo = new FormattingInfo();
  protected String pattern;
  public
  PatternParser(String pattern) {
    this.pattern = pattern;
    patternLength =  pattern.length();    
    state = LITERAL_STATE;
  }
  private
  void  addToList(PatternConverter pc) {
    if(head == null) {
      head = tail = pc;
    } else {
      tail.next = pc;
      tail = pc;    
    }
  }
  private
  String extractOption() {
    if((i < patternLength) && (pattern.charAt(i) == '{')) {
      int end = pattern.indexOf('}', i);	
      if (end > i) {
	String r = pattern.substring(i + 1, end);
	i = end+1;
	return r;
      }
    }
    return null;
  }
  /**
     The option is expected to be in decimal and positive. In case of
     error, zero is returned.  */
  private
  int extractPrecisionOption() {
    String opt = extractOption();
    int r = 0;
    if(opt != null) {
      try {
	r = Integer.parseInt(opt);
	if(r <= 0) {
	    LogLog.error(
	        ""Precision option ("" + opt + "") isn't a positive integer."");
	    r = 0;
	}
      }      
      catch (NumberFormatException e) {
	LogLog.error(""Category option \""""+opt+""\"" not a decimal integer."", e);
      }      
    }
    return r;    
  }
  public 
  PatternConverter parse() {
    char c;
    i = 0;
    while(i < patternLength) {
      c = pattern.charAt(i++);
      switch(state) {
      case LITERAL_STATE: 
        // In literal state, the last char is always a literal.
        if(i == patternLength) {
          currentLiteral.append(c);
          continue;
        }
        if(c == ESCAPE_CHAR) {      
          // peek at the next char. 
          switch(pattern.charAt(i)) {
          case ESCAPE_CHAR:
            currentLiteral.append(c);
            i++; // move pointer
            break;
          case 'n':
            currentLiteral.append(Layout.LINE_SEP);
            i++; // move pointer
            break;
          default:
            if(currentLiteral.length() != 0) {
              addToList(new LiteralPatternConverter(
                                                  currentLiteral.toString()));
              //LogLog.debug(""Parsed LITERAL converter: \"""" 
              //           +currentLiteral+""\""."");
            }
            currentLiteral.setLength(0); 
            currentLiteral.append(c); // append %
            state = CONVERTER_STATE;
            formattingInfo.reset();
          }
        }
        else {
          currentLiteral.append(c);
        }
        break;
      case CONVERTER_STATE:
	currentLiteral.append(c);
	switch(c) {
	case '-':
	  formattingInfo.leftAlign = true;
	  break;
	case '.':
	  state = DOT_STATE;
	  break;
	default:
	  if(c >= '0' && c <= '9') {
	    formattingInfo.min = c - '0';
	    state = MIN_STATE;
	  }
	  else 
	    finalizeConverter(c);	    
	} // switch
	break;
      case MIN_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.min = formattingInfo.min*10 + (c - '0');
	else if(c == '.')
	  state = DOT_STATE;
	else {
	  finalizeConverter(c);
	}
	break;
      case DOT_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') {
	  formattingInfo.max = c - '0';
	   state = MAX_STATE;
	}
	else {
	  LogLog.error(""Error occured in position ""+i
		     +"".\n Was expecting digit, instead got char \""""+c+""\""."");
	  state = LITERAL_STATE;
	}
	break;
      case MAX_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.max = formattingInfo.max*10 + (c - '0');
	else {
	  finalizeConverter(c);
	  state = LITERAL_STATE;
	}
	break;
      } // switch
    } // while
    if(currentLiteral.length() != 0) {
      addToList(new LiteralPatternConverter(currentLiteral.toString()));
      //LogLog.debug(""Parsed LITERAL converter: \""""+currentLiteral+""\""."");
    }
    return head;
  }
  protected
  void finalizeConverter(char c) {
    PatternConverter pc = null;
    switch(c) {
    case 'c':
      pc = new CategoryPatternConverter(formattingInfo,
					extractPrecisionOption());	
      //LogLog.debug(""CATEGORY converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;     
    case 'C':
      pc = new ClassNamePatternConverter(formattingInfo,
					 extractPrecisionOption());
      //LogLog.debug(""CLASS_NAME converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'd':
      String dateFormatStr = AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT;
      DateFormat df;
      String dOpt = extractOption();
      if(dOpt != null)
	dateFormatStr = dOpt;
      if(dateFormatStr.equalsIgnoreCase(
                                    AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) 
	df = new  ISO8601DateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                                   AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT))
	df = new AbsoluteTimeDateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT))
	df = new DateTimeDateFormat();
      else {
	try {
	  df = new SimpleDateFormat(dateFormatStr);
	}
	catch (IllegalArgumentException e) {
	  LogLog.error(""Could not instantiate SimpleDateFormat with "" +
		       dateFormatStr, e);
	  df = (DateFormat) OptionConverter.instantiateByClassName(
			           ""org.apache.log4j.helpers.ISO8601DateFormat"",
				   DateFormat.class, null);
	}	
      }
      pc = new DatePatternConverter(formattingInfo, df);
      //LogLog.debug(""DATE converter {""+dateFormatStr+""}."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'F':
      pc = new LocationPatternConverter(formattingInfo,
					FILE_LOCATION_CONVERTER);
      //LogLog.debug(""File name converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'l':
      pc = new LocationPatternConverter(formattingInfo,
					FULL_LOCATION_CONVERTER);
      //LogLog.debug(""Location converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'L':
      pc = new LocationPatternConverter(formattingInfo,
					LINE_LOCATION_CONVERTER);
      //LogLog.debug(""LINE NUMBER converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'm':
      pc = new BasicPatternConverter(formattingInfo, MESSAGE_CONVERTER);
      //LogLog.debug(""MESSAGE converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'M':
      pc = new LocationPatternConverter(formattingInfo,
					METHOD_LOCATION_CONVERTER);
      //LogLog.debug(""METHOD converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'p':
      pc = new BasicPatternConverter(formattingInfo, PRIORITY_CONVERTER);
      //LogLog.debug(""PRIORITY converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'r':
      pc = new BasicPatternConverter(formattingInfo, 
					 RELATIVE_TIME_CONVERTER);
      //LogLog.debug(""RELATIVE time converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 't':
      pc = new BasicPatternConverter(formattingInfo, THREAD_CONVERTER);
      //LogLog.debug(""THREAD converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
      /*case 'u':
      if(i < patternLength) {
	char cNext = pattern.charAt(i);
	if(cNext >= '0' && cNext <= '9') {
	  pc = new UserFieldPatternConverter(formattingInfo, cNext - '0');
	  LogLog.debug(""USER converter [""+cNext+""]."");
	  formattingInfo.dump();      
	  currentLiteral.setLength(0);
	  i++;
	}
	else 
	  LogLog.error(""Unexpected char "" +cNext+"" at position ""+i);
      }
      break;*/
    case 'x':
      pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);
      //LogLog.debug(""NDC converter."");      
      currentLiteral.setLength(0);
      break;
    default:
      LogLog.error(""Unexpected char "" +c+"" at position ""+i);
      pc = new LiteralPatternConverter(currentLiteral.toString());
      currentLiteral.setLength(0);
    }
    addConverter(pc);
  }
  protected
  void addConverter(PatternConverter pc) {
    currentLiteral.setLength(0);
    // Add the pattern converter to the list.
    addToList(pc);
    // Next pattern is assumed to be a literal.
    state = LITERAL_STATE;
    // Reset formatting info
    formattingInfo.reset();
  }
  // ---------------------------------------------------------------------
  //                      PatternConverters
  // ---------------------------------------------------------------------
  private static class BasicPatternConverter extends PatternConverter {
    int type;
    BasicPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);     
      this.type = type;
    }
    public
    String convert(LoggingEvent event) {
      switch(type) {
      case RELATIVE_TIME_CONVERTER: 
	return (Long.toString(event.timeStamp - LoggingEvent.getStartTime()));
      case THREAD_CONVERTER:
	return event.getThreadName();
      case PRIORITY_CONVERTER:
	return event.priority.toString();
      case NDC_CONVERTER:  
	return event.getNDC();
      case MESSAGE_CONVERTER: {
	return event.message;
      }
      default: return null;
      }
    }
  }
  private static class LiteralPatternConverter extends PatternConverter {
    private String literal;
    LiteralPatternConverter(String value) {
      literal = value;
    }
    public
    final
    void format(StringBuffer sbuf, LoggingEvent event) {
      sbuf.append(literal);
    }
    public    
    String convert(LoggingEvent event) {
      return literal;
    }
  }
  private static class DatePatternConverter extends PatternConverter {
    private DateFormat df;
    private Date date;
    DatePatternConverter(FormattingInfo formattingInfo, DateFormat df) {
      super(formattingInfo);
      date = new Date();
      this.df = df;      
    }
    public
    String convert(LoggingEvent event) {
      date.setTime(System.currentTimeMillis());
      return df.format(date);
    }
  }
  private class LocationPatternConverter extends PatternConverter {
    int type;
    LocationPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }
    public
    String convert(LoggingEvent event) {
      event.setLocationInformation();
      switch(type) {
      case FULL_LOCATION_CONVERTER: 
	return event.locationInfo.fullInfo;
      case METHOD_LOCATION_CONVERTER: 
	return event.locationInfo.getMethodName();
      case LINE_LOCATION_CONVERTER: 
	return event.locationInfo.getLineNumber();
      case FILE_LOCATION_CONVERTER: 
	return event.locationInfo.getFileName();
      default: return null;
      }
    }
  }
  private static abstract class NamedPatternConverter extends PatternConverter {
    int precision;
    NamedPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo);
      this.precision =  precision;      
    }
    abstract
    String getFullyQualifiedName(LoggingEvent event);
    public
    String convert(LoggingEvent event) {
      String n = getFullyQualifiedName(event);
      if(precision <= 0)
	return n;
      else {
	int len = n.length();
	// We substract 1 from 'len' when assigning to 'end' to avoid out of
	// bounds exception in return r.substring(end+1, len). This can happen if
	// precision is 1 and the category name ends with a dot. you 
	int end = len -1 ;
	for(int i = precision; i > 0; i--) {	  
	  end = n.lastIndexOf('.', end-1);
	  if(end == -1)
	    return n;
	}
	return n.substring(end+1, len);
      }      
    }
  }
  private class ClassNamePatternConverter extends NamedPatternConverter {
    ClassNamePatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    String getFullyQualifiedName(LoggingEvent event) {
      event.setLocationInformation();
      return event.locationInfo.getClassName();
    }
  }
  private class CategoryPatternConverter extends NamedPatternConverter {
    CategoryPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    String getFullyQualifiedName(LoggingEvent event) {
      return event.categoryName;
    }
  }  
}
"
org.apache.log4j.helpers.QuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
/**
   QuietWriter does not throw exceptions when things go
   wrong. Instead, it delegates error handling to its {@link ErrorHandler}. 
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.3
*/
public class QuietWriter extends FilterWriter {
  protected ErrorHandler errorHandler;
  public
  QuietWriter(Writer writer, ErrorHandler errorHandler) {
    super(writer);
    setErrorHandler(errorHandler);
  }
  public
  void write(String string) {
    try {
      out.write(string);
    } catch(IOException e) {
      errorHandler.error(""Failed to write [""+string+""]."", e, 
			 ErrorCode.WRITE_FAILURE);
    }
  }
  public
  void flush() {
    try {
      out.flush();
    } catch(IOException e) {
      errorHandler.error(""Failed to flush writer,"", e, 
			 ErrorCode.FLUSH_FAILURE);
    }	
  }
  public
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // This is a programming error on the part of the enclosing appender.
      throw new IllegalArgumentException(""Attempted to set null ErrorHandler."");
    } else { 
      this.errorHandler = eh;
    }
  }
}
"
org.apache.log4j.helpers.RelativeTimeDateFormat,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.helpers;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
/**
   Formats a {@link Date} by printing the number of milliseconds
   elapsed since the start of the application.  This is the fastest
   printing DateFormat in the package.
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class RelativeTimeDateFormat extends DateFormat {
  protected final long startTime;
  public
  RelativeTimeDateFormat() {
    this.startTime = System.currentTimeMillis();
  }
  /**
     Appends to <code>sbuf</code> the number of milliseconds elapsed
     since the start of the application. 
     @since 0.7.5
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    //System.err.println("":""+ date.getTime() + "" - "" + startTime);
    return sbuf.append((date.getTime() - startTime));
  }
  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org.apache.log4j.helpers.SyslogQuietWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
/**
   SyslogQuietWriter extends QuietWriter by prepending the syslog
   priority code before each printed String.
   @since 0.7.3
*/
public class SyslogQuietWriter extends QuietWriter {
  int syslogFacility;
  int priority;
  public
  SyslogQuietWriter(Writer writer, int syslogFacility, ErrorHandler eh) {
    super(writer, eh);
    this.syslogFacility = syslogFacility;
  }
  public
  void setPriority(int priority) {
    this.priority = priority;
  }
  public
  void setSyslogFacility(int syslogFacility) {
    this.syslogFacility = syslogFacility;
  }
  public
  void write(String string) {
    super.write(""<""+(syslogFacility | priority)+"">"" + string);
  }
}
"
org.apache.log4j.helpers.SyslogWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;
import java.io.Writer;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import java.io.IOException;
/**
   SyslogWriter is a wrapper around the java.net.DatagramSocket class
   so that it behaves like a java.io.Writer.
   @since 0.7.3
*/
public class SyslogWriter extends Writer {
  final int SYSLOG_PORT = 514;
  static String syslogHost;
  private InetAddress address;
  private DatagramSocket ds;
  public
  SyslogWriter(String syslogHost) {
    this.syslogHost = syslogHost;
    try {      
      this.address = InetAddress.getByName(syslogHost);
    }
    catch (UnknownHostException e) {
      LogLog.error(""Could not find "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
    try {
      this.ds = new DatagramSocket();
    }
    catch (SocketException e) {
      e.printStackTrace(); 
      LogLog.error(""Could not instantiate DatagramSocket to "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
  }
  public
  void write(char[] buf, int off, int len) throws IOException {
    this.write(new String(buf, off, len));
  }
  public
  void write(String string) throws IOException {
    DatagramPacket packet = new DatagramPacket(string.getBytes(),
					       string.length(), 
					       address, SYSLOG_PORT);
    if(this.ds != null)
      ds.send(packet);
  }
  public
  void flush() {}
  public
  void close() {}
}
"
org.apache.log4j.helpers.TracerPrintWriter,"// WARNING
// WARNING Do not use Log statements in this file.
// WARNING
//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
// Contributors: Nocolai <XNH@crisplant.com>
package org.apache.log4j.helpers;
import java.io.PrintWriter;
/**
   A PrintWriter used to print stack traces of exceptions.
   <p>It's output target is always a QuietWriter.
 */
public class TracerPrintWriter extends PrintWriter {
  protected QuietWriter qWriter;
  public
  TracerPrintWriter(QuietWriter qWriter) {
    super(qWriter);
    this.qWriter = qWriter;
  }
  final
  public
  void setQuietWriter(QuietWriter qWriter) {
    this.qWriter = qWriter;
  }
  public
  void println(Object o) {
    this.qWriter.write(o.toString());
    this.qWriter.write(org.apache.log4j.Layout.LINE_SEP);
  }
  // JDK 1.1.x apprenly uses this form of println while in
  // printStackTrace()
  public
  void println(char[] s) {
    this.println(new String(s));
  }
  public
  void println(String s) {
    this.qWriter.write(s);
    this.qWriter.write(org.apache.log4j.Layout.LINE_SEP);
  }
}
"
org.apache.log4j.net.JMSAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import java.util.Properties;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
/**
   A simple appender based on JMS.
   @author Ceki G&uuml;lc&uuml;
*/
public class JMSAppender extends AppenderSkeleton {
  TopicConnection  topicConnection;
  TopicSession topicSession;
  TopicPublisher  topicPublisher;
  static String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION 
                                                 = ""TopicConnectionFactoryBindingName"";
  static String TOPIC_BINDING_NAME_OPTION = ""TopicBindingName"";
  String topicBindingName;
  String tcfBindingName;
  public 
  JMSAppender() {
  }
  protected
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }
  public
  void activateOptions() {
    TopicConnectionFactory  topicConnectionFactory;
    try {
      Context ctx = new InitialContext();      
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, tcfBindingName);
      topicConnection = topicConnectionFactory.createTopicConnection();
      topicConnection.start();
      topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);
      Topic topic = (Topic) lookup(ctx, topicBindingName);
      topicPublisher = topicSession.createPublisher(topic);
      ctx.close();      
    } catch(Exception e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    }
  }
  protected
  boolean checkEntryConditions() {
    String fail = null;
    if(this.topicConnection == null) {
      fail = ""No TopicConnection"";
    } else if(this.topicSession == null) {
      fail = ""No TopicSession"";
    } else if(this.topicPublisher == null) {
      fail = ""No TopicPublisher"";
    } 
    if(fail != null) {
      errorHandler.error(fail +"" for JMSAppender named [""+name+""]."");      
      return false;
    } else {
      return true;
    }
  }
  public 
  synchronized // avoid concurrent append and close operations
  void close() {
    if(this.closed) 
      return;
    LogLog.debug(""Closing appender [""+name+""]."");
    this.closed = true;    
    try {
      if(topicSession != null) 
	topicSession.close();	
      if(topicConnection != null) 
	topicConnection.close();
    } catch(Exception e) {
      LogLog.error(""Error while closing JMSAppender [""+name+""]."", e);	
    }   
    // Help garbage collection
    topicPublisher = null;
    topicSession = null;
    topicConnection = null;
  }
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }
    try {
      ObjectMessage msg = topicSession.createObjectMessage();
      msg.setObject(event);
      topicPublisher.publish(msg);
    } catch(Exception e) {
      errorHandler.error(""Could not publish message in JMSAppender [""+name+""]."", e, 
			 ErrorCode.GENERIC_FAILURE);
    }
  }
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TOPIC_BINDING_NAME_OPTION, 
			  TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION});
  }
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);    
    if(key.equals(TOPIC_BINDING_NAME_OPTION)) 
      topicBindingName = value;
    else if(key.equals(TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION)) {
      tcfBindingName = value;
    }
  }
  public
  boolean requiresLayout() {
    return false;
  }  
}
"
org.apache.log4j.net.JMSSink,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.or.MessageRenderer;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
/**
   A simple application receiving the logging events sent by a JMSAppender.
   @author Ceki G&uuml;lc&uuml;
*/
public class JMSSink  {
  static public void main(String[] args) {
    if(args.length != 3) {
      usage(""Wrong number of arguments."");     
    }
    String tcfBindingName = args[0];
    String topicBindingName = args[1];
    PropertyConfigurator.configure(args[2]);
    Category.getDefaultHierarchy().addRenderer(Message.class, 
					       new MessageRenderer());
    try {
      Context ctx = new InitialContext();      
      TopicConnectionFactory topicConnectionFactory;
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, 
							       tcfBindingName);
      TopicConnection topicConnection = 
	                        topicConnectionFactory.createTopicConnection(); 
      topicConnection.start();
      TopicSession topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);
      Topic topic = (Topic)ctx.lookup(topicBindingName);
      //TopicSubscriber topicSubscriber = topicSession.createSubscriber(topic);
      TopicSubscriber topicSubscriber = 
           topicSession.createDurableSubscriber(topic, ""x"");
      LoggingEvent event;
      Category remoteCategory;    
      while(true) {
	ObjectMessage msg = (ObjectMessage)topicSubscriber.receive();      
	event = (LoggingEvent) msg.getObject();
	remoteCategory = Category.getInstance(event.categoryName);
	remoteCategory.callAppenders(event);	
	// dump the JMSMessage
	// remoteCategory.debug(msg);
      }
    } catch(Exception e) {
      LogLog.error(""Could not read JMS message."", e);
    }
  }
  protected
  static
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }  
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + JMSSink.class.getName()
            + "" TopicConnectionFactoryBindingName TopicBindingName configFile"");
    System.exit(1);
  }
}
"
org.apache.log4j.net.SimpleSocketServer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
/**
   A simple {@link SocketNode} based server.
   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SimpleSocketServer port configFile
     where <em>port</em> is a part number where the server listens and
     <em>configFile</em> is a configuration file fed to the {@link
     PropertyConfigurator}.
   </pre>
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4 */
public class SimpleSocketServer  {
  static Category cat = Category.getInstance(SimpleSocketServer.class.getName());
  static int port;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	cat.info(""Connected to client at "" + socket.getInetAddress());
	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, 
				  Category.getDefaultHierarchy())).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SimpleSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
org.apache.log4j.net.SMTPAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.TriggeringEventEvaluator;
import java.util.Properties;
import java.util.Date;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.AddressException;
import javax.mail.internet.MimeUtility;
/**
   Send an e-mail when a specific logging event occurs, typically on
   errors or fatal errors.
   <p>The number of logging events delivered in this e-mail depend on
   the value of <b>BufferSize</b> option. The
   <code>SMTPAppender</code> keeps only the last
   <code>BufferSize</code> logging events in its cyclic buffer. This
   keeps memory requirements at a reasonable level while still
   delivering useful application context.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class SMTPAppender extends AppenderSkeleton {
 /**
     A string constant used in naming the <em>To</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>To</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String TO_OPTION = ""To"";
 /**
     A string constant used in naming the <em>From</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>From</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String FROM_OPTION = ""From"";
 /**
     A string constant used in naming the <em>Subject</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>Subject</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String SUBJECT_OPTION = ""Subject"";
 /**
     A string constant used in naming the SMTP host that will be
     contacted to send the e-mail. Current value of this string
     constant is <b>SMTPHost</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String SMTP_HOST_OPTION = ""SMTPHost"";
 /**
     A string constant used in naming the cyclic buffer size option.
     Current value of this string constant is <b>BufferSize</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String BUFFER_SIZE_OPTION = ""BufferSize"";
 /**
     A string constant used in naming the class of the
     TriggeringEventEvaluator that this SMTPApepdner wll use. Current
     value of this string constant is <b>EvaluatorClass</b>.
     <p>Note that all option keys are case sensitive.
  */
  public static final String EVALUATOR_CLASS_OPTION = ""EvaluatorClass"";
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  
     <p>Note that all option keys are case sensitive.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  String to;
  String from;
  String subject;
  String smtpHost;
  int bufferSize = 512;
  CyclicBuffer cb = new CyclicBuffer(bufferSize);
  Session session;
  Message msg;
  boolean locationInfo = false;
  TriggeringEventEvaluator evaluator;
  /**
     The default constructor will instantiate the appedner with a
     {@link TriggeringEventEvaluator} that will tirgger on events with
     priority ERROR or higher.*/
  public
  SMTPAppender() {
    this(new DefaultEvaluator());
  }
  /**
     Use <code>evaluator</code> passed as parameter as the {@link
     TriggeringEventEvaluator} for this SMTPAppender.  */
  public 
  SMTPAppender(TriggeringEventEvaluator evaluator) {
    this.evaluator = evaluator;
  }
  public
  void activateOptions() {
    Properties props = System.getProperties();
    if (smtpHost != null)
      props.put(""mail.smtp.host"", smtpHost);
     session = Session.getDefaultInstance(props, null);
     //session.setDebug(true);
     msg = new MimeMessage(session);
     try {
       if (from != null)
	 msg.setFrom(getAddress(from));
       else
	 msg.setFrom();
       msg.setRecipients(Message.RecipientType.TO, parseAddress(to));
       if(subject != null)
	 msg.setSubject(subject);
     } catch(MessagingException e) {
       LogLog.error(""Could not activate SMTPAppender options."", e );
     }
  }
  /**
     Perform SMTPAppender specific appending actions, mainly adding
     the event to a cyclic buffer and checking if the event triggers
     an e-mail to be sent. */
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }
    event.getThreadName();
    event.getNDC();
    if(locationInfo) {
      event.setLocationInformation();	
    }
    cb.add(event);    
    if(evaluator.isTriggeringEvent(event)) {
      sendBuffer();
    }
  }
 /**
     This method determines if there is a sense in attempting to append.
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.msg == null) {
      errorHandler.error(""Message object not configured."");
      return false;
    }
    if(this.evaluator == null) {
      errorHandler.error(""No TriggeringEventEvaluator is set for appender [""+
			 name+""]."");
      return false;
    }
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+name+""]."");
      return false;
    }
    return true;
  }
  public
  void close() {
    this.closed = true;
  }
  InternetAddress getAddress(String addressStr) {
    try {
      return new InternetAddress(addressStr);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }
 /**
     Retuns the option names for this component in addition in
     addition to the options of its super class {@link
     AppenderSkeleton}.  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TO_OPTION, FROM_OPTION, SUBJECT_OPTION, 
			  SMTP_HOST_OPTION, BUFFER_SIZE_OPTION,  
			  LOCATION_INFO_OPTION });
  }
  InternetAddress[] parseAddress(String addressStr) {
    try {
      return InternetAddress.parse(addressStr, true);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }
  /**
     The <code>SMTPAppender</code> requires a {@link Layout layout}.  
  */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
     Send the contents of the cyclic buffer as an e-mail message.
   */
  protected
  void sendBuffer() {
    try {      
      MimeBodyPart part = new MimeBodyPart();
      StringBuffer sbuf = new StringBuffer();
      String t = layout.getHeader();
      if(t != null)
	sbuf.append(t);
      int len =  cb.length();
      for(int i = 0; i < len; i++) {
	//sbuf.append(MimeUtility.encodeText(layout.format(cb.get())));
	sbuf.append(layout.format(cb.get()));
      }
      t = layout.getFooter();
      if(t != null)
	sbuf.append(t);
      part.setContent(sbuf.toString(), layout.getContentType());      
      Multipart mp = new MimeMultipart();
      mp.addBodyPart(part);
      msg.setContent(mp);
      msg.setSentDate(new Date());
      Transport.send(msg);      
    } catch(Exception e) {
      LogLog.error(""Error occured while sending e-mail notification."", e);
    }
  }
 /**
     Set SMTPAppender specific options.
     <p>On top of the options of the super class {@link
     AppenderSkeleton}, the recognized options are <b>To</b>,
     <b>From</b>, <b>Subject</b>, <b>SMTPHost</b>,
     <b>BufferSize</b>, <b>EvaluatorClass</b> and <b>LocationInfo</b>. 
     <p>The <b>To</b> option takes a string value which should be a
     comma separated list of e-mail address of the recipients.
     <p>The <b>From</b> option takes a string value which should be a
     e-mail address of the sender.
     <p>The <b>Subject</b> option takes a string value which should be a
     the subject of the e-mail message.
     <p>The <b>SMTPHost</b> option takes a string value which should be a
     the host name of the SMTP server that will send the e-mail message.
     <p>The <b>BufferSize</b>option takes a positive integer
     representing the maximum number of logging events to collect in a
     cyclic buffer. When the <code>BufferSize</code> is reached,
     oldest events are deleted as new events are added to the
     buffer. By default the size of the cyclic buffer is 512 events.
     <p>The <b>EvaluatorClass</b> option takes a string value
     repsenting the name of the class implementing the {@link
     TriggeringEventEvaluator} interface. A corresponding object will
     be instantiated and assigned as the triggering event evaluator
     for the SMTPAppender.
     <p>The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the layout that formats the events as they are sent out
     in an e-mail is likely to place the wrong location information
     (if present in the format).
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
 */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    
    if(option.equals(TO_OPTION)) 
      to = value;
    else if (option.equals(FROM_OPTION))
      from = value;
    else if (option.equals(SMTP_HOST_OPTION)) 
      smtpHost = value;
    else if (option.equals(SUBJECT_OPTION)) 
      subject = value;
    else if (option.equals(EVALUATOR_CLASS_OPTION)) {      
      evaluator = (TriggeringEventEvaluator) 
                OptionConverter.instantiateByClassName(value, 
					   TriggeringEventEvaluator.class,
						       evaluator);    
    }
    else if (option.equals(BUFFER_SIZE_OPTION)) {
      bufferSize = OptionConverter.toInt(value, bufferSize);    
      cb.resize(bufferSize);
    }
    else if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
  }
}
class DefaultEvaluator implements TriggeringEventEvaluator {
  /**
     Is this <code>event</code> the e-mail triggering event?
     <p>This method returns <code>true</code>, if the event priority
     has ERROR priority or higher. Otherwisem it returns
     <code>false</code>. */
  public 
  boolean isTriggeringEvent(LoggingEvent event) {
    return event.priority.isGreaterOrEqual(Priority.ERROR); 
  }
}
"
org.apache.log4j.net.SocketAppender,"//      Copyright 1996-2000, International Business Machines
//      Corporation. All Rights Reserved.
//
//      See the LICENCE file for the terms of distribution.
// Contributors: Dan MacDonald <dan@redknee.com>
package org.apache.log4j.net;
import java.net.InetAddress;
import java.net.Socket;
import java.io.OutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;
/**
    Sends {@link LoggingEvent} objects to a remote a log server,
    usually a {@link SocketNode}.
    <p>The SocketAppender has the following properties:
    <ul>
      <p><li>If sent to a {@link SocketNode}, remote logging is
      non-intrusive as far as the log event is concerned. In other
      words, the event will be logged with the same time stamp, {@link
      org.apache.log4j.NDC}, location info as if it were logged locally by
      the client.
      <p><li>SocketAppenders do not use a layout. They ship a
      serialized {@link LoggingEvent} object to the server side.
      <p><li>Remote logging uses the TCP protocol. Consequently, if
      the server is reachable, then log events will eventually arrive
      at the server.
      <p><li>If the remote server is down, the logging requests are
      simply dropped. However, if and when the server comes back up,
      then event transmission is resumed transparently. This
      transparent reconneciton is performed by a <em>connector</em>
      thread which periodically attempts to connect to the server.
      <p><li>Logging events are automatically <em>buffered</em> by the
      native TCP implementation. This means that if the link to server
      is slow but still faster than the rate of (log) event production
      by the client, the client will not be affected by the slow
      network connection. However, if the network connection is slower
      then the rate of event production, then the client can only
      progress at the network rate. In particular, if the network link
      to the the server is down, the client will be blocked.
      <p>On the other hand, if the network link is up, but the server
      is down, the client will not be blocked when making log requests
      but the log events will be lost due to server unavailability.
      <p><li>Even if a <code>SocketAppender</code> is no longer
      attached to any category, it will not be garbage collected in
      the presence of a connector thread. A connector thread exists
      only if the connection to the server is down. To avoid this
      garbage collection problem, you should {@link #close} the the
      <code>SocketAppender</code> explicitly. See also next item.
      <p>Long lived applications which create/destroy many
      <code>SocketAppender</code> instances should be aware of this
      garbage collection problem. Most other applications can safely
      ignore it.
      <p><li>If the JVM hosting the <code>SocketAppender</code> exits
      before the <code>SocketAppender</code> is closed either
      explicitly or subsequent to garbage collection, then there might
      be untransmitted data in the pipe which might be lost. This is a
      common problem on Windows based systems.
      <p>To avoid lost data, it is usually sufficient to {@link #close}
      the <code>SocketAppender</code> either explicitly or by calling
      the {@link Category#shutdown} method before exiting the
      application.  
     </ul>
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4 */
public class SocketAppender extends AppenderSkeleton {
  InetAddress address;
  int port = 4560;
  String hostName;
  ObjectOutputStream oos;
  int reconnectionDelay = 30000;
  boolean locationInfo = false;
  private Connector connector;
  int counter = 0; 
  // reset the ObjectOutputStream every 70 calls
  //private static final int RESET_FREQUENCY = 70;
  private static final int RESET_FREQUENCY = 1;
  /**
     A string constant used in naming the option for setting the the
     host name of the remote server.  Current value of this string
     constant is <b>RemoteHost</b>. See the {@link #setOption} method
     for the meaning of this option.
  */
  public static final String REMOTE_HOST_OPTION = ""RemoteHost"";
 /**
     A string constant used in naming the option for setting the the
     port to contect on the remote server.  Current value of this string
     constant is <b>Port</b>.  See the {@link #setOption} method
     for the meaning of this option.
  */
  public static final String PORT_OPTION = ""Port"";
  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  See the {@link #setOption} method
     for the meaning of this option.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  /**
     A string constant used in naming the option for setting the delay
     between each reconneciton attempt to remote server.  Current
     value a of this string constant is <b>ReconnectionDelay</b>.  See
     the {@link #setOption} method for the meaning of this option.
  */
  public static final String RECONNECTION_DELAY_OPTION = ""ReconnectionDelay"";
  public SocketAppender() {
  }
  /**
     Connects to remote server at <code>address</code> and <code>port</code>.
  */
  public
  SocketAppender(InetAddress address, int port) {
    this.address = address;
    this.port = port;
    this.hostName = address.getHostName();
    connect(address, port);
  }
  /**
     Connects to remote server at <code>host</code> and <code>port</code>.
  */
  public
  SocketAppender(String host, int port) { 
    this.port = port;
    this.hostName = host;
    this.address = getAddressByName(host);
    connect(address, port);
  }
  /**
     Connect to the specified <b>RemoteHost</b> and <b>Port</b>. 
  */
  public
  void activateOptions() {
    connect(address, port);
  }
  /**
     Close this appender. 
     <p>This will mark the appender as closed and
     call then {@link #cleanUp} method.
  */
  public
  void close() {
    this.closed = true;
    cleanUp();
  }
  /**
     Drop the connection to the remote host and release the underlying
     connector thread if it has been created
   */
  public 
  void cleanUp() {
    if(oos != null) {
      try {
	oos.close();
      }
      catch(IOException e) {
	LogLog.error(""Could not close oos."", e);
      }
      oos = null;      
    }
    if(connector != null) {
      //LogLog.debug(""Interrupting the connector."");      
      connector.interrupt();
      connector = null;  // allow gc
    }
  }
  void connect(InetAddress address, int port) {
    if(this.address == null)
      return;
    try {
      // First, close the previous connection if any.
      cleanUp();          
      oos = new ObjectOutputStream(new Socket(address, port).getOutputStream());
    }
    catch(IOException e) {
      LogLog.error(""Could not connect to remote log4j server at [""
		   +address.getHostName()+""]. We will try again later."", e);
      fireConnector();
    }
  }
  public
  void append(LoggingEvent event) {
    if(address==null) {
      errorHandler.error(""No remote host is set for SocketAppedender named \""""+
			this.name+""\""."");
      return;
    }
    if(oos != null) {
      try {
	if(locationInfo) {
	   event.setLocationInformation();	
	} 
	oos.writeObject(event);
	//LogLog.debug(""=========Flushing."");
	oos.flush();
	if(++counter >= RESET_FREQUENCY) {
	  counter = 0;
	  // Failing to reset the object output stream every now and
	  // then creates a serious memory leak.
	  //System.err.println(""Doing oos.reset()"");
	  oos.reset();
	}
      }
      catch(IOException e) {
	oos = null;
	LogLog.debug(""Detected problem with connection: ""+e);
	fireConnector();
      }
    }
  }
  void fireConnector() {
    if(connector == null) {
      LogLog.debug(""Starting a new connector thread."");
      connector = new Connector();
      connector.setDaemon(true);
      connector.setPriority(Thread.MIN_PRIORITY);
      connector.start();      
    }
  }
  InetAddress getAddressByName(String host) {
    try {
      return InetAddress.getByName(host);
    }	
    catch(Exception e) {
      LogLog.error(""Could not find address of [""+host+""]."", e);
      return null;
    }
  }
  /**
     Retuns the option names for this component, namely the string
     array consisting of {{@link #REMOTE_HOST_OPTION}, {@link
     #PORT_OPTION}, {@link #LOCATION_INFO_OPTION}, {@link
     #RECONNECTION_DELAY_OPTION}} in addition to the options of its
     super class {@link AppenderSkeleton}.
    */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
                          new String[] {REMOTE_HOST_OPTION, PORT_OPTION, 
					LOCATION_INFO_OPTION,
					RECONNECTION_DELAY_OPTION});
  }
  /**
     The SocketAppender does not use a layout. Hence, this method returns
     <code>false</code>.
  */
  public
  boolean requiresLayout() {
    return false;
  }
  /**
     Set SocketAppender specific options.
     <p>On top of the options of the super class {@link
     AppenderSkeleton}, the recognized options are <b>RemoteHost</b>,
     <b>Port</b> and <b>ReconnectionDelay</b>, i.e. the values of the
     string constants {@link #REMOTE_HOST_OPTION}, {@link
     #PORT_OPTION},{@link #LOCATION_INFO_OPTION} and respectively {@link
     #RECONNECTION_DELAY_OPTION}.
     <p>The <b>RemoteHost</b> option takes a string value which should be
     the host name of the server where a {@link SocketNode} is running.
     <p>The <b>Port</b> option takes a positive integer representing
     the port where the server is waiting for connections.
     <p>The <b>LocationInfo</b> option takes a boolean value. If true,
     the information sent to the remote host will include location
     information. By default no location information is sent to the server.
     <p>The <b>ReconnectionDelay</b> option takes a positive integer
     representing the number of milliseconds to wait between each
     failed connection attempt to the server. The default value of
     this option is 30000 which corresponds to 30 seconds.
   */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    
    if(option.equals(REMOTE_HOST_OPTION)) 
      address = getAddressByName(value);
    else if (option.equals(PORT_OPTION))
      port = OptionConverter.toInt(value, port);
    else if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);    
    else if (option.equals(RECONNECTION_DELAY_OPTION))
      reconnectionDelay = OptionConverter.toInt(value, reconnectionDelay);
  }
  /**
     The Connector will reconnect when the server becomes available
     again.  It does this by attempting to open a new connection every
     <code>reconnectionDelay</code> milliseconds.
     <p>It stops trying whenever a connection is established. It will
     restart to try reconnect to the server when previpously open
     connection is droppped.
     @author  Ceki G&uuml;lc&uuml; 
     @since 0.8.4
  */
  class Connector extends Thread {
    public
    void run() {
      Socket socket;      
      while(!isInterrupted()) {
	try {
	  sleep(reconnectionDelay);
	  LogLog.debug(""Attempting connection to ""+address.getHostName());
	  socket = new Socket(address, port);
	  synchronized(this) {
	    oos = new ObjectOutputStream(socket.getOutputStream()); 
	    connector = null;
	    break;
	  }
	}
	catch(InterruptedException e) {
	  LogLog.debug(""Connector interrupted. Leaving loop."");
	  return;
	}
	catch(java.net.ConnectException e) {
	  LogLog.debug(""Remote host ""+address.getHostName()
		       +"" refused connection."");
	}
	catch(IOException e) {	  
	  LogLog.debug(""Could not connect to "" + address.getHostName()+
		       "". Exception is "" + e);
	}
      }
      //LogLog.debug(""Exiting Connector.run() method."");
    }
    /**
       public
       void finalize() {
       LogLog.debug(""Connector finalize() has been called."");
       }
    */
  }
}
"
org.apache.log4j.net.SocketNode,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
//      Copyright 2000, Ceki Gulcu. All Rights Reserved.
//      See the LICENCE file for the terms of usage and distribution.
package org.apache.log4j.net;
import java.net.InetAddress;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.InputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
// Contributors:  Moses Hohman <mmhohman@rainbow.uchicago.edu>
/**
   Read {@link LoggingEvent} objects sent from a remote client using
   Sockets (TCP). These logging events are logged according to local
   policy, as if they were generated locally.
   <p>For example, the socket node might decide to log events to a
   local file and also resent them to a second socket node.
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4
*/
public class SocketNode implements Runnable {
  Socket socket;
  Hierarchy hierarchy;
  ObjectInputStream ois;
  static Category cat = Category.getInstance(SocketNode.class.getName());
  public 
  SocketNode(Socket socket, Hierarchy hierarchy) {
    this.socket = socket;
    this.hierarchy = hierarchy;
    try {
      ois = new ObjectInputStream(socket.getInputStream());
    }
    catch(Exception e) {
      cat.error(""Could not open ObjectInputStream to ""+socket, e);
    }
  }
  //public
  //void finalize() {
  //System.err.println(""-------------------------Finalize called"");
  // System.err.flush();
  //}
  public void run() {
    LoggingEvent event;
    Category remoteCategory;
    try {
      while(true) {	
	event = (LoggingEvent) ois.readObject();	
	remoteCategory = hierarchy.getInstance(event.categoryName);
	if(event.priority.isGreaterOrEqual(remoteCategory.getChainedPriority())) {
	  remoteCategory.callAppenders(event);	
	}
      }
    }
    catch(java.io.EOFException e) {
      cat.info(""Caught java.io.EOFException closing conneciton."");
    }
    catch(java.net.SocketException e) {
      cat.info(""Caught java.net.SocketException closing conneciton."");
    }
    catch(Exception e) {
      cat.error(""Unexpected exception. Closing conneciton."", e);
    }
    try {
      ois.close();
    }
    catch(Exception e) {
      cat.info(""Could not close connection."", e);	
    }  
  }
}
"
org.apache.log4j.net.SocketServer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import java.net.Socket;
import java.net.ServerSocket;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.io.IOException;
import java.io.File;
import java.util.Hashtable;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.Priority;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.RootCategory;
/**
   A {@link SocketNode} based server that uses a different hiearchy
   for each client.
   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SocketServer port configFile configDir
     where <b>port</b> is a part number where the server listens,
           <b>configFile</b> is a configuration file fed to the {@link PropertyConfigurator} and
           <b>configDir</b> is a path to a directory containing configuration files, possibly one for each client host.
     </pre>
     <p>The <code>configFile</code> is used to configure the log4j
     default hierarchy that the <code>SocketServer</code> will use to
     report on its actions.
     <p>When a new connection is opened from a previously unknown
     host, say <code>foo.bar.net</code>, then the
     <code>SocketServer</code> will search for a configuration file
     called <code>foo.bar.net.lcf</code> under the directory
     <code>configDir</code> that was passed as the third argument. If
     the file can be found, then a new hierarchy is instantiated and
     configured using the configuration file
     <code>foo.bar.net.lcf</code>. If and when the host
     <code>foo.bar.net</code> opens another connection to the server,
     then the previously configured hierarchy is used.
     <p>In case there is no file called <code>foo.bar.net.lcf</code>
     under the directory <code>configDir</code>, then the
     <em>generic</em> hierarchy is used. The generic hierarchy is
     configured using a configuration file called
     <code>generic.lcf</code> under the <code>configDir</code>
     directory. If no such file exists, then the generic hierarchy will be
     identical to the log4j default hierarchy.
     <p>Having different client hosts log using different hierarchies
     ensures the total independence of the clients with respect to
     their logging settings. 
     <p>Currently, the hierarchy that will be used for a given request
     depends on the IP address of the client host. For example, two
     separate applicatons running on the same host and logging to the
     same server will share the same hierarchy. This is perfectly safe
     except that it might not provide the right amount of independence
     between applications. The <code>SocketServer</code> is intended
     as an example to be enhanced in order to implement more elaborate
     policies.
    @author  Ceki G&uuml;lc&uuml;
    @since 1.0 */
public class SocketServer  {
  static String GENERIC = ""generic"";
  static String CONFIG_FILE_EXT = "".lcf"";
  static Category cat = Category.getInstance(SocketServer.class);  
  static SocketServer server;
  static int port;
  // key=inetAddress, value=hierarchy
  Hashtable hierarchyMap;
  Hierarchy genericHierarchy;
  File dir;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1], argv[2]);
    else 
      usage(""Wrong number of arguments."");     
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	InetAddress inetAddress =  socket.getInetAddress();
	cat.info(""Connected to client at "" + inetAddress);
	Hierarchy h = (Hierarchy) server.hierarchyMap.get(inetAddress);
	if(h == null) {
	  h = server.configureHierarchy(inetAddress);
	} 
	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, h)).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SocketServer.class.getName() + "" port configFile directory"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile, String dirStr) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);
    File dir = new File(dirStr);    
    if(!dir.isDirectory()) {
      usage(""[""+dirStr+""] is not a directory."");
    }
    server = new SocketServer(dir);
  }
  public
  SocketServer(File directory) {
    this.dir = directory;
    hierarchyMap = new Hashtable(11);
  }
  // This method assumes that there is no hiearchy for inetAddress
  // yet. It will configure one and return it.
  Hierarchy configureHierarchy(InetAddress inetAddress) {
    cat.info(""Locating configuration file for ""+inetAddress);
    // We assume that the toSting method of InetAddress returns is in
    // the format hostname/d1.d2.d3.d4 e.g. torino/192.168.1.1
    String s = inetAddress.toString();
    int i = s.indexOf(""/"");
    if(i == -1) {
      cat.warn(""Could not parse the inetAddress [""+inetAddress+
	       ""]. Using default hierarchy."");
      return genericHierarchy();
    } else {
      String key = s.substring(0, i);
      File configFile = new File(dir, key+CONFIG_FILE_EXT);
      if(configFile.exists()) {
	Hierarchy h = new Hierarchy(new RootCategory(Priority.DEBUG));
	hierarchyMap.put(inetAddress, h);
	try {
	  new PropertyConfigurator().doConfigure(configFile.toURL(), h);
	} catch(MalformedURLException e) {
	  cat.error(""Could not convert""+configFile+"" to a URL."", e);
	}
	return h;	
      } else {
	cat.warn(""Could not find config file [""+configFile+""]."");
	return genericHierarchy();
      }
    }
  }
  Hierarchy genericHierarchy() {
    if(genericHierarchy == null) {
      File f = new File(dir, GENERIC+CONFIG_FILE_EXT);
      if(f.exists()) {
	genericHierarchy = new Hierarchy(new RootCategory(Priority.DEBUG));
	try {
	  new PropertyConfigurator().doConfigure(f.toURL(),
					       genericHierarchy);
	} catch(MalformedURLException e) {
	  cat.error(""Could not convert""+f
		    +"" to a URL. Reverting to default hierarchy"", e);	  
	  genericHierarchy = Category.getDefaultHierarchy();
	}
      } else {
	cat.warn(""Could not find config file [""+f+
		 ""]. Will use the default hierarchy."");
	genericHierarchy = Category.getDefaultHierarchy();
      }
    }
    return genericHierarchy;
  }
}
"
org.apache.log4j.net.SyslogAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.SyslogWriter;
import org.apache.log4j.helpers.SyslogQuietWriter;
import org.apache.log4j.net.SyslogTracerPrintWriter;
// Contributors: Yves Bossel <ybossel@opengets.cl>
//               Christopher Taylor <cstaylor@pacbell.net>
/**
    Use SyslogAppender to send log messages to a remote syslog daemon.
    @author Ceki G&uuml;lc&uuml; 
 */
public class SyslogAppender extends AppenderSkeleton {
  // The following constants are extracted from a syslog.h file
  // copyrighted by the Regents of the University of California
  // I hope nobody at Berkley gets offended.
  /** Kernel messages */
  final static public int LOG_KERN     = 0; 
  /** Random user-level messages */
  final static public int LOG_USER     = 1<<3; 
  /** Mail system */
  final static public int LOG_MAIL     = 2<<3; 
  /** System daemons */
  final static public int LOG_DAEMON   = 3<<3; 
  /** security/authorization messages */
  final static public int LOG_AUTH     = 4<<3; 
  /** messages generated internally by syslogd */
  final static public int LOG_SYSLOG   = 5<<3; 
  /** line printer subsystem */  
  final static public int LOG_LPR      = 6<<3; 
  /** network news subsystem */
  final static public int LOG_NEWS     = 7<<3; 
  /** UUCP subsystem */
  final static public int LOG_UUCP     = 8<<3; 
  /** clock daemon */
  final static public int LOG_CRON     = 9<<3; 
  /** security/authorization  messages (private) */
  final static public int LOG_AUTHPRIV = 10<<3; 
  /** ftp daemon */
  final static public int LOG_FTP      = 11<<3; 
  // other codes through 15 reserved for system use
  /** reserved for local use */
  final static public int LOG_LOCAL0 = 16<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL1 = 17<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL2 = 18<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL3 = 19<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL4 = 20<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL5 = 21<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL6 = 22<<3; 
  /** reserved for local use*/
  final static public int LOG_LOCAL7 = 23<<3; 
   /**
     A string constant used in naming the option for setting the the
     syslog server.  Current value of this string constant is
     <b>SyslogHost</b>.
     @since 0.8.1 */
  public static final String SYSLOG_HOST_OPTION = ""SyslogHost"";
   /**
     A string constant used in naming the option for setting facility
     type.  Current value of this string constant is <b>Facility</b>.
     @since 0.8.1 */
  public static final String FACILITY_OPTION = ""Facility"";  
   /**
     A string constant used in naming the option for setting whether
     the facility name is printed or not.  Current value of this
     string constant is <b>FacilityPrinting</b>.
     @since 0.8.1 */
  public static final String FACILITY_PRINTING_OPTION = ""FacilityPrinting"";  
  protected static final int SYSLOG_HOST_OI = 0;
  protected static final int FACILITY_OI = 1;
  // Have LOG_USER as default
  int syslogFacility = LOG_USER;
  String facilityStr;  
  boolean facilityPrinting = false;
  SyslogTracerPrintWriter stp;
  SyslogQuietWriter sqw;  
  String syslogHost;
  public
  SyslogAppender() {
    this.initSyslogFacilityStr(this.syslogFacility);
  }
  public
  SyslogAppender(Layout layout, int syslogFacility) {
    this.layout = layout;
    this.syslogFacility = syslogFacility;    
    this.initSyslogFacilityStr(syslogFacility);
  }
  public
  SyslogAppender(Layout layout, String syslogHost, int syslogFacility) {
    this(layout, syslogFacility);
    setSyslogHost(syslogHost);
  }
  /**
     Release any resources held by this SyslogAppender.
     @since 0.8.4
   */
  public
  void close() {
    closed = true;
    // A SyslogWriter is UDP based and needs no opening. Hence, it
    // can't be closed. We just unset the variables here.    
    sqw = null;
    stp = null;
  }
  private
  void initSyslogFacilityStr(int syslogFacility) {
    switch(syslogFacility) {
    case LOG_KERN: facilityStr = ""kern:""; break;
    case LOG_USER: facilityStr = ""user:""; break;
    case LOG_MAIL: facilityStr = ""mail:""; break;
    case LOG_DAEMON: facilityStr = ""daemon:""; break;
    case LOG_AUTH: facilityStr = ""auth:"";; break;
    case LOG_SYSLOG: facilityStr = ""syslog:""; break;
    case LOG_LPR: facilityStr = ""lpr:""; break;
    case LOG_NEWS: facilityStr = ""news:""; break;
    case LOG_UUCP: facilityStr = ""uucp:""; break;
    case LOG_CRON: facilityStr = ""cron:""; break;
    case LOG_AUTHPRIV: facilityStr = ""authpriv:""; break;
    case LOG_FTP: facilityStr = ""ftp:""; break;
    case LOG_LOCAL0: facilityStr = ""local0:""; break;
    case LOG_LOCAL1: facilityStr = ""local1:""; break;
    case LOG_LOCAL2: facilityStr = ""local2:""; break;
    case LOG_LOCAL3: facilityStr = ""local3:""; break;
    case LOG_LOCAL4: facilityStr = ""local4:""; break;
    case LOG_LOCAL5: facilityStr = ""local5:""; break;
    case LOG_LOCAL6: facilityStr = ""local6:""; break;
    case LOG_LOCAL7: facilityStr = ""local7:""; break;
    default: 
      System.err.println(""\"""" + syslogFacility +
                  ""\"" is an unknown syslog facility. Defaulting to \""USER\""."");
      this.syslogFacility = LOG_USER;
      facilityStr = ""user:"";
    }	   
  }	   
  public
  void append(LoggingEvent event) {
    if(!isAsSevereAsThreshold(event.priority))
      return;
    // We must not attempt to append if sqw is null.
    if(sqw == null) {
      errorHandler.error(""No syslog host is set for SyslogAppedender named \""""+
			this.name+""\""."");
      return;
    }
    String buffer = (facilityPrinting? facilityStr : """") +
                          layout.format(event);
    sqw.setPriority(event.priority.getSyslogEquivalent());    
    sqw.write(buffer);
    if(event.throwable != null) 
      event.throwable.printStackTrace(stp);
    else if (event.throwableInformation != null) {
      sqw.write(event.throwableInformation);
    }
  }
  /**
     This method returns immediately as options are activated when they
     are set.
     @see #setOption
  */
  public
  void activateOptions() {
  }
  /**
     Retuns the option names for this component, namely the string
     array consisting of {{@link #SYSLOG_HOST_OPTION}, {@link
     #FACILITY_OPTION}, {@link #FACILITY_PRINTING_OPTION}}.
     @since 0.8.1 */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		      new String[] {SYSLOG_HOST_OPTION, FACILITY_OPTION,
			            FACILITY_PRINTING_OPTION});
  }
  /**
     The SyslogAppender requires a layout. Hence, this method return
     <code>true</code>.
     @since 0.8.4 */
  public
  boolean requiresLayout() {
    return true;
  }
  /**
     Set the syslog facility.
     <p>The <code>facilityName</code> parameter must be one of the
     strings KERN, USER, MAIL, DAEMON, AUTH, SYSLOG, LPR, NEWS, UUCP,
     CRON, AUTHPRIV, FTP, LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4,
     LOCAL5, LOCAL6, LOCAL7. Case is unimportant.
     @since 0.8.1 */
  public
  void setFacility(String facilityName) {
    if(facilityName == null)
      return;
    if(""KERN"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_KERN;
    else if(""USER"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_USER;
    else if(""MAIL"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_MAIL;
    else if(""DAEMON"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_DAEMON;
    else if(""AUTH"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_AUTH;
    else if(""SYSLOG"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_SYSLOG;
    else if(""LPR"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LPR;
    else if(""NEWS"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_NEWS;
    else if(""UUCP"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_UUCP;
    else if(""CRON"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_CRON;
    else if(""AUTHPRIV"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_AUTHPRIV;
    else if(""FTP"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_FTP;
    else if(""LOCAL0"".equalsIgnoreCase(facilityName)) 
      this.syslogFacility = LOG_LOCAL0;
    else if(""LOCAL1"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LOCAL1;
    else if(""LOCAL2"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LOCAL2;
    else if(""LOCAL3"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LOCAL3;
    else if(""LOCAL4"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LOCAL4;
    else if(""LOCAL5"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LOCAL5;
    else if(""LOCAL6"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LOCAL6;
    else if(""LOCAL7"".equalsIgnoreCase(facilityName))
      this.syslogFacility = LOG_LOCAL7;
    else {
      System.err.println(facilityName +
                  "" is an unknown syslog facility. Defaulting to \""USER\""."");
      this.syslogFacility = LOG_USER;
    }
    this.initSyslogFacilityStr(this.syslogFacility);
    // If there is already a sqw, make it use the new facility.
    if(sqw != null) {
      sqw.setSyslogFacility(this.syslogFacility);
    }
  }
  /**
    Set SyslogAppender specific parameters. 
    <p>The recognized options are <b>SyslogHost</b>, <b>Facility</b> and
    <b>FacilityPrinting</b>, i.e. the values of the string constants
    {@link #SYSLOG_HOST_OPTION}, {@link #FACILITY_OPTION} and {@link
    #FACILITY_PRINTING_OPTION} respectively.
    <dl>
    <p><dt><b>SyslogHost</b>
    <dd>The host name of the syslog host where log output should
    go.
    <b>WARNING</b> If the SyslogHost is not set, then this appender
    will fail. 
     <p><dt><b>Facility</b>
     A string representing the syslog facility.
     <p>Acceptable values are in the set {KERN, USER, MAIL, DAEMON,
     AUTH, SYSLOG, LPR, NEWS, UUCP, CRON, AUTHPRIV, FTP LOCAL0,
     LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7}.
    <p><dt><b>FacilityPrinting</b>
    <dd>If set to true, the printed message will include the facility
    name of the application. Is set to <em>false</em> by default.
    </dl>
    <p>
    @since 0.8.1 */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    
    if(option.equals(SYSLOG_HOST_OPTION)) 
      this.setSyslogHost(value);
    else if(option.equals(FACILITY_PRINTING_OPTION))
      facilityPrinting = OptionConverter.toBoolean(value, facilityPrinting);
    else if(option.equals(FACILITY_OPTION)) {
      this.setFacility(value);
    }
  }
  public
  void setSyslogHost(String syslogHost) {
    this.sqw = new SyslogQuietWriter(new SyslogWriter(syslogHost), 
				     syslogFacility, errorHandler);
    this.stp = new SyslogTracerPrintWriter(sqw);    
    this.syslogHost = syslogHost;
  }
}
"
org.apache.log4j.net.SyslogTracerPrintWriter,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.TracerPrintWriter;
/**
   SyslogTracerPrintWriter overrides the println function in
   TracerPrintWriter by replacing the TAB character which appear as
   '^I' on syslog files with spaces. It also does not print the ""\n"".
*/
class SyslogTracerPrintWriter extends TracerPrintWriter {
  static String TAB = ""    "";
  SyslogTracerPrintWriter(QuietWriter qWriter) {
    super(qWriter);
  }
  /**
     Make the first Exception line print properly by omitting the \n ath the 
     end.
  */
  public
   void println(Object o) {
    this.qWriter.write(o.toString());
  }
  // Note: the Char[] form is handled by the TracerPrinterWriter super
  // class
  /**
     Remove the first character from the string (usually a TAB) and do
     not print ""\n""
  */   
  public
  void println(String s) {
      // remove '^I' and replace it with 4 spaces
      this.qWriter.write(TAB+s.substring(1));
  }
}
"
org.apache.log4j.net.test.Loop,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.*;
import org.apache.log4j.net.SocketAppender;
public class Loop {
  public static void main(String[] args) {
    Category root = Category.getRoot();
    Category cat = Category.getInstance(Loop.class.getName());
    if(args.length != 2) 
      usage(""Wrong number of arguments."");     
    String host = args[0];
    int port = 0;
    try {
      port = Integer.valueOf(args[1]).intValue();
    }
    catch (NumberFormatException e) {
        usage(""Argument ["" + args[1]  + ""] is not in proper int form."");
    }
    SocketAppender sa = new SocketAppender(host, port);
    Layout layout = new PatternLayout(""%5p [%t] %x %c - %m\n"");
    FileAppender so = new FileAppender(layout, System.out);
    root.addAppender(sa);
    root.addAppender(so);
    int i = 0;
    while(true) {
      NDC.push(""""+ (i++));
      cat.debug(""Debug message."");
      root.info(""Info message."");
      NDC.pop();
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +Loop.class.getName() + "" host port"");
    System.exit(1);
  }
}
"
org.apache.log4j.net.test.SMTPMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.*;
import java.io.IOException;
import java.io.InputStreamReader;
public class SMTPMin {
  static Category cat = Category.getInstance(SMTPMin.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");     
    NDC.push(""some context"");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SMTPMin.class.getName()
		       + "" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    Category.shutdown();
    Thread.currentThread().getThreadGroup().list();
  }
}
"
org.apache.log4j.net.test.SocketMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
import java.io.InputStreamReader;
public class SocketMin {
  static Category cat = Category.getInstance(SyslogMin.class.getName());
  static SocketAppender s;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    NDC.push(""some context"");
    if(argv[2].equals(""true""))
      loop();
    else
      test();
    s.close();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SocketMin.class 
		       + "" host port true|false"");
    System.exit(1);
  }
  static
  void init(String host, String portStr) {
    Category root = Category.getRoot();
    BasicConfigurator.configure();
    try {
      int port   = Integer.parseInt(portStr);
      cat.info(""Creating socket appender (""+host+"",""+port+"")."");
      s = new SocketAppender(host, port);
      s.setName(""S"");
      root.addAppender(s);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    catch(Exception e) {
      System.err.println(""Could not start!"");
      e.printStackTrace();
      System.exit(1);
    }
  }
  static
  void loop() {
    Category root = Category.getRoot();
    InputStreamReader in = new InputStreamReader(System.in);
    System.out.println(""Type 'q' to quit"");
    int i;
    int k = 0;
    while (true) {
      cat.debug(""Message "" + k++);
      cat.info(""Message "" + k++);
      cat.warn(""Message "" + k++);
      cat.error(""Message "" + k++, new Exception(""Just testing""));
      try {i = in.read(); }
      catch(Exception e) { return; }
      if(i == -1) break;
      if(i == 'q') break;
      if(i == 'r') {
	System.out.println(""Removing appender S"");
	root.removeAppender(""S"");
      }
    }
  }
  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.net.test.SyslogMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.net.test;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
public class SyslogMin {
  static Category CAT = Category.getInstance(SyslogMin.class.getName());
  public 
  static 
  void main(String argv[]) {
      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test(""someHost"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + SyslogMin.class + "" configFile"");
    System.exit(1);
  }
  static
  void ProgramInit(String configFile) {
    int port = 0;
    PropertyConfigurator.configure(configFile);
  }
  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    CAT.debug( ""Message "" + i++);
    CAT.info( ""Message "" + i++);
    CAT.warn( ""Message "" + i++);
    CAT.error( ""Message "" + i++);
    CAT.log(Priority.FATAL, ""Message "" + i++);
    CAT.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.nt.NTEventLogAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.nt;
import org.apache.log4j.*;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import java.io.*;
/**
   Append to the NT event log system. 
   <p><b>WARNING</b> This appender can only be installed and used on a
   Windows system.
   <p>Do not forget to place the file NTEventLogAppender.dll in a
   directory that is on the PATH of the Windows system. Otherwise, you
   will get a java.lang.UnsatisfiedLinkError.
   @author <a href=""mailto:cstaylor@pacbell.net"">Chris Taylor</a>
   @author <a href=""mailto:jim_cakalic@na.biomerieux.com"">Jim Cakalic</a> */
public class NTEventLogAppender extends AppenderSkeleton {
  private int _handle = 0;
  private static final int FATAL  = Priority.FATAL.toInt();
  private static final int ERROR  = Priority.ERROR.toInt();
  private static final int WARN   = Priority.WARN.toInt();
  private static final int INFO   = Priority.INFO.toInt();
  private static final int DEBUG  = Priority.DEBUG.toInt();
  public NTEventLogAppender() {
    this(null, null, null);
  }
  public NTEventLogAppender(String source) {
    this(null, source, null);
  }
  public NTEventLogAppender(String server, String source) {
    this(server, source, null);
  }
  public NTEventLogAppender(Layout layout) {
    this(null, null, layout);
  }
  public NTEventLogAppender(String source, Layout layout) {
    this(null, source, layout);
  }
  public NTEventLogAppender(String server, String source, Layout layout) {
    if (source == null) {
      source = ""Log4j"";
    }
    if (layout == null) {
      this.layout = new TTCCLayout();
    } else {
      this.layout = layout;
    }
    try {
      _handle = registerEventSource(server, source);
    } catch (Exception e) {
      e.printStackTrace();
      _handle = 0;
    }
  }
  public
  void close() {
    // unregister ...
  }
  public void append(LoggingEvent event) {
    // First, format the log string so we can send it to NT.
    StringWriter sw_writer = new StringWriter();
    PrintWriter pw_writer = new PrintWriter(sw_writer);
    pw_writer.print(layout.format(event));
    // And append a throwable if supplied
    if (event.throwable != null) 
      event.throwable.printStackTrace(pw_writer);
    pw_writer.close();
    // Normalize the log message priority into the supported categories
    int nt_category = event.priority.toInt();
    if (nt_category < FATAL || nt_category > DEBUG) {
      nt_category = INFO;
    }
    reportEvent(_handle, sw_writer.toString(), nt_category);
  }
  public 
  void finalize() {
    deregisterEventSource(_handle);
    _handle = 0;
  }
/**
     The <code>NTEventLogAppender</code> requires a layout. Hence,
     this method always returns <code>true</code>. */
  public
  boolean requiresLayout() {
    return true;
  }
  native private int registerEventSource(String server, String source);
  native private void reportEvent(int handle, String message, int priority);
  native private void deregisterEventSource(int handle);
  static {
    System.loadLibrary(""NTEventLogAppender"");
  }
}   
"
org.apache.log4j.nt.test.NTMin,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.nt.test;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.nt.NTEventLogAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
public class NTMin {
  static Category cat = Category.getInstance(NTMin.class.getName());
  public 
  static 
  void main(String argv[]) {
    //if(argv.length == 1) {
    init();
    //}
    //else {
    //Usage(""Wrong number of arguments."");
    //}
      test(""someHost"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + NTMin.class + """");
    System.exit(1);
  }
  static
  void init() {
    BasicConfigurator.configure(new NTEventLogAppender());
  }
  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org.apache.log4j.or.DefaultRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
/**
   The default Renderer renders objects by calling their
   <code>toString</code> method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
class DefaultRenderer implements ObjectRenderer {
  DefaultRenderer() {
  }
  /**
     Render the the object passed as parameter by calling its
     <code>toString</code> method.  */
  public
  String doRender(Object o) {
    return o.toString();
  }
}  
"
org.apache.log4j.or.MessageRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.LogLog;
import javax.jms.Message;
import javax.jms.JMSException;
import javax.jms.DeliveryMode;
import java.util.Enumeration;
/**
   Render {@link ThreadGroup} objects in a format similar to the
   information output by the {@link ThreadGroup#list} method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class MessageRenderer implements ObjectRenderer {
  public
  MessageRenderer() {
  }
  /**
     Render a {@link Message}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof Message) {  
      StringBuffer sbuf = new StringBuffer();
      Message m = (Message) o;
      try {
	sbuf.append(""DeliveryMode="");
	switch(m.getJMSDeliveryMode()) {
	case DeliveryMode.NON_PERSISTENT : 	
	  sbuf.append(""NON_PERSISTENT"");
	  break;
	case DeliveryMode.PERSISTENT : 	
	  sbuf.append(""PERSISTENT"");
	  break;
	default: sbuf.append(""UNKNOWN"");
	}
	sbuf.append("", CorrelationID="");
	sbuf.append(m.getJMSCorrelationID());
	sbuf.append("", Destination="");
	sbuf.append(m.getJMSDestination());
	sbuf.append("", Expiration="");
	sbuf.append(m.getJMSExpiration());
	sbuf.append("", MessageID="");
	sbuf.append(m.getJMSMessageID());
	sbuf.append("", Priority="");
	sbuf.append(m.getJMSPriority());
	sbuf.append("", Redelivered="");
	sbuf.append(m.getJMSRedelivered());
	sbuf.append("", ReplyTo="");
	sbuf.append(m.getJMSReplyTo());
	sbuf.append("", Timestamp="");
	sbuf.append(m.getJMSTimestamp());
	sbuf.append("", Type="");
	sbuf.append(m.getJMSType());
	//Enumeration enum = m.getPropertyNames();
	//while(enum.hasMoreElements()) {
	//  String key = (String) enum.nextElement();
	//  sbuf.append(""; ""+key+""="");
	//  sbuf.append(m.getStringProperty(key));
	//}
      } catch(JMSException e) {
	LogLog.error(""Could not parse Message."", e);
      }
      return sbuf.toString();
    } else {
      return o.toString();
    }
  }
}
"
org.apache.log4j.or.ObjectRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
/**
   Implement this interface in order to Render objects as strings.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public interface ObjectRenderer {
  /**
     Render the object passed as parameter as a String.
   */
  public
  String doRender(Object o);
}
"
org.apache.log4j.or.RendererMap,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import java.util.Hashtable;
/**
   Map class objects to an {@link ObjectRenderer}.
   @author Ceki G&uuml;lc&uuml;
   @since version 1.0 */
public class RendererMap {
  Hashtable map;
  static ObjectRenderer defaultRenderer = new DefaultRenderer();
  public
  RendererMap() {
    map = new Hashtable();
  }
  /**
     Find the appropriate renderer for the class type of the
     <code>o</code> parameter. This is accimplished by calling the
     {@link #get(Class)} method. Once a renderer is found, it is
     applied on the object <code>o</code> and the result is returned
     as a {@link String}. */
  public
  String findAndRender(Object o) {
    if(o == null)
      return null;
    else 
      return get(o.getClass()).doRender(o);
  }
  /**
     Syntactic sugar method that calls {@link #get(Class)} with the
     class of the object parameter. */
  public 
  ObjectRenderer get(Object o) {
    if(o == null) 
      return null;
    else
      return get(o.getClass());
  }
  /**
     Search the parents of <code>clazz</code> for a renderer. The
     renderer closest in the hierarchy will be returned. If no
     renderers could be found, then the default renderer is returned.          
     <p>The search first looks for a renderer configured for
     <code>clazz</code>. If a renderer could not be found, then the
     search continues by looking at all the interfaces implemented by
     <code>clazz</code> including the super-interfaces of each
     interface.  If a renderer cannot be found, then the search looks
     for a renderer defined for the parent (superclass) of
     <code>clazz</code>. If that fails, then all the interfaces
     implemented by the parent of <code>clazz</code> are searched and
     so on.
     <p>For example, if A0, A1, A2 are classes and X0, X1, X2, Y0, Y1
     are interfaces where A2 extends A1 which in turn extends A0 and
     similarly X2 extends X1 which extends X0 and Y1 extends Y0. Let
     us also assume that A1 implements the Y0 interface and that A2
     implements the X2 interface.
     <p>The table below shows the results returned by the
     <code>get(A2.class)</code> method depending on the renderers
     added to the map.
     <table>
     <tr><th>Added renderers</th><th>Value returned by <code>get(A2.class)</code></th>
     <tr><td><code>A0Renderer</code>
         <td><code>A0Renderer</code>  
     <tr><td><code>A0Renderer, A1Renderer</code>
         <td><code>A1Renderer</code>  
     <tr><td><code>X0Renderer</code>
         <td><code>X0Renderer</code>  
     <tr><td><code>A1Renderer, X0Renderer</code>
         <td><code>X0Renderer</code>  
     </table>
     This search algorithm is not the most natural. although it is
     particularly easy to implement. Future log4j versions
     <em>may</em> implement a more intuitive search
     algorithm. However, the present algorithm should be acceptable in
     the vast majority of circumstances.
 */
  public
  ObjectRenderer get(Class clazz) {
    //System.out.println(""\nget: ""+clazz);    
    ObjectRenderer r = null;
    for(Class c = clazz; c != null; c = c.getSuperclass()) {
      //System.out.println(""Searching for class: ""+c);
      r = (ObjectRenderer) map.get(c);
      if(r != null) {
	return r;
      }      
      r = searchInterfaces(c);
      if(r != null)
	return r;
    }
    return defaultRenderer;
  }  
  ObjectRenderer searchInterfaces(Class c) {
    //System.out.println(""Searching interfaces of class: ""+c);
    ObjectRenderer r = (ObjectRenderer) map.get(c);
    if(r != null) {
      return r;
    } else {
      Class[] ia = c.getInterfaces();
      for(int i = 0; i < ia.length; i++) {
	r = searchInterfaces(ia[i]);
	if(r != null)
	  return r; 
      }
    }
    return null;
  }
  public
  ObjectRenderer getDefaultRenderer() {
    return defaultRenderer;
  }
  public
  void clear() {
    map.clear();
  }
  /**
     Register an {@link ObjectRenderer} for <code>clazz</code>.
     <b>Warning:</b>Interfaces cannot have object renderers. If clazz
     is an interface, then a {@link IllegalArgumentException} will be
     thrown.
  */
  public
  void put(Class clazz, ObjectRenderer or) {
    //if(clazz.isInterface()) {
    //throw new IllegalArgumentException(clazz +
    //"" is an interface. Only classes allowed to regiter object renderers."");
    //}
    map.put(clazz, or);
  }
}
"
org.apache.log4j.or.ThreadGroupRenderer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.or;
import org.apache.log4j.Layout;
/**
   Render {@link ThreadGroup} objects in a format similar to the
   information output by the {@link ThreadGroup#list} method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class ThreadGroupRenderer implements ObjectRenderer {
  public
  ThreadGroupRenderer() {
  }
  /**
     Render a {@link ThreadGroup} object similar to the way that the
     {@link ThreadGroup#list} method output information. 
     <p>The output of a simple program consisting of one
     <code>main</code> thread is:
     <pre>
     java.lang.ThreadGroup[name=main, maxpri=10]
         Thread=[main,5,false]
     </pre>
     <p>The boolean value in thread information is the value returned
     by {@link Thread#isDaemon}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof ThreadGroup) {
      StringBuffer sbuf = new StringBuffer();
      ThreadGroup tg = (ThreadGroup) o;
      sbuf.append(""java.lang.ThreadGroup[name="");
      sbuf.append(tg.getName());
      sbuf.append("", maxpri="");
      sbuf.append(tg.getMaxPriority());
      sbuf.append(""]"");
      Thread[] t = new Thread[tg.activeCount()];
      tg.enumerate(t);
      for(int i = 0; i < t.length; i++) {
	sbuf.append(Layout.LINE_SEP);	
	sbuf.append(""   Thread=["");
	sbuf.append(t[i].getName());
	sbuf.append("","");
	sbuf.append(t[i].getPriority());
	sbuf.append("","");
	sbuf.append(t[i].isDaemon());
	sbuf.append(""]"");
      }
      return sbuf.toString();
    } else {
      // this is the best we can do
      return o.toString();
    }    
  }
}  
"
org.apache.log4j.performance.ConcatVsArray,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import java.util.Date;
/**
   Measure difference in performance of string concatenation versus
   creating an anonymous string array.
   <p>You should be able to see that anonymous string array
   construction is significatnly faster than string concatenation. The
   difference increases proportionally with the length of the strings
   to be concatanated.
   @author Ceki G&uuml;lc&uuml;
 */
public class ConcatVsArray {
  static
  void  Usage() {
    System.err.println(""Usage: java org.apache.log4j.performance.ConcatVsArray "" +
		       ""string1 string2 runLength\n"" +
		       ""       where runLength is an integer."");
    System.exit(1);
  }
  public static void main(String args[]) {
    if(args.length != 3) {
      Usage();
    }    
    String s1 = args[0];
    String s2 = args[1];
    int runLength = 0;
    try {
      runLength = Integer.parseInt(args[2]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      
    double micros;
    String[] sa;
    long before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      sa = new String[]{s1, s2};
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The anonymous array loop took around "" + micros + "" microseconds."");
    String s;    
    before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      s = s1 + s2;
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The append loop took around "" + micros + "" microseconds."");
  }
}
"
org.apache.log4j.performance.ListVsVector,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
import java.util.Vector;
/**
   Compares the performance of looping through a list versus a Vector.
   Chain looping is *20* times faster than vector access on JDK 1.1.7B on NT
*/
public class ListVsVector {
  static int RUN_LENGTH = 1000000;
  static Vector v = new Vector();
  static Chain head;
  static String tmp;
  static
  public 
  void main(String[] args) {
    v.addElement(""aaa"");
    v.addElement(""bbb"");
    v.addElement(""ccc"");
    v.addElement(""ddd"");
    v.addElement(""eee"");
    Chain c = new Chain(""aaa"");
    head = c;
    c.next = new Chain(""bbb""); c = c.next;
    c.next = new Chain(""ccc""); c = c.next;
    c.next = new Chain(""ddd""); c = c.next;
    c.next = new Chain(""eee"");
    double t;
    t = loopChain();
    System.out.println(""Looping thourgh the chain took "" + t);
    t = loopVector();
    System.out.println(""Looping thourgh the vector took "" + t);
  }
  static
  double loopChain() {
    long before = System.currentTimeMillis();
    Chain c;
    for(int i = 0; i < RUN_LENGTH; i++) {
      c = head;
      while(c != null) {
	tmp = c.s;
	c = c.next;
      }
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double loopVector() {
    long before = System.currentTimeMillis();
    int size = v.size();
    for(int i = 0; i < RUN_LENGTH; i++) {
      for(int j = 0; j < size; j++)
	tmp = (String) v.elementAt(j);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static class Chain {
    public String s;
    public Chain next;
    Chain(String s) {
      this.s = s;
    }
    void setNext(Chain c) {
      next = c;
    }
  }
}
"
org.apache.log4j.performance.Logging,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
//      Copyright 2000, Ceki Gulcu. All Rights Reserved.
//      See the LICENCE file for the terms of distribution.
package org.apache.log4j.performance;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.NDC;
import org.apache.log4j.performance.NOPWriter;
import java.util.Enumeration;
/**
   Measure the performance of logging.
   <p>Experimental results are listed below in units of
   <b>micro-seconds</b>. Measurements were done on a AMD Duron clocked
   at 800Mhz running Windows 2000 and Sun's 1.3 JDK.
<p><table border=1>
<tr>
<th>Layout 
<th>NullAppender 
<th>FileAppender
<th>FileAppender (no flush)
<th>AsyncAppender (no flush)
<tr>
<td>SimpleLayout 
<td>4
<td>21
<td>16
<td>31
<tr>
<td>PatternLayout ""%p - %m%n"" 
<td>4
<td>21
<td>16
<td>31
<tr>
<td>PatternLayout ""%-5p - %m%n""
<td>4
<td>NA
<td>NA
<td>NA
<tr>
<td>TTCCLayout/RELATIVE
<td>10
<td>37
<td>31
<td>45
<tr>
<td>PatternLayout ""%r [%t] %-5p %c{2} %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %.10c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %.20c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA
<tr>
<td>PatternLayout ""%r [%t] %-5p %c - %m%n""
<td>9
<td>36
<td>29
<td>45
<tr>
<td>TTCCLayout/ISO8601
<td>25
<td>58
<td>51
<td>68
<tr>
<td>PatternLayout ""%d{ISO8601} [%t] %-5p %c %x - %m%n""
<td>28
<td>62
<td>55
<td>73
<tr>
<td>PatternLayout ""%d{yyyy-MM-dd HH:mm:ss,SSS} [%t] %-5p %c %x - %m%n""
<td>46
<td>82
<td>72
<td>91
<tr>
<td>PatternLayout ""%l - %m%n""
<td> 1353
<td> 1565
<td> 1474 
<td> 1459 
<tr>
<td>PatternLayout ""%C.%M.%L - %m%n""
<td>1379 
<td>NA
<td>NA
<td>NA
</table>
   <p>The results of the measurements (should) show that:
   <ol>
   <li><b>The PatternLayout perforance is very close to the performance of
   a dedicated layout of equivalent format.</b>
   <p><li>Format specifiers in conversion patterns have almost no impact
   on performance.
   <p>Formating time and date information is costly. Using relative
   time has the least impact on performance. It is recommended that to
   use log4j specific date formatters such as the {@link
   org.apache.log4j.helpers.ISO8601DateFormat} instead of the standard {@link
   java.text.SimpleDateFormat} because of its poor performance. See
   the <b>%d</b> conversion character in {@link
   org.apache.log4j.PatternLayout}.
   <p><li>Avoiding the flush operation at the end of each append
   results in a performance gain of 10 to 20 percent. However, there
   is safety tradeoff invloving in skipping flushing. Indeed, when
   flushing is skipped, then it is likely that the last few log events
   will not be recorded on disk when the application exits. This is a
   high price to pay even for a 20% performance gain.
   <p><li>The <code>AsyncAppender</code> does not automatically
   increase performance. On the contrary, it significantly degrades
   performance. The performance tests done here very quickly fill up
   the bounded buffer of the <code>AsyncAppender</code> and there is
   cosiderable overhead in managing this bounded buffer.
   <p>On the other hand, had we interleaved logging operations with
   long blocking and non CPU-intensive operations, such as I/O,
   network access, sleeping threads, then the
   <code>AsyncAppender</code> would have tremendously reduced the cost
   of logging in terms of overall application runtime.
   <p>In a variant of this test, we have inserted a short sleep
   operation between every 10 log operations. When the total sleept
   time was substracted, logging with the <code>AsyncLogger</code>
   took up no time at all. In other words, logging was done for
   ""free"".
   <p><li>Extracting location information is (comparatively) very
   slow. It should be avoided unless performace is not a concern.
   </ol>
   @author Ceki G&uuml;lc&uuml;
 */
public class Logging {
  static int runLength;
  static int delay = -1;
  /**
     A delay is applied after every <code>burstLen</code> log
     requests.  The default value of this constant is 100.  */
  static  int burstLen = 100;
  static int DELAY_MULT = 1000/burstLen;
  static Category cat = Category.getInstance(""A0123456789.B0123456789.C0123456789"");
  static
  void  Usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java org.apache.log4j.test.Logging confFile runLength delay burstLen\n""+
      ""        confFile is a configuration file and\n""+
      ""        runLength (integer) is the length of test loop.\n""+
      ""        delay is the time in millisecs to wait every bustLen log requests."");
    System.exit(1);
  }
  /**
     <b>Usage:</b> <code>java org.apache.log4j.test.Logging confFile runLength [delay] [burstLen]</code>
     <p><code>confFile</code> is an XML configuration file and
      <code>runLength</code> (integer) is the length of test loop,
      <code>delay</code> is the time in millisecs to sleep every
      <code>bustLen</code> log requests.
      <p>This application just prints the average time it took to log.
   */
  public static void main(String argv[]) {
    if(argv.length == 2)
      init(argv[0], argv[1], null, null);
    else if( argv.length == 4)
      init(argv[0], argv[1], argv[2], argv[3]);
    else
      Usage(""Wrong number of arguments."");
    NDC.push(""some context"");
    double delta;
    String msg = ""ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890"";
     if(delay <= 0) 
      delta = NoDelayLoop(cat, msg);
    else
      delta = DelayedLoop(cat, msg);
    System.out.print((int)delta); 
    // this will close all appenders atatched to root
    //Appender a = Category.getRoot().getAppender(""ASYNC"");
    //if(a != null) {
    //LogLog.debug(""Closing ASYNC."");
    //a.close();
    //}
    Category.getRoot().removeAllAppenders();
    // this will close all appenders attached to all non-root category
    //Enumeration enum = Category.getCurrentCategories();
    //while(enum.hasMoreElements()) {
    //	Category c = (Category) enum.nextElement();
    //	c.removeAllAppenders();
    //}
    //System.out.println(""Garbage collecting.""); 
    System.gc();     System.gc(); 
  }
  /**
    Program wide initialization method.
    */
  static
  void init(String configFile, String runLengthStr, String delayStr, 
	    String burstLenStr) {
    try {
      runLength   = Integer.parseInt(runLengthStr);
      if(delayStr != null) {
	delay = Integer.parseInt(delayStr);
      }
      if(delayStr != null) {
	burstLen = Integer.parseInt(burstLenStr);
	DELAY_MULT = 1000/burstLen;	
      }      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
    }      
    DOMConfigurator.configure(configFile);
  }
  static
  double NoDelayLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
  static
  double DelayedLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    int j = 0;
    Thread currentThread = Thread.currentThread();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
      if(j++ == burstLen) {
	j = 0;
	try{currentThread.sleep(delay);}catch(Exception e){}
      }
    }
    double actualTime = ((System.currentTimeMillis()-before)*1000.0/runLength);
    System.out.println(""actual time: ""+actualTime);
    return (actualTime - delay*DELAY_MULT); 
  }  
}
"
org.apache.log4j.performance.NewVsSetLen,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
/**
   This program compares the cost of creating a new StringBuffer and
   converting it to a String versus keeping the same StringBuffer,
   setting its size to zero and then converting it to String.
   <p>The table below gives some figures.
<p>   <table border=""1"" cellpadding=""4"">
   <tr BGCOLOR=""#33CCFF"">
     <th BGCOLOR=""#CCCCCC"" rowspan=""2"">Total Message length
     <th colspan=""2"" align=""center"">0
     <th colspan=""2"" align=""center"">1
     <th colspan=""2"" align=""center"">2
     <th colspan=""2"" align=""center"">4
     <th colspan=""2"" align=""center"">8
   </tr>
   <tr BGCOLOR=""#3366FF"">
     <td>New Buffer</td> <td>setLength</td> 
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">256 
   <td>33 <td>22 
   <td>34 <td>22
   <td>34 <td>22
   <td>34 <td>22 
   <td>33 <td>23
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1024 
   <td>58 <td>41
   <td>59 <td>45
   <td>59 <td>48
   <td>59 <td>51 
   <td>60 <td>44
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">4096 
   <td>146 <td>132
   <td>138 <td>132
   <td>144 <td>126
   <td>142 <td>132
   <td>136 <td>132 
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">16384 
   <td>617 <td>593 
   <td>593 <td>609
   <td>601 <td>617
   <td>601 <td>632 
   <td>593 <td>632
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">65536 
   <td>3218 <td>3281
   <td>3093 <td>3125 
   <td>3125 <td>3156
   <td>3125 <td>3281 
   <td>3062 <td>3562
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">262144 
   <td>14750 <td>15125
   <td>14000 <td>15500 
   <td>14000 <td>16125 
   <td>14000 <td>18000 
   <td>14000 <td>21375 
   </tr>
   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1048576 
   <td>87500 <td>80000
   <td>60500 <td>82000 
   <td>57000 <td>93000 
   <td>57500 <td>118500 
   <td>57500 <td>168500 
   </tr>
   <caption ALIGN=""BOTTOM"">Performance comparisons of new buffer
   creation versus setLengh(0) approach for various message sizes and
   secondary loop lengths.
   </caption>
   </table>
   <p>The tests copy a message to a destination string buffer and then
   copy a 256 character buffer to another buffer the number of times
   as specified by the secondary loop length.
   <p>The <code>setLength(0)</code> method is usually faster. However,
   after copying a large string it becomes slow even when copying
   small strings.
   <p>This is due to a peculiarity in the <code>copy</code> method in
   StringBuffer class which creates a character array of the same
   length as the old buffer even if the vast majority of those
   characters are unused. 
   <p>The tests were performed on Linux using IBM's JDK 1.1.8.
   <p>The test script is a crude model of what might happen in
   reality. If you remain unconvinced of its results, then please send
   your alternative measurement scenario.
*/
public class NewVsSetLen {
  static String s;
  static int BIGBUF_LEN = 1048576;
  static int SBUF_LEN = 256;
  static int RUN_LENGTH = BIGBUF_LEN/4;
  static char[] sbuf = new char[SBUF_LEN];
  static char[] bigbuf = new char[BIGBUF_LEN];
  {
    for(int i = 0; i < SBUF_LEN; i++) {
      sbuf[i] = (char) (i);
    }
    for(int i = 0; i < BIGBUF_LEN; i++) {
      bigbuf[i] = (char) (i);
    }
  }
  static
  public 
  void main(String[] args) {    
    int t;
    for(int len = SBUF_LEN; len <= BIGBUF_LEN; len*=4, RUN_LENGTH /= 4) {
      System.out.println(""<td>""+len+""\n"");
      for(int second = 0; second < 16;) {
	System.out.println(""SECOND loop=""+second +"", RUN_LENGTH=""
			   +RUN_LENGTH+"", len=""+len);
	t = (int)newBuffer(len, second);;
	System.out.print(""<td>"" + t);
	t = (int)setLen(len, second);
	System.out.println("" <td>"" + t + "" \n"");
	if(second == 0) {
	  second = 1;
	} else {
	  second *= 2;
	}
      }
    }
  }
  static
  double newBuffer(int size, int second) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < RUN_LENGTH; i++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
    }
    for(int x = 0; x <  second; x++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double setLen(int size, int second) {
    long before = System.currentTimeMillis();
    StringBuffer buf = new StringBuffer(SBUF_LEN);
    for(int i = 0; i < RUN_LENGTH; i++) {
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
      buf.setLength(0);
    }
    for(int x = 0; x < second; x++) {
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
      buf.setLength(0);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org.apache.log4j.performance.NOPWriter,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import java.io.Writer;
import java.io.IOException;
/**
  Extends {@link Writer} with methods that return immediately without
  doing anything. This class is used to measure the cost of
  constructing a log message but not actually writing to the
  OutputStream.
  @author  Ceki G&uuml;lc&uuml;
*/
public class NOPWriter extends Writer {
  //public
  //NOPWriter() {
  //}
  public
  void write(char[] cbuf) throws IOException {}
  public
  void write(char[] cbuf, int off, int len) throws IOException {}
  public
  void write(int b) throws IOException {}
  public 
  void write(String s) throws IOException {} 
  public 
  void write(String s, int off, int len) throws IOException {} 
  public 
  void flush() throws IOException {
  }
  public 
  void close() throws IOException {
    System.err.println(""Close called."");
  }
}
"
org.apache.log4j.performance.NotLogging,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.performance;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
/**
   Measure the performance of evaluating whether to log or not to log,
   but not actually logging.
   <p>This program takes two arguments, a string which should be
   ""true"" for testing shipped code performance and ""false"" for testing
   debug-enabled performance the second argument is the run length of
   the measurement loops.
   <p>The results of the measurement (should) show that
   <ul>
   <p>
   <li>Category evaluation is independent of the length of the category name.
   <p>
   <li>As expected, using the {@link Category#isDebugEnabled
   isDebugEnabled} and {@link Category#isInfoEnabled isInfoEnabled}
   methods eliminates the overhead of message argument construction.
   <p> <li>Message argument construction can be an important slowing
   factor while evaluating whether to log or not.
   </ul>
   @author Ceki G&uuml;lc&uuml;
*/
public class NotLogging {
  static int runLength;
  final static int INITIAL_HASH_SIZE = 101; 
  static String  SHORT_MSG = ""Hello World"";
  static Category SHORT_CAT = Category.getInstance(""A0123456789"");
  static Category MEDIUM_CAT= Category.getInstance(""A0123456789.B0123456789"");
  static Category LONG_CAT  = 
                   Category.getInstance(""A0123456789.B0123456789.C0123456789"");
  static Category INEXISTENT_SHORT_CAT = Category.getInstance(""I0123456789"");
  static Category INEXISTENT_MEDIUM_CAT=
                                Category.getInstance(""I0123456789.B0123456789"");
  static Category INEXISTENT_LONG_CAT= 
                     Category.getInstance(""I0123456789.B0123456789.C0123456789"");
  static Category[] CAT_ARRAY = new Category[] {SHORT_CAT, MEDIUM_CAT, 
						LONG_CAT, INEXISTENT_SHORT_CAT,
						INEXISTENT_MEDIUM_CAT,
						INEXISTENT_LONG_CAT};
  static
  void  Usage() {
    System.err.println(
      ""Usage: java org.apache.log4j.test.NotLogging true|false runLength\n"" +
      ""true indicates shipped code, false indicates code in development"" +
      ""  where runLength is an int representing the run length of loops\n""+
      ""We suggest that runLength be at least 100'000."");
    System.exit(1);
  }
  public static void main(String argv[]) {
    if(argv.length != 2) {
      Usage();
    }    
    ProgramInit(argv);
    double delta;
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = SimpleMessage(CAT_ARRAY[i], SHORT_MSG, runLength);
      System.out.println(""Simple argument,          "" + delta 
			 + "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = FullyOptimizedComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Fully optimized complex,  "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = ComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Complex message argument, "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
  }
  /**
    Program wide initialization method.  */
  static
  void ProgramInit(String[] args) {
    try {
      runLength = Integer.parseInt(args[1]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      
    FileAppender appender = new FileAppender(new SimpleLayout(), System.err);
    if(""false"".equals(args[0]))
      ;       
    else if (""true"".equals(args[0])) {
      System.out.println(""Flagging as shipped code."");
      BasicConfigurator.disableInfo();
    }
    else 
      Usage();
    SHORT_CAT.setPriority(Priority.INFO);      
    Category.getRoot().setPriority(Priority.INFO);
  }    
  static
  double SimpleMessage(Category category, String msg, long runLength) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(msg);
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
  static
  double FullyOptimizedComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      if(category.isDebugEnabled())
	category.debug(""Message"" + i + 
		  "" bottles of beer standing on the wall."");
    }    
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
  static
  double ComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(""Message"" + i +
		"" bottles of beer standing on the wall."");
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
}
"
org.apache.log4j.performance.NullAppender,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;
/**
   A bogus appender which calls the format method of its layout object
   but does not write the result anywhere.   
 */
public class NullAppender extends AppenderSkeleton {
  public static String s;
  public String t;	
  public
  NullAppender() {}
  public
  NullAppender(Layout layout) {
    this.layout = layout;
  }
  public
  void close() {}
  public
  void doAppend(LoggingEvent event) {
    if(layout != null) {
      t = layout.format(event);
      s = t;
    }
  }
  public
  void append(LoggingEvent event) {
  }
  /**
     This is a bogus appender but it still uses a layout.
  */
  public
  boolean requiresLayout() {
    return true;
  }  
}
"
org.apache.log4j.performance.SystemTime,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.performance;
/**
   Measures the time required to make a System.currentTimeMillis() and
   Thread.currentThread().getName() calls.
   <p>On an 233Mhz NT machine (JDK 1.1.7B) the
   System.currentTimeMillis() call takes under half a microsecond to
   complete whereas the Thread.currentThread().getName() call takes
   about 4 micro-seconds.
*/
public class SystemTime {
  static int RUN_LENGTH = 1000000;
  static
  public 
  void main(String[] args) {    
    double t = systemCurrentTimeLoop();
    System.out.println(""Average System.currentTimeMillis() call took "" + t);
    t = currentThreadNameloop();
    System.out.println(""Average Thread.currentThread().getName() call took "" 
		       + t);
  }
  static
  double systemCurrentTimeLoop() {
    long before = System.currentTimeMillis();
    long l;
    for(int i = 0; i < RUN_LENGTH; i++) {
      l = System.currentTimeMillis();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }
  static
  double currentThreadNameloop() {
    long before = System.currentTimeMillis();
    String t;
    for(int i = 0; i < RUN_LENGTH; i++) {
      t = Thread.currentThread().getName();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org.apache.log4j.spi.AppenderAttachable,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Appender;
import java.util.Enumeration;
/**
   Interface for attaching appenders to objects.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public interface AppenderAttachable {
  /**
     Add an appender.
   */
  public
  void addAppender(Appender newAppender);
  /**
     Get all previously added appenders as an Enumeration.  */
  public
  Enumeration getAllAppenders();
  /**
     Get  an appender by name.
   */
  public
  Appender getAppender(String name);
  /**
     Remove all previously added appenders.
  */
  void removeAllAppenders();
  /**
     Remove the appender passed as parameter form the list of appenders.
  */
   void removeAppender(Appender appender);
 /**
    Remove the appender with the name passed as parameter form the
    list of appenders.  
  */
 void
 removeAppender(String name);   
}
"
org.apache.log4j.spi.CategoryFactory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Category;
/**
  Implement this interface to create new instances of Category or
  a sub-class of Category.
  <p>See {@link org.apache.log4j.examples.MyCategory} for an example.
  @author Ceki G&uuml;lc&uuml;
  @since version 0.8.5
 */
public interface CategoryFactory {
  public
  Category makeNewCategoryInstance(String name);
}
"
org.apache.log4j.spi.Configurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Hierarchy;
import java.net.URL;
/**
   Implemented by classes capable of configuring log4j using a URL.
   @since 1.0
   @author Anders Kristensen
 */
public interface Configurator {
  /**
     Interpret a resource pointed by a URL and set up log4j accordingly.
     The configuration is done relative to the <code>hierarchy</code>
     parameter.
     @param url The URL to parse
     @param hierarchy The hierarchy to operation upon.
   */
  void doConfigure(URL url, Hierarchy hierarchy);
}
"
org.apache.log4j.spi.ErrorCode,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
/**
   This interface defines commonly encoutered error codes.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0
 */
public interface ErrorCode {
  public final int GENERIC_FAILURE = 0;
  public final int WRITE_FAILURE = 1;
  public final int FLUSH_FAILURE = 2;
  public final int CLOSE_FAILURE = 3;
  public final int FILE_OPEN_FAILURE = 4;
  public final int MISSING_LAYOUT = 5;
  public final int ADDRESS_PARSE_FAILURE = 6;
}
"
org.apache.log4j.spi.ErrorHandler,"/**
  Copyright (c) 2000, Ceki Gulcu
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the ""Software""), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
package org.apache.log4j.spi;
import org.apache.log4j.Appender;
/**
   Appenders may delegate their error handling to ErrorHandlers.
   <p>Error handling is a particularly tedious to get right because by
   definition errors are hard to predict and to reproduce. 
   <p>Please take the time to contact the author in case you discover
   that errors are not properly handled. You are most welcome to
   suggest new error handling policies or criticize existing policies.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public interface ErrorHandler extends OptionHandler {
  /**
     This method should handle the error. Information about the error
     condition is passed a parameter.
     @param message The message assoicated with the error.
     @param e The Exption that was thrown when the error occured.
     @param errorCode The error code associated with the error.
  */
  void error(String message, Exception e, int errorCode);
  /**
     This method prints the error message passed as a parameter.
  */
  void error(String message);
}
"
org.apache.log4j.spi.Filter,"/**
  Copyright (c) 2000, Ceki Gulcu
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the ""Software""), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
package org.apache.log4j.spi;
import org.apache.log4j.spi.LoggingEvent;
/**
   Users should extend this class to implement customized logging
   event filtering. Note that {@link org.apache.log4j.Category} and {@link
   org.apache.log4j.AppenderSkeleton}, the parent class of all standard
   appenders, have built-in filtering rules. It is suggested that you
   first use and understand the built-in rules before rushing to write
   your own custom filters.
   <p>This abstract class assumes and also imposes that filters be
   organized in a linear chain. The {@link #decide
   decide(LoggingEvent)} method of each filter is called sequentially,
   in the order of their addition to the chain.
   <p>The {@link #decide decide(LoggingEvent)} method must return one
   of the integer constants {@link #DENY}, {@link #NEUTRAL} or {@link
   #ACCEPT}.
   <p>If the value {@link #DENY} is returned, then the log event is
   dropped immediately without consulting with the remaining
   filters. 
   <p>If the value {@link #NEUTRAL} is returned, then the next filter
   in the chain is consulted. If there are no more filters in the
   chain, then the log event is logged. Thus, in the presence of no
   filters, the default behaviour is to log all logging events.
   <p>If the value {@link #ACCEPT} is returned, then the log
   event is logged without consulting the remaining filters. 
   <p>The philosophy of log4j filters is largely inspired from the
   Linux ipchains. 
   <p>Note that filtering is only supported by the {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}. The {@link
   org.apache.log4j.PropertyConfigurator PropertyConfigurator} does not
   support filters.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public abstract class Filter implements OptionHandler {
  /**
     Points to the next filter in the filter chain.
   */
  public Filter next;
  /**
     The log event must be dropped immediately without consulting
     with the remaining filters, if any, in the chain.  */
  public static final int DENY    = -1;
  /**
     This filter is neutral with respect to the log event. The
     remaining filters, if any, should be consulted for a final decision.
  */
  public static final int NEUTRAL = 0;
  /**
     The log event must be logged immediately without consulting with
     the remaining filters, if any, in the chain.  */
  public static final int ACCEPT  = 1;
  /**
     Usually filters options become active when set. We provide a
     default do-nothing implementation for convenience.
  */
  public
  void activateOptions() {
  }
  /**     
     <p>If the decision is <code>DENY</code>, then the event will be
     dropped. If the decision is <code>NEUTRAL</code>, then the next
     filter, if any, will be invoked. If the decision is ACCEPT then
     the event will be logged without consulting with other filters in
     the chain.
     @param event The LoggingEvent to decide upon.
     @param decision The decision of the filter.  */
  abstract
  public
  int decide(LoggingEvent event);
}
"
org.apache.log4j.spi.LocationInfo,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.Layout;;
/**
   The internal representation of caller location information.
   @since 0.8.3
*/
public class LocationInfo implements java.io.Serializable {
  /**
     Caller's line number.
  */
  transient String lineNumber;
  /**
     Caller's file name.
  */
  transient String fileName;
  /**
     Caller's fully qualified class name.
  */
  transient String className;
  /**
     Caller's method name.
  */
  transient String methodName;
  /**
     All available caller information, in the format
     <code>fully.qualified.classname.of.caller.methodName(Filename.java:line)</code>
    */
  public String fullInfo;
  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);
  /**
     When location information is not available the constant
     <code>NA</code> is returned. Current value of this string
     constant is <b>?</b>.  */
  public final static String NA = ""?"";
  static final long serialVersionUID = -1325822038990805636L;
  // Check if we are running in IBM's visual age.
  static boolean inVisualAge = false;
  {
    try {
      Class dummy = Class.forName(""com.ibm.uvm.tools.DebugSupport"");
      inVisualAge = true;
      LogLog.debug(""Detected IBM VisualAge environment."");
    } catch(Throwable e) { 
      // nothing to do
    }
  }
  /**
     Instantiate location information based on a Throwable. We
     expect the Throwable <code>t</code>, to be in the format
       <pre>
        java.lang.Throwable
        ...
          at org.apache.log4j.PatternLayout.format(PatternLayout.java:413)
          at org.apache.log4j.FileAppender.doAppend(FileAppender.java:183)
        at org.apache.log4j.Category.callAppenders(Category.java:131)
        at org.apache.log4j.Category.log(Category.java:512)
        at callers.fully.qualified.className.methodName(FileName.java:74)
	...
       </pre>
       <p>However, we can also deal with JIT compilers that ""lose"" the
       location information, especially between the parentheses.
    */
    public LocationInfo(Throwable t, String fqnOfCallingClass) {
      if(t == null)
	return;
/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
      String s;
      // Protect against multiple access to sw.
      synchronized(sw) {
	t.printStackTrace(pw);
	s = sw.toString();
	sw.getBuffer().setLength(0);
      }
      //System.out.println(""s is [""+s+""]."");
      int ibegin, iend;
      // Given the current structure of the package, the line
      // containing ""org.apache.log4j.Category."" should be printed just
      // before the caller.
      // This method of searching may not be fastest but it's safer
      // than counting the stack depth which is not guaranteed to be
      // constant across JVM implementations.      
      ibegin = s.lastIndexOf(fqnOfCallingClass);
      if(ibegin == -1) return;
      ibegin = s.indexOf(Layout.LINE_SEP, ibegin); if(ibegin == -1) return;
      ibegin+= Layout.LINE_SEP_LEN;
      // determine end of line
      iend = s.indexOf(Layout.LINE_SEP, ibegin); if(iend == -1) return;
      // VA has a different stack trace format which doesn't 
      // need to skip the inital 'at'
      if(!inVisualAge) {
	// back up to first blank character
	ibegin = s.lastIndexOf(""at "", iend); if(ibegin == -1) return;
	// Add 3 to skip ""at "";
	ibegin += 3;
      }
      // everything between is the requested stack item
      this.fullInfo = s.substring(ibegin, iend);
    }
    /**
       Return the fully qualified class name of the caller making the
       logging request.
    */
    public
    String getClassName() {      
      if(fullInfo == null) return NA;      
      if(className == null) {
	// Starting the search from '(' is safer because there is
	// potentially a dot between the parentheses.
	int iend = fullInfo.lastIndexOf('(');
	if(iend == -1) 
	  className = NA;
	else {
	  iend = fullInfo.lastIndexOf('.', iend);
	  if(iend == -1) 
	    className = NA;
	  else
	    className = this.fullInfo.substring(0, iend);
	}
      }
      return className;
    }
    /**
       Return the file name of the caller.
       <p>This information is not always available.
    */
    public 
    String getFileName() {
      if(fullInfo == null) return NA;
      if(fileName == null) {
	int iend = fullInfo.lastIndexOf(':');	
	if(iend == -1)
	  fileName = NA;
	else {
	  int ibegin = fullInfo.lastIndexOf('(', iend - 1);
	  fileName = this.fullInfo.substring(ibegin + 1, iend);
	}	
      }
      return fileName;
    }
    /**
       Returns the line number of the caller.
       <p>This information is not always available.       
    */
    public 
    String getLineNumber() {
      if(fullInfo == null) return NA;
      if(lineNumber == null) {
	int iend = fullInfo.lastIndexOf(')');	
	int ibegin = fullInfo.lastIndexOf(':', iend -1);
	if(ibegin == -1)
	  lineNumber = NA;
	else 
	  lineNumber = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return lineNumber;
    }
    /**
       Returns the method name of the caller.
    */
    public
    String getMethodName() {
      if(fullInfo == null) return NA;            
      if(methodName == null) {
	int iend = fullInfo.lastIndexOf('(');	
	int ibegin = fullInfo.lastIndexOf('.', iend);
	if(ibegin == -1)
	  methodName = NA;
	else
	  methodName = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return methodName;
    }
}
"
org.apache.log4j.spi.LoggingEvent,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import org.apache.log4j.helpers.LogLog;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Wolf Siberski
/**
   The internal representation of logging events. When a affirmative
   logging decision is made a <code>LoggingEvent</code> instance is
   created. This instance is passed around the different log4j
   components.
   <p>This class is of concern to those wishing to extend log4j. 
   @author Ceki G&uuml;lc&uuml;
   @author <a href=mailto:jim_cakalic@na.biomerieux.com>Jim Cakalic</a>
   @since 0.8.2 */
public class LoggingEvent implements java.io.Serializable {
  private static long startTime = System.currentTimeMillis();
  ///** Category of logging event. Can not be shipped to remote hosts. */
  //transient public Category category;
  /** Fully qualified name of the calling category class. */
  transient public String fqnOfCategoryClass;
  /** The category name. */
  public String categoryName;
  /** Priority of logging event. Priority cannot be serializable
      because it is a flyweight.
  */
  transient public Priority priority;
  /** The nested diagnostic context (NDC) of logging event. */
  public String ndc;
  /** Have we tried to do an NDC lookup? If we did, there is no need
      to do it again.  Note that its value is always false when
      serialized. Thus, a receiving SocketNode will never use it's own
      (incorrect) NDC. See also writeObject method. */
  public boolean ndcLookupRequired = true;
  /** The application supplied message of logging event. */
  public String message;
  /** The name of thread in which this logging event was generated. */
  public String threadName;
  /** The throwable associated with this logging event.
      This is field is transient because not all exception are
      serializable. More importantly, the stack information does not
      survive serialization.
  */
  transient public Throwable throwable;
  /** This variable collects the info on a throwable. This variable
      will be shipped to 
   */
  public String throwableInformation;
  /** The number of milliseconds elapsed from 1/1/1970 until logging event
      was created. */
  public long timeStamp;
  /** Location information for the caller. */
  public LocationInfo locationInfo;
  // Damn serialization
  static final long serialVersionUID = -868428216207166145L;
  /**
     Instantiate a LoggingEvent from the supplied parameters.
     <p>Except {@link #timeStamp} all the other fields of
     <code>LoggingEvent</code> are filled when actually needed.
     <p>
     @param category The category of this event.
     @param priority The priority of this event.
     @param message  The message of this event.
     @param throwable The throwable of this event.  */
  public LoggingEvent(String fqnOfCategoryClass, Category category, 
		      Priority priority, String message, Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.categoryName = category.getName();
    this.priority = priority;
    this.message = message;
    this.throwable = throwable;
    timeStamp = System.currentTimeMillis();
  }  
  /**
     Returns the time when the application started, in milliseconds
     elapsed since 01.01.1970.  */
  public
  static 
  long getStartTime() {
    return startTime;
  }
  public
  String getNDC() {
    if(ndcLookupRequired) {
      ndcLookupRequired = false;
      ndc = NDC.get();
    }
    return ndc; 
  }
  public
  String getThreadName() {
    if(threadName == null)
      threadName = (Thread.currentThread()).getName();
    return threadName;
  }
  public 
  String getThrowableInformation() {
    if(throwable == null) {
       return null;
    }
    if(throwableInformation == null ) {
      StringWriter sw = new StringWriter();
      PrintWriter pw = new PrintWriter(sw);
      throwable.printStackTrace(pw);
      throwableInformation = sw.toString();
    }
    return throwableInformation;
  }
  private
  void writeObject(ObjectOutputStream oos) throws java.io.IOException {
    // Aside from returning the current thread name the wgetThreadName
    // method sets the threadName variable.
    this.getThreadName();    
    // This call has a side effect of setting this.ndc and
    // setting ndcLookupRequired to false if not already false.
    this.getNDC();
    // This sets the throwableInformation variable to the stack trace
    // of the throwable variable.
    this.getThrowableInformation();
    oos.defaultWriteObject();
    oos.writeInt(priority.toInt());    
  }
  private void readObject(ObjectInputStream ois)
                        throws java.io.IOException, ClassNotFoundException {
    ois.defaultReadObject();    
    priority = Priority.toPriority(ois.readInt());
    // Make sure that no location info is available to Layouts
    if(locationInfo == null)
      locationInfo = new LocationInfo(null, null);
  }
  /**
     Set the location information for this logging event. The collected
     information is cached for future use.
   */
  public
  void setLocationInformation() {
    if(locationInfo == null) {
      locationInfo = new LocationInfo(new Throwable(), fqnOfCategoryClass);
    }
  }
}
"
org.apache.log4j.spi.OptionHandler,"/**
  Copyright (c) 2000, Ceki Gulcu
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the ""Software""), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
package org.apache.log4j.spi;
/**
   A string based interface to configure package components.
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.1
 */
public interface OptionHandler {
  /**
     Activate the options that were previously set with calls to {@link
     #setOption setOption}.
     <p>This allows to defer activiation of the options until all
     options have been set. This is required for components which have
     related options that remain ambigous until all are set.
     <p>For example, the FileAppender has the ""File"" and ""Append"" options
     both of which are ambigous until the other is also set.
  */
  void activateOptions();  
  /**
     Return list of strings that the OptionHandler instance recognizes.
   */
  String[] getOptionStrings();
  /**
     Set <code>option</code> to <code>value</code>.
     <p>The handling of each option depends on the OptionHandler
     instance. Some options may become active immediately whereas
     other may be activated only when {@link #activateOptions} is
     called.
  */
  void setOption(String option, String value);
}
"
org.apache.log4j.spi.RootCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
import  org.apache.log4j.Category;
import  org.apache.log4j.Priority;
import  org.apache.log4j.helpers.LogLog;
/**
   RootCategory sits at the top of the category hierachy. It is a
   regular category except that it provides several guarantees.
   <p>First, it cannot be assigned a <code>null</code>
   priority. Second, since root category cannot have a parent, the
   {@link #getChainedPriority} method always returns the value of the
   priority field without walking the hierarchy.
   @author Ceki G&uuml;lc&uuml;
 */
final public class RootCategory extends Category {
  /**
     The root category names itself as ""root"". However, the root
     category cannot be retrieved by name.  
  */
  public
  RootCategory(Priority priority) {
    super(""root"");
    this.priority = priority;
  }
  /**
     Return the assigned priority value without walking the category
     hierarchy.
  */
  final
  public 
  Priority getChainedPriority() {
    return priority;
  }
  /**
     Setting a null value to the root category may have catastrophic
     results. We prevent this here.
     @since 0.8.3 */
  final  
  public
  void setPriority(Priority priority) {
    if(priority == null) {
      LogLog.error(""You have tried to set a null priority to root."",
		   new Throwable());
    }
    else {
      this.priority = priority;
    }
  }
}
"
org.apache.log4j.spi.TriggeringEventEvaluator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.spi;
/**
   Implementions of this interface allow certain appenders to decide
   when to perform an appender specific action.
  <p>See {@link org.apache.log4j.net.SMTPAppender} for an example of
  an appender that depends on a
  <code>TriggeringEventEvaluators</code>.
  @author Ceki G&uuml;lc&uuml;
  @since version 1.0
 */
public interface TriggeringEventEvaluator {
  /**
     Is this the triggering event?
   */
  public boolean isTriggeringEvent(LoggingEvent event);
}
"
org.apache.log4j.test.Base64,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.
package org.apache.log4j.test;
class Base64 {
  final static int MAX_LINE = 76;
  static byte[] asciiEncoding =
    //A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q  
    {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
    //R  S ...                        Z   a   b   c    d    e    f    g
    82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103,
    //h    i    j    k    l    m    n    o    p    q    r    s   t     u
    104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
    //v    w    x    y    z   0   1   2   3   4   5   6   7   8   9   +   /
    118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47}; 
  static char[] charEnc = new char[64];
  static {
    for(int i = 0; i < 26; i ++) {
      charEnc[i] = (char) ('A' + i);
      charEnc[i+26] = (char) ('a' + i);
    }
    for(int i = 0; i < 10; i ++) {
      charEnc[i+52] = (char) ('0' + i);
    }
    charEnc[62] = '+';
    charEnc[63] = '/';
  }
  static
  String toString(byte[] inbuf) {
    return toString(inbuf, 0, inbuf.length);
  }
  /**
   */
  static
  String toString(byte[] inbuf, int offset, int length) {
    StringBuffer output = new StringBuffer((length)*4/3 + 1);
    int in;
    char[] out = new char[4];
    int i = offset;
    boolean ended = false;
    int last = offset + length;
    int j;
    int bitsRead;
    while(!ended) {
      in = 0;
      bitsRead = 0;
      for(j = 0; j < 3; j++) {
	if(i == last) {
	  ended = true;
	  break;
	}
	in = (in << 8) | (inbuf[i++] & 0xFF);
	bitsRead += 8;
      }
      while(bitsRead >= 6) {
	bitsRead -= 6;
	output.append(charEnc[(in >>> bitsRead) & 0x3F]);
      }
      if(bitsRead == 4) {
	output.append(charEnc[(in & 0x0F) << 2]);
	output.append(""="");
      }
      else if (bitsRead == 2) {
	output.append(charEnc[(in & 0x03) << 4]);
	output.append(""=="");
      }
    }
    return output.toString();
  }
  public static void main(String[] args) {
    byte[] inbuf = new byte[MAX_LINE];
    while(true) {
      try {
	int read = System.in.read(inbuf, 0, MAX_LINE);
	if(read == -1) break;
	System.out.println(""Read "" + read + "" chars."");
	System.out.println(Base64.toString(inbuf, 0, read));
      }
      catch (Exception e) {
	System.out.println(""Exception "" + e);
      }
    }
  }
}
"
org.apache.log4j.test.CategoryWrapper,"package org.apache.log4j.test;
import org.apache.log4j.*;
/**
   This is just to test that wrapper can work. This implementation is
   actually quite bad and should be avoided.
*/
public class CategoryWrapper {
  Category c;
  static String FQCN = CategoryWrapper.class.getName();
  CategoryWrapper(String name) {
    c = Category.getInstance(name);
  }
  public 
  static 
  void main(String argv[]) {    
    Layout layout = new PatternLayout(""%p [%t] %C %F - %m\n"");
    Appender out = new FileAppender(layout, System.out);
    CategoryWrapper w1 = new CategoryWrapper(""c1"");
    w1.addAppender(out);
    w1.print(""hello"");
  }
  public 
  void addAppender(Appender appender) {
    c.addAppender(appender);
  }
  public 
  void print(String msg) {
    // You have to supply the fully qualified named of the wrapper
    // class to the specially tailored category.log method for
    // PatternLayout's %C conversion pattern to work.
    // We have to add the "".print"" string because the invocation of
    // wrapper.print method is made from the wrapper itself (main
    // method). This is highly unusual. The fqcn of the wrapper is
    // normally sufficient.
    c.log(FQCN+"".print"", Priority.DEBUG, msg, null);
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+CategoryWrapper.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.ConfigurationFileParsing,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
public class ConfigurationFileParsing {
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) {
      NDC.push(""testing"");
      PropertyConfigurator.configure(argv[0]);
      Category root = Category.getRoot();
      root.debug(""Message 1"");
      root.debug(""Message 2"");      
      NDC.pop();
    }
    else {
      Usage(""Wrong number of arguments."");
    }
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+ConfigurationFileParsing.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.DefaultInit,"package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
public class DefaultInit {
  static Category cat = Category.getInstance(DefaultInit.class.getName());
  public static void main( String[] argv) {
    cat.debug(""Hello world"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.DefaultInit "");
    System.exit(1);
  }
}
"
org.apache.log4j.test.DelayedLoop,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
/**
   This test program sits in a loop and logs things. Its logging is
   configured by a configuration file. Changes to this configuration
   file are monitored and when a change occurs, the config file is re-read.
   @author Ceki G&uuml;lc&uuml; */
public class DelayedLoop {
  static Category cat = Category.getInstance(DelayedLoop.class);
  static int loopLength;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DelayedLoop.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    if(configFile.endsWith(""xml"")) {
      DOMConfigurator.configureAndWatch(configFile, 3000);
    } else {
      PropertyConfigurator.configureAndWatch(configFile, 3000);
    }
  }
  static
  void test() {
    int i = 0;
    while(true) {
      cat.debug(""MSG ""+i++);
      try {
	Thread.currentThread().sleep(1000);
      } catch(Exception e) {}
    }
  }
}
"
org.apache.log4j.test.Finalize,"package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Enumeration;
public class Finalize {
  static Category CAT = Category.getInstance(Finalize.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Finalize.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    InputStreamReader in = new InputStreamReader(System.in);	    
    Category root = Category.getRoot();
    System.out.println(""Type 'q' to quit"");
    int j = 0;
    while (true) {
      System.gc();      
      try {i = in.read(); }
      catch(Exception e) { return; }
      System.gc();
      System.out.println(""Read [""+i+""]."");
      if(i == -1)
	break;
      else if(i == 'q')
	break;
      else 
	root.debug(""Hello "" + (++j));
    } 
    //foo(root);
    root.removeAllAppenders();
    System.gc(); delay(3000);
    System.gc(); delay(3000);    
    System.gc(); delay(3000);  System.gc();
  }
  static
  void foo(Category cat) {    
    Enumeration enum = cat.getAllAppenders();
    while(enum != null && enum.hasMoreElements()) {
      ((org.apache.log4j.Appender) enum.nextElement()).close();
    }
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.Hello,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
/**
   Very simple log4j usage example.
   @author  Ceki G&uuml;lc&uuml;   
 */
public class Hello {
  static Category cat = Category.getInstance(Hello.class);
  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    cat.debug(""Hello world."");
    cat.info(""What a beatiful day."");
  }
}
"
org.apache.log4j.test.L7D,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
// 
//      See the LICENCE file for the terms of distribution.
package org.apache.log4j.test; 
import org.apache.log4j.*;
import java.util.*;
import java.text.*;
/**
   This class is a simple test of the localization routines in
   Category class.
   @author Ceki G&uuml;lc&uuml;, IBM Zurich Research Laboratory */
public class L7D {
  static ResourceBundle[] bundles;
  public 
  static 
  void main(String args[]) {
    if(args.length == 3) 
      init(args[0], args[1], args[2]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + L7D.class.getName() +
			""configFile ISO639LanguageCode ISO2166CountryCode"");
    System.exit(1);
  }
  static
  void init(String configFile, String lanCode, String countryCode) {
    PropertyConfigurator.configure(configFile);
    bundles = new ResourceBundle[3];
    try {
      bundles[0] = ResourceBundle.getBundle(""L7D"", new Locale(""en"", ""US""));
      bundles[1] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""FR""));
      bundles[2] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""CH"")); 
    }
    catch(MissingResourceException e) {
      e.printStackTrace();
    }
  }
  static
  void test() { 
    Category root = Category.getRoot();
    for(int i = 0; i < bundles.length; i++) {
      root.setResourceBundle(bundles[i]);
      root.l7dlog(Priority.DEBUG, ""bogus1"", null);            
      root.l7dlog(Priority.INFO, ""test"", null);
      root.l7dlog(Priority.WARN, ""hello_world"", null);
      root.l7dlog(Priority.DEBUG, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.ERROR, ""bogusMsg"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);      
      root.l7dlog(Priority.ERROR, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.INFO, ""bogus2"", null);
    }
  }
}
"
org.apache.log4j.test.Min,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test; 
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.Appender;
import org.apache.log4j.FileAppender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.TTCCLayout;
import org.apache.log4j.Priority;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import java.io.IOException;
/**
   This class tests the functionality of the Log class and the
   different layouts.
   @author  Ceki G&uuml;lc&uuml;
*/
public class Min {
  public 
  static 
  void main(String argv[]) {
      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test1();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.Min "" +
			""simple|ttcc"");
    System.exit(1);
  }
  /**
    Program wide initialization method.
    */
  static
  void ProgramInit(String layoutType) {
    Appender appender = null;	
    Layout layout = null;
    if(layoutType.equals(""simple"")) 
      layout = new SimpleLayout();
    else if(layoutType.equals(""ttcc"")) {
      layout = new TTCCLayout(AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT);
    }
    else 
      Usage(""Wrong layoutType ["" + layoutType +""]."");
    appender = new FileAppender(layout, System.out);
    BasicConfigurator.configure(appender);
  }
  static
  void test1() {
    int i = 0;
    // In the lines below, the category names are chosen as an aid in
    // remembering their priority values. In general, the category
    // names should have no bearing to priority values.
    Category ERR = Category.getInstance(""ERR"");
    ERR.setPriority(Priority.ERROR);
    Category INF = Category.getInstance(""INF"");
    INF.setPriority(Priority.INFO);
    Category INF_ERR = Category.getInstance(""INF.ERR"");
    INF_ERR.setPriority(Priority.ERROR);
    Category DEB = Category.getInstance(""DEB"");
    DEB.setPriority(Priority.DEBUG);
    // Note: categories with undefined priority 
    Category INF_UNDEF = Category.getInstance(""INF.UNDEF"");
    Category INF_ERR_UNDEF = Category.getInstance(""INF.ERR.UNDEF"");    
    Category UNDEF = Category.getInstance(""UNDEF"");   
    // These should all log.----------------------------
    ERR.log(Priority.FATAL, ""Message "" + i); i++;  //0
    ERR.error( ""Message "" + i); i++;          
    INF.log(Priority.FATAL, ""Message "" + i); i++; // 2
    INF.error( ""Message "" + i); i++;         
    INF.warn ( ""Message "" + i); i++; 
    INF.info ( ""Message "" + i); i++;
    INF_UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  //6
    INF_UNDEF.error( ""Message "" + i); i++;         
    INF_UNDEF.warn ( ""Message "" + i); i++; 
    INF_UNDEF.info ( ""Message "" + i); i++; 
    INF_ERR.log(Priority.FATAL, ""Message "" + i); i++;  // 10
    INF_ERR.error( ""Message "" + i); i++;  
     INF_ERR_UNDEF.log(Priority.FATAL, ""Message "" + i); i++; 
    INF_ERR_UNDEF.error( ""Message "" + i); i++;             
    DEB.log(Priority.FATAL, ""Message "" + i); i++;  //14
    DEB.error( ""Message "" + i); i++;         
    DEB.warn ( ""Message "" + i); i++; 
    DEB.info ( ""Message "" + i); i++; 
    DEB.debug( ""Message "" + i); i++; 
    // defaultPriority=DEBUG
    UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  // 19
    UNDEF.error(""Message "" + i); i++;         
    UNDEF.warn (""Message "" + i); i++; 
    UNDEF.info (""Message "" + i); i++; 
    UNDEF.debug(""Message "" + i, new Exception(""Just testing."")); i++;    
    // -------------------------------------------------
    // The following should not log
    ERR.warn(""Message "" + i);  i++; 
    ERR.info(""Message "" + i);  i++; 
    ERR.debug(""Message "" + i);  i++; 
    INF.debug(""Message "" + i);  i++; 
    INF_UNDEF.debug(""Message "" + i); i++; 
    INF_ERR.warn(""Message "" + i);  i++; 
    INF_ERR.info(""Message "" + i);  i++; 
    INF_ERR.debug(""Message "" + i); i++; 
    INF_ERR_UNDEF.warn(""Message "" + i);  i++; 
    INF_ERR_UNDEF.info(""Message "" + i);  i++; 
    INF_ERR_UNDEF.debug(""Message "" + i); i++; 
    // -------------------------------------------------
    INF.info(""Messages should bear numbers 0 through 23."");
  }     
}
"
org.apache.log4j.test.MultipleAppenders,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Appender;
import java.util.Enumeration;
import java.util.Vector;
public class MultipleAppenders {
  public 
  static 
  void main(String argv[]) {
    // A1 and A2 should be added to root by reading the config file
    PropertyConfigurator.configure(argv[0]);
    Category root = Category.getRoot();
    Enumeration e1 = root.getAllAppenders();
    Vector v = new Vector(1);
    while(e1.hasMoreElements()) {
      Appender a = (Appender) e1.nextElement();
      v.addElement(a);
      String appenderName = a.getName();	
      if(a != root.getAppender(appenderName)) {
	System.out.println(appenderName + "" lookup failed. Exiting."");
	System.exit(1);
      }
      // attempt to add the existing appender
      root.addAppender(a);
    }
    // attempt to add a null appender
    root.addAppender(null);
    Enumeration e2 = root.getAllAppenders();
    for(int i = 0; i < v.size(); i++) {
      if(v.elementAt(i) != e2.nextElement()) {
      }
    }
    if(e2.hasMoreElements()){
      System.out.println(""Failure, e2 has remaining elements. Exiting."");
      System.exit(1);      
    }
    System.out.println(""OK"");
  }
}
"
org.apache.log4j.test.PatternTest,"package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
/**
   This class is a test of the PatternLayout class.
   @author Ceki G&uuml;lc&uuml;
*/
public class PatternTest {
  static Category CAT = Category.getInstance(PatternTest.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + PatternTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    CAT.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    CAT.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    CAT.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    CAT.error(""Message "" + ++i);
    root.error(""Message "" + i);
    CAT.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    CAT.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    CAT.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);    
    CAT.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);    
    CAT.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
    CAT.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);    
  }
}
"
org.apache.log4j.test.ROFile,"package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.io.IOException;
public class ROFile {
  static Category cat = Category.getInstance(ROFile.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + ROFile.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    cat.debug(""Message "" + ++i);
  }
}
"
org.apache.log4j.test.Shallow,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
// NOTICE: Some test are sensitive to line numbers!
package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.util.Enumeration;
/**
   This class is a shallow test of the various appenders and
   layouts. It also tests their reading of the configuration file.
   @author  Ceki G&uuml;lc&uuml;
*/
public class Shallow {
  static Category cat = Category.getInstance(Shallow.class);
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ Shallow.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1; 
    NDC.push(""NDC""); 
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    cat.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);    
    cat.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);    
    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
    cat.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);    
    // It is always a good idea to call this method when exiting an
    // application.
    Category.shutdown();    
    System.gc(); 
  }
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org.apache.log4j.test.ShippedCodeFlagTest,"package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
public class ShippedCodeFlagTest {
  static Category CAT=Category.getInstance(ShippedCodeFlagTest.class.getName());
  public static void main( String[] argv) {
    String type = null;
    if(argv.length == 1) 
      type = argv[0];
    else 
      Usage(""Wrong number of arguments."");
    if(type.equals(""basic"")) {
       System.out.println(""System property \""""+
			  BasicConfigurator.DISABLE_OVERRIDE_KEY +
			  ""\"" is set to [""+
		  System.getProperty(BasicConfigurator.DISABLE_OVERRIDE_KEY)
			  +""]."");
       BasicConfigurator.configure(new FileAppender(new SimpleLayout(),
						 System.out));
    }
    else { 
      PropertyConfigurator.configure(type);
    }
    BasicConfigurator.disableInfo();       
    CAT.debug(""Hello world"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.ShippedCodeFlagTest "" +
			""basic|configFile"");
    System.exit(1);
  }
}
"
org.apache.log4j.test.ShortSocketServer,"package org.apache.log4j.test;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.net.SocketNode;
import org.apache.log4j.net.SocketServer;
/**
*/
public class ShortSocketServer  {
  static Category cat = Category.getInstance(ShortSocketServer.class.getName());
  static int port;
  static int delay;
  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1], argv[2]);
    else 
      usage(""Wrong number of arguments."");     
    try {
      LogLog.debug(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      LogLog.debug(""Waiting to accept a new client."");
      Socket socket = serverSocket.accept();
      LogLog.debug(""Connected to client at "" + socket.getInetAddress());
      LogLog.debug(""Starting new socket node."");	
      SocketNode sn = new SocketNode(socket, Category.getDefaultHierarchy());
      Thread t = new Thread(sn);
      t.start(); 
      t.join();
    }
    catch(Exception e) {
      cat.error(""Error while in main."", e);
    }
  }
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +ShortSocketServer.class.getName() + 
                    "" port configFile delay"");
    System.exit(1);
  }
  static
  void init(String portStr, String configFile, String delayStr) {
    try {
      port   = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    try {
      delay  = Integer.parseInt(delayStr);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret delay number [""+ delayStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
org.apache.log4j.test.SpacePad,"package org.apache.log4j.test;
public class SpacePad {
  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32
  static public void main(String[] args) {
    StringBuffer sbuf = new StringBuffer();
    for(int i = 0; i < 35; i++) {
      sbuf.setLength(0);
      sbuf.append(""\"""");
      spacePad(sbuf, i);
      sbuf.append(""\"""");
      System.out.println(sbuf.toString());
    }
    sbuf.setLength(0);
    sbuf.append(""\"""");
    spacePad(sbuf, 67);
    sbuf.append(""\"""");
    System.out.println(sbuf.toString());
  }
  static
  public
  void spacePad(StringBuffer sbuf, int length) {
    //LogLog.debug(""Padding with "" + length + "" spaces."");
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org.apache.log4j.test.StressAsyncAppender,"//  Copyright 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.util.Random;
import java.util.Stack;
/**
   Stress test {@link AsyncAppender}.
 */
public class StressAsyncAppender extends Thread {
  static Category root = Category.getRoot();  
  static Random random = new Random(101);
  static final int LOOP_LENGTH = 24;
  static final int BRANCHING_FACTOR = 4;
  static int maxThreads;  
  static long msgCounter = 0;
  static int threadCounter = 0;  
  static double LOG_2 = Math.log(2);
  static Object lock = new Object();
  public 
  static 
  void main(String args[]) {
    if(args.length != 1) {
      usage();
    }
    DOMConfigurator.configure(""stressAsyncAppender.xml"");
    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created. 	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);
	// wait until all threads are finished
	try {
	  root.debug(""About to wait for notification."");
	  lock.wait();
	  root.debug(""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }
  static
  void usage() {
    System.err.println(""Usage: java ""+ StressAsyncAppender.class.getName() +
			"" MAX_THREADS"");
    System.exit(1);
  }
  public
  StressAsyncAppender() {
  }
  public
  void run() {
    int loopLength = StressAsyncAppender.randomInt(LOOP_LENGTH);
    root.debug(""In run loop, loopLength = ""+loopLength);
    // half of the way, create new childres
    int createIndex = loopLength/2;
    for(int i = 0; i <= loopLength; i++) {
      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      synchronized(lock) {      
	root.debug(""Message number "" + msgCounter++);	
      }
      //delay(1+randomInt(4)*100);
    }    
    synchronized(lock) {
      StressAsyncAppender.threadCounter--;
      root.debug(""Exiting run loop. "" + threadCounter);
      if(StressAsyncAppender.threadCounter <= 0) {
	root.debug(""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }
  }
  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;
    synchronized(lock) {
      n = maxThreadsConstrained(n);    
      root.debug(""Creating "" + n+ "" child StressAsyncAppender threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressAsyncAppender, threadCounter = "" + (++threadCounter));
	new StressAsyncAppender().start();
      }
    }
  }
  static
  public
  int maxThreadsConstrained(int a) {
    int maxAllowed = StressAsyncAppender.maxThreads - 
                                                 StressAsyncAppender.threadCounter;
    return a <= maxAllowed ? a : maxAllowed;
  }
  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }
  public
  void delay(long millis) {
    try {
      Thread.currentThread().sleep(millis);
    } catch(Exception e) {}
  }
}
"
org.apache.log4j.test.StressNDC,"//      Copyright 1996-1999, International Business Machines 
//      Corporation and others. All Rights Reserved.
package org.apache.log4j.test;
import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.util.Random;
import java.util.Stack;
/**
   Stress test {@link NDC}.
 */
public class StressNDC extends Thread {
  static Category root = Category.getRoot();  
  static Random random = new Random(101);
  static final int LOOP_LENGTH = 24;
  static final int PUSH_MISS = LOOP_LENGTH/2;      
  static final int POP_MISS = PUSH_MISS*2;    
  static final int BRANCHING_FACTOR = 4 + 1; // add 1 to the number you want
  static int maxThreads;  
  static int msgCounter = 0;
  static int threadCounter = 0;  
  static double LOG_2 = Math.log(2);
  static Object lock = new Object();
  public 
  static 
  void main(String args[]) {
    root.setPriority(Priority.DEBUG);
    BasicConfigurator.configure();
    if(args.length != 1) {
      usage();
    }
    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    root.debug( ""push(IP=127.0.0.1)"");
    NDC.push(""IP=127.0.0.1"");
    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created. 	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);
	// wait until all threads are finished
	try {
	  root.debug( ""About to wait for notification."");
	  lock.wait();
	  root.debug( ""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }
  static
  void usage() {
    System.err.println( ""Usage: java org.apache.log4j.test.StressNDC "" +
			""MAX_THREADS"");
    System.exit(1);
  }
  Stack parentDC;
  public
  StressNDC(Stack parentDC) {
    this.setName(randomID());
    this.parentDC = parentDC;
  }
  public
  void run() {
    NDC.inherit(parentDC);
    int loopLength = StressNDC.randomInt(LOOP_LENGTH);
    root.debug(""In run loop.debug( loopLength = ""+loopLength);
    int createIndex = loopLength/2;
    for(int i = 0; i <= loopLength; i++) {
      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      if(randomInt(PUSH_MISS) == 0) {
	String id = randomID();
	root.debug( ""push(""+id+"")""); 
	NDC.push(id);
      }      
      root.debug( ""Message number "" + StressNDC.msgCounter++);	
      if(randomInt(POP_MISS) == 0) {
	root.debug( ""pop()"");
	NDC.pop();
      }
    }    
    synchronized(lock) {
      StressNDC.threadCounter--;
      root.debug( ""Exiting run loop. "" + threadCounter);
      if(StressNDC.threadCounter <= 0) {
	root.debug( ""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }
    // We sometimes forget to remove references
    if((loopLength % 2) == 0) {
      root.debug(""Removing NDC for this thread."");
      NDC.remove();
    }
  }
  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;
    synchronized(lock) {
      n = maxThreadsConstained(n);    
      root.debug(""Creating "" + n+ "" child StressNDC threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressNDC, threadCounter = "" + (++threadCounter));
	new StressNDC(NDC.cloneStack()).start();
      }
    }
  }
  static
  public
  int maxThreadsConstained(int a) {
    int maxAllowed = StressNDC.maxThreads - StressNDC.threadCounter;      
    return a <= maxAllowed ? a : maxAllowed;
  }
  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }
  public
  static
  String randomID() {
    return Integer.toHexString(random.nextInt()& 0xFFFFFF);
  }
}
"
org.apache.log4j.test.SysoutConfigurator,"package org.apache.log4j.test;
import java.util.Properties;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
/**
 * This configurator simply always adds a FileAppender writing to
 * System.out to the root Category and ignores whatever is in the
 * properties file.
 */
public class SysoutConfigurator implements Configurator {
  public
  void
  doConfigure(java.net.URL url, Hierarchy hierarchy) {
    Category.getRoot().addAppender(
        new FileAppender(
            new SimpleLayout(), System.out));
  }
}
"
org.apache.log4j.test.TP,"//      Copyright 1996-2000, International Business Machines 
//      Corporation and others. All Rights Reserved.
package org.apache.log4j.test; 
import org.apache.log4j.*;
import org.apache.log4j.gui.TextPaneAppender;
import javax.swing.JFrame;
import javax.swing.JTextPane;
import java.awt.Dimension;
public class TP {
  static Category cat = Category.getInstance(TP.class.getName());
  public 
  static 
  void main(String argv[]) {
    JFrame frame = new JFrame(""asdasd"");
    Category root = Category.getRoot();
    PatternLayout layout = new PatternLayout(""%p [%t] $c{2} %m\n"");
    TextPaneAppender ap = new TextPaneAppender(layout, ""c"");
    JTextPane textPane = ap.getTextPane();
    textPane.setPreferredSize(new Dimension(200, 200));
    frame.getContentPane().add(textPane);
    frame.pack();
    ap.getTextPane().setVisible(true);    
    frame.setVisible(true);
    root.addAppender(ap);
    cat.debug(""Message 1."");
    cat.debug(""Message 2."");    
  }
}
"
org.apache.log4j.test.UnitTestBoundedFIFO,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
//
// Log4j uses the JUnit framework for internal unit testing. JUnit
// available from
//
//     http://www.junit.org
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.BoundedFIFO;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.TestFailure;
import junit.framework.Test;
/**
   Unit test the {@link BoundedFIFO}.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public class UnitTestBoundedFIFO extends TestCase {
  static Category cat = Category.getInstance(""x"");
  static int MAX = 1000;  
  static LoggingEvent[] e = new LoggingEvent[MAX];
  {
    for (int i = 0; i < MAX; i++) {
      e[i] =  new LoggingEvent("""", cat, Priority.DEBUG, ""e""+i, null);
    }
  }
  public UnitTestBoundedFIFO(String name) {
    super(name);
  }
  public
  void setUp() {
  }
  /**
     Pattern: +++++..-----..
   */
  public
  void test1() {
    for(int size = 1; size <= 128; size *=2) {
      BoundedFIFO bf = new BoundedFIFO(size);
      assertEquals(bf.getMaxSize(), size);
      assertNull(bf.get());
      int i;
      int j;
      int k;
      for(i = 1; i < 2*size; i++) {      
	for(j = 0; j < i; j++) {
	  //System.out.println(""Putting ""+e[j]);
	  bf.put(e[j]); assertEquals(bf.length(), j < size ?  j+1 : size);
	}
	int max = size < j ? size : j;
	j--;
	for(k = 0; k <= j; k++) {	  
	  //System.out.println(""max=""+max+"", j=""+j+"", k=""+k);
	  assertEquals(bf.length(), max - k > 0 ? max - k : 0); 
	  Object r = bf.get();
	  //System.out.println(""Got ""+r);
	  if(k >= size) 
	    assertNull(r);
	  else 
	    assertEquals(r, e[k]);
	}
      }
      System.out.println(""Passed size=""+size);
    }
  }
  /**
     Pattern: ++++--++--++
   */
  public
  void test2() {
    int size = 3;
    BoundedFIFO bf = new BoundedFIFO(size);
    bf.put(e[0]);	
    assertEquals(bf.get(), e[0]);
    assertNull(bf.get());
    bf.put(e[1]); assertEquals(bf.length(), 1);
    bf.put(e[2]); assertEquals(bf.length(), 2);
    bf.put(e[3]); assertEquals(bf.length(), 3);
    assertEquals(bf.get(), e[1]); assertEquals(bf.length(), 2);
    assertEquals(bf.get(), e[2]); assertEquals(bf.length(), 1);
    assertEquals(bf.get(), e[3]); assertEquals(bf.length(), 0);
    assertNull(bf.get()); assertEquals(bf.length(), 0);
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestBoundedFIFO(""test1""));
    suite.addTest(new UnitTestBoundedFIFO(""test2""));
    return suite;
  }
}
"
org.apache.log4j.test.UnitTestCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.FileAppender;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.RootCategory;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.Test;
import java.util.Enumeration;
import java.util.ResourceBundle;
import java.util.Locale;
/**
   Used for internal unit testing the Category class.
   @author Ceki G&uuml;lc&uuml;
*/
public class UnitTestCategory extends TestCase {
  Category cat;
  Appender a1;
  Appender a2;
  ResourceBundle rbUS;
  ResourceBundle rbFR; 
  ResourceBundle rbCH; 
  // A short message.
  static String MSG = ""M"";
  public UnitTestCategory(String name) {
    super(name);
  }
  public
  void setUp() {
    rbUS = ResourceBundle.getBundle(""L7D"", new Locale(""en"", ""US""));
    assertNotNull(rbUS);
    rbFR = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""FR""));
    assertNotNull(""Got a null resource bundle."", rbFR);
    rbCH = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""CH""));
    assertNotNull(""Got a null resource bundle."", rbCH);
  }
  public
  void tearDown() {
    // Regular users should not use the clear method lightly!
    Category.getDefaultHierarchy().clear();
    BasicConfigurator.resetConfiguration();
    a1 = null;
    a2 = null;
  }
  /**
     Add an appender and see if it can be retrieved.
  */
  public
  void testAppender1() {
    cat = Category.getInstance(""test"");
    a1 = new FileAppender();
    a1.setName(""testAppender1"");             
    cat.addAppender(a1);
    Enumeration enum = cat.getAllAppenders();
    Appender aHat = (Appender) enum.nextElement();    
    assertEquals(a1, aHat);    
  }
  /**
     Add an appender X, Y, remove X and check if Y is the only
     remaining appender.
  */
  public
  void testAppender2() {
    a1 = new FileAppender();
    a1.setName(""testAppender2.1"");           
    a2 = new FileAppender();
    a2.setName(""testAppender2.2"");           
    cat = Category.getInstance(""test"");
    cat.addAppender(a1);
    cat.addAppender(a2);    
    cat.removeAppender(""testAppender2.1"");
    Enumeration enum = cat.getAllAppenders();
    Appender aHat = (Appender) enum.nextElement();    
    assertEquals(a2, aHat);
    assert(!enum.hasMoreElements());
  }
  /**
     Test if category a.b inherits its appender from a.
   */
  public
  void testAdditivity1() {
    Category a = Category.getInstance(""a"");
    Category ab = Category.getInstance(""a.b"");
    CountingAppender ca = new CountingAppender();
    a.addAppender(ca);
                   assertEquals(ca.counter, 0);
    ab.debug(MSG); assertEquals(ca.counter, 1);
    ab.info(MSG);  assertEquals(ca.counter, 2);
    ab.warn(MSG);  assertEquals(ca.counter, 3);
    ab.error(MSG); assertEquals(ca.counter, 4);    
  }
  /**
     Test multiple additivity.
   */
  public
  void testAdditivity2() {
    Category a = Category.getInstance(""a"");
    Category ab = Category.getInstance(""a.b"");
    Category abc = Category.getInstance(""a.b.c"");
    Category x   = Category.getInstance(""x"");
    CountingAppender ca1 = new CountingAppender();
    CountingAppender ca2 = new CountingAppender();
    a.addAppender(ca1);
    abc.addAppender(ca2);
    assertEquals(ca1.counter, 0); 
    assertEquals(ca2.counter, 0);        
    ab.debug(MSG);  
    assertEquals(ca1.counter, 1); 
    assertEquals(ca2.counter, 0);        
    abc.debug(MSG);
    assertEquals(ca1.counter, 2); 
    assertEquals(ca2.counter, 1);        
    x.debug(MSG);
    assertEquals(ca1.counter, 2); 
    assertEquals(ca2.counter, 1);    
  }
  /**
     Test additivity flag.
   */
  public
  void testAdditivity3() {
    Category root = Category.getRoot();    
    Category a = Category.getInstance(""a"");
    Category ab = Category.getInstance(""a.b"");
    Category abc = Category.getInstance(""a.b.c"");
    Category x   = Category.getInstance(""x"");
    CountingAppender caRoot = new CountingAppender();
    CountingAppender caA = new CountingAppender();
    CountingAppender caABC = new CountingAppender();
    root.addAppender(caRoot);
    a.addAppender(caA);
    abc.addAppender(caABC);
    assertEquals(caRoot.counter, 0); 
    assertEquals(caA.counter, 0); 
    assertEquals(caABC.counter, 0);        
    ab.setAdditivity(false);
    a.debug(MSG);  
    assertEquals(caRoot.counter, 1); 
    assertEquals(caA.counter, 1); 
    assertEquals(caABC.counter, 0);        
    ab.debug(MSG);  
    assertEquals(caRoot.counter, 1); 
    assertEquals(caA.counter, 1); 
    assertEquals(caABC.counter, 0);        
    abc.debug(MSG);  
    assertEquals(caRoot.counter, 1); 
    assertEquals(caA.counter, 1); 
    assertEquals(caABC.counter, 1);        
  }
  public
  void testDisable1() {
    CountingAppender caRoot = new CountingAppender();
    Category root = Category.getRoot();    
    root.addAppender(caRoot);
    BasicConfigurator.disableDebug();
    assertEquals(caRoot.counter, 0);     
    root.debug(MSG); assertEquals(caRoot.counter, 0);  
    root.info(MSG); assertEquals(caRoot.counter, 1);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 2);  
    root.warn(MSG); assertEquals(caRoot.counter, 3);  
    BasicConfigurator.disableInfo();
    root.debug(MSG); assertEquals(caRoot.counter, 3);  
    root.info(MSG); assertEquals(caRoot.counter, 3);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 4);  
    root.error(MSG); assertEquals(caRoot.counter, 5);  
    root.log(Priority.ERROR, MSG); assertEquals(caRoot.counter, 6);  
    BasicConfigurator.disableAll();
    root.debug(MSG); assertEquals(caRoot.counter, 6);  
    root.info(MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 6);  
    root.error(MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.FATAL, MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.FATAL, MSG); assertEquals(caRoot.counter, 6);  
    BasicConfigurator.disable(Priority.FATAL);
    root.debug(MSG); assertEquals(caRoot.counter, 6);  
    root.info(MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.WARN, MSG); assertEquals(caRoot.counter, 6);  
    root.error(MSG); assertEquals(caRoot.counter, 6);
    root.log(Priority.ERROR, MSG); assertEquals(caRoot.counter, 6);  
    root.log(Priority.FATAL, MSG); assertEquals(caRoot.counter, 6);  
  }
  public
  void testRB1() {
    Category root = Category.getRoot(); 
    root.setResourceBundle(rbUS);
    ResourceBundle t = root.getResourceBundle();
    assertSame(t, rbUS);
    Category x = Category.getInstance(""x"");
    Category x_y = Category.getInstance(""x.y"");
    Category x_y_z = Category.getInstance(""x.y.z"");
    t = x.getResourceBundle();     assertSame(t, rbUS);
    t = x_y.getResourceBundle();   assertSame(t, rbUS);
    t = x_y_z.getResourceBundle(); assertSame(t, rbUS);
  }
  public
  void testRB2() {
    Category root = Category.getRoot(); 
    root.setResourceBundle(rbUS);
    ResourceBundle t = root.getResourceBundle();
    assertSame(t, rbUS);
    Category x = Category.getInstance(""x"");
    Category x_y = Category.getInstance(""x.y"");
    Category x_y_z = Category.getInstance(""x.y.z"");
    x_y.setResourceBundle(rbFR);
    t = x.getResourceBundle();     assertSame(t, rbUS);
    t = x_y.getResourceBundle();   assertSame(t, rbFR);
    t = x_y_z.getResourceBundle(); assertSame(t, rbFR);    
  }
  public
  void testRB3() {
    Category root = Category.getRoot(); 
    root.setResourceBundle(rbUS);
    ResourceBundle t = root.getResourceBundle();
    assertSame(t, rbUS);
    Category x = Category.getInstance(""x"");
    Category x_y = Category.getInstance(""x.y"");
    Category x_y_z = Category.getInstance(""x.y.z"");
    x_y.setResourceBundle(rbFR);
    x_y_z.setResourceBundle(rbCH);
    t = x.getResourceBundle();     assertSame(t, rbUS);
    t = x_y.getResourceBundle();   assertSame(t, rbFR);
    t = x_y_z.getResourceBundle(); assertSame(t, rbCH);    
  }
  public
  void testExists() {
    Category a = Category.getInstance(""a"");
    Category a_b = Category.getInstance(""a.b"");
    Category a_b_c = Category.getInstance(""a.b.c"");
    Category t;
    t = Category.exists(""xx"");    assertNull(t);
    t = Category.exists(""a"");     assertSame(a, t);
    t = Category.exists(""a.b"");   assertSame(a_b, t);
    t = Category.exists(""a.b.c""); assertSame(a_b_c, t);
  }
  public
  void testHierarchy1() {
    Hierarchy h = new Hierarchy( new RootCategory(Priority.ERROR));
    Category a0 = h.getInstance(""a"");
    assertEquals(""a"", a0.getName());
    assertNull(a0.getPriority());
    assertSame(Priority.ERROR, a0.getChainedPriority());
    Category a1 = h.getInstance(""a"");
    assertSame(a0, a1);
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestCategory(""testAppender1""));
    suite.addTest(new UnitTestCategory(""testAppender2""));
    suite.addTest(new UnitTestCategory(""testAdditivity1""));        
    suite.addTest(new UnitTestCategory(""testAdditivity2""));        
    suite.addTest(new UnitTestCategory(""testAdditivity3""));        
    suite.addTest(new UnitTestCategory(""testDisable1""));        
    suite.addTest(new UnitTestCategory(""testRB1""));        
    suite.addTest(new UnitTestCategory(""testRB2""));        
    suite.addTest(new UnitTestCategory(""testRB3""));        
    suite.addTest(new UnitTestCategory(""testExists""));        
    suite.addTest(new UnitTestCategory(""testHierarchy1""));        
    return suite;
  }
  static private class CountingAppender extends AppenderSkeleton {
    int counter;
    CountingAppender() {
      counter = 0;
    }
    public void close() {
    }
    public
    void append(LoggingEvent event) {
      counter++;
    }
    public 
    boolean requiresLayout() {
      return true;
    }
  }
}
"
org.apache.log4j.test.UnitTestCyclicBuffer,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
//
// Log4j uses the JUnit framework for internal unit testing. JUnit
// available from
//
//     http://www.junit.org
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.CyclicBuffer;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.TestFailure;
import junit.framework.Test;
/**
   Unit test the {@link CyclicBuffer}.
   @author Ceki G&uuml;lc&uuml;</a> 
   @since 0.9.0
*/
public class UnitTestCyclicBuffer extends TestCase {
  static Category cat = Category.getInstance(""x"");
  static int MAX = 1000;
  static LoggingEvent[] e = new LoggingEvent[MAX];
  {
    for (int i = 0; i < MAX; i++) {
      e[i] =  new LoggingEvent("""", cat, Priority.DEBUG, ""e""+i, null);
    }
  }
  public UnitTestCyclicBuffer(String name) {
    super(name);
  }
  public
  void setUp() {
  }
  public
  void test0() {
    int size = 2;
    CyclicBuffer cb = new CyclicBuffer(size);    
    assertEquals(cb.getMaxSize(), size);    
    cb.add(e[0]);
    assertEquals(cb.length(), 1);    
    assertEquals(cb.get(), e[0]); assertEquals(cb.length(), 0);
    assertNull(cb.get()); assertEquals(cb.length(), 0);
    cb = new CyclicBuffer(size);    
    cb.add(e[0]);
    cb.add(e[1]);
    assertEquals(cb.length(), 2);    
    assertEquals(cb.get(), e[0]); assertEquals(cb.length(), 1);
    assertEquals(cb.get(), e[1]); assertEquals(cb.length(), 0);
    assertNull(cb.get()); assertEquals(cb.length(), 0);
  }
  /**
     Test a buffer of size 1,2,4,8,..,128
   */
  public
  void test1() {
    for(int bufSize = 1; bufSize <= 128; bufSize *=2) 
      doTest1(bufSize);
  }
  void doTest1(int size) {
    //System.out.println(""Doing test with size = ""+size);
    CyclicBuffer cb = new CyclicBuffer(size);
    assertEquals(cb.getMaxSize(), size);
    for(int i = -(size+10); i < (size+10); i++) {
      assertNull(cb.get(i));
    }
    for(int i = 0; i < MAX; i++) {
      cb.add(e[i]);
      int limit = i < size-1 ? i : size-1;
      //System.out.println(""\nLimit is "" + limit + "", i=""+i);
      for(int j = limit; j >= 0; j--) {
	//System.out.println(""i= ""+i+"", j=""+j);
	assertEquals(cb.get(j), e[i-(limit-j)]);
      }
      assertNull(cb.get(-1));
      assertNull(cb.get(limit+1));
    }
  }
  public
  void testResize() {
    for(int isize = 1; isize <= 128; isize *=2) {      
      doTestResize(isize, isize/2+1, isize/2+1);
      doTestResize(isize, isize/2+1, isize+10);
      doTestResize(isize, isize+10, isize/2+1);
      doTestResize(isize, isize+10, isize+10);
    }
  }
  void doTestResize(int initialSize, int numberOfAdds, int newSize) {
    //System.out.println(""initialSize = ""+initialSize+"", numberOfAdds=""
    //	       +numberOfAdds+"", newSize=""+newSize);
    CyclicBuffer cb = new CyclicBuffer(initialSize);
    for(int i = 0; i < numberOfAdds; i++) {
      cb.add(e[i]);
    }    
    cb.resize(newSize);
    int offset = numberOfAdds - initialSize;
    if(offset< 0)
      offset = 0;
    int len = newSize < numberOfAdds ? newSize : numberOfAdds;
    len = len < initialSize ? len : initialSize;
    //System.out.println(""Len = ""+len+"", offset=""+offset);
    for(int j = 0; j < len; j++) {
      assertEquals(cb.get(j), e[offset+j]);
    }
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestCyclicBuffer(""test0""));
    suite.addTest(new UnitTestCyclicBuffer(""test1""));
    suite.addTest(new UnitTestCyclicBuffer(""testResize""));
    return suite;
  }
}
"
org.apache.log4j.test.UnitTestOR,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
//
// Log4j uses the JUnit framework for internal unit testing. JUnit
// available from
//
//     http://www.junit.org
package org.apache.log4j.test;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.TestFailure;
import junit.framework.Test;
import java.io.Serializable;
/**
   Unit test the {@link ObjectRenderer}.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class UnitTestOR extends TestCase {
  static UTObjectRenderer aor;
  static UTObjectRenderer bor;
  static UTObjectRenderer xor;
  static UTObjectRenderer yor;
  static UTObjectRenderer oor;
  static UTObjectRenderer nor;
  static UTObjectRenderer ior;
  static UTObjectRenderer cor;
  static UTObjectRenderer sor;
  public UnitTestOR(String name) {
    super(name);
  }
  public
  void setUp() {
    aor = new UTObjectRenderer(""A"");
    bor = new UTObjectRenderer(""B"");
    xor = new UTObjectRenderer(""X"");    
    yor = new UTObjectRenderer(""Y"");    
    oor = new UTObjectRenderer(""Object"");
    nor = new UTObjectRenderer(""Number"");
    ior = new UTObjectRenderer(""Integer"");
    cor = new UTObjectRenderer(""Comparable"");
    sor = new UTObjectRenderer(""Serializable"");
  }
  // Add: no renderer
  // Expect: defaultRenderer
  public
  void test1() {
    RendererMap map = new RendererMap();
    ObjectRenderer dr = map.getDefaultRenderer();
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, dr);
  }
  // Add: Integer renderer
  // Expect: Integer renderer
  public
  void test2() {
    RendererMap map = new RendererMap();
    map.put(Integer.class, ior);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, ior);
  }
  // Add: Number renderer
  // Expect: Number
  public
  void test3() {
    RendererMap map = new RendererMap();
    map.put(Number.class, ior);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, ior);
  }
  // Add: Object renderer
  // Result: Object
  public
  void test4() {
    RendererMap map = new RendererMap();
    map.put(Object.class, oor);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, oor);
  }
  // Add: Object, Number, Integer
  // Expect: Integer
  public
  void test5() {
    RendererMap map = new RendererMap();
    map.put(Object.class, oor);
    map.put(Number.class, nor);
    map.put(Integer.class, ior);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, ior);
  }
  // Add: Object, Number
  // Expect: Number
  public
  void test6() {
    RendererMap map = new RendererMap();
    map.put(Object.class, oor);
    map.put(Number.class, nor);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, nor);
  }
  // Add: Comparable
  // Expect: Comparable
  public
  void test7() {
    RendererMap map = new RendererMap();
    map.put(Comparable.class, cor);
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, cor);
  }
  // Add: Serializable
  // Expect: Serializablee
  public
  void test8() {
    RendererMap map = new RendererMap();
    map.put(Serializable.class, sor); 
    ObjectRenderer r = map.get(Integer.class);
    assertEquals(r, sor);
  }
  // Add: Y
  // Expect: Y
  public
  void test9() {
    RendererMap map = new RendererMap();
    map.put(Y.class, yor); 
    ObjectRenderer r = map.get(B.class);
    assertEquals(r, yor);
  }
  // Add: X
  // Expect: X
  public
  void test10() {
    RendererMap map = new RendererMap();
    map.put(X.class, xor); 
    ObjectRenderer r = map.get(B.class);
    assertEquals(r, xor);
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestOR(""test1""));
    suite.addTest(new UnitTestOR(""test2""));
    suite.addTest(new UnitTestOR(""test3""));
    suite.addTest(new UnitTestOR(""test4""));
    suite.addTest(new UnitTestOR(""test5""));
    suite.addTest(new UnitTestOR(""test6""));
    suite.addTest(new UnitTestOR(""test7""));
    suite.addTest(new UnitTestOR(""test8""));
    suite.addTest(new UnitTestOR(""test9""));
    suite.addTest(new UnitTestOR(""test10""));
    return suite;
  }
}
class UTObjectRenderer implements ObjectRenderer {
  String name;
  UTObjectRenderer(String name) {
    this.name = name;
  }
  public
  String doRender(Object o) {
    return name;
  }
  public
  String toString() {
    return(""UTObjectRenderer: ""+name);
  }
}
interface X  {
}
interface Y extends X {
}
class A implements Y  {
}
class B extends A  {
}
"
org.apache.log4j.test.UnitTestVarSubst,"// Log4j uses the JUnit framework for internal unit testing. JUnit
// is available from ""http://www.junit.org"".
package org.apache.log4j.test;
import org.apache.log4j.helpers.OptionConverter;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.Test;
import java.util.Properties;
/**
   Test variable substitution code.   
   @author Ceki G&uuml;lc&uuml;
   @since 1.0
*/
public class UnitTestVarSubst extends TestCase {
  Properties props;
  public UnitTestVarSubst(String name) {
    super(name);
  }
  public
  void setUp() {
    props = new Properties();
    props.put(""TOTO"", ""wonderful"");
    props.put(""key1"", ""value1"");
    props.put(""key2"", ""value2"");
    System.setProperties(props);
  }  
  public
  void tearDown() {
    props = null;
  }
  public
  void varSubstTest1() {
    String r;
    r = OptionConverter.substVars(""hello world."", null);
    assertEquals(""hello world."", r);
    r = OptionConverter.substVars(""hello ${TOTO} world."", null);
    assertEquals(""hello wonderful world."", r);
  }
  public
  void varSubstTest2() {
    String r;
    r = OptionConverter.substVars(""Test2 ${key1} mid ${key2} end."", null);
    assertEquals(""Test2 value1 mid value2 end."", r);
  }
  public
  void varSubstTest3() {
    String r;
    r = OptionConverter.substVars(
				     ""Test3 ${unset} mid ${key1} end."", null);
    assertEquals(""Test3  mid value1 end."", r);
  }
  public
  void varSubstTest4() {
    String res;
    String val = ""Test4 ${incomplete "";
    try {
      res = OptionConverter.substVars(val, null);
    }
    catch(IllegalArgumentException e) {
      String errorMsg = e.getMessage();
      //System.out.println('['+errorMsg+']');
      assertEquals('""'+val+ ""\"" has no closing brace. Opening brace at position 6."", errorMsg);
    }
  }
  public
  static
  Test suite() {
    TestSuite suite = new TestSuite();
    suite.addTest(new UnitTestVarSubst(""varSubstTest1""));
    suite.addTest(new UnitTestVarSubst(""varSubstTest2""));
    suite.addTest(new UnitTestVarSubst(""varSubstTest3""));
    suite.addTest(new UnitTestVarSubst(""varSubstTest4""));
    return suite;
  }
}
"
org.apache.log4j.varia.DenyAllFilter,"//  Copyright (c) 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.varia;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
/**
   This filter drops all logging events. 
   <p>You can add this filter to the to the end of a filter chain to
   switch from the default ""accept all unless instructed otherwise""
   filtering behaviour to a ""deny all unless instructed otherwise""
   behaviour.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class DenyAllFilter extends Filter {
  /**
     Always returns the integer constant {@link Filter#DENY}
     regardless of the {@link LoggingEvent} parameter.
     @param event The LoggingEvent to filter.
     @return Always returns {@link Filter#DENY}.
  */
  public
  int decide(LoggingEvent event) {
    return Filter.DENY;
  }
  /**
     Returns <code>null</code> as there are no options.
  */
  public
  String[] getOptionStrings() {
    return null;
  }
  /**
     No options to set.
  */
  public
  void setOption(String key, String value) {
  }
}
"
org.apache.log4j.varia.ExternallyRolledFileAppender,"//      Copyright 2000, Ceki Gulcu. 
//
//      See the LICENCE file for the terms of usage and distribution.
package org.apache.log4j.varia;
import java.io.*;
import java.net.Socket;
import java.net.ServerSocket;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.RollingFileAppender;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
/**
   This appender listen on a socket on the port specified by the
   {@link #PORT_OPTION} for a ""RollOver"" message. If and and when such
   a message is received, the underlying log file is rolled over and
   an acknowledgement message is sent back to the process initiating
   the roll over.
   <p>Compared to the the {@link ResilientFileAppender}, this method
   of triggering roll over has the advantage of being operating system
   independent, fast and reliable.
   <p>A simple application {@link Roller} is provided to initiate the
   roll over.
   <p>Note that the intiator is not authenticated. Anyone can trigger
   a rollover. In production environments, it is recommended that you
   add some form of protection to prevent undesired rollovers.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.0 */
public class ExternallyRolledFileAppender extends RollingFileAppender {
  /**
     A string constant used in naming the option for setting the port
     for listening to external roll over messages. Current value of
     this string constant is <b>Port</b>.  
     <p>All option keys are case sensitive.  */
  static final public String PORT_OPTION = ""Port"";
  /**
     The string constant sent to initiate a roll over.   Current value of
     this string constant is <b>RollOver</b>.  
  */
  static final public String ROLL_OVER = ""RollOver"";
  /**
     The string constant sent to acknowledge a roll over.   Current value of
      this string constant is <b>OK</b>.
  */
  static final public String OK = ""OK"";
  int port = 0;
  HUP hup;
  /**
     Thia default constructor does nothing but call its super-class
     constructor.  */
  public
  ExternallyRolledFileAppender() { 
  }
  /**
     Start listening on the port specified by a preceding call to
     {@link #setOption}.  */
  public
  void activateOptions() {
    super.activateOptions();
    if(port != 0) {
      if(hup != null) {
	hup.interrupt();
      }
      hup = new HUP(this, port);      
      hup.setDaemon(true);
      hup.start();
    }
  }
  /**
     Retuns the option names for this component, namely {@link
     #PORT_OPTION} in addition to the options of its super class {@link
     RollingFileAppender#getOptionStrings FileAppender}.  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		 new String[] {PORT_OPTION});
  }
  /**
     The <b>Port</b> options takes a 
   */
  public
  void setOption(String option, String value) {
    super.setOption(option, value);    
    if(option.equalsIgnoreCase(PORT_OPTION)) {
      port = OptionConverter.toInt(value, port);
      LogLog.debug(""Port option set to ""+port); 
    }
  }
}
class HUP extends Thread {
  int port;
  ExternallyRolledFileAppender er;
  HUP(ExternallyRolledFileAppender er, int port) {
    this.er = er;
    this.port = port;
  }
  public
  void run() {
    while(!isInterrupted()) {
      try {	
	ServerSocket serverSocket = new ServerSocket(port);
	while(true) {
	  Socket socket = serverSocket.accept();
	  LogLog.debug(""Connected to client at "" + socket.getInetAddress());
	  new Thread(new HUPNode(socket, er)).start();
	}
      }
      catch(Exception e) {
	e.printStackTrace();
      }
    } 
  }
}
class HUPNode implements Runnable {
  Socket socket;
  DataInputStream dis;
  DataOutputStream dos;
  ExternallyRolledFileAppender er;
  public
  HUPNode(Socket socket, ExternallyRolledFileAppender er) {
    this.socket = socket;
    this.er = er;
    try {
      dis = new DataInputStream(socket.getInputStream());
      dos = new DataOutputStream(socket.getOutputStream());
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }
  public void run() {
    try {
      String line = dis.readUTF();
      LogLog.debug(""Got external roll over signal."");      
      if(ExternallyRolledFileAppender.ROLL_OVER.equals(line)) {
	synchronized(er) {
	  er.rollOver();
	}
	dos.writeUTF(ExternallyRolledFileAppender.OK);
      }
      else {
	dos.writeUTF(""Expecting [RollOver] string."");
      }
      dos.close();
    }
    catch(Exception e) {
      LogLog.error(""Unexptected exception. Exiting HUPNode."", e);
    }    
  }
}
"
org.apache.log4j.varia.PriorityMatchFilter,"//  Copyright (c) 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.varia;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
/**
   This is a very simple filter based on priority matching.
   <p>The filter admits two options <b>PriorityToMatch</b> and
   <b>AcceptOnMatch</b>. If there is an exact match between the value
   of the PriorityToMatch option and the priority of the {@link
   LoggingEvent}, then the {@link #decide} method returns {@link
   Filter#ACCEPT} in case the <b>AcceptOnMatch</b> option value is set
   to <code>true</code>, if it is <code>false</code> then {@link
   Filter#DENY} is returned. If there is no match, {@link
   Filter#NEUTRAL} is returned.
   <p>See configuration files <a
   href=""../xml/doc-files/test11.xml"">test11.xml</a> and <a
   href=""../xml/doc-files/test12.xml"">test12.xml</a> for an example of
   seeting up a <code>PriorityMatchFilter</code>.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public class PriorityMatchFilter extends Filter {
  public static final String PRIORITY_TO_MATCH_OPTION = ""PriorityToMatch"";
  /**
   */
  public static final String ACCEPT_ON_MATCH_OPTION = ""AcceptOnMatch"";
  /**
     Do we return ACCEPT when a match occurs. Default is
     <code>true</code>.  */
  boolean acceptOnMatch = true;
  /**
   */
  Priority priorityToMatch;
  /**
     Return the decision of this filter.
     Returns {@link Filter#NEUTRAL} if the <b>PriorityToMatch</b>
     option is not set.  Otherwise, the returned decision is defined
     according to the following table:
     <p><table border=1>
     <tr><th rowspan=""2"" BGCOLOR=""#AAAAFF"">Did a priority match occur?</th>
     	 <th colspan=""2"" BGCOLOR=""#CCCCCC"">AcceptOnMatch setting</th>
     <tr><td BGCOLOR=""#CCCCCC"" align=""center"">TRUE</td>
     	 <td BGCOLOR=""#CCCCCC"" align=""center"">FALSE</td>
     <tr><td BGCOLOR=""#AAAAFF"" align=""center"">TRUE</td>
     	 <td>{@link Filter#ACCEPT}</td><td>{@link Filter#DENY}</td>
     <tr><td BGCOLOR=""#AAAAFF"" align=""center"">FALSE</td>
     	 <td>{@link Filter#DENY}</td><td>{@link Filter#ACCEPT}</td>
     	 <caption align=""bottom"">Filter decision in function of whether a match
     	 occured and the AcceptOnMatch settings</caption> 
    </table> */
  public
  int decide(LoggingEvent event) {
    if(this.priorityToMatch == null) {
      return Filter.NEUTRAL;
    }
    boolean matchOccured = false;
    if(this.priorityToMatch == event.priority) {
      matchOccured = true;
    }
    if(this.acceptOnMatch ^ matchOccured) {
      return Filter.DENY;
    } else {
      return Filter.ACCEPT;
    }
  }
  public
  String[] getOptionStrings() {
    return new String[] {PRIORITY_TO_MATCH_OPTION, ACCEPT_ON_MATCH_OPTION};
  }
  public
  void setOption(String key, String value) {    
    if(key.equalsIgnoreCase(PRIORITY_TO_MATCH_OPTION)) {
      priorityToMatch = Priority.toPriority(value, null);
    } else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {
      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);
    }
  }
}
"
org.apache.log4j.varia.ResilientFileAppender,"package org.apache.log4j.varia;
import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Layout;
/**
   This appender is resilient against moving of the log output
   file. Before every write operation, it checks whether the target
   log file has been moved by an external process. If that is the
   case, a new output file is created.
   <p>This method of detecting externally triggered roll overs has the
   following disadvantages:
   <ul> 
   <li>It adds the overhead of calling File.exists method before each
   write.
   <li>It is not guaranteed to work on all environments. For example,
   on Windows NT, it is not possible to move an already open file.
   <li>Since there is no proper synchronization between the external
   process and the JVM doing the logging, race conditions are possible
   and can result in the loss of log records.
   </ul>
   For all these reasons, it is recommended that you use the {@link
   ExternallyRolledFileAppender}.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.0 */
public class ResilientFileAppender extends FileAppender {
  File file;
  /**
     Thia default constructor does nothing but call its super-class
     constructor.  */
  public
  ResilientFileAppender() {    
  }
  /**
     This constructor does nothing but call its super-class constructor
     with the same parameters.  */
  public
  ResilientFileAppender(Layout layout, Writer writer) {
    super(layout, writer);
  }                    
  /**
   */
  protected
  boolean checkEntryConditions() {
    if(!super.checkEntryConditions()) {
      return false;
    }
    if((file != null) && !file.exists()) {
      // the file has been removed under our feet.
      // we call our super-classes' setFile method to close the current writer
      // reference and open a new file.
      file = new File(fileName);
      try {
	setFile(fileName);
      } catch(java.io.IOException e) {
	LogLog.error(""setFile(""+fileName+"",""+ fileAppend+"") call failed."", e);
      }
    }
    return true;
  }
  public
  void setFile(String fileName, boolean append) throws IOException {
    super.setFile(fileName, append);
    file = new File(fileName);
  }
  protected
  void reset() {
    super.reset();
    file = null;
  }
}
"
org.apache.log4j.varia.Roller,"// Copyright 2000, Ceki Gulcu. 
package org.apache.log4j.varia;
import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
/**
   A simple application to send roll over messages to a potentially
   remote {@link ExternallyRolledFileAppender}. 
   <p>It takes two arguments, the <code>host_name</code> and
   <code>port_number</code> where the
   <code>ExternallyRolledFileAppender</code> is listening.
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.0 */
public class Roller {
  static Category cat = Category.getInstance(Roller.class.getName());
  static String host;
  static int port;
  // Static class.
  Roller() {
  }
  /**
     Send a ""RollOver"" message to
     <code>ExternallyRolledFileAppender</code> on <code>host</code>
     and <code>port</code>.
   */
  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    roll();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Roller.class.getName() +
			""host_name port_number"");
    System.exit(1);
  }
  static 
  void init(String hostArg, String portArg) {
    host = hostArg;
    try {
      port =  Integer.parseInt(portArg);
    }
    catch(java.lang.NumberFormatException e) {
      usage(""Second argument ""+portArg+"" is not a valid integer."");
    }
  }
  static
  void roll() {
    try {
      Socket socket = new Socket(host, port);
      DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
      DataInputStream dis = new DataInputStream(socket.getInputStream());
      dos.writeUTF(ExternallyRolledFileAppender.ROLL_OVER);
      String rc = dis.readUTF();
      if(ExternallyRolledFileAppender.OK.equals(rc)) {
	cat.info(""Roll over signal acknowledged by remote appender."");
      } else {
	cat.warn(""Unexpected return code ""+rc+"" from remote entity."");
	System.exit(2);
      }
    } catch(IOException e) {
      cat.error(""Could not send roll signal on host ""+host+"" port ""+port+"" ."",
		e);
      System.exit(2);
    }
    System.exit(0);
  }
}
"
org.apache.log4j.varia.StringMatchFilter,"//  Copyright (c) 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.
package org.apache.log4j.varia;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
/**
   This is a very simple filter based on string matching.
   <p>The filter admits two options <b>StringToMatch</b> and
   <b>AcceptOnMatch</b>. If there is a match between the value of the
   StringToMatch option and the message of the {@link LoggingEvent},
   then the {@link #decide} method returns {@link Filter#ACCEPT} if
   the <b>AcceptOnMatch</b> option value is true, if it is false then
   {@link Filter#DENY} is returned. If there is no match, {@link
   Filter#NEUTRAL} is returned.
   <p>See configuration files <a
   href=""../xml/doc-files/test6.xml"">test6.xml</a>, <a
   href=""../xml/doc-files/test7.xml"">test7.xml</a>, <a
   href=""../xml/doc-files/test8.xml"">test8.xml</a>, <a
   href=""../xml/doc-files/test9.xml"">test9.xml</a>, and <a
   href=""../xml/doc-files/test10.xml"">test10.xml</a> for examples of
   seeting up a <code>StringMatchFilter</code>.
   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class StringMatchFilter extends Filter {
  public static final String STRING_TO_MATCH_OPTION = ""StringToMatch"";
  /**
   */
  public static final String ACCEPT_ON_MATCH_OPTION = ""AcceptOnMatch"";
  boolean acceptOnMatch = true;
  String stringToMatch;
  /**
     Returns {@link Filter#NEUTRAL} is there is no string match.
   */
  public
  int decide(LoggingEvent event) {
    if(event.message == null ||  stringToMatch == null)
      return Filter.NEUTRAL;
    // we've got a string message
    if(event.message instanceof String) {      
      String msg = (String) event.message;
      // match
      if( msg.indexOf(stringToMatch) == -1 ) {
	return Filter.NEUTRAL;
      } else { // we've got a match
	if(acceptOnMatch) {
	  return Filter.ACCEPT;
	} else {
	  return Filter.DENY;
	}
      }
    } else { // we've got an non-string message
      return Filter.NEUTRAL;      
    }
  }
  public
  String[] getOptionStrings() {
    return new String[] {STRING_TO_MATCH_OPTION, ACCEPT_ON_MATCH_OPTION};
  }
  public
  void setOption(String key, String value) { 
    if(key.equalsIgnoreCase(STRING_TO_MATCH_OPTION)) {
      stringToMatch = value;
    } else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {
      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);
    }
  }
}
"
org.apache.log4j.varia.test.Loop,"package org.apache.log4j.varia.test; 
import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
/**
   This test program reads a config file and attempts to log to the
   appenders specified as many times as specified by the second
   loopLength parameter.
   @author Ceki G&uuml;lc&uuml; */
public class Loop {
  static Category cat = Category.getInstance(Loop.class.getName());
  static int loopLength;
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }
  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + Loop.class.getName() +
			""configFile loopLength"");
    System.exit(1);
  }
  static
  void init(String configFile, String loopStr) {
    PropertyConfigurator.configure(configFile);
    try {
      loopLength   = Integer.parseInt(loopStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret loopLength [""+ loopStr +""]."");
    }
  }
  static
  void test() {
    for(int i=0; i < loopLength; i++) {
      Thread.yield();
      cat.debug(""MSG ""+i);
    }
  }
}
"
org.apache.log4j.xml.DOMConfigurator,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml;
import java.util.*;
import java.net.URL;
import org.w3c.dom.*;
import java.lang.reflect.Method;
import org.apache.log4j.Category;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.Appender;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.FileWatchdog;
import org.xml.sax.InputSource;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.FactoryConfigurationError;
/**
   Use this class to initialize the log4j environment using a DOM tree.
   <p>The DTD is specified in <a
   href=""doc-files/log4j.dtd""><b>log4j.dtd</b></a>.
   <p>Sometimes it is useful to see how log4j is reading configuration
   files. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable on the java command line.
   <p>There are sample XML files included in the package.
   @author <a href=mailto:cstaylor@pacbell.net>Christopher Taylor</a>
   @author Ceki G&uuml;lc&uuml;
   @since 0.8.3 */
public class DOMConfigurator extends BasicConfigurator implements Configurator {
  static final String CONFIGURATION_TAG = ""configuration"";
  static final String RENDERER_TAG      = ""renderer"";
  static final String APPENDER_TAG 	= ""appender"";
  static final String APPENDER_REF_TAG 	= ""appender-ref"";  
  static final String PARAM_TAG    	= ""param"";
  static final String LAYOUT_TAG	= ""layout"";
  static final String CATEGORY		= ""category"";
  static final String NAME_ATTR		= ""name"";
  static final String CLASS_ATTR        = ""class"";
  static final String VALUE_ATTR	= ""value"";
  static final String ROOT_TAG		= ""root"";
  static final String PRIORITY_TAG	= ""priority"";
  static final String FILTER_TAG	= ""filter"";
  static final String ERROR_HANDLER_TAG	= ""errorHandler"";
  static final String REF_ATTR		= ""ref"";
  static final String ADDITIVITY_ATTR    = ""additivity"";  
  static final String SCFO_ATTR          = ""disableOverride"";
  static final String CONFIG_DEBUG_ATTR  = ""configDebug"";
  static final String RENDERING_CLASS_ATTR = ""renderingClass"";
  static final String RENDERED_CLASS_ATTR = ""renderedClass"";
  static final String EMPTY_STR = """";
  static final Class[] ONE_STRING_PARAM = new Class[] {String.class};
  final static String dbfKey = ""javax.xml.parsers.DocumentBuilderFactory"";
  // key: appenderName, value: appender
  Hashtable appenderBag;
  /**
     No argument constructor.
  */
  public
  DOMConfigurator () { 
    appenderBag = new Hashtable();
  }
  /**
     Used internally to parse appenders by IDREF.
   */
  protected
  Appender findAppenderByReference(Element appenderRef) {    
    String appenderName = appenderRef.getAttribute(REF_ATTR);
    Appender appender = (Appender) appenderBag.get(appenderName);
    if(appender != null) {
      return appender;
    } else {
      Document doc = appenderRef.getOwnerDocument();
      // DOESN'T WORK!! :
      // Element element = doc.getElementById(appenderName);
      // Endre's hack:
      Element element = null;
      NodeList list = doc.getElementsByTagName(""appender"");
      for (int t=0; t<list.getLength(); t++) {
	Node node = list.item(t);
	NamedNodeMap map= node.getAttributes();
	Node attrNode = map.getNamedItem(""name"");
	if (appenderName.equals(attrNode.getNodeValue())) {
	  element = (Element) node;
	  break;
	}
      }
      // Hack finished.
      if(element == null) {
	LogLog.error(""No appender named [""+appenderName+""] could be found.""); 
	return null;
      } else {
	appender = parseAppender(element);
	appenderBag.put(appenderName, appender);
	return appender;
      }
    } 
  }
  /**
     Used internally to parse an appender element.
   */
  protected
  Appender parseAppender (Element appenderElement) {
    String className = appenderElement.getAttribute(CLASS_ATTR);
    LogLog.debug(""Class name: ["" + className+']');    
    try {
      Object instance 	= Class.forName(className).newInstance();
      Appender appender	= (Appender)instance;
      appender.setName(appenderElement.getAttribute(NAME_ATTR));
      NodeList children	= appenderElement.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	/* We're only interested in Elements */
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element)currentNode;
	  // Parse appender parameters 
	  if (currentElement.getTagName().equals(PARAM_TAG)) {
	    if(appender instanceof OptionHandler) {
	      parseParameters(currentElement, (OptionHandler) appender);
	    }
	  }
	  // Set appender layout
	  else if (currentElement.getTagName().equals(LAYOUT_TAG)) {
	    appender.setLayout(parseLayout(currentElement));
	  }
	  // Add filters
	  else if (currentElement.getTagName().equals(FILTER_TAG)) {
	    parseFilters(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) {
	    parseErrorHandler(currentElement, appender);
	  }
	  else if (currentElement.getTagName().equals(APPENDER_REF_TAG)) {
	    String refName = currentElement.getAttribute(REF_ATTR);
	    if(appender instanceof AppenderAttachable) {
	      AppenderAttachable aa = (AppenderAttachable) appender;
	      LogLog.debug(""Attaching appender named [""+ refName+
			   ""] to appender named [""+ appender.getName()+""]."");
	      aa.addAppender(findAppenderByReference(currentElement));
	    } else {
	      LogLog.error(""Requesting attachment of appender named [""+
			   refName+ ""] to appender named [""+ appender.getName()+
                ""] which does not implement org.apache.log4j.spi.AppenderAttachable."");
	    }
	  }
	}
      }
      if(appender instanceof OptionHandler) {
	((OptionHandler) appender).activateOptions();
      }
      return appender;
    }
    /* Yes, it's ugly.  But all of these exceptions point to the same
       problem: we can't create an Appender */
    catch (Exception oops) {
      LogLog.error(""Could not create an Appender. Reported error follows."",
		   oops);
      return null;
    }
  }
  /**
     Used internally to parse an {@link ErrorHandler} element.
   */
  protected
  void parseErrorHandler(Element element, Appender appender) {
    ErrorHandler eh = (ErrorHandler) OptionConverter.instantiateByClassName(
                                       element.getAttribute(CLASS_ATTR),
                                       org.apache.log4j.spi.ErrorHandler.class, 
 				       null);
    if(eh != null) {
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
	    parseParameters(currentElement, eh);
	  }
	}
      }
      appender.setErrorHandler(eh);
    }
  }
  /**
     Used internally to parse an <code>param</code> element.
   */
  protected
  void parseParameters(Element elem, OptionHandler oh) {
    String name = elem.getAttribute(NAME_ATTR);
    String value = elem.getAttribute(VALUE_ATTR);
    LogLog.debug(""Handling parameter \""""+name+ ""=""+value+'\""');	   
    if(oh instanceof OptionHandler && value != null) {
      oh.setOption(name, OptionConverter.convertSpecialChars(value));
    }
  }
  /**
     Used internally to parse a filter element.
   */
  protected
  void parseFilters(Element element, Appender appender) {
    String clazz = element.getAttribute(CLASS_ATTR);
    Filter filter = (Filter) OptionConverter.instantiateByClassName(clazz,
                                                org.apache.log4j.spi.Filter.class, 
					        null);
    if(filter != null) {
      NodeList children = element.getChildNodes();
      final int length 	= children.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = children.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
	    parseParameters(currentElement, filter);
	  }
	}
      }
      appender.addFilter(filter);
    }    
  }
  /**
     Used internally to parse an category element.
  */
  protected
  void parseCategory (Element categoryElement, Hierarchy hierarchy) {
    // Create a new org.apache.log4j.Category object from the <category> element.
    String catName = categoryElement.getAttribute(NAME_ATTR);
    Category cat;    
    String className = categoryElement.getAttribute(CLASS_ATTR);
    if(EMPTY_STR.equals(className)) {
      LogLog.debug(""Retreiving an instance of org.apache.log4j.Category."");
      cat = hierarchy.getInstance(catName);
    }
    else {
      LogLog.debug(""Desired category sub-class: [""+className+']');
       try {	 
	 Class clazz = Class.forName(className);
	 Method getInstanceMethod = clazz.getMethod(""getInstance"", 
						    ONE_STRING_PARAM);
	 cat = (Category) getInstanceMethod.invoke(null, new Object[] {catName});
       } catch (Exception oops) {
	 LogLog.error(""Could not retrieve category [""+catName+
		      ""]. Reported error follows."", oops);
	 return;
       }
    }
    // Setting up a category needs to be an atomic operation, in order
    // to protect potential log operations while category
    // configuration is in progress.
    synchronized(cat) {
      cat.setAdditivity(OptionConverter.toBoolean(
                  categoryElement.getAttribute(ADDITIVITY_ATTR), true));
      parseChildrenOfCategoryElement(categoryElement, cat, false);
    }
  }
  /**
     Used internally to parse the roor category element.
  */
  protected
  void parseRoot (Element rootElement, Hierarchy hierarchy) {
    Category root = hierarchy.getRoot();
    // category configuration needs to be atomic
    synchronized(root) {    
      parseChildrenOfCategoryElement(rootElement, root, true);
    }
  }
  /**
     Used internally to parse the children of a category element.
  */
  protected
  void parseChildrenOfCategoryElement(Element catElement,
				      Category cat, boolean isRoot) {
    // Remove all existing appenders from cat. They will be
    // reconstructed if need be.
    cat.removeAllAppenders();
    NodeList children 	= catElement.getChildNodes();
    final int length 	= children.getLength();
    for (int loop = 0; loop < length; loop++) {
      Node currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	Element currentElement = (Element) currentNode;
	String tagName = currentElement.getTagName();
	if (tagName.equals(APPENDER_REF_TAG)) {
	  Element appenderRef = (Element) currentNode;
	  Appender appender = findAppenderByReference(appenderRef);
	  String refName =  appenderRef.getAttribute(REF_ATTR);
	  if(appender != null)
	    LogLog.debug(""Adding appender named [""+ refName+ 
			 ""] to category [""+cat.getName()+""]."");
	  else 
	    LogLog.debug(""Appender named [""+ refName + ""] not found."");
	  cat.addAppender(appender);
	} else if(tagName.equals(PRIORITY_TAG)) {
	  parsePriority(currentElement, cat, isRoot);	
	} else if(tagName.equals(PARAM_TAG)) {
	  if(cat instanceof OptionHandler) {
	    OptionHandler oh = (OptionHandler) cat;
	    parseParameters(currentElement, oh);
	    oh.activateOptions();
	  }
	}
      }
    }
  }
  /**
     Used internally to parse a layout element.
  */  
  protected
  Layout parseLayout (Element layout_element) {
    String className = layout_element.getAttribute(CLASS_ATTR);
    LogLog.debug(""Parsing layout of class: \""""+className+""\"""");		 
    try {
      Object instance 	= Class.forName(className).newInstance();
      Layout layout   	= (Layout)instance;
      NodeList params 	= layout_element.getChildNodes();
      final int length 	= params.getLength();
      for (int loop = 0; loop < length; loop++) {
	Node currentNode = (Node)params.item(loop);
	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	  Element currentElement = (Element) currentNode;
	  String tagName = currentElement.getTagName();
	  if(tagName.equals(PARAM_TAG)) {
	    parseParameters(currentElement, layout);
	  }
	}
      }
      /* Now make those options take effect */
      layout.activateOptions();
      return layout;
    }
    catch (Exception oops) {
      LogLog.error(""Could not create the Layout. Reported error follows."",
		   oops);
      return null;
    }
  }
  protected 
  void parserRenderer(Element element) {
    String renderingClass = element.getAttribute(RENDERING_CLASS_ATTR);
    String renderedClass = element.getAttribute(RENDERED_CLASS_ATTR);
    addRenderer(renderedClass, renderingClass);
  }
  /**
     Used internally to parse a priority  element.
  */
  protected
  void parsePriority(Element element, Category cat, boolean isRoot) {
    String catName = cat.getName();
    if(isRoot) {
      catName = ""root"";
    }
    String priStr = element.getAttribute(VALUE_ATTR);
    LogLog.debug(""Priority value for ""+catName+"" is  [""+priStr+""]."");
    if(BasicConfigurator.INHERITED.equals(priStr)) {
      if(isRoot) {
	LogLog.error(""Root priority cannot be inherited. Ignoring directive."");
      } else {
	cat.setPriority(null);
      }
    }
    else {
      String className = element.getAttribute(CLASS_ATTR);      
      if(EMPTY_STR.equals(className)) {      
	cat.setPriority(Priority.toPriority(priStr));
      } else {
	LogLog.debug(""Desired Priority sub-class: [""+className+']');
	try {	 
	  Class clazz = Class.forName(className);
	  Method toPriorityMethod = clazz.getMethod(""toPriority"", 
						    ONE_STRING_PARAM);
	  Priority pri = (Priority) toPriorityMethod.invoke(null, 
						    new Object[] {priStr});
	  cat.setPriority(pri);
	} catch (Exception oops) {
	  LogLog.error(""Could not create priority [""+priStr+
		       ""]. Reported error follows."", oops);
	  return;
	}
      }
    }
    LogLog.debug(catName +"" priority set to "" +cat.getPriority());    
  }
  /**
     Configure log4j using a <code>configuration</code> element as
     defined in the log4j.dtd. 
  */
  static
  public
  void configure (Element element) {
    DOMConfigurator configurator = new DOMConfigurator();
    configurator.parse(element, Category.getDefaultHierarchy());
  }
 /**
     Like {@link #configureAndWatch(String, long)} except that the
     default delay as defined by {@link FileWatchdog#DEFAULT_DELAY} is
     used. 
     @param configFilename A log4j configuration file in XML format.
  */
  static
  public
  void configureAndWatch(String configFilename) {
    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);
  }
  /**
     Read the configuration file <code>configFilename</code> if it
     exists. Moreover, a thread will be created that will periodically
     check if <code>configFilename</code> has been created or
     modified. The period is determined by the <code>delay</code>
     argument. If a change or file creation is detected, then
     <code>configFilename</code> is read to configure log4j.  
      @param configFilename A log4j configuration file in XML format.
      @param delay The delay in milliseconds to wait between each check.
  */
  static
  public
  void configureAndWatch(String configFilename, long delay) {
    XMLWatchdog xdog = new XMLWatchdog(configFilename);
    xdog.setDelay(delay);
    xdog.start();
  }
  public
  void doConfigure(String filename, Hierarchy hierarchy) {
    try {
      doConfigure(new FileInputStream(filename), hierarchy);
    } catch(IOException e) {
      LogLog.error(""Could not open [""+filename+""]."", e);
    }
  }
  public
  void doConfigure(URL url, Hierarchy hierarchy) {
    try {
      doConfigure(url.openStream(), hierarchy);
    } catch(IOException e) {
      LogLog.error(""Could not open [""+url+""]."", e);
    }
  }
  /**
     Configure log4j by reading in a log4j.dtd compliant XML
     configuration file.
  */
  public
  void doConfigure(InputStream input, Hierarchy hierarchy) 
                                          throws FactoryConfigurationError {
    DocumentBuilderFactory dbf = null;
    try { 
      LogLog.debug(""System property is :""+System.getProperty(dbfKey));      
      dbf = DocumentBuilderFactory.newInstance();
      LogLog.debug(""Standard DocumentBuilderFactory search succeded."");
      LogLog.debug(""DocumentBuilderFactory is: ""+dbf.getClass().getName());
    } catch(FactoryConfigurationError fce) {
      Exception e = fce.getException();
      LogLog.debug(""Could not instantiate a DocumentBuilderFactory."", e);
      throw fce;
    }
    try {
      // This makes ID/IDREF attributes to have a meaning. Don't ask
      // me why.
      dbf.setValidating(true);
      DocumentBuilder docBuilder = dbf.newDocumentBuilder();
      //docBuilder.setErrorHandler(new ReportParserError());
      InputSource inputSource = new InputSource(input);
      URL dtdURL = DOMConfigurator.class.getResource(""log4j.dtd"");
      if(dtdURL == null) {
	LogLog.error(""Could not find log4j.dtd."");
      }
      else {
	LogLog.debug(""URL to log4j.dtd is ["" + dtdURL.toString()+""]."");
	inputSource.setSystemId(dtdURL.toString());
      }
      Document doc = docBuilder.parse(inputSource);
      parse(doc.getDocumentElement(), hierarchy);
    } catch (Exception e) {
      // I know this is miserable...
      LogLog.error(""Could not parse input stream [""+input+""]."", e);
    }
  }
  /**
     This is the static version of {@link #doConfigure(String, Hierarchy)}.x
   */
  static
  public
  void configure(String filename) throws FactoryConfigurationError {
    new DOMConfigurator().doConfigure(filename, Category.getDefaultHierarchy());
  }
  /**
     Used internally to configure the log4j framework by parsing a DOM
     tree of XML elements based on <a
     href=""doc-files/log4j.dtd"">log4j.dtd</a>.
  */
  protected
  void parse(Element element, Hierarchy hierarchy) {
    if (!element.getTagName().equals(CONFIGURATION_TAG)) {
      LogLog.error(""DOM element is not a <configuration> element"");
      return;
    }
    String confDebug = element.getAttribute(CONFIG_DEBUG_ATTR);
    LogLog.debug(""configDebug attribute= \"""" + confDebug +""\""."");
    // if the log4j.dtd is not specified in the XML file, then the
    // configDebug attribute is returned as the empty string when it
    // is not specified in the XML file.
    if(!confDebug.equals("""") && !confDebug.equals(""null"")) {      
      LogLog.setInternalDebugging(OptionConverter.toBoolean(confDebug, true));
    }
    else 
      LogLog.debug(""Ignoring "" + CONFIG_DEBUG_ATTR + "" attribute."");
    String override = element.getAttribute(SCFO_ATTR);
    LogLog.debug(""Disable override=\"""" + override +""\""."");
    // if the log4j.dtd is not specified in the XML file, then the
    // SCFO_ATTR attribute is returned as the empty string when it
    // is not specified in the XML file.
    if(!override.equals("""") && !override.equals(""null"")) {
      // overrideAsNeeded is defined in BasicConfigurator.
      overrideAsNeeded(override);
    }
    else 
      LogLog.debug(""Ignoring "" + SCFO_ATTR + "" attribute."");
    //Hashtable appenderBag = new Hashtable(11);
    /* Building Appender objects, placing them in a local namespace
       for future reference */
    NodeList children = element.getChildNodes();
    final int length = children.getLength();
    for (int loop = 0; loop < length; loop++) {
      Node currentNode = children.item(loop);
      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
	Element currentElement = (Element) currentNode;
	String tagName = currentElement.getTagName();
	if (tagName.equals(CATEGORY)) {
	  parseCategory(currentElement, hierarchy);
	} else if (tagName.equals(ROOT_TAG)) {
	  parseRoot(currentElement, hierarchy);
	} else if(tagName.equals(RENDERER_TAG)) {
	  parserRenderer(currentElement);
	}
      }
    }
  }
}
class XMLWatchdog extends FileWatchdog {
  XMLWatchdog(String filename) {
    super(filename);
  }
  /**
     Call {@link PropertyConfigurator#configure(String)} with the
     <code>filename</code> to reconfigure log4j. */
  public
  void doOnChange() {
    new DOMConfigurator().doConfigure(filename, Category.getDefaultHierarchy());
  }
}
"
org.apache.log4j.xml.Transform,"package org.apache.log4j.xml;
import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.DateLayout;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.SAXException;
import org.apache.xerces.parsers.SAXParser;
import org.apache.trax.Processor;
import org.apache.trax.TemplatesBuilder;
import org.apache.trax.Templates;
import org.apache.trax.Transformer;
import org.apache.trax.Result;
import org.apache.trax.ProcessorException; 
import org.apache.trax.ProcessorFactoryException;
import org.apache.trax.TransformException; 
import org.apache.serialize.SerializerFactory;
import org.apache.serialize.Serializer;
import org.apache.serialize.OutputFormat;
import org.xml.sax.helpers.AttributesImpl;
import java.io.FileOutputStream;
import java.io.IOException;
public class Transform {
  public static void main(String[] args) throws Exception {
    PropertyConfigurator.disableAll();
    PropertyConfigurator.configure(""x.lcf"");
    // I. Instantiate  a stylesheet processor.
    Processor processor = Processor.newInstance(""xslt"");
    // II. Process the stylesheet. producing a Templates object.
    // Get the XMLReader.
    XMLReader reader = XMLReaderFactory.createXMLReader();
    // Set the ContentHandler.
    TemplatesBuilder templatesBuilder = processor.getTemplatesBuilder();
    reader.setContentHandler(templatesBuilder);
    // Set the ContentHandler to also function as a LexicalHandler, which
    // includes ""lexical"" (e.g., comments and CDATA) events. The Xalan
    // TemplatesBuilder -- org.apache.xalan.processor.StylesheetHandler -- is
    // also a LexicalHandler).
    if(templatesBuilder instanceof LexicalHandler) {
       reader.setProperty(""http://xml.org/sax/properties/lexical-handler"", 
                           templatesBuilder);
    }
    // Parse the stylesheet.                       
    reader.parse(args[0]);
    //Get the Templates object from the ContentHandler.
    Templates templates = templatesBuilder.getTemplates();
    // III. Use the Templates object to instantiate a Transformer.
    Transformer transformer = templates.newTransformer();
    // IV. Perform the transformation.
    // Set up the ContentHandler for the output.
	FileOutputStream fos = new FileOutputStream(args[2]);
    Result result = new Result(fos);
    Serializer serializer = SerializerFactory.getSerializer(""xml"");
    serializer.setOutputStream(fos);
    transformer.setContentHandler(serializer.asContentHandler());
    // Set up the ContentHandler for the input.
    org.xml.sax.ContentHandler chandler = transformer.getInputContentHandler();
    DC dc = new DC(chandler);
    reader.setContentHandler(dc);
    if(chandler instanceof LexicalHandler) {
       reader.setProperty(""http://xml.org/sax/properties/lexical-handler"", 
			  chandler);
    } else {
       reader.setProperty(""http://xml.org/sax/properties/lexical-handler"", 
			  null);
    }
    // Parse the XML input document. The input ContentHandler and
    // output ContentHandler work in separate threads to optimize
    // performance.
    reader.parse(args[1]);
  }	
}
 class DC implements ContentHandler {
   static Category cat = Category.getInstance(""DC"");
   ContentHandler  chandler;
   DC(ContentHandler chandler) {
     this.chandler = chandler;
   }
  public 
  void characters(char[] ch, int start, int length) 
                            throws org.xml.sax.SAXException {
    cat.debug(""characters: [""+new String(ch, start, length)+ ""] called"");
    chandler.characters(ch, start, length);
  }
  public 
  void endDocument() throws org.xml.sax.SAXException {
    cat.debug(""endDocument called."");
    chandler.endDocument();
  }
  public 
  void endElement(String namespaceURI, String localName, String qName)
                                           throws org.xml.sax.SAXException {
    cat.debug(""endElement(""+namespaceURI+"", ""+localName+"", ""+qName+"") called"");
    chandler.endElement(namespaceURI, localName, qName);
  }
   public
   void endPrefixMapping(String prefix) throws org.xml.sax.SAXException {
     cat.debug(""endPrefixMapping(""+prefix+"") called"");
     chandler.endPrefixMapping(prefix);
   }
  public 
  void ignorableWhitespace(char[] ch, int start, int length) 
                                     throws org.xml.sax.SAXException {
    cat.debug(""ignorableWhitespace called"");
    chandler.ignorableWhitespace(ch, start, length);
  }
  public 
  void processingInstruction(java.lang.String target, java.lang.String data) 
                                              throws org.xml.sax.SAXException {
    cat.debug(""processingInstruction called"");
    chandler.processingInstruction(target, data);
  }
  public 
  void setDocumentLocator(Locator locator)  {
    cat.debug(""setDocumentLocator called"");
    chandler.setDocumentLocator(locator);
  }
   public
   void skippedEntity(String name) throws org.xml.sax.SAXException {
     cat.debug(""skippedEntity(""+name+"")  called"");
     chandler.skippedEntity(name);     
   }
  public 
  void startDocument() throws org.xml.sax.SAXException {
    cat.debug(""startDocument called"");
    chandler.startDocument();
  }
  public 
  void startElement(String namespaceURI, String localName, String qName,
		    Attributes atts) throws org.xml.sax.SAXException {
    cat.debug(""startElement(""+namespaceURI+"", ""+localName+"", ""+qName+"")called"");
    if(""log4j:event"".equals(qName)) {
      cat.debug(""-------------"");      
      if(atts instanceof org.xml.sax.helpers.AttributesImpl) {
	AttributesImpl ai = (AttributesImpl) atts;
	int i = atts.getIndex(""timestamp"");
	ai.setValue(i, ""hello"");
      }
      String ts = atts.getValue(""timestamp"");
      cat.debug(""New timestamp is "" + ts);
    }
    chandler.startElement(namespaceURI, localName, qName, atts);
  }
   public
   void startPrefixMapping(String prefix, String uri) 
                                          throws org.xml.sax.SAXException {
     cat.debug(""startPrefixMapping(""+prefix+"", ""+uri+"") called"");     
     chandler.startPrefixMapping(prefix, uri);
   }
}
"
org.apache.log4j.xml.XMLLayout,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.DateLayout;
/**
   The output of the XMLLayout consists of a series of log4j:event
   elements as defined in the <a
   href=""doc-files/log4j.dtd"">log4j.dtd</a>. It does not output a
   complete well-formed XML file. The output is designed to be
   included as an <em>external entity</em> in a separate file to form
   a correct XML file.
   <p>For example, if <code>abc</code> is the name of the file where
   the XMLLayout ouput goes, then a well-formed XML file would be:
   <pre>
   &lt;?xml version=""1.0"" ?&gt;
   &lt;!DOCTYPE log4j:eventSet SYSTEM ""log4j.dtd"" [&lt;!ENTITY data SYSTEM ""abc""&gt;]&gt;
   &lt;log4j:eventSet xmlns:log4j=""http://log4j.org""&gt;
       &nbsp;&nbsp;&data;
   &lt;/log4j:eventSet&gt;
   </pre>
   <p>This approach enforces the independence of the XMLLayout and the
   appender where it is embedded.
   @author Ceki  G&uuml;lc&uuml;
   @since 0.9.0 */
public class XMLLayout extends Layout {
  private  final int DEFAULT_SIZE = 256;
  private final int UPPER_LIMIT = 2048;
  private StringBuffer buf = new StringBuffer(DEFAULT_SIZE);
  private boolean locationInfo = false;
  /**
     This is a string constant to name the option for setting the
     location information flag. Current value of this string constant
     is <b>LocationInfo</b>. 
     <p>See the {@link #setOption(java.lang.String, java.lang.String)}
     method for the meaning of this option.  
     <p>Note all option keys are case sensitive.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  public
  void activateOptions() {
  }
  /**
     Formats a {@link LoggingEvent} in conformance with the log4j.dtd.  */
  public
  String format(LoggingEvent event) {
    // Reset working buffer. If the buffer is too large, then we need a new
    // one in order to avoid the penalty of creating a large array.
    if(buf.capacity() > UPPER_LIMIT) {
      buf = new StringBuffer(DEFAULT_SIZE);
    } else {
      buf.setLength(0);
    }
    // We yield to the \r\n heresy.
    buf.append(""<log4j:event category=\"""");
    buf.append(event.categoryName);
    buf.append(""\"" timestamp=\"""");
    buf.append(event.timeStamp);
    buf.append(""\"" priority=\"""");
    buf.append(event.priority);
    buf.append(""\"" thread=\"""");
    buf.append(event.getThreadName());
    buf.append(""\"">\r\n"");
       buf.append(""<log4j:message>"");
       buf.append(event.message);
       buf.append(""</log4j:message>\r\n"");       
       String ndc = event.getNDC();
       if(ndc != null) {
	 buf.append(""<log4j:NDC>"");
	 buf.append(ndc);
	 buf.append(""</log4j:NDC>\r\n"");       
       }
       String t = event.getThrowableInformation();
       if(t != null) {
	 buf.append(""<log4j:throwable>"");
	 buf.append(t);
	 buf.append(""</log4j:throwable>\r\n"");
       }
       if(locationInfo) { 
	 event.setLocationInformation();	
	 buf.append(""<log4j:locationInfo class=\"""");
	 buf.append(event.locationInfo.getClassName());
	 buf.append(""\"" method=\"""");
	 buf.append(event.locationInfo.getMethodName());
	 buf.append(""\"" file=\"""");
	 buf.append(event.locationInfo.getFileName());
	 buf.append(""\"" line=\"""");
	 buf.append(event.locationInfo.getLineNumber());
	 buf.append(""\""/>\r\n"");
       }
    buf.append(""</log4j:event>\r\n\r\n"");
    return buf.toString();
  }
  public
  String[] getOptionStrings() {
    return new String[]{LOCATION_INFO_OPTION};
  }
  /**
     The XMLLayout prints and does not ignore exceptions. Hence the
     return value <code>false</code>.
  */
  public
  boolean ignoresThrowable() {
    return false;
  }
  /**
     The XMLLayout specific options are:
     <p>The <b>LocationInfo</b> option takes a boolean value. If true,
     the oupyt will include location information. By default no
     location information is sent to the server.
  */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    if (key.equals(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);    
    } 
  }
}
"
org.apache.log4j.xml.examples.ReportParserError,"package org.apache.log4j.xml.examples;
import org.apache.log4j.helpers.LogLog;
/**
   This class is needed for validating a log4j.dtd derived XML file.
   @author Joe Kesselman
   @since 0.8.3
 */
public class ReportParserError implements org.xml.sax.ErrorHandler {
  void report(String msg, org.xml.sax.SAXParseException e) {
    LogLog.error(msg+e.getMessage()+ ""\n\tat line=""+ e.getLineNumber()+
		 "" col=""+e.getColumnNumber()+ "" of ""+
		 ""SystemId=\""""+e.getSystemId()+
		 ""\"" PublicID = \""""+e.getPublicId()+'\""');
  }
  public void warning(org.xml.sax.SAXParseException e) {
    report(""WARNING: "", e);
  }
  public void error(org.xml.sax.SAXParseException e) {
    report(""ERROR: "", e);
  }
  public void fatalError(org.xml.sax.SAXParseException e) {
    report(""FATAL: "", e);
  }
}
"
org.apache.log4j.xml.examples.XCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml.examples;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.xml.examples.XPriority;
/**
   A simple example showing Category sub-classing. It shows the
   minimum steps necessary to implement one's {@link CategoryFactory}.
   Note that sub-classes follow the hiearchy even if its categories
   belong to different classes.
   See <b><a href=""doc-files/XCategory.java"">source
   code</a></b> for more details.
 */
public class XCategory extends Category implements OptionHandler {
  // It's enough to instantiate a factory once and for all.
  private static XFactory factory = new XFactory();
  static String instanceFQCN = XCategory.class.getName();
  public static final String SUFFIX_OPTION = ""Suffix"";
  String suffix;
  /**
     Just calls the parent constuctor.
   */
  public XCategory(String name) {
    super(name);
  }
  public
  void activateOptions() {
  }
  /**
     Overrides the standard debug method by appending "" world"" to each
     message.  */
  public 
  void debug(String message) {
    log(instanceFQCN, Priority.DEBUG, message + suffix, null);
  }
  public
  void fatal(String message) { 
    // disable is defined in Category class
    if(disable <=  XPriority.FATAL_INT) return;   
    if(XPriority.FATAL.isGreaterOrEqual(this.getChainedPriority()))
      callAppenders(new LoggingEvent(instanceFQCN, this, XPriority.FATAL, 
				     message, null));
  }
  /**
     This method overrides {@link Category#getInstance} by supplying
     its own factory type as a parameter.
   */
  public 
  static
  Category getInstance(String name) {
    return Category.getInstance(name, factory); 
  }
  public
  String[] getOptionStrings() {
    return (new String[] {SUFFIX_OPTION});
  }
  public
  void setOption(String option, String value) {
    System.out.println(option+""=""+value);
    if(option == null) {
      return;
    }
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      this.suffix = value;
      System.out.println(""Setting suffix to""+suffix);
    }
  }
  public
  void trace(String message) { 
    // disable is defined in Category
    if(disable <=  XPriority.TRACE_INT) return;   
    if(XPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      callAppenders(new LoggingEvent(instanceFQCN, this, XPriority.TRACE, message, 
				     null));
  }
  // Any sub-class of Category must also have its own implementation of 
  // CategoryFactory.
  private static class XFactory implements CategoryFactory {
    XFactory() {
    }
    public
    Category makeNewCategoryInstance(String name) {
      return new XCategory(name);
    }
  }
}
"
org.apache.log4j.xml.examples.XMLSample,"package org.apache.log4j.xml.examples;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.net.*;
/**
   This <a href=""doc-files/XMLSample.java"">example code</a> shows how to
   read an XML based configuration file using a DOM parser.
   <p>Sample XML files <a href=""doc-files/sample1.xml"">sample1.xml</a>
   and <a href=""doc-files/sample2.xml"">sample2.xml</a> are provided.
   <p>Note that the log4j.dtd is not in the local directory.
   It is found by the class loader.
   @author Ceki G&uuml;lc&uuml;
*/
public class XMLSample {
  static Category cat = Category.getInstance(XMLSample.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    sample();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + XMLSample.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void sample() {
    int i = -1;
    Category root = Category.getRoot();    
    cat.debug(""Message "" + ++i);
    cat.warn (""Message "" + ++i);
    cat.error(""Message "" + ++i);        
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
  }
}
"
org.apache.log4j.xml.examples.XPriority,"package org.apache.log4j.xml.examples;
import org.apache.log4j.Priority;
/**
   This class introduces a new priority level called TRACE. TRACE has
   lower priority than DEBUG.
 */
public class XPriority extends Priority {
  static final int  TRACE_INT  = 800;
  static final int  FATAL_INT  = 1;
  // We assimilate FATAL to EMERG on Syslog  
  static final int SYSLOG_FATAL_INT  = 0;  
  // We assimilate TRACE to DEBUG on Syslog
  static final int SYSLOG_TRACE_INT  = 7;
  public static final XPriority TRACE = new XPriority(TRACE_INT, ""TRACE"", 7);
  public static final XPriority FATAL = new XPriority(FATAL_INT, ""FATAL"", 
						      FATAL_INT);
  protected
  XPriority(int level, String strLevel, int syslogEquiv) {
    super(level, strLevel, syslogEquiv);
  }
  public
  static
  Priority toPriority(String sArg) {
    if(sArg == null)
       return XPriority.TRACE;
    String stringVal = sArg.toUpperCase();
    if(stringVal.equals(""TRACE"")) return XPriority.TRACE; 
    if(stringVal.equals(""FATAL"")) return XPriority.FATAL;
    return Priority.toPriority(sArg);
  }
  public
  static
  Priority toPriority(int i) throws  IllegalArgumentException {
    switch(i) {
    case TRACE_INT: return XPriority.TRACE;
    case FATAL_INT: return XPriority.FATAL;
    }
    return Priority.toPriority(i);
  }
}
"
org.apache.log4j.xml.examples.XTest,"package org.apache.log4j.xml.examples;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.net.*;
/**
   A simple example showing Category sub-classing. It shows the
   minimum steps necessary to implement one's {@link
   org.apache.log4j.spi.CategoryFactory} and that sub-classes can follow the
   hiearchy
   See <b><a href=""doc-files/XCategory.java"">source
   code</a></b> for more details.
 */
public class XTest {
  /**
     This program will just print 
     <pre>
       DEBUG [main] some.cat - Hello world.
     </pre>
     and exit.
   */
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    sample();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + XTest.class.getName() +
			""configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void sample() {
    int i = -1;
    XCategory cat = (XCategory) XCategory.getInstance(""some.cat"");    
    Category root = Category.getRoot();    
    cat.trace(""Message "" + ++i);
    cat.debug(""Message "" + ++i);
    cat.warn (""Message "" + ++i);
    cat.error(""Message "" + ++i);        
    cat.fatal(""Message "" + ++i);        
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
  }
}
"
org.apache.log4j.xml.test.DisableOverrideTest,"package org.apache.log4j.xml.test;
import org.apache.log4j.Category;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
//import org.xml.sax.InputSource;
//import org.apache.log4j.xml.examples.ReportParserError;
//import org.apache.xerces.parsers.DOMParser;
public class DisableOverrideTest {
  static Category CAT = Category.getInstance(DisableOverrideTest.class.getName());
  public static void main( String[] argv) {
    String configFile = null;
    if(argv.length == 1) 
      configFile = argv[0];
    else 
      Usage(""Wrong number of arguments."");
    //try {
      //DOMParser domParser = new DOMParser();
      //domParser.setFeature(""http://xml.org/sax/features/validation"", true);
      //domParser.setFeature(""http://apache.org/xml/features/validation/dynamic"",
      //		   true);      
      //domParser.setErrorHandler(new ReportParserError());      
      //domParser.parse(new InputSource(configFile));
      //DOMConfigurator.configure(domParser.getDocument().getDocumentElement());
    //}
    //catch(Exception e) {
    //System.err.println(""Could not initialize test program."");
    //e.printStackTrace();
    // System.exit(1);           
    //}
    DOMConfigurator.configure(configFile);
    DOMConfigurator.disableInfo();       
    CAT.debug(""Hello world"");
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+ DisableOverrideTest.class.getName() +
		       ""configFile"");
    System.exit(1);
  }
}
"
org.apache.log4j.xml.test.DOMTest,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml.test;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
//import org.apache.log4j.xml.examples.ReportParserError;
//import org.apache.xerces.parsers.DOMParser;
//import java.io.FileInputStream;
//import org.xml.sax.InputSource;
/**
   @author Ceki G&uuml;lc&uuml;
*/
public class DOMTest {
  static Category cat = Category.getInstance(DOMTest.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DOMTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
    //try {
      //DOMParser domParser = new DOMParser();
      //domParser.setFeature(""http://xml.org/sax/features/validation"", true);
      //domParser.setFeature(""http://xml.org/sax/features/namespaces"", true); 
      //domParser.setErrorHandler(new ReportParserError());      
      //domParser.parse(new InputSource(configFile));
      //DOMConfigurator.configure(domParser.getDocument().getDocumentElement() );
      //}
    //catch(Exception e) {
    //System.err.println(""Could not initialize test program."");
    //e.printStackTrace();
    //System.exit(1);		
    //}
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        
    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);        
    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        
    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    
  }
}
"
org.apache.log4j.xml.test.SubClassTest,"package org.apache.log4j.xml.test;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.xml.examples.ReportParserError;
//import org.apache.xerces.parsers.DOMParser;
//import java.io.FileInputStream;
//import org.xml.sax.InputSource;
/**
   @author Ceki G&uuml;lc&uuml;
*/
public class SubClassTest {
  static TCategory cat = (TCategory) 
                        TCategory.getInstance(SubClassTest.class.getName());
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");
    test();
  }
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + SubClassTest.class.getName() +
			"" configFile"");
    System.exit(1);
  }
  static
  void init(String configFile) {
    DOMConfigurator.configure(configFile);
  }
  static
  void test() {
    int i = -1;
    Category root = Category.getRoot();
    cat.trace(""Message "" + ++i);
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);
    cat.info (""Message "" + ++i);
    cat.warn (""Message "" + ++i);
    cat.error(""Message "" + ++i);    
    cat.log(Priority.FATAL, ""Message "" + ++i);    
    Exception e = new Exception(""Just testing"");
    cat.trace(""Message "" + ++i, e);
    cat.debug(""Message "" + ++i, e);
    cat.error(""Message "" + ++i, e); 
  }
}
"
org.apache.log4j.xml.test.TCategory,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */
package org.apache.log4j.xml.test;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.xml.test.TPriority;
/**
   A simple example showing Category sub-classing. It shows the
   minimum steps necessary to implement one's {@link CategoryFactory} 
   and that sub-classes can follow the hiearchy 
   See <b><a href=""doc-files/XCategory.java"">source
   code</a></b> for more details.
 */
public class TCategory extends Category implements OptionHandler {
  // It's enough to instantiate a factory once and for all.
  private static TFactory factory = new TFactory();
  static String instanceFQCN = TCategory.class.getName();
  public static final String SUFFIX_OPTION = ""Suffix"";
  String suffix;
  /**
     Just calls the parent constuctor.
   */
  public TCategory(String name) {
    super(name);
  }
  public
  void activateOptions() {
  }
  /**
     Overrides the standard debug method by appending "" world"" to each
     message.  */
  public 
  void debug(String message) {
    log(instanceFQCN, Priority.DEBUG, message + suffix, null);
  }
  /**
     This method overrides {@link Category#getInstance} by supplying
     its own factory type as a parameter.
   */
  public 
  static
  Category getInstance(String name) {
    return Category.getInstance(name, factory); 
  }
  public
  String[] getOptionStrings() {
    return (new String[] {SUFFIX_OPTION});
  }
  public
  void setOption(String option, String value) {
    System.out.println(option+""=""+value);
    if(option == null) {
      return;
    }
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      this.suffix = value;
      System.out.println(""Setting suffix to""+suffix);
    }
  }
  public
  void trace(String message) { 
    // disable is a static variable defined in Category class
    if(disable <=  TPriority.TRACE_INT) return;   
    if(TPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      callAppenders(new LoggingEvent(instanceFQCN, this, 
				     TPriority.TRACE, message, null));
  }
  public
  void trace(String message, Exception e) { 
    // disable is a static variable defined in Category class
    if(disable <=  TPriority.TRACE_INT) return;   
    if(TPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      callAppenders(new LoggingEvent(instanceFQCN, this, 
				     TPriority.TRACE, message, e));
  }
  // Any sub-class of Category must also have its own implementation of 
  // CategoryFactory.
  private static class TFactory implements CategoryFactory {
    TFactory() {
    }
    public
    Category makeNewCategoryInstance(String name) {
      return new TCategory(name);
    }
  }
}
"
org.apache.log4j.xml.test.TPriority,"package org.apache.log4j.xml.test;
import org.apache.log4j.Priority;
/**
   This class introduces a new priority level called TRACE. TRACE has
   lower priority than DEBUG.
 */
public class TPriority extends Priority {
  static final int  TRACE_INT  = 8000;
  // We assimilate TRACE to DEBUG on Syslog
  static final int SYSLOG_TRACE_INT  = 7;  
  private static String TRACE_STR  = ""TRACE"";
  public static final TPriority TRACE = new TPriority(TRACE_INT, ""TRACE"", 7);
  protected
  TPriority(int level, String strLevel, int syslogEquiv) {
    super(level, strLevel, syslogEquiv);
  }
  public
  static
  Priority toPriority(String sArg) {
    if(sArg == null)
       return TPriority.TRACE;
    String stringVal = sArg.toUpperCase();
    if(stringVal.equalsIgnoreCase(TRACE_STR)) return TPriority.TRACE; 
    return Priority.toPriority(sArg);
  }
  public
  static
  Priority toPriority(int i) throws  IllegalArgumentException {
    switch(i) {
    case TRACE_INT: return TPriority.TRACE;
    }
    return Priority.toPriority(i);
  }
}
"
