metric_name,file
org.apache.velocity.Template,"package org.apache.velocity;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import java.io.Writer;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextAdapterImpl;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.MethodInvocationException;
/**
 * This class is used for controlling all template
 * operations. This class uses a parser created
 * by JavaCC to create an AST that is subsequently
 * traversed by a Visitor. 
 *
 * <pre>
 * Template template = Velocity.getTemplate(""test.wm"");
 * Context context = new VelocityContext();
 *
 * context.put(""foo"", ""bar"");
 * context.put(""customer"", new Customer());
 *
 * template.merge(context, writer);
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Template.java,v 1.36.4.1 2004/03/03 22:28:24 geirm Exp $
 */
public class Template extends Resource
{
    /**
     *   To keep track of whether this template has been
     *   initialized. We use the document.init(context)
     *   to perform this.
     */
    private boolean initialized = false;
    private Exception errorCondition = null;
    /** Default constructor */
    public Template()
    {
    }
    /**
     *  gets the named resource as a stream, parses and inits
     *
     * @return true if successful
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception some other problem, should only be from 
     *          initialization of the template AST.
     */
    public boolean process()
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        data = null;
        InputStream is = null;
        errorCondition = null;
        /*
         *  first, try to get the stream from the loader
         */
        try 
        {
            is = resourceLoader.getResourceStream(name);
        }
        catch( ResourceNotFoundException rnfe )
        {
            /*
             *  remember and re-throw
             */
            errorCondition = rnfe;
            throw rnfe;
        }
        /*
         *  if that worked, lets protect in case a loader impl
         *  forgets to throw a proper exception
         */
        if (is != null)
        {
            /*
             *  now parse the template
             */
            try
            {
                BufferedReader br = new BufferedReader( new InputStreamReader( is, encoding ) );
                data = rsvc.parse( br, name);
                initDocument();
                return true;
            }
            catch( UnsupportedEncodingException  uce )
            {   
                String msg = ""Template.process : Unsupported input encoding : "" + encoding 
                + "" for template "" + name;
                errorCondition  = new ParseErrorException( msg );
                throw errorCondition;
            }
            catch ( ParseException pex )
            {
                /*
                 *  remember the error and convert
                 */
               errorCondition =  new ParseErrorException( pex.getMessage() );
               throw errorCondition;
            }
            catch( Exception e )
            {
                /*
                 *  who knows?  Something from initDocument()
                 */
                errorCondition = e;
                throw e;
            }
            finally 
            {
                /*
                 *  Make sure to close the inputstream when we are done.
                 */
                is.close();
            }
        }    
        else
        {
            /* 
             *  is == null, therefore we have some kind of file issue
             */
            errorCondition = new ResourceNotFoundException(""Unknown resource error for resource "" + name );
            throw errorCondition;
        }
    }
    /**
     *  initializes the document.  init() is not longer 
     *  dependant upon context, but we need to let the 
     *  init() carry the template name down throught for VM
     *  namespace features
     */
    public void initDocument()
        throws Exception
    {
        /*
         *  send an empty InternalContextAdapter down into the AST to initialize it
         */
        InternalContextAdapterImpl ica = new InternalContextAdapterImpl(  new VelocityContext() );
        try
        {
            /*
             *  put the current template name on the stack
             */
            ica.pushCurrentTemplateName( name );
            /*
             *  init the AST
             */
            ((SimpleNode)data).init( ica, rsvc);
        }
        finally
        {
            /*  
             *  in case something blows up...
             *  pull it off for completeness
             */
            ica.popCurrentTemplateName();
        }
    }
    /**
     * The AST node structure is merged with the
     * context to produce the final output. 
     *
     * Throws IOException if failure is due to a file related
     * issue, and Exception otherwise
     *
     *  @param context Conext with data elements accessed by template
     *  @param writer output writer for rendered template
     *  @throws ResourceNotFoundException if template not found
     *          from any available source.
     *  @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     *  @throws  Exception  anything else. 
     */
    public void merge( Context context, Writer writer)
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        /*
         *  we shouldn't have to do this, as if there is an error condition, 
         *  the application code should never get a reference to the 
         *  Template
         */
        if (errorCondition != null)
        {
            throw errorCondition;
        }
        if( data != null)
        {
            /*
             *  create an InternalContextAdapter to carry the user Context down
             *  into the rendering engine.  Set the template name and render()
             */
            InternalContextAdapterImpl ica = new InternalContextAdapterImpl( context );
            try
            {
                ica.pushCurrentTemplateName( name );
                ica.setCurrentResource( this );
                ( (SimpleNode) data ).render( ica, writer);
            }
            finally
            {
                /*
                 *  lets make sure that we always clean up the context 
                 */
                ica.popCurrentTemplateName();
                ica.setCurrentResource( null );
            }
        }
        else
        {
            /*
             * this shouldn't happen either, but just in case.
             */
            String msg = ""Template.merge() failure. The document is null, "" + 
                ""most likely due to parsing error."";
            rsvc.error(msg);
            throw new Exception(msg);
        }
    }
}
"
org.apache.velocity.VelocityContext,"package org.apache.velocity;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.HashMap;
import java.util.Map;
import org.apache.velocity.context.AbstractContext;
import org.apache.velocity.context.Context;
/**
 *  General purpose implemention of the application Context 
 *  interface for general application use.  This class should 
 *  be used in place of the original Context class.
 *
 *  This implementation uses a HashMap  (@see java.util.HashMap ) 
 *  for data storage.
 *
 *  This context implementation cannot be shared between threads
 *  without those threads synchronizing access between them, as 
 *  the HashMap is not synchronized, nor are some of the fundamentals
 *  of AbstractContext.  If you need to share a Context between 
 *  threads with simultaneous access for some reason, please create 
 *  your own and extend the interface Context 
 *  
 *  @see org.apache.velocity.context.Context
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 *  @author <a href=""mailto:fedor.karpelevitch@home.com"">Fedor Karpelevitch</a>
 *  @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 *  @version $Id: VelocityContext.java,v 1.6.8.1 2004/03/03 22:27:36 geirm Exp $
 */
public class VelocityContext extends AbstractContext implements Cloneable
{
    /**
     *  Storage for key/value pairs.
     */
    private Map context = null;
    /** 
     *  Creates a new instance (with no inner context).
     */
    public VelocityContext()
    {
        this(null, null);
    }
    /** 
     *  Creates a new instance with the provided storage (and no inner
     *  context).
     */
    public VelocityContext(Map context)
    {
        this(context, null);
    }
    /**
     *  Chaining constructor, used when you want to 
     *  wrap a context in another.  The inner context
     *  will be 'read only' - put() calls to the 
     *  wrapping context will only effect the outermost
     *  context
     *
     *  @param innerContext The <code>Context</code> implementation to
     *  wrap.
     */
    public VelocityContext( Context innerContext )
    {
        this(null, innerContext);
    }
    /**
     *  Initializes internal storage (never to <code>null</code>), and
     *  inner context.
     *
     *  @param context Internal storage, or <code>null</code> to
     *  create default storage.
     *  @param innerContext Inner context.
     */
    public VelocityContext(Map context, Context innerContext)
    {
        super(innerContext);
        this.context = (context == null ? new HashMap() : context);
    }
    /**
     *  retrieves value for key from internal
     *  storage
     *
     *  @param key name of value to get
     *  @return value as object
     */
    public Object internalGet( String key )
    {
        return context.get( key );
    }        
    /**
     *  stores the value for key to internal
     *  storage
     *
     *  @param key name of value to store
     *  @param value value to store
     *  @return previous value of key as Object
     */
    public Object internalPut( String key, Object value )
    {
        return context.put( key, value );
    }
    /**
     *  determines if there is a value for the
     *  given key
     *
     *  @param key name of value to check
     *  @return true if non-null value in store
     */
    public  boolean internalContainsKey(Object key)
    {
        return context.containsKey( key );
    }
    /**
     *  returns array of keys
     *
     *  @return keys as []
     */
    public  Object[] internalGetKeys()
    {
        return context.keySet().toArray();
    }
    /**
     *  remove a key/value pair from the
     *  internal storage
     *
     *  @param key name of value to remove
     *  @return value removed
     */
    public  Object internalRemove(Object key)
    {
        return context.remove( key );
    }
    /**
     * Clones this context object.
     *
     * @return A deep copy of this <code>Context</code>.
     */
    public Object clone()
    {
        VelocityContext clone = null;
        try
        {
            clone = (VelocityContext) super.clone();
            clone.context = new HashMap(context);
        }
        catch (CloneNotSupportedException ignored)
        {
        }
        return clone;
    }
}
"
org.apache.velocity.anakia.AnakiaElement,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import java.util.List;
/**
 * A JDOM {@link Element} that is tailored for Anakia needs. It has
 * {@link #selectNodes(String)} method as well as a {@link #toString()} that
 * outputs the XML serialized form of the element. This way it acts in much the
 * same way as a single-element {@link NodeList} would.
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: AnakiaElement.java,v 1.3.4.1 2004/03/03 23:22:03 geirm Exp $
 */
public class AnakiaElement extends Element
{
    private static final XMLOutputter DEFAULT_OUTPUTTER = new XMLOutputter();
    /**
     * <p>
     * This will create a new <code>AnakiaElement</code>
     *   with the supplied (local) name, and define
     *   the <code>{@link Namespace}</code> to be used.
     * If the provided namespace is null, the element will have 
     * no namespace.
     * </p>
     *
     * @param name <code>String</code> name of element.
     * @namespace <code>Namespace</code> to put element in.
     */
    public AnakiaElement(String name, Namespace namespace)
    {
        super(name, namespace);
    }
    /**
     * <p>
     *  This will create an <code>AnakiaElement</code> in no
     *    <code>{@link Namespace}</code>.
     * </p>
     *
     * @param name <code>String</code> name of element.
     */
    public AnakiaElement(String name)
    {
        super(name);
    }
    /**
     * <p>
     *  This will create a new <code>AnakiaElement</code> with
     *    the supplied (local) name, and specifies the URI
     *    of the <code>{@link Namespace}</code> the <code>Element</code>
     *    should be in, resulting it being unprefixed (in the default
     *    namespace).
     * </p>
     *
     * @param name <code>String</code> name of element.
     * @param uri <code>String</code> URI for <code>Namespace</code> element
     *        should be in.
     */
    public AnakiaElement(String name, String uri)
    {
        super(name, uri);
    }
    /**
     * <p>
     *  This will create a new <code>AnakiaElement</code> with
     *    the supplied (local) name, and specifies the prefix and URI
     *    of the <code>{@link Namespace}</code> the <code>Element</code>
     *    should be in.
     * </p>
     *
     * @param name <code>String</code> name of element.
     * @param uri <code>String</code> URI for <code>Namespace</code> element
     *        should be in.
     */
    public AnakiaElement(String name, String prefix, String uri)
    {
        super(name, prefix, uri);
    }
    /**
     * Applies an XPath expression to this element and returns the resulting
     * node list. In order for this method to work, your application must have
     * access to <a href=""http://code.werken.com"">werken.xpath</a> library
     * classes. The implementation does cache the parsed format of XPath
     * expressions in a weak hash map, keyed by the string representation of
     * the XPath expression. As the string object passed as the argument is
     * usually kept in the parsed template, this ensures that each XPath
     * expression is parsed only once during the lifetime of the template that
     * first invoked it.
     * @param xpathExpression the XPath expression you wish to apply
     * @return a NodeList representing the nodes that are the result of
     * application of the XPath to the current element. It can be empty.
     */
    public NodeList selectNodes(String xpathExpression)
    {
        return new NodeList(XPathCache.getXPath(xpathExpression).applyTo(this), false);
    }
    /**
     * Returns the XML serialized form of this element, as produced by the default
     * {@link XMLOutputter}.
     */
    public String toString()
    {
        return DEFAULT_OUTPUTTER.outputString(this);
    }
    /**
     * <p>
     * This returns the full content of the element as a NodeList which
     * may contain objects of type <code>String</code>, <code>Element</code>,
     * <code>Comment</code>, <code>ProcessingInstruction</code>,
     * <code>CDATA</code>, and <code>EntityRef</code>.  
     * The List returned is ""live"" in document order and modifications 
     * to it affect the element's actual contents.  Whitespace content is 
     * returned in its entirety.
     * </p>
     *
     * @return a <code>List</code> containing the mixed content of the
     *         element: may contain <code>String</code>,
     *         <code>{@link Element}</code>, <code>{@link Comment}</code>,
     *         <code>{@link ProcessingInstruction}</code>,
     *         <code>{@link CDATA}</code>, and
     *         <code>{@link EntityRef}</code> objects.
     */
    public List getContent()
    {
        return new NodeList(super.getContent(), false);
    }
    /**
     * <p>
     * This returns a <code>NodeList</code> of all the child elements
     * nested directly (one level deep) within this element, as 
     * <code>Element</code> objects.  If this target element has no nested 
     * elements, an empty List is returned.  The returned list is ""live""
     * in document order and changes to it affect the element's actual 
     * contents.
     * </p>
     * <p>
     * This performs no recursion, so elements nested two levels
     *   deep would have to be obtained with:
     * <pre>
     * <code>
     *   Iterator itr = currentElement.getChildren().iterator();
     *   while (itr.hasNext()) {
     *     Element oneLevelDeep = (Element)nestedElements.next();
     *     List twoLevelsDeep = oneLevelDeep.getChildren();
     *     // Do something with these children
     *   }
     * </code>
     * </pre>
     * </p>
     *
     * @return list of child <code>Element</code> objects for this element
     */
    public List getChildren()
    {
        return new NodeList(super.getChildren(), false);
    }
    /**
     * <p>
     * This returns a <code>NodeList</code> of all the child elements
     * nested directly (one level deep) within this element with the given
     * local name and belonging to no namespace, returned as 
     * <code>Element</code> objects.  If this target element has no nested 
     * elements with the given name outside a namespace, an empty List 
     * is returned.  The returned list is ""live"" in document order
     * and changes to it affect the element's actual contents.
     * </p>
     * <p>
     * Please see the notes for <code>{@link #getChildren}</code>
     * for a code example.
     * </p>
     *
     * @param name local name for the children to match
     * @return all matching child elements
     */
    public List getChildren(String name)
    {
        return new NodeList(super.getChildren(name));
    }
    /**
     * <p>
     * This returns a <code>NodeList</code> of all the child elements
     * nested directly (one level deep) within this element with the given
     * local name and belonging to the given Namespace, returned as 
     * <code>Element</code> objects.  If this target element has no nested 
     * elements with the given name in the given Namespace, an empty List 
     * is returned.  The returned list is ""live"" in document order
     * and changes to it affect the element's actual contents.
     * </p>
     * <p>
     * Please see the notes for <code>{@link #getChildren}</code>
     * for a code example.
     * </p>
     *
     * @param name local name for the children to match
     * @param ns <code>Namespace</code> to search within
     * @return all matching child elements
     */
    public List getChildren(String name, Namespace ns)
    {
        return new NodeList(super.getChildren(name, ns));
    }
    /**
     * <p>
     * This returns the complete set of attributes for this element, as a 
     * <code>NodeList</code> of <code>Attribute</code> objects in no particular 
     * order, or an empty list if there are none.  
     * The returned list is ""live"" and changes to it affect the 
     * element's actual attributes.
     * </p>
     *
     * @return attributes for the element
     */
    public List getAttributes()
    {
        return new NodeList(super.getAttributes());
    }
}
"
org.apache.velocity.anakia.AnakiaJDOMFactory,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.DefaultJDOMFactory;
/**
 * A customized JDOMFactory for Anakia that produces {@link AnakiaElement}
 * instances instead of ordinary JDOM {@link Element} instances.
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: AnakiaJDOMFactory.java,v 1.2.8.1 2004/03/03 23:22:04 geirm Exp $
 */
public class AnakiaJDOMFactory extends DefaultJDOMFactory
{
    public AnakiaJDOMFactory()
    {
    }
    public Element element(String name, Namespace namespace)
    {
        return new AnakiaElement(name, namespace);
    }
    public Element element(String name)
    {
        return new AnakiaElement(name);
    }
    public Element element(String name, String uri)
    {
        return new AnakiaElement(name, uri);
    }
    public Element element(String name, String prefix, String uri)
    {
        return new AnakiaElement(name, prefix, uri);
    }
}
"
org.apache.velocity.anakia.AnakiaTask,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.StringTokenizer;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.xml.sax.SAXParseException;
import org.jdom.Document;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.apache.velocity.Template;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.VelocityContext;
/**
 * The purpose of this Ant Task is to allow you to use 
 * Velocity as an XML transformation tool like XSLT is.
 * So, instead of using XSLT, you will be able to use this 
 * class instead to do your transformations. It works very
 * similar in concept to Ant's &lt;style&gt; task.
 * <p>
 * You can find more documentation about this class on the
 * Velocity 
 * <a href=""http://jakarta.apache.org/velocity/anakia.html"">Website</a>.
 *   
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: AnakiaTask.java,v 1.34.4.1 2004/03/03 23:22:04 geirm Exp $
 */
public class AnakiaTask extends MatchingTask
{
    /** <code>{@link SAXBuilder}</code> instance to use */
    private SAXBuilder builder;
    /** the destination directory */
    private File destDir = null;
    /** the base directory */
    private File baseDir = null;
    /** the style= attribute */
    private String style = null;
    /** the File to the style file */
    private File styleFile = null;
    /** last modified of the style sheet */
    private long styleSheetLastModified = 0;
    /** the projectFile= attribute */
    private String projectAttribute = null;
    /** the File for the project.xml file */
    private File projectFile = null;
    /** last modified of the project file if it exists */
    private long projectFileLastModified = 0;
    /** check the last modified date on files. defaults to true */
    private boolean lastModifiedCheck = true;
    /** the default output extension is .html */
    private String extension = "".html"";
    /** the template path */
    private String templatePath = null;
    /** the file to get the velocity properties file */
    private File velocityPropertiesFile = null;
    /** the VelocityEngine instance to use */
    private VelocityEngine ve = new VelocityEngine();
    /**
     * Constructor creates the SAXBuilder.
     */
    public AnakiaTask()
    {
        builder = new SAXBuilder();
        builder.setFactory(new AnakiaJDOMFactory());
    }
    /**
     * Set the base directory.
     */
    public void setBasedir(File dir)
    {
        baseDir = dir;
    }
    /**
     * Set the destination directory into which the VSL result
     * files should be copied to
     * @param dirName the name of the destination directory
     */
    public void setDestdir(File dir)
    {
        destDir = dir;
    }
    /**
     * Allow people to set the default output file extension
     */
    public void setExtension(String extension)
    {
        this.extension = extension;
    }
    /**
     * Allow people to set the path to the .vsl file
     */
    public void setStyle(String style)
    {
        this.style = style;
    }
    /**
     * Allow people to set the path to the project.xml file
     */
    public void setProjectFile(String projectAttribute)
    {
        this.projectAttribute = projectAttribute;
    }
    /**
     * Set the path to the templates.
     * The way it works is this:
     * If you have a Velocity.properties file defined, this method
     * will <strong>override</strong> whatever is set in the 
     * Velocity.properties file. This allows one to not have to define
     * a Velocity.properties file, therefore using Velocity's defaults
     * only.
     */
    public void setTemplatePath(File templatePath)
     {
         try 
         {
             this.templatePath = templatePath.getCanonicalPath();
         } 
         catch (java.io.IOException ioe) 
         {
             throw new BuildException(ioe);
         }
     }
    /**
     * Allow people to set the path to the velocity.properties file
     * This file is found relative to the path where the JVM was run.
     * For example, if build.sh was executed in the ./build directory, 
     * then the path would be relative to this directory.
     * This is optional based on the setting of setTemplatePath().
     */
    public void setVelocityPropertiesFile(File velocityPropertiesFile)
    {
        this.velocityPropertiesFile = velocityPropertiesFile;
    }
    /**
     * Turn on/off last modified checking. by default, it is on.
     */
    public void setLastModifiedCheck(String lastmod)
    {
        if (lastmod.equalsIgnoreCase(""false"") || lastmod.equalsIgnoreCase(""no"") 
                || lastmod.equalsIgnoreCase(""off""))
        {
            this.lastModifiedCheck = false;
        }
    }
    /**
     * Main body of the application
     */
    public void execute () throws BuildException
    {
        DirectoryScanner scanner;
        String[]         list;
        String[]         dirs;
        if (baseDir == null)
        {
            baseDir = project.resolveFile(""."");
        }
        if (destDir == null )
        {
            String msg = ""destdir attribute must be set!"";
            throw new BuildException(msg);
        }
        if (style == null) 
        {
            throw new BuildException(""style attribute must be set!"");
        }
        if (velocityPropertiesFile == null)
        {
            velocityPropertiesFile = new File(""velocity.properties"");
        }
        /*
         * If the props file doesn't exist AND a templatePath hasn't 
         * been defined, then throw the exception.
         */
        if ( !velocityPropertiesFile.exists() && templatePath == null )
        {
            throw new BuildException (""No template path and could not "" + 
                ""locate velocity.properties file: "" + 
                velocityPropertiesFile.getAbsolutePath());
        }
        log(""Transforming into: "" + destDir.getAbsolutePath(), Project.MSG_INFO);
        // projectFile relative to baseDir
        if (projectAttribute != null && projectAttribute.length() > 0)
        {
            projectFile = new File(baseDir, projectAttribute);
            if (projectFile.exists())
            {
                projectFileLastModified = projectFile.lastModified();
            }
            else
            {
                log (""Project file is defined, but could not be located: "" + 
                    projectFile.getAbsolutePath(), Project.MSG_INFO );
                projectFile = null;
            }
        }
        Document projectDocument = null;
        try
        {
            if ( velocityPropertiesFile.exists() )
            {
                ve.init(velocityPropertiesFile.getAbsolutePath());
            }
            else if (templatePath != null && templatePath.length() > 0)
            {
                ve.setProperty( RuntimeConstants.FILE_RESOURCE_LOADER_PATH,
                    templatePath);
                ve.init();
            }
            // get the last modification of the VSL stylesheet
            styleSheetLastModified = ve.getTemplate( style ).getLastModified();
            // Build the Project file document
            if (projectFile != null)
            {
                projectDocument = builder.build(projectFile);
            }
        }
        catch (Exception e)
        {
            log(""Error: "" + e.toString(), Project.MSG_INFO);
            throw new BuildException(e);
        }
        // find the files/directories
        scanner = getDirectoryScanner(baseDir);
        // get a list of files to work on
        list = scanner.getIncludedFiles();
        for (int i = 0;i < list.length; ++i)
        {
            process( baseDir, list[i], destDir, projectDocument );
        }
    }    
    /**
     * Process an XML file using Velocity
     */
    private void process(File baseDir, String xmlFile, File destDir, 
                         Document projectDocument)
        throws BuildException
    {
        File   outFile=null;
        File   inFile=null;
        Writer writer = null;
        try
        {
            // the current input file relative to the baseDir
            inFile = new File(baseDir,xmlFile);
            // the output file relative to basedir
            outFile = new File(destDir, 
                            xmlFile.substring(0,
                            xmlFile.lastIndexOf('.')) + extension);
            // only process files that have changed
            if (lastModifiedCheck == false || 
                    (inFile.lastModified() > outFile.lastModified() ||
                    styleSheetLastModified > outFile.lastModified() ||
                    projectFileLastModified > outFile.lastModified()))
            {
                ensureDirectoryFor( outFile );
                //-- command line status
                log(""Input:  "" + xmlFile, Project.MSG_INFO );
                // Build the JDOM Document
                Document root = builder.build(inFile);
                // Shove things into the Context
                VelocityContext context = new VelocityContext();
                /*
                 *  get the property TEMPLATE_ENCODING
                 *  we know it's a string...
                 */
                String encoding = (String) ve.getProperty( RuntimeConstants.OUTPUT_ENCODING );
                if (encoding == null || encoding.length() == 0 
                    || encoding.equals(""8859-1"") || encoding.equals(""8859_1""))
                {
                    encoding = ""ISO-8859-1"";
                }
                OutputWrapper ow = new OutputWrapper();
                ow.setEncoding (encoding);
                context.put (""root"", root.getRootElement());
                context.put (""xmlout"", ow );
                context.put (""relativePath"", getRelativePath(xmlFile));
                context.put (""treeWalk"", new TreeWalker());
                context.put (""xpath"", new XPathTool() );
                context.put (""escape"", new Escape() );
                context.put (""date"", new java.util.Date() );
                // only put this into the context if it exists.
                if (projectDocument != null)
                {
                    context.put (""project"", projectDocument.getRootElement());
                }
                // Process the VSL template with the context and write out
                // the result as the outFile.
                writer = new BufferedWriter(new OutputStreamWriter(
                                            new FileOutputStream(outFile),
                                                encoding));
                // get the template to process
                Template template = ve.getTemplate(style);
                template.merge(context, writer);
                log(""Output: "" + outFile, Project.MSG_INFO );
            }
        }
        catch (JDOMException e)
        {
            if (outFile != null ) outFile.delete();
            if (e.getCause() != null)
            {
                Throwable rootCause = e.getCause();
                if (rootCause instanceof SAXParseException)
                {
                    System.out.println("""");
                    System.out.println(""Error: "" + rootCause.getMessage());
                    System.out.println(
                        ""       Line: "" + 
                            ((SAXParseException)rootCause).getLineNumber() + 
                        "" Column: "" + 
                            ((SAXParseException)rootCause).getColumnNumber());
                    System.out.println("""");
                }
                else
                {
                    rootCause.printStackTrace();
                }
            }
            else
            {
                e.printStackTrace();
            }
//            log(""Failed to process "" + inFile, Project.MSG_INFO);
        }
        catch (Throwable e)
        {
//            log(""Failed to process "" + inFile, Project.MSG_INFO);
            if (outFile != null)
            {
                outFile.delete();
            }
            e.printStackTrace();
        }        
        finally
        {
            if (writer != null)
            {
                try
                {
                    writer.flush();
                    writer.close();
                }
                catch (Exception e)
                {
                }
            }
        }
    }
    /**
     * Hacky method to figure out the relative path
     * that we are currently in. This is good for getting
     * the relative path for images and anchor's.
     */
    private String getRelativePath(String file)
    {
        if (file == null || file.length()==0)
            return """";
        StringTokenizer st = new StringTokenizer(file, ""/\\"");
        // needs to be -1 cause ST returns 1 even if there are no matches. huh?
        int slashCount = st.countTokens() - 1;
        StringBuffer sb = new StringBuffer();        
        for (int i=0;i<slashCount ;i++ )
        {
            sb.append (""../"");
        }
        if (sb.toString().length() > 0)
        {
            return StringUtils.chop(sb.toString(), 1);
        }
        else
        {
            return ""."";
        }
    }
    /**
     * create directories as needed
     */
    private void ensureDirectoryFor( File targetFile ) throws BuildException
    {
        File directory = new File( targetFile.getParent() );
        if (!directory.exists())
        {
            if (!directory.mkdirs())
            {
                throw new BuildException(""Unable to create directory: "" 
                                         + directory.getAbsolutePath() );
            }
        }
    }
}    
"
org.apache.velocity.anakia.Escape,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class is for escaping CDATA sections. The code was 
 * ""borrowed"" from the JDOM code. I also added in escaping
 * of the "" -> &amp;quot; character.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: Escape.java,v 1.4.14.1 2004/03/03 23:22:04 geirm Exp $
 */
public class Escape
{
    /**
     * Empty constructor
     */
    public Escape()
    {
        // left blank on purpose
    }
    /**
     * Do the escaping.
     */
    public static final String getText(String st)
    {
        StringBuffer buff = new StringBuffer();
        char[] block = st.toCharArray();
        String stEntity = null;
        int i, last;
        for (i=0, last=0; i < block.length; i++)
        {
            switch(block[i])
            {
                case '<' :
                    stEntity = ""&lt;"";
                    break;
                case '>' :
                    stEntity = ""&gt;"";
                    break;
                case '&' :
                    stEntity = ""&amp;"";
                    break;
                case '""' :
                    stEntity = ""&quot;"";
                    break;
                default :
                    /* no-op */ ;
            }
            if (stEntity != null)
            {
                buff.append(block, last, i - last);
                buff.append(stEntity);
                stEntity = null;
                last = i + 1;
            }
        }
        if(last < block.length)
        {
            buff.append(block, last, i - last);
        }
        return buff.toString();
    }
}
"
org.apache.velocity.anakia.NodeList,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import java.io.StringWriter;
import java.util.*;
import org.jdom.*;
import org.jdom.output.*;
/**
 * Provides a class for wrapping a list of JDOM objects primarily for use in template
 * engines and other kinds of text transformation tools.
 * It has a {@link #toString()} method that will output the XML serialized form of the
 * nodes it contains - again focusing on template engine usage, as well as the
 * {@link #selectNodes(String)} method that helps selecting a different set of nodes
 * starting from the nodes in this list. The class also implements the {@link java.util.List}
 * interface by simply delegating calls to the contained list (the {@link #subList(int, int)}
 * method is implemented by delegating to the contained list and wrapping the returned
 * sublist into a <code>NodeList</code>).
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: NodeList.java,v 1.2.4.1 2004/03/03 23:22:04 geirm Exp $
 */
public class NodeList implements List, Cloneable
{
    private static final AttributeXMLOutputter DEFAULT_OUTPUTTER = 
        new AttributeXMLOutputter();
    /** The contained nodes */
    private List nodes;
    /**
     * Creates an empty node list.
     */
    public NodeList()
    {
        nodes = new ArrayList();
    }
    /**
     * Creates a node list that holds a single {@link Document} node.
     */
    public NodeList(Document document)
    {
        this((Object)document);
    }
    /**
     * Creates a node list that holds a single {@link Element} node.
     */
    public NodeList(Element element)
    {
        this((Object)element);
    }
    private NodeList(Object object)
    {
        if(object == null)
        {
            throw new IllegalArgumentException(
                ""Cannot construct NodeList with null."");
        }
        nodes = new ArrayList(1);
        nodes.add(object);
    }
    /**
     * Creates a node list that holds a list of nodes. 
     * @param nodes the list of nodes this template should hold. The created 
     * template will copy the passed nodes list, so changes to the passed list
     * will not affect the model.
     */
    public NodeList(List nodes)
    {
        this(nodes, true);
    }
    /**
     * Creates a node list that holds a list of nodes. 
     * @param nodes the list of nodes this template should hold.
     * @param copy if true, the created template will copy the passed nodes
     * list, so changes to the passed list will not affect the model. If false,
     * the model will reference the passed list and will sense changes in it,
     * altough no operations on the list will be synchronized.
     */
    public NodeList(List nodes, boolean copy)
    {
        if(nodes == null)
        {
            throw new IllegalArgumentException(
                ""Cannot initialize NodeList with null list"");
        }
        this.nodes = copy ? new ArrayList(nodes) : nodes;
    }
    /**
     * Retrieves the underlying list used to store the nodes. Note however, that
     * you can fully use the underlying list through the <code>List</code> interface
     * of this class itself. You would probably access the underlying list only for
     * synchronization purposes.
     */
    public List getList()
    {
        return nodes;
    }
    /**
     * This method returns the string resulting from concatenation of string 
     * representations of its nodes. Each node is rendered using its XML
     * serialization format. This greatly simplifies creating XML-transformation
     * templates, as to output a node contained in variable x as XML fragment,
     * you simply write ${x} in the template (or whatever your template engine
     * uses as its expression syntax).
     */
    public String toString()
    {
        if(nodes.isEmpty())
        {
            return """";
        }
        StringWriter sw = new StringWriter(nodes.size() * 128);
        try
        {
            for(Iterator i = nodes.iterator(); i.hasNext();)
            {
                Object node = i.next();
                if(node instanceof Element)
                {
                    DEFAULT_OUTPUTTER.output((Element)node, sw);
                }
                else if(node instanceof Attribute)
                {
                    DEFAULT_OUTPUTTER.output((Attribute)node, sw);
                }
                else if(node instanceof Text)
                {
                    DEFAULT_OUTPUTTER.output((Text)node, sw);
                }
                else if(node instanceof Document)
                {
                    DEFAULT_OUTPUTTER.output((Document)node, sw);
                }
                else if(node instanceof ProcessingInstruction)
                {
                    DEFAULT_OUTPUTTER.output((ProcessingInstruction)node, sw);
                }
                else if(node instanceof Comment)
                {
                    DEFAULT_OUTPUTTER.output((Comment)node, sw);
                }
                else if(node instanceof CDATA)
                {
                    DEFAULT_OUTPUTTER.output((CDATA)node, sw);
                }
                else if(node instanceof DocType)
                {
                    DEFAULT_OUTPUTTER.output((DocType)node, sw);
                }
                else if(node instanceof EntityRef)
                {
                    DEFAULT_OUTPUTTER.output((EntityRef)node, sw);
                }
                else
                {
                    throw new IllegalArgumentException(
                        ""Cannot process a "" + 
                        (node == null 
                         ? ""null node"" 
                         : ""node of class "" + node.getClass().getName()));
                }
            }
        }
        catch(IOException e)
        {
            // Cannot happen as we work with a StringWriter in memory
            throw new Error();
        }
        return sw.toString();
    }
    /**
     * Returns a NodeList that contains the same nodes as this node list.
     * @throws CloneNotSupportedException if the contained list's class does
     * not have an accessible no-arg constructor.
     */
    public Object clone()
        throws CloneNotSupportedException
    {
        NodeList clonedList = (NodeList)super.clone();
        clonedList.cloneNodes();
        return clonedList;
    }
    private void cloneNodes()
        throws CloneNotSupportedException
    {
        Class listClass = nodes.getClass();
        try
        {
            List clonedNodes = (List)listClass.newInstance();
            clonedNodes.addAll(nodes);
            nodes = clonedNodes;
        }
        catch(IllegalAccessException e)
        {
            throw new CloneNotSupportedException(""Cannot clone NodeList since""
            + "" there is no accessible no-arg constructor on class ""
            + listClass.getName());
        }
        catch(InstantiationException e)
        {
            // Cannot happen as listClass represents a concrete, non-primitive,
            // non-array, non-void class - there's an instance of it in ""nodes""
            // which proves these assumptions.
            throw new Error(); 
        }
    }
    /**
     * Returns the hash code of the contained list.
     */
    public int hashCode()
    {
        return nodes.hashCode();
    }
    /**
     * Tests for equality with another object.
     * @param o the object to test for equality
     * @return true if the other object is also a NodeList and their contained
     * {@link List} objects evaluate as equals.
     */
    public boolean equals(Object o)
    {
        return o instanceof NodeList 
            ? ((NodeList)o).nodes.equals(nodes)
            : false;
    }
    /**
     * Applies an XPath expression to the node list and returns the resulting
     * node list. In order for this method to work, your application must have
     * access to <a href=""http://code.werken.com"">werken.xpath</a> library
     * classes. The implementation does cache the parsed format of XPath
     * expressions in a weak hash map, keyed by the string representation of
     * the XPath expression. As the string object passed as the argument is
     * usually kept in the parsed template, this ensures that each XPath
     * expression is parsed only once during the lifetime of the template that
     * first invoked it.
     * @param xpathExpression the XPath expression you wish to apply
     * @return a NodeList representing the nodes that are the result of
     * application of the XPath to the current node list. It can be empty.
     */
    public NodeList selectNodes(String xpathString)
    {
        return new NodeList(XPathCache.getXPath(xpathString).applyTo(nodes), false);
    }
// List methods implemented hereafter
    public boolean add(Object o)
    {
        return nodes.add(o);
    }
    public void add(int index, Object o)
    {
        nodes.add(index, o);
    }
    public boolean addAll(Collection c)
    {
        return nodes.addAll(c);
    }
    public boolean addAll(int index, Collection c)
    {
        return nodes.addAll(index, c);
    }
    public void clear()
    {
        nodes.clear();
    }
    public boolean contains(Object o)
    {
        return nodes.contains(o);
    }
    public boolean containsAll(Collection c)
    {
        return nodes.containsAll(c);
    }
    public Object get(int index)
    {
        return nodes.get(index);
    }
    public int indexOf(Object o)
    {
        return nodes.indexOf(o);
    }
    public boolean isEmpty()
    {
        return nodes.isEmpty();
    }
    public Iterator iterator()
    {
        return nodes.iterator();
    }
    public int lastIndexOf(Object o)
    {
        return nodes.lastIndexOf(o);
    }
    public ListIterator listIterator()
    {
        return nodes.listIterator();
    }
    public ListIterator listIterator(int index)
    {
        return nodes.listIterator(index);
    }
    public Object remove(int index)
    {
        return nodes.remove(index);
    }
    public boolean remove(Object o)
    {
        return nodes.remove(o);
    }
    public boolean removeAll(Collection c)
    {
        return nodes.removeAll(c);
    }
    public boolean retainAll(Collection c)
    {
        return nodes.retainAll(c);
    }
    public Object set(int index, Object o)
    {
        return nodes.set(index, o);
    }
    public int size()
    {
        return nodes.size();
    }
    public List subList(int fromIndex, int toIndex)
    {
        return new NodeList(nodes.subList(fromIndex, toIndex));
    }
    public Object[] toArray()
    {
        return nodes.toArray();
    }
    public Object[] toArray(Object[] a)
    {
        return nodes.toArray(a);
    }
    /**
     * A special subclass of XMLOutputter that will be used to output 
     * Attribute nodes. As a subclass of XMLOutputter it can use its protected
     * method escapeAttributeEntities() to serialize the attribute
     * appropriately.
     */
    private static final class AttributeXMLOutputter extends XMLOutputter
    {
        public void output(Attribute attribute, Writer out)
            throws IOException
        {
            out.write("" "");
            out.write(attribute.getQualifiedName());
            out.write(""="");
            out.write(""\"""");
            out.write(escapeAttributeEntities(attribute.getValue()));
            out.write(""\"""");            
        }
    }
}
"
org.apache.velocity.anakia.OutputWrapper,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.IOException;
import java.io.StringWriter;
import org.jdom.Element;
import org.jdom.output.XMLOutputter;
/**
 * This class extends XMLOutputter in order to provide
 * a way to walk an Element tree into a String.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
 * @version $Id: OutputWrapper.java,v 1.6.4.1 2004/03/03 23:22:04 geirm Exp $
 */
public class OutputWrapper extends XMLOutputter
{
    /**
     * Empty constructor
     */
    public OutputWrapper()
    {
    }
    /**
     * This method walks an Element tree into a String. The cool
     * thing about it is that it will strip off the first Element.
     * For example, if you have:
     * <p>
     * &lt;td&gt; foo &lt;strong&gt;bar&lt;/strong&gt; ack &lt;/td&gt;
     * </p>
     * It will output
     * <p>
     *  foo &lt;strong&gt;bar&lt;/strong&gt; ack &lt;/td&gt;
     * </p>
     */
    public String outputString(Element element, boolean strip)
    {
        StringWriter buff = new StringWriter();
        String name = element.getName();
        try
        {
            outputElementContent(element, buff);
        }
        catch (IOException e)
        {
        }
        return buff.toString();
    }
}
"
org.apache.velocity.anakia.TreeWalker,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import org.jdom.Element;
/**
 * This class allows you to walk a tree of JDOM Element objects.
 * It first walks the tree itself starting at the Element passed 
 * into allElements() and stores each node of the tree 
 * in a Vector which allElements() returns as a result of its
 * execution. You can then use a #foreach in Velocity to walk
 * over the Vector and visit each Element node. However, you can
 * achieve the same effect by calling <code>element.selectNodes(""//*"")</code>.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: TreeWalker.java,v 1.6.4.1 2004/03/03 23:22:04 geirm Exp $
 */
public class TreeWalker
{
    /**
     * Empty constructor
     */
    public TreeWalker()
    {
        // Left blank
    }
    /**
     * Creates a new Vector and walks the Element tree.
     *   
     * @param Element the starting Element node
     * @return Vector a vector of Element nodes
     */
    public NodeList allElements(Element e)
    {
        ArrayList theElements = new ArrayList();
        treeWalk (e, theElements);
        return new NodeList(theElements, false);
    }
    /**
     * A recursive method to walk the Element tree.
     * @param Element the current Element
     */
    private final void treeWalk(Element e, Collection theElements )
    {
        for (Iterator i=e.getChildren().iterator(); i.hasNext(); )
        {
            Element child = (Element)i.next();
            theElements.add(child);
            treeWalk(child, theElements);
        }            
    }
}    
"
org.apache.velocity.anakia.XPathCache,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import com.werken.xpath.XPath;
import java.util.Map;
import java.util.WeakHashMap;
/**
 * Provides a cache for XPath expressions. Used by {@link NodeList} and 
 * {@link AnakiaElement} to minimize XPath parsing in their 
 * <code>selectNodes()</code> methods.
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: XPathCache.java,v 1.1.10.1 2004/03/03 23:22:04 geirm Exp $
 */
class XPathCache
{
    // Cache of already parsed XPath expressions, keyed by String representations
    // of the expression as passed to getXPath().
    private static final Map XPATH_CACHE = new WeakHashMap();
    private XPathCache()
    {
    }
    /**
     * Returns an XPath object representing the requested XPath expression.
     * A cached object is returned if it already exists for the requested expression.
     * @param xpathString the XPath expression to parse
     * @return the XPath object that represents the parsed XPath expression.
     */
    static XPath getXPath(String xpathString)
    {
        XPath xpath = null;
        synchronized(XPATH_CACHE)
        {
            xpath = (XPath)XPATH_CACHE.get(xpathString);
            if(xpath == null)
            {
                xpath = new XPath(xpathString);
                XPATH_CACHE.put(xpathString, xpath);
            }
        }
        return xpath;
    }
}
"
org.apache.velocity.anakia.XPathTool,"package org.apache.velocity.anakia;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.List;
import org.jdom.Document;
import org.jdom.Element;
/**
 * This class adds an entrypoint into XPath functionality,
 * for Anakia.
 * <p>
 * All methods take a string XPath specification, along with
 * a context, and produces a resulting java.util.List.
 * <p>
 * The W3C XPath Specification (http://www.w3.org/TR/xpath) refers
 * to NodeSets repeatedly, but this implementation simply uses
 * java.util.List to hold all Nodes.  A 'Node' is any object in
 * a JDOM object tree, such as an org.jdom.Element, org.jdom.Document,
 * or org.jdom.Attribute.
 * <p>
 * To use it in Velocity, do this:
 * <p>
 * <pre>
 * #set $authors = $xpath.applyTo(""document/author"", $root)
 * #foreach ($author in $authors)
 *   $author.getValue() 
 * #end
 * #set $chapterTitles = $xpath.applyTo(""document/chapter/@title"", $root)
 * #foreach ($title in $chapterTitles)
 *   $title.getValue()
 * #end
 * </pre>
 * <p>
 * In newer Anakia builds, this class is obsoleted in favor of calling
 * <code>selectNodes()</code> on the element directly:
 * <pre>
 * #set $authors = $root.selectNodes(""document/author"")
 * #foreach ($author in $authors)
 *   $author.getValue() 
 * #end
 * #set $chapterTitles = $root.selectNodes(""document/chapter/@title"")
 * #foreach ($title in $chapterTitles)
 *   $title.getValue()
 * #end
 * </pre>
 * <p>
 *  
 * @author <a href=""mailto:bob@werken.com"">bob mcwhirter</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: XPathTool.java,v 1.13.4.1 2004/03/03 23:22:04 geirm Exp $
 */
public class XPathTool
{
    /**
     * Constructor does nothing, as this is mostly
     * just objectified static methods
     */
    public XPathTool()
    {
        //        RuntimeSingleton.info(""XPathTool::XPathTool()"");
        // intentionally left blank
    }
    /**
     * Apply an XPath to a JDOM Document
     *
     * @param xpathSpec The XPath to apply
     * @param doc The Document context
     *
     * @return A list of selected nodes
     */
    public NodeList applyTo(String xpathSpec,
                        Document doc)
    {
        //RuntimeSingleton.info(""XPathTool::applyTo(String, Document)"");
        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( doc ), false);
    }
    /**
     * Apply an XPath to a JDOM Element
     *
     * @param xpathSpec The XPath to apply
     * @param doc The Element context
     *
     * @return A list of selected nodes
     */
    public NodeList applyTo(String xpathSpec,
                        Element elem)
    {
        //RuntimeSingleton.info(""XPathTool::applyTo(String, Element)"");
        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( elem ), false);
    }
    /**
     * Apply an XPath to a nodeset
     *
     * @param xpathSpec The XPath to apply
     * @param doc The nodeset context
     *
     * @return A list of selected nodes
     */
    public NodeList applyTo(String xpathSpec,
                        List nodeSet)
    {
        //RuntimeSingleton.info(""XPathTool::applyTo(String, List)"");
        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( nodeSet ), false);
    }
}
"
org.apache.velocity.app.FieldMethodizer,"package org.apache.velocity.app;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.lang.Class;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
/**
 *  <p>
 *  This is a small utility class allow easy access to static fields in a class,
 *  such as string constants.  Velocity will not introspect for class
 *  fields (and won't in the future :), but writing setter/getter methods to do 
 *  this really is a pain,  so use this if you really have
 *  to access fields.
 *  
 *  <p>
 *  The idea it so enable access to the fields just like you would in Java.  
 *  For example, in Java, you would access a static field like
 *  <blockquote><pre>
 *  MyClass.STRING_CONSTANT
 *  </pre></blockquote>
 *  and that is the same thing we are trying to allow here.
 *
 *  <p>
 *  So to use in your Java code, do something like this :
 *  <blockquote><pre>
 *   context.put(""runtime"", new FieldMethodizer( ""org.apache.velocity.runtime.Runtime"" ));
 *  </pre></blockquote>
 *  and then in your template, you can access any of your static fields in this way :
 *  <blockquote><pre>  
 *   $runtime.RUNTIME_LOG_WARN_STACKTRACE
 *  </pre></blockquote>
 *
 *  <p>
 *  Right now, this class only methodizes <code>public static</code> fields.  It seems
 *  that anything else is too dangerous.  This class is for convenience accessing
 *  'constants'.  If you have fields that aren't <code>static</code> it may be better
 *  to handle them by explicitly placing them into the context.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: FieldMethodizer.java,v 1.3.14.1 2004/03/03 23:22:53 geirm Exp $ 
 */
public class FieldMethodizer
{
    /** Hold the field objects by field name */
    private HashMap fieldHash = new HashMap();
    /** Hold the class objects by field name */
    private HashMap classHash = new HashMap();
    /**
     * Allow object to be initialized without any data. You would use
     * addObject() to add data later.
     */
    public FieldMethodizer()
    {
    }
    /**
     *  Constructor that takes as it's arg the name of the class
     *  to methodize.
     *
     *  @param s Name of class to methodize.
     */
    public FieldMethodizer( String s )
    {
        try
        {
            addObject(s);
        }
        catch( Exception e )
        {
            System.out.println( e );
        }
    }
  /**
     *  Constructor that takes as it's arg a living
     *  object to methodize.  Note that it will still
     *  only methodized the public static fields of
     *  the class.
     *
     *  @param s Name of class to methodize.
     */
    public FieldMethodizer( Object o )
    {
        try
        {
            addObject(o);
        }
        catch( Exception e )
        {
            System.out.println( e );
        }
    }
    /**
     * Add the Name of the class to methodize
     */
    public void addObject ( String s )
        throws Exception
    {
        inspect(Class.forName(s));
    }
    /**
     * Add an Object to methodize
     */
    public void addObject ( Object o )
        throws Exception
    {
        inspect(o.getClass());
    }
    /**
     *  Accessor method to get the fields by name.
     *
     *  @param fieldName Name of static field to retrieve
     *
     *  @return The value of the given field.
     */
    public Object get( String fieldName )
    {
        try 
        {
            Field f = (Field) fieldHash.get( fieldName );
            if (f != null)
                return f.get( (Class) classHash.get(fieldName) );
        }
        catch( Exception e )
        {
        }
        return null;
    }
    /**
     *  Method that retrieves all public static fields
     *  in the class we are methodizing.
     */
    private void inspect(Class clas)
    {
        Field[] fields = clas.getFields();
        for( int i = 0; i < fields.length; i++)
        {
            /*
             *  only if public and static
             */
            int mod = fields[i].getModifiers();
            if ( Modifier.isStatic(mod) && Modifier.isPublic(mod) )
            {
                fieldHash.put(fields[i].getName(), fields[i]);
                classHash.put(fields[i].getName(), clas);
            }
        }
    }
}
"
org.apache.velocity.app.Velocity,"package org.apache.velocity.app;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.util.Properties;
import java.io.InputStream;
import java.io.IOException;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import org.apache.velocity.context.Context;
import org.apache.velocity.Template;
import org.apache.velocity.context.InternalContextAdapterImpl;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.configuration.Configuration;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * This class provides  services to the application
 * developer, such as :
 * <ul>
 * <li> Simple Velocity Runtime engine initialization methods.
 * <li> Functions to apply the template engine to streams and strings
 *      to allow embedding and dynamic template generation.
 * <li> Methods to access Velocimacros directly.
 * </ul>
 *
 * <br><br>
 * While the most common way to use Velocity is via templates, as
 * Velocity is a general-purpose template engine, there are other
 * uses that Velocity is well suited for, such as processing dynamically
 * created templates, or processing content streams.
 *
 * <br><br>
 * The methods herein were developed to allow easy access to the Velocity
 * facilities without direct spelunking of the internals.  If there is
 * something you feel is necessary to add here, please, send a patch.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Velocity.java,v 1.30.4.1 2004/03/03 23:22:53 geirm Exp $
 */
public class Velocity implements RuntimeConstants
{
    /**
     *  initialize the Velocity runtime engine, using the default
     *  properties of the Velocity distribution
     */
    public static void init()
        throws Exception
    {
        RuntimeSingleton.init();
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the properties file passed in as the arg
     *
     *  @param propsFilename file containing properties to use to initialize
     *         the Velocity runtime
     */
    public static void init( String propsFilename )
        throws Exception
    {
        RuntimeSingleton.init(propsFilename);
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the passed in java.util.Properties object
     *
     *  @param p  Proprties object containing initialization properties
     *
     */
    public static void init( Properties p )
        throws Exception
    {
        RuntimeSingleton.init( p );
    }
    /**
     * Set a Velocity Runtime property.
     *
     * @param String key
     * @param Object value
     */
    public static void setProperty(String key, Object value)
    {
        RuntimeSingleton.setProperty(key,value);
    }
    /**
     * Add a Velocity Runtime property.
     *
     * @param String key
     * @param Object value
     */
    public static void addProperty(String key, Object value)
    {
        RuntimeSingleton.addProperty(key,value);
    }
    /**
     * Clear a Velocity Runtime property.
     *
     * @param key of property to clear
     */
    public static void clearProperty(String key)
    {
        RuntimeSingleton.clearProperty(key);
    }
    /**
     * Set an entire configuration at once. This is
     * useful in cases where the parent application uses
     * the Configuration class and the velocity configuration
     * is a subset of the parent application's configuration.
     *
     * @param Configuration configuration
     *
     * @deprecated Use
     *  {@link #setExtendedProperties( ExtendedProperties  ) }
     */
    public static void setConfiguration(Configuration configuration)
    {
        /*
         *  Yuk. We added a little helper to Configuration to
         *  help with deprecation.  The Configuration class
         *  contains a 'shadow' ExtendedProperties
         */
        ExtendedProperties ep = configuration.getExtendedProperties();
        RuntimeSingleton.setConfiguration( ep );
    }
    /**
     * Set an entire configuration at once. This is
     * useful in cases where the parent application uses
     * the ExtendedProperties class and the velocity configuration
     * is a subset of the parent application's configuration.
     *
     * @param ExtendedProperties configuration
     *
     */
    public static void setExtendedProperties( ExtendedProperties configuration)
    {
        RuntimeSingleton.setConfiguration( configuration );
    }
    /**
     *  Get a Velocity Runtime property.
     *
     *  @param key property to retrieve
     *  @return property value or null if the property
     *        not currently set
     */
    public static Object getProperty( String key )
    {
        return RuntimeSingleton.getProperty( key );
    }
    /**
     *  renders the input string using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to use
     *  Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log
     *                 messages in case of error
     *  @param instring input string containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *             Velocity runtime log
     */
    public static  boolean evaluate( Context context,  Writer out,
                                     String logTag, String instring )
        throws ParseErrorException, MethodInvocationException,
        	ResourceNotFoundException, IOException
    {
        return evaluate( context, out, logTag, new BufferedReader( new StringReader( instring )) );
    }
    /**
     *  Renders the input stream using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param instream input stream containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *               Velocity runtime log
     *  @deprecated Use
     *  {@link #evaluate( Context context, Writer writer,
     *      String logTag, Reader reader ) }
     */
    public static boolean evaluate( Context context, Writer writer,
                                    String logTag, InputStream instream )
        throws ParseErrorException, MethodInvocationException,
        	ResourceNotFoundException, IOException
    {
        /*
         *  first, parse - convert ParseException if thrown
         */
        BufferedReader br  = null;
        String encoding = null;
        try
        {
            encoding = RuntimeSingleton.getString(INPUT_ENCODING,ENCODING_DEFAULT);
            br = new BufferedReader(  new InputStreamReader( instream, encoding));
        }
        catch( UnsupportedEncodingException  uce )
        {
            String msg = ""Unsupported input encoding : "" + encoding
                + "" for template "" + logTag;
            throw new ParseErrorException( msg );
        }
        return evaluate( context, writer, logTag, br );
    }
    /**
     *  Renders the input reader using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param reader Reader containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *               Velocity runtime log
     *
     *  @since Velocity v1.1
     */
    public static boolean evaluate( Context context, Writer writer,
                                    String logTag, Reader reader )
        throws ParseErrorException, MethodInvocationException,
        	ResourceNotFoundException,IOException
    {
        SimpleNode nodeTree = null;
        try
        {
            nodeTree = RuntimeSingleton.parse( reader, logTag );
        }
        catch ( ParseException pex )
        {
            throw  new ParseErrorException( pex.getMessage() );
        }
        /*
         * now we want to init and render
         */
        if (nodeTree != null)
        {
            InternalContextAdapterImpl ica =
                new InternalContextAdapterImpl( context );
            ica.pushCurrentTemplateName( logTag );
            try
            {
                try
                {
                    nodeTree.init( ica, RuntimeSingleton.getRuntimeServices() );
                }
                catch( Exception e )
                {
                    RuntimeSingleton.error(""Velocity.evaluate() : init exception for tag = ""
                                  + logTag + "" : "" + e );
                }
                /*
                 *  now render, and let any exceptions fly
                 */
                nodeTree.render( ica, writer );
            }
            finally
            {
                ica.popCurrentTemplateName();
            }
            return true;
        }
        return false;
    }
    /**
     *  Invokes a currently registered Velocimacro with the parms provided
     *  and places the rendered stream into the writer.
     *
     *  Note : currently only accepts args to the VM if they are in the context.
     *
     *  @param vmName name of Velocimacro to call
     *  @param logTag string to be used for template name in case of error
     *  @param params[] args used to invoke Velocimacro. In context key format :
     *                  eg  ""foo"",""bar"" (rather than ""$foo"",""$bar"")
     *  @param context Context object containing data/objects used for rendering.
     *  @param writer  Writer for output stream
     *  @return true if Velocimacro exists and successfully invoked, false otherwise.
     */
    public static  boolean invokeVelocimacro( String vmName, String logTag,
                                              String params[], Context context,
                                              Writer writer )
    {
        /*
         *  check parms
         */
        if ( vmName == null ||  params == null ||  context == null
             || writer == null || logTag == null)
        {
            RuntimeSingleton.error( ""Velocity.invokeVelocimacro() : invalid parameter"");
            return false;
        }
        /*
         * does the VM exist?
         */
        if (!RuntimeSingleton.isVelocimacro( vmName, logTag ))
        {
            RuntimeSingleton.error( ""Velocity.invokeVelocimacro() : VM '""+ vmName
                           + ""' not registered."");
            return false;
        }
        /*
         *  now just create the VM call, and use evaluate
         */
        StringBuffer construct = new StringBuffer(""#"");
        construct.append( vmName );
        construct.append( ""("" );
        for( int i = 0; i < params.length; i++)
        {
            construct.append( "" $"" );
            construct.append( params[i] );
        }
        construct.append("" )"");
        try
        {
            boolean retval = evaluate(  context,  writer,
                                         logTag, construct.toString() );
            return retval;
        }
        catch( Exception  e )
        {
            RuntimeSingleton.error( ""Velocity.invokeVelocimacro() : error "" + e );
        }
        return false;
    }
    /**
     *  merges a template and puts the rendered stream into the writer
     *
     *  @param templateName name of template to be used in merge
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors
     *           logged to velocity log.
     *  @deprecated Use
     *  {@link #mergeTemplate( String templateName, String encoding,
     *                Context context, Writer writer )}
     */
    public static boolean mergeTemplate( String templateName,
                                         Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        return mergeTemplate( templateName, RuntimeSingleton.getString(INPUT_ENCODING,ENCODING_DEFAULT),
                               context, writer );
    }
    /**
     *  merges a template and puts the rendered stream into the writer
     *
     *  @param templateName name of template to be used in merge
     *  @param encoding encoding used in template
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors
     *           logged to velocity log
     *
     *  @since Velocity v1.1
     */
    public static boolean mergeTemplate( String templateName, String encoding,
                                      Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        Template template = RuntimeSingleton.getTemplate(templateName, encoding);
        if ( template == null )
        {
            RuntimeSingleton.error(""Velocity.parseTemplate() failed loading template '""
                          + templateName + ""'"" );
            return false;
        }
        else
        {
            template.merge(context, writer);
            return true;
         }
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name );
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @param encoding The character encoding to use for the template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     *
     *  @since Velocity v1.1
     */
    public static Template getTemplate(String name, String encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name, encoding );
    }
    /**
     * <p>Determines whether a resource is accessable via the
     * currently configured resource loaders.  {@link
     * org.apache.velocity.runtime.resource.Resource} is the generic
     * description of templates, static content, etc.</p>
     *
     * <p>Note that the current implementation will <b>not</b> change
     * the state of the system in any real way - so this cannot be
     * used to pre-load the resource cache, as the previous
     * implementation did as a side-effect.</p>
     *
     * @param resourceName The name of the resource to search for.
     * @return Whether the resource was located.
     */
    public static boolean resourceExists(String resourceName)
    {
        return (RuntimeSingleton.getLoaderNameForResource(resourceName) != null);
    }
    /**
     * Log a warning message.
     *
     * @param Object message to log
     */
    public static void warn(Object message)
    {
        RuntimeSingleton.warn( message );
    }
    /**
     * Log an info message.
     *
     * @param Object message to log
     */
    public static void info(Object message)
    {
        RuntimeSingleton.info( message );
    }
    /**
     * Log an error message.
     *
     * @param Object message to log
     */
    public static void error(Object message)
    {
        RuntimeSingleton.error( message );
    }
    /**
     * Log a debug message.
     *
     * @param Object message to log
     */
    public static void debug(Object message)
    {
        RuntimeSingleton.debug( message );
    }
    /**
     *  <p>
     *  Set the an ApplicationAttribue, which is an Object
     *  set by the application which is accessable from
     *  any component of the system that gets a RuntimeServices.
     *  This allows communication between the application
     *  environment and custom pluggable components of the
     *  Velocity engine, such as loaders and loggers.
     *  </p>
     *
     *  <p>
     *  Note that there is no enfocement or rules for the key
     *  used - it is up to the application developer.  However, to
     *  help make the intermixing of components possible, using
     *  the target Class name (e.g.  com.foo.bar ) as the key
     *   might help avoid collision.
     *  </p>
     *
     *  @param key object 'name' under which the object is stored
     *  @param value object to store under this key
     */
     public static void setApplicationAttribute( Object key, Object value )
     {
        RuntimeSingleton.getRuntimeInstance().setApplicationAttribute( key, value);
     }
    /**
     * @see #resourceExists(String)
     * @deprecated Use resourceExists(String) instead.
     */
    public static boolean templateExists(String resourceName)
    {
        return resourceExists(resourceName);
    }
}
"
org.apache.velocity.app.VelocityEngine,"package org.apache.velocity.app;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.util.Properties;
import java.io.InputStream;
import java.io.IOException;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import org.apache.velocity.context.Context;
import org.apache.velocity.Template;
import org.apache.velocity.context.InternalContextAdapterImpl;
import org.apache.velocity.runtime.RuntimeInstance;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.configuration.Configuration;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * <p>
 * This class provides a separate new-able instance of the
 * Velocity template engine.  The alternative model for use
 * is using the Velocity class which employs the singleton
 * model.
 * </p>
 *
 * <p>
 * Please ensure that you call one of the init() variants. 
 * This is critical for proper behavior.  
 * </p>
 *
 * <p> Coming soon : Velocity will call
 * the parameter-less init() at the first use of this class
 * if the init() wasn't explicitly called.  While this will
 * ensure that Velocity functions, it almost certainly won't
 * function in the way you intend, so please make sure to
 * call init().
 * </p>
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelocityEngine.java,v 1.6.4.1 2004/03/03 23:22:53 geirm Exp $
 */
public class VelocityEngine implements RuntimeConstants
{
    private RuntimeInstance ri = new RuntimeInstance();
    /**
     *  initialize the Velocity runtime engine, using the default 
     *  properties of the Velocity distribution
     */
    public void init() 
        throws Exception
    {
        ri.init();
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the properties file passed in as the arg
     *
     *  @param propsFilename file containing properties to use to initialize 
     *         the Velocity runtime
     */
    public void init( String propsFilename ) 
        throws Exception
    {
        ri.init(propsFilename);
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the passed in java.util.Properties object
     *
     *  @param p  Proprties object containing initialization properties
     *
     */
    public void init( Properties p )
        throws Exception
    {      
        ri.init( p ); 
    }
    /**
     * Set a Velocity Runtime property.
     *
     * @param String key
     * @param Object value
     */
    public void setProperty(String key, Object value)
    {
        ri.setProperty(key,value);
    }
    /**
     * Add a Velocity Runtime property.
     *
     * @param String key
     * @param Object value
     */
    public void addProperty(String key, Object value)
    {
        ri.addProperty(key,value);
    }
    /**
     * Clear a Velocity Runtime property.
     *
     * @param key of property to clear
     */
    public void clearProperty(String key)
    {
        ri.clearProperty(key);
    }        
    /**
     * Set an entire configuration at once. This is
     * useful in cases where the parent application uses
     * the Configuration class and the velocity configuration
     * is a subset of the parent application's configuration.
     *
     * @param Configuration configuration
     *
     * @deprecated Use
     *  {@link #setExtendedProperties( ExtendedProperties  ) }
     */
    public void setConfiguration(Configuration configuration)
    {
        /*
         *  Yuk. We added a little helper to Configuration to 
         *  help with deprecation.  The Configuration class
         *  contains a 'shadow' ExtendedProperties
         */
        ExtendedProperties ep = configuration.getExtendedProperties();
        ri.setConfiguration( ep );
    }
    /**
     * Set an entire configuration at once. This is
     * useful in cases where the parent application uses
     * the ExtendedProperties class and the velocity configuration
     * is a subset of the parent application's configuration.
     *
     * @param ExtendedProperties configuration
     *
     */
    public void setExtendedProperties( ExtendedProperties configuration)
    {
        ri.setConfiguration( configuration );
    }
    /**
     *  Get a Velocity Runtime property.
     *
     *  @param key property to retrieve
     *  @return property value or null if the property
     *        not currently set
     */
    public Object getProperty( String key )
    {
        return ri.getProperty( key );
    }
    /**
     *  renders the input string using the context into the output writer. 
     *  To be used when a template is dynamically constructed, or want to use 
     *  Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log 
     *                 messages in case of error
     *  @param instring input string containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *             Velocity runtime log
     */
    public  boolean evaluate( Context context,  Writer out,  
                                     String logTag, String instring )
        throws ParseErrorException, MethodInvocationException,
        	ResourceNotFoundException, IOException
    {
        return evaluate( context, out, logTag, new BufferedReader( new StringReader( instring )) );
    }
    /**
     *  Renders the input stream using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param instream input stream containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see 
     *               Velocity runtime log
     *  @deprecated Use
     *  {@link #evaluate( Context context, Writer writer, 
     *      String logTag, Reader reader ) }
     */
    public boolean evaluate( Context context, Writer writer, 
                                    String logTag, InputStream instream )
        throws ParseErrorException, MethodInvocationException, 
        	ResourceNotFoundException, IOException
    {
        /*
         *  first, parse - convert ParseException if thrown
         */
        BufferedReader br  = null;
        String encoding = null;
        try
        {
            encoding = ri.getString(INPUT_ENCODING,ENCODING_DEFAULT);
            br = new BufferedReader(  new InputStreamReader( instream, encoding));
        }
        catch( UnsupportedEncodingException  uce )
        {   
            String msg = ""Unsupported input encoding : "" + encoding
                + "" for template "" + logTag;
            throw new ParseErrorException( msg );
        }
        return evaluate( context, writer, logTag, br );
    }
    /**
     *  Renders the input reader using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param reader Reader containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see 
     *               Velocity runtime log
     *
     *  @since Velocity v1.1
     */
    public boolean evaluate( Context context, Writer writer, 
                                    String logTag, Reader reader )
        throws ParseErrorException, MethodInvocationException, 
        	ResourceNotFoundException,IOException
    {
        SimpleNode nodeTree = null;
        try
        {
            nodeTree = ri.parse( reader, logTag );        
        }
        catch ( ParseException pex )
        {
            throw  new ParseErrorException( pex.getMessage() );
        }                
        /*
         * now we want to init and render
         */
        if (nodeTree != null)
        {
            InternalContextAdapterImpl ica = 
                new InternalContextAdapterImpl( context );
            ica.pushCurrentTemplateName( logTag );
            try
            {
                try
                {
                    nodeTree.init( ica, ri );
                }
                catch( Exception e )
                {
                    ri.error(""Velocity.evaluate() : init exception for tag = "" 
                                  + logTag + "" : "" + e );
                }
                /*
                 *  now render, and let any exceptions fly
                 */
                nodeTree.render( ica, writer );
            }
            finally
            {
                ica.popCurrentTemplateName();
            }
            return true;
        }
        return false;
    }
    /**
     *  Invokes a currently registered Velocimacro with the parms provided
     *  and places the rendered stream into the writer.
     *
     *  Note : currently only accepts args to the VM if they are in the context. 
     *
     *  @param vmName name of Velocimacro to call
     *  @param logTag string to be used for template name in case of error
     *  @param params[] args used to invoke Velocimacro. In context key format : 
     *                  eg  ""foo"",""bar"" (rather than ""$foo"",""$bar"")
     *  @param context Context object containing data/objects used for rendering.
     *  @param writer  Writer for output stream
     *  @return true if Velocimacro exists and successfully invoked, false otherwise.
     */
    public boolean invokeVelocimacro( String vmName, String logTag, 
                                              String params[], Context context, 
                                              Writer writer )
        throws Exception
    {
        /*
         *  check parms
         */
        if ( vmName == null ||  params == null ||  context == null 
             || writer == null || logTag == null)
        {
            ri.error( ""VelocityEngine.invokeVelocimacro() : invalid parameter"");
            return false;
        }
        /*
         * does the VM exist?
         */
        if (!ri.isVelocimacro( vmName, logTag ))
        {
            ri.error( ""VelocityEngine.invokeVelocimacro() : VM '""+ vmName 
                           + ""' not registered."");
            return false;
        }
        /*
         *  now just create the VM call, and use evaluate
         */
        StringBuffer construct = new StringBuffer(""#"");
        construct.append( vmName );
        construct.append( ""("" );
        for( int i = 0; i < params.length; i++)
        {
            construct.append( "" $"" );
            construct.append( params[i] );
        }
        construct.append("" )"");
        try
        {
            boolean retval = evaluate(  context,  writer,  
                                         logTag, construct.toString() );
            return retval;
        }
        catch( Exception  e )
        {
            ri.error( ""VelocityEngine.invokeVelocimacro() : error "" + e );
            throw e;
        }
    }
    /**
     *  merges a template and puts the rendered stream into the writer
     *
     *  @param templateName name of template to be used in merge
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors 
     *           logged to velocity log.
     * *  @deprecated Use
     *  {@link #mergeTemplate( String templateName, String encoding,
     *                Context context, Writer writer )}
     */
    public boolean mergeTemplate( String templateName, 
                                         Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        return mergeTemplate( templateName, ri.getString(INPUT_ENCODING,ENCODING_DEFAULT),
                               context, writer );
    }
    /**
     *  merges a template and puts the rendered stream into the writer
     *
     *  @param templateName name of template to be used in merge
     *  @param encoding encoding used in template
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors 
     *           logged to velocity log
     *
     *  @since Velocity v1.1
     */
    public boolean mergeTemplate( String templateName, String encoding,
                                      Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        Template template = ri.getTemplate(templateName, encoding);
        if ( template == null )
        {
            ri.error(""Velocity.parseTemplate() failed loading template '"" 
                          + templateName + ""'"" );
            return false;
        }
        else
        {
            template.merge(context, writer);
            return true;
         }
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name );
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @param encoding The character encoding to use for the template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     *
     *  @since Velocity v1.1
     */
    public Template getTemplate(String name, String encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name, encoding );
    }
    /**
     *   Determines if a template is accessable via the currently 
     *   configured resource loaders.
     *   <br><br>
     *   Note that the current implementation will <b>not</b>
     *   change the state of the system in any real way - so this
     *   cannot be used to pre-load the resource cache, as the 
     *   previous implementation did as a side-effect. 
     *   <br><br>
     *   The previous implementation exhibited extreme lazyness and
     *   sloth, and the author has been flogged.
     *
     *   @param templateName  name of the temlpate to search for
     *   @return true if found, false otherwise
     */
    public boolean templateExists( String templateName )
    {
        return (ri.getLoaderNameForResource(templateName) != null);
    }
    /**
     * Log a warning message.
     *
     * @param Object message to log
     */
    public void warn(Object message)
    {
        ri.warn( message );
    }
    /** 
     * Log an info message.
     *
     * @param Object message to log
     */
    public void info(Object message)
    {
        ri.info( message );
    }
    /**
     * Log an error message.
     *
     * @param Object message to log
     */
    public void error(Object message)
    {
        ri.error( message );
    }
    /**
     * Log a debug message.
     *
     * @param Object message to log
     */
    public void debug(Object message)
    {
        ri.debug( message );
    }
    /**
     *  <p>
     *  Set the an ApplicationAttribue, which is an Object
     *  set by the application which is accessable from
     *  any component of the system that gets a RuntimeServices.
     *  This allows communication between the application
     *  environment and custom pluggable components of the
     *  Velocity engine, such as loaders and loggers.
     *  </p>
     *
     *  <p>
     *  Note that there is no enfocement or rules for the key
     *  used - it is up to the application developer.  However, to
     *  help make the intermixing of components possible, using
     *  the target Class name (e.g.  com.foo.bar ) as the key
     *   might help avoid collision.
     *  </p>
     *
     *  @param key object 'name' under which the object is stored
     *  @param value object to store under this key
     */
     public void setApplicationAttribute( Object key, Object value )
     {
        ri.setApplicationAttribute( key, value );
     }
} 
"
org.apache.velocity.app.event.EventCartridge,"package org.apache.velocity.app.event;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalEventContext;
import org.apache.velocity.context.Context;
/**
 *  'Package' of event handlers...
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:j_a_fernandez@yahoo.com"">Jose Alberto Fernandez</a>
 * @version $Id: EventCartridge.java,v 1.3.4.1 2004/03/03 23:22:53 geirm Exp $
 */
public class EventCartridge implements ReferenceInsertionEventHandler,
                                       NullSetEventHandler,
                                       MethodExceptionEventHandler
{
    private ReferenceInsertionEventHandler rieh = null;
    private NullSetEventHandler nseh = null;
    private MethodExceptionEventHandler meeh = null;
    /**
     *  Adds an event handler(s) to the Cartridge.  This method
     *  will find all possible event handler interfaces supported
     *  by the passed in object.
     *
     *  @param ev object impementing a valid EventHandler-derived interface
     *  @return true if a supported interface, false otherwise or if null
     */
    public boolean addEventHandler( EventHandler ev )
    {
        if (ev == null)
        {
            return false;
        }
        boolean found = false;
        if ( ev instanceof ReferenceInsertionEventHandler)
        {
            rieh = (ReferenceInsertionEventHandler) ev;
            found = true;
        }
        if ( ev instanceof NullSetEventHandler )
        {
            nseh = (NullSetEventHandler) ev;
            found = true;
        }
        if ( ev instanceof MethodExceptionEventHandler )
        {
            meeh = (MethodExceptionEventHandler) ev;
            found = true;
        }
        return found;
    }
    /**
     *  Removes an event handler(s) from the Cartridge.  This method
     *  will find all possible event handler interfaces supported
     *  by the passed in object and remove them.
     *
     *  @param ev object impementing a valid EventHandler-derived interface
     *  @return true if a supported interface, false otherwise or if null
     */
    public boolean removeEventHandler(EventHandler ev)
    {
        if ( ev == null )
        {
            return false;
        }
        boolean found = false;
        if (ev == rieh) 
        {
            rieh = null;
            found = true;
        }
        if (ev == nseh) 
        {
            nseh = null;
            found = true;
        }
        if (ev == meeh) 
        {
            meeh = null;
            found = true;
        }
        return found;
    }
    /**
     *  Implementation of ReferenceInsertionEventHandler method
     *  <code>referenceInsert()</code>.
     *
     *  Called during Velocity merge before a reference value will
     *  be inserted into the output stream.
     *
     *  @param reference reference from template about to be inserted
     *  @param value  value about to be inserted (after toString() )
     *  @return Object on which toString() should be called for output.
     */
    public Object referenceInsert( String reference, Object value  )
    {
        if (rieh == null)
        {
            return value;
        }
        return rieh.referenceInsert( reference, value );
    }
    /**
     *  Implementation of NullSetEventHandler method
     *  <code>shouldLogOnNullSet()</code>.
     *
     *  Called during Velocity merge to determine if when
     *  a #set() results in a null assignment, a warning
     *  is logged.
     *
     *  @param reference reference from template about to be inserted
     *  @return true if to be logged, false otherwise
     */
    public boolean shouldLogOnNullSet( String lhs, String rhs )
    {
        if ( nseh == null)
        {
            return true;
        }
        return nseh.shouldLogOnNullSet( lhs, rhs );
    }
    /**
     *  Implementation of MethodExceptionEventHandler  method
     *  <code>methodException()</code>.
     *
     *  Called during Velocity merge if a reference is null
     *
     *  @param claz  Class that is causing the exception
     *  @param method method called that causes the exception
     *  @param e Exception thrown by the method
     *  @return Object to return as method result
     *  @throws exception to be wrapped and propogated to app  
     */
    public Object methodException( Class claz, String method, Exception e )
        throws Exception
    {
        /*
         *  if we don't have a handler, just throw what we were handed
         */
        if (meeh == null)
        {
            throw e;
        }
        /*
         *  otherwise, call it..
         */
        return meeh.methodException( claz, method, e );
    }
    /**
     *  Attached the EventCartridge to the context
     *
     *  Final because not something one should mess with lightly :)
     *
     *  @param context context to attach to
     *  @return true if successful, false otherwise
     */
    public final boolean attachToContext( Context context )
    {
        if (  context instanceof InternalEventContext )
        {         
            InternalEventContext iec = (InternalEventContext) context;
            iec.attachEventCartridge( this );
            return true;
        }
        else
        {
            return false;
        }
    }
}
"
org.apache.velocity.app.event.EventHandler,"package org.apache.velocity.app.event;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Base interface for all event handlers
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: EventHandler.java,v 1.2.4.1 2004/03/03 23:22:53 geirm Exp $
 */
public interface  EventHandler
{
}
"
org.apache.velocity.app.event.MethodExceptionEventHandler,"package org.apache.velocity.app.event;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Called when a method throws an exception.  This gives the
 *  application a chance to deal with it and either
 *  return something nice, or throw.
 *
 *  Please return what you want rendered into the output stream.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: MethodExceptionEventHandler.java,v 1.1.12.1 2004/03/03 23:22:53 geirm Exp $
 */
public interface MethodExceptionEventHandler extends EventHandler
{
    public Object methodException( Class claz, String method, Exception e )
         throws Exception;
}
"
org.apache.velocity.app.event.NullSetEventHandler,"package org.apache.velocity.app.event;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Event handler : lets an app approve / veto
 *  writing a log message when RHS of #set() is null.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: NullSetEventHandler.java,v 1.2.12.1 2004/03/03 23:22:53 geirm Exp $
 */
public interface NullSetEventHandler extends EventHandler
{
    /**
     *  Called when the RHS of a #set() is null, which will result
     *  in a null LHS.
     *
     *  @param lhs  reference literal of left-hand-side of set statement
     *  @param rhs  reference literal of right-hand-side of set statement
     *  @return true if log message should be written, false otherwise
     */
    public boolean shouldLogOnNullSet( String lhs, String rhs );
}
"
org.apache.velocity.app.event.ReferenceInsertionEventHandler,"package org.apache.velocity.app.event;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Reference 'Stream insertion' event handler.  Called with object
 *  that will be inserted into stream via value.toString().
 *
 *  Please return an Object that will toString() nicely :)
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ReferenceInsertionEventHandler.java,v 1.2.8.1 2004/03/03 23:22:53 geirm Exp $
 */
public interface  ReferenceInsertionEventHandler extends EventHandler
{
    /**
     * A call-back which is executed during Velocity merge before a
     * reference value is inserted into the output stream.
     *
     * @param reference Reference from template about to be inserted.
     * @param value Value about to be inserted (after its
     * <code>toString()</code> method is called).
     * @return Object on which <code>toString()</code> should be
     * called for output.
     */
    public Object referenceInsert( String reference, Object value  );
}
"
org.apache.velocity.app.tools.VelocityFormatter,"package org.apache.velocity.app.tools;
/*
 * Copyright (c) 2001 The Java Apache Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    ""This product includes software developed by the Java Apache
 *    Project for use in the Apache JServ servlet engine project
 *    <http://java.apache.org/>.""
 *
 * 4. The names ""Apache JServ"", ""Apache JServ Servlet Engine"", ""Turbine"",
 *    ""Apache Turbine"", ""Turbine Project"", ""Apache Turbine Project"" and
 *    ""Java Apache Project"" must not be used to endorse or promote products
 *    derived from this software without prior written permission.
 *
 * 5. Products derived from this software may not be called ""Apache JServ""
 *    nor may ""Apache"" nor ""Apache JServ"" appear in their names without
 *    prior written permission of the Java Apache Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    ""This product includes software developed by the Java Apache
 *    Project for use in the Apache JServ servlet engine project
 *    <http://java.apache.org/>.""
 *
 * THIS SOFTWARE IS PROVIDED BY THE JAVA APACHE PROJECT ""AS IS"" AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE JAVA APACHE PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Java Apache Group. For more information
 * on the Java Apache Project and the Apache JServ Servlet Engine project,
 * please see <http://java.apache.org/>.
 *
 */
// Java Core Classes
import java.util.*;
import java.text.*;
import java.lang.reflect.Array;
// Veclocity classes
import org.apache.velocity.context.*;
/**
 * Formatting tool for inserting into the Velocity WebContext.  Can
 * format dates or lists of objects.
 *
 * <p>Here's an example of some uses:
 *
 * <code><pre>
 * $formatter.formatShortDate($object.Date)
 * $formatter.formatLongDate($db.getRecord(232).getDate())
 * $formatter.formatArray($array)
 * $formatter.limitLen(30, $object.Description)
 * </pre></code>
 * 
 * @author <a href=""sean@somacity.com"">Sean Legassick</a>
 * @author <a href=""dlr@collab.net"">Daniel Rall</a>
 * @version $Id: VelocityFormatter.java,v 1.9 2003/05/04 17:06:11 geirm Exp $
 */
public class VelocityFormatter
{
    Context context = null;
    NumberFormat nf = NumberFormat.getInstance();
    /**
     * Constructor needs a backpointer to the context.
     *
     * @param context A Context.
     */
    public VelocityFormatter(Context context)
    {
        this.context = context;
    }
    /**
     * Formats a date in <code>DateFormat.SHORT</code> style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatShortDate(Date date)
    {
        return DateFormat.getDateInstance(DateFormat.SHORT).format(date);
    }
    /**
     * Formats a date in <code>DateFormat.LONG</code> style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatLongDate(Date date)
    {
        return DateFormat.getDateInstance(DateFormat.LONG).format(date);
    }
    /**
     * Formats a date/time in 'short' style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatShortDateTime(Date date)
    {
        return DateFormat
            .getDateTimeInstance(DateFormat.SHORT,
                                 DateFormat.SHORT).format(date);
    }
    /**
     * Formats a date/time in 'long' style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatLongDateTime(Date date)
    {
        return DateFormat.getDateTimeInstance(
                DateFormat.LONG, DateFormat.LONG).format(date);
    }
    /**
     * Formats an array into the form ""A, B and C"".
     *
     * @param array An Object.
     * @return A String.
     */
    public String formatArray(Object array)
    {
        return formatArray(array, "", "", "" and "");
    }
    /**
     * Formats an array into the form
     * ""A&lt;delim&gt;B&lt;delim&gt;C"".
     *
     * @param array An Object.
     * @param delim A String.
     * @return A String.
     */
    public String formatArray(Object array,
                              String delim)
    {
        return formatArray(array, delim, delim);
    }
    /**
     * Formats an array into the form
     * ""A&lt;delim&gt;B&lt;finaldelim&gt;C"".
     *
     * @param array An Object.
     * @param delim A String.
     * @param finalDelim A String.
     * @return A String.
     */
    public String formatArray(Object array,
                              String delim,
                              String finaldelim)
    {
        StringBuffer sb = new StringBuffer();
        int arrayLen = Array.getLength(array);
        for (int i = 0; i < arrayLen; i++)
        {
            // Use the Array.get method as this will automatically
            // wrap primitive types in a suitable Object-derived
            // wrapper if necessary.
            sb.append(Array.get(array, i).toString());
            if (i  < arrayLen - 2)
            {
                sb.append(delim);
            }
            else if (i < arrayLen - 1)
            {
                sb.append(finaldelim);
            }
        }
        return sb.toString();
    }
    /**
     * Formats a vector into the form ""A, B and C"".
     *
     * @param list The list of elements to format.
     * @return A String.
     */
    public String formatVector(List list)
    {
        return formatVector(list, "", "", "" and "");
    }
    /**
     * Formats a vector into the form ""A&lt;delim&gt;B&lt;delim&gt;C"".
     *
     * @param list The list of elements to format.
     * @param delim A String.
     * @return A String.
     */
    public String formatVector(List list,
                               String delim)
    {
        return formatVector(list, delim, delim);
    }
    /**
     * Formats a list into the form
     * ""Adelim&gt;B&lt;finaldelim&gt;C"".
     *
     * @param list The list of elements to format.
     * @param delim A String.
     * @param finalDelim A String.
     * @return A String.
     */
    public String formatVector(List list,
                               String delim,
                               String finaldelim)
    {
        StringBuffer sb = new StringBuffer();
        int size = list.size();
        for (int i = 0; i < size; i++)
        {
            sb.append(list.get(i));
            if (i < size - 2)
            {
                sb.append(delim);
            }
            else if (i < size - 1)
            {
                sb.append(finaldelim);
            }
        }
        return sb.toString();
    }
    /**
     * Limits 'string' to 'maxlen' characters.  If the string gets
     * curtailed, ""..."" is appended to it.
     *
     * @param maxlen An int with the maximum length.
     * @param string A String.
     * @return A String.
     */
    public String limitLen(int maxlen,
                           String string)
    {
        return limitLen(maxlen, string, ""..."");
    }
    /**
     * Limits 'string' to 'maxlen' character.  If the string gets
     * curtailed, 'suffix' is appended to it.
     *
     * @param maxlen An int with the maximum length.
     * @param string A String.
     * @param suffix A String.
     * @return A String.
     */
    public String limitLen(int maxlen,
                           String string,
                           String suffix)
    {
        String ret = string;
        if (string.length() > maxlen)
        {
            ret = string.substring(0, maxlen - suffix.length()) + suffix;
        }
        return ret;
    }
    /**
     * Class that returns alternating values in a template.  It stores
     * a list of alternate Strings, whenever alternate() is called it
     * switches to the next in the list.  The current alternate is
     * retrieved through toString() - i.e. just by referencing the
     * object in a Velocity template.  For an example of usage see the
     * makeAlternator() method below.
     */
    public class VelocityAlternator
    {
        protected String[] alternates = null;
        protected int current = 0;
        /**
         * Constructor takes an array of Strings.
         *
         * @param alternates A String[].
         */
        public VelocityAlternator(String[] alternates)
        {
            this.alternates = alternates;
        }
        /**
         * Alternates to the next in the list.
         *
         * @return The current alternate in the sequence.
         */
        public String alternate()
        {
            current++;
            current %= alternates.length;
            return """";
        }
        /**
         * Returns the current alternate.
         *
         * @return A String.
         */
        public String toString()
        {
            return alternates[current];
        }
    }
    /**
     * As VelocityAlternator, but calls <code>alternate()</code>
     * automatically on rendering in a template.
     */
    public class VelocityAutoAlternator extends VelocityAlternator
    {
        /**
         * Constructor takes an array of Strings.
         *
         * @param alternates A String[].
         */
        public VelocityAutoAlternator(String[] alternates)
        {
            super(alternates);
        }
        /**
         * Returns the current alternate, and automatically alternates
         * to the next alternate in its sequence (trigged upon
         * rendering).
         *
         * @return The current alternate in the sequence.
         */
        public final String toString()
        {
            String s = alternates[current];
            alternate();
            return s;
        }
    }
    /**
     * Makes an alternator object that alternates between two values.
     *
     * <p>Example usage in a Velocity template:
     *
     * <code><pre>
     * &lt;table&gt;
     * $formatter.makeAlternator(""rowcolor"", ""#c0c0c0"", ""#e0e0e0"")
     * #foreach $item in $items
     * #begin
     * &lt;tr&gt;&lt;td bgcolor=""$rowcolor""&gt;$item.Name&lt;/td&gt;&lt;/tr&gt;
     * $rowcolor.alternate()
     * #end
     * &lt;/table&gt;
     * </pre></code>
     *
     * @param name The name for the alternator int the context.
     * @param alt1 The first alternate.
     * @param alt2 The second alternate.
     * @return The newly created instance.
     */
    public String makeAlternator(String name,
                                 String alt1,
                                 String alt2)
    {
        String[] alternates = { alt1, alt2 };
        context.put(name, new VelocityAlternator(alternates));
        return """";
    }
    /**
     * Makes an alternator object that alternates between three
     * values.
     *
     * @see #makeAlternator(String name, String alt1, String alt2)
     */
    public String makeAlternator(String name,
                                 String alt1,
                                 String alt2,
                                 String alt3)
    {
        String[] alternates = { alt1, alt2, alt3 };
        context.put(name, new VelocityAlternator(alternates));
        return """";
    }
    /**
     * Makes an alternator object that alternates between four values.
     *
     * @see #makeAlternator(String name, String alt1, String alt2)
     */
    public String makeAlternator(String name, String alt1, String alt2,
                                 String alt3, String alt4)
    {
        String[] alternates = { alt1, alt2, alt3, alt4 };
        context.put(name, new VelocityAlternator(alternates));
        return """";
    }
    /**
     * Makes an alternator object that alternates between two values
     * automatically.
     *
     * @see #makeAlternator(String name, String alt1, String alt2)
     */
    public String makeAutoAlternator(String name, String alt1, String alt2)
    {
        String[] alternates = { alt1, alt2 };
        context.put(name, new VelocityAutoAlternator(alternates));
        return """";
    }
    /**
     * Returns a default value if the object passed is null.
     */
    public Object isNull(Object o, Object dflt)
    {
        if ( o == null )
        {
            return dflt;
        }
        else
        {
            return o;
        }
    }
}
"
org.apache.velocity.context.AbstractContext,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Serializable;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextBase;
/**
 *  This class is the abstract base class for all conventional 
 *  Velocity Context  implementations.  Simply extend this class 
 *  and implement the abstract routines that access your preferred 
 *  storage method.
 *
 *  Takes care of context chaining.
 *
 *  Also handles / enforces policy on null keys and values :
 *
 *  <ul>
 *  <li> Null keys and values are accepted and basically dropped.
 *  <li> If you place an object into the context with a null key, it
 *        will be ignored and logged.
 *  <li> If you try to place a null into the context with any key, it
 *        will be dropped and logged.
 *  </ul>
 *
 *  The default implementation of this for application use is 
 *  org.apache.velocity.VelocityContext.
 *
 *  All thanks to Fedor for the chaining idea.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:fedor.karpelevitch@home.com"">Fedor Karpelevitch</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: AbstractContext.java,v 1.8.8.1 2004/03/03 23:22:54 geirm Exp $
 */
public abstract class AbstractContext extends InternalContextBase 
    implements Context, Serializable
{
    /**
     *  the chained Context if any
     */
    private   Context  innerContext = null;
    /** 
     *  Implement to return a value from the context storage. 
     *  <br><br>
     *  The implementation of this method is required for proper
     *  operation of a Context implementation in general
     *  Velocity use.
     *  
     *  @param key key whose associated value is to be returned
     *  @return object stored in the context
     */
    public abstract Object internalGet( String key );
    /** 
     *  Implement to put a value into the context storage.
     *  <br><br>
     *  The implementation of this method is required for 
     *  proper operation of a Context implementation in
     *  general Velocity use.
     *
     *  @param key key with which to associate the value
     *  @param value value to be associated with the key
     *  @return previously stored value if exists, or null
     */
    public abstract Object internalPut( String key, Object value );
    /** 
     *  Implement to determine if a key is in the storage.
     *  <br><br>
     *  Currently, this method is not used internally by 
     *  the Velocity core. 
     *
     *   @param key key to test for existance 
     *   @return true if found, false if not
     */
    public abstract boolean internalContainsKey(Object key);
    /** 
     *  Implement to return an object array of key 
     *  strings from your storage.
     *  <br><br>
     *  Currently, this method is not used internally by
     *  the Velocity core.
     *
     *  @return array of keys
     */
    public abstract Object[] internalGetKeys();
    /** 
     *  I mplement to remove an item from your storage.
     *  <br><br>
     *  Currently, this method is not used internally by
     *  the Velocity core.
     *
     *  @param key key to remove
     *  @return object removed if exists, else null
     */
    public abstract Object internalRemove(Object key);
    /**
     *  default CTOR
     */
    public AbstractContext()
    {
    }        
    /**
     *  Chaining constructor accepts a Context argument.
     *  It will relay get() operations into this Context
     *  in the even the 'local' get() returns null.
     *  
     *  @param inner context to be chained
     */
    public AbstractContext( Context inner )
    {
        innerContext = inner;
        /*
         *  now, do a 'forward pull' of event cartridge so
         *  it's accessable, bringing to the top level.
         */
        if (innerContext instanceof InternalEventContext )
        {
            attachEventCartridge( ( (InternalEventContext) innerContext).getEventCartridge() );
        }
    }
    /**
     * Adds a name/value pair to the context. 
     * 
     * @param key   The name to key the provided value with.
     * @param value The corresponding value.
     * @return Object that was replaced in the the Context if
     *         applicable or null if not.
     */
    public Object put(String key, Object value)
    {
        /*
         * don't even continue if key or value is null
         */
        if (key == null)
        {
            return null;
        }
        else if (value == null)
        {
            return null;
        }
        return internalPut(key, value);
    }
    /**
     *  Gets the value corresponding to the provided key from the context.
     *
     *  Supports the chaining context mechanism.  If the 'local' context
     *  doesn't have the value, we try to get it from the chained context.
     *
     *  @param key The name of the desired value.
     *  @return    The value corresponding to the provided key or null if
     *             the key param is null.
     */
    public Object get(String key)
    {
        /*
         *  punt if key is null
         */
        if (key == null)
        {
            return null;
        }
        /*
         *  get the object for this key.  If null, and we are chaining another Context
         *  call the get() on it.
         */
        Object o = internalGet( key );
        if (o == null && innerContext != null)
        {
            o = innerContext.get( key );
        }
        return o;
    }        
    /**
     *  Indicates whether the specified key is in the context.  Provided for 
     *  debugging purposes.
     *
     * @param key The key to look for.
     * @return true if the key is in the context, false if not.
     */
    public boolean containsKey(Object key)
    {
        if (key == null)
        {
            return false;
        }
        return internalContainsKey(key);
    }        
    /**
     *  Get all the keys for the values in the context
     *  @return Object[] of keys in the Context. Does not return
     *          keys in chained context.
     */
    public Object[] getKeys()
    {
        return internalGetKeys();
    }
    /**
     * Removes the value associated with the specified key from the context.
     *
     * @param key The name of the value to remove.
     * @return    The value that the key was mapped to, or <code>null</code> 
     *            if unmapped.
     */
    public Object remove(Object key)
    {
        if (key == null)
        {
            return null;
        }
        return internalRemove(key);
    }   
    /**
     *  returns innerContext if one is chained
     *
     *  @return Context if chained, <code>null</code> if not
     */
    public Context getChainedContext()
    {
        return innerContext;
    }
}
"
org.apache.velocity.context.Context,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Interface describing the application data context.  This set of
 *  routines is used by the application to set and remove 'named' data
 *  object to pass them to the template engine to use when rendering
 *  a template.
 *
 *  This is the same set of methods supported by the original Context
 *  class
 *
 *  @see org.apache.velocity.context.AbstractContext
 *  @see org.apache.velocity.VelocityContext
 *
 *  @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: Context.java,v 1.5.4.1 2004/03/03 23:22:54 geirm Exp $
 */
public interface Context
{
    /**
     * Adds a name/value pair to the context.
     *
     * @param key   The name to key the provided value with.
     * @param value The corresponding value.
     */
    Object put(String key, Object value);
    /**
     * Gets the value corresponding to the provided key from the context.
     *
     * @param key The name of the desired value.
     * @return    The value corresponding to the provided key.
     */
    Object get(String key);
    /**
     * Indicates whether the specified key is in the context.
     *
     * @param key The key to look for.
     * @return    Whether the key is in the context.
     */
    boolean containsKey(Object key);
    /**
     * Get all the keys for the values in the context
     */
    Object[] getKeys();
    /**
     * Removes the value associated with the specified key from the context.
     *
     * @param key The name of the value to remove.
     * @return    The value that the key was mapped to, or <code>null</code> 
     *            if unmapped.
     */
    Object remove(Object key);
}
"
org.apache.velocity.context.InternalContextAdapter,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  interface to bring all necessary internal and user contexts together.
 *  this is what the AST expects to deal with.  If anything new comes
 *  along, add it here.
 *
 *  I will rename soon :)
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: InternalContextAdapter.java,v 1.5.4.1 2004/03/03 23:22:54 geirm Exp $
 */
public interface InternalContextAdapter 
    extends InternalHousekeepingContext, Context, InternalWrapperContext, InternalEventContext
{
}
"
org.apache.velocity.context.InternalContextAdapterImpl,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.runtime.resource.Resource;
/**
 *  This adapter class is the container for all context types for internal
 *  use.  The AST now uses this class rather than the app-level Context
 *  interface to allow flexibility in the future.
 *
 *  Currently, we have two context interfaces which must be supported :
 *  <ul>
 *  <li> Context : used for application/template data access
 *  <li> InternalHousekeepingContext : used for internal housekeeping and caching
 *  <li> InternalWrapperContext : used for getting root cache context and other
 *       such.
 *  <li> InternalEventContext : for event handling.
 *  </ul>
 *
 *  This class implements the two interfaces to ensure that all methods are 
 *  supported.  When adding to the interfaces, or adding more context 
 *  functionality, the interface is the primary definition, so alter that first
 *  and then all classes as necessary.  As of this writing, this would be 
 *  the only class affected by changes to InternalContext
 *
 *  This class ensures that an InternalContextBase is available for internal
 *  use.  If an application constructs their own Context-implementing
 *  object w/o subclassing AbstractContext, it may be that support for
 *  InternalContext is not available.  Therefore, InternalContextAdapter will
 *  create an InternalContextBase if necessary for this support.  Note that 
 *  if this is necessary, internal information such as node-cache data will be
 *  lost from use to use of the context.  This may or may not be important,
 *  depending upon application.
 * 
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: InternalContextAdapterImpl.java,v 1.8.12.1 2004/03/03 23:22:54 geirm Exp $
 */
public final class InternalContextAdapterImpl implements InternalContextAdapter
{
    /**  
     *  the user data Context that we are wrapping 
     */
    Context context = null;
    /** 
     *  the ICB we are wrapping.  We may need to make one
     *  if the user data context implementation doesn't
     *  support one.  The default AbstractContext-derived
     *  VelocityContext does, and it's recommended that 
     *  people derive new contexts from AbstractContext
     *  rather than piecing things together
     */
    InternalHousekeepingContext icb = null;
    /**
     *  The InternalEventContext that we are wrapping.  If
     *  the context passed to us doesn't support it, no
     *  biggie.  We don't make it for them - since its a 
     *  user context thing, nothing gained by making one
     *  for them now
     */
    InternalEventContext iec = null;
    /**
     *  CTOR takes a Context and wraps it, delegating all 'data' calls 
     *  to it.
     * 
     *  For support of internal contexts, it will create an InternalContextBase
     *  if need be.
     */
    public InternalContextAdapterImpl( Context c )
    {
        context = c;
        if ( !( c instanceof InternalHousekeepingContext ))
        {
            icb = new InternalContextBase();
        }
        else
        {
            icb = (InternalHousekeepingContext) context;
        }
        if ( c instanceof InternalEventContext)
        {
            iec = ( InternalEventContext) context;
        }
    }
    /* --- InternalHousekeepingContext interface methods --- */
    public void pushCurrentTemplateName( String s )
    {
        icb.pushCurrentTemplateName( s );
    }
    public void popCurrentTemplateName()
    {
        icb.popCurrentTemplateName();
    }
    public String getCurrentTemplateName()
    {
        return icb.getCurrentTemplateName();
    }
    public Object[] getTemplateNameStack()
    {
        return icb.getTemplateNameStack();
    }
    public IntrospectionCacheData icacheGet( Object key )
    {
        return icb.icacheGet( key );
    }
    public void icachePut( Object key, IntrospectionCacheData o )
    {
        icb.icachePut( key, o );
    }
   public void setCurrentResource( Resource r )
    {
        icb.setCurrentResource(r);
    }
    public Resource getCurrentResource()
    {
        return icb.getCurrentResource();
    }
    /* ---  Context interface methods --- */
    public Object put(String key, Object value)
    {
        return context.put( key , value );
    }
    public Object get(String key)
    {
        return context.get( key );
    }
    public boolean containsKey(Object key)
    {
        return context.containsKey( key );
    }
    public Object[] getKeys()
    {
        return context.getKeys();
    }
    public Object remove(Object key)
    {
        return context.remove( key );
    }
    /* ---- InternalWrapperContext --- */
    /**
     *  returns the user data context that
     *  we are wrapping
     */
    public Context getInternalUserContext()
    {
        return context;
    }
    /**
     *  Returns the base context that we are 
     *  wrapping. Here, its this, but for other thing
     *  like VM related context contortions, it can
     *  be something else
     */
    public InternalContextAdapter getBaseContext()
    {
        return this;
    }
    /* -----  InternalEventContext ---- */
    public EventCartridge attachEventCartridge( EventCartridge ec )
    {
        if (iec != null)
        {
            return iec.attachEventCartridge( ec );
        }
        return null;
    }
    public EventCartridge getEventCartridge()
    {
        if ( iec != null)
        {
            return iec.getEventCartridge( );
        }
        return null;
    }
}
"
org.apache.velocity.context.InternalContextBase,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.HashMap;
import java.util.Stack;
import java.io.Serializable;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.runtime.resource.Resource;
/**
 *  class to encapsulate the 'stuff' for internal operation of velocity.  
 *  We use the context as a thread-safe storage : we take advantage of the
 *  fact that it's a visitor  of sorts  to all nodes (that matter) of the 
 *  AST during init() and render().
 *  Currently, it carries the template name for namespace
 *  support, as well as node-local context data introspection caching.
 *
 *  Note that this is not a public class.  It is for package access only to
 *  keep application code from accessing the internals, as AbstractContext
 *  is derived from this.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: InternalContextBase.java,v 1.8.12.1 2004/03/03 23:22:54 geirm Exp $
 */
class InternalContextBase implements InternalHousekeepingContext, InternalEventContext,  Serializable
{
    /**
     *  cache for node/context specific introspection information
     */
    private HashMap introspectionCache = new HashMap(33);
    /**
     *  Template name stack. The stack top contains the current template name.
     */
    private Stack templateNameStack = new Stack();
    /**
     *  EventCartridge we are to carry.  Set by application
     */
    private EventCartridge eventCartridge = null;
    /**
     *  Current resource - used for carrying encoding and other
     *  information down into the rendering process
     */
    private Resource currentResource = null;
    /**
     *  set the current template name on top of stack
     *
     *  @param s current template name
     */
    public void pushCurrentTemplateName( String s )
    {
        templateNameStack.push(s);
        return;
    }
    /**
     *  remove the current template name from stack
     */
    public void popCurrentTemplateName()
    {
        templateNameStack.pop();
        return;
    }
    /**
     *  get the current template name
     *
     *  @return String current template name
     */
    public String getCurrentTemplateName()
    {
        if ( templateNameStack.empty() )
            return ""<undef>"";
        else
            return (String) templateNameStack.peek();
    }
    /**
     *  get the current template name stack
     *
     *  @return Object[] with the template name stack contents.
     */
    public Object[] getTemplateNameStack()
    {
        return templateNameStack.toArray();
    }
    /**
     *  returns an IntrospectionCache Data (@see IntrospectionCacheData)
     *  object if exists for the key
     *
     *  @param key  key to find in cache
     *  @return cache object
     */
    public IntrospectionCacheData icacheGet( Object key )
    {
        return ( IntrospectionCacheData ) introspectionCache.get( key );
    }
    /**
     *  places an IntrospectionCache Data (@see IntrospectionCacheData)
     *  element in the cache for specified key
     *
     *  @param key  key 
     *  @param o  IntrospectionCacheData object to place in cache
     */
    public void icachePut( Object key, IntrospectionCacheData o )
    {
        introspectionCache.put( key, o );
    }
    public void setCurrentResource( Resource r )
    {
        currentResource = r;
    }
    public Resource getCurrentResource()
    {
        return currentResource;
    }
    public EventCartridge attachEventCartridge( EventCartridge ec )
    {
        EventCartridge temp = eventCartridge;
        eventCartridge = ec;
        return temp;
    }
    public EventCartridge getEventCartridge()
    {
        return eventCartridge;
    }
}
"
org.apache.velocity.context.InternalEventContext,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.app.event.EventCartridge;
/**
 *  Interface for event support.  Note that this is a public internal
 *  interface, as it is something that will be accessed from outside 
 *  of the .context package.
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: InternalEventContext.java,v 1.2.12.1 2004/03/03 23:22:54 geirm Exp $
 */
public interface InternalEventContext
{
    public EventCartridge attachEventCartridge( EventCartridge ec);
    public EventCartridge getEventCartridge();
}
"
org.apache.velocity.context.InternalHousekeepingContext,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.runtime.resource.Resource;
/**
 *  interface to encapsulate the 'stuff' for internal operation of velocity.  
 *  We use the context as a thread-safe storage : we take advantage of the
 *  fact that it's a visitor  of sorts  to all nodes (that matter) of the 
 *  AST during init() and render().
 *
 *  Currently, it carries the template name for namespace
 *  support, as well as node-local context data introspection caching.
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 *  @version $Id: InternalHousekeepingContext.java,v 1.6.12.1 2004/03/03 23:22:54 geirm Exp $
 */
interface InternalHousekeepingContext
{
    /**
     *  set the current template name on top of stack
     *
     *  @param s current template name
     */
    void pushCurrentTemplateName( String s );
    /**
     *  remove the current template name from stack
     */
    void popCurrentTemplateName();
    /**
     *  get the current template name
     *
     *  @return String current template name
     */
    String getCurrentTemplateName();
    /**
     *  Returns the template name stack in form of an array.
     *
     *  @return Object[] with the template name stack contents.
     */
    Object[] getTemplateNameStack();
    /**
     *  returns an IntrospectionCache Data (@see IntrospectionCacheData)
     *  object if exists for the key
     *
     *  @param key  key to find in cache
     *  @return cache object
     */
    IntrospectionCacheData icacheGet( Object key );
    /**
     *  places an IntrospectionCache Data (@see IntrospectionCacheData)
     *  element in the cache for specified key
     *
     *  @param key  key 
     *  @param o  IntrospectionCacheData object to place in cache
     */
    void icachePut( Object key, IntrospectionCacheData o );
    /**
     *  temporary fix to enable #include() to figure out
     *  current encoding.
     *
     */
    Resource getCurrentResource();
    void setCurrentResource( Resource r );
}
"
org.apache.velocity.context.InternalWrapperContext,"package org.apache.velocity.context;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  interface for internal context wrapping functionality
 *  
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: InternalWrapperContext.java,v 1.2.14.1 2004/03/03 23:22:54 geirm Exp $ 
 */
public interface InternalWrapperContext
{
    /** returns the wrapped user context */
    public Context getInternalUserContext();
    /** returns the base full context impl */
    public InternalContextAdapter getBaseContext();
}
"
org.apache.velocity.context.VMContext,"package org.apache.velocity.context;
/*
 * Copyright 2000,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.HashMap;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.directive.VMProxyArg;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.app.event.EventCartridge;
/**
 *  This is a special, internal-use-only context implementation to be
 *  used for the new Velocimacro implementation.
 *
 *  The main distinguishing feature is the management of the VMProxyArg objects
 *  in the put() and get() methods.
 *
 *  Further, this context also supports the 'VM local context' mode, where
 *  any get() or put() of references that aren't args to the VM are considered
 *  local to the vm, protecting the global context.
 *  
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: VMContext.java,v 1.9.10.1 2004/03/03 23:22:54 geirm Exp $ 
 */
public class VMContext implements InternalContextAdapter
{
    /** container for our VMProxy Objects */
    HashMap vmproxyhash = new HashMap();
    /** container for any local or constant VMProxy items */
    HashMap localcontext = new HashMap();
    /** the base context store.  This is the 'global' context */
    InternalContextAdapter innerContext = null;
    /** context that we are wrapping */
    InternalContextAdapter wrappedContext = null;
    /** support for local context scope feature, where all references are local */
    private  boolean localcontextscope = false;
     /**
     *  CTOR, wraps an ICA
     */
    public VMContext( InternalContextAdapter  inner, RuntimeServices rsvc )
    {
        localcontextscope = rsvc.getBoolean( RuntimeConstants.VM_CONTEXT_LOCALSCOPE, false );
        wrappedContext = inner;
        innerContext = inner.getBaseContext();
    }
    /**
     *  return the inner / user context
     */
    public Context getInternalUserContext()
    {
        return innerContext.getInternalUserContext();
    }
    public InternalContextAdapter getBaseContext()
    {
        return innerContext.getBaseContext();
    }
    /**
     *  Used to put VMProxyArgs into this context.  It separates
     *  the VMProxyArgs into constant and non-constant types
     *  pulling out the value of the constant types so they can
     *  be modified w/o damaging the VMProxyArg, and leaving the
     *  dynamic ones, as they modify context rather than their own
     *  state
     *  @param  vmpa VMProxyArg to add 
     */
    public void addVMProxyArg(  VMProxyArg vmpa )
    {
        /*
         *  ask if it's a constant : if so, get the value and put into the
         *  local context, otherwise, put the vmpa in our vmproxyhash
         */
        String key = vmpa.getContextReference();
        if ( vmpa.isConstant() )
        {
            localcontext.put( key, vmpa.getObject( wrappedContext ) );
        }
        else
        {
            vmproxyhash.put( key, vmpa );
        }
    }
    /**
     *  Impl of the Context.put() method. 
     *
     *  @param key name of item to set
     *  @param value object to set to key
     *  @return old stored object
     */
    public Object put(String key, Object value)
    {
        /*
         *  first see if this is a vmpa
         */
        VMProxyArg vmpa = (VMProxyArg) vmproxyhash.get( key );
        if( vmpa != null)
        {
            return vmpa.setObject( wrappedContext, value );
        }
        else
        {
            if(localcontextscope)
            {
                /*
                 *  if we have localcontextscope mode, then just 
                 *  put in the local context
                 */
                return localcontext.put( key, value );
            }
            else
            {
                /*
                 *  ok, how about the local context?
                 */
                if (localcontext.containsKey( key ))
                {
                    return localcontext.put( key, value);
                }
                else
                {
                    /*
                     * otherwise, let them push it into the 'global' context
                     */
                    return innerContext.put( key, value );   
                }
            }
        }
    }
    /**
     *  Impl of the Context.gut() method. 
     *
     *  @param key name of item to get
     *  @return  stored object or null
     */
    public Object get( String key )
    {
        /*
         * first, see if it's a VMPA
         */
        Object o = null;
        VMProxyArg vmpa = (VMProxyArg) vmproxyhash.get( key );
        if( vmpa != null )
        {
            o = vmpa.getObject( wrappedContext );
        }
        else
        {
            if(localcontextscope)
            {
                /*
                 * if we have localcontextscope mode, then just 
                 * put in the local context
                 */
                o =  localcontext.get( key );
            }
            else
            {
                /*
                 *  try the local context
                 */
                o = localcontext.get( key );
                if ( o == null)
                {
                    /*
                     * last chance
                     */
                    o = innerContext.get( key );
                }
            }
        }
        return o;
    }
    /**
     *  not yet impl
     */
    public boolean containsKey(Object key)
    {
        return false;
    }
    /**
     *  impl badly
     */
    public Object[] getKeys()
    {
        return vmproxyhash.keySet().toArray();
    }
    /**
     *  impl badly
     */
    public Object remove(Object key)
    {
        return vmproxyhash.remove( key );
    }
    public void pushCurrentTemplateName( String s )
    {
        innerContext.pushCurrentTemplateName( s );
    }
    public void popCurrentTemplateName()
    {
        innerContext.popCurrentTemplateName();
    }
    public String getCurrentTemplateName()
    {
        return innerContext.getCurrentTemplateName();
    }
    public Object[] getTemplateNameStack()
    {
        return innerContext.getTemplateNameStack();
    }
    public IntrospectionCacheData icacheGet( Object key )
    {
        return innerContext.icacheGet( key );
    }
    public void icachePut( Object key, IntrospectionCacheData o )
    {
        innerContext.icachePut( key, o );
    }
    public EventCartridge attachEventCartridge( EventCartridge ec )
    {
        return innerContext.attachEventCartridge( ec );
    }
    public EventCartridge getEventCartridge()
    {
        return innerContext.getEventCartridge();
    }
    public void setCurrentResource( Resource r )
    {
        innerContext.setCurrentResource( r );
    }
    public Resource getCurrentResource()
    {
        return innerContext.getCurrentResource();
    }
}
"
org.apache.velocity.convert.WebMacro,"package org.apache.velocity.convert;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import java.io.FileWriter;
import org.apache.oro.text.perl.Perl5Util;
import org.apache.velocity.util.StringUtils;
import org.apache.tools.ant.DirectoryScanner;
/**
 * This class will convert a WebMacro template to
 * a Velocity template. Uses the ORO Regexp package to do the 
 * rewrites. Note, it isn't 100% perfect, but will definitely get
 * you about 99.99% of the way to a converted system. Please
 * see the website documentation for more information on how to use
 * this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @version $Id: WebMacro.java,v 1.20.8.1 2004/03/03 23:22:54 geirm Exp $ 
 */
public class WebMacro
{
    protected static final String VM_EXT = "".vm"";
    protected static final String WM_EXT = "".wm"";
    /**
     * The regexes to use for line by line substition. The regexes
     * come in pairs. The first is the string to match, the second is
     * the substitution to make.
     */
    protected static String[] perLineREs =
    {
        // Make #if directive match the Velocity directive style.
        ""#if\\s*[(]\\s*(.*\\S)\\s*[)]\\s*(#begin|{)[ \\t]?"",
        ""#if( $1 )"",
        // Remove the WM #end #else #begin usage.
        ""[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?(\\w)"",
        ""$2#else#**#$4"", // avoid touching followup word with embedded comment
        ""[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?"",
        ""$2#else"",
        ""(#end|})(\\s*#else)\\s*(#begin|{)[ \\t]?"",
        ""$1\n$2"",
        // Convert WM style #foreach to Velocity directive style.
        ""#foreach\\s+(\\$\\w+)\\s+in\\s+(\\$[^\\s#]+)\\s*(#begin|{)[ \\t]?"",
        ""#foreach( $1 in $2 )"",
        // Convert WM style #set to Velocity directive style.
        ""#set\\s+(\\$[^\\s=]+)\\s*=\\s*([\\S \\t]+)"",
        ""#set( $1 = $2 )"",
        ""(##[# \\t\\w]*)\\)"", // fix comments included at end of line
        "")$1"",
        // Convert WM style #parse to Velocity directive style.
        ""#parse\\s+([^\\s#]+)[ \\t]?"",
        ""#parse( $1 )"",
        // Convert WM style #include to Velocity directive style.
        ""#include\\s+([^\\s#]+)[ \\t]?"",
        ""#include( $1 )"",
        // Convert WM formal reference to VTL syntax.
        ""\\$\\(([^\\)]+)\\)"",
        ""${$1}"",
        ""\\${([^}\\(]+)\\(([^}]+)}\\)"", // fix encapsulated brakets: {(})
        ""${$1($2)}"",
        // Velocity currently does not permit leading underscore.
        ""\\$_"",
        ""$l_"",
        ""\\${(_[^}]+)}"", // within a formal reference
        ""${l$1}"",
        // Eat semi-colons in (converted) VTL #set directives.
        ""(#set\\s*\\([^;]+);(\\s*\\))"",
        ""$1$2"",
        // Convert explicitly terminated WM statements to VTL syntax.
        ""(^|[^\\\\])\\$(\\w[^=\n;'\""]*);"",
        ""$1${$2}"",
        // Change extensions when seen.
        ""\\.wm"",
        "".vm""
    };
    /**
     * Iterate through the set of find/replace regexes
     * that will convert a given WM template to a VM template
     */
    public void convert(String target)
    {
        File file = new File(target);
        if (!file.exists())
        {
            System.err.println
                (""The specified template or directory does not exist"");
            System.exit(1);
        }
        if (file.isDirectory())
        {
            String basedir = file.getAbsolutePath();
            String newBasedir = basedir + VM_EXT;
            DirectoryScanner ds = new DirectoryScanner();
            ds.setBasedir(basedir);
            ds.addDefaultExcludes();
            ds.scan();
            String[] files = ds.getIncludedFiles();
            for (int i = 0; i < files.length; i++)
            {
                writeTemplate(files[i], basedir, newBasedir);
            }
        }
        else
        {
            writeTemplate(file.getAbsolutePath(), """", """");
        }
    }
    /**
     * Write out the converted template to the given named file
     * and base directory.
     */
    private boolean writeTemplate(String file, String basedir,
                                  String newBasedir)
    {
        if (file.indexOf(WM_EXT) < 0)
        {
            return false;
        }
        System.out.println(""Converting "" + file + ""..."");
        String template;
        String templateDir;
        String newTemplate;
        File outputDirectory;
        if (basedir.length() == 0)
        {
            template = file;
            templateDir = """";
            newTemplate = convertName(file);
        }            
        else
        {
            template = basedir + File.separator + file;
            templateDir = newBasedir + extractPath(file);
            outputDirectory = new File(templateDir);
            if (! outputDirectory.exists())
            {
                outputDirectory.mkdirs();
            }
            newTemplate = newBasedir + File.separator + convertName(file);
        }            
        String convertedTemplate = convertTemplate(template);
        try
        {
            FileWriter fw = new FileWriter(newTemplate);
            fw.write(convertedTemplate);
            fw.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return true;
    }
    /**
     * Gets the path segment of the full path to a file (i.e. one
     * which originally included the file name).
     */
    private final String extractPath(String file)
    {
        int lastSepPos = file.lastIndexOf(File.separator);
        return (lastSepPos == -1 ? """" :
                File.separator + file.substring(0, lastSepPos));
    }
    /**
     * Simple extension conversion of .wm to .vm
     */
    private String convertName(String name)
    {
        if (name.indexOf(WM_EXT) > 0)
        {
            return name.substring(0, name.indexOf(WM_EXT)) + VM_EXT;
        }
        else
        {
            return name;
        }
    }
    /**
     * How to use this little puppy :-)
     */
    private static final void usage()
    {
        System.err.println(""Usage: convert-wm <template.wm | directory>"");
        System.exit(1);
    }
    /**
     * Apply find/replace regexes to our WM template
     */
    public String convertTemplate(String template)
    {
        String contents = StringUtils.fileContentsToString(template);
        // Overcome Velocity 0.71 limitation.
        // HELP: Is this still necessary?
        if (!contents.endsWith(""\n""))
        {
            contents += ""\n"";
        }
        // Convert most markup.
        Perl5Util perl = new Perl5Util();
        for (int i = 0; i < perLineREs.length; i += 2)
        {
            contents = perl.substitute(makeSubstRE(i), contents);
        }
        // Convert closing curlies.
        if (perl.match(""m/javascript/i"", contents))
        {
            // ASSUMPTION: JavaScript is indented, WM is not.
            contents = perl.substitute(""s/\n}/\n#end/g"", contents);
        }
        else
        {
            contents = perl.substitute(""s/(\n\\s*)}/$1#end/g"", contents);
            contents = perl.substitute(""s/#end\\s*\n\\s*#else/#else/g"",
                                       contents);
        }
        return contents;
    }
    /**
     * Makes a Perl 5 regular expression for use by ORO.
     */
    private final String makeSubstRE(int i)
    {
        return (""s/"" + perLineREs[i] + '/' + perLineREs[i + 1] + ""/g"");
    }
    /**
     * Main hook for the conversion process.
     */
    public static void main(String[] args)
    {
        if (args.length > 0)
        {
            for (int x=0; x < args.length; x++)
            {
                WebMacro converter = new WebMacro();
                converter.convert(args[x]);
            }
        }
        else
        {
            usage();
        }
    }
}
"
org.apache.velocity.exception.MethodInvocationException,"package org.apache.velocity.exception;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Application-level exception thrown when a reference method is 
 *  invoked and an exception is thrown.
 *  <br>
 *  When this exception is thrown, a best effort will be made to have
 *  useful information in the exception's message.  For complete 
 *  information, consult the runtime log.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: MethodInvocationException.java,v 1.2.14.1 2004/03/03 23:22:54 geirm Exp $
 */
public class MethodInvocationException extends VelocityException
{
    private String methodName = """";
    private String referenceName = """";
    private Throwable wrapped = null;
    /**
     *  CTOR - wraps the passed in exception for
     *  examination later
     *
     *  @param message 
     *  @param e Throwable that we are wrapping
     *  @param methodName name of method that threw the exception
     */
    public MethodInvocationException( String message, Throwable e, String methodName )
    {
        super(message);
        this.wrapped = e;
        this.methodName = methodName;
    }       
    /**
     *  Returns the name of the method that threw the
     *  exception
     *
     *  @return String name of method
     */
    public String getMethodName()
    {
        return methodName;
    }
    /**
     *  returns the wrapped Throwable that caused this
     *  MethodInvocationException to be thrown
     *  
     *  @return Throwable thrown by method invocation
     */
    public Throwable getWrappedThrowable()
    {
        return wrapped;
    }
    /**
     *  Sets the reference name that threw this exception
     *
     *  @param reference name of reference
     */
    public void setReferenceName( String ref )
    {
        referenceName = ref;
    }
    /**
     *  Retrieves the name of the reference that caused the 
     *  exception
     *
     *  @return name of reference
     */
    public String getReferenceName()
    {
        return referenceName;
    }
}
"
org.apache.velocity.exception.ParseErrorException,"package org.apache.velocity.exception;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Application-level exception thrown when a resource of any type
 *  has a syntax or other error which prevents it from being parsed.
 *  <br>
 *  When this resource is thrown, a best effort will be made to have
 *  useful information in the exception's message.  For complete 
 *  information, consult the runtime log.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ParseErrorException.java,v 1.2.14.1 2004/03/03 23:22:54 geirm Exp $
 */
public class ParseErrorException extends VelocityException
{
    public ParseErrorException(String exceptionMessage )
    {
        super(exceptionMessage);
    }       
}
"
org.apache.velocity.exception.ResourceNotFoundException,"package org.apache.velocity.exception;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Application-level exception thrown when a resource of any type
 *  isn't found by the Velocity engine.
 *  <br>
 *  When this exception is thrown, a best effort will be made to have
 *  useful information in the exception's message.  For complete 
 *  information, consult the runtime log.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @version $Id: ResourceNotFoundException.java,v 1.3.8.1 2004/03/03 23:22:54 geirm Exp $
 */
public class ResourceNotFoundException extends VelocityException
{
    public ResourceNotFoundException(String exceptionMessage)
    {
        super(exceptionMessage);
    }
}
"
org.apache.velocity.exception.VelocityException,"package org.apache.velocity.exception;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Base class for Velocity exceptions thrown to the 
 *  application layer.
 *
 * @author <a href=""mailto:kdowney@amberarcher.com"">Kyle F. Downey</a>
 * @version $Id: VelocityException.java,v 1.2.14.1 2004/03/03 23:22:54 geirm Exp $
 */
public class VelocityException extends Exception
{
    public VelocityException(String exceptionMessage )
    {
        super(exceptionMessage);
    }       
}
"
org.apache.velocity.io.VelocityWriter,"package org.apache.velocity.io;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.IOException;
import java.io.Writer;
/**
 * Implementation of a fast Writer. It was originally taken from JspWriter
 * and modified to have less syncronization going on.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author Anil K. Vijendran
 * @version $Id: VelocityWriter.java,v 1.8.4.1 2004/03/03 23:22:54 geirm Exp $
 */
public final class VelocityWriter extends Writer
{
    /**
     * constant indicating that the Writer is not buffering output
     */
    public static final int	NO_BUFFER = 0;
    /**
     * constant indicating that the Writer is buffered and is using the 
     * implementation default buffer size
     */
    public static final int	DEFAULT_BUFFER = -1;
    /**
     * constant indicating that the Writer is buffered and is unbounded; 
     * this is used in BodyContent
     */
    public static final int	UNBOUNDED_BUFFER = -2;
    protected int     bufferSize;
    protected boolean autoFlush;
    private Writer writer;
    private char cb[];
    private int nextChar;
    private static int defaultCharBufferSize = 8 * 1024;
    private boolean flushed = false;
    /**
     * Create a buffered character-output stream that uses a default-sized
     * output buffer.
     *
     * @param  response  A Servlet Response
     */
    public VelocityWriter(Writer writer)
    {
        this(writer, defaultCharBufferSize, true);
    }
    /**
     * private constructor.
     */
    private VelocityWriter(int bufferSize, boolean autoFlush)
    {
        this.bufferSize = bufferSize;
        this.autoFlush  = autoFlush;
    }
    /**
     * This method returns the size of the buffer used by the JspWriter.
     *
     * @return the size of the buffer in bytes, or 0 is unbuffered.
     */
    public int getBufferSize() { return bufferSize; }
    /**
     * This method indicates whether the JspWriter is autoFlushing.
     *
     * @return if this JspWriter is auto flushing or throwing IOExceptions on 
     *         buffer overflow conditions
     */
    public boolean isAutoFlush() { return autoFlush; }
    /**
     * Create a new buffered character-output stream that uses an output
     * buffer of the given size.
     *
     * @param  response A Servlet Response
     * @param  sz   	Output-buffer size, a positive integer
     *
     * @exception  IllegalArgumentException  If sz is <= 0
     */
    public VelocityWriter(Writer writer, int sz, boolean autoFlush)
    {
        this(sz, autoFlush);
        if (sz < 0)
            throw new IllegalArgumentException(""Buffer size <= 0"");
        this.writer = writer;
        cb = sz == 0 ? null : new char[sz];
        nextChar = 0;
    }
    private final void init( Writer writer, int sz, boolean autoFlush )
    {
        this.writer= writer;
        if( sz > 0 && ( cb == null || sz > cb.length ) )
            cb=new char[sz];
        nextChar = 0;
        this.autoFlush=autoFlush;
        this.bufferSize=sz;
    }
    /**
     * Flush the output buffer to the underlying character stream, without
     * flushing the stream itself.  This method is non-private only so that it
     * may be invoked by PrintStream.
     */
    private final void flushBuffer() throws IOException
    {
        if (bufferSize == 0)
            return;
        flushed = true;
        if (nextChar == 0)
            return;
        writer.write(cb, 0, nextChar);
        nextChar = 0;
    }
    /**
     * Discard the output buffer.
     */
    public final void clear()
    {
        nextChar = 0;
    }
    private final void bufferOverflow() throws IOException
    {
        throw new IOException(""overflow"");
    }
    /**
     * Flush the stream.
     *
     */
    public final void flush()  throws IOException
    {
        flushBuffer();
        if (writer != null)
        {
            writer.flush();
        }
    }
    /**
     * Close the stream.
     *
     */
    public final void close() throws IOException {
        if (writer == null)
            return;
        flush();
    }
    /**
     * @return the number of bytes unused in the buffer
     */
    public final int getRemaining()
    {
        return bufferSize - nextChar;
    }
    /**
     * Write a single character.
     *
     */
    public final void write(int c) throws IOException
    {
        if (bufferSize == 0)
        {
            writer.write(c);
        }
        else
        {
            if (nextChar >= bufferSize)
                if (autoFlush)
                    flushBuffer();
                else
                    bufferOverflow();
            cb[nextChar++] = (char) c;
        }
    }
    /**
     * Our own little min method, to avoid loading
     * <code>java.lang.Math</code> if we've run out of file
     * descriptors and we're trying to print a stack trace.
     */
    private final int min(int a, int b)
    {
	    return (a < b ? a : b);
    }
    /**
     * Write a portion of an array of characters.
     *
     * <p> Ordinarily this method stores characters from the given array into
     * this stream's buffer, flushing the buffer to the underlying stream as
     * needed.  If the requested length is at least as large as the buffer,
     * however, then this method will flush the buffer and write the characters
     * directly to the underlying stream.  Thus redundant
     * <code>DiscardableBufferedWriter</code>s will not copy data unnecessarily.
     *
     * @param  cbuf  A character array
     * @param  off   Offset from which to start reading characters
     * @param  len   Number of characters to write
     *
     */
    public final void write(char cbuf[], int off, int len) 
        throws IOException 
    {
        if (bufferSize == 0)
        {
            writer.write(cbuf, off, len);
            return;
        }
        if (len == 0)
        {
            return;
        } 
        if (len >= bufferSize)
        {
            /* If the request length exceeds the size of the output buffer,
            flush the buffer and then write the data directly.  In this
            way buffered streams will cascade harmlessly. */
            if (autoFlush)
                flushBuffer();
            else
                bufferOverflow();
                writer.write(cbuf, off, len);
            return;
        }
        int b = off, t = off + len;
        while (b < t)
        {
            int d = min(bufferSize - nextChar, t - b);
            System.arraycopy(cbuf, b, cb, nextChar, d);
            b += d;
            nextChar += d;
            if (nextChar >= bufferSize) 
                if (autoFlush)
                    flushBuffer();
                else
                    bufferOverflow();
        }
    }
    /**
     * Write an array of characters.  This method cannot be inherited from the
     * Writer class because it must suppress I/O exceptions.
     */
    public final void write(char buf[]) throws IOException
    {
    	write(buf, 0, buf.length);
    }
    /**
     * Write a portion of a String.
     *
     * @param  s     String to be written
     * @param  off   Offset from which to start reading characters
     * @param  len   Number of characters to be written
     *
     */
    public final void write(String s, int off, int len) throws IOException
    {
        if (bufferSize == 0)
        {
            writer.write(s, off, len);
            return;
        }
        int b = off, t = off + len;
        while (b < t)
        {
            int d = min(bufferSize - nextChar, t - b);
            s.getChars(b, b + d, cb, nextChar);
            b += d;
            nextChar += d;
            if (nextChar >= bufferSize) 
                if (autoFlush)
                    flushBuffer();
                else
                    bufferOverflow();
        }
    }
    /**
     * Write a string.  This method cannot be inherited from the Writer class
     * because it must suppress I/O exceptions.
     */
    public final void write(String s) throws IOException
    {
    	write(s, 0, s.length());
    }
    /**
     * resets this class so that it can be reused
     *
     */
    public final void recycle( Writer writer)
    {
        this.writer = writer;
        flushed = false;
        clear();
    }
}
"
org.apache.velocity.runtime.Runtime,"package org.apache.velocity.runtime;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Reader;
import java.util.Properties;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * This is the Runtime system for Velocity. It is the
 * single access point for all functionality in Velocity.
 * It adheres to the mediator pattern and is the only
 * structure that developers need to be familiar with
 * in order to get Velocity to perform.
 *
 * The Runtime will also cooperate with external
 * systems like Turbine. Runtime properties can
 * set and then the Runtime is initialized.
 *
 * Turbine for example knows where the templates
 * are to be loaded from, and where the velocity
 * log file should be placed.
 *
 * So in the case of Velocity cooperating with Turbine
 * the code might look something like the following:
 *
 * <pre>
 * Runtime.setProperty(Runtime.FILE_RESOURCE_LOADER_PATH, templatePath);
 * Runtime.setProperty(Runtime.RUNTIME_LOG, pathToVelocityLog);
 * Runtime.init();
 * </pre>
 *
 * <pre>
 * -----------------------------------------------------------------------
 * N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
 * -----------------------------------------------------------------------
 * Runtime.init()
 * 
 * If Runtime.init() is called by itself the Runtime will
 * initialize with a set of default values.
 * -----------------------------------------------------------------------
 * Runtime.init(String/Properties)
 *
 * In this case the default velocity properties are layed down
 * first to provide a solid base, then any properties provided
 * in the given properties object will override the corresponding
 * default property.
 * -----------------------------------------------------------------------
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jlb@houseofdistraction.com"">Jeff Bowden</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 *
 * @see org.apache.velocity.runtime.RuntimeInstance
 * @see org.apache.velocity.runtime.RuntimeSingleton
 * @deprecated Use RuntimeInstance or RuntimeSingleton instead.
 *
 * @version $Id: Runtime.java,v 1.116.4.1 2004/03/03 23:22:55 geirm Exp $
 */
public class Runtime implements RuntimeConstants
{
    /*
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     * 
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     */
    public synchronized static void init()
        throws Exception
    {
        RuntimeSingleton.init();
    }
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param String property key
     * @param String property value
     */
    public static void setProperty(String key, Object value)
    {
        RuntimeSingleton.setProperty( key, value );
    }        
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param ExtendedProperties configuration
     */
    public static void setConfiguration( ExtendedProperties configuration)
    {
        RuntimeSingleton.setConfiguration( configuration );
    }
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param String key
     * @param String value
     */
    public static void addProperty(String key, Object value)
    {
        RuntimeSingleton.addProperty( key, value );
    }
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param String key of property to clear
     */
    public static void clearProperty(String key)
    {
        RuntimeSingleton.clearProperty( key );
    }
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     */
    public static Object getProperty( String key )
    {
        return RuntimeSingleton.getProperty( key );
    }
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param Properties
     */
    public static void init(Properties p) throws Exception
    {
        RuntimeSingleton.init(p);
    }
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param Properties
     */
    public static void init(String configurationFile)
        throws Exception
    {
        RuntimeSingleton.init( configurationFile );
    }
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd 
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the 
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     */
    public static SimpleNode parse( Reader reader, String templateName )
        throws ParseException
    {
        return RuntimeSingleton.parse( reader, templateName );
    }
    /**
     *  Parse the input and return the root of the AST node structure.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template
     */
    public static SimpleNode parse( Reader reader, String templateName, boolean dumpNamespace )
        throws ParseException
    {
        return RuntimeSingleton.parse( reader, templateName, dumpNamespace );
    }
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the 
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name );
    }
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name, encoding );
    }
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public static ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getContent( name );
    }
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public static ContentResource getContent( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getContent( name, encoding );
    }
    /**
     *  Determines is a template exists, and returns name of the loader that 
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public static String getLoaderNameForResource( String resourceName )
    {
        return RuntimeSingleton.getLoaderNameForResource( resourceName );
    }
    /**
     * Log a warning message.
     *
     * @param Object message to log
     */
    public static void warn(Object message)
    {
        RuntimeSingleton.warn( message );
    }
    /** 
     * Log an info message.
     *
     * @param Object message to log
     */
    public static void info(Object message)
    {
        RuntimeSingleton.info( message );
    }
    /**
     * Log an error message.
     *
     * @param Object message to log
     */
    public static void error(Object message)
    {
        RuntimeSingleton.error( message );
    }
    /**
     * Log a debug message.
     *
     * @param Object message to log
     */
    public static void debug(Object message)
    {
        RuntimeSingleton.debug( message );
    }
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     * 
     * @param String key property key
     * @param String defaultValue  default value to return if key not 
     *               found in resource manager.
     * @return String  value of key or default 
     */
    public static String getString( String key, String defaultValue)
    {
        return RuntimeSingleton.getString( key, defaultValue );
    }
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param String vmName  Name of velocimacro requested
     * @return String VelocimacroProxy 
     */
    public static Directive getVelocimacro( String vmName, String templateName  )
    {
        return RuntimeSingleton.getVelocimacro( vmName, templateName );
    }
   /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param String name  Name of velocimacro 
     * @param String macro  String form of macro body
     * @param String argArray  Array of strings, containing the 
     *                         #macro() arguments.  the 0th is the name.
     * @return boolean  True if added, false if rejected for some 
     *                  reason (either parameters or permission settings) 
     */
    public static boolean addVelocimacro( String name, 
                                          String macro, 
                                          String argArray[], 
                                          String sourceTemplate )
    {    
        return RuntimeSingleton.addVelocimacro( name, macro, argArray, sourceTemplate );
    }
    /**
     *  Checks to see if a VM exists
     *
     * @param name  Name of velocimacro
     * @return boolean  True if VM by that name exists, false if not
     */
    public static boolean isVelocimacro( String vmName, String templateName )
    {
        return RuntimeSingleton.isVelocimacro( vmName, templateName );
    }
    /**
     *  tells the vmFactory to dump the specified namespace.  This is to support
     *  clearing the VM list when in inline-VM-local-scope mode
     */
    public static boolean dumpVMNamespace( String namespace )
    {
        return RuntimeSingleton.dumpVMNamespace( namespace );
    }
    /* --------------------------------------------------------------------
     * R U N T I M E  A C C E S S O R  M E T H O D S
     * --------------------------------------------------------------------
     * These are the getXXX() methods that are a simple wrapper
     * around the configuration object. This is an attempt
     * to make a the Velocity Runtime the single access point
     * for all things Velocity, and allow the Runtime to
     * adhere as closely as possible the the Mediator pattern
     * which is the ultimate goal.
     * --------------------------------------------------------------------
     */
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     */
    public static String getString(String key)
    {
        return RuntimeSingleton.getString( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param String key property key
     * @return int value
     */
    public static int getInt( String key )
    {
        return RuntimeSingleton.getInt( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param int default value
     * @return int  value
     */
    public static int getInt( String key, int defaultValue )
    {
        return RuntimeSingleton.getInt( key, defaultValue );
    }
    /**
     * Boolean property accessor method to hide the configuration implementation.
     * 
     * @param String key  property key
     * @param boolean default default value if property not found
     * @return boolean  value of key or default value
     */
    public static boolean getBoolean( String key, boolean def )
    {
        return RuntimeSingleton.getBoolean( key, def );
    }
    /**
     * Return the velocity runtime configuration object.
     *
     * @return ExtendedProperties configuration object which houses
     *                       the velocity runtime properties.
     */
    public static ExtendedProperties getConfiguration()
    {
        return RuntimeSingleton.getConfiguration();
    }        
}
"
org.apache.velocity.runtime.RuntimeConstants,"package org.apache.velocity.runtime;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class defines the keys that are used in the 
 * velocity.properties file so that they can be referenced as a constant
 * within Java code.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: RuntimeConstants.java,v 1.33.4.1 2004/03/03 23:22:55 geirm Exp $
 */
public interface RuntimeConstants
{
    /*
     * ----------------------------------------------------------------------
     * These are public constants that are used as handles for the
     * properties that can be specified in your typical
     * velocity.properties file.
     * ----------------------------------------------------------------------
     */
    /*
     * ----------------------------------------------------------------------
     * L O G G I N G  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /** 
     * Location of the velocity log file.
     */
    public static final String RUNTIME_LOG = 
        ""runtime.log"";
    /**
     *  externally provided logger
     */
    public static final String RUNTIME_LOG_LOGSYSTEM = 
        ""runtime.log.logsystem"";
    /**
     *  class of log system to use
     */
    public static final String RUNTIME_LOG_LOGSYSTEM_CLASS = 
        ""runtime.log.logsystem.class"";
    /** 
     * Stack trace output for error messages.
     */
    public static final String RUNTIME_LOG_ERROR_STACKTRACE = 
        ""runtime.log.error.stacktrace"";
    /** 
     * Stack trace output for warning messages.
     */
    public static final String RUNTIME_LOG_WARN_STACKTRACE = 
        ""runtime.log.warn.stacktrace"";
    /** 
     * Stack trace output for info messages.
     */
    public static final String RUNTIME_LOG_INFO_STACKTRACE = 
        ""runtime.log.info.stacktrace"";
    /**
     * Logging of invalid references.
     */
    public static final String RUNTIME_LOG_REFERENCE_LOG_INVALID  = 
        ""runtime.log.invalid.references"";
    /**
     *  Log message prefixes
     */
    public final static String DEBUG_PREFIX = "" [debug] "";
    public final static String INFO_PREFIX  = ""  [info] "";
    public final static String WARN_PREFIX  = ""  [warn] "";
    public final static String ERROR_PREFIX = "" [error] "";
    public final static String UNKNOWN_PREFIX = "" [unknown] "";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_PATTERN = 
        ""runtime.log.logsystem.log4j.pattern"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_FILE_SIZE = 
        ""runtime.log.logsystem.log4j.file.size"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_FILE_BACKUPS = 
        ""runtime.log.logsystem.log4j.file.backups"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_SYSLOGD_HOST = 
        ""runtime.log.logsystem.log4j.syslogd.host"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_SYSLOGD_FACILITY = 
        ""runtime.log.logsystem.log4j.syslogd.facility"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_REMOTE_HOST = 
        ""runtime.log.logsystem.log4j.remote.host"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_REMOTE_PORT = 
        ""runtime.log.logsystem.log4j.remote.port"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_EMAIL_SERVER = 
        ""runtime.log.logsystem.log4j.email.server"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_EMAIL_FROM = 
        ""runtime.log.logsystem.log4j.email.from"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_EMAIL_TO = 
        ""runtime.log.logsystem.log4j.email.to"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_EMAIL_SUBJECT = 
        ""runtime.log.logsystem.log4j.email.subject"";
    /**
     * Log4J configuration
     */
    public final static String LOGSYSTEM_LOG4J_EMAIL_BUFFER_SIZE = 
        ""runtime.log.logsystem.log4j.email.buffer.size"";
    /*
     * ----------------------------------------------------------------------
     * D I R E C T I V E  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     * Directive properties are of the form:
     * 
     * directive.<directive-name>.<property>
     * ----------------------------------------------------------------------
     */
    /** 
     * Initial counter value in #foreach directives.
     */
    public static final String COUNTER_NAME = 
        ""directive.foreach.counter.name"";
    /** 
     * Initial counter value in #foreach directives.
     */
    public static final String COUNTER_INITIAL_VALUE = 
        ""directive.foreach.counter.initial.value"";
    /**
     * Starting tag for error messages triggered by passing
     * a parameter not allowed in the #include directive. Only
     * string literals, and references are allowed.
     */
    public static String ERRORMSG_START = 
        ""directive.include.output.errormsg.start"";
    /**
     * Ending tag for error messages triggered by passing
     * a parameter not allowed in the #include directive. Only
     * string literals, and references are allowed.
     */
    public static String ERRORMSG_END  = 
        ""directive.include.output.errormsg.end"";
    /**
     * Maximum recursion depth allowed for the #parse directive.
     */
    public static String PARSE_DIRECTIVE_MAXDEPTH 
        = ""directive.parse.max.depth"";
    /*
     * ----------------------------------------------------------------------
     *  R E S O U R C E   M A N A G E R   C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
     public static String RESOURCE_MANAGER_CLASS = ""resource.manager.class"";
     public static String RESOURCE_MANAGER_CACHE_CLASS =
                ""resource.manager.cache.class"";
    /*
     * ----------------------------------------------------------------------
     * R E S O U R C E  L O A D E R  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /**
     *  controls if the finding of a resource is logged
     */
    public static final String RESOURCE_MANAGER_LOGWHENFOUND = 
        ""resource.manager.logwhenfound"";
    /**
     * Key used to retrieve the names of the resource loaders
     * to be used. In a properties file they may appear as
     * the following:
     *
     * resource.loader = file,classpath
     */
    public static final String RESOURCE_LOADER = ""resource.loader"";
    /**
     * The public handle for setting a path in
     * the FileResourceLoader.
     */
    public static final String FILE_RESOURCE_LOADER_PATH =
        ""file.resource.loader.path"";
    /**
     * The public handle for turning the caching on in the
     * FileResourceLoader.
     */
    public static final String FILE_RESOURCE_LOADER_CACHE = 
        ""file.resource.loader.cache"";
    /*
     * ----------------------------------------------------------------------
     * V E L O C I M A C R O  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /** 
     * Name of local Velocimacro library template.
     */
    public static final String VM_LIBRARY  = ""velocimacro.library"";
    /** 
     * switch for autoloading library-sourced VMs (for development) 
     */
    public final static String VM_LIBRARY_AUTORELOAD = 
        ""velocimacro.library.autoreload"";
    /** 
     * boolean (true/false) default true : allow 
     * inline (in-template) macro definitions 
     */
    public static final String VM_PERM_ALLOW_INLINE  = 
        ""velocimacro.permissions.allow.inline"";
    /**
     * boolean (true/false) default false : allow inline 
     * (in-template) macro definitions to replace existing 
     */
    public final static String VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL  = 
        ""velocimacro.permissions.allow.inline.to.replace.global"";
    /** 
     * Switch for forcing inline macros to be local : default false.
     */
    public final static String VM_PERM_INLINE_LOCAL = 
        ""velocimacro.permissions.allow.inline.local.scope"";
    /** 
     * Switch for VM blather : default true.
     */
    public final static String VM_MESSAGES_ON = ""velocimacro.messages.on"";
   /** 
    * switch for local context in VM : default false 
    */
    public final static String VM_CONTEXT_LOCALSCOPE = 
        ""velocimacro.context.localscope"";
    /*
     * ----------------------------------------------------------------------
     * G E N E R A L  R U N T I M E  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /**
     *  Switch for the interpolation facility for string literals
     */
    public static String INTERPOLATE_STRINGLITERALS = 
        ""runtime.interpolate.string.literals"";
    /** 
     * The character encoding for the templates.  Used by the parser in 
     * processing the input streams.
     */
    public static final String INPUT_ENCODING = ""input.encoding"";
    /**
     * Encoding for the output stream.  Currently used by Anakia and
     * VelocityServlet
     */
    public static final String OUTPUT_ENCODING = ""output.encoding"";
    public static final String ENCODING_DEFAULT = ""ISO-8859-1"";
    /*
     * ----------------------------------------------------------------------
     * These constants are used internally by the Velocity runtime i.e.
     * the constansts listed below are strictly used in the Runtime
     * class itself.
     * ----------------------------------------------------------------------
     */
    /** 
     * Default Runtime properties.
     */
    final static String DEFAULT_RUNTIME_PROPERTIES = 
        ""org/apache/velocity/runtime/defaults/velocity.properties"";
    /** 
     * Default Runtime properties 
     */
    final static String DEFAULT_RUNTIME_DIRECTIVES = 
        ""org/apache/velocity/runtime/defaults/directive.properties"";
    /**
     * The default number of parser instances to create.  Configurable
     * via the parameter named by the {@link #PARSER_POOL_SIZE}
     * constant.
     */
    final static int NUMBER_OF_PARSERS = 20;
    /**
     * @see #NUMBER_OF_PARSERS
     */
    final static String PARSER_POOL_SIZE = ""parser.pool.size"";
    /**
     *  key name for uberspector
     */
    final static String UBERSPECT_CLASSNAME = ""runtime.introspector.uberspect"";
}
"
org.apache.velocity.runtime.RuntimeInstance,"package org.apache.velocity.runtime;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.util.Map;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Enumeration;
import java.util.HashMap;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.log.LogManager;
import org.apache.velocity.runtime.log.LogSystem;
import org.apache.velocity.runtime.log.PrimordialLogSystem;
import org.apache.velocity.runtime.log.NullLogSystem;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.VelocimacroFactory;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.runtime.resource.ResourceManager;
import org.apache.velocity.util.SimplePool;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.util.introspection.Uberspect;
import org.apache.velocity.util.introspection.UberspectLoggable;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * This is the Runtime system for Velocity. It is the
 * single access point for all functionality in Velocity.
 * It adheres to the mediator pattern and is the only
 * structure that developers need to be familiar with
 * in order to get Velocity to perform.
 *
 * The Runtime will also cooperate with external
 * systems like Turbine. Runtime properties can
 * set and then the Runtime is initialized.
 *
 * Turbine, for example, knows where the templates
 * are to be loaded from, and where the Velocity
 * log file should be placed.
 *
 * So in the case of Velocity cooperating with Turbine
 * the code might look something like the following:
 *
 * <blockquote><code><pre>
 * ri.setProperty(Runtime.FILE_RESOURCE_LOADER_PATH, templatePath);
 * ri.setProperty(Runtime.RUNTIME_LOG, pathToVelocityLog);
 * ri.init();
 * </pre></code></blockquote>
 *
 * <pre>
 * -----------------------------------------------------------------------
 * N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
 * -----------------------------------------------------------------------
 * init()
 * 
 * If init() is called by itself the RuntimeInstance will initialize
 * with a set of default values.
 * -----------------------------------------------------------------------
 * init(String/Properties)
 *
 * In this case the default velocity properties are layed down
 * first to provide a solid base, then any properties provided
 * in the given properties object will override the corresponding
 * default property.
 * -----------------------------------------------------------------------
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jlb@houseofdistraction.com"">Jeff Bowden</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 * @version $Id: RuntimeInstance.java,v 1.19.4.1 2004/03/03 23:22:55 geirm Exp $
 */
public class RuntimeInstance implements RuntimeConstants, RuntimeServices
{    
    /**
     *  VelocimacroFactory object to manage VMs
     */
    private  VelocimacroFactory vmFactory = null;
    /** 
     *  The Runtime logger.  We start with an instance of
     *  a 'primordial logger', which just collects log messages
     *  then, when the log system is initialized, we dump
     *  all messages out of the primordial one into the real one.
     */
    private  LogSystem logSystem = new PrimordialLogSystem();
    /** 
     * The Runtime parser pool 
     */
    private  SimplePool parserPool;
    /** 
     * Indicate whether the Runtime has been fully initialized.
     */
    private  boolean initialized;
    /**
     * These are the properties that are laid down over top
     * of the default properties when requested.
     */
    private  ExtendedProperties overridingProperties = null;
    /**
     * This is a hashtable of initialized directives.
     * The directives that populate this hashtable are
     * taken from the RUNTIME_DEFAULT_DIRECTIVES
     * property file. This hashtable is passed
     * to each parser that is created.
     */
    private Hashtable runtimeDirectives;
    /**
     * Object that houses the configuration options for
     * the velocity runtime. The ExtendedProperties object allows
     * the convenient retrieval of a subset of properties.
     * For example all the properties for a resource loader
     * can be retrieved from the main ExtendedProperties object
     * using something like the following:
     *
     * ExtendedProperties loaderConfiguration = 
     *         configuration.subset(loaderID);
     *
     * And a configuration is a lot more convenient to deal
     * with then conventional properties objects, or Maps.
     */
    private  ExtendedProperties configuration = new ExtendedProperties();
    private ResourceManager resourceManager = null;
    /*
     *  Each runtime instance has it's own introspector
     *  to ensure that each instance is completely separate.
     */
    private Introspector introspector = null;
    /*
     *  Opaque reference to something specificed by the 
     *  application for use in application supplied/specified
     *  pluggable components
     */
    private Map applicationAttributes = null;
    private Uberspect uberSpect;
    public RuntimeInstance()
    {
        /*
         *  create a VM factory, resource manager
         *  and introspector
         */
        vmFactory = new VelocimacroFactory( this );
        /*
         *  make a new introspector and initialize it
         */
        introspector = new Introspector( this );
        /*
         * and a store for the application attributes
         */
        applicationAttributes = new HashMap();
    }
    /*
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     *
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     */
    public synchronized void init()
        throws Exception
    {
        if (initialized == false)
        {
            info(""************************************************************** "");
            info(""Starting Jakarta Velocity v1.4"");
            info(""RuntimeInstance initializing."");
            initializeProperties();
            initializeLogger();
            initializeResourceManager();
            initializeDirectives();
            initializeParserPool();
            initializeIntrospection();
            /*
             *  initialize the VM Factory.  It will use the properties 
             * accessable from Runtime, so keep this here at the end.
             */
            vmFactory.initVelocimacro();
            info(""Velocity successfully started."");
            initialized = true;
        }
    }
    /**
     *  Gets the classname for the Uberspect introspection package and
     *  instantiates an instance.
     */
    private void initializeIntrospection()
        throws Exception
    {
        String rm = getString(RuntimeConstants.UBERSPECT_CLASSNAME);
        if (rm != null && rm.length() > 0)
        {
            Object o = null;
            try
            {
               o = Class.forName(rm).newInstance();
            }
            catch (ClassNotFoundException cnfe)
            {
                String err = ""The specified class for Uberspect (""
                    + rm
                    + "") does not exist (or is not accessible to the current classlaoder."";
                 error(err);
                 throw new Exception(err);
            }
            if (!(o instanceof Uberspect))
            {
                String err = ""The specified class for Uberspect (""
                    + rm
                    + "") does not implement org.apache.velocity.util.introspector.Uberspect.""
                    + "" Velocity not initialized correctly."";
                error(err);
                throw new Exception(err);
            }
            uberSpect = (Uberspect) o;
            if (uberSpect instanceof UberspectLoggable)
            {
                ((UberspectLoggable) uberSpect).setRuntimeLogger(this);
            }
            uberSpect.init();
         }
         else
         {
            /*
             *  someone screwed up.  Lets not fool around...
             */
            String err = ""It appears that no class was specified as the""
            + "" Uberspect.  Please ensure that all configuration""
            + "" information is correct."";
            error(err);
            throw new Exception(err);
        }
    }
    /**
     * Initializes the Velocity Runtime with properties file.
     * The properties file may be in the file system proper,
     * or the properties file may be in the classpath.
     */
    private void setDefaultProperties()
    {
        try
        {
            InputStream inputStream = getClass()
                .getResourceAsStream('/' + DEFAULT_RUNTIME_PROPERTIES);
            configuration.load( inputStream );
            info (""Default Properties File: "" + 
                new File(DEFAULT_RUNTIME_PROPERTIES).getPath());
        }
        catch (IOException ioe)
        {
            System.err.println(""Cannot get Velocity Runtime default properties!"");
        }
    }
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param String property key
     * @param String property value
     */
    public void setProperty(String key, Object value)
    {
        if (overridingProperties == null)
        {
            overridingProperties = new ExtendedProperties();
        }            
        overridingProperties.setProperty( key, value );
    }        
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param ExtendedProperties configuration
     */
    public void setConfiguration( ExtendedProperties configuration)
    {
        if (overridingProperties == null)
        {
            overridingProperties = configuration;
        }
        else
        {
            // Avoid possible ConcurrentModificationException
            if (overridingProperties != configuration)
            {
                overridingProperties.combine(configuration);
            }
        }
    }
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param String key
     * @param String value
     */
    public void addProperty(String key, Object value)
    {
        if (overridingProperties == null)
        {
            overridingProperties = new ExtendedProperties();
        }            
        overridingProperties.addProperty( key, value );
    }
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param String key of property to clear
     */
    public void clearProperty(String key)
    {
        if (overridingProperties != null)
        {
            overridingProperties.clearProperty(key);
        }            
    }
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     */
    public Object getProperty( String key )
    {
        return configuration.getProperty( key );
    }
    /**
     * Initialize Velocity properties, if the default
     * properties have not been laid down first then
     * do so. Then proceed to process any overriding
     * properties. Laying down the default properties
     * gives a much greater chance of having a
     * working system.
     */
    private void initializeProperties()
    {
        /* 
         * Always lay down the default properties first as
         * to provide a solid base.
         */
        if (configuration.isInitialized() == false)
        {
            setDefaultProperties();
        }            
        if( overridingProperties != null)
        {        
            configuration.combine(overridingProperties);
        }
    }
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param Properties
     */
    public void init(Properties p) throws Exception
    {
        overridingProperties = ExtendedProperties.convertProperties(p);
        init();
    }
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param Properties
     */
    public void init(String configurationFile)
        throws Exception
    {
        overridingProperties = new ExtendedProperties(configurationFile);
        init();
    }
    private void initializeResourceManager()
        throws Exception
    {
        /*
         * Which resource manager?
         */
        String rm = getString( RuntimeConstants.RESOURCE_MANAGER_CLASS );
        if ( rm != null && rm.length() > 0 )
        {
            /*
             *  if something was specified, then make one.
             *  if that isn't a ResourceManager, consider
             *  this a huge error and throw
             */
            Object o = null;
            try
            {
               o = Class.forName( rm ).newInstance();
            }
            catch (ClassNotFoundException cnfe )
            {
                String err = ""The specified class for Resourcemanager (""
                    + rm    
                    + "") does not exist (or is not accessible to the current classlaoder."";
                 error( err );
                 throw new Exception( err );
            }
            if (!(o instanceof ResourceManager) )
            {
                String err = ""The specified class for ResourceManager (""
                    + rm 
                    + "") does not implement org.apache.runtime.resource.ResourceManager.""
                    + "" Velocity not initialized correctly."";
                error( err);
                throw new Exception(err);
            }
            resourceManager = (ResourceManager) o;
            resourceManager.initialize( this );        
         }
         else
         {
            /*
             *  someone screwed up.  Lets not fool around...
             */
            String err = ""It appears that no class was specified as the""
            + "" ResourceManager.  Please ensure that all configuration""
            + "" information is correct."";
            error( err);
            throw new Exception( err );
        }                            
    }
    /**
     * Initialize the Velocity logging system.
     *
     * @throws Exception
     */
    private void initializeLogger() throws Exception
    { 
        /*
         * Initialize the logger. We will eventually move all
         * logging into the logging manager.
         */
        if (logSystem instanceof PrimordialLogSystem )
        {
            PrimordialLogSystem pls = (PrimordialLogSystem) logSystem;
            logSystem = LogManager.createLogSystem( this );
            /*
             * in the event of failure, lets do something to let it 
             * limp along.
             */
             if (logSystem == null)
             {
                logSystem = new NullLogSystem();
             }
             else
             {
                pls.dumpLogMessages( logSystem );
             }
        }
   }
    /**
     * This methods initializes all the directives
     * that are used by the Velocity Runtime. The
     * directives to be initialized are listed in
     * the RUNTIME_DEFAULT_DIRECTIVES properties
     * file.
     *
     * @throws Exception
     */
    private void initializeDirectives() throws Exception
    {
        /*
         * Initialize the runtime directive table.
         * This will be used for creating parsers.
         */
        runtimeDirectives = new Hashtable();
        Properties directiveProperties = new Properties();
        /*
         * Grab the properties file with the list of directives
         * that we should initialize.
         */
        InputStream inputStream =
            getClass().getResourceAsStream('/' + DEFAULT_RUNTIME_DIRECTIVES);
        if (inputStream == null)
            throw new Exception(""Error loading directive.properties! "" +
                                ""Something is very wrong if these properties "" +
                                ""aren't being located. Either your Velocity "" +
                                ""distribution is incomplete or your Velocity "" +
                                ""jar file is corrupted!"");
        directiveProperties.load(inputStream);
        /*
         * Grab all the values of the properties. These
         * are all class names for example:
         *
         * org.apache.velocity.runtime.directive.Foreach
         */
        Enumeration directiveClasses = directiveProperties.elements();
        while (directiveClasses.hasMoreElements())
        {
            String directiveClass = (String) directiveClasses.nextElement();
            loadDirective( directiveClass, ""System"" );
        }
        /*
         *  now the user's directives
         */
        String[] userdirective = configuration.getStringArray(""userdirective"");
        for( int i = 0; i < userdirective.length; i++)
        {
            loadDirective( userdirective[i], ""User"");
        }
    }
    /**
     *  instantiates and loads the directive with some basic checks
     * 
     *  @param directiveClass classname of directive to load 
     */
    private void loadDirective( String directiveClass, String caption )
    {    
        try
        {
            Object o = Class.forName( directiveClass ).newInstance();
            if ( o instanceof Directive )
            {
                Directive directive = (Directive) o;
                runtimeDirectives.put(directive.getName(), directive);
                info(""Loaded "" + caption + "" Directive: "" 
                    + directiveClass);
            }
            else
            {
                error( caption + "" Directive "" + directiveClass 
                    + "" is not org.apache.velocity.runtime.directive.Directive.""
                    + "" Ignoring. "" );
            }
        }
        catch (Exception e)
        {
            error(""Exception Loading "" + caption + "" Directive: "" 
                + directiveClass + "" : "" + e);    
        }
    }
    /**
     * Initializes the Velocity parser pool.
     * This still needs to be implemented.
     */
    private void initializeParserPool()
    {
        int numParsers = getInt( PARSER_POOL_SIZE, NUMBER_OF_PARSERS);
        parserPool = new SimplePool( numParsers);
        for (int i=0; i < numParsers ;i++ )
        {
            parserPool.put (createNewParser());
        }
        info (""Created: "" + numParsers + "" parsers."");
    }
    /**
     * Returns a JavaCC generated Parser.
     *
     * @return Parser javacc generated parser
     */
    public Parser createNewParser()
    {
        Parser parser = new Parser( this );
        parser.setDirectives(runtimeDirectives);
        return parser;
    }
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd 
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the 
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     */
    public SimpleNode parse( Reader reader, String templateName )
        throws ParseException
    {
        /*
         *  do it and dump the VM namespace for this template
         */
        return parse( reader, templateName, true );
    }
    /**
     *  Parse the input and return the root of the AST node structure.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template
     */
    public SimpleNode parse( Reader reader, String templateName, boolean dumpNamespace )
        throws ParseException
    {
        SimpleNode ast = null;
        Parser parser = (Parser) parserPool.get();
        boolean madeNew = false;
        if (parser == null)
        {
            /*
             *  if we couldn't get a parser from the pool
             *  make one and log it.
             */
            error(""Runtime : ran out of parsers. Creating new.  ""
                  + "" Please increment the parser.pool.size property.""
                  + "" The current value is too small."");
            parser = createNewParser();
            if( parser != null )
            {
                madeNew = true;
            }
        }
        /*
         *  now, if we have a parser
         */
        if (parser != null)
        {
            try
            {
                /*
                 *  dump namespace if we are told to.  Generally, you want to 
                 *  do this - you don't in special circumstances, such as 
                 *  when a VM is getting init()-ed & parsed
                 */
                if ( dumpNamespace )
                {
                    dumpVMNamespace( templateName );
                }
                ast = parser.parse( reader, templateName );
            }
            finally
            {
                /*
                 *  if this came from the pool, then put back
                 */
                if (!madeNew)
                {
                    parserPool.put(parser);
                }
            }
        }
        else
        {
            error(""Runtime : ran out of parsers and unable to create more."");
        }
        return ast;
    }
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the 
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return getTemplate( name, getString( INPUT_ENCODING, ENCODING_DEFAULT) );
    }
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return (Template) resourceManager.getResource(name, ResourceManager.RESOURCE_TEMPLATE, encoding);
    }
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        /*
         *  the encoding is irrelvant as we don't do any converstion
         *  the bytestream should be dumped to the output stream
         */
        return getContent( name,  getString( INPUT_ENCODING, ENCODING_DEFAULT));
    }
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public ContentResource getContent( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return (ContentResource) resourceManager.getResource(name,ResourceManager.RESOURCE_CONTENT, encoding );
    }
    /**
     *  Determines is a template exists, and returns name of the loader that 
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public String getLoaderNameForResource( String resourceName )
    {
        return resourceManager.getLoaderNameForResource( resourceName );
    }
    /**
     * Added this to check and make sure that the configuration
     * is initialized before trying to get properties from it.
     * This occurs when there are errors during initialization
     * and the default properties have yet to be layed down.
     */
    private boolean showStackTrace()
    {
        if (configuration.isInitialized())
        {
            return getBoolean(RUNTIME_LOG_WARN_STACKTRACE, false);
        }            
        else
        {
            return false;
        }            
    }
    /**
     * Handle logging.
     *
     * @param String message to log
     */
    private void log(int level, Object message)
    {
        String out;
        /*
         *  now,  see if the logging stacktrace is on
         *  and modify the message to suit
         */
        if ( showStackTrace() &&
            (message instanceof Throwable || message instanceof Exception) )
        {
            out = StringUtils.stackTrace((Throwable)message);
        }
        else
        {
            out = message.toString();    
        }            
        /*
         *  just log it, as we are guaranteed now to have some
         *  kind of logger - save the if()
         */
        logSystem.logVelocityMessage( level, out);
    }
    /**
     * Log a warning message.
     *
     * @param Object message to log
     */
    public void warn(Object message)
    {
        log(LogSystem.WARN_ID, message);
    }
    /** 
     * Log an info message.
     *
     * @param Object message to log
     */
    public void info(Object message)
    {
        log(LogSystem.INFO_ID, message);
    }
    /**
     * Log an error message.
     *
     * @param Object message to log
     */
    public void error(Object message)
    {
        log(LogSystem.ERROR_ID, message);
    }
    /**
     * Log a debug message.
     *
     * @param Object message to log
     */
    public void debug(Object message)
    {
        log(LogSystem.DEBUG_ID, message);
    }
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     * 
     * @param String key property key
     * @param String defaultValue  default value to return if key not 
     *               found in resource manager.
     * @return String  value of key or default 
     */
    public String getString( String key, String defaultValue)
    {
        return configuration.getString(key, defaultValue);
    }
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param String vmName  Name of velocimacro requested
     * @return String VelocimacroProxy 
     */
    public Directive getVelocimacro( String vmName, String templateName  )
    {
        return vmFactory.getVelocimacro( vmName, templateName );
    }
   /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param String name  Name of velocimacro 
     * @param String macro  String form of macro body
     * @param String argArray  Array of strings, containing the 
     *                         #macro() arguments.  the 0th is the name.
     * @return boolean  True if added, false if rejected for some 
     *                  reason (either parameters or permission settings) 
     */
    public boolean addVelocimacro( String name, 
                                          String macro, 
                                          String argArray[], 
                                          String sourceTemplate )
    {    
        return vmFactory.addVelocimacro(  name, macro,  argArray,  sourceTemplate );
    }
    /**
     *  Checks to see if a VM exists
     *
     * @param name  Name of velocimacro
     * @return boolean  True if VM by that name exists, false if not
     */
    public boolean isVelocimacro( String vmName, String templateName )
    {
        return vmFactory.isVelocimacro( vmName, templateName );
    }
    /**
     *  tells the vmFactory to dump the specified namespace.  This is to support
     *  clearing the VM list when in inline-VM-local-scope mode
     */
    public boolean dumpVMNamespace( String namespace )
    {
        return vmFactory.dumpVMNamespace( namespace );
    }
    /* --------------------------------------------------------------------
     * R U N T I M E  A C C E S S O R  M E T H O D S
     * --------------------------------------------------------------------
     * These are the getXXX() methods that are a simple wrapper
     * around the configuration object. This is an attempt
     * to make a the Velocity Runtime the single access point
     * for all things Velocity, and allow the Runtime to
     * adhere as closely as possible the the Mediator pattern
     * which is the ultimate goal.
     * --------------------------------------------------------------------
     */
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     */
    public String getString(String key)
    {
        return configuration.getString( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param String key property key
     * @return int value
     */
    public int getInt( String key )
    {
        return configuration.getInt( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param int default value
     * @return int  value
     */
    public int getInt( String key, int defaultValue )
    {
        return configuration.getInt( key, defaultValue );
    }
    /**
     * Boolean property accessor method to hide the configuration implementation.
     * 
     * @param String key  property key
     * @param boolean default default value if property not found
     * @return boolean  value of key or default value
     */
    public boolean getBoolean( String key, boolean def )
    {
        return configuration.getBoolean( key, def );
    }
    /**
     * Return the velocity runtime configuration object.
     *
     * @return ExtendedProperties configuration object which houses
     *                       the velocity runtime properties.
     */
    public ExtendedProperties getConfiguration()
    {
        return configuration;
    }        
    /**
     *  Return the Introspector for this instance
     */
    public Introspector getIntrospector()
    {
        return introspector;
    }
    public Object getApplicationAttribute( Object key)
    {
        return applicationAttributes.get( key );
    }
    public Object setApplicationAttribute( Object key, Object o )
    {
        return applicationAttributes.put( key, o );
    }
    public Uberspect getUberspect()
    {
        return uberSpect;
    }
}
"
org.apache.velocity.runtime.RuntimeLogger,"package org.apache.velocity.runtime;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface for internal runtime logging services that are needed by the
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magusson Jr.</a>
 * @version $Id: RuntimeLogger.java,v 1.1.4.1 2004/03/03 23:22:55 geirm Exp $
 */
public interface RuntimeLogger
{
    /**
     * Log a warning message.
     *
     * @param Object message to log
     */
    public void warn(Object message);
    /**
     * Log an info message.
     *
     * @param Object message to log
     */
    public  void info(Object message);
    /**
     * Log an error message.
     *
     * @param Object message to log
     */
    public void error(Object message);
    /**
     * Log a debug message.
     *
     * @param Object message to log
     */
    public void debug(Object message);
}
"
org.apache.velocity.runtime.RuntimeServices,"package org.apache.velocity.runtime;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Reader;
import java.util.Properties;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.util.introspection.Uberspect;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * Interface for internal runtime services that are needed by the 
 * various components w/in Velocity.  This was taken from the old
 * Runtime singleton, and anything not necessary was removed.
 *
 *  Currently implemented by RuntimeInstance.
 * 
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 * @version $Id: RuntimeServices.java,v 1.7.4.1 2004/03/03 23:22:55 geirm Exp $
 */
public interface RuntimeServices extends RuntimeLogger
{
   /*
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     * 
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     */
    public void init() throws Exception;
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param String property key
     * @param String property value
     */
    public  void setProperty(String key, Object value);
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param ExtendedProperties configuration
     */
    public void setConfiguration( ExtendedProperties configuration);
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param String key
     * @param String value
     */
    public void addProperty(String key, Object value);
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param String key of property to clear
     */
    public void clearProperty(String key);
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     */
    public  Object getProperty( String key );
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param Properties
     */
    public void init(Properties p) throws Exception;
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param Properties
     */
    public void init(String configurationFile) throws Exception;
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd 
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the 
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     */
    public  SimpleNode parse( Reader reader, String templateName )
        throws ParseException;
    /**
     *  Parse the input and return the root of the AST node structure.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template
     */
    public SimpleNode parse( Reader reader, String templateName, boolean dumpNamespace )
        throws ParseException;
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the 
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public ContentResource getContent( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     *  Determines is a template exists, and returns name of the loader that 
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public String getLoaderNameForResource( String resourceName );
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     * 
     * @param String key property key
     * @param String defaultValue  default value to return if key not 
     *               found in resource manager.
     * @return String  value of key or default 
     */
    public String getString( String key, String defaultValue);
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param String vmName  Name of velocimacro requested
     * @return String VelocimacroProxy 
     */
    public Directive getVelocimacro( String vmName, String templateName  );
   /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param String name  Name of velocimacro 
     * @param String macro  String form of macro body
     * @param String argArray  Array of strings, containing the 
     *                         #macro() arguments.  the 0th is the name.
     * @return boolean  True if added, false if rejected for some 
     *                  reason (either parameters or permission settings) 
     */
    public boolean addVelocimacro( String name, 
                                          String macro, 
                                          String argArray[], 
                                          String sourceTemplate );
    /**
     *  Checks to see if a VM exists
     *
     * @param name  Name of velocimacro
     * @return boolean  True if VM by that name exists, false if not
     */
    public boolean isVelocimacro( String vmName, String templateName );
    /**
     *  tells the vmFactory to dump the specified namespace.  This is to support
     *  clearing the VM list when in inline-VM-local-scope mode
     */
    public boolean dumpVMNamespace( String namespace );
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     */
    public String getString(String key);
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param String key property key
     * @return int value
     */
    public int getInt( String key );
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param int default value
     * @return int  value
     */
    public int getInt( String key, int defaultValue );
    /**
     * Boolean property accessor method to hide the configuration implementation.
     * 
     * @param String key  property key
     * @param boolean default default value if property not found
     * @return boolean  value of key or default value
     */
    public boolean getBoolean( String key, boolean def );
    /**
     * Return the velocity runtime configuration object.
     *
     * @return ExtendedProperties configuration object which houses
     *                       the velocity runtime properties.
     */
    public ExtendedProperties getConfiguration();
    /**
     * Return the specified applcation attribute.
     *
     * @param key The name of the attribute to retrieve.
     */
    public Object getApplicationAttribute( Object key );
    /**
     * Returns the configured class introspection/reflection
     * implemenation.
     */
    public Uberspect getUberspect();
    /**
     * Returns the configured method introspection/reflection
     * implemenation.
     */
    public Introspector getIntrospector();
}
"
org.apache.velocity.runtime.RuntimeSingleton,"package org.apache.velocity.runtime;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Reader;
import java.util.Properties;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.util.introspection.Uberspect;
/**
 * This is the Runtime system for Velocity. It is the
 * single access point for all functionality in Velocity.
 * It adheres to the mediator pattern and is the only
 * structure that developers need to be familiar with
 * in order to get Velocity to perform.
 *
 * The Runtime will also cooperate with external
 * systems like Turbine. Runtime properties can
 * set and then the Runtime is initialized.
 *
 * Turbine for example knows where the templates
 * are to be loaded from, and where the velocity
 * log file should be placed.
 *
 * So in the case of Velocity cooperating with Turbine
 * the code might look something like the following:
 *
 * <pre>
 * RuntimeSingleton.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, templatePath);
 * RuntimeSingleton.setProperty(RuntimeConstants.RUNTIME_LOG, pathToVelocityLog);
 * RuntimeSingleton.init();
 * </pre>
 *
 * <pre>
 * -----------------------------------------------------------------------
 * N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
 * -----------------------------------------------------------------------
 * RuntimeSingleton.init()
 * 
 * If Runtime.init() is called by itself the Runtime will
 * initialize with a set of default values.
 * -----------------------------------------------------------------------
 * RuntimeSingleton.init(String/Properties)
 *
 * In this case the default velocity properties are layed down
 * first to provide a solid base, then any properties provided
 * in the given properties object will override the corresponding
 * default property.
 * -----------------------------------------------------------------------
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jlb@houseofdistraction.com"">Jeff Bowden</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 *
 * @see org.apache.velocity.runtime.RuntimeInstance
 *
 * @version $Id: RuntimeSingleton.java,v 1.7.4.1 2004/03/03 23:22:55 geirm Exp $
 */
public class RuntimeSingleton implements RuntimeConstants
{
    private static RuntimeInstance ri = new RuntimeInstance();
    /**
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     * 
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     */
    public synchronized static void init()
        throws Exception
    {
        ri.init();
    }
    /**
     * @return The RuntimeInstance used by this wrapper.
     */
    public static RuntimeServices getRuntimeServices()
    {
        return ri;
    }
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param String property key
     * @param String property value
     */
    public static void setProperty(String key, Object value)
    {
        ri.setProperty( key, value );
    }        
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param ExtendedProperties configuration
     */
    public static void setConfiguration( ExtendedProperties configuration)
    {
        ri.setConfiguration( configuration );
    }
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param String key
     * @param String value
     */
    public static void addProperty(String key, Object value)
    {
        ri.addProperty( key, value );
    }
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param String key of property to clear
     */
    public static void clearProperty(String key)
    {
        ri.clearProperty( key );
    }
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     */
    public static Object getProperty( String key )
    {
        return ri.getProperty( key );
    }
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param Properties
     */
    public static void init(Properties p) throws Exception
    {
        ri.init(p);
    }
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param Properties
     */
    public static void init(String configurationFile)
        throws Exception
    {
        ri.init( configurationFile );
    }
    /**
     * Returns a JavaCC generated Parser.
     *
     * @return Parser javacc generated parser
     */
    private static Parser createNewParser()
    {
        return ri.createNewParser();
    }
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd 
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the 
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     */
    public static SimpleNode parse( Reader reader, String templateName )
        throws ParseException
    {
        return ri.parse( reader, templateName );
    }
    /**
     *  Parse the input and return the root of the AST node structure.
     *
     * @param InputStream inputstream retrieved by a resource loader
     * @param String name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template
     */
    public static SimpleNode parse( Reader reader, String templateName, boolean dumpNamespace )
        throws ParseException
    {
        return ri.parse( reader, templateName, dumpNamespace );
    }
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the 
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name );
    }
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name, encoding );
    }
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public static ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getContent( name );
    }
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     */
    public static ContentResource getContent( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getContent( name, encoding );
    }
    /**
     *  Determines is a template exists, and returns name of the loader that 
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public static String getLoaderNameForResource( String resourceName )
    {
        return ri.getLoaderNameForResource( resourceName );
    }
    /**
     * Log a warning message.
     *
     * @param Object message to log
     */
    public static void warn(Object message)
    {
        ri.warn( message );
    }
    /** 
     * Log an info message.
     *
     * @param Object message to log
     */
    public static void info(Object message)
    {
        ri.info( message );
    }
    /**
     * Log an error message.
     *
     * @param Object message to log
     */
    public static void error(Object message)
    {
        ri.error( message );
    }
    /**
     * Log a debug message.
     *
     * @param Object message to log
     */
    public static void debug(Object message)
    {
        ri.debug( message );
    }
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     * 
     * @param String key property key
     * @param String defaultValue  default value to return if key not 
     *               found in resource manager.
     * @return String  value of key or default 
     */
    public static String getString( String key, String defaultValue)
    {
        return ri.getString( key, defaultValue );
    }
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param String vmName  Name of velocimacro requested
     * @return String VelocimacroProxy 
     */
    public static Directive getVelocimacro( String vmName, String templateName  )
    {
        return ri.getVelocimacro( vmName, templateName );
    }
   /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param String name  Name of velocimacro 
     * @param String macro  String form of macro body
     * @param String argArray  Array of strings, containing the 
     *                         #macro() arguments.  the 0th is the name.
     * @return boolean  True if added, false if rejected for some 
     *                  reason (either parameters or permission settings) 
     */
    public static boolean addVelocimacro( String name, 
                                          String macro, 
                                          String argArray[], 
                                          String sourceTemplate )
    {    
        return ri.addVelocimacro( name, macro, argArray, sourceTemplate );
    }
    /**
     *  Checks to see if a VM exists
     *
     * @param name  Name of velocimacro
     * @return boolean  True if VM by that name exists, false if not
     */
    public static boolean isVelocimacro( String vmName, String templateName )
    {
        return ri.isVelocimacro( vmName, templateName );
    }
    /**
     *  tells the vmFactory to dump the specified namespace.  This is to support
     *  clearing the VM list when in inline-VM-local-scope mode
     */
    public static boolean dumpVMNamespace( String namespace )
    {
        return ri.dumpVMNamespace( namespace );
    }
    /* --------------------------------------------------------------------
     * R U N T I M E  A C C E S S O R  M E T H O D S
     * --------------------------------------------------------------------
     * These are the getXXX() methods that are a simple wrapper
     * around the configuration object. This is an attempt
     * to make a the Velocity Runtime the single access point
     * for all things Velocity, and allow the Runtime to
     * adhere as closely as possible the the Mediator pattern
     * which is the ultimate goal.
     * --------------------------------------------------------------------
     */
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     */
    public static String getString(String key)
    {
        return ri.getString( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param String key property key
     * @return int value
     */
    public static int getInt( String key )
    {
        return ri.getInt( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param int default value
     * @return int  value
     */
    public static int getInt( String key, int defaultValue )
    {
        return ri.getInt( key, defaultValue );
    }
    /**
     * Boolean property accessor method to hide the configuration implementation.
     * 
     * @param String key  property key
     * @param boolean default default value if property not found
     * @return boolean  value of key or default value
     */
    public static boolean getBoolean( String key, boolean def )
    {
        return ri.getBoolean( key, def );
    }
    /**
     * Return the velocity runtime configuration object.
     *
     * @return ExtendedProperties configuration object which houses
     *                       the velocity runtime properties.
     */
    public static ExtendedProperties getConfiguration()
    {
        return ri.getConfiguration();
    }        
    /**
     *  Return the Introspector for this RuntimeInstance
     *
     *  @return Introspector object for this runtime instance
     */
    public static Introspector getIntrospector()
    {
        return ri.getIntrospector();
    }
    /**
     * @see org.apache.velocity.runtime.RuntimeServices#getApplicationAttribute(Object)
     */
    public static Object getApplicationAttribute(Object key)
    {
        return ri.getApplicationAttribute(key);
    }
    /**
     * @see org.apache.velocity.runtime.RuntimeServices#getUberspect()
     */
    public static Uberspect getUberspect()
    {
        return ri.getUberspect();
    }
    /**
     * @deprecated Use getRuntimeServices() instead.
     */
    public static RuntimeInstance getRuntimeInstance()
    {
        return ri;
    }
}
"
org.apache.velocity.runtime.VelocimacroFactory,"package org.apache.velocity.runtime;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.Template;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.directive.VelocimacroProxy;
import java.util.Vector;
import java.util.Map;
import java.util.HashMap;
/**
 *  VelocimacroFactory.java
 *
 *   manages the set of VMs in a running Velocity engine.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelocimacroFactory.java,v 1.17.4.1 2004/03/03 23:22:55 geirm Exp $ 
 */
public class VelocimacroFactory
{
    /**
     *  runtime services for this instance
     */
    private RuntimeServices rsvc = null;
    /**
     *  VMManager : deal with namespace management
     *  and actually keeps all the VM definitions
     */
    private VelocimacroManager vmManager = null;
    /**
     *  determines if replacement of global VMs are allowed
     *  controlled by  VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL
     */
    private boolean replaceAllowed = false;
    /**
     *  controls if new VMs can be added.  Set by
     *  VM_PERM_ALLOW_INLINE  Note the assumption that only
     *  through inline defs can this happen.
     *  additions through autoloaded VMs is allowed
     */
    private boolean addNewAllowed = true;
    /**
     *  sets if template-local namespace in used
     */
    private boolean templateLocal = false;
    /**
     *  controls log output
     */
    private boolean blather = false;
    /**
     *  determines if the libraries are auto-loaded
     *  when they change
     */
    private boolean autoReloadLibrary = false;
    /**
     *  vector of the library names
     */
    private Vector macroLibVec = null;
    /**
     *  map of the library Template objects
     *  used for reload determination
     */
    private Map libModMap;
    /**
     *  CTOR : requires a runtime services from now
     *  on
     */
    public VelocimacroFactory( RuntimeServices rs )
    {
        this.rsvc = rs;
        /*
         *  we always access in a synchronized(), so we 
         *  can use an unsynchronized hashmap
         */
        libModMap = new HashMap();
        vmManager = new VelocimacroManager( rsvc );
    }
    /**
     *  initialize the factory - setup all permissions
     *  load all global libraries.
     */
    public void initVelocimacro()
    {
        /*
         *  maybe I'm just paranoid...
         */
        synchronized( this )
        {
            /*
             *   allow replacements while we add the libraries, if exist
             */
            setReplacementPermission( true );
            setBlather( true );
            logVMMessageInfo(""Velocimacro : initialization starting."");
            /*
             *  add all library macros to the global namespace
             */
            vmManager.setNamespaceUsage( false );
            /*
             *  now, if there is a global or local libraries specified, use them.
             *  All we have to do is get the template. The template will be parsed;
             *  VM's  are added during the parse phase
             */
             Object libfiles = rsvc.getProperty( RuntimeConstants.VM_LIBRARY );
             if( libfiles != null)
             {         
                 if (libfiles instanceof Vector)
                 {
                     macroLibVec = (Vector) libfiles;
                 }
                 else if (libfiles instanceof String)
                 { 
                     macroLibVec = new Vector();
                     macroLibVec.addElement( libfiles );
                 }
                 for( int i = 0; i < macroLibVec.size(); i++)
                 {
                     String lib = (String) macroLibVec.elementAt(i);
                     /*
                      * only if it's a non-empty string do we bother
                      */
                     if (lib != null && !lib.equals(""""))
                     {
                         /*
                          *  let the VMManager know that the following is coming
                          *  from libraries - need to know for auto-load
                          */
                         vmManager.setRegisterFromLib( true );
                         logVMMessageInfo(""Velocimacro : adding VMs from "" +
                             ""VM library template : "" + lib  );
                         try 
                         {
                             Template template = rsvc.getTemplate( lib );
                             /*
                              *  save the template.  This depends on the assumption
                              *  that the Template object won't change - currently
                              *  this is how the Resource manager works
                              */
                             Twonk twonk = new Twonk();
                             twonk.template = template;
                             twonk.modificationTime = template.getLastModified();
                             libModMap.put( lib, twonk );                         
                         } 
                         catch (Exception e)
                         {
                             logVMMessageInfo(""Velocimacro : error using  VM "" +
                                              ""library template "" + lib + "" : "" + e );
                         }
                         logVMMessageInfo(""Velocimacro :  VM library template "" +
                                 ""macro registration complete."" );
                         vmManager.setRegisterFromLib( false );
                     }
                 }
             }
            /*
             *   now, the permissions
             */
            /*
             *  allowinline : anything after this will be an inline macro, I think
             *  there is the question if a #include is an inline, and I think so
             *
             *  default = true
             */
            setAddMacroPermission( true );
            if ( !rsvc.getBoolean(  RuntimeConstants.VM_PERM_ALLOW_INLINE, true) )
            {
                setAddMacroPermission( false );
                logVMMessageInfo(""Velocimacro : allowInline = false : VMs can not "" +
                    ""be defined inline in templates"");
            }
            else
            {
                logVMMessageInfo(""Velocimacro : allowInline = true : VMs can be "" +
                    ""defined inline in templates"");
            }
            /*
             *  allowInlineToReplaceGlobal : allows an inline VM , if allowed at all,
             *  to replace an existing global VM
             *
             *  default = false
             */
            setReplacementPermission( false );
            if ( rsvc.getBoolean(  
                 RuntimeConstants.VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL, false) )
            {
                setReplacementPermission( true );
                logVMMessageInfo(""Velocimacro : allowInlineToOverride = true : VMs "" +
                    ""defined inline may replace previous VM definitions"");
            }
            else
            {
                logVMMessageInfo(""Velocimacro : allowInlineToOverride = false : VMs "" +
                    ""defined inline may NOT replace previous VM definitions"");
            }
            /*
             * now turn on namespace handling as far as permissions allow in the 
             * manager, and also set it here for gating purposes
             */
            vmManager.setNamespaceUsage( true );
            /*
             *  template-local inline VM mode : default is off
             */
            setTemplateLocalInline( rsvc.getBoolean(
                RuntimeConstants.VM_PERM_INLINE_LOCAL, false) );
            if ( getTemplateLocalInline() )
            {
                logVMMessageInfo(""Velocimacro : allowInlineLocal = true : VMs "" +
                    ""defined inline will be local to their defining template only."");
            }
            else
            {
                logVMMessageInfo(""Velocimacro : allowInlineLocal = false : VMs "" +
                    ""defined inline will be  global in scope if allowed."");
            }
            vmManager.setTemplateLocalInlineVM( getTemplateLocalInline() );
            /*
             *  general message switch.  default is on
             */
            setBlather( rsvc.getBoolean( RuntimeConstants.VM_MESSAGES_ON, true ));
            if (getBlather())
            {
                logVMMessageInfo(""Velocimacro : messages on  : VM system "" +
                    ""will output logging messages"");
            }
            else
            {
                logVMMessageInfo(""Velocimacro : messages off : VM system will be quiet"");
            }
            /*
             *  autoload VM libraries
             */
            setAutoload( rsvc.getBoolean( RuntimeConstants.VM_LIBRARY_AUTORELOAD, false ));
            if (getAutoload())
            {
                logVMMessageInfo(""Velocimacro : autoload on  : VM system "" +
                                 ""will automatically reload global library macros"");
            }
            else
            {
                logVMMessageInfo(""Velocimacro : autoload off  : VM system "" +
                                 ""will not automatically reload global library macros"");
            }
            rsvc.info(""Velocimacro : initialization complete."");
        }
        return;
    }
    /**
     *  adds a macro to the factory. 
     */
    public boolean addVelocimacro( String name, String macroBody,  
    	String argArray[], String sourceTemplate )
    {
        /*
         * maybe we should throw an exception, maybe just tell 
         * the caller like this...
         * 
         * I hate this : maybe exceptions are in order here...
         */
        if ( name == null ||   macroBody == null || argArray == null || 
        	sourceTemplate == null )
        {
            logVMMessageWarn(""Velocimacro : VM addition rejected : "" +
                ""programmer error : arg null""  );
            return false;
        }
        /*
         *  see if the current ruleset allows this addition
         */
        if (!canAddVelocimacro( name, sourceTemplate ))
        {
            return false;
        }
        /*
         *  seems like all is good.  Lets do it.
         */
        synchronized( this ) 
        {
            vmManager.addVM( name, macroBody, argArray, sourceTemplate );
        }
        /*
         *  if we are to blather, blather...
         */
        if ( blather)
        {
            String s = ""#"" +  argArray[0];
            s += ""("";
            for( int i=1; i < argArray.length; i++)
            {
                s += "" "";
                s += argArray[i];
            }
            s += "" ) : source = "";
            s += sourceTemplate;
           logVMMessageInfo( ""Velocimacro : added new VM : "" + s );
        }
        return true;
    }
    /**
     *  determines if a given macro/namespace (name, source) combo is allowed
     *  to be added
     *
     *  @param name Name of VM to add
     *  @param sourceTemplate Source template that contains the defintion of the VM
     *  @return true if it is allowed to be added, false otherwise
     */
    private boolean canAddVelocimacro( String name, String sourceTemplate)
    {
        /*
         *  short circuit and do it if autoloader is on, and the
         *  template is one of the library templates
         */
        if ( getAutoload() )
        {
            /*
             *  see if this is a library template
             */
            for( int i = 0; i < macroLibVec.size(); i++)
            {
                String lib = (String) macroLibVec.elementAt(i);
                if (lib.equals( sourceTemplate ) )
                {
                    return true;
                }
            }
        }
        /*
         * maybe the rules should be in manager?  I dunno. It's to manage 
         * the namespace issues first, are we allowed to add VMs at all? 
         * This trumps all.
         */
        if (!addNewAllowed)
        {
            logVMMessageWarn(""Velocimacro : VM addition rejected : "" + name + 
                "" : inline VMs not allowed.""  );
            return false;
        }
        /*
         *  are they local in scope?  Then it is ok to add.
         */
        if (!templateLocal)
        {
            /* 
             * otherwise, if we have it already in global namespace, and they can't replace
             * since local templates are not allowed, the global namespace is implied.
             *  remember, we don't know anything about namespace managment here, so lets
             *  note do anything fancy like trying to give it the global namespace here
             *
             *  so if we have it, and we aren't allowed to replace, bail
             */
            if ( isVelocimacro( name, sourceTemplate ) && !replaceAllowed )
            {
                logVMMessageWarn(""Velocimacro : VM addition rejected : ""
                    + name + "" : inline not allowed to replace existing VM""  );
                return false;
            }
        }
        return true;
    }
    /**
     *  localization of the logging logic
     */
    private void logVMMessageInfo( String s )
    {
        if (blather)
            rsvc.info( s );
    }
    /**
     *  localization of the logging logic
     */
    private void logVMMessageWarn( String s )
    {
        if (blather)
            rsvc.warn( s );
    }
    /**
     *  Tells the world if a given directive string is a Velocimacro
     */
    public boolean isVelocimacro( String vm , String sourceTemplate )
    {
        synchronized(this)
        {
            /*
             * first we check the locals to see if we have 
             * a local definition for this template
             */
            if (vmManager.get( vm, sourceTemplate ) != null)
                return true;
        }
        return false;
    }
    /**
     *  actual factory : creates a Directive that will
     *  behave correctly wrt getting the framework to 
     *  dig out the correct # of args
     */
    public Directive getVelocimacro( String vmName, String sourceTemplate )
    {
        VelocimacroProxy vp = null;
        synchronized( this ) 
        {
            /*
             *  don't ask - do
             */
            vp = vmManager.get( vmName, sourceTemplate);
            /*
             *  if this exists, and autoload is on, we need to check
             *  where this VM came from
             */
            if ( vp != null && getAutoload() ) 
            {    
                /*
                 *  see if this VM came from a library.  Need to pass sourceTemplate
                 *  in the event namespaces are set, as it could be masked by local
                 */
                String lib = vmManager.getLibraryName( vmName, sourceTemplate );
                if (lib != null)
                {
                    try 
                    {
                        /*
                         *  get the template from our map
                         */
                        Twonk tw = (Twonk) libModMap.get( lib );
                        if ( tw != null)
                        {
                            Template template = tw.template;
                            /*
                             *  now, compare the last modified time of the resource
                             *  with the last modified time of the template
                             *  if the file has changed, then reload. Otherwise, we should
                             *  be ok.
                             */
                            long tt = tw.modificationTime;
                            long ft = template.getResourceLoader().getLastModified( template );
                            if ( ft > tt )
                            {
                                logVMMessageInfo(""Velocimacro : autoload reload for VMs from "" +
                                                 ""VM library template : "" + lib  );
                                /*
                                 *  when there are VMs in a library that invoke each other,
                                 *  there are calls into getVelocimacro() from the init() 
                                 *  process of the VM directive.  To stop the infinite loop
                                 *  we save the current time reported by the resource loader
                                 *  and then be honest when the reload is complete
                                 */
                                tw.modificationTime = ft;
                                template = rsvc.getTemplate( lib );
                                /*
                                 * and now we be honest
                                 */
                                tw.template = template;
                                tw.modificationTime = template.getLastModified();
                                /*
                                 *  note that we don't need to put this twonk back 
                                 *  into the map, as we can just use the same reference
                                 *  and this block is synchronized
                                 */                                  
                             }
                         } 
                    }
                    catch (Exception e)
                    {
                        logVMMessageInfo(""Velocimacro : error using  VM "" +
                                         ""library template "" + lib + "" : "" + e );
                    }
                    /*
                     *  and get again
                     */
                    vp = vmManager.get( vmName, sourceTemplate);
                }
            }
        }
        return vp;
    }
    /**
     *  tells the vmManager to dump the specified namespace
     */
    public boolean dumpVMNamespace( String namespace )
    {
        return vmManager.dumpNamespace( namespace );
    }
    /**
     *  sets permission to have VMs local in scope to their declaring template
     *  note that this is really taken care of in the VMManager class, but
     *  we need it here for gating purposes in addVM
     *  eventually, I will slide this all into the manager, maybe.
     */   
    private void setTemplateLocalInline( boolean b )
    {
        templateLocal = b;
    }
    private boolean getTemplateLocalInline()
    {
        return templateLocal;
    }
    /**
     *   sets the permission to add new macros
     */
    private boolean setAddMacroPermission( boolean arg )
    {
        boolean b = addNewAllowed;
        addNewAllowed = arg;
        return b;
    }
    /**
     *    sets the permission for allowing addMacro() calls to 
     *    replace existing VM's
     */
    private boolean setReplacementPermission( boolean arg )
    {
        boolean b = replaceAllowed;
        replaceAllowed = arg;
        return b;
    }
    /**
     *  set output message mode 
     */
    private void setBlather( boolean b )
    {
        blather = b;
    }
    /**
     * get output message mode
     */
    private boolean getBlather()
    {
        return blather;
    }
    /**
     *  set the switch for automatic reloading of
     *  global library-based VMs
     */
    private void setAutoload( boolean b)
    {
        autoReloadLibrary = b;
    }
    /**
     *  get the switch for automatic reloading of
     *  global library-based VMs
     */
    private boolean getAutoload()
    {
        return autoReloadLibrary;
    }
    /**
     * small continer class to hold the duple
     * of a template and modification time.
     * We keep the modification time so we can 
     * 'override' it on a reload to prevent
     * recursive reload due to inter-calling
     * VMs in a library
     */
    private class Twonk
    {
        public Template template;
        public long modificationTime;
    }
}
"
org.apache.velocity.runtime.VelocimacroManager,"package org.apache.velocity.runtime;
/*
 * Copyright 2000-2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Hashtable;
import java.io.StringReader;
import java.io.BufferedReader;
import org.apache.velocity.runtime.directive.VelocimacroProxy;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.context.InternalContextAdapter;
/**
 * Manages VMs in namespaces.  Currently, two namespace modes are
 * supported:
 *
 * <ul>
 * <li>flat - all allowable VMs are in the global namespace</li>
 * <li>local - inline VMs are added to it's own template namespace</li>
 * </ul>
 *
 * Thanks to <a href=""mailto:JFernandez@viquity.com"">Jose Alberto Fernandez</a>
 * for some ideas incorporated here.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:JFernandez@viquity.com"">Jose Alberto Fernandez</a>
 * @version $Id: VelocimacroManager.java,v 1.17.4.1 2004/03/03 23:22:55 geirm Exp $ 
 */
public class VelocimacroManager
{
    private RuntimeServices rsvc = null;
    private static String GLOBAL_NAMESPACE = """";
    private boolean registerFromLib = false;
    /** Hash of namespace hashes. */
    private Hashtable namespaceHash = new Hashtable();
    /** map of names of library tempates/namespaces */
    private Hashtable libraryMap = new Hashtable();
    /* 
     * big switch for namespaces.  If true, then properties control 
     * usage. If false, no. 
     */
    private boolean namespacesOn = true;
    private boolean  inlineLocalMode = false;
    /**
     * Adds the global namespace to the hash.
     */
    VelocimacroManager(RuntimeServices rs)
    {
        this.rsvc = rs;
        /*
         *  add the global namespace to the namespace hash. We always have that.
         */
        addNamespace( GLOBAL_NAMESPACE );
    }
    /**
     * Adds a VM definition to the cache.
     * @return Whether everything went okay.
     */
    public boolean addVM(String vmName, String macroBody, String argArray[],
                         String namespace)
    {
        MacroEntry me = new MacroEntry(this, vmName, macroBody, argArray,
                                       namespace);
        me.setFromLibrary(registerFromLib);
        /*
         *  the client (VMFactory) will signal to us via
         *  registerFromLib that we are in startup mode registering
         *  new VMs from libraries.  Therefore, we want to
         *  addto the library map for subsequent auto reloads
         */
        boolean isLib = true;
        if (registerFromLib)
        {
           libraryMap.put(namespace, namespace);
        }
        else
        {
            /*
             *  now, we first want to check to see if this namespace (template)
             *  is actually a library - if so, we need to use the global namespace
             *  we don't have to do this when registering, as namespaces should
             *  be shut off. If not, the default value is true, so we still go
             *  global
             */
            isLib = libraryMap.containsKey(namespace);
        }
        if ( !isLib && usingNamespaces(namespace) )
        {
            /*
             *  first, do we have a namespace hash already for this namespace?
             *  if not, add it to the namespaces, and add the VM
             */
            Hashtable local = getNamespace(namespace, true);
            local.put((String) vmName, me);
            return true;
        }
        else
        {        
            /*
             *  otherwise, add to global template.  First, check if we
             *  already have it to preserve some of the autoload information
             */
            MacroEntry exist = (MacroEntry) getNamespace(GLOBAL_NAMESPACE).get(vmName);
            if (exist != null)
            {
                me.setFromLibrary(exist.getFromLibrary());
            }
            /*
             *  now add it
             */
            getNamespace(GLOBAL_NAMESPACE).put(vmName, me);
            return true;
        }
    }
    /**
     * gets a new living VelocimacroProxy object by the 
     * name / source template duple
     */
    public VelocimacroProxy get(String vmName, String namespace)
    {
        if (usingNamespaces(namespace))
        {
            Hashtable local =  getNamespace(namespace, false);
            /*
             *  if we have macros defined for this template
             */
            if (local != null)
            {
                MacroEntry me = (MacroEntry) local.get(vmName);
                if (me != null)
                {
                    return me.createVelocimacro(namespace);
                }
            }
        }
        /*
         * if we didn't return from there, we need to simply see 
         * if it's in the global namespace
         */
        MacroEntry me = (MacroEntry) getNamespace(GLOBAL_NAMESPACE).get( vmName );
        if (me != null)
        {
            return me.createVelocimacro(namespace);
        }
        return null;
    }
    /**
     * Removes the VMs and the namespace from the manager.
     * Used when a template is reloaded to avoid 
     * accumulating drek
     *
     * @param namespace namespace to dump
     * @return boolean representing success
     */
    public boolean dumpNamespace(String namespace)
    {
        synchronized(this)
        {
            if (usingNamespaces(namespace))
            {
                Hashtable h = (Hashtable) namespaceHash.remove(namespace);
                if (h == null)
                    return false;
                h.clear();
                return true;
            }
            return false;
        }
    }
    /**
     *  public switch to let external user of manager to control namespace
     *  usage indep of properties.  That way, for example, at startup the 
     *  library files are loaded into global namespace
     */
    public void setNamespaceUsage(boolean b)
    {
        namespacesOn = b;
    }
    public void setRegisterFromLib(boolean b)
    {
        registerFromLib = b;
    }
    public void setTemplateLocalInlineVM(boolean b)
    {
        inlineLocalMode = b;
    }
    /**
     *  returns the hash for the specified namespace.  Will not create a new one
     *  if it doesn't exist
     *
     *  @param namespace  name of the namespace :)
     *  @return namespace Hashtable of VMs or null if doesn't exist
     */
    private Hashtable getNamespace(String namespace)
    {
        return getNamespace(namespace, false);
    }
    /**
     *  returns the hash for the specified namespace, and if it doesn't exist
     *  will create a new one and add it to the namespaces
     *
     *  @param namespace  name of the namespace :)
     *  @param addIfNew  flag to add a new namespace if it doesn't exist
     *  @return namespace Hashtable of VMs or null if doesn't exist
     */
    private Hashtable getNamespace(String namespace, boolean addIfNew)
    {
        Hashtable h = (Hashtable) namespaceHash.get(namespace);
        if (h == null && addIfNew)
        {
            h = addNamespace(namespace);
        }
        return h;
    }
    /**
     *   adds a namespace to the namespaces
     *
     *  @param namespace name of namespace to add
     *  @return Hash added to namespaces, ready for use
     */
    private Hashtable addNamespace(String namespace)
    {
        Hashtable h = new Hashtable();
        Object oh;
        if ((oh = namespaceHash.put(namespace, h)) != null)
        {
          /*
           * There was already an entry on the table, restore it!
           * This condition should never occur, given the code
           * and the fact that this method is private.
           * But just in case, this way of testing for it is much
           * more efficient than testing before hand using get().
           */
          namespaceHash.put(namespace, oh);
          /*
           * Should't we be returning the old entry (oh)?
           * The previous code was just returning null in this case.
           */
          return null;
        }
        return h;
    }
    /**
     *  determines if currently using namespaces.
     *
     *  @param namespace currently ignored
     *  @return true if using namespaces, false if not
     */
    private boolean usingNamespaces(String namespace)
    {
        /*
         *  if the big switch turns of namespaces, then ignore the rules
         */
        if (!namespacesOn)
        {
            return false;
        }
        /*
         *  currently, we only support the local template namespace idea
         */
        if (inlineLocalMode)
        {
            return true;
        }
        return false;
    }
    public String getLibraryName(String vmName, String namespace)
    {
        if (usingNamespaces(namespace))
        {
            Hashtable local =  getNamespace(namespace, false);
            /*
             *  if we have this macro defined in this namespace, then
             *  it is masking the global, library-based one, so 
             *  just return null
             */
            if ( local != null)
            {
                MacroEntry me = (MacroEntry) local.get(vmName);
                if (me != null)
                {
                    return null;
                }
            }
        }
        /*
         * if we didn't return from there, we need to simply see 
         * if it's in the global namespace
         */
        MacroEntry me = (MacroEntry) getNamespace(GLOBAL_NAMESPACE).get(vmName);
        if (me != null)
        {
            return me.getSourceTemplate();
        }
        return null;
    }
    /**
     *  wrapper class for holding VM information
     */
    protected class MacroEntry
    {
        String macroname;
        String[] argarray;
        String macrobody;
        String sourcetemplate;
        SimpleNode nodeTree = null;
        VelocimacroManager manager = null;
        boolean fromLibrary = false;
        MacroEntry(VelocimacroManager vmm, String vmName, String macroBody,
                   String argArray[],  String sourceTemplate)
        {
            this.macroname = vmName;
            this.argarray = argArray;
            this.macrobody = macroBody;
            this.sourcetemplate = sourceTemplate;
            this.manager = vmm;
        }
        public void setFromLibrary(boolean b)
        {
            fromLibrary = b;
        }
        public boolean getFromLibrary()
        {
            return fromLibrary;
        }
        public SimpleNode getNodeTree()
        {
            return nodeTree;
        }
        public String getSourceTemplate()
        {
            return sourcetemplate;
        }
        VelocimacroProxy createVelocimacro(String namespace)
        {
            VelocimacroProxy vp = new VelocimacroProxy();
            vp.setName(this.macroname);
            vp.setArgArray(this.argarray);
            vp.setMacrobody(this.macrobody);
            vp.setNodeTree(this.nodeTree);
            vp.setNamespace(namespace);
            return vp;
        }
        void setup( InternalContextAdapter ica)
        {
            /*
             *  if not parsed yet, parse!
             */
            if( nodeTree == null)
                parseTree(ica);
        }
        void parseTree(InternalContextAdapter ica)
        {
            try 
            {
                BufferedReader br = new BufferedReader(new StringReader(macrobody));
                nodeTree = rsvc.parse(br, ""VM:"" + macroname, true);
                nodeTree.init(ica,null);
            } 
            catch ( Exception e ) 
            {
                rsvc.error(""VelocimacroManager.parseTree() : exception "" +
                           macroname + "" : ""  + StringUtils.stackTrace(e));
            }
        }
    }
}
"
org.apache.velocity.runtime.compiler.Compiler,"package org.apache.velocity.runtime.compiler;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.bcel.generic.*;
import org.apache.bcel.Constants;
/**
 * The start of a velocity template compiler. Incomplete.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Compiler.java,v 1.6.8.1 2004/03/03 23:22:55 geirm Exp $
 */
public class Compiler implements InstructionConstants
{
    public static void main(String[] args)
    {
        String template = args[0].substring(0, args[0].indexOf("".""));
        ClassGen cg =
                new ClassGen(template, ""java.lang.Object"", ""<generated>"",
                Constants.ACC_PUBLIC | Constants.ACC_SUPER, null);
        ConstantPoolGen cp = cg.getConstantPool(); // cg creates constant pool
        InstructionList il = new InstructionList();
        MethodGen mg = new MethodGen(Constants.ACC_STATIC |
                Constants.ACC_PUBLIC, // access flags
                Type.VOID, // return type
                new Type[]{ // argument types
                new ArrayType(Type.STRING, 1)},
                new String[]{ ""argv"" }, // arg names
                ""main"", template, // method, class
                il, cp);
        //Add often needed constants to constant pool.
        int br_index = cp.addClass(""java.io.BufferedReader"");
        int ir_index = cp.addClass(""java.io.InputStreamReader"");
        int system_out = cp.addFieldref(""java.lang.System"", ""out"", // System.out
                ""Ljava/io/PrintStream;"");
        int system_in = cp.addFieldref(""java.lang.System"", ""in"", // System.in
                ""Ljava/io/InputStream;"");
        // Create BufferedReader object and store it in local variable `in'.
        il.append(new NEW(br_index));
        il.append(DUP);
        il.append(new NEW(ir_index));
        il.append(DUP);
        il.append(new GETSTATIC(system_in));
        // Call constructors, i.e. BufferedReader(InputStreamReader())
        il.append( new INVOKESPECIAL(
                cp.addMethodref(""java.io.InputStreamReader"", ""<init>"",
                ""(Ljava/io/InputStream;)V"")));
        il.append( new INVOKESPECIAL(
                cp.addMethodref(""java.io.BufferedReader"", ""<init>"", ""(Ljava/io/Reader;)V"")));
        // Create local variable `in'
        LocalVariableGen lg = mg.addLocalVariable(""in"",
                new ObjectType(""java.io.BufferedReader""), null, null);
        int in = lg.getIndex();
        lg.setStart(il.append(new ASTORE(in))); // `i' valid from here
        // Create local variable `name'
        lg = mg.addLocalVariable(""name"", Type.STRING, null, null);
        int name = lg.getIndex();
        il.append(ACONST_NULL);
        lg.setStart(il.append(new ASTORE(name))); // `name' valid from here
        InstructionHandle try_start = il.append(new GETSTATIC(system_out));
        il.append(new PUSH(cp, ""I will be a template compiler!""));
        il.append( new INVOKEVIRTUAL(
                cp.addMethodref(""java.io.PrintStream"", ""println"", ""(Ljava/lang/String;)V"")));
        // Upon normal execution we jump behind exception handler,
        // the target address is not known yet.
        GOTO g = new GOTO(null);
        InstructionHandle try_end = il.append(g);
        InstructionHandle handler = il.append(RETURN);
        mg.addExceptionHandler(try_start, try_end, handler,
                new ObjectType(""java.io.IOException""));
        // Normal code continues, now we can set the branch target of the GOTO.
        InstructionHandle ih = il.append(new GETSTATIC(system_out));
        g.setTarget(ih);
        // String concatenation compiles to StringBuffer operations.
        il.append(new NEW(cp.addClass(""java.lang.StringBuffer"")));
        il.append(DUP);
        il.append(new PUSH(cp, "" ""));
        il.append( new INVOKESPECIAL(
                cp.addMethodref(""java.lang.StringBuffer"", ""<init>"", ""(Ljava/lang/String;)V"")));
        il.append(new ALOAD(name));
        // One can also abstract from using the ugly signature syntax by using
        // the getMethodSignature() method. For example:
        String sig = Type.getMethodSignature(Type.STRINGBUFFER,
                new Type[]{ Type.STRING });
        il.append( new INVOKEVIRTUAL(
                cp.addMethodref(""java.lang.StringBuffer"", ""append"", sig)));
        il.append( new INVOKEVIRTUAL(
                cp.addMethodref(""java.lang.StringBuffer"", ""toString"", ""()Ljava/lang/String;"")));
        il.append(RETURN);
        mg.setMaxStack(5); // Needed stack size
        cg.addMethod(mg.getMethod());
        // Add public <init> method, i.e. empty constructor
        cg.addEmptyConstructor(Constants.ACC_PUBLIC);
        // Get JavaClass object and dump it to file.
        try
        {
            cg.getJavaClass().dump(template + "".class"");
        }
        catch (java.io.IOException e)
        {
            System.err.println(e);
        }
    }
}
"
org.apache.velocity.runtime.configuration.Configuration,"package org.apache.velocity.runtime.configuration;
/*
 * Copyright (c) 2001 The Java Apache Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    ""This product includes software developed by the Java Apache
 *    Project for use in the Apache JServ servlet engine project
 *    <http://java.apache.org/>.""
 *
 * 4. The names ""Apache JServ"", ""Apache JServ Servlet Engine"", ""Turbine"",
 *    ""Apache Turbine"", ""Turbine Project"", ""Apache Turbine Project"" and
 *    ""Java Apache Project"" must not be used to endorse or promote products
 *    derived from this software without prior written permission.
 *
 * 5. Products derived from this software may not be called ""Apache JServ""
 *    nor may ""Apache"" nor ""Apache JServ"" appear in their names without
 *    prior written permission of the Java Apache Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    ""This product includes software developed by the Java Apache
 *    Project for use in the Apache JServ servlet engine project
 *    <http://java.apache.org/>.""
 *
 * THIS SOFTWARE IS PROVIDED BY THE JAVA APACHE PROJECT ""AS IS"" AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE JAVA APACHE PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Java Apache Group. For more information
 * on the Java Apache Project and the Apache JServ Servlet Engine project,
 * please see <http://java.apache.org/>.
 *
 */
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;
import org.apache.commons.collections.ExtendedProperties;
/**
 * This class extends normal Java properties by adding the possibility
 * to use the same key many times concatenating the value strings
 * instead of overwriting them.
 *
 * <p>The Extended Properties syntax is explained here:
 *
 * <ul>
 *  <li>
 *   Each property has the syntax <code>key = value</code>
 *  </li>
 *  <li>
 *   The <i>key</i> may use any character but the equal sign '='.
 *  </li>
 *  <li>
 *   <i>value</i> may be separated on different lines if a backslash
 *   is placed at the end of the line that continues below.
 *  </li>
 *  <li>
 *   If <i>value</i> is a list of strings, each token is separated
 *   by a comma ','.
 *  </li>
 *  <li>
 *   Commas in each token are escaped placing a backslash right before
 *   the comma.
 *  </li>
 *  <li>
 *   If a <i>key</i> is used more than once, the values are appended
 *   like if they were on the same line separated with commas.
 *  </li>
 *  <li>
 *   Blank lines and lines starting with character '#' are skipped.
 *  </li>
 *  <li>
 *   If a property is named ""include"" (or whatever is defined by
 *   setInclude() and getInclude() and the value of that property is
 *   the full path to a file on disk, that file will be included into
 *   the ConfigurationsRepository. You can also pull in files relative
 *   to the parent configuration file. So if you have something
 *   like the following:
 *
 *   include = additional.properties
 *
 *   Then ""additional.properties"" is expected to be in the same
 *   directory as the parent configuration file.
 * 
 *   Duplicate name values will be replaced, so be careful.
 *
 *  </li>
 * </ul>
 *
 * <p>Here is an example of a valid extended properties file:
 *
 * <p><pre>
 *      # lines starting with # are comments
 *
 *      # This is the simplest property
 *      key = value
 *
 *      # A long property may be separated on multiple lines
 *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
 *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 *
 *      # This is a property with many tokens
 *      tokens_on_a_line = first token, second token
 *
 *      # This sequence generates exactly the same result
 *      tokens_on_multiple_lines = first token
 *      tokens_on_multiple_lines = second token
 *
 *      # commas may be escaped in tokens
 *      commas.excaped = Hi\, what'up?
 * </pre>
 *
 * <p><b>NOTE</b>: this class has <b>not</b> been written for
 * performance nor low memory usage.  In fact, it's way slower than it
 * could be and generates too much memory garbage.  But since
 * performance is not an issue during intialization (and there is not
 * much time to improve it), I wrote it this way.  If you don't like
 * it, go ahead and tune it up!
 *
 *
 * @author <a href=""mailto:stefano@apache.org"">Stefano Mazzocchi</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:daveb@miceda-data"">Dave Bryson</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:leon@opticode.co.za"">Leon Messerschmidt</a>
 * @author <a href=""mailto:kjohnson@transparent.com>Kent Johnson</a>
 * @version $Id: Configuration.java,v 1.34 2003/05/04 17:14:37 geirm Exp $
 *
 * @deprecated As of version 1.1, please use ExtendedProperties from
 * the Jakarta Commons Collections component.
 */
public class Configuration extends Hashtable
{
    // $$$ GMJ : remove post version 1.1
    // intended to help deprecate this class w/o having to modify 
    // the jakarta commons collections class which contains
    // extended properties.  We need this when someone wants to 
    // configure velocity w/ a Configuration : the strategy is simply
    // to shadow the Configuration with the EP
    private ExtendedProperties deprecationCrutch = new ExtendedProperties();
    /**
     * Default configurations repository.
     */
    private Configuration defaults;
    /**
     * The file connected to this repository (holding comments and
     * such).
     *
     * @serial
     */
    protected String file;
    /**
     * Base path of the configuration file used to create
     * this Configuration object.
     */
    protected String basePath;
    /**
     * File separator.
     */
    protected String fileSeparator = System.getProperty(""file.separator"");
    /**
     * Has this configuration been intialized.
     */
    protected boolean isInitialized = false;
    /**
     * This is the name of the property that can point to other
     * properties file for including other properties files.
     */
    protected static String include = ""include"";
    /**
     * These are the keys in the order they listed
     * in the configuration file. This is useful when
     * you wish to perform operations with configuration
     * information in a particular order.
     */
    protected ArrayList keysAsListed = new ArrayList();
    /**
     * This class is used to read properties lines.  These lines do
     * not terminate with new-line chars but rather when there is no
     * backslash sign a the end of the line.  This is used to
     * concatenate multiple lines for readability.
     */
    class PropertiesReader extends LineNumberReader
    {
        /**
         * Constructor.
         *
         * @param reader A Reader.
         */
        public PropertiesReader(Reader reader)
        {
            super(reader);
        }
        /**
         * Read a property.
         *
         * @return A String.
         * @exception IOException.
         */
        public String readProperty() throws IOException
        {
            StringBuffer buffer = new StringBuffer();
            try
            {
                while (true)
                {
                    String line = readLine().trim();
                    if ((line.length() != 0) && (line.charAt(0) != '#'))
                    {
                        if (line.endsWith(""\\""))
                        {
                            line = line.substring(0, line.length() - 1);
                            buffer.append(line);
                        }
                        else
                        {
                            buffer.append(line);
                            break;
                        }
                    }
                }
            }
            catch (NullPointerException e)
            {
                return null;
            }
            return buffer.toString();
        }
    }
    /**
     * This class divides into tokens a property value.  Token
     * separator is "","" but commas into the property value are escaped
     * using the backslash in front.
     */
    class PropertiesTokenizer extends StringTokenizer
    {
        /**
         * The property delimiter used while parsing (a comma).
         */
        static final String DELIMITER = "","";
        /**
         * Constructor.
         *
         * @param string A String.
         */
        public PropertiesTokenizer(String string)
        {
            super(string, DELIMITER);
        }
        /**
         * Check whether the object has more tokens.
         *
         * @return True if the object has more tokens.
         */
        public boolean hasMoreTokens()
        {
            return super.hasMoreTokens();
        }
        /**
         * Get next token.
         *
         * @return A String.
         */
        public String nextToken()
        {
            StringBuffer buffer = new StringBuffer();
            while (hasMoreTokens())
            {
                String token = super.nextToken();
                if (token.endsWith(""\\""))
                {
                    buffer.append(token.substring(0, token.length() - 1));
                    buffer.append(DELIMITER);
                }
                else
                {
                    buffer.append(token);
                    break;
                }
            }
            return buffer.toString().trim();
        }
    }
    /**
     * Creates an empty extended properties object.
     */
    public Configuration ()
    {
        super();
    }
    /**
     * Creates and loads the extended properties from the specified
     * file.
     *
     * @param file A String.
     * @exception IOException.
     */
    public Configuration (String file) throws IOException
    {
        this(file,null);
    }
    /**
     * Creates and loads the extended properties from the specified
     * file.
     *
     * @param file A String.
     * @exception IOException.
     */
    public Configuration (String file, String defaultFile)
        throws IOException
    {
        this.file = file;
        basePath = new File(file).getAbsolutePath();
        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);
        this.load(new FileInputStream(file));
        if (defaultFile != null)
        {
            defaults = new Configuration(defaultFile);
        }            
    }
    /**
     * Private initializer method that sets up the generic
     * resources.
     *
     * @exception IOException, if there was an I/O problem.
     */
    private void init( Configuration exp ) throws IOException
    {
        isInitialized = true;
    }
    /**
     * Indicate to client code whether property
     * resources have been initialized or not.
     */
    public boolean isInitialized()
    {
        return isInitialized;
    }        
    /**
     * Gets the property value for including other properties files.
     * By default it is ""include"".
     *
     * @return A String.
     */
    public String getInclude()
    {
        return Configuration.include;
    }
    /**
     * Sets the property value for including other properties files.
     * By default it is ""include"".
     *
     * @param inc A String.
     */
    public void setInclude(String inc)
    {
		Configuration.include = inc;
    }
    /**
     * Load the properties from the given input stream.
     *
     * @param input An InputStream.
     * @exception IOException.
     */
    public synchronized void load(InputStream input)
        throws IOException
    {
        PropertiesReader reader =
            new PropertiesReader(new InputStreamReader(input));
        try
        {
            while (true)
            {
                String line = reader.readProperty();
                int equalSign = line.indexOf('=');
                if (equalSign > 0)
                {
                    String key = line.substring(0, equalSign).trim();
                    String value = line.substring(equalSign + 1).trim();
                    /*
                     * Configure produces lines like this ... just
                     * ignore them.
                     */
                    if ("""".equals(value))
                        continue;
                    if (getInclude() != null && 
                        key.equalsIgnoreCase(getInclude()))
                    {
                        /*
                         * Recursively load properties files.
                         */
                        File file = null;
                        if (value.startsWith(fileSeparator))
                        {
                            /*
                             * We have an absolute path so we'll
                             * use this.
                             */
                            file = new File(value);
                        }
                        else
                        {   
                            /* 
                             * We have a relative path, and we have
                             * two possible forms here. If we have the
                             * ""./"" form then just strip that off first
                             * before continuing.
                             */
                            if (value.startsWith(""."" + fileSeparator))
                            {
                                value = value.substring(2);
                            }
                            file = new File(basePath + value);
                        }
                        if (file != null && file.exists() && file.canRead())
                        {
                            load ( new FileInputStream(file));
                        }
                    }
                    else
                    {
                        addProperty(key,value);
                        //setProperty(key,value);
                    }                       
                }
            }
        }
        catch (NullPointerException e)
        {
            /*
             * Should happen only when EOF is reached.
             */
            return;
        }
    }
    /**
     *  Gets a property from the configuration.
     *
     *  @param key property to retrieve
     *  @return value as object. Will return user value if exists,
     *          if not then default value if exists, otherwise null
     */
    public Object getProperty( String key)
    {
        /*
         *  first, try to get from the 'user value' store
         */
        Object o = this.get(key);
        if ( o == null)
        {
            /*
             *  if there isn't a value there, get it from the
             *  defaults if we have them
             */
            if (defaults != null)
            {
                o = defaults.get(key);
            }
        }
        return o;
    }
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param String key
     * @param String value
     */
    //public void setProperty(String key, Object token)
    public void addProperty(String key, Object token)
    {
        // $$$ GMJ : remove after 1.1 release
        // for deprecation help
        deprecationCrutch.addProperty( key, token );
        Object o = this.get(key);
        /*
         *  $$$ GMJ
         *  FIXME : post 1.0 release, we need to not assume
         *  that a scalar is a String - it can be an Object
         *  so we should make a little vector-like class
         *  say, Foo that wraps (not extends Vector),
         *  so we can do things like
         *  if ( !( o instanceof Foo) )
         *  so we know it's our 'vector' container
         *
         *  This applies throughout
         */
        if (o instanceof String)
        {
            Vector v = new Vector(2);
            v.addElement(o);
            v.addElement(token);
            put(key, v);
        }
        else if (o instanceof Vector)
        {
            ((Vector) o).addElement(token);
        }
        else
        {
            /*
             * This is the first time that we have seen
             * request to place an object in the 
             * configuration with the key 'key'. So
             * we just want to place it directly into
             * the configuration ... but we are going to
             * make a special exception for String objects
             * that contain "","" characters. We will take
             * CSV lists and turn the list into a vector of
             * Strings before placing it in the configuration.
             * This is a concession for Properties and the
             * like that cannot parse multiple same key
             * values.
             */
            if (token instanceof String &&
                ((String)token).indexOf(PropertiesTokenizer.DELIMITER) > 0)
            {
                PropertiesTokenizer tokenizer = 
                    new PropertiesTokenizer((String)token);
                while (tokenizer.hasMoreTokens())
                {
                    String value = tokenizer.nextToken();
                    /*
                     * we know this is a string, so make sure it
                     * just goes in rather than risking vectorization
                     * if it contains an escaped comma
                     */
                    addStringProperty(key,value);
                }
            }
            else
            {
                /*
                 * We want to keep track of the order the keys
                 * are parsed, or dynamically entered into
                 * the configuration. So when we see a key
                 * for the first time we will place it in
                 * an ArrayList so that if a client class needs
                 * to perform operations with configuration
                 * in a definite order it will be possible.
                 */
                /*
                 * safety check
                 */
                if( !containsKey( key ) )
                {
                    keysAsListed.add(key);
                }
                /*
                 * and the value
                 */
                put(key, token);
            }                
        }
    }
    /**
     *  Sets a string property w/o checking for commas - used
     *  internally when a property has been broken up into
     *  strings that could contain escaped commas to prevent
     *  the inadvertant vectorization.
     *
     *  Thanks to Leon Messerschmidt for this one.
     *
     */
    private  void addStringProperty(String key, String token)
    {
        Object o = this.get(key);
        /*
         *  $$$ GMJ
         *  FIXME : post 1.0 release, we need to not assume
         *  that a scalar is a String - it can be an Object
         *  so we should make a little vector-like class
         *  say, Foo that wraps (not extends Vector),
         *  so we can do things like
         *  if ( !( o instanceof Foo) )
         *  so we know it's our 'vector' container
         *
         *  This applies throughout
         */
        /*
         *  do the usual thing - if we have a value and 
         *  it's scalar, make a vector, otherwise add
         *  to the vector
         */
        if (o instanceof String)
        {
            Vector v = new Vector(2);
            v.addElement(o);
            v.addElement(token);
            put(key, v);
        }
        else if (o instanceof Vector)
        {
            ((Vector) o).addElement(token);
        }
        else
        {
            if( !containsKey( key ) )
            {
                keysAsListed.add(key);
            }
            put( key, token);
        }
    }
    /**
     * Set a property, this will replace any previously
     * set values. Set values is implicitly a call
     * to clearProperty(key), addProperty(key,value).
     *
     * @param String key
     * @param String value
     */
    public void setProperty(String key, Object value)
    {
        clearProperty(key);
        addProperty(key,value);
    }
    /**
     * Save the properties to the given outputstream.
     *
     * @param output An OutputStream.
     * @param header A String.
     * @exception IOException.
     */
    public synchronized void save(OutputStream output,
                                  String Header)
        throws IOException
    {
        if(output != null)
        {
            PrintWriter theWrtr = new PrintWriter(output);
            if(Header != null)
            {
                theWrtr.println(Header);
            }
            Enumeration theKeys = keys();
            while(theKeys.hasMoreElements())
            {
                String key = (String) theKeys.nextElement();
                Object value = get((Object) key);
                if(value != null)
                {
                    if(value instanceof String)
                    {
                        StringBuffer currentOutput = new StringBuffer();
                        currentOutput.append(key);
                        currentOutput.append(""="");
                        currentOutput.append((String) value);
                        theWrtr.println(currentOutput.toString());
                    }
                    else if(value instanceof Vector)
                    {
                        Vector values = (Vector) value;
                        Enumeration valuesEnum = values.elements();
                        while(valuesEnum.hasMoreElements())
                        {
                            String currentElement = 
                                   (String) valuesEnum.nextElement();
                            StringBuffer currentOutput = new StringBuffer();
                            currentOutput.append(key);
                            currentOutput.append(""="");
                            currentOutput.append(currentElement);
                            theWrtr.println(currentOutput.toString());
                        }
                    }
                }    
                theWrtr.println();
                theWrtr.flush();
            }    
        }        
    }
    /**
     * Combines an existing Hashtable with this Hashtable.
     *
     * Warning: It will overwrite previous entries without warning.
     *
     * @param Configuration
     */
    public void combine (Configuration c)
    {
        for (Iterator i = c.getKeys() ; i.hasNext() ;)
        {
            String key = (String) i.next();
            //clearProperty(key);
            setProperty( key, c.get(key) );
        }
    }
    /**
     * Clear a property in the configuration.
     *
     * @param String key to remove along with corresponding value.
     */
    public void clearProperty(String key)
    {
        // $$$ GMJ : remove after 1.1 release
        // for deprecation help
        deprecationCrutch.clearProperty( key  );
        if (containsKey(key))
        {
            /*
             * we also need to rebuild the keysAsListed or else
             * things get *very* confusing
             */
            for(int i = 0; i < keysAsListed.size(); i++)
            {
                if ( ( (String) keysAsListed.get(i)).equals( key ) )
                {
                    keysAsListed.remove(i);
                    break;
                }
            }
            remove(key);
        }            
    }
    /**
     * Get the list of the keys contained in the configuration
     * repository.
     *
     * @return An Iterator.
     */
    public Iterator getKeys()
    {
        return keysAsListed.iterator();
    }
    /**
     * Get the list of the keys contained in the configuration
     * repository that match the specified prefix.
     *
     * @param prefix The prefix to test against.
     * @return An Iterator of keys that match the prefix.
     */
    public Iterator getKeys(String prefix)
    {
        Iterator keys = getKeys();
        ArrayList matchingKeys = new ArrayList();
        while( keys.hasNext() )
        {
            Object key = keys.next();
            if( key instanceof String && ((String) key).startsWith(prefix) )
            {
                matchingKeys.add(key);
            }
        }
        return matchingKeys.iterator();
    }
    /**
     * Create a Configurations object that is a subset
     * of this one. Take into account duplicate keys
     * by using the setProperty() in Configuration.
     *
     * @param String prefix
     */
    public Configuration subset(String prefix)
    {
        Configuration c = new Configuration();
        Iterator keys = getKeys();
        boolean validSubset = false;
        while( keys.hasNext() )
        {
            Object key = keys.next();
            if( key instanceof String && ((String) key).startsWith(prefix) )
            {
                if (!validSubset)
                {
                    validSubset = true;
                }
                String newKey = null;
                /*
                 * Check to make sure that c.subset(prefix) doesn't
                 * blow up when there is only a single property
                 * with the key prefix. This is not a useful
                 * subset but it is a valid subset.
                 */
                if ( ((String)key).length() == prefix.length())
                {
                    newKey = prefix;
                }
                else
                {
                    newKey = ((String)key).substring(prefix.length() + 1);
                }                    
                /*
                 * Make sure to use the setProperty() method and not
                 * just put(). setProperty() takes care of catching
                 * all the keys in the order they appear in a
                 * properties files or the order they are set
                 * dynamically.
                 */
                c.setProperty(newKey, get(key));
            }
        }
        if (validSubset)
        {
            return c;
        }
        else
        {
            return null;
        }
    }
    /**
     * Display the configuration for debugging
     * purposes.
     */
    public void display()
    {
        Iterator i = getKeys();
        while (i.hasNext())
        {
            String key = (String) i.next();
            Object value = get(key);
            System.out.println(key + "" => "" + value);
        }
    }     
    /**
     * Get a string associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated string.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a String.
     */
    public String getString(String key)
    {
        return getString(key, null);
    }
    /**
     * Get a string associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated string if key is found,
     * default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a String.
     */
    public String getString(String key,
                            String defaultValue)
    {
        Object value = get(key);
        if (value instanceof String)
        {
            return (String) value;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getString(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else if (value instanceof Vector)
        {
            return (String) ((Vector) value).get(0);
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a String object"");
        }
    }
    /**
     * Get a list of properties associated with the given
     * configuration key.
     *
     * @param key The configuration key.
     * @return The associated properties if key is found.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a String/Vector.
     * @exception IllegalArgumentException if one of the tokens is
     * malformed (does not contain an equals sign).
     */
    public Properties getProperties(String key)
    {
        return getProperties(key, new Properties());
    }
    /**
     * Get a list of properties associated with the given
     * configuration key.
     *
     * @param key The configuration key.
     * @return The associated properties if key is found.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a String/Vector.
     * @exception IllegalArgumentException if one of the tokens is
     * malformed (does not contain an equals sign).
     */
    public Properties getProperties(String key,
                                    Properties defaults)
    {
        /*
         * Grab an array of the tokens for this key.
         */
        String[] tokens = getStringArray(key);
        /* 
         * Each token is of the form 'key=value'.
         */
        Properties props = new Properties(defaults);
        for (int i = 0; i < tokens.length; i++)
        {
            String token = tokens[i];
            int equalSign = token.indexOf('=');
            if (equalSign > 0)
            {
                String pkey = token.substring(0, equalSign).trim();
                String pvalue = token.substring(equalSign + 1).trim();
                props.put(pkey, pvalue);
            }
            else
            {
                throw new IllegalArgumentException('\'' + token +
                                                   ""' does not contain "" +
                                                   ""an equals sign"");
            }
        }
        return props;
    }
    /**
     * Get an array of strings associated with the given configuration
     * key.
     *
     * @param key The configuration key.
     * @return The associated string array if key is found.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a String/Vector.
     */
    public String[] getStringArray(String key)
    {
        Object value = get(key);
        // What's your vector, Victor?
        Vector vector;
        if (value instanceof String)
        {
            vector = new Vector(1);
            vector.addElement(value);
        }
        else if (value instanceof Vector)
        {
            vector = (Vector)value;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getStringArray(key);
            }
            else
            {
                return new String[0];
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a String/Vector object"");
        }
        String[] tokens = new String[vector.size()];
        for (int i = 0; i < tokens.length; i++)
        {
            tokens[i] = (String)vector.elementAt(i);
        }
        return tokens;
    }
    /**
     * Get a Vector of strings associated with the given configuration
     * key.
     *
     * @param key The configuration key.
     * @return The associated Vector.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Vector.
     */
    public Vector getVector(String key)
    {
        return getVector(key, null);
    }
    /**
     * Get a Vector of strings associated with the given configuration
     * key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated Vector.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Vector.
     */
    public Vector getVector(String key,
                            Vector defaultValue)
    {
        Object value = get(key);
        if (value instanceof Vector)
        {
            return (Vector) value;
        }
        else if (value instanceof String)
        {
            Vector v = new Vector(1);
            v.addElement((String) value);
            put(key, v);
            return v;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getVector(key, defaultValue);
            }
            else
            {
                return ((defaultValue == null) ?
                        new Vector() : defaultValue);
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Vector object"");
        }
    }
    /**
     * Get a boolean associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated boolean.
     * @exception NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Boolean.
     */
    public boolean getBoolean(String key)
    {
        Boolean b = getBoolean(key, (Boolean) null);
        if (b != null)
        {
            return b.booleanValue();
        }
        else
        {
            throw new NoSuchElementException(
                '\'' + key + ""' doesn't map to an existing object"");
        }
    }
    /**
     * Get a boolean associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated boolean.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Boolean.
     */
    public boolean getBoolean(String key, boolean defaultValue)
    {
        return getBoolean(key, new Boolean(defaultValue)).booleanValue();
    }
    /**
     * Get a boolean associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated boolean if key is found and has valid
     * format, default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Boolean.
     */
    public Boolean getBoolean(String key, Boolean defaultValue)
    {
        Object value = get(key);
        if (value instanceof Boolean)
        {
            return (Boolean) value;
        }
        else if (value instanceof String)
        {
            String s = testBoolean((String)value);
            Boolean b = new Boolean(s);
            put(key, b);
            return b;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getBoolean(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Boolean object"");
        }
    }
    /**
     * Test whether the string represent by value maps to a boolean
     * value or not. We will allow <code>true</code>, <code>on</code>,
     * and <code>yes</code> for a <code>true</code> boolean value, and
     * <code>false</code>, <code>off</code>, and <code>no</code> for
     * <code>false</code> boolean values.  Case of value to test for
     * boolean status is ignored.
     *
     * @param String The value to test for boolean state.
     * @return <code>true</code> or <code>false</code> if the supplied
     * text maps to a boolean value, or <code>null</code> otherwise.
     */
    public String testBoolean(String value)
    {
        String s = ((String)value).toLowerCase();
        if (s.equals(""true"") || s.equals(""on"") || s.equals(""yes""))
        {
            return ""true"";
        }
        else if (s.equals(""false"") || s.equals(""off"") || s.equals(""no""))
        {
            return ""false"";
        }
        else
        {
            return null;
        }
    }
    /**
     * Get a byte associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated byte.
     * @exception NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Byte.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public byte getByte(String key)
    {
        Byte b = getByte(key, null);
        if (b != null)
        {
            return b.byteValue();
        }
        else
        {
            throw new NoSuchElementException(
                '\'' + key + "" doesn't map to an existing object"");
        }
    }
    /**
     * Get a byte associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated byte.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Byte.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public byte getByte(String key,
                        byte defaultValue)
    {
        return getByte(key, new Byte(defaultValue)).byteValue();
    }
    /**
     * Get a byte associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated byte if key is found and has valid
     * format, default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Byte.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Byte getByte(String key,
                        Byte defaultValue)
    {
        Object value = get(key);
        if (value instanceof Byte)
        {
            return (Byte) value;
        }
        else if (value instanceof String)
        {
            Byte b = new Byte((String) value);
            put(key, b);
            return b;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getByte(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Byte object"");
        }
    }
    /**
     * Get a short associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated short.
     * @exception NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Short.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public short getShort(String key)
    {
        Short s = getShort(key, null);
        if (s != null)
        {
            return s.shortValue();
        }
        else
        {
            throw new NoSuchElementException(
                '\'' + key + ""' doesn't map to an existing object"");
        }
    }
    /**
     * Get a short associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated short.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Short.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public short getShort(String key,
                          short defaultValue)
    {
        return getShort(key, new Short(defaultValue)).shortValue();
    }
    /**
     * Get a short associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated short if key is found and has valid
     * format, default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Short.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Short getShort(String key,
                          Short defaultValue)
    {
        Object value = get(key);
        if (value instanceof Short)
        {
            return (Short) value;
        }
        else if (value instanceof String)
        {
            Short s = new Short((String) value);
            put(key, s);
            return s;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getShort(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Short object"");
        }
    }
    /**
     * The purpose of this method is to get the configuration resource
     * with the given name as an integer.
     *
     * @param name The resource name.
     * @return The value of the resource as an integer.
     */
    public int getInt(String name)
    {
        return getInteger(name);
    }
    /**
     * The purpose of this method is to get the configuration resource
     * with the given name as an integer, or a default value.
     *
     * @param name The resource name
     * @param def The default value of the resource.
     * @return The value of the resource as an integer.
     */
    public int getInt(String name,
                      int def)
    {
        return getInteger(name, def);
    }
    /**
     * Get a int associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated int.
     * @exception NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Integer.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public int getInteger(String key)
    {
        Integer i = getInteger(key, null);
        if (i != null)
        {
            return i.intValue();
        }
        else
        {
            throw new NoSuchElementException(
                '\'' + key + ""' doesn't map to an existing object"");
        }
    }
    /**
     * Get a int associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated int.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Integer.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public int getInteger(String key,
                          int defaultValue)
    {    
        Integer i = getInteger(key, null);
        if (i == null)
        {
            return defaultValue;
        }
        return i.intValue();
      }
    /**
     * Get a int associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated int if key is found and has valid
     * format, default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Integer.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Integer getInteger(String key,
                              Integer defaultValue)
    {
        Object value = get(key);
        if (value instanceof Integer)
        {
            return (Integer) value;
        }
        else if (value instanceof String)
        {
            Integer i = new Integer((String) value);
            put(key, i);
            return i;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getInteger(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Integer object"");
        }
    }
    /**
     * Get a long associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated long.
     * @exception NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Long.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public long getLong(String key)
    {
        Long l = getLong(key, null);
        if (l != null)
        {
            return l.longValue();
        }
        else
        {
            throw new NoSuchElementException(
                '\'' + key + ""' doesn't map to an existing object"");
        }
    }
    /**
     * Get a long associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated long.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Long.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public long getLong(String key,
                        long defaultValue)
    {
        return getLong(key, new Long(defaultValue)).longValue();
    }
    /**
     * Get a long associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated long if key is found and has valid
     * format, default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Long.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Long getLong(String key,
                        Long defaultValue)
    {
        Object value = get(key);
        if (value instanceof Long)
        {
            return (Long) value;
        }
        else if (value instanceof String)
        {
            Long l = new Long((String) value);
            put(key, l);
            return l;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getLong(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Long object"");
        }
    }
    /**
     * Get a float associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated float.
     * @exception NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Float.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public float getFloat(String key)
    {
        Float f = getFloat(key, null);
        if (f != null)
        {
            return f.floatValue();
        }
        else
        {
            throw new NoSuchElementException(
                '\'' + key + ""' doesn't map to an existing object"");
        }
    }
    /**
     * Get a float associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated float.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Float.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public float getFloat(String key,
                          float defaultValue)
    {
        return getFloat(key, new Float(defaultValue)).floatValue();
    }
    /**
     * Get a float associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated float if key is found and has valid
     * format, default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Float.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Float getFloat(String key,
                          Float defaultValue)
    {
        Object value = get(key);
        if (value instanceof Float)
        {
            return (Float) value;
        }
        else if (value instanceof String)
        {
            Float f = new Float((String) value);
            put(key, f);
            return f;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getFloat(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Float object"");
        }
    }
    /**
     * Get a double associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated double.
     * @exception NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Double.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public double getDouble(String key)
    {
        Double d = getDouble(key, null);
        if (d != null)
        {
            return d.doubleValue();
        }
        else
        {
            throw new NoSuchElementException(
                '\'' + key + ""' doesn't map to an existing object"");
        }
    }
    /**
     * Get a double associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated double.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Double.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public double getDouble(String key,
                            double defaultValue)
    {
        return getDouble(key, new Double(defaultValue)).doubleValue();
    }
    /**
     * Get a double associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated double if key is found and has valid
     * format, default value otherwise.
     * @exception ClassCastException is thrown if the key maps to an
     * object that is not a Double.
     * @exception NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Double getDouble(String key,
                            Double defaultValue)
    {
        Object value = get(key);
        if (value instanceof Double)
        {
            return (Double) value;
        }
        else if (value instanceof String)
        {
            Double d = new Double((String) value);
            put(key, d);
            return d;
        }
        else if (value == null)
        {
            if (defaults != null)
            {
                return defaults.getDouble(key, defaultValue);
            }
            else
            {
                return defaultValue;
            }
        }
        else
        {
            throw new ClassCastException(
                '\'' + key + ""' doesn't map to a Double object"");
        }
    }
    /**
     * Convert a standard properties class into a configuration
     * class.
     *
     * @param Properties properties object to convert into
     *                   a Configuration object.
     *
     * @return Configuration configuration created from the
     *                      properties object.
     */
    public static Configuration convertProperties(Properties p)
    {
        Configuration c = new Configuration();
        for (Enumeration e = p.keys(); e.hasMoreElements() ; ) 
        {
            String s = (String) e.nextElement();
            c.setProperty(s, p.getProperty(s));
        }
        return c;
    }
    /**
     *  <p>
     *  Routine intended for deprecation period only
     *  as we switch from using the Configuration
     *  class in Velocity to the Jakarta Commons
     *  ExtendedProperties
     *  </p>
     *  <p>
     *  Do not use this for general use. It will disappear
     * </p>
     *  @return ExtendedProperties containing data of Configuration
     *  
     *  @deprecated Do not use.  For deprecation assistance only.
     */
    public ExtendedProperties getExtendedProperties() 
    {
        return deprecationCrutch; 
    }
}
"
org.apache.velocity.runtime.directive.Directive,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 * Base class for all directives used in Velocity.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Directive.java,v 1.18.4.1 2004/03/03 23:22:55 geirm Exp $ 
 */
public abstract class Directive implements DirectiveConstants, Cloneable
{
    private int line = 0;
    private int column = 0;
    protected RuntimeServices rsvc = null;
    /** Return the name of this directive */
    public abstract String getName();
    /** Get the directive type BLOCK/LINE */
    public abstract int getType();
    /** Allows the template location to be set */
    public void setLocation( int line, int column )
    {
        this.line = line;
        this.column = column;
    }
    /** for log msg purposes */
    public int getLine()
    {
        return line;
    }
    /** for log msg purposes */
    public int getColumn()
    {
        return column;
    }     
    /**
     * How this directive is to be initialized.
     */
    public void init( RuntimeServices rs, InternalContextAdapter context,
                      Node node)
        throws Exception
    {
        rsvc = rs;
        //        int i, k = node.jjtGetNumChildren();
        //for (i = 0; i < k; i++)
        //    node.jjtGetChild(i).init(context, rs);
    }
    /**
     * How this directive is to be rendered 
     */
    public abstract boolean render( InternalContextAdapter context, 
                                    Writer writer, Node node )       
           throws IOException, ResourceNotFoundException, ParseErrorException, 
                MethodInvocationException;
}
"
org.apache.velocity.runtime.directive.DirectiveConstants,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Base class for all directives used in Velocity.
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: DirectiveConstants.java,v 1.4.14.1 2004/03/03 23:22:55 geirm Exp $ 
 */
public interface DirectiveConstants
{
    /** Block directive indicator */
    public static final int BLOCK = 1;
    /** Line directive indicator */
    public static final int LINE = 2;
}        
"
org.apache.velocity.runtime.directive.Foreach,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.util.introspection.Info;
/**
 * Foreach directive used for moving through arrays,
 * or objects that provide an Iterator.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Foreach.java,v 1.42.4.1 2004/03/03 23:22:55 geirm Exp $
 */
public class Foreach extends Directive
{
    /**
     * Return name of this directive.
     */
    public String getName()
    {
        return ""foreach"";
    }        
    /**
     * Return type of this directive.
     */
    public int getType()
    {
        return BLOCK;
    }        
    /**
     * The name of the variable to use when placing
     * the counter value into the context. Right
     * now the default is $velocityCount.
     */
    private String counterName;
    /**
     * What value to start the loop counter at.
     */
    private int counterInitialValue;
    /**
     * The reference name used to access each
     * of the elements in the list object. It
     * is the $item in the following:
     *
     * #foreach ($item in $list)
     *
     * This can be used class wide because
     * it is immutable.
     */
    private String elementKey;
    /**
     *  immutable, so create in init
     */
    protected Info uberInfo;
    /**
     *  simple init - init the tree and get the elementKey from
     *  the AST
     */
    public void init(RuntimeServices rs, InternalContextAdapter context, Node node)
        throws Exception
    {
        super.init(rs, context, node);
        counterName = rsvc.getString(RuntimeConstants.COUNTER_NAME);
        counterInitialValue = rsvc.getInt(RuntimeConstants.COUNTER_INITIAL_VALUE);
        /*
         *  this is really the only thing we can do here as everything
         *  else is context sensitive
         */
        elementKey = node.jjtGetChild(0).getFirstToken().image.substring(1);
        /*
         * make an uberinfo - saves new's later on
         */
        uberInfo = new Info(context.getCurrentTemplateName(),
                getLine(),getColumn());
    }
    /**
     *  renders the #foreach() block
     */
    public boolean render(InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException,  MethodInvocationException, ResourceNotFoundException,
        	ParseErrorException
    {        
        /*
         *  do our introspection to see what our collection is
         */
        Object listObject = node.jjtGetChild(2).value(context);
        if (listObject == null)
             return false;
        Iterator i = null;
        try
        {
            i = rsvc.getUberspect().getIterator(listObject, uberInfo);
        }
        catch(Exception ee)
        {
            System.out.println(ee);
        }
        if (i == null)
        {
            return false;
        }
        int counter = counterInitialValue;
        /*
         *  save the element key if there is one,
         *  and the loop counter
         */
        Object o = context.get(elementKey);
        Object ctr = context.get( counterName);
        while (i.hasNext())
        {
            context.put( counterName , new Integer(counter));
            context.put(elementKey,i.next());
            node.jjtGetChild(3).render(context, writer);
            counter++;
        }
        /*
         * restores the loop counter (if we were nested)
         * if we have one, else just removes
         */
        if (ctr != null)
        {
            context.put(counterName, ctr);
        }
        else
        {
            context.remove(counterName);
        }
        /*
         *  restores element key if exists
         *  otherwise just removes
         */
        if (o != null)
        {
            context.put(elementKey, o);
        }
        else
        {
            context.remove(elementKey);
        }
        return true;
    }
}
"
org.apache.velocity.runtime.directive.Include,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 * Pluggable directive that handles the #include() statement in VTL. 
 * This #include() can take multiple arguments of either 
 * StringLiteral or Reference.
 *
 * Notes:
 * -----
 *  1) The included source material can only come from somewhere in 
 *    the TemplateRoot tree for security reasons. There is no way 
 *    around this.  If you want to include content from elsewhere on
 *    your disk, use a link from somwhere under Template Root to that 
 *    content.
 *
 *  2) By default, there is no output to the render stream in the event of
 *    a problem.  You can override this behavior with two property values :
 *       include.output.errormsg.start
 *       include.output.errormsg.end
 *     If both are defined in velocity.properties, they will be used to
 *     in the render output to bracket the arg string that caused the 
 *     problem.
 *     Ex. : if you are working in html then
 *       include.output.errormsg.start=<!-- #include error :
 *       include.output.errormsg.end= -->
 *     might be an excellent way to start...
 *
 *  3) As noted above, #include() can take multiple arguments.
 *    Ex : #include( ""foo.vm"" ""bar.vm"" $foo )
 *    will simply include all three if valid to output w/o any
 *    special separator.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:kav@kav.dk"">Kasper Nielsen</a>
 * @version $Id: Include.java,v 1.26.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class Include extends InputBase
{
    private String outputMsgStart = """";
    private String outputMsgEnd = """";
    /**
     * Return name of this directive.
     */
    public String getName()
    {
        return ""include"";
    }        
    /**
     * Return type of this directive.
     */
    public int getType()
    {
        return LINE;
    }        
    /**
     *  simple init - init the tree and get the elementKey from
     *  the AST
     */
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node) 
        throws Exception
    {
        super.init( rs, context, node );
        /*
         *  get the msg, and add the space so we don't have to
         *  do it each time
         */
        outputMsgStart = rsvc.getString(RuntimeConstants.ERRORMSG_START);
        outputMsgStart = outputMsgStart + "" "";
        outputMsgEnd = rsvc.getString(RuntimeConstants.ERRORMSG_END );
        outputMsgEnd = "" "" + outputMsgEnd;   
    }
    /**
     *  iterates through the argument list and renders every
     *  argument that is appropriate.  Any non appropriate
     *  arguments are logged, but render() continues.
     */
    public boolean render(InternalContextAdapter context, 
                           Writer writer, Node node)
        throws IOException, MethodInvocationException,
               ResourceNotFoundException
    {
        /*
         *  get our arguments and check them
         */
        int argCount = node.jjtGetNumChildren();
        for( int i = 0; i < argCount; i++)
        {
            /*
             *  we only handle StringLiterals and References right now
             */
            Node n = node.jjtGetChild(i);
            if ( n.getType() ==  ParserTreeConstants.JJTSTRINGLITERAL || 
                 n.getType() ==  ParserTreeConstants.JJTREFERENCE )
            {
                if (!renderOutput( n, context, writer ))
                    outputErrorToStream( writer, ""error with arg "" + i 
                        + "" please see log."");
            }
            else
            {
                rsvc.error(""#include() error : invalid argument type : "" 
                    + n.toString());
                outputErrorToStream( writer, ""error with arg "" + i 
                    + "" please see log."");
            }
        }
        return true;
    }
    /**
     *  does the actual rendering of the included file
     *
     *  @param node AST argument of type StringLiteral or Reference
     *  @param context valid context so we can render References
     *  @param writer output Writer
     *  @return boolean success or failure.  failures are logged
     */
    private boolean renderOutput( Node node, InternalContextAdapter context, 
                                  Writer writer )
        throws IOException, MethodInvocationException,
               ResourceNotFoundException
    {
        String arg = """";
        if ( node == null )
        {
            rsvc.error(""#include() error :  null argument"");
            return false;
        }
        /*
         *  does it have a value?  If you have a null reference, then no.
         */        
        Object value = node.value( context );
        if ( value == null)
        {
            rsvc.error(""#include() error :  null argument"");
            return false;
        }
        /*
         *  get the path
         */
        arg = value.toString();
        Resource resource = null;
        try
        {
            resource = rsvc.getContent(arg, getInputEncoding(context));
        }
        catch ( ResourceNotFoundException rnfe )
        {
       		/*
       		 * the arg wasn't found.  Note it and throw
       		 */
        	rsvc.error(""#include(): cannot find resource '"" + arg +
                       ""', called from template "" +
                       context.getCurrentTemplateName() + "" at ("" +
                       getLine() + "", "" + getColumn() + "")"" );
        	throw rnfe;
        }
        catch (Exception e)
        {
        	rsvc.error(""#include(): arg = '"" + arg +
                       ""', called from template "" +
                       context.getCurrentTemplateName() + "" at ("" +
                       getLine() + "", "" + getColumn() + "") : "" + e);
        }            
        if ( resource == null )
            return false;
        writer.write((String)resource.getData());       
        return true;
    }
    /**
     *  Puts a message to the render output stream if ERRORMSG_START / END
     *  are valid property strings.  Mainly used for end-user template
     *  debugging.
     */
    private void outputErrorToStream( Writer writer, String msg )
        throws IOException
    {        
        if ( outputMsgStart != null  && outputMsgEnd != null)
        {
            writer.write(outputMsgStart);
            writer.write(msg);
            writer.write(outputMsgEnd);
        }
        return;
    }
}
"
org.apache.velocity.runtime.directive.InputBase,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.resource.Resource;
/**
 * Base class for directives which do input operations
 * (e.g. <code>#include()</code>, <code>#parse()</code>, etc.).
 *
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @since 1.4
 */
public abstract class InputBase extends Directive
{
    /**
     * Decides the encoding used during input processing of this
     * directive.
     *
     * Get the resource, and assume that we use the encoding of the
     * current template the 'current resource' can be
     * <code>null</code> if we are processing a stream....
     *
     * @param context The context to derive the default input encoding
     * from.
     * @return The encoding to use when processing this directive.     
     */
    protected String getInputEncoding(InternalContextAdapter context)
    {
        Resource current = context.getCurrentResource();
        if (current != null)
        {
            return current.getEncoding();
        }
        else
        {
            return (String) rsvc.getProperty(RuntimeConstants.INPUT_ENCODING);
        }
    }
}
"
org.apache.velocity.runtime.directive.Literal,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.*;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * A very simple directive that leverages the Node.literal()
 * to grab the literal rendition of a node. We basically
 * grab the literal value on init(), then repeatedly use
 * that during render().
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Literal.java,v 1.7.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class Literal extends Directive
{
    String literalText;
    /**
     * Return name of this directive.
     */
    public String getName()
    {
        return ""literal"";
    }        
    /**
     * Return type of this directive.
     */
    public int getType()
    {
        return BLOCK;
    }        
    /**
     * Store the literal rendition of a node using
     * the Node.literal().
     */
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node)
        throws Exception
    {
        super.init( rs, context, node );
        literalText = node.jjtGetChild(0).literal();
    }    
    /**
     * Throw the literal rendition of the block between
     * #literal()/#end into the writer.
     */
    public boolean render( InternalContextAdapter context, 
                           Writer writer, Node node)
        throws IOException
    {
        writer.write(literalText);
        return true;
    }
}
"
org.apache.velocity.runtime.directive.Macro,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.NodeUtils;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.RuntimeServices;
/**
 *   Macro.java
 *
 *  Macro implements the macro definition directive of VTL.
 *
 *  example :
 *
 *  #macro( isnull $i )
 *     #if( $i )
 *         $i
 *      #end
 *  #end
 *
 *  This object is used at parse time to mainly process and register the 
 *  macro.  It is used inline in the parser when processing a directive.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Macro.java,v 1.16.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class Macro extends Directive
{
    private static  boolean debugMode = false;
    /**
     * Return name of this directive.
     */
    public String getName()
    {
        return ""macro"";
    }        
    /**
     * Return type of this directive.
     */
    public int getType()
    {
        return BLOCK;
    }        
    /**
     *   render() doesn't do anything in the final output rendering.
     *   There is no output from a #macro() directive.
     */
    public boolean render(InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException 
    {
        /*
         *  do nothing : We never render.  The VelocimacroProxy object does that
         */
        return true;
    }
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node)
       throws Exception
    {
        super.init(rs, context, node);
        /*
         * again, don't do squat.  We want the AST of the macro 
         * block to hang off of this but we don't want to 
         * init it... it's useless...
         */
        return;
    }
    /**
     *  Used by Parser.java to process VMs withing the parsing process
     *
     *  processAndRegister() doesn't actually render the macro to the output
     *  Processes the macro body into the internal representation used by the
     *  VelocimacroProxy objects, and if not currently used, adds it
     *  to the macro Factory
     */ 
    public static void processAndRegister(RuntimeServices rs,  Node node,
                                          String sourceTemplate)
        throws IOException, ParseException
    {
        /*
         *  There must be at least one arg to  #macro,
         *  the name of the VM.  Note that 0 following 
         *  args is ok for naming blocks of HTML
         */
        int numArgs = node.jjtGetNumChildren();
        /*
         *  this number is the # of args + 1.  The + 1
         *  is for the block tree
         */
        if (numArgs < 2) 
        {
            /*
             *  error - they didn't name the macro or
             *  define a block
             */
            rs.error(""#macro error : Velocimacro must have name as 1st "" + 
                ""argument to #macro(). #args = "" + numArgs);
            throw new MacroParseException(""First argument to #macro() must be "" +
                    "" macro name."");
        }
        /*
         *  lets make sure that the first arg is an ASTWord
         */
        int firstType = node.jjtGetChild(0).getType();
        if(firstType != ParserTreeConstants.JJTWORD)
        {
            Token t = node.jjtGetChild(0).getFirstToken();
            throw new MacroParseException(""First argument to #macro() must be a""
                    + "" token without surrounding \' or \"", which specifies""
                    + "" the macro name.  Currently it is a ""
                    + ParserTreeConstants.jjtNodeName[firstType]);
        }
        /*
         *  get the arguments to the use of the VM
         */
        String argArray[] = getArgArray(node);
        /*
         *   now, try and eat the code block. Pass the root.
         */
        List macroArray = 
            getASTAsStringArray(node.jjtGetChild(numArgs - 1));
        /*
         *  make a big string out of our macro
         */
        StringBuffer temp  = new StringBuffer();
        for (int i=0; i < macroArray.size(); i++)
        {
            temp.append(macroArray.get(i));
        }
        String macroBody = temp.toString();
        /*
         * now, try to add it.  The Factory controls permissions, 
         * so just give it a whack...
         */
        boolean bRet = rs.addVelocimacro(argArray[0], macroBody,
                        argArray, sourceTemplate);
        return;
    }
    /**
     *  creates an array containing the literal
     *  strings in the macro arguement
     */
    private static String[] getArgArray(Node node)
    {
        /*
         *  remember : this includes the block tree
         */
        int numArgs = node.jjtGetNumChildren();
        numArgs--;  // avoid the block tree...
        String argArray[] = new String[numArgs];
        int i = 0;
        /*
         *  eat the args
         */
        while (i < numArgs)
        {
            argArray[i] = node.jjtGetChild(i).getFirstToken().image;
            /*
             *  trim off the leading $ for the args after the macro name.
             *  saves everyone else from having to do it
             */
            if (i > 0)
            {
                if (argArray[i].startsWith(""$""))
                {
                    argArray[i] = argArray[i]
                        .substring(1, argArray[i].length());
                }
            }
            i++;
        }
        if (debugMode)
        {
            System.out.println(""Macro.getArgArray() : #args = "" + numArgs);
            System.out.print(argArray[0] + ""("");
            for (i = 1; i < numArgs; i++)
            {
                System.out.print("" "" + argArray[i]);
            }
            System.out.println("" )"");
        }
        return argArray;
    }
    /**
     *  Returns an array of the literal rep of the AST
     */
    private static List getASTAsStringArray(Node rootNode)
    {
        /*
         *  this assumes that we are passed in the root 
         *  node of the code block
         */
        Token t = rootNode.getFirstToken();
        Token tLast = rootNode.getLastToken();
        /*
         *  now, run down the part of the tree bounded by
         *  our first and last tokens
         */
        ArrayList list = new ArrayList();
        t = rootNode.getFirstToken();
        while (t != tLast)
        {
            list.add(NodeUtils.tokenLiteral(t));
            t = t.next;
        }
        /*
         *  make sure we get the last one...
         */
        list.add(NodeUtils.tokenLiteral(t));
        return list;
    }
}
"
org.apache.velocity.runtime.directive.MacroParseException,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.ParseException;
/**
 *  Exception to indicate problem happened while constructing #macro()
 *
 *  For internal use in parser - not to be passed to app level
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: MacroParseException.java,v 1.1.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class MacroParseException extends ParseException
{
    public MacroParseException(String msg)
    {
        super(msg);
    }
}
"
org.apache.velocity.runtime.directive.Parse,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 * Pluggable directive that handles the <code>#parse()</code>
 * statement in VTL.
 *
 * <pre>
 * Notes:
 * -----
 *  1) The parsed source material can only come from somewhere in 
 *    the TemplateRoot tree for security reasons. There is no way 
 *    around this.  If you want to include content from elsewhere on
 *    your disk, use a link from somwhere under Template Root to that 
 *    content.
 *
 *  2) There is a limited parse depth.  It is set as a property 
 *    ""parse_directive.maxdepth = 10""  for example.  There is a 20 iteration
 *    safety in the event that the parameter isn't set.
 * </pre>
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @version $Id: Parse.java,v 1.27.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class Parse extends InputBase
{
    private boolean ready = false;
    /**
     * Return name of this directive.
     */
    public String getName()
    {
        return ""parse"";
    }        
    /**
     * Return type of this directive.
     */
    public int getType()
    {
        return LINE;
    }        
    /**
     *  iterates through the argument list and renders every
     *  argument that is appropriate.  Any non appropriate
     *  arguments are logged, but render() continues.
     */
    public boolean render( InternalContextAdapter context, 
                           Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException,
               MethodInvocationException
    {
        /*
         *  did we get an argument?
         */
        if ( node.jjtGetChild(0) == null)
        {
            rsvc.error( ""#parse() error :  null argument"" );
            return false;
        }
        /*
         *  does it have a value?  If you have a null reference, then no.
         */
        Object value =  node.jjtGetChild(0).value( context );
        if ( value == null)
        {
            rsvc.error( ""#parse() error :  null argument"" );
            return  false;
        }
        /*
         *  get the path
         */
        String arg = value.toString();
        /*
         *   see if we have exceeded the configured depth.
         *   If it isn't configured, put a stop at 20 just in case.
         */
        Object[] templateStack = context.getTemplateNameStack();
        if ( templateStack.length >= 
                rsvc.getInt(RuntimeConstants.PARSE_DIRECTIVE_MAXDEPTH, 20) )
        {
            StringBuffer path = new StringBuffer();
            for( int i = 0; i < templateStack.length; ++i)
            {
                path.append( "" > "" + templateStack[i] );
            }
            rsvc.error( ""Max recursion depth reached ("" + 
                templateStack.length + "")""  + "" File stack:"" + path );
            return false;
        }
        /*
         *  now use the Runtime resource loader to get the template
         */
        Template t = null;
        try 
        {
            t = rsvc.getTemplate( arg, getInputEncoding(context) );
        }
        catch ( ResourceNotFoundException rnfe )
        {
       		/*
       		 * the arg wasn't found.  Note it and throw
       		 */
        	rsvc.error(""#parse(): cannot find template '"" + arg +
                       ""', called from template "" +
                       context.getCurrentTemplateName() + "" at ("" +
                       getLine() + "", "" + getColumn() + "")"" );
        	throw rnfe;
        }
        catch ( ParseErrorException pee )
        {
        	/*
        	 * the arg was found, but didn't parse - syntax error
        	 *  note it and throw
        	 */
        	rsvc.error(""#parse(): syntax error in #parse()-ed template '"" +
                       arg + ""', called from template "" +
                       context.getCurrentTemplateName() + "" at ("" +
                       getLine() + "", "" + getColumn() + "")"" );
        	throw pee;
        } 
        catch ( Exception e)
        {	
        	rsvc.error(""#parse() : arg = "" + arg + "".  Exception : "" + e);
            return false;
        }
        /*
         *  and render it
         */
        try
        {
            context.pushCurrentTemplateName(arg);
            ((SimpleNode) t.getData()).render( context, writer );
        }
        catch ( Exception e )
        {        
            /*
             *  if it's a MIE, it came from the render.... throw it...
             */
            if ( e instanceof MethodInvocationException)
            {
                throw (MethodInvocationException) e;
            }
            rsvc.error( ""Exception rendering #parse( "" + arg + "" )  : "" + e );
            return false;
        }
        finally
        {
            context.popCurrentTemplateName();
        }
        return true;
    }
}
"
org.apache.velocity.runtime.directive.ParseDirectiveException,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Stack;
/**
 * Exception for #parse() problems
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ParseDirectiveException.java,v 1.4.14.1 2004/03/03 23:22:56 geirm Exp $
 */
public class ParseDirectiveException extends Exception
{
    private Stack filenameStack = new Stack();
    private String msg = """";
    private int depthCount = 0;
    /**
     * Constructor
     */
    ParseDirectiveException( String m, int i )
    {
        msg = m;
        depthCount = i;
    }
    /**
     * Get a message.
     */
    public String getMessage()
    {
        String returnStr  =  ""#parse() exception : depth = "" + 
            depthCount + "" -> "" + msg;
        returnStr += "" File stack : "";
        try
        {
            while( !filenameStack.empty())
            {
                returnStr += (String) filenameStack.pop();
                returnStr += "" -> "";
            }
        }
        catch( Exception e)
        {
        }
        return returnStr;
    }
    /**
     * Add a file to the filename stack
     */
    public void addFile( String s )
    {
        filenameStack.push( s );
    }
}
"
org.apache.velocity.runtime.directive.VelocimacroProxy,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.StringReader;
import java.util.HashMap;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.context.VMContext;
import org.apache.velocity.runtime.visitor.VMReferenceMungeVisitor;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.exception.MethodInvocationException;
/**
 *  VelocimacroProxy.java
 *
 *   a proxy Directive-derived object to fit with the current directive system
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelocimacroProxy.java,v 1.27.4.1 2004/03/03 23:22:56 geirm Exp $ 
 */
public class VelocimacroProxy extends Directive
{
    private String macroName = """";
    private String macroBody = """";
    private String[] argArray = null;
    private SimpleNode nodeTree = null;
    private int numMacroArgs = 0;
    private String namespace = """";
    private boolean init = false;
    private String[] callingArgs;
    private int[]  callingArgTypes;
    private HashMap proxyArgHash = new HashMap();
    /**
     * Return name of this Velocimacro.
     */
    public String getName() 
    { 
        return  macroName; 
    }
    /**
     * Velocimacros are always LINE
     * type directives.
     */
    public int getType()
    { 
        return LINE; 
    }
    /**
     *   sets the directive name of this VM
     */
    public void setName( String name )
    {
        macroName = name;
    }
    /**
     *  sets the array of arguments specified in the macro definition
     */
    public void setArgArray( String [] arr )
    {
        argArray = arr;
        /*
         *  get the arg count from the arg array.  remember that the arg array 
         *  has the macro name as it's 0th element
         */
        numMacroArgs = argArray.length - 1;
    }
    public void setNodeTree( SimpleNode tree )
    {
        nodeTree = tree;
    }
    /**
     *  returns the number of ars needed for this VM
     */
    public int getNumArgs()
    {
        return numMacroArgs;
    }
    /**
     *   Sets the orignal macro body.  This is simply the cat of the macroArray, but the 
     *   Macro object creates this once during parsing, and everyone shares it.
     *   Note : it must not be modified.
     */
    public void setMacrobody( String mb )
    {
        macroBody = mb;
    }
    public void setNamespace( String ns )
    {
        this.namespace = ns;
    }
    /**
     *   Renders the macro using the context
     */
    public boolean render( InternalContextAdapter context, Writer writer, Node node)
        throws IOException, MethodInvocationException
    {
        try 
        {
            /*
             *  it's possible the tree hasn't been parsed yet, so get 
             *  the VMManager to parse and init it
             */
            if (nodeTree != null)
            {
                if ( !init )
                {
                    nodeTree.init( context, rsvc);
                    init = true;
                }
                /*
                 *  wrap the current context and add the VMProxyArg objects
                 */
                VMContext vmc = new VMContext( context, rsvc );
                for( int i = 1; i < argArray.length; i++)
                {
                    /*
                     *  we can do this as VMProxyArgs don't change state. They change
                     *  the context.
                     */
                    VMProxyArg arg = (VMProxyArg) proxyArgHash.get( argArray[i] ); 
                    vmc.addVMProxyArg( arg );
                }
                /*
                 *  now render the VM
                 */
                nodeTree.render( vmc, writer );               
            }
            else
            {
                rsvc.error( ""VM error : "" + macroName + "". Null AST"");
            }
        } 
        catch ( Exception e ) 
        {
            /*
             *  if it's a MIE, it came from the render.... throw it...
             */
            if ( e instanceof MethodInvocationException)
            {
                throw (MethodInvocationException) e;
            }
            rsvc.error(""VelocimacroProxy.render() : exception VM = #"" + macroName + 
            ""() : ""  + StringUtils.stackTrace(e));
        }
        return true;
    }
    /**
     *   The major meat of VelocimacroProxy, init() checks the # of arguments, patches the
     *   macro body, renders the macro into an AST, and then inits the AST, so it is ready 
     *   for quick rendering.  Note that this is only AST dependant stuff. Not context.
     */
    public void init( RuntimeServices rs, InternalContextAdapter context, Node node) 
       throws Exception
    {
        super.init( rs, context, node );
        /*
         *  how many args did we get?
         */
        int i  = node.jjtGetNumChildren();
        /*
         *  right number of args?
         */        
        if ( getNumArgs() != i ) 
        {
            rsvc.error(""VM #"" + macroName + "": error : too "" 
                       + ( (getNumArgs() > i) ? ""few"" : ""many"") + "" arguments to macro. Wanted "" 
                       + getNumArgs() + "" got "" + i );
            return;
        }
        /*
         *  get the argument list to the instance use of the VM
         */
         callingArgs = getArgArray( node );
        /*
         *  now proxy each arg in the context
         */
         setupMacro( callingArgs, callingArgTypes );
         return;
    }
    /**
     *  basic VM setup.  Sets up the proxy args for this
     *  use, and parses the tree
     */
    public boolean setupMacro( String[] callArgs, int[] callArgTypes )
    {
        setupProxyArgs( callArgs, callArgTypes );
        parseTree( callArgs );
        return true;
    }
    /**
     *   parses the macro.  We need to do this here, at init time, or else
     *   the local-scope template feature is hard to get to work :)
     */
    private void parseTree( String[] callArgs )
    {
        try 
        {                
            BufferedReader br = new BufferedReader( new StringReader( macroBody ) );
            /*
             *  now parse the macro - and don't dump the namespace
             */
            nodeTree = rsvc.parse( br, namespace, false );
            /*
             *  now, to make null references render as proper schmoo
             *  we need to tweak the tree and change the literal of
             *  the appropriate references
             *
             *  we only do this at init time, so it's the overhead
             *  is irrelevant
             */
            HashMap hm = new HashMap();
            for( int i = 1; i < argArray.length; i++)
            {
                String arg = callArgs[i-1];
                /*
                 *  if the calling arg is indeed a reference
                 *  then we add to the map.  We ignore other
                 *  stuff
                 */
                if (arg.charAt(0) == '$')
                {
                    hm.put( argArray[i], arg );
                }
            }
            /*
             *  now make one of our reference-munging visitor, and 
             *  let 'er rip
             */
            VMReferenceMungeVisitor v = new VMReferenceMungeVisitor( hm );
            nodeTree.jjtAccept( v, null );
        } 
        catch ( Exception e ) 
        {
            rsvc.error(""VelocimacroManager.parseTree() : exception "" + macroName + 
                          "" : ""  + StringUtils.stackTrace(e));
        }
    }
    private void setupProxyArgs( String[] callArgs, int [] callArgTypes )
    {
        /*
         * for each of the args, make a ProxyArg
         */
        for( int i = 1; i < argArray.length; i++)
        {
            VMProxyArg arg = new VMProxyArg( rsvc, argArray[i], callArgs[i-1], callArgTypes[i-1] );
            proxyArgHash.put( argArray[i], arg );
        }
    }
    /**
     *   gets the args to the VM from the instance-use AST
     */
    private String[] getArgArray( Node node )
    {
        int numArgs = node.jjtGetNumChildren();
        String args[] = new String[ numArgs ];
        callingArgTypes = new int[numArgs];
        /*
         *  eat the args
         */
        int i = 0;
        Token t = null;
        Token tLast = null;
        while( i <  numArgs ) 
        {
            args[i] = """";
            /*
             *  we want string literalss to lose the quotes.  #foo( ""blargh"" ) should have 'blargh' patched 
             *  into macro body.  So for each arg in the use-instance, treat the stringlierals specially...
             */
            callingArgTypes[i] = node.jjtGetChild(i).getType();
            if (false &&  node.jjtGetChild(i).getType() == ParserTreeConstants.JJTSTRINGLITERAL )
            {
                args[i] += node.jjtGetChild(i).getFirstToken().image.substring(1, node.jjtGetChild(i).getFirstToken().image.length() - 1);
            }
            else
            {
                /*
                 *  just wander down the token list, concatenating everything together
                 */
                t = node.jjtGetChild(i).getFirstToken();
                tLast = node.jjtGetChild(i).getLastToken();
                while( t != tLast ) 
                {
                    args[i] += t.image;
                    t = t.next;
                }
                /*
                 *  don't forget the last one... :)
                 */
                args[i] += t.image;
            }
            i++;
         }
        return args;
    }
}
"
org.apache.velocity.runtime.directive.VMProxyArg,"package org.apache.velocity.runtime.directive;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.StringWriter;
import java.io.StringReader;
import java.io.BufferedReader;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.context.InternalContextAdapterImpl;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.ASTReference;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.VelocityContext;
/**
 *  The function of this class is to proxy for the calling parameter to the VM.
 *
 *  This class is designed to be used in conjunction with the VMContext class
 *  which knows how to get and set values via it, rather than a simple get()
 *  or put() from a hashtable-like object.
 *
 *  There is probably a lot of undocumented subtlty here, so step lightly.
 *
 *  We rely on the observation that an instance of this object has a constant
 *  state throughout its lifetime as it's bound to the use-instance of a VM.
 *  In other words, it's created by the VelocimacroProxy class, to represent
 *  one of the arguments to a VM in a specific template.  Since the template
 *  is fixed (it's a file...), we don't have to worry that the args to the VM
 *  will change.  Yes, the VM will be called in other templates, or in other 
 *  places on the same template, bit those are different use-instances.
 *
 *  These arguments can be, in the lingo of
 *  the parser, one of :
 *   <ul>
 *   <li> Reference() : anything that starts with '$'
 *   <li> StringLiteral() : something like ""$foo"" or ""hello geir""
 *   <li> NumberLiteral() : 1, 2 etc
 *   <li> IntegerRange() : [ 1..2] or [$foo .. $bar]
 *   <li> ObjectArray() : [ ""a"", ""b"", ""c""]
 *   <li> True() : true
 *   <li> False() : false
 *    <li>Word() : not likely - this is simply allowed by the parser so we can have
 *             syntactical sugar like #foreach($a in $b)  where 'in' is the Word  
 *    </ul>
 *  Now, Reference(), StringLit, NumberLit, IntRange, ObjArr are all dynamic things, so 
 *  their value is gotten with the use of a context.  The others are constants.  The trick
 *  we rely on is that the context rather than this class really represents the 
 *  state of the argument. We are simply proxying for the thing, returning the proper value 
 *  when asked, and storing the proper value in the appropriate context when asked.
 *
 *  So, the hope here, so an instance of this can be shared across threads, is to
 *  keep any dynamic stuff out of it, relying on trick of having the appropriate 
 *  context handed to us, and when a constant argument, letting VMContext punch that 
 *  into a local context.
 *  
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: VMProxyArg.java,v 1.13.4.1 2004/03/03 23:22:56 geirm Exp $ 
 */
public class VMProxyArg
{
    /**  type of arg I will have */
    private int type = 0;
    /**  the AST if the type is such that it's dynamic (ex. JJTREFERENCE ) */
    private SimpleNode nodeTree = null;
    /**  reference for the object if we proxy for a static arg like an NumberLiteral */
    private Object staticObject = null;
    /** not used in this impl : carries the appropriate user context */
    private InternalContextAdapter usercontext = null;
    /** number of children in our tree if a reference */
    private int numTreeChildren = 0;
    /** our identity in the current context */
    private String contextReference = null;
    /** the reference we are proxying for  */
    private String callerReference = null;
    /** the 'de-dollared' reference if we are a ref but don't have a method attached */
    private String singleLevelRef = null;
    /** by default, we are dynamic.  safest */
    private boolean constant = false;
    /** in the event our type is switched - we don't care really what it is */
    private final int GENERALSTATIC = -1;
    private RuntimeServices rsvc = null;
    /**
     *  ctor for current impl 
     *
     *  takes the reference literal we are proxying for, the literal 
     *  the VM we are for is called with...
     *
     *  @param contextRef reference arg in the definition of the VM, used in the VM
     *  @param callerRef  reference used by the caller as an arg to the VM
     *  @param t  type of arg : JJTREFERENCE, JJTTRUE, etc
     */
    public VMProxyArg( RuntimeServices rs, String contextRef, String callerRef, int t )
    {
        rsvc = rs;
        contextReference = contextRef;
        callerReference = callerRef;
        type = t;
        /*
         *  make our AST if necessary
         */
        setup();
        /*
         *  if we are multi-node tree, then save the size to 
         *  avoid fn call overhead 
         */
        if( nodeTree != null)
            numTreeChildren = nodeTree.jjtGetNumChildren();
        /*
         *  if we are a reference, and 'scalar' (i.e. $foo )
         *  then get the de-dollared ref so we can
         *  hit our context directly, avoiding the AST
         */
        if ( type == ParserTreeConstants.JJTREFERENCE )
        {
            if ( numTreeChildren == 0)
            {
                /*
                 * do this properly and use the Reference node
                 */
                 singleLevelRef = ((ASTReference) nodeTree).getRootString();
            }
        }
    }
    /**
     *  tells if arg we are poxying for is
     *  dynamic or constant.
     *
     *  @return true of constant, false otherwise
     */
    public boolean isConstant()
    {
        return constant;
    }
    /**
     *  Invoked by VMContext when Context.put() is called for a proxied reference.
     *
     *  @param context context to modify via direct placement, or AST.setValue()
     *  @param o  new value of reference
     *  @return Object currently null
     */
    public Object setObject(  InternalContextAdapter context,  Object o )
    {  
        /*
         *  if we are a reference, we could be updating a property
         */
        if( type == ParserTreeConstants.JJTREFERENCE )
        {
            if( numTreeChildren > 0)
            {
                /*
                 *  we are a property, and being updated such as
                 *  #foo( $bar.BangStart) 
                 */
                try
                {
                    ( (ASTReference) nodeTree).setValue( context, o );
                }
                catch( MethodInvocationException mie )
                {
                    rsvc.error(""VMProxyArg.getObject() : method invocation error setting value : "" + mie );                    
                }
           }
            else
            {
                /*
                 *  we are a 'single level' reference like $foo, so we can set
                 *  out context directly
                 */
                context.put( singleLevelRef, o);
                // alternate impl : usercontext.put( singleLevelRef, o);
             }
        }
        else
        {
            /*
             *  if we aren't a reference, then we simply switch type, 
             *  get a new value, and it doesn't go into the context
             *
             *  in current impl, this shouldn't happen.
             */
            type = GENERALSTATIC;
            staticObject = o;
            rsvc.error(""VMProxyArg.setObject() : Programmer error : I am a constant!  No setting! : ""
                               + contextReference + "" / "" + callerReference);
        }
        return null;
    }
    /**
     *  returns the value of the reference.  Generally, this is only
     *  called for dynamic proxies, as the static ones should have
     *  been stored in the VMContext's localcontext store
     *
     *  @param context Context to use for getting current value
     *  @return Object value
     *
     */
    public Object getObject( InternalContextAdapter context )
    {        
        try
        {
            /*
             *  we need to output based on our type
             */
            Object retObject = null;
            if ( type == ParserTreeConstants.JJTREFERENCE ) 
            {                
                /*
                 *  two cases :  scalar reference ($foo) or multi-level ($foo.bar....)
                 */
                if ( numTreeChildren == 0)
                {      
                    /*
                     *  if I am a single-level reference, can I not get get it out of my context?
                     */
                    retObject = context.get( singleLevelRef );
                }
                else
                {
                    /*
                     *  I need to let the AST produce it for me.
                     */
                    retObject = nodeTree.execute( null, context);
                }
            }
            else if( type == ParserTreeConstants.JJTOBJECTARRAY )
            {
                retObject = nodeTree.value( context );
            }
            else if ( type == ParserTreeConstants.JJTINTEGERRANGE)
            {
                retObject = nodeTree.value( context );    
            }
            else if( type == ParserTreeConstants.JJTTRUE )
            {
                retObject = staticObject;
            }
            else if ( type == ParserTreeConstants.JJTFALSE )
            {
                retObject = staticObject;
            }
            else if ( type == ParserTreeConstants.JJTSTRINGLITERAL )
            {
                retObject =  nodeTree.value( context );
            }
            else if ( type == ParserTreeConstants.JJTNUMBERLITERAL )
            {
                retObject = staticObject;
            }
            else if ( type == ParserTreeConstants.JJTTEXT )
            {
                /*
                 *  this really shouldn't happen.  text is just a thowaway arg for #foreach()
                 */
                try 
                {
                    StringWriter writer =new StringWriter();
                    nodeTree.render( context, writer );
                    retObject = writer;
                }
                catch (Exception e )
                {
                    rsvc.error(""VMProxyArg.getObject() : error rendering reference : "" + e );
                }
            }
            else if( type ==  GENERALSTATIC )
            {
                retObject = staticObject;
            }
            else
            {
                rsvc.error(""Unsupported VM arg type : VM arg = "" + callerReference +"" type = "" + type + ""( VMProxyArg.getObject() )"");
            }
            return retObject;
        }
        catch( MethodInvocationException mie )
        {
            /*
             *  not ideal, but otherwise we propogate out to the 
             *  VMContext, and the Context interface's put/get 
             *  don't throw. So this is a the best compromise
             *  I can think of
             */
            rsvc.error(""VMProxyArg.getObject() : method invocation error getting value : "" + mie );
            return null;
        }
    }
    /**
     *  does the housekeeping upon creationg.  If a dynamic type
     *  it needs to make an AST for further get()/set() operations
     *  Anything else is constant.
     */
    private void setup()
    {
        switch( type ) {
        case ParserTreeConstants.JJTINTEGERRANGE :
        case ParserTreeConstants.JJTREFERENCE :
        case ParserTreeConstants.JJTOBJECTARRAY :
        case ParserTreeConstants.JJTSTRINGLITERAL :
        case ParserTreeConstants.JJTTEXT :
            {
                /*
                 *  dynamic types, just render
                 */
                constant = false;
                try
                {
                    /*
                     *  fakie : wrap in  directive to get the parser to treat our args as args
                     *   it doesn't matter that #include() can't take all these types, because we 
                     *   just want the parser to consider our arg as a Directive/VM arg rather than
                     *   as if inline in schmoo
                     */
                    String buff =""#include("" + callerReference + "" ) "";
                    //ByteArrayInputStream inStream = new ByteArrayInputStream( buff.getBytes() );
                    BufferedReader br = new BufferedReader( new StringReader( buff ) );
                    nodeTree = rsvc.parse(br, ""VMProxyArg:"" + callerReference, true);
                    /*
                     *  now, our tree really is the first DirectiveArg(), and only one
                     */
                    nodeTree = (SimpleNode) nodeTree.jjtGetChild(0).jjtGetChild(0);
                    /*
                     * sanity check
                     */
                    if ( nodeTree != null && nodeTree.getType() != type )
                    {
                        rsvc.error( ""VMProxyArg.setup() : programmer error : type doesn't match node type."");
                    }
                    /*
                     *  init.  be a good citizen and give it an ICA
                     */
                    InternalContextAdapter ica
                            = new InternalContextAdapterImpl(new VelocityContext());
                    ica.pushCurrentTemplateName(""VMProxyArg : ""
                            + ParserTreeConstants.jjtNodeName[type]);
                    nodeTree.init(ica, rsvc);
                } 
                catch ( Exception e ) 
                {
                    rsvc.error(""VMProxyArg.setup() : exception "" + callerReference + 
                                  "" : ""  + StringUtils.stackTrace(e));
                }
                break;
            }
        case ParserTreeConstants.JJTTRUE :
            {
                constant = true;
                staticObject = new  Boolean(true);
                break;
            }
        case ParserTreeConstants.JJTFALSE :
            {
                constant = true;
                staticObject =  new Boolean(false);
                break;
            }
        case ParserTreeConstants.JJTNUMBERLITERAL :
            {
                constant = true;
                staticObject = new Integer(callerReference);
                break;
            }
      case ParserTreeConstants.JJTWORD :
          {
              /*
               *  this is technically an error...
               */
              rsvc.error(""Unsupported arg type : "" + callerReference
                            + ""  You most likely intended to call a VM with a string literal, so enclose with ' or \"" characters. (VMProxyArg.setup())"");
              constant = true;
              staticObject = new String( callerReference );
              break;
          }
        default :
            {
                 rsvc.error("" VMProxyArg.setup() : unsupported type : "" 
                                    + callerReference  );
            }
        }
    }
    /*
     * CODE FOR ALTERNATE IMPL : please ignore.  I will remove when confortable with current.
     */
    /**
     *  not used in current impl
     *
     *  Constructor for alternate impl where VelProxy class would make new
     *  VMProxyArg objects, and use this contructor to avoid reparsing the 
     *  reference args
     *
     *  that impl also had the VMProxyArg carry it's context
     */
    public VMProxyArg( VMProxyArg model, InternalContextAdapter c )
    {
        usercontext = c;
        contextReference = model.getContextReference();
        callerReference = model.getCallerReference();
        nodeTree = model.getNodeTree();
        staticObject = model.getStaticObject();
        type = model.getType();
       if( nodeTree != null)
            numTreeChildren = nodeTree.jjtGetNumChildren();
        if ( type == ParserTreeConstants.JJTREFERENCE )
        {
            if ( numTreeChildren == 0)
            {
                /*
                 *  use the reference node to do this...
                 */
                singleLevelRef = ((ASTReference) nodeTree).getRootString();
            }
        }
    }
    public String getCallerReference()
    {
        return callerReference;
    }
    public String getContextReference()
    {
        return contextReference;
    }
    public SimpleNode getNodeTree()
    {
        return nodeTree;
    }
    public Object getStaticObject()
    {
        return staticObject;
    }
    public int getType()
    {
        return type;
    }
}
"
org.apache.velocity.runtime.exception.NodeException,"package org.apache.velocity.runtime.exception;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.node.Node;
public class NodeException extends Exception
{
    public NodeException(String exceptionMessage, Node node)
    {
        super(exceptionMessage + "": "" + node.literal() + 
                "" [line "" + node.getLine() + "",column "" +
                    node.getColumn() + ""]"");
    }        
}
"
org.apache.velocity.runtime.exception.ReferenceException,"package org.apache.velocity.runtime.exception;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.node.Node;
/**
 * Exception thrown when a bad reference is found.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ReferenceException.java,v 1.5.14.1 2004/03/03 23:22:56 geirm Exp $ 
 */
public class ReferenceException extends Exception
{
    public ReferenceException(String exceptionMessage, Node node)
    {
        super(exceptionMessage + "" [line "" + node.getLine() + "",column "" +
                    node.getColumn() + ""] : "" + node.literal() + 
            "" is not a valid reference."");
    }        
}
"
org.apache.velocity.runtime.log.AvalonLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import org.apache.log.Priority;
import org.apache.log.Logger;
import org.apache.log.Hierarchy;
import org.apache.log.LogTarget;
import org.apache.log.output.io.FileTarget;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
/**
 * Implementation of a Avalon logger.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: AvalonLogSystem.java,v 1.12.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class AvalonLogSystem implements LogSystem
{
    private Logger logger = null;
    private RuntimeServices rsvc = null;
    /**
     *  default CTOR.  Initializes itself using the property RUNTIME_LOG
     *  from the Velocity properties
     */
    public AvalonLogSystem()
    {
    }
    public void init( RuntimeServices rs )
        throws Exception
    {
        this.rsvc = rs;
        /*
         *  if a logger is specified, we will use this instead of
         *  the default
         */
        String loggerName = (String) rsvc.getProperty(""runtime.log.logsystem.avalon.logger"");
        if (loggerName != null)
        {
            this.logger = Hierarchy.getDefaultHierarchy().getLoggerFor(loggerName);
        } 
        else 
        {
            /*
             *  since this is a Velocity-provided logger, we will
             *  use the Runtime configuration
             */
            String logfile = (String) rsvc.getProperty( RuntimeConstants.RUNTIME_LOG );
            /*
             *  now init.  If we can't, panic!
             */
            try
            {
                init( logfile );
                logVelocityMessage( 0,
                    ""AvalonLogSystem initialized using logfile '"" + logfile + ""'"" );
            }
            catch( Exception e )
            {
                System.out.println(
                    ""PANIC : Error configuring AvalonLogSystem : "" + e );
                System.err.println(
                    ""PANIC : Error configuring AvalonLogSystem : "" + e );
                throw new Exception(""Unable to configure AvalonLogSystem : "" + e );
            }
        }
    }
    /**
     *  initializes the log system using the logfile argument
     *
     *  @param logFile   file for log messages
     */
    public void init(String logFile)
        throws Exception
    {
	/*
	 *  make our FileTarget.  Note we are going to keep the 
	 *  default behavior of not appending...
	 */
        FileTarget target = new FileTarget( new File( logFile), 
					    false, 
					    new VelocityFormatter(""%{time} %{message}\\n%{throwable}"" ) );
        /*
         *  use the toString() of RuntimeServices to make a unique logger
         */
        logger = Hierarchy.getDefaultHierarchy().getLoggerFor( rsvc.toString() );
        logger.setPriority( Priority.DEBUG );
        logger.setLogTargets( new LogTarget[] { target } );
    }
    /**
     *  logs messages
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void logVelocityMessage(int level, String message)
    {
        /*
         *  based on level, call teh right logger method
         *  and prefix with the appropos prefix
         */
        switch (level) 
        {
            case LogSystem.WARN_ID:
                logger.warn( RuntimeConstants.WARN_PREFIX + message );
                break;
            case LogSystem.INFO_ID:
                logger.info( RuntimeConstants.INFO_PREFIX + message);
                break;
            case LogSystem.DEBUG_ID:
                logger.debug( RuntimeConstants.DEBUG_PREFIX + message);
                break;
            case LogSystem.ERROR_ID:
                logger.error(RuntimeConstants.ERROR_PREFIX + message);
                break;
            default:
                logger.info( message);
                break;
        }
    }
}
"
org.apache.velocity.runtime.log.Log4JLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Enumeration;
import org.apache.log4j.*;
import org.apache.log4j.net.*;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Implementation of a Log4J logger.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: Log4JLogSystem.java,v 1.7.4.1 2004/03/03 23:22:56 geirm Exp $
 *
 * @deprecated As of v1.3.  Use
 *  {@link SimpleLog4jLogSystem}
 */
public class Log4JLogSystem implements LogSystem
{
    private RuntimeServices rsvc = null;
    /** log4java logging interface */
    protected Category logger = null;
    /** logging layout */
    protected Layout layout = null;
    /** the runtime.log property value */
    private String logfile = """";
    /**
     *  default CTOR.  Initializes itself using the property RUNTIME_LOG
     *  from the Velocity properties
     */
    public Log4JLogSystem()
    {
    }
    public void init( RuntimeServices rs )
    {
        rsvc = rs;
        /*
         *  since this is a Velocity-provided logger, we will
         *  use the Runtime configuration
         */
        logfile = rsvc.getString( RuntimeConstants.RUNTIME_LOG );
        /*
         *  now init.  If we can't, panic!
         */
        try
        {
            internalInit();
            logVelocityMessage( 0, 
                ""Log4JLogSystem initialized using logfile "" + logfile );
        }
        catch( Exception e )
        {
            System.out.println( 
                ""PANIC : error configuring Log4JLogSystem : "" + e );
        }
    }
    /**
     *  initializes the log system using the logfile argument
     *
     *  @param logFile   file for log messages
     */
    private void internalInit()
        throws Exception
    {
        logger = Category.getInstance("""");
        logger.setAdditivity(false);
        /*
         * Priority is set for DEBUG becouse this implementation checks 
         * log level.
         */
        logger.setPriority(Priority.DEBUG);
        String pattern = rsvc.getString( RuntimeConstants.LOGSYSTEM_LOG4J_PATTERN );
        if (pattern == null || pattern.length() == 0)
        {
            pattern = ""%d - %m%n"";
        }
        layout = new PatternLayout(pattern);
        configureFile();
        configureRemote();
        configureSyslog();
        configureEmail();
    }
    /**
     * Configures the logging to a file.
     */
    private void configureFile()
        throws Exception
    {
        int backupFiles = 
            rsvc.getInt(RuntimeConstants.LOGSYSTEM_LOG4J_FILE_BACKUPS, 1);
        int fileSize = 
            rsvc.getInt(RuntimeConstants.LOGSYSTEM_LOG4J_FILE_SIZE, 100000);
        Appender appender = new RollingFileAppender(layout,logfile,true);
        ((RollingFileAppender)appender).setMaxBackupIndex(backupFiles);
        /* finding file size */
        if (fileSize > -1)
        {
            ((RollingFileAppender)appender).setMaximumFileSize(fileSize);
        }
        logger.addAppender(appender);
    }
    /**
     * Configures the logging to a remote server
     */
    private void configureRemote()
        throws Exception
    {
        String remoteHost = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_REMOTE_HOST);
        int remotePort = 
            rsvc.getInt(RuntimeConstants.LOGSYSTEM_LOG4J_REMOTE_PORT, 1099);
        if (remoteHost == null || remoteHost.trim().equals("""") || 
            remotePort <= 0)
        {
            return;
        }
        Appender appender=new SocketAppender(remoteHost,remotePort);
        logger.addAppender(appender);
    }
    /**
     * Configures the logging to syslogd
     */
    private void configureSyslog()
        throws Exception
    {
        String syslogHost = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_SYSLOGD_HOST);
        String syslogFacility = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_SYSLOGD_FACILITY);
        if (syslogHost == null || syslogHost.trim().equals("""") || 
            syslogFacility == null )
        {
            return;
        }
        Appender appender = new SyslogAppender();
        ((SyslogAppender)appender).setLayout(layout);
        ((SyslogAppender)appender).setSyslogHost(syslogHost);
        ((SyslogAppender)appender).setFacility(syslogFacility);
        logger.addAppender(appender);
    }
    /**
     * Configures the logging to email
     */
    private void configureEmail()
        throws Exception
    {
        String smtpHost = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_EMAIL_SERVER);
        String emailFrom = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_EMAIL_FROM);
        String emailTo = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_EMAIL_TO);
        String emailSubject = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_EMAIL_SUBJECT);
        String bufferSize = 
            rsvc.getString(RuntimeConstants.LOGSYSTEM_LOG4J_EMAIL_BUFFER_SIZE);
        if (smtpHost == null || smtpHost.trim().equals("""")
                || emailFrom == null || smtpHost.trim().equals("""")
                || emailTo == null || emailTo.trim().equals("""")
                || emailSubject == null || emailSubject.trim().equals("""")
                || bufferSize == null || bufferSize.trim().equals("""") )
        {
            return;
        }
        SMTPAppender appender = new SMTPAppender();
        appender.setSMTPHost( smtpHost );
        appender.setFrom( emailFrom );
        appender.setTo( emailTo );
        appender.setSubject( emailSubject );
        appender.setBufferSize( Integer.parseInt(bufferSize) );
        appender.setLayout(layout);
        appender.activateOptions();
        logger.addAppender(appender);
    }
    /**
     *  logs messages
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void logVelocityMessage(int level, String message)
    {
        switch (level) 
        {
            case LogSystem.WARN_ID:
                logger.warn( message );
                break;
            case LogSystem.INFO_ID:
                logger.info(message);
                break;
            case LogSystem.DEBUG_ID:
                logger.debug(message);
                break;
            case LogSystem.ERROR_ID:
                logger.error(message);
                break;
            default:
                logger.debug(message);
                break;
        }
    }
    /**
     * Also do a shutdown if the object is destroy()'d.
     */
    protected void finalize() throws Throwable
    {
        shutdown();
    }
    /** Close all destinations*/
    public void shutdown()
    {
        Enumeration appenders = logger.getAllAppenders();
        while (appenders.hasMoreElements())
        {
            Appender appender = (Appender)appenders.nextElement();
            appender.close();
        }
    }
}
"
org.apache.velocity.runtime.log.LogManager,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
/**
 * <p>
 * This class is responsible for instantiating the correct LoggingSystem
 * </p>
 *
 * <p>
 * The approach is :
 * </p>
 * <ul>
 * <li> 
 *      First try to see if the user is passing in a living object
 *      that is a LogSystem, allowing the app to give is living
 *      custom loggers.
 *  </li>
 *  <li> 
 *       Next, run through the (possible) list of classes specified
 *       specified as loggers, taking the first one that appears to 
 *       work.  This is how we support finding either log4j or
 *       logkit, whichever is in the classpath, as both are 
 *       listed as defaults.
 *  </li>
 *  <li>
 *      Finally, we turn to 'faith-based' logging, and hope that
 *      logkit is in the classpath, and try for an AvalonLogSystem
 *      as a final gasp.  After that, there is nothing we can do.
 *  </li>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: LogManager.java,v 1.10.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class LogManager
{
    /**
     *  Creates a new logging system or returns an existing one
     *  specified by the application.
     */
    public static LogSystem createLogSystem( RuntimeServices rsvc )
        throws Exception
    {
        /*
         *  if a logSystem was set as a configuation value, use that. 
         *  This is any class the user specifies.
         */
        Object o = rsvc.getProperty( RuntimeConstants.RUNTIME_LOG_LOGSYSTEM );
        if (o != null && o instanceof LogSystem)
        {
            ((LogSystem) o).init( rsvc );
            return (LogSystem) o;
        }
        /*
         *  otherwise, see if a class was specified.  You
         *  can put multiple classes, and we use the first one we find.
         *
         *  Note that the default value of this property contains both the
         *  AvalonLogSystem and the SimpleLog4JLogSystem for convenience - 
         *  so we use whichever we find.
         */
        List classes = null;
        Object obj = rsvc.getProperty( RuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS );
        /*
         *  we might have a list, or not - so check
         */
        if ( obj instanceof List)
        {
            classes = (List) obj;
        }
        else if ( obj instanceof String)
        { 
            classes = new ArrayList();
            classes.add( obj );
        }
        /*
         *  now run through the list, trying each.  It's ok to 
         *  fail with a class not found, as we do this to also
         *  search out a default simple file logger
         */
        for( Iterator ii = classes.iterator(); ii.hasNext(); )
        {
            String claz = (String) ii.next();
            if (claz != null && claz.length() > 0 )
            {
                rsvc.info(""Trying to use logger class "" + claz );
                try
                {
                    o = Class.forName( claz ).newInstance();
                    if ( o instanceof LogSystem )
                    {
                        ((LogSystem) o).init( rsvc );
                        rsvc.info(""Using logger class "" + claz );
                        return (LogSystem) o;
                    }
                    else
                    {
                        rsvc.error(""The specifid logger class "" + claz + 
                                   "" isn't a valid LogSystem"");
                    }
                }
                catch( NoClassDefFoundError ncdfe )
                {
                    rsvc.debug(""Couldn't find class "" + claz 
                               + "" or necessary supporting classes in ""
                               + ""classpath. Exception : "" + ncdfe);
                }
            }
        }
        /*
         *  if the above failed, then we are in deep doo-doo, as the 
         *  above means that either the user specified a logging class
         *  that we can't find, there weren't the necessary
         *  dependencies in the classpath for it, or there were no
         *  dependencies for the default loggers, log4j and logkit.
         *  Since we really don't know, 
         *  then take a wack at the AvalonLogSystem as a last resort.
         */
        LogSystem als = null;
        try
        {
            als = new AvalonLogSystem();
            als.init( rsvc );
        }
        catch( NoClassDefFoundError ncdfe )
        {
            String errstr = ""PANIC : Velocity cannot find any of the""
                + "" specified or default logging systems in the classpath,""
                + "" or the classpath doesn't contain the necessary classes""
                + "" to support them.""
                + "" Please consult the documentation regarding logging.""
                + "" Exception : "" + ncdfe;
            System.out.println( errstr );
            System.err.println( errstr );
            throw ncdfe;
        }
        rsvc.info(""Using AvalonLogSystem as logger of final resort."");
        return als;
    }
}
"
org.apache.velocity.runtime.log.LogSystem,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Base interface that Logging systems need to implement.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: LogSystem.java,v 1.7.10.1 2004/03/03 23:22:56 geirm Exp $
 */
public interface LogSystem
{
    public final static boolean DEBUG_ON = true;
    /**
     * Prefix for debug messages.
     */
    public final static int DEBUG_ID = 0;
    /** 
     * Prefix for info messages.
     */
    public final static int INFO_ID = 1;
    /** 
     * Prefix for warning messages.
     */
    public final static int WARN_ID = 2;
    /** 
     * Prefix for error messages.
     */
    public final static int ERROR_ID = 3;
    /**
     *  init()
     */
    public void init( RuntimeServices rs ) throws Exception;
    /**
     * Send a log message from Velocity.
     */
    public void logVelocityMessage(int level, String message);
}
"
org.apache.velocity.runtime.log.NullLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.RuntimeServices;
/**
 *  Logger used in case of failure. Does nothing.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: NullLogSystem.java,v 1.1.10.1 2004/03/03 23:22:56 geirm Exp $
 */
public class NullLogSystem implements LogSystem
{
    public NullLogSystem()
    {
    }
    public void init( RuntimeServices rs )
        throws Exception
    {
    }
    /**
     *  logs messages to the great Garbage Collector
     *  in the sky
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void logVelocityMessage(int level, String message)
    {
    }
}
"
org.apache.velocity.runtime.log.PrimordialLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Vector;
import java.util.Enumeration;
import org.apache.velocity.runtime.RuntimeServices;
/**
 *  Pre-init logger.  I believe that this was suggested by
 *  Carsten Ziegeler <cziegeler@sundn.de> and 
 *  Jeroen C. van Gelderen.  If this isn't correct, let me
 *  know as this was a good idea... 
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: PrimordialLogSystem.java,v 1.4.4.1 2004/03/03 23:22:56 geirm Exp $
 */
public class PrimordialLogSystem implements LogSystem
{
    private Vector pendingMessages = new Vector();    
    private RuntimeServices rsvc = null;
    /**
     *  default CTOR.
     */
    public PrimordialLogSystem()
    {
    }
    public void init( RuntimeServices rs )
        throws Exception
    {
        rsvc = rs;
    }
    /**
     *  logs messages.  All we do is store them until
     *   'later'.
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void logVelocityMessage(int level, String message)
    {
        synchronized( this )
        {
            Object[] data = new Object[2];
            data[0] = new Integer(level);
            data[1] = message;
            pendingMessages.addElement(data);
        }
    }
    /**
     * dumps the log messages this logger is holding into a new logger
     */
    public void dumpLogMessages( LogSystem newLogger )
    {
        synchronized( this )
        {
            if ( !pendingMessages.isEmpty())
            {
                /*
                 *  iterate and log each individual message...
                 */
                for( Enumeration e = pendingMessages.elements(); e.hasMoreElements(); )
                {
                    Object[] data = (Object[]) e.nextElement();
                    newLogger.logVelocityMessage(((Integer) data[0]).intValue(), (String) data[1]);
                }
            }    
        }
    }    
}
"
org.apache.velocity.runtime.log.SimpleLog4JLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Enumeration;
import org.apache.log4j.Category;
import org.apache.log4j.RollingFileAppender;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.Priority;
import org.apache.log4j.Appender;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
/**
 *  Implementation of a simple log4j system that will either
 *  latch onto an existing category, or just do a simple
 *  rolling file log.  Derived from Jon's 'complicated'
 *  version :)
 *
 * @author <a href=""mailto:geirm@apache.org>Geir Magnusson Jr.</a>
 * @version $Id: SimpleLog4JLogSystem.java,v 1.1.8.1 2004/03/03 23:22:57 geirm Exp $
 */
public class SimpleLog4JLogSystem implements LogSystem
{
    private RuntimeServices rsvc = null;
    /** log4java logging interface */
    protected Category logger = null;
    public SimpleLog4JLogSystem()
    {
    }
    public void init( RuntimeServices rs )
    {
        rsvc = rs;
        /*
         *  first see if there is a category specified and just use that - it allows
         *  the application to make us use an existing logger
         */
        String categoryname =  (String) rsvc.getProperty(""runtime.log.logsystem.log4j.category"");
        if ( categoryname != null )
        {
            logger = Category.getInstance( categoryname );
            logVelocityMessage( 0,
                                ""SimpleLog4JLogSystem using category '"" + categoryname + ""'"");
            return;
        }
        /*
         *  if not, use the file...
         */
        String logfile = rsvc.getString( RuntimeConstants.RUNTIME_LOG );
        /*
         *  now init.  If we can't, panic!
         */
        try
        {
            internalInit( logfile );
            logVelocityMessage( 0, 
                ""SimpleLog4JLogSystem initialized using logfile '"" + logfile + ""'"" );
        }
        catch( Exception e )
        {
            System.out.println( 
                ""PANIC : error configuring SimpleLog4JLogSystem : "" + e );
        }
    }
    /**
     *  initializes the log system using the logfile argument
     */
    private void internalInit( String logfile )
        throws Exception
    {
        /*
         *  do it by our classname to avoid conflicting with anything else 
         *  that might be used...
         */
        logger = Category.getInstance(this.getClass().getName());
        logger.setAdditivity(false);
        /*
         * Priority is set for DEBUG becouse this implementation checks 
         * log level.
         */
        logger.setPriority(Priority.DEBUG);
        RollingFileAppender appender = new RollingFileAppender( new PatternLayout( ""%d - %m%n""), logfile, true);
        appender.setMaxBackupIndex( 1 );
        appender.setMaximumFileSize( 100000 );
        logger.addAppender(appender);
    }
    /**
     *  logs messages
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void logVelocityMessage(int level, String message)
    {
        switch (level) 
        {
            case LogSystem.WARN_ID:
                logger.warn( message );
                break;
            case LogSystem.INFO_ID:
                logger.info(message);
                break;
            case LogSystem.DEBUG_ID:
                logger.debug(message);
                break;
            case LogSystem.ERROR_ID:
                logger.error(message);
                break;
            default:
                logger.debug(message);
                break;
        }
    }
    /**
     * Also do a shutdown if the object is destroy()'d.
     */
    protected void finalize() throws Throwable
    {
        shutdown();
    }
    /** Close all destinations*/
    public void shutdown()
    {
        Enumeration appenders = logger.getAllAppenders();
        while (appenders.hasMoreElements())
        {
            Appender appender = (Appender)appenders.nextElement();
            appender.close();
        }
    }
}
"
org.apache.velocity.runtime.log.VelocityFormatter,"package org.apache.velocity.runtime.log;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Date;
import org.apache.log.format.PatternFormatter;
public class VelocityFormatter extends PatternFormatter
{
    public VelocityFormatter( String format )
    {
	super( format );
    }
    /**
     * Utility method to format time.
     *
     * @param time the time
     * @param format ancilliary format parameter - allowed to be null
     * @return the formatted string
     */
    protected String getTime( final long time, final String format )
    {
        return new Date().toString();
    }
}
"
org.apache.velocity.runtime.parser.CharStream,"/* Generated By:JavaCC: Do not edit this line. CharStream.java Version 2.1 */
package org.apache.velocity.runtime.parser;
/**
 * This interface describes a character stream that maintains line and
 * column number positions of the characters.  It also has the capability
 * to backup the stream to some extent.  An implementation of this
 * interface is used in the TokenManager implementation generated by
 * JavaCCParser.
 *
 * All the methods except backup can be implemented in any fashion. backup
 * needs to be implemented correctly for the correct operation of the lexer.
 * Rest of the methods are all used to get information like line number,
 * column number and the String that constitutes a token and are not used
 * by the lexer. Hence their implementation won't affect the generated lexer's
 * operation.
 */
public interface CharStream {
  /**
   * Returns the next character from the selected input.  The method
   * of selecting the input is the responsibility of the class
   * implementing this interface.  Can throw any java.io.IOException.
   */
  char readChar() throws java.io.IOException;
  /**
   * Returns the column position of the character last read.
   * @deprecated 
   * @see #getEndColumn
   */
  int getColumn();
  /**
   * Returns the line number of the character last read.
   * @deprecated 
   * @see #getEndLine
   */
  int getLine();
  /**
   * Returns the column number of the last character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getEndColumn();
  /**
   * Returns the line number of the last character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getEndLine();
  /**
   * Returns the column number of the first character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getBeginColumn();
  /**
   * Returns the line number of the first character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getBeginLine();
  /**
   * Backs up the input stream by amount steps. Lexer calls this method if it
   * had already read some characters, but could not use them to match a
   * (longer) token. So, they will be used again as the prefix of the next
   * token and it is the implemetation's responsibility to do this right.
   */
  void backup(int amount);
  /**
   * Returns the next character that marks the beginning of the next token.
   * All characters must remain in the buffer between two successive calls
   * to this method to implement backup correctly.
   */
  char BeginToken() throws java.io.IOException;
  /**
   * Returns a string made up of characters from the marked token beginning 
   * to the current buffer position. Implementations have the choice of returning
   * anything that they want to. For example, for efficiency, one might decide
   * to just return null, which is a valid implementation.
   */
  String GetImage();
  /**
   * Returns an array of characters that make up the suffix of length 'len' for
   * the currently matched token. This is used to build up the matched string
   * for use in actions in the case of MORE. A simple and inefficient
   * implementation of this is as follows :
   *
   *   {
   *      String t = GetImage();
   *      return t.substring(t.length() - len, t.length()).toCharArray();
   *   }
   */
  char[] GetSuffix(int len);
  /**
   * The lexer calls this function to indicate that it is done with the stream
   * and hence implementations can free any resources held by this class.
   * Again, the body of this function can be just empty and it will not
   * affect the lexer's operation.
   */
  void Done();
}
"
org.apache.velocity.runtime.parser.JJTParserState,"/* Generated By:JJTree: Do not edit this line. JJTParserState.java */
package org.apache.velocity.runtime.parser;
import org.apache.velocity.runtime.parser.node.*;
class JJTParserState {
  private java.util.Stack nodes;
  private java.util.Stack marks;
  private int sp;		// number of nodes on stack
  private int mk;		// current mark
  private boolean node_created;
  JJTParserState() {
    nodes = new java.util.Stack();
    marks = new java.util.Stack();
    sp = 0;
    mk = 0;
  }
  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  boolean nodeCreated() {
    return node_created;
  }
  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  void reset() {
    nodes.removeAllElements();
    marks.removeAllElements();
    sp = 0;
    mk = 0;
  }
  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  Node rootNode() {
    return (Node)nodes.elementAt(0);
  }
  /* Pushes a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
    ++sp;
  }
  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.pop()).intValue();
    }
    return (Node)nodes.pop();
  }
  /* Returns the node currently on the top of the stack. */
  Node peekNode() {
    return (Node)nodes.peek();
  }
  /* Returns the number of children on the stack in the current node
     scope. */
  int nodeArity() {
    return sp - mk;
  }
  void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.pop()).intValue();
  }
  void openNodeScope(Node n) {
    marks.push(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }
  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }
  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }
}
"
org.apache.velocity.runtime.parser.ParseException,"/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 2.1 */
package org.apache.velocity.runtime.parser;
/**
 * This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */
public class ParseException extends Exception {
  /**
   * This constructor is used by the method ""generateParseException""
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields ""currentToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" set.  The boolean
   * flag ""specialConstructor"" is also set to true to indicate that
   * this constructor was used to create this object.
   * This constructor calls its super class with the empty string
   * to force the ""toString"" method of parent class ""Throwable"" to
   * print the error message in the form:
   *     ParseException: <result of getMessage>
   */
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
    super("""");
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }
  /**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class ""Throwable"".  The fields ""errorToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */
  public ParseException() {
    super();
    specialConstructor = false;
  }
  public ParseException(String message) {
    super(message);
    specialConstructor = false;
  }
  /**
   * This variable determines which constructor was used to create
   * this object and thereby affects the semantics of the
   * ""getMessage"" method (see below).
   */
  protected boolean specialConstructor;
  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * followng this token will (therefore) be the first error token.
   */
  public Token currentToken;
  /**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;
  /**
   * This is a reference to the ""tokenImage"" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */
  public String[] tokenImage;
  /**
   * This method has the standard behavior when this object has been
   * created using the standard constructors.  Otherwise, it uses
   * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser), then this method is called during the printing
   * of the final stack trace, and hence the correct error message
   * gets displayed.
   */
  public String getMessage() {
    if (!specialConstructor) {
      return super.getMessage();
    }
    String expected = """";
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected += ""..."";
      }
      expected += eol + ""    "";
    }
    String retval = ""Encountered \"""";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += "" "";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += add_escapes(tok.image);
      tok = tok.next; 
    }
    retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn;
    retval += ""."" + eol;
    if (expectedTokenSequences.length == 1) {
      retval += ""Was expecting:"" + eol + ""    "";
    } else {
      retval += ""Was expecting one of:"" + eol + ""    "";
    }
    retval += expected;
    return retval;
  }
  /**
   * The end of line string for this machine.
   */
  protected String eol = System.getProperty(""line.separator"", ""\n"");
  /**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */
  protected String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
}
"
org.apache.velocity.runtime.parser.Parser,"/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package org.apache.velocity.runtime.parser;
import java.io.*;
import java.util.*;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.*;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.directive.Macro;
import org.apache.velocity.runtime.directive.MacroParseException;
import org.apache.velocity.util.StringUtils;
/**
 * This class is responsible for parsing a Velocity
 * template. This class was generated by JavaCC using
 * the JJTree extension to produce an Abstract
 * Syntax Tree (AST) of the template.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Parser.java,v 1.74 2002/04/27 19:33:30 geirm Exp $
*/
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();/**
     *  This Hashtable contains a list of all of the dynamic directives.
     */
    private Hashtable directives = new Hashtable(0);
    /**
     *  Name of current template we are parsing.  Passed to us in parse()
     */
    String currentTemplateName = """";
    VelocityCharStream velcharstream = null;
    private RuntimeServices rsvc = null;
    /**
     * This constructor was added to allow the re-use of parsers.
     * The normal constructor takes a single argument which
     * an InputStream. This simply creates a re-usable parser
     * object, we satisfy the requirement of an InputStream
     * by using a newline character as an input stream.
     */
    public Parser( RuntimeServices rs)
    {
        /*
         * need to call the CTOR first thing.
         */
        this(   new VelocityCharStream(
                new ByteArrayInputStream(""\n"".getBytes()), 1, 1 ));
        /*
         * now setup a VCS for later use
         */
        velcharstream = new VelocityCharStream(
                new ByteArrayInputStream(""\n"".getBytes()), 1, 1 );
        /*
         *  and save the RuntimeServices
         */
        rsvc = rs;
    }
    /**
     * This was also added to allow parsers to be
     * re-usable. Normal JavaCC use entails passing an
     * input stream to the constructor and the parsing
     * process is carried out once. We want to be able
     * to re-use parsers: we do this by adding this
     * method and re-initializing the lexer with
     * the new stream that we want parsed.
     */
    public SimpleNode parse( Reader reader, String templateName )
        throws ParseException
    {
        SimpleNode sn = null;
        currentTemplateName = templateName;
        try
        {
            token_source.clearStateVars();
            /*
             *  reinitialize the VelocityCharStream
             *  with the new reader
             */
            velcharstream.ReInit( reader, 1, 1 );
            /*
             * now reinit the Parser with this CharStream
             */
            ReInit( velcharstream  );
            /*
             *  do that voodoo...
             */
            sn = process();
        }
        catch (MacroParseException mee)
        {
            /*
             *  thrown by the Macro class when something is amiss in the
             *  Macro specification
             */
            rsvc.error (""Parser Error:  #macro() : "" + templateName + "" : "" + StringUtils.stackTrace(mee));
            throw new ParseException(mee.getMessage());
        }
        catch (ParseException pe)
        {
            rsvc.error (""Parser Exception: "" + templateName + "" : "" + StringUtils.stackTrace(pe));
            throw new ParseException (pe.currentToken,
                pe.expectedTokenSequences, pe.tokenImage);
        }
        catch (TokenMgrError tme)
        {
            throw new ParseException(""Lexical error: "" + tme.toString());
        }
        catch (Exception e)
        {
            rsvc.error (""Parser Error: "" + templateName + "" : "" + StringUtils.stackTrace(e));
        }
        currentTemplateName = """";
        return sn;
    }
    /**
     *  This method sets the directives Hashtable
     */
    public void setDirectives(Hashtable directives)
    {
        this.directives = directives;
    }
    /**
     *  This method gets a Directive from the directives Hashtable
     */
    public Directive getDirective(String directive)
    {
        return (Directive) directives.get(directive);
    }
    /**
     *  This method finds out of the directive exists in the directives
     *  Hashtable.
     */
    public boolean isDirective(String directive)
    {
        if (directives.containsKey(directive))
            return true;
        else
            return false;
    }
    /**
     * Produces a processed output for an escaped control or
     * pluggable directive
     */
    private String escapedDirective( String strImage )
    {
        int iLast = strImage.lastIndexOf(""\\"");
        String strDirective = strImage.substring(iLast + 1);
        boolean bRecognizedDirective = false;
        /*
         *  is this a PD or a control directive?
         */
        if ( isDirective( strDirective.substring(1)))
        {
           bRecognizedDirective = true;
        }
        else if ( rsvc.isVelocimacro( strDirective.substring(1), currentTemplateName))
        {
            bRecognizedDirective = true;
        }
        else
        {
            /* order for speed? */
            if ( strDirective.substring(1).equals(""if"")
                || strDirective.substring(1).equals(""end"")
                || strDirective.substring(1).equals(""set"")
                || strDirective.substring(1).equals(""else"")
                || strDirective.substring(1).equals(""elseif"")
                || strDirective.substring(1).equals(""stop"")
            )
            {
                bRecognizedDirective = true;
            }
        }
        /*
         *  if so, make the proper prefix string (let the escapes do their thing..)
         *  otherwise, just return what it is..
         */
        if (bRecognizedDirective)
            return ( strImage.substring(0,iLast/2) + strDirective);
        else
            return ( strImage );
    }
/**
 * This method is what starts the whole parsing
 * process. After the parsing is complete and
 * the template has been turned into an AST,
 * this method returns the root of AST which
 * can subsequently be traversed by a visitor
 * which implements the ParserVisitor interface
 * which is generated automatically by JavaCC
 */
  final public SimpleNode process() throws ParseException {
                        /*@bgen(jjtree) process */
  ASTprocess jjtn000 = new ASTprocess(this, JJTPROCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case RPAREN:
        case ESCAPE_DIRECTIVE:
        case SET_DIRECTIVE:
        case DOUBLE_ESCAPE:
        case ESCAPE:
        case TEXT:
        case SINGLE_LINE_COMMENT:
        case FORMAL_COMMENT:
        case MULTI_LINE_COMMENT:
        case STRING_LITERAL:
        case IF_DIRECTIVE:
        case STOP_DIRECTIVE:
        case NUMBER_LITERAL:
        case WORD:
        case IDENTIFIER:
        case DOT:
        case LCURLY:
        case RCURLY:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        Statement();
      }
      jj_consume_token(0);
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error(""Missing return statement in function"");
  }
/**
 * These are the types of statements that
 * are acceptable in Velocity templates.
 */
  final public void Statement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF_DIRECTIVE:
      IfStatement();
      break;
    case STOP_DIRECTIVE:
      StopStatement();
      break;
    default:
      jj_la1[1] = jj_gen;
      if (jj_2_1(2)) {
        Reference();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLE_LINE_COMMENT:
        case FORMAL_COMMENT:
        case MULTI_LINE_COMMENT:
          Comment();
          break;
        case SET_DIRECTIVE:
          SetDirective();
          break;
        case ESCAPE_DIRECTIVE:
          EscapedDirective();
          break;
        case DOUBLE_ESCAPE:
          Escape();
          break;
        case WORD:
          Directive();
          break;
        case LPAREN:
        case RPAREN:
        case ESCAPE:
        case TEXT:
        case STRING_LITERAL:
        case NUMBER_LITERAL:
        case DOT:
        case LCURLY:
        case RCURLY:
          Text();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
/**
 *  used to separate the notion of a valid directive that has been
 *  escaped, versus something that looks like a directive and
 *  is just schmoo.  This is important to do as a separate production
 *  that creates a node, because we want this, in either case, to stop
 *  the further parsing of the Directive() tree.
 */
  final public void EscapedDirective() throws ParseException {
                           /*@bgen(jjtree) EscapedDirective */
  ASTEscapedDirective jjtn000 = new ASTEscapedDirective(this, JJTESCAPEDDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
        Token t = null;
      t = jj_consume_token(ESCAPE_DIRECTIVE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        /*
         *  churn and burn..
         */
        t.image = escapedDirective( t.image );
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *  Used to catch and process escape sequences in grammatical constructs
 *  as escapes outside of VTL are just characters.  Right now we have both
 *  this and the EscapeDirective() construction because in the EscapeDirective()
 *  case, we want to suck in the #<directive> and here we don't.  We just want
 *  the escapes to render correctly
 */
  final public void Escape() throws ParseException {
                 /*@bgen(jjtree) Escape */
  ASTEscape jjtn000 = new ASTEscape(this, JJTESCAPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
        Token t = null;
        int count = 0;
        boolean control = false;
      label_2:
      while (true) {
        t = jj_consume_token(DOUBLE_ESCAPE);
        count++;
        if (jj_2_2(2)) {
          ;
        } else {
          break label_2;
        }
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        /*
         * first, check to see if we have a control directive
         */
        switch(t.next.kind ) {
            case IF_DIRECTIVE :
            case ELSE_DIRECTIVE :
            case ELSEIF_DIRECTIVE :
            case END :
            case STOP_DIRECTIVE :
                control = true;
                break;
        }
        /*
         * if that failed, lets lookahead to see if we matched a PD or a VM
         */
        if ( isDirective( t.next.image.substring(1)))
            control = true;
        else if ( rsvc.isVelocimacro( t.next.image.substring(1), currentTemplateName))
            control = true;
        jjtn000.val = """";
        for( int i = 0; i < count; i++)
            jjtn000.val += ( control ? ""\\"" : ""\\\\"");
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void Comment() throws ParseException {
                  /*@bgen(jjtree) Comment */
  ASTComment jjtn000 = new ASTComment(this, JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SINGLE_LINE_COMMENT:
        jj_consume_token(SINGLE_LINE_COMMENT);
        break;
      case MULTI_LINE_COMMENT:
        jj_consume_token(MULTI_LINE_COMMENT);
        break;
      case FORMAL_COMMENT:
        jj_consume_token(FORMAL_COMMENT);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void NumberLiteral() throws ParseException {
                        /*@bgen(jjtree) NumberLiteral */
  ASTNumberLiteral jjtn000 = new ASTNumberLiteral(this, JJTNUMBERLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(NUMBER_LITERAL);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void StringLiteral() throws ParseException {
                        /*@bgen(jjtree) StringLiteral */
  ASTStringLiteral jjtn000 = new ASTStringLiteral(this, JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(STRING_LITERAL);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method corresponds to variable
 * references in Velocity templates.
 * The following are examples of variable
 * references that may be found in a
 * template:
 *
 * $foo
 * $bar
 *
 */
  final public void Identifier() throws ParseException {
                     /*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void Word() throws ParseException {
               /*@bgen(jjtree) Word */
  ASTWord jjtn000 = new ASTWord(this, JJTWORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(WORD);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *   Supports the arguments for the Pluggable Directives
 *   We add whitespace in here as a token so the VMs can
 *   easily reconstruct a macro body from the token stream
 *   See Directive()
 */
  final public int DirectiveArg() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case LCURLY:
      Reference();
        {if (true) return ParserTreeConstants.JJTREFERENCE;}
      break;
    case WORD:
      Word();
        {if (true) return ParserTreeConstants.JJTWORD;}
      break;
    case STRING_LITERAL:
      StringLiteral();
        {if (true) return ParserTreeConstants.JJTSTRINGLITERAL;}
      break;
    case NUMBER_LITERAL:
      NumberLiteral();
        {if (true) return ParserTreeConstants.JJTNUMBERLITERAL;}
      break;
    default:
      jj_la1[4] = jj_gen;
      if (jj_2_3(2147483647)) {
        IntegerRange();
        {if (true) return ParserTreeConstants.JJTINTEGERRANGE;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ObjectArray();
        {if (true) return ParserTreeConstants.JJTOBJECTARRAY;}
          break;
        case TRUE:
          True();
        {if (true) return ParserTreeConstants.JJTTRUE;}
          break;
        case FALSE:
          False();
        {if (true) return ParserTreeConstants.JJTFALSE;}
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error(""Missing return statement in function"");
  }
/**
 *   Supports the Pluggable Directives
 *     #foo( arg+ )
 */
  final public SimpleNode Directive() throws ParseException {
 /*@bgen(jjtree) Directive */
    ASTDirective jjtn000 = new ASTDirective(this, JJTDIRECTIVE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t = null;
    int argType;
    int argPos = 0;
    Directive d;
    int directiveType;
    boolean isVM = false;
    boolean doItNow = false;
    try {
      /*
           * note that if we were escaped, that is now handled by
           * EscapedDirective()
           */
          t = jj_consume_token(WORD);
        String directiveName = t.image.substring(1);
        d = (Directive) directives.get(directiveName);
        /*
         *  Velocimacro support : if the directive is macro directive
         *   then set the flag so after the block parsing, we add the VM
         *   right then. (So available if used w/in the current template )
         */
        if (directiveName.equals(""macro""))
        {
             doItNow = true;
        }
        /*
         * set the directive name from here.  No reason for the thing to know
         * about parser tokens
         */
        jjtn000.setDirectiveName(directiveName);
        if ( d == null)
        {
            /*
             *  if null, then not a real directive, but maybe a Velocimacro
             */
            isVM = rsvc.isVelocimacro(directiveName, currentTemplateName);
            if (!isVM)
            {
                token_source.stateStackPop();
                token_source.inDirective = false;
                {if (true) return jjtn000;}
            }
            /*
             *  Currently, all VMs are LINE directives
             */
            directiveType = Directive.LINE;
        }
        else
        {
            directiveType = d.getType();
        }
        /*
         *  now, switch us out of PRE_DIRECTIVE
         */
        token_source.SwitchTo(DIRECTIVE);
        argPos = 0;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      jj_consume_token(LPAREN);
      label_3:
      while (true) {
        if (jj_2_4(2)) {
          ;
        } else {
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          jj_consume_token(WHITESPACE);
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        argType = DirectiveArg();
                if (argType == ParserTreeConstants.JJTWORD)
                {
                    if (doItNow && argPos == 0)
                    {
                        /* if a VM and it's the 0th arg... ok */
                        ;
                    }
                    else if( t.image.equals(""#foreach"") && argPos == 1)
                    {
                        /* if a foreach and it's the 2nd arg ok */
                        ;
                    }
                    else
                    {
                        {if (true) throw new MacroParseException(""Invalid arg #""
                            + argPos + "" in ""
                            + (isVM ? ""VM "" : ""directive "" )
                            + t.image
                            + "" at line "" + t.beginLine + "", column ""
                            + t.beginColumn
                            + "" in template "" + currentTemplateName);}
                    }
                }
                else
                {
                    if (doItNow && argPos == 0)
                    {
                        /* if a VM and it's the 0th arg, not ok */
                        {if (true) throw new MacroParseException(""Invalid first arg ""
                            + "" in #macro() directive - must be a""
                            + "" word token (no \' or \"" surrounding)""
                            + "" at line "" + t.beginLine + "", column ""
                            + t.beginColumn
                            + "" in template "" + currentTemplateName);}
                    }
                }
                argPos++;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
        if (directiveType  == Directive.LINE)
        {
            {if (true) return jjtn000;}
        }
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_4:
        while (true) {
          Statement();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case SINGLE_LINE_COMMENT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case NUMBER_LITERAL:
          case WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[9] = jj_gen;
            break label_4;
          }
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
      jj_consume_token(END);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        /*
         *  VM : if we are processing a #macro directive, we need to
         *     process the block.  In truth, I can just register the name
         *     and do the work later when init-ing.  That would work
         *     as long as things were always defined before use.  This way
         *     we don't have to worry about forward references and such...
         */
        if (doItNow)
        {
            Macro.processAndRegister(rsvc, jjtn000, currentTemplateName);
        }
        /*
         *  VM : end
         */
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }
  final public void ObjectArray() throws ParseException {
                      /*@bgen(jjtree) ObjectArray */
  ASTObjectArray jjtn000 = new ASTObjectArray(this, JJTOBJECTARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case WHITESPACE:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case NUMBER_LITERAL:
      case IDENTIFIER:
      case LCURLY:
        Parameter();
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[10] = jj_gen;
            break label_5;
          }
          jj_consume_token(COMMA);
          Parameter();
        }
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jj_consume_token(RBRACKET);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *  supports the [n..m] vector generator for use in
 *  the #foreach() to generate measured ranges w/o
 *  needing explicit support from the app/servlet
 */
  final public void IntegerRange() throws ParseException {
                       /*@bgen(jjtree) IntegerRange */
  ASTIntegerRange jjtn000 = new ASTIntegerRange(this, JJTINTEGERRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case LCURLY:
        Reference();
        break;
      case NUMBER_LITERAL:
        NumberLiteral();
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      jj_consume_token(DOUBLEDOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case LCURLY:
        Reference();
        break;
      case NUMBER_LITERAL:
        NumberLiteral();
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      jj_consume_token(RBRACKET);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
  final public void Parameter() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      StringLiteral();
      break;
    default:
      jj_la1[19] = jj_gen;
      if (jj_2_5(2147483647)) {
        IntegerRange();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ObjectArray();
          break;
        case TRUE:
          True();
          break;
        case FALSE:
          False();
          break;
        case IDENTIFIER:
        case LCURLY:
          Reference();
          break;
        case NUMBER_LITERAL:
          NumberLiteral();
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
  }
/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
  final public void Method() throws ParseException {
                 /*@bgen(jjtree) Method */
  ASTMethod jjtn000 = new ASTMethod(this, JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Identifier();
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case WHITESPACE:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case NUMBER_LITERAL:
      case IDENTIFIER:
      case LCURLY:
        Parameter();
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[22] = jj_gen;
            break label_6;
          }
          jj_consume_token(COMMA);
          Parameter();
        }
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      jj_consume_token(REFMOD2_RPAREN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
  }
  final public void Reference() throws ParseException {
                    /*@bgen(jjtree) Reference */
  ASTReference jjtn000 = new ASTReference(this, JJTREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        label_7:
        while (true) {
          if (jj_2_6(2)) {
            ;
          } else {
            break label_7;
          }
          jj_consume_token(DOT);
          if (jj_2_7(3)) {
            Method();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              Identifier();
              break;
            default:
              jj_la1[24] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
      case LCURLY:
        jj_consume_token(LCURLY);
        jj_consume_token(IDENTIFIER);
        label_8:
        while (true) {
          if (jj_2_8(2)) {
            ;
          } else {
            break label_8;
          }
          jj_consume_token(DOT);
          if (jj_2_9(3)) {
            Method();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              Identifier();
              break;
            default:
              jj_la1[25] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        jj_consume_token(RCURLY);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }
  final public void True() throws ParseException {
               /*@bgen(jjtree) True */
  ASTTrue jjtn000 = new ASTTrue(this, JJTTRUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(TRUE);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void False() throws ParseException {
                /*@bgen(jjtree) False */
  ASTFalse jjtn000 = new ASTFalse(this, JJTFALSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(FALSE);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method is responsible for allowing
 * all non-grammar text to pass through
 * unscathed.
 */
  final public void Text() throws ParseException {
               /*@bgen(jjtree) Text */
  ASTText jjtn000 = new ASTText(this, JJTTEXT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT:
        jj_consume_token(TEXT);
        break;
      case DOT:
        jj_consume_token(DOT);
        break;
      case RPAREN:
        jj_consume_token(RPAREN);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      case NUMBER_LITERAL:
        jj_consume_token(NUMBER_LITERAL);
        break;
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
        break;
      case ESCAPE:
        jj_consume_token(ESCAPE);
        break;
      case LCURLY:
        jj_consume_token(LCURLY);
        break;
      case RCURLY:
        jj_consume_token(RCURLY);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/* -----------------------------------------------------------------------
 *
 *  Defined Directive Syntax
 *
 * ----------------------------------------------------------------------*/
  final public void IfStatement() throws ParseException {
                      /*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IF_DIRECTIVE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_9:
        while (true) {
          Statement();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case SINGLE_LINE_COMMENT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case NUMBER_LITERAL:
          case WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[29] = jj_gen;
            break label_9;
          }
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSEIF_DIRECTIVE:
        label_10:
        while (true) {
          ElseIfStatement();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ELSEIF_DIRECTIVE:
            ;
            break;
          default:
            jj_la1[30] = jj_gen;
            break label_10;
          }
        }
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE_DIRECTIVE:
        ElseStatement();
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      jj_consume_token(END);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void ElseStatement() throws ParseException {
                        /*@bgen(jjtree) ElseStatement */
  ASTElseStatement jjtn000 = new ASTElseStatement(this, JJTELSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ELSE_DIRECTIVE);
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_11:
        while (true) {
          Statement();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case SINGLE_LINE_COMMENT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case NUMBER_LITERAL:
          case WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[33] = jj_gen;
            break label_11;
          }
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
  }
  final public void ElseIfStatement() throws ParseException {
                          /*@bgen(jjtree) ElseIfStatement */
  ASTElseIfStatement jjtn000 = new ASTElseIfStatement(this, JJTELSEIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ELSEIF_DIRECTIVE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_12:
        while (true) {
          Statement();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case SINGLE_LINE_COMMENT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case NUMBER_LITERAL:
          case WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[35] = jj_gen;
            break label_12;
          }
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *  Currently support both types of set :
 *   #set( expr )
 *   #set expr
 */
  final public void SetDirective() throws ParseException {
                       /*@bgen(jjtree) SetDirective */
  ASTSetDirective jjtn000 = new ASTSetDirective(this, JJTSETDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SET_DIRECTIVE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      Reference();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      Expression();
      jj_consume_token(RPAREN);
        /*
         * ensure that inSet is false.  Leads to some amusing bugs...
         */
        token_source.inSet = false;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEWLINE:
        jj_consume_token(NEWLINE);
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method corresponds to the #stop
 * directive which just simulates and EOF
 * so that parsing stops. The #stop directive
 * is useful for end-user debugging
 * purposes.
 */
  final public void StopStatement() throws ParseException {
    jj_consume_token(STOP_DIRECTIVE);
  }
/* -----------------------------------------------------------------------
 *
 *  Expression Syntax
 *
 * ----------------------------------------------------------------------*/
  final public void Expression() throws ParseException {
                     /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ConditionalOrExpression();
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }
  final public void Assignment() throws ParseException {
                                    /*@bgen(jjtree) #Assignment( 2) */
  ASTAssignment jjtn000 = new ASTAssignment(this, JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      PrimaryExpression();
      jj_consume_token(EQUALS);
      Expression();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  2);
      }
    }
  }
  final public void ConditionalOrExpression() throws ParseException {
    ConditionalAndExpression();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_OR:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_13;
      }
      jj_consume_token(LOGICAL_OR);
                     ASTOrNode jjtn001 = new ASTOrNode(this, JJTORNODE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
      try {
        ConditionalAndExpression();
      } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       {if (true) throw (RuntimeException)jjte001;}
                     }
                     if (jjte001 instanceof ParseException) {
                       {if (true) throw (ParseException)jjte001;}
                     }
                     {if (true) throw (Error)jjte001;}
      } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  2);
                     }
      }
    }
  }
  final public void ConditionalAndExpression() throws ParseException {
    EqualityExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_AND:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_14;
      }
      jj_consume_token(LOGICAL_AND);
                    ASTAndNode jjtn001 = new ASTAndNode(this, JJTANDNODE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
      try {
        EqualityExpression();
      } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                      {if (true) throw (RuntimeException)jjte001;}
                    }
                    if (jjte001 instanceof ParseException) {
                      {if (true) throw (ParseException)jjte001;}
                    }
                    {if (true) throw (Error)jjte001;}
      } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
      }
    }
  }
  final public void EqualityExpression() throws ParseException {
    RelationalExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_EQUALS:
      case LOGICAL_NOT_EQUALS:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_EQUALS:
        jj_consume_token(LOGICAL_EQUALS);
                          ASTEQNode jjtn001 = new ASTEQNode(this, JJTEQNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
          RelationalExpression();
        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            {if (true) throw (RuntimeException)jjte001;}
                          }
                          if (jjte001 instanceof ParseException) {
                            {if (true) throw (ParseException)jjte001;}
                          }
                          {if (true) throw (Error)jjte001;}
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
        }
        break;
      case LOGICAL_NOT_EQUALS:
        jj_consume_token(LOGICAL_NOT_EQUALS);
                              ASTNENode jjtn002 = new ASTNENode(this, JJTNENODE);
                              boolean jjtc002 = true;
                              jjtree.openNodeScope(jjtn002);
        try {
          RelationalExpression();
        } catch (Throwable jjte002) {
                              if (jjtc002) {
                                jjtree.clearNodeScope(jjtn002);
                                jjtc002 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte002 instanceof RuntimeException) {
                                {if (true) throw (RuntimeException)jjte002;}
                              }
                              if (jjte002 instanceof ParseException) {
                                {if (true) throw (ParseException)jjte002;}
                              }
                              {if (true) throw (Error)jjte002;}
        } finally {
                              if (jjtc002) {
                                jjtree.closeNodeScope(jjtn002,  2);
                              }
        }
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void RelationalExpression() throws ParseException {
    AdditiveExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_LT:
      case LOGICAL_LE:
      case LOGICAL_GT:
      case LOGICAL_GE:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_LT:
        jj_consume_token(LOGICAL_LT);
                        ASTLTNode jjtn001 = new ASTLTNode(this, JJTLTNODE);
                        boolean jjtc001 = true;
                        jjtree.openNodeScope(jjtn001);
        try {
          AdditiveExpression();
        } catch (Throwable jjte001) {
                        if (jjtc001) {
                          jjtree.clearNodeScope(jjtn001);
                          jjtc001 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte001 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte001;}
                        }
                        if (jjte001 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte001;}
                        }
                        {if (true) throw (Error)jjte001;}
        } finally {
                        if (jjtc001) {
                          jjtree.closeNodeScope(jjtn001,  2);
                        }
        }
        break;
      case LOGICAL_GT:
        jj_consume_token(LOGICAL_GT);
                        ASTGTNode jjtn002 = new ASTGTNode(this, JJTGTNODE);
                        boolean jjtc002 = true;
                        jjtree.openNodeScope(jjtn002);
        try {
          AdditiveExpression();
        } catch (Throwable jjte002) {
                        if (jjtc002) {
                          jjtree.clearNodeScope(jjtn002);
                          jjtc002 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte002 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte002;}
                        }
                        if (jjte002 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte002;}
                        }
                        {if (true) throw (Error)jjte002;}
        } finally {
                        if (jjtc002) {
                          jjtree.closeNodeScope(jjtn002,  2);
                        }
        }
        break;
      case LOGICAL_LE:
        jj_consume_token(LOGICAL_LE);
                        ASTLENode jjtn003 = new ASTLENode(this, JJTLENODE);
                        boolean jjtc003 = true;
                        jjtree.openNodeScope(jjtn003);
        try {
          AdditiveExpression();
        } catch (Throwable jjte003) {
                        if (jjtc003) {
                          jjtree.clearNodeScope(jjtn003);
                          jjtc003 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte003 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte003;}
                        }
                        if (jjte003 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte003;}
                        }
                        {if (true) throw (Error)jjte003;}
        } finally {
                        if (jjtc003) {
                          jjtree.closeNodeScope(jjtn003,  2);
                        }
        }
        break;
      case LOGICAL_GE:
        jj_consume_token(LOGICAL_GE);
                        ASTGENode jjtn004 = new ASTGENode(this, JJTGENODE);
                        boolean jjtc004 = true;
                        jjtree.openNodeScope(jjtn004);
        try {
          AdditiveExpression();
        } catch (Throwable jjte004) {
                        if (jjtc004) {
                          jjtree.clearNodeScope(jjtn004);
                          jjtc004 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte004 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte004;}
                        }
                        if (jjte004 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte004;}
                        }
                        {if (true) throw (Error)jjte004;}
        } finally {
                        if (jjtc004) {
                          jjtree.closeNodeScope(jjtn004,  2);
                        }
        }
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void AdditiveExpression() throws ParseException {
    MultiplicativeExpression();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
      case PLUS:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_17;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                  ASTAddNode jjtn001 = new ASTAddNode(this, JJTADDNODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
          MultiplicativeExpression();
        } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
        break;
      case MINUS:
        jj_consume_token(MINUS);
                  ASTSubtractNode jjtn002 = new ASTSubtractNode(this, JJTSUBTRACTNODE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
        try {
          MultiplicativeExpression();
        } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte002;}
                  }
                  if (jjte002 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte002;}
                  }
                  {if (true) throw (Error)jjte002;}
        } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  2);
                  }
        }
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void MultiplicativeExpression() throws ParseException {
    UnaryExpression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case MODULUS:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_18;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        jj_consume_token(MULTIPLY);
                          ASTMulNode jjtn001 = new ASTMulNode(this, JJTMULNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
          UnaryExpression();
        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            {if (true) throw (RuntimeException)jjte001;}
                          }
                          if (jjte001 instanceof ParseException) {
                            {if (true) throw (ParseException)jjte001;}
                          }
                          {if (true) throw (Error)jjte001;}
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
        }
        break;
      case DIVIDE:
        jj_consume_token(DIVIDE);
                        ASTDivNode jjtn002 = new ASTDivNode(this, JJTDIVNODE);
                        boolean jjtc002 = true;
                        jjtree.openNodeScope(jjtn002);
        try {
          UnaryExpression();
        } catch (Throwable jjte002) {
                        if (jjtc002) {
                          jjtree.clearNodeScope(jjtn002);
                          jjtc002 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte002 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte002;}
                        }
                        if (jjte002 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte002;}
                        }
                        {if (true) throw (Error)jjte002;}
        } finally {
                        if (jjtc002) {
                          jjtree.closeNodeScope(jjtn002,  2);
                        }
        }
        break;
      case MODULUS:
        jj_consume_token(MODULUS);
                         ASTModNode jjtn003 = new ASTModNode(this, JJTMODNODE);
                         boolean jjtc003 = true;
                         jjtree.openNodeScope(jjtn003);
        try {
          UnaryExpression();
        } catch (Throwable jjte003) {
                         if (jjtc003) {
                           jjtree.clearNodeScope(jjtn003);
                           jjtc003 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte003 instanceof RuntimeException) {
                           {if (true) throw (RuntimeException)jjte003;}
                         }
                         if (jjte003 instanceof ParseException) {
                           {if (true) throw (ParseException)jjte003;}
                         }
                         {if (true) throw (Error)jjte003;}
        } finally {
                         if (jjtc003) {
                           jjtree.closeNodeScope(jjtn003,  2);
                         }
        }
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void UnaryExpression() throws ParseException {
    if (jj_2_10(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      jj_consume_token(LOGICAL_NOT);
                                                    ASTNotNode jjtn001 = new ASTNotNode(this, JJTNOTNODE);
                                                    boolean jjtc001 = true;
                                                    jjtree.openNodeScope(jjtn001);
      try {
        UnaryExpression();
      } catch (Throwable jjte001) {
                                                    if (jjtc001) {
                                                      jjtree.clearNodeScope(jjtn001);
                                                      jjtc001 = false;
                                                    } else {
                                                      jjtree.popNode();
                                                    }
                                                    if (jjte001 instanceof RuntimeException) {
                                                      {if (true) throw (RuntimeException)jjte001;}
                                                    }
                                                    if (jjte001 instanceof ParseException) {
                                                      {if (true) throw (ParseException)jjte001;}
                                                    }
                                                    {if (true) throw (Error)jjte001;}
      } finally {
                                                    if (jjtc001) {
                                                      jjtree.closeNodeScope(jjtn001,  1);
                                                    }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case LPAREN:
      case WHITESPACE:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case NUMBER_LITERAL:
      case IDENTIFIER:
      case LCURLY:
        PrimaryExpression();
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void PrimaryExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      StringLiteral();
      break;
    case NUMBER_LITERAL:
      NumberLiteral();
      break;
    case IDENTIFIER:
    case LCURLY:
      Reference();
      break;
    default:
      jj_la1[52] = jj_gen;
      if (jj_2_11(2147483647)) {
        IntegerRange();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ObjectArray();
          break;
        case TRUE:
          True();
          break;
        case FALSE:
          False();
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          Expression();
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
  }
  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }
  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }
  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }
  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }
  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }
  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }
  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }
  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_8();
    jj_save(7, xla);
    return retval;
  }
  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_9();
    jj_save(8, xla);
    return retval;
  }
  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_10();
    jj_save(9, xla);
    return retval;
  }
  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_11();
    jj_save(10, xla);
    return retval;
  }
  final private boolean jj_3R_54() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_24() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_41() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_24()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_25()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_38() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_29() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_32() {
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_30() {
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_37() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_2() {
    if (jj_scan_token(DOUBLE_ESCAPE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_28() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_36() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_9() {
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_82() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_23() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_7() {
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_27() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_58() {
    if (jj_scan_token(FALSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_35() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_57() {
    if (jj_scan_token(TRUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_8() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_51() {
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_82()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3_6() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_40() {
    if (jj_scan_token(LCURLY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_8()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RCURLY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_22() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_11() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_38()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DOUBLEDOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_26() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_39() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3_1() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_81() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_80() {
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_33() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_79() {
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_78() {
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_77() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_76() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_21() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_5() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_26()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_29()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DOUBLEDOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_75() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_31() {
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(REFMOD2_RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_74() {
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_73() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_85() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_72() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_71() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_83() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_70() {
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_69() {
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LOGICAL_NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_34()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_52() {
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_68() {
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_67() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_66() {
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_20() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_87() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_89() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_63() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_65() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_83()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_61() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_3() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_23()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DOUBLEDOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_49() {
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_88() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_86() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_48() {
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_84() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_62() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_64() {
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_89()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_47() {
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_55() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_84()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DOUBLEDOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_85()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_88()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_46() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_45() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_56() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_44() {
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_43() {
    if (jj_3R_53()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_42() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_53() {
    if (jj_scan_token(WORD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_50() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  public ParserTokenManager token_source;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[55];
  final private int[] jj_la1_0 = {0x13f0360,0x0,0x13f0360,0x380000,0x1000000,0x6000002,0x800000,0x800000,0x800000,0x13f0360,0x8,0x7800002,0x800000,0x0,0x800000,0x800000,0x0,0x800000,0x800000,0x1000000,0x6000002,0x800000,0x8,0x7800002,0x0,0x0,0x0,0x1060060,0x800000,0x13f0360,0x0,0x0,0x0,0x13f0360,0x800000,0x13f0360,0x800000,0x800000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x30000000,0xc0000000,0xc0000000,0x800000,0x7800022,0x800000,0x1000000,0x6000022,0x800000,};
  final private int[] jj_la1_1 = {0xf129000,0x9000,0xe120000,0x0,0x5120000,0x0,0x0,0x0,0x0,0xf129000,0x0,0x5020000,0x0,0x5020000,0x0,0x0,0x5020000,0x0,0x0,0x0,0x5020000,0x0,0x0,0x5020000,0x1000000,0x1000000,0x5000000,0xe020000,0x0,0xf129000,0x2000,0x2000,0x4000,0xf129000,0x0,0xf129000,0x0,0x0,0x0,0x4,0x2,0x180,0x180,0x78,0x78,0x0,0x0,0x1,0x1,0x0,0x5020000,0x0,0x5020000,0x0,0x0,};
  final private JJCalls[] jj_2_rtns = new JJCalls[11];
  private boolean jj_rescan = false;
  private int jj_gc = 0;
  public Parser(CharStream stream) {
    token_source = new ParserTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }
  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }
  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }
  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;
  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
        int[] oldentry = (int[])(enum.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }
  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[62];
    for (int i = 0; i < 62; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 55; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 62; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }
  final public void enable_tracing() {
  }
  final public void disable_tracing() {
  }
  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 11; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }
  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }
  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }
}
"
org.apache.velocity.runtime.parser.ParserConstants,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserConstants.java */
package org.apache.velocity.runtime.parser;
public interface ParserConstants {
  int EOF = 0;
  int LBRACKET = 1;
  int RBRACKET = 2;
  int COMMA = 3;
  int DOUBLEDOT = 4;
  int LPAREN = 5;
  int RPAREN = 6;
  int REFMOD2_RPAREN = 7;
  int ESCAPE_DIRECTIVE = 8;
  int SET_DIRECTIVE = 9;
  int DOLLAR = 10;
  int DOLLARBANG = 11;
  int HASH = 15;
  int DOUBLE_ESCAPE = 16;
  int ESCAPE = 17;
  int TEXT = 18;
  int SINGLE_LINE_COMMENT = 19;
  int FORMAL_COMMENT = 20;
  int MULTI_LINE_COMMENT = 21;
  int WHITESPACE = 23;
  int STRING_LITERAL = 24;
  int TRUE = 25;
  int FALSE = 26;
  int NEWLINE = 27;
  int MINUS = 28;
  int PLUS = 29;
  int MULTIPLY = 30;
  int DIVIDE = 31;
  int MODULUS = 32;
  int LOGICAL_AND = 33;
  int LOGICAL_OR = 34;
  int LOGICAL_LT = 35;
  int LOGICAL_LE = 36;
  int LOGICAL_GT = 37;
  int LOGICAL_GE = 38;
  int LOGICAL_EQUALS = 39;
  int LOGICAL_NOT_EQUALS = 40;
  int LOGICAL_NOT = 41;
  int EQUALS = 42;
  int END = 43;
  int IF_DIRECTIVE = 44;
  int ELSEIF_DIRECTIVE = 45;
  int ELSE_DIRECTIVE = 46;
  int STOP_DIRECTIVE = 47;
  int DIGIT = 48;
  int NUMBER_LITERAL = 49;
  int LETTER = 50;
  int DIRECTIVE_CHAR = 51;
  int WORD = 52;
  int ALPHA_CHAR = 53;
  int ALPHANUM_CHAR = 54;
  int IDENTIFIER_CHAR = 55;
  int IDENTIFIER = 56;
  int DOT = 57;
  int LCURLY = 58;
  int RCURLY = 59;
  int REFERENCE_TERMINATOR = 60;
  int DIRECTIVE_TERMINATOR = 61;
  int DIRECTIVE = 0;
  int REFMOD2 = 1;
  int REFMODIFIER = 2;
  int DEFAULT = 3;
  int PRE_DIRECTIVE = 4;
  int REFERENCE = 5;
  int IN_MULTI_LINE_COMMENT = 6;
  int IN_FORMAL_COMMENT = 7;
  int IN_SINGLE_LINE_COMMENT = 8;
  String[] tokenImage = {
    ""<EOF>"",
    ""\""[\"""",
    ""\""]\"""",
    ""\"",\"""",
    ""\""..\"""",
    ""\""(\"""",
    ""<RPAREN>"",
    ""\"")\"""",
    ""<ESCAPE_DIRECTIVE>"",
    ""<SET_DIRECTIVE>"",
    ""<DOLLAR>"",
    ""<DOLLARBANG>"",
    ""\""##\"""",
    ""<token of kind 13>"",
    ""\""#*\"""",
    ""\""#\"""",
    ""\""\\\\\\\\\"""",
    ""\""\\\\\"""",
    ""<TEXT>"",
    ""<SINGLE_LINE_COMMENT>"",
    ""\""*#\"""",
    ""\""*#\"""",
    ""<token of kind 22>"",
    ""<WHITESPACE>"",
    ""<STRING_LITERAL>"",
    ""\""true\"""",
    ""\""false\"""",
    ""<NEWLINE>"",
    ""\""-\"""",
    ""\""+\"""",
    ""\""*\"""",
    ""\""/\"""",
    ""\""%\"""",
    ""\""&&\"""",
    ""\""||\"""",
    ""\""<\"""",
    ""\""<=\"""",
    ""\"">\"""",
    ""\"">=\"""",
    ""\""==\"""",
    ""\""!=\"""",
    ""\""!\"""",
    ""\""=\"""",
    ""<END>"",
    ""\""if\"""",
    ""\""elseif\"""",
    ""<ELSE_DIRECTIVE>"",
    ""\""stop\"""",
    ""<DIGIT>"",
    ""<NUMBER_LITERAL>"",
    ""<LETTER>"",
    ""<DIRECTIVE_CHAR>"",
    ""<WORD>"",
    ""<ALPHA_CHAR>"",
    ""<ALPHANUM_CHAR>"",
    ""<IDENTIFIER_CHAR>"",
    ""<IDENTIFIER>"",
    ""<DOT>"",
    ""\""{\"""",
    ""\""}\"""",
    ""<REFERENCE_TERMINATOR>"",
    ""<DIRECTIVE_TERMINATOR>"",
  };
}
"
org.apache.velocity.runtime.parser.ParserTokenManager,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserTokenManager.java */
package org.apache.velocity.runtime.parser;
import java.io.*;
import java.util.*;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.*;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.directive.Macro;
import org.apache.velocity.runtime.directive.MacroParseException;
import org.apache.velocity.util.StringUtils;
public class ParserTokenManager implements ParserConstants
{
    private int fileDepth = 0;
    private int lparen = 0;
    private int rparen = 0;
    Stack stateStack = new Stack();
    public boolean debugPrint = false;
    private boolean inReference;
    public boolean inDirective;
    private boolean inComment;
    public  boolean inSet;
    /**
     *  pushes the current state onto the 'state stack',
     *  and maintains the parens counts
     *  public because we need it in PD & VM handling
     *
     *  @return boolean : success.  It can fail if the state machine
     *     gets messed up (do don't mess it up :)
     */
    public boolean stateStackPop()
    {
        Hashtable h;
        try
        {
            h = (Hashtable) stateStack.pop();
        }
        catch( EmptyStackException e)
        {
            lparen=0;
            SwitchTo(DEFAULT);
            return false;
        }
        if( debugPrint )
            System.out.println(
                "" stack pop ("" + stateStack.size() + "") : lparen="" +
                    ( (Integer) h.get(""lparen"")).intValue() +
                        "" newstate="" + ( (Integer) h.get(""lexstate"")).intValue() );
        lparen = ( (Integer) h.get(""lparen"")).intValue();
        rparen = ( (Integer) h.get(""rparen"")).intValue();
        SwitchTo( ( (Integer) h.get(""lexstate"")).intValue() );
        return true;
    }
    /**
     *  pops a state off the stack, and restores paren counts
     *
     *  @return boolean : success of operation
     */
    public boolean stateStackPush()
    {
        if( debugPrint )
            System.out.println("" ("" + stateStack.size() + "") pushing cur state : "" +
                curLexState );
        Hashtable h = new Hashtable();
        h.put(""lexstate"", new Integer( curLexState ) );
        h.put(""lparen"", new Integer( lparen ));
        h.put(""rparen"", new Integer( rparen ));
        lparen = 0;
        stateStack.push( h );
        return true;
    }
    /**
     *  Clears all state variables, resets to
     *  start values, clears stateStack.  Call
     *  before parsing.
     *  @return void
     */
    public void clearStateVars()
    {
        stateStack.clear();
        lparen = 0;
        rparen = 0;
        inReference = false;
        inDirective = false;
        inComment = false;
        inSet = false;
        return;
    }
    /**
     *  handles the dropdown logic when encountering a RPAREN
     */
    private void RPARENHandler()
    {
        /*
         *  Ultimately, we want to drop down to the state below
         *  the one that has an open (if we hit bottom (DEFAULT),
         *  that's fine. It's just text schmoo.
         */
        boolean closed = false;
        if (inComment)
            closed = true;
        while( !closed )
        {
            /*
             * look at current state.  If we haven't seen a lparen
             * in this state then we drop a state, because this
             * lparen clearly closes our state
             */
            if( lparen > 0)
            {
                /*
                 *  if rparen + 1 == lparen, then this state is closed.
                 * Otherwise, increment and keep parsing
                 */
                 if( lparen == rparen + 1)
                 {
                       stateStackPop();
                 }
                else
                {
                    rparen++;
                }
                 closed = true;
            }
            else
            {
                /*
                 * now, drop a state
                 */
                if(!stateStackPop())
                    break;
            }
        }
    }
  public  java.io.PrintStream debugStream = System.out;
  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private final int jjStopStringLiteralDfa_0(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 52;
            return 33;
         }
         if ((active0 & 0x10000000L) != 0L)
            return 31;
         if ((active0 & 0xd000L) != 0L)
            return 7;
         return -1;
      case 1:
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 1;
            return 33;
         }
         if ((active0 & 0x4000L) != 0L)
            return 5;
         return -1;
      case 2:
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 2;
            return 33;
         }
         return -1;
      case 3:
         if ((active0 & 0x4000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 3;
            return 33;
         }
         if ((active0 & 0x2000000L) != 0L)
            return 33;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
}
private final int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private final int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 33:
         jjmatchedKind = 41;
         return jjMoveStringLiteralDfa1_0(0x10000000000L);
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_0(0x5000L);
      case 37:
         return jjStopAtPos(0, 32);
      case 38:
         return jjMoveStringLiteralDfa1_0(0x200000000L);
      case 40:
         return jjStopAtPos(0, 5);
      case 42:
         return jjStopAtPos(0, 30);
      case 43:
         return jjStopAtPos(0, 29);
      case 44:
         return jjStopAtPos(0, 3);
      case 45:
         return jjStartNfaWithStates_0(0, 28, 31);
      case 46:
         return jjMoveStringLiteralDfa1_0(0x10L);
      case 47:
         return jjStopAtPos(0, 31);
      case 60:
         jjmatchedKind = 35;
         return jjMoveStringLiteralDfa1_0(0x1000000000L);
      case 61:
         jjmatchedKind = 42;
         return jjMoveStringLiteralDfa1_0(0x8000000000L);
      case 62:
         jjmatchedKind = 37;
         return jjMoveStringLiteralDfa1_0(0x4000000000L);
      case 91:
         return jjStopAtPos(0, 1);
      case 93:
         return jjStopAtPos(0, 2);
      case 102:
         return jjMoveStringLiteralDfa1_0(0x4000000L);
      case 116:
         return jjMoveStringLiteralDfa1_0(0x2000000L);
      case 124:
         return jjMoveStringLiteralDfa1_0(0x400000000L);
      default :
         return jjMoveNfa_0(0, 0);
   }
}
private final int jjMoveStringLiteralDfa1_0(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         break;
      case 38:
         if ((active0 & 0x200000000L) != 0L)
            return jjStopAtPos(1, 33);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_0(1, 14, 5);
         break;
      case 46:
         if ((active0 & 0x10L) != 0L)
            return jjStopAtPos(1, 4);
         break;
      case 61:
         if ((active0 & 0x1000000000L) != 0L)
            return jjStopAtPos(1, 36);
         else if ((active0 & 0x4000000000L) != 0L)
            return jjStopAtPos(1, 38);
         else if ((active0 & 0x8000000000L) != 0L)
            return jjStopAtPos(1, 39);
         else if ((active0 & 0x10000000000L) != 0L)
            return jjStopAtPos(1, 40);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_0(active0, 0x4000000L);
      case 114:
         return jjMoveStringLiteralDfa2_0(active0, 0x2000000L);
      case 124:
         if ((active0 & 0x400000000L) != 0L)
            return jjStopAtPos(1, 34);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0);
}
private final int jjMoveStringLiteralDfa2_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(0, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_0(active0, 0x4000000L);
      case 117:
         return jjMoveStringLiteralDfa3_0(active0, 0x2000000L);
      default :
         break;
   }
   return jjStartNfa_0(1, active0);
}
private final int jjMoveStringLiteralDfa3_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(1, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_0(3, 25, 33);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_0(active0, 0x4000000L);
      default :
         break;
   }
   return jjStartNfa_0(2, active0);
}
private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(2, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_0(4, 26, 33);
         break;
      default :
         break;
   }
   return jjStartNfa_0(3, active0);
}
private final void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private final void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private final void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}
private final void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}
private final void jjCheckNAddStates(int start)
{
   jjCheckNAdd(jjnextStates[start]);
   jjCheckNAdd(jjnextStates[start + 1]);
}
static final long[] jjbitVec0 = {
   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec2 = {
   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
};
private final int jjMoveNfa_0(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 42;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 49)
                        kind = 49;
                     jjCheckNAdd(31);
                  }
                  else if ((0x2400L & l) != 0L)
                  {
                     if (kind > 27)
                        kind = 27;
                  }
                  else if ((0x100000200L & l) != 0L)
                  {
                     if (kind > 23)
                        kind = 23;
                     jjCheckNAdd(9);
                  }
                  else if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(39, 40);
                  }
                  else if (curChar == 45)
                     jjCheckNAdd(31);
                  else if (curChar == 39)
                     jjCheckNAddStates(0, 2);
                  else if (curChar == 34)
                     jjCheckNAddStates(3, 5);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 7;
                  else if (curChar == 41)
                  {
                     if (kind > 6)
                        kind = 6;
                     jjCheckNAddStates(6, 8);
                  }
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 28;
                  break;
               case 1:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if ((0x2400L & l) != 0L && kind > 6)
                     kind = 6;
                  break;
               case 3:
                  if (curChar == 10 && kind > 6)
                     kind = 6;
                  break;
               case 4:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 3;
                  break;
               case 5:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 6;
                  break;
               case 6:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 7:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 8:
                  if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 9:
                  if ((0x100000200L & l) == 0L)
                     break;
                  if (kind > 23)
                     kind = 23;
                  jjCheckNAdd(9);
                  break;
               case 10:
                  if (curChar == 34)
                     jjCheckNAddStates(3, 5);
                  break;
               case 11:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     jjCheckNAddStates(3, 5);
                  break;
               case 12:
                  if (curChar == 34 && kind > 24)
                     kind = 24;
                  break;
               case 14:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(3, 5);
                  break;
               case 15:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(9, 12);
                  break;
               case 16:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(3, 5);
                  break;
               case 17:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 18;
                  break;
               case 18:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(16);
                  break;
               case 19:
                  if (curChar == 32)
                     jjAddStates(13, 14);
                  break;
               case 20:
                  if (curChar == 10)
                     jjCheckNAddStates(3, 5);
                  break;
               case 21:
                  if (curChar == 39)
                     jjCheckNAddStates(0, 2);
                  break;
               case 22:
                  if ((0xffffff7fffffdbffL & l) != 0L)
                     jjCheckNAddStates(0, 2);
                  break;
               case 24:
                  if (curChar == 32)
                     jjAddStates(15, 16);
                  break;
               case 25:
                  if (curChar == 10)
                     jjCheckNAddStates(0, 2);
                  break;
               case 26:
                  if (curChar == 39 && kind > 24)
                     kind = 24;
                  break;
               case 27:
                  if ((0x2400L & l) != 0L && kind > 27)
                     kind = 27;
                  break;
               case 28:
                  if (curChar == 10 && kind > 27)
                     kind = 27;
                  break;
               case 29:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 28;
                  break;
               case 30:
                  if (curChar == 45)
                     jjCheckNAdd(31);
                  break;
               case 31:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 49)
                     kind = 49;
                  jjCheckNAdd(31);
                  break;
               case 33:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjstateSet[jjnewStateCnt++] = 33;
                  break;
               case 36:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 38:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(39, 40);
                  break;
               case 40:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 41:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(39, 40);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAdd(33);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(17, 20);
                  break;
               case 6:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 11:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAddStates(3, 5);
                  break;
               case 13:
                  if (curChar == 92)
                     jjAddStates(21, 25);
                  break;
               case 14:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(3, 5);
                  break;
               case 22:
                  jjAddStates(0, 2);
                  break;
               case 23:
                  if (curChar == 92)
                     jjAddStates(15, 16);
                  break;
               case 32:
               case 33:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAdd(33);
                  break;
               case 34:
                  if (curChar == 92)
                     jjCheckNAddStates(17, 20);
                  break;
               case 35:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(35, 36);
                  break;
               case 37:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(37, 38);
                  break;
               case 39:
                  if (curChar == 92)
                     jjAddStates(26, 27);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               case 11:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(3, 5);
                  break;
               case 22:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(0, 2);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 42 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_6(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xd000L) != 0L)
            return 2;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_6(int pos, long active0)
{
   return jjMoveNfa_6(jjStopStringLiteralDfa_6(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_6(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_6(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_6()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_6(0x5000L);
      case 42:
         return jjMoveStringLiteralDfa1_6(0x200000L);
      default :
         return jjMoveNfa_6(3, 0);
   }
}
private final int jjMoveStringLiteralDfa1_6(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_6(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         else if ((active0 & 0x200000L) != 0L)
            return jjStopAtPos(1, 21);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_6(1, 14, 0);
         break;
      default :
         break;
   }
   return jjStartNfa_6(0, active0);
}
private final int jjMoveNfa_6(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 12;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(9, 10);
                  }
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 6:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 8:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(9, 10);
                  break;
               case 10:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 11:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(9, 10);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 92)
                     jjCheckNAddStates(28, 31);
                  break;
               case 1:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 5:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(5, 6);
                  break;
               case 7:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(7, 8);
                  break;
               case 9:
                  if (curChar == 92)
                     jjAddStates(32, 33);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 12 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_4(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xd000L) != 0L)
            return 2;
         if ((active0 & 0x200000000000L) != 0L)
         {
            jjmatchedKind = 52;
            return 22;
         }
         if ((active0 & 0x900000000000L) != 0L)
         {
            jjmatchedKind = 52;
            return 7;
         }
         return -1;
      case 1:
         if ((active0 & 0x4000L) != 0L)
            return 0;
         if ((active0 & 0x200000000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 1;
            return 28;
         }
         if ((active0 & 0x800000000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 1;
            return 7;
         }
         if ((active0 & 0x100000000000L) != 0L)
            return 7;
         return -1;
      case 2:
         if ((active0 & 0x200000000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 2;
            return 23;
         }
         if ((active0 & 0x800000000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 2;
            return 7;
         }
         return -1;
      case 3:
         if ((active0 & 0x800000000000L) != 0L)
            return 7;
         if ((active0 & 0x200000000000L) != 0L)
         {
            jjmatchedKind = 46;
            jjmatchedPos = 3;
            return 30;
         }
         return -1;
      case 4:
         if ((active0 & 0x200000000000L) != 0L)
         {
            jjmatchedKind = 52;
            jjmatchedPos = 4;
            return 7;
         }
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_4(int pos, long active0)
{
   return jjMoveNfa_4(jjStopStringLiteralDfa_4(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_4(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_4(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_4()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_4(0x5000L);
      case 101:
         return jjMoveStringLiteralDfa1_4(0x200000000000L);
      case 105:
         return jjMoveStringLiteralDfa1_4(0x100000000000L);
      case 115:
         return jjMoveStringLiteralDfa1_4(0x800000000000L);
      default :
         return jjMoveNfa_4(3, 0);
   }
}
private final int jjMoveStringLiteralDfa1_4(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_4(1, 14, 0);
         break;
      case 102:
         if ((active0 & 0x100000000000L) != 0L)
            return jjStartNfaWithStates_4(1, 44, 7);
         break;
      case 108:
         return jjMoveStringLiteralDfa2_4(active0, 0x200000000000L);
      case 116:
         return jjMoveStringLiteralDfa2_4(active0, 0x800000000000L);
      default :
         break;
   }
   return jjStartNfa_4(0, active0);
}
private final int jjMoveStringLiteralDfa2_4(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_4(0, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 111:
         return jjMoveStringLiteralDfa3_4(active0, 0x800000000000L);
      case 115:
         return jjMoveStringLiteralDfa3_4(active0, 0x200000000000L);
      default :
         break;
   }
   return jjStartNfa_4(1, active0);
}
private final int jjMoveStringLiteralDfa3_4(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_4(1, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         return jjMoveStringLiteralDfa4_4(active0, 0x200000000000L);
      case 112:
         if ((active0 & 0x800000000000L) != 0L)
            return jjStartNfaWithStates_4(3, 47, 7);
         break;
      default :
         break;
   }
   return jjStartNfa_4(2, active0);
}
private final int jjMoveStringLiteralDfa4_4(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_4(2, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa5_4(active0, 0x200000000000L);
      default :
         break;
   }
   return jjStartNfa_4(3, active0);
}
private final int jjMoveStringLiteralDfa5_4(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_4(3, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(4, active0);
      return 5;
   }
   switch(curChar)
   {
      case 102:
         if ((active0 & 0x200000000000L) != 0L)
            return jjStartNfaWithStates_4(5, 45, 7);
         break;
      default :
         break;
   }
   return jjStartNfa_4(4, active0);
}
private final int jjMoveNfa_4(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 30;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 49)
                        kind = 49;
                     jjCheckNAdd(5);
                  }
                  else if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(13, 14);
                  }
                  else if (curChar == 45)
                     jjCheckNAdd(5);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 30:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAdd(7);
                  }
                  else if ((0x2400L & l) != 0L)
                  {
                     if (kind > 46)
                        kind = 46;
                  }
                  else if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(34, 36);
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 26;
                  break;
               case 22:
               case 7:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAdd(7);
                  break;
               case 28:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAdd(7);
                  break;
               case 23:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAdd(7);
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 4:
                  if (curChar == 45)
                     jjCheckNAdd(5);
                  break;
               case 5:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 49)
                     kind = 49;
                  jjCheckNAdd(5);
                  break;
               case 10:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 12:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(13, 14);
                  break;
               case 14:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 15:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(13, 14);
                  break;
               case 18:
                  if ((0x100000200L & l) != 0L)
                     jjAddStates(37, 39);
                  break;
               case 19:
                  if ((0x2400L & l) != 0L && kind > 43)
                     kind = 43;
                  break;
               case 20:
                  if (curChar == 10 && kind > 43)
                     kind = 43;
                  break;
               case 21:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 20;
                  break;
               case 24:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(34, 36);
                  break;
               case 25:
                  if ((0x2400L & l) != 0L && kind > 46)
                     kind = 46;
                  break;
               case 26:
                  if (curChar == 10 && kind > 46)
                     kind = 46;
                  break;
               case 27:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 26;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAdd(7);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(40, 43);
                  if (curChar == 101)
                     jjAddStates(44, 45);
                  break;
               case 30:
               case 7:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAdd(7);
                  break;
               case 22:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAdd(7);
                  }
                  if (curChar == 108)
                     jjstateSet[jjnewStateCnt++] = 28;
                  else if (curChar == 110)
                     jjstateSet[jjnewStateCnt++] = 17;
                  break;
               case 28:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAdd(7);
                  }
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 23;
                  break;
               case 23:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAdd(7);
                  }
                  if (curChar == 101)
                  {
                     if (kind > 46)
                        kind = 46;
                     jjAddStates(34, 36);
                  }
                  break;
               case 1:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 6:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAdd(7);
                  break;
               case 8:
                  if (curChar == 92)
                     jjCheckNAddStates(40, 43);
                  break;
               case 9:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(9, 10);
                  break;
               case 11:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(11, 12);
                  break;
               case 13:
                  if (curChar == 92)
                     jjAddStates(46, 47);
                  break;
               case 16:
                  if (curChar == 101)
                     jjAddStates(44, 45);
                  break;
               case 17:
                  if (curChar != 100)
                     break;
                  if (kind > 43)
                     kind = 43;
                  jjAddStates(37, 39);
                  break;
               case 29:
                  if (curChar == 108)
                     jjstateSet[jjnewStateCnt++] = 28;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 30 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_3(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x30000L) != 0L)
            return 9;
         if ((active0 & 0xd000L) != 0L)
            return 16;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_3(int pos, long active0)
{
   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_3(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_3(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_3()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_3(0x5000L);
      case 92:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_3(0x10000L);
      default :
         return jjMoveNfa_3(13, 0);
   }
}
private final int jjMoveStringLiteralDfa1_3(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_3(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_3(1, 14, 14);
         break;
      case 92:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_3(1, 16, 25);
         break;
      default :
         break;
   }
   return jjStartNfa_3(0, active0);
}
private final int jjMoveNfa_3(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 25;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 16:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 14;
                  break;
               case 13:
                  if ((0xffffffe7ffffffffL & l) != 0L)
                  {
                     if (kind > 18)
                        kind = 18;
                     jjCheckNAdd(7);
                  }
                  else if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(22, 23);
                  }
                  else if (curChar == 35)
                     jjCheckNAddTwoStates(5, 16);
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 6);
                  break;
               case 25:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(22, 23);
                  if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                  }
                  break;
               case 9:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(22, 23);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 11;
                  if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                  }
                  break;
               case 0:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 6);
                  break;
               case 2:
                  if (curChar == 32)
                     jjAddStates(48, 49);
                  break;
               case 3:
                  if (curChar == 40 && kind > 9)
                     kind = 9;
                  break;
               case 6:
                  if (curChar == 35)
                     jjCheckNAdd(5);
                  break;
               case 7:
                  if ((0xffffffe7ffffffffL & l) == 0L)
                     break;
                  if (kind > 18)
                     kind = 18;
                  jjCheckNAdd(7);
                  break;
               case 10:
                  if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 11;
                  break;
               case 12:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 8)
                     kind = 8;
                  jjstateSet[jjnewStateCnt++] = 12;
                  break;
               case 14:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 15;
                  break;
               case 15:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 19:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 21:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(22, 23);
                  break;
               case 23:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 24:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(22, 23);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 16:
               case 5:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 13:
                  if ((0xffffffffefffffffL & l) != 0L)
                  {
                     if (kind > 18)
                        kind = 18;
                     jjCheckNAdd(7);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(50, 53);
                  if (curChar == 92)
                     jjAddStates(32, 33);
                  break;
               case 25:
                  if (curChar == 92)
                     jjAddStates(32, 33);
                  if (curChar == 92)
                     jjCheckNAddTwoStates(20, 21);
                  if (curChar == 92)
                     jjCheckNAddTwoStates(18, 19);
                  break;
               case 9:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(20, 21);
                  if (curChar == 92)
                     jjCheckNAddTwoStates(18, 19);
                  if (curChar == 92)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 1:
                  if (curChar == 116)
                     jjAddStates(48, 49);
                  break;
               case 4:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 7:
                  if ((0xffffffffefffffffL & l) == 0L)
                     break;
                  if (kind > 18)
                     kind = 18;
                  jjCheckNAdd(7);
                  break;
               case 8:
                  if (curChar == 92)
                     jjAddStates(32, 33);
                  break;
               case 11:
               case 12:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 8)
                     kind = 8;
                  jjCheckNAdd(12);
                  break;
               case 15:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 17:
                  if (curChar == 92)
                     jjCheckNAddStates(50, 53);
                  break;
               case 18:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(18, 19);
                  break;
               case 20:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(20, 21);
                  break;
               case 22:
                  if (curChar == 92)
                     jjAddStates(54, 55);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 13:
               case 7:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 18)
                     kind = 18;
                  jjCheckNAdd(7);
                  break;
               case 15:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 25 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_7(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xd000L) != 0L)
            return 2;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_7(int pos, long active0)
{
   return jjMoveNfa_7(jjStopStringLiteralDfa_7(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_7(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_7(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_7()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_7(0x5000L);
      case 42:
         return jjMoveStringLiteralDfa1_7(0x100000L);
      default :
         return jjMoveNfa_7(3, 0);
   }
}
private final int jjMoveStringLiteralDfa1_7(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_7(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         else if ((active0 & 0x100000L) != 0L)
            return jjStopAtPos(1, 20);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_7(1, 14, 0);
         break;
      default :
         break;
   }
   return jjStartNfa_7(0, active0);
}
private final int jjMoveNfa_7(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 12;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(9, 10);
                  }
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 6:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 8:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(9, 10);
                  break;
               case 10:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 11:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(9, 10);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 92)
                     jjCheckNAddStates(28, 31);
                  break;
               case 1:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 5:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(5, 6);
                  break;
               case 7:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(7, 8);
                  break;
               case 9:
                  if (curChar == 92)
                     jjAddStates(32, 33);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 12 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_8(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xd000L) != 0L)
            return 2;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_8(int pos, long active0)
{
   return jjMoveNfa_8(jjStopStringLiteralDfa_8(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_8(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_8(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_8()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_8(0x5000L);
      default :
         return jjMoveNfa_8(3, 0);
   }
}
private final int jjMoveStringLiteralDfa1_8(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_8(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_8(1, 14, 0);
         break;
      default :
         break;
   }
   return jjStartNfa_8(0, active0);
}
private final int jjMoveNfa_8(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 15;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x2400L & l) != 0L)
                  {
                     if (kind > 19)
                        kind = 19;
                  }
                  else if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(12, 13);
                  }
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 4:
                  if ((0x2400L & l) != 0L && kind > 19)
                     kind = 19;
                  break;
               case 5:
                  if (curChar == 10 && kind > 19)
                     kind = 19;
                  break;
               case 6:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 9:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 11:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(12, 13);
                  break;
               case 13:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 14:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(12, 13);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 92)
                     jjCheckNAddStates(56, 59);
                  break;
               case 1:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 8:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(8, 9);
                  break;
               case 10:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(10, 11);
                  break;
               case 12:
                  if (curChar == 92)
                     jjAddStates(60, 61);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 15 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_5(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xd000L) != 0L)
            return 2;
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            return 5;
         }
         return -1;
      case 1:
         if ((active0 & 0x4000L) != 0L)
            return 0;
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 1;
            return 5;
         }
         return -1;
      case 2:
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 2;
            return 5;
         }
         return -1;
      case 3:
         if ((active0 & 0x4000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 3;
            return 5;
         }
         if ((active0 & 0x2000000L) != 0L)
            return 5;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_5(int pos, long active0)
{
   return jjMoveNfa_5(jjStopStringLiteralDfa_5(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_5(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_5(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_5()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_5(0x5000L);
      case 102:
         return jjMoveStringLiteralDfa1_5(0x4000000L);
      case 116:
         return jjMoveStringLiteralDfa1_5(0x2000000L);
      case 123:
         return jjStopAtPos(0, 58);
      case 125:
         return jjStopAtPos(0, 59);
      default :
         return jjMoveNfa_5(3, 0);
   }
}
private final int jjMoveStringLiteralDfa1_5(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_5(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_5(1, 14, 0);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_5(active0, 0x4000000L);
      case 114:
         return jjMoveStringLiteralDfa2_5(active0, 0x2000000L);
      default :
         break;
   }
   return jjStartNfa_5(0, active0);
}
private final int jjMoveStringLiteralDfa2_5(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_5(0, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_5(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_5(active0, 0x4000000L);
      case 117:
         return jjMoveStringLiteralDfa3_5(active0, 0x2000000L);
      default :
         break;
   }
   return jjStartNfa_5(1, active0);
}
private final int jjMoveStringLiteralDfa3_5(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_5(1, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_5(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_5(3, 25, 5);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_5(active0, 0x4000000L);
      default :
         break;
   }
   return jjStartNfa_5(2, active0);
}
private final int jjMoveStringLiteralDfa4_5(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_5(2, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_5(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_5(4, 26, 5);
         break;
      default :
         break;
   }
   return jjStartNfa_5(3, active0);
}
private final int jjMoveNfa_5(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 16;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(13, 14);
                  }
                  else if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 7;
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 5:
                  if ((0x3ff200000000000L & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 6:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 10:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 12:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(13, 14);
                  break;
               case 14:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 15:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(13, 14);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     jjCheckNAdd(5);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(40, 43);
                  break;
               case 1:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 4:
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  jjCheckNAdd(5);
                  break;
               case 7:
                  if ((0x7fffffe07fffffeL & l) != 0L && kind > 57)
                     kind = 57;
                  break;
               case 8:
                  if (curChar == 92)
                     jjCheckNAddStates(40, 43);
                  break;
               case 9:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(9, 10);
                  break;
               case 11:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(11, 12);
                  break;
               case 13:
                  if (curChar == 92)
                     jjAddStates(46, 47);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 16 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_1(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xd000L) != 0L)
            return 2;
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            return 25;
         }
         if ((active0 & 0x10L) != 0L)
            return 27;
         return -1;
      case 1:
         if ((active0 & 0x4000L) != 0L)
            return 0;
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 1;
            return 25;
         }
         return -1;
      case 2:
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 2;
            return 25;
         }
         return -1;
      case 3:
         if ((active0 & 0x4000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 3;
            return 25;
         }
         if ((active0 & 0x2000000L) != 0L)
            return 25;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_1(int pos, long active0)
{
   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_1(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_1(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_1()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_1(0x5000L);
      case 41:
         return jjStopAtPos(0, 7);
      case 44:
         return jjStopAtPos(0, 3);
      case 46:
         return jjMoveStringLiteralDfa1_1(0x10L);
      case 91:
         return jjStopAtPos(0, 1);
      case 93:
         return jjStopAtPos(0, 2);
      case 102:
         return jjMoveStringLiteralDfa1_1(0x4000000L);
      case 116:
         return jjMoveStringLiteralDfa1_1(0x2000000L);
      case 123:
         return jjStopAtPos(0, 58);
      case 125:
         return jjStopAtPos(0, 59);
      default :
         return jjMoveNfa_1(3, 0);
   }
}
private final int jjMoveStringLiteralDfa1_1(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_1(1, 14, 0);
         break;
      case 46:
         if ((active0 & 0x10L) != 0L)
            return jjStopAtPos(1, 4);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_1(active0, 0x4000000L);
      case 114:
         return jjMoveStringLiteralDfa2_1(active0, 0x2000000L);
      default :
         break;
   }
   return jjStartNfa_1(0, active0);
}
private final int jjMoveStringLiteralDfa2_1(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(0, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_1(active0, 0x4000000L);
      case 117:
         return jjMoveStringLiteralDfa3_1(active0, 0x2000000L);
      default :
         break;
   }
   return jjStartNfa_1(1, active0);
}
private final int jjMoveStringLiteralDfa3_1(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(1, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_1(3, 25, 25);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_1(active0, 0x4000000L);
      default :
         break;
   }
   return jjStartNfa_1(2, active0);
}
private final int jjMoveStringLiteralDfa4_1(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(2, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_1(4, 26, 25);
         break;
      default :
         break;
   }
   return jjStartNfa_1(3, active0);
}
private final int jjMoveNfa_1(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 36;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 49)
                        kind = 49;
                     jjCheckNAdd(23);
                  }
                  else if ((0x100000200L & l) != 0L)
                  {
                     if (kind > 23)
                        kind = 23;
                     jjCheckNAdd(4);
                  }
                  else if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(33, 34);
                  }
                  else if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 27;
                  else if (curChar == 45)
                     jjCheckNAdd(23);
                  else if (curChar == 39)
                     jjCheckNAddStates(62, 64);
                  else if (curChar == 34)
                     jjCheckNAddStates(65, 67);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 4:
                  if ((0x100000200L & l) == 0L)
                     break;
                  if (kind > 23)
                     kind = 23;
                  jjCheckNAdd(4);
                  break;
               case 5:
                  if (curChar == 34)
                     jjCheckNAddStates(65, 67);
                  break;
               case 6:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     jjCheckNAddStates(65, 67);
                  break;
               case 7:
                  if (curChar == 34 && kind > 24)
                     kind = 24;
                  break;
               case 9:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(65, 67);
                  break;
               case 10:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(68, 71);
                  break;
               case 11:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(65, 67);
                  break;
               case 12:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 13;
                  break;
               case 13:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(11);
                  break;
               case 14:
                  if (curChar == 32)
                     jjAddStates(72, 73);
                  break;
               case 15:
                  if (curChar == 10)
                     jjCheckNAddStates(65, 67);
                  break;
               case 16:
                  if (curChar == 39)
                     jjCheckNAddStates(62, 64);
                  break;
               case 17:
                  if ((0xffffff7fffffdbffL & l) != 0L)
                     jjCheckNAddStates(62, 64);
                  break;
               case 19:
                  if (curChar == 32)
                     jjAddStates(13, 14);
                  break;
               case 20:
                  if (curChar == 10)
                     jjCheckNAddStates(62, 64);
                  break;
               case 21:
                  if (curChar == 39 && kind > 24)
                     kind = 24;
                  break;
               case 22:
                  if (curChar == 45)
                     jjCheckNAdd(23);
                  break;
               case 23:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 49)
                     kind = 49;
                  jjCheckNAdd(23);
                  break;
               case 25:
                  if ((0x3ff200000000000L & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  jjstateSet[jjnewStateCnt++] = 25;
                  break;
               case 26:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 27;
                  break;
               case 30:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 32:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(33, 34);
                  break;
               case 34:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 35:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(33, 34);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     jjCheckNAdd(25);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(74, 77);
                  break;
               case 1:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 6:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAddStates(65, 67);
                  break;
               case 8:
                  if (curChar == 92)
                     jjAddStates(78, 82);
                  break;
               case 9:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(65, 67);
                  break;
               case 17:
                  jjAddStates(62, 64);
                  break;
               case 18:
                  if (curChar == 92)
                     jjAddStates(13, 14);
                  break;
               case 24:
               case 25:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  jjCheckNAdd(25);
                  break;
               case 27:
                  if ((0x7fffffe07fffffeL & l) != 0L && kind > 57)
                     kind = 57;
                  break;
               case 28:
                  if (curChar == 92)
                     jjCheckNAddStates(74, 77);
                  break;
               case 29:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(29, 30);
                  break;
               case 31:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(31, 32);
                  break;
               case 33:
                  if (curChar == 92)
                     jjAddStates(83, 84);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(65, 67);
                  break;
               case 17:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(62, 64);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_2(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0xd000L) != 0L)
            return 2;
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            return 5;
         }
         return -1;
      case 1:
         if ((active0 & 0x4000L) != 0L)
            return 0;
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 1;
            return 5;
         }
         return -1;
      case 2:
         if ((active0 & 0x6000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 2;
            return 5;
         }
         return -1;
      case 3:
         if ((active0 & 0x4000000L) != 0L)
         {
            jjmatchedKind = 56;
            jjmatchedPos = 3;
            return 5;
         }
         if ((active0 & 0x2000000L) != 0L)
            return 5;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_2(int pos, long active0)
{
   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
}
private final int jjStartNfaWithStates_2(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_2(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_2()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 15;
         return jjMoveStringLiteralDfa1_2(0x5000L);
      case 40:
         return jjStopAtPos(0, 5);
      case 102:
         return jjMoveStringLiteralDfa1_2(0x4000000L);
      case 116:
         return jjMoveStringLiteralDfa1_2(0x2000000L);
      case 123:
         return jjStopAtPos(0, 58);
      case 125:
         return jjStopAtPos(0, 59);
      default :
         return jjMoveNfa_2(3, 0);
   }
}
private final int jjMoveStringLiteralDfa1_2(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x1000L) != 0L)
            return jjStopAtPos(1, 12);
         break;
      case 42:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_2(1, 14, 0);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_2(active0, 0x4000000L);
      case 114:
         return jjMoveStringLiteralDfa2_2(active0, 0x2000000L);
      default :
         break;
   }
   return jjStartNfa_2(0, active0);
}
private final int jjMoveStringLiteralDfa2_2(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(0, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_2(active0, 0x4000000L);
      case 117:
         return jjMoveStringLiteralDfa3_2(active0, 0x2000000L);
      default :
         break;
   }
   return jjStartNfa_2(1, active0);
}
private final int jjMoveStringLiteralDfa3_2(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(1, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x2000000L) != 0L)
            return jjStartNfaWithStates_2(3, 25, 5);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_2(active0, 0x4000000L);
      default :
         break;
   }
   return jjStartNfa_2(2, active0);
}
private final int jjMoveStringLiteralDfa4_2(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(2, old0); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_2(4, 26, 5);
         break;
      default :
         break;
   }
   return jjStartNfa_2(3, active0);
}
private final int jjMoveNfa_2(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 16;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 36)
                  {
                     if (kind > 10)
                        kind = 10;
                     jjCheckNAddTwoStates(13, 14);
                  }
                  else if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 7;
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 5:
                  if ((0x3ff200000000000L & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 6:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 10:
                  if (curChar == 36 && kind > 10)
                     kind = 10;
                  break;
               case 12:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(13, 14);
                  break;
               case 14:
                  if (curChar == 33 && kind > 11)
                     kind = 11;
                  break;
               case 15:
                  if (curChar != 36)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjCheckNAddTwoStates(13, 14);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 56)
                        kind = 56;
                     jjCheckNAdd(5);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(40, 43);
                  break;
               case 1:
                  if (kind > 13)
                     kind = 13;
                  break;
               case 4:
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 56)
                     kind = 56;
                  jjCheckNAdd(5);
                  break;
               case 7:
                  if ((0x7fffffe07fffffeL & l) != 0L && kind > 57)
                     kind = 57;
                  break;
               case 8:
                  if (curChar == 92)
                     jjCheckNAddStates(40, 43);
                  break;
               case 9:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(9, 10);
                  break;
               case 11:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(11, 12);
                  break;
               case 13:
                  if (curChar == 92)
                     jjAddStates(46, 47);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
                     kind = 13;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 16 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   22, 23, 26, 11, 12, 13, 1, 2, 4, 11, 16, 12, 13, 19, 20, 24, 
   25, 35, 36, 37, 38, 14, 15, 17, 19, 20, 39, 40, 5, 6, 7, 8, 
   9, 10, 24, 25, 27, 18, 19, 21, 9, 10, 11, 12, 22, 29, 13, 14, 
   2, 3, 18, 19, 20, 21, 22, 23, 8, 9, 10, 11, 12, 13, 17, 18, 
   21, 6, 7, 8, 6, 11, 7, 8, 14, 15, 29, 30, 31, 32, 9, 10, 
   12, 14, 15, 33, 34, 
};
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec2[i2] & l2) != 0L);
      default : 
         if ((jjbitVec0[i1] & l1) != 0L)
            return true;
         return false;
   }
}
public static final String[] jjstrLiteralImages = {
null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, };
public static final String[] lexStateNames = {
   ""DIRECTIVE"", 
   ""REFMOD2"", 
   ""REFMODIFIER"", 
   ""DEFAULT"", 
   ""PRE_DIRECTIVE"", 
   ""REFERENCE"", 
   ""IN_MULTI_LINE_COMMENT"", 
   ""IN_FORMAL_COMMENT"", 
   ""IN_SINGLE_LINE_COMMENT"", 
};
public static final int[] jjnewLexState = {
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
};
static final long[] jjtoToken = {
   0xf12ffffffbf03ffL, 
};
static final long[] jjtoSkip = {
   0x3000000000000000L, 
};
static final long[] jjtoSpecial = {
   0x3000000000000000L, 
};
static final long[] jjtoMore = {
   0x40fc00L, 
};
private CharStream input_stream;
private final int[] jjrounds = new int[42];
private final int[] jjstateSet = new int[84];
StringBuffer image;
int jjimageLen;
int lengthOfMatch;
protected char curChar;
public ParserTokenManager(CharStream stream)
{
   input_stream = stream;
}
public ParserTokenManager(CharStream stream, int lexState)
{
   this(stream);
   SwitchTo(lexState);
}
public void ReInit(CharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
private final void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 42; i-- > 0;)
      jjrounds[i] = 0x80000000;
}
public void ReInit(CharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}
public void SwitchTo(int lexState)
{
   if (lexState >= 9 || lexState < 0)
      throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}
private final Token jjFillToken()
{
   Token t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   String im = jjstrLiteralImages[jjmatchedKind];
   t.image = (im == null) ? input_stream.GetImage() : im;
   t.beginLine = input_stream.getBeginLine();
   t.beginColumn = input_stream.getBeginColumn();
   t.endLine = input_stream.getEndLine();
   t.endColumn = input_stream.getEndColumn();
   return t;
}
int curLexState = 3;
int defaultLexState = 3;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;
public final Token getNextToken() 
{
  int kind;
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;
  EOFLoop :
  for (;;)
  {   
   try   
   {     
      curChar = input_stream.BeginToken();
   }     
   catch(java.io.IOException e)
   {        
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
   }
   image = null;
   jjimageLen = 0;
   for (;;)
   {
     switch(curLexState)
     {
       case 0:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_0();
         break;
       case 1:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_1();
         if (jjmatchedPos == 0 && jjmatchedKind > 60)
         {
            jjmatchedKind = 60;
         }
         break;
       case 2:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_2();
         if (jjmatchedPos == 0 && jjmatchedKind > 60)
         {
            jjmatchedKind = 60;
         }
         break;
       case 3:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_3();
         break;
       case 4:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_4();
         if (jjmatchedPos == 0 && jjmatchedKind > 61)
         {
            jjmatchedKind = 61;
         }
         break;
       case 5:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_5();
         if (jjmatchedPos == 0 && jjmatchedKind > 60)
         {
            jjmatchedKind = 60;
         }
         break;
       case 6:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_6();
         if (jjmatchedPos == 0 && jjmatchedKind > 22)
         {
            jjmatchedKind = 22;
         }
         break;
       case 7:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_7();
         if (jjmatchedPos == 0 && jjmatchedKind > 22)
         {
            jjmatchedKind = 22;
         }
         break;
       case 8:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_8();
         if (jjmatchedPos == 0 && jjmatchedKind > 22)
         {
            jjmatchedKind = 22;
         }
         break;
     }
     if (jjmatchedKind != 0x7fffffff)
     {
        if (jjmatchedPos + 1 < curPos)
           input_stream.backup(curPos - jjmatchedPos - 1);
        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
        {
           matchedToken = jjFillToken();
           matchedToken.specialToken = specialToken;
           TokenLexicalActions(matchedToken);
       if (jjnewLexState[jjmatchedKind] != -1)
         curLexState = jjnewLexState[jjmatchedKind];
           return matchedToken;
        }
        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
        {
           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
           {
              matchedToken = jjFillToken();
              if (specialToken == null)
                 specialToken = matchedToken;
              else
              {
                 matchedToken.specialToken = specialToken;
                 specialToken = (specialToken.next = matchedToken);
              }
              SkipLexicalActions(matchedToken);
           }
           else 
              SkipLexicalActions(null);
         if (jjnewLexState[jjmatchedKind] != -1)
           curLexState = jjnewLexState[jjmatchedKind];
           continue EOFLoop;
        }
        MoreLexicalActions();
      if (jjnewLexState[jjmatchedKind] != -1)
        curLexState = jjnewLexState[jjmatchedKind];
        curPos = 0;
        jjmatchedKind = 0x7fffffff;
        try {
           curChar = input_stream.readChar();
           continue;
        }
        catch (java.io.IOException e1) { }
     }
     int error_line = input_stream.getEndLine();
     int error_column = input_stream.getEndColumn();
     String error_after = null;
     boolean EOFSeen = false;
     try { input_stream.readChar(); input_stream.backup(1); }
     catch (java.io.IOException e1) {
        EOFSeen = true;
        error_after = curPos <= 1 ? """" : input_stream.GetImage();
        if (curChar == '\n' || curChar == '\r') {
           error_line++;
           error_column = 0;
        }
        else
           error_column++;
     }
     if (!EOFSeen) {
        input_stream.backup(1);
        error_after = curPos <= 1 ? """" : input_stream.GetImage();
     }
     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
   }
  }
}
final void SkipLexicalActions(Token matchedToken)
{
   switch(jjmatchedKind)
   {
      case 60 :
         if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * push every terminator character back into the stream
         */
        input_stream.backup(1);
        inReference = false;
        if ( debugPrint )
            System.out.print(""REF_TERM :"");
        stateStackPop();
         break;
      case 61 :
         if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if ( debugPrint )
            System.out.print(""DIRECTIVE_TERM :"");
        input_stream.backup(1);
        inDirective = false;
        stateStackPop();
         break;
      default :
         break;
   }
}
final void MoreLexicalActions()
{
   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
   switch(jjmatchedKind)
   {
      case 10 :
         if (image == null)
              image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen)));
         else
            image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (! inComment)
        {
            /*
             * if we find ourselves in REFERENCE, we need to pop down
             * to end the previous ref
             */
            if (curLexState == REFERENCE)
            {
                inReference = false;
                stateStackPop();
            }
            inReference = true;
            if ( debugPrint )
                System.out.print( ""$  : going to "" + REFERENCE );
            stateStackPush();
            SwitchTo(REFERENCE);
        }
         break;
      case 11 :
         if (image == null)
              image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen)));
         else
            image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (! inComment)
        {
            /*
             * if we find ourselves in REFERENCE, we need to pop down
             * to end the previous ref
             */
            if (curLexState == REFERENCE)
            {
                inReference = false;
                stateStackPop();
            }
            inReference = true;
            if ( debugPrint )
                System.out.print( ""$!  : going to "" + REFERENCE );
            stateStackPush();
            SwitchTo(REFERENCE);
        }
         break;
      case 12 :
         if (image == null)
              image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen)));
         else
            image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (!inComment)
        {
            if (curLexState == REFERENCE)
            {
                inReference = false;
                stateStackPop();
            }
            inComment = true;
            stateStackPush();
            SwitchTo(IN_SINGLE_LINE_COMMENT);
        }
         break;
      case 13 :
         if (image == null)
              image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen)));
         else
            image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        input_stream.backup(1);
        inComment = true;
        stateStackPush();
        SwitchTo( IN_FORMAL_COMMENT);
         break;
      case 14 :
         if (image == null)
              image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen)));
         else
            image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        inComment=true;
        stateStackPush();
        SwitchTo( IN_MULTI_LINE_COMMENT );
         break;
      case 15 :
         if (image == null)
              image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen)));
         else
            image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (! inComment)
        {
            /*
             * We can have the situation where #if($foo)$foo#end.
             * We need to transition out of REFERENCE before going to DIRECTIVE.
             * I don't really like this, but I can't think of a legal way
             * you are going into DIRECTIVE while in REFERENCE.  -gmj
             */
            if (curLexState == REFERENCE || curLexState == REFMODIFIER )
            {
                inReference = false;
                stateStackPop();
            }
            inDirective = true;
            if ( debugPrint )
                System.out.print(""# :  going to "" + DIRECTIVE );
            stateStackPush();
            SwitchTo(PRE_DIRECTIVE);
        }
         break;
      default : 
         break;
   }
}
final void TokenLexicalActions(Token matchedToken)
{
   switch(jjmatchedKind)
   {
      case 5 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if (!inComment)
            lparen++;
        /*
         * If in REFERENCE and we have seen the dot, then move
         * to REFMOD2 -> Modifier()
         */
        if (curLexState == REFMODIFIER )
            SwitchTo( REFMOD2 );
         break;
      case 6 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
       RPARENHandler();
         break;
      case 7 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * need to simply switch back to REFERENCE, not drop down the stack
         * because we can (infinitely) chain, ala
         * $foo.bar().blargh().woogie().doogie()
         */
        SwitchTo( REFERENCE );
         break;
      case 9 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if (! inComment)
        {
            inDirective = true;
            if ( debugPrint )
                System.out.print(""#set :  going to "" + DIRECTIVE );
            stateStackPush();
            inSet = true;
            SwitchTo(DIRECTIVE);
        }
        /*
         *  need the LPAREN action
         */
        if (!inComment)
        {
            lparen++;
            /*
             * If in REFERENCE and we have seen the dot, then move
             * to REFMOD2 -> Modifier()
             */
            if (curLexState == REFMODIFIER )
                SwitchTo( REFMOD2 );
        }
         break;
      case 19 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
     inComment = false;
     stateStackPop();
         break;
      case 20 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
    inComment = false;
    stateStackPop();
         break;
      case 21 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
    inComment = false;
    stateStackPop();
         break;
      case 24 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         *  - if we are in DIRECTIVE and haven't seen ( yet, then also drop out.
         *      don't forget to account for the beloved yet wierd #set
         *  - finally, if we are in REFMOD2 (remember : $foo.bar( ) then "" is ok!
         */
         if( curLexState == DIRECTIVE && !inSet && lparen == 0)
            stateStackPop();
         break;
      case 27 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if ( debugPrint )
            System.out.println("" NEWLINE :"");
        stateStackPop();
        if (inSet)
            inSet = false;
        if (inDirective)
            inDirective = false;
         break;
      case 43 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        inDirective = false;
        stateStackPop();
         break;
      case 44 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        SwitchTo(DIRECTIVE);
         break;
      case 45 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        SwitchTo(DIRECTIVE);
         break;
      case 46 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        inDirective = false;
        stateStackPop();
         break;
      case 47 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        matchedToken.kind = EOF;
        fileDepth = 0;
         break;
      case 49 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * check to see if we are in set
         *    ex.  #set $foo = $foo + 3
         *  because we want to handle the \n after
         */
        if ( lparen == 0 && !inSet && curLexState != REFMOD2)
        {
            stateStackPop();
        }
         break;
      case 57 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * push the alpha char back into the stream so the following identifier
         * is complete
         */
        input_stream.backup(1);
        /*
         * and munge the <DOT> so we just get a . when we have normal text that
         * looks like a ref.ident
         */
        matchedToken.image = ""."";
        if ( debugPrint )
            System.out.print(""DOT : switching to "" + REFMODIFIER);
        SwitchTo(REFMODIFIER);
         break;
      case 59 :
        if (image == null)
            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
         else
            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        stateStackPop();
         break;
      default : 
         break;
   }
}
}
"
org.apache.velocity.runtime.parser.ParserTreeConstants,"/* Generated By:JJTree: Do not edit this line. ParserTreeConstants.java */
package org.apache.velocity.runtime.parser;
public interface ParserTreeConstants
{
  public int JJTPROCESS = 0;
  public int JJTVOID = 1;
  public int JJTESCAPEDDIRECTIVE = 2;
  public int JJTESCAPE = 3;
  public int JJTCOMMENT = 4;
  public int JJTNUMBERLITERAL = 5;
  public int JJTSTRINGLITERAL = 6;
  public int JJTIDENTIFIER = 7;
  public int JJTWORD = 8;
  public int JJTDIRECTIVE = 9;
  public int JJTBLOCK = 10;
  public int JJTOBJECTARRAY = 11;
  public int JJTINTEGERRANGE = 12;
  public int JJTMETHOD = 13;
  public int JJTREFERENCE = 14;
  public int JJTTRUE = 15;
  public int JJTFALSE = 16;
  public int JJTTEXT = 17;
  public int JJTIFSTATEMENT = 18;
  public int JJTELSESTATEMENT = 19;
  public int JJTELSEIFSTATEMENT = 20;
  public int JJTSETDIRECTIVE = 21;
  public int JJTEXPRESSION = 22;
  public int JJTASSIGNMENT = 23;
  public int JJTORNODE = 24;
  public int JJTANDNODE = 25;
  public int JJTEQNODE = 26;
  public int JJTNENODE = 27;
  public int JJTLTNODE = 28;
  public int JJTGTNODE = 29;
  public int JJTLENODE = 30;
  public int JJTGENODE = 31;
  public int JJTADDNODE = 32;
  public int JJTSUBTRACTNODE = 33;
  public int JJTMULNODE = 34;
  public int JJTDIVNODE = 35;
  public int JJTMODNODE = 36;
  public int JJTNOTNODE = 37;
  public String[] jjtNodeName = {
    ""process"",
    ""void"",
    ""EscapedDirective"",
    ""Escape"",
    ""Comment"",
    ""NumberLiteral"",
    ""StringLiteral"",
    ""Identifier"",
    ""Word"",
    ""Directive"",
    ""Block"",
    ""ObjectArray"",
    ""IntegerRange"",
    ""Method"",
    ""Reference"",
    ""True"",
    ""False"",
    ""Text"",
    ""IfStatement"",
    ""ElseStatement"",
    ""ElseIfStatement"",
    ""SetDirective"",
    ""Expression"",
    ""Assignment"",
    ""OrNode"",
    ""AndNode"",
    ""EQNode"",
    ""NENode"",
    ""LTNode"",
    ""GTNode"",
    ""LENode"",
    ""GENode"",
    ""AddNode"",
    ""SubtractNode"",
    ""MulNode"",
    ""DivNode"",
    ""ModNode"",
    ""NotNode"",
  };
}
"
org.apache.velocity.runtime.parser.Token,"/* Generated By:JavaCC: Do not edit this line. Token.java Version 2.1 */
package org.apache.velocity.runtime.parser;
/**
 * Describes the input token stream.
 */
public class Token {
  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;
  /**
   * beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.
   */
  public int beginLine, beginColumn, endLine, endColumn;
  /**
   * The string image of the token.
   */
  public String image;
  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;
  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;
  /**
   * Returns the image.
   */
  public final String toString()
  {
     return image;
  }
  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simlpy add something like :
   *
   *    case MyParserConstants.ID : return new IDToken();
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use it in your lexical actions.
   */
  public static final Token newToken(int ofKind)
  {
     switch(ofKind)
     {
       default : return new Token();
     }
  }
}
"
org.apache.velocity.runtime.parser.TokenMgrError,"/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 2.1 */
package org.apache.velocity.runtime.parser;
public class TokenMgrError extends Error
{
   /*
    * Ordinals for various reasons why an Error of this type can be thrown.
    */
   /**
    * Lexical error occured.
    */
   static final int LEXICAL_ERROR = 0;
   /**
    * An attempt wass made to create a second instance of a static token manager.
    */
   static final int STATIC_LEXER_ERROR = 1;
   /**
    * Tried to change to an invalid lexical state.
    */
   static final int INVALID_LEXICAL_STATE = 2;
   /**
    * Detected (and bailed out of) an infinite loop in the token manager.
    */
   static final int LOOP_DETECTED = 3;
   /**
    * Indicates the reason why the exception is thrown. It will have
    * one of the above 4 values.
    */
   int errorCode;
   /**
    * Replaces unprintable characters by their espaced (or unicode escaped)
    * equivalents in the given string
    */
   protected static final String addEscapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
   /**
    * Returns a detailed message for the Error when it is thrown by the
    * token manager to indicate a lexical error.
    * Parameters : 
    *    EOFSeen     : indicates if EOF caused the lexicl error
    *    curLexState : lexical state in which this error occured
    *    errorLine   : line number when the error occured
    *    errorColumn : column number when the error occured
    *    errorAfter  : prefix that was seen before this error occured
    *    curchar     : the offending character
    * Note: You can customize the lexical error message by modifying this method.
    */
   private static final String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
      return(""Lexical error at line "" +
           errorLine + "", column "" +
           errorColumn + "".  Encountered: "" +
           (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") +
           ""after : \"""" + addEscapes(errorAfter) + ""\"""");
   }
   /**
    * You can also modify the body of this method to customize your error messages.
    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
    * of end-users concern, so you can return something like : 
    *
    *     ""Internal Error : Please file a bug report .... ""
    *
    * from this method for such cases in the release version of your parser.
    */
   public String getMessage() {
      return super.getMessage();
   }
   /*
    * Constructors of various flavors follow.
    */
   public TokenMgrError() {
   }
   public TokenMgrError(String message, int reason) {
      super(message);
      errorCode = reason;
   }
   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
}
"
org.apache.velocity.runtime.parser.VelocityCharStream,"package org.apache.velocity.runtime.parser;
/**
 *  NOTE : This class was originally an ASCII_CharStream autogenerated
 *  by Javacc.  It was then modified via changing class name with appropriate
 *  fixes for CTORS, and mods to readChar().
 *
 *  This is safe because we *always* use Reader with this class, and never a
 *  InputStream.  This guarantees that we have a correct stream of 16-bit 
 *  chars - all encoding transformations have been done elsewhere, so we 
 *  believe that there is no risk in doing this.  Time will tell :)
 */
/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
public final class VelocityCharStream
    implements CharStream
{
  public static final boolean staticFlag = false;
  int bufsize;
  int available;
  int tokenBegin;
  public int bufpos = -1;
  private int bufline[];
  private int bufcolumn[];
  private int column = 0;
  private int line = 1;
  private boolean prevCharIsCR = false;
  private boolean prevCharIsLF = false;
  private java.io.Reader inputStream;
  private char[] buffer;
  private int maxNextCharInd = 0;
  private int inBuf = 0;
  private final void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];
     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;
           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;
           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;
           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;
           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;
           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;
           maxNextCharInd = (bufpos -= tokenBegin);
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }
     bufsize += 2048;
     available = bufsize;
     tokenBegin = 0;
  }
  private final void FillBuff() throws java.io.IOException
  {
     if (maxNextCharInd == available)
     {
        if (available == bufsize)
        {
           if (tokenBegin > 2048)
           {
              bufpos = maxNextCharInd = 0;
              available = tokenBegin;
           }
           else if (tokenBegin < 0)
              bufpos = maxNextCharInd = 0;
           else
              ExpandBuff(false);
        }
        else if (available > tokenBegin)
           available = bufsize;
        else if ((tokenBegin - available) < 2048)
           ExpandBuff(true);
        else
           available = tokenBegin;
     }
     int i;
     try {
        if ((i = inputStream.read(buffer, maxNextCharInd,
                                    available - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        --bufpos;
        backup(0);
        if (tokenBegin == -1)
           tokenBegin = bufpos;
        throw e;
     }
  }
  public final char BeginToken() throws java.io.IOException
  {
     tokenBegin = -1;
     char c = readChar();
     tokenBegin = bufpos;
     return c;
  }
  private final void UpdateLineColumn(char c)
  {
     column++;
     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }
     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (8 - (column & 07));
           break;
        default :
           break;
     }
     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }
  public final char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;
        /*
         *  was : return (char)((char)0xff & buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos]);
         */
        return  buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
     }
     if (++bufpos >= maxNextCharInd)
        FillBuff();
     /*
      *  was : char c = (char)((char)0xff & buffer[bufpos]);
      */
     char c = buffer[bufpos];
     UpdateLineColumn(c);
     return (c);
  }
  /**
   * @deprecated 
   * @see #getEndColumn
   */
  public final int getColumn() {
     return bufcolumn[bufpos];
  }
  /**
   * @deprecated 
   * @see #getEndLine
   */
  public final int getLine() {
     return bufline[bufpos];
  }
  public final int getEndColumn() {
     return bufcolumn[bufpos];
  }
  public final int getEndLine() {
     return bufline[bufpos];
  }
  public final int getBeginColumn() {
     return bufcolumn[tokenBegin];
  }
  public final int getBeginLine() {
     return bufline[tokenBegin];
  }
  public final void backup(int amount) {
    inBuf += amount;
    if ((bufpos -= amount) < 0)
       bufpos += bufsize;
  }
  public VelocityCharStream(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;
    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
  }
  public VelocityCharStream(java.io.Reader dstream, int startline,
                                                           int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;
    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    bufpos = -1;
  }
  public void ReInit(java.io.Reader dstream, int startline,
                                                           int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public VelocityCharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }
  public VelocityCharStream(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public final String GetImage()
  {
     if (bufpos >= tokenBegin)
        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
     else
        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                              new String(buffer, 0, bufpos + 1);
  }
  public final char[] GetSuffix(int len)
  {
     char[] ret = new char[len];
     if ((bufpos + 1) >= len)
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
     else
     {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                          len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
     }
     return ret;
  }
  public void Done()
  {
     buffer = null;
     bufline = null;
     bufcolumn = null;
  }
  /**
   * Method to adjust line and column numbers for the start of a token.<BR>
   */
  public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;
     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }
     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;
     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 
     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;
        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }
     line = bufline[j];
     column = bufcolumn[j];
  }
}
"
org.apache.velocity.runtime.parser.node.AbstractExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.velocity.runtime.RuntimeLogger;
/**
 * Abstract class that is used to execute an arbitrary
 * method that is in introspected. This is the superclass
 * for the GetExecutor and PropertyExecutor.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: AbstractExecutor.java,v 1.12.4.1 2004/03/03 23:22:59 geirm Exp $
 */
public abstract class AbstractExecutor
{
    protected RuntimeLogger rlog = null;
    /**
     * Method to be executed.
     */
    protected Method method = null;
    /**
     * Execute method against context.
     */
     public abstract Object execute(Object o)
         throws IllegalAccessException, InvocationTargetException;
    /**
     * Tell whether the executor is alive by looking
     * at the value of the method.
     */
    public boolean isAlive()
    {
        return (method != null);
    }
    public Method getMethod()
    {
        return method;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTAddNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Handles integer addition of nodes
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTAddNode.java,v 1.8.8.1 2004/03/03 23:22:58 geirm Exp $ 
*/
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTAddNode extends SimpleNode
{
    public ASTAddNode(int id)
    {
        super(id);
    }
    public ASTAddNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  computes the sum of the two nodes.  Currently only integer operations are 
     *  supported.
     *  @return Integer object with value, or null
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two addends
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) 
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of addition operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of addition operation is not a valid type. ""
                           + ""Currently only integers (1,2,3...) and Integer type is supported. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        return new Integer( ( (Integer) left ).intValue() + (  (Integer) right ).intValue() );
    }
}
"
org.apache.velocity.runtime.parser.node.ASTAndNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
/**
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTAndNode.java,v 1.8.8.1 2004/03/03 23:22:58 geirm Exp $ 
 */
public class ASTAndNode extends SimpleNode
{
    public ASTAndNode(int id)
    {
        super(id);
    }
    public ASTAndNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  Returns the value of the expression.
     *  Since the value of the expression is simply the boolean
     *  result of evaluate(), lets return that.
     */
    public Object value(InternalContextAdapter context )
        throws MethodInvocationException
    {
        return new Boolean( evaluate( context ) );
    }
    /**
     * logical and : 
     *   null && right = false
     *   left && null = false
     *   null && null = false
     */     
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {       
        Node left = jjtGetChild(0);
        Node right = jjtGetChild(1);
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) + "" side of '&&' operation is null.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        /*
         *  short circuit the test.  Don't eval the RHS if the LHS is false
         */
        if( left.evaluate( context ) )
        {
            if ( right.evaluate( context ) )
            {
                return true;
            }
        }        
        return false;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTAssignment,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Parser;
public class ASTAssignment extends SimpleNode
{
    public ASTAssignment(int id)
    {
        super(id);
    }
    public ASTAssignment(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTBlock,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
public class ASTBlock extends SimpleNode
{
    public ASTBlock(int id)
    {
        super(id);
    }
    public ASTBlock(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException,
        	ResourceNotFoundException, ParseErrorException
    {
        int i, k = jjtGetNumChildren();
        for (i = 0; i < k; i++)
            jjtGetChild(i).render(context, writer);
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTComment,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.MethodInvocationException;
import java.io.IOException;
import java.io.Writer;
/**
 *  Represents all comments...
 *
 *  @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 *  @version $Id: ASTComment.java,v 1.5.4.1 2004/03/03 23:22:58 geirm Exp $
 */
public class ASTComment extends SimpleNode
{
    private static final char[] ZILCH = """".toCharArray();
    private char[] carr;
    public ASTComment(int id)
    {
        super(id);
    }
    public ASTComment(Parser p, int id) 
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data) 
    {
        return visitor.visit(this, data);
    }
    /**
     *  We need to make sure we catch any of the dreaded MORE tokens.
     */
    public Object init(InternalContextAdapter context, Object data)
            throws Exception
    {
        Token t = getFirstToken();
        int loc1 = t.image.indexOf(""##"");
        int loc2 = t.image.indexOf(""#*"");
        if (loc1 == -1 && loc2 == -1)
        {
            carr = ZILCH;
        }
        else
        {
            carr = t.image.substring(0, (loc1 == -1) ? loc2 : loc1).toCharArray();
        }
        return data;
    }
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException, ParseErrorException, ResourceNotFoundException
    {
        writer.write(carr);
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTDirective,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 * This class is responsible for handling the pluggable
 * directives in VTL. ex.  #foreach()
 * 
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:kav@kav.dk"">Kasper Nielsen</a>
 * @version $Id: ASTDirective.java,v 1.21.4.1 2004/03/03 23:22:58 geirm Exp $ 
 */
public class ASTDirective extends SimpleNode
{
    private Directive directive;
    private String directiveName = """";
    private boolean isDirective;
    public ASTDirective(int id)
    {
        super(id);
    }
    public ASTDirective(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public Object init( InternalContextAdapter context, Object data) 
        throws Exception
    {
        super.init( context, data );
        /*
         *  only do things that are not context dependant
         */
        if (parser.isDirective( directiveName ))
        {
            isDirective = true;
            directive = (Directive) parser.getDirective( directiveName )
                .getClass().newInstance();
            directive.init(rsvc, context,this);
            directive.setLocation( getLine(), getColumn() );
        }          
        else if (rsvc.isVelocimacro( directiveName, context.getCurrentTemplateName()  )) 
        {
            /*
             *  we seem to be a Velocimacro.
             */
            isDirective = true;
            directive = (Directive) rsvc.getVelocimacro( directiveName,  context.getCurrentTemplateName() );
            directive.init( rsvc, context, this );
            directive.setLocation( getLine(), getColumn() );
        } 
        else
        {
            isDirective = false;
        }            
        return data;
    }
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException, ResourceNotFoundException, ParseErrorException
    {
        /*
         *  normal processing
         */
        if (isDirective)
        {           
            directive.render(context, writer, this);
        }
        else
        {
            writer.write( ""#"");
            writer.write( directiveName );
        }
        return true;
    }
    /**
     *   Sets the directive name.  Used by the parser.  This keeps us from having to 
     *   dig it out of the token stream and gives the parse the change to override.
     */
    public void setDirectiveName( String str )
    {
        directiveName = str;
        return;
    }
    /**
     *  Gets the name of this directive.
     */
    public String getDirectiveName()
    {
        return directiveName;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTDivNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
/**
 * Handles integer division of nodes
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTDivNode.java,v 1.8.8.1 2004/03/03 23:22:58 geirm Exp $ 
 */
public class ASTDivNode extends SimpleNode
{
    public ASTDivNode(int id)
    {
        super(id);
    }
    public ASTDivNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  computes the result of the division. Currently limited to
     *  Integers.
     *  @return Integer(value) or null 
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) 
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of division operation has null value.""
                           + "" Operation not possible. ""
                           +  context.getCurrentTemplateName() 
                           + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of division operation is not a valid type. ""
                           + ""Currently only integers (1,2,3...) and Integer type is supported. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  check for divide by 0
         */
        if ( ( (Integer) right).intValue() == 0 )
        {
            rsvc.error( ""Right side of division operation is zero. Must be non-zero. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        return new Integer( ( (Integer) left ).intValue() / (  (Integer) right ).intValue() );
    }
}
"
org.apache.velocity.runtime.parser.node.ASTElseIfStatement,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.*;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 * This class is responsible for handling the ElseIf VTL control statement.
 * 
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTElseIfStatement.java,v 1.9.8.1 2004/03/03 23:22:58 geirm Exp $ 
*/
public class ASTElseIfStatement extends SimpleNode
{
    public ASTElseIfStatement(int id)
    {
        super(id);
    }
    public ASTElseIfStatement(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * An ASTElseStatement is true if the expression
     * it contains evaluates to true. Expressions know
     * how to evaluate themselves, so we do that
     * here and return the value back to ASTIfStatement
     * where this node was originally asked to evaluate
     * itself.
     */
    public boolean evaluate ( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return jjtGetChild(0).evaluate(context);
    }
    /**
     *  renders the block
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException, 
        	ResourceNotFoundException, ParseErrorException
    {
        return jjtGetChild(1).render( context, writer );
    }
}
"
org.apache.velocity.runtime.parser.node.ASTElseStatement,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling the Else VTL control statement.
 * 
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTElseStatement.java,v 1.8.4.1 2004/03/03 23:22:58 geirm Exp $ 
 */
public class ASTElseStatement extends SimpleNode
{
    public ASTElseStatement(int id)
    {
        super(id);
    }
    public ASTElseStatement(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * An ASTElseStatement always evaluates to
     * true. Basically behaves like an #if(true).
     */
    public boolean evaluate( InternalContextAdapter context)
    {
        return true;
    }        
}
"
org.apache.velocity.runtime.parser.node.ASTEQNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
/**
 *  Handles the equivalence operator
 *
 *    <arg1>  == <arg2>
 *
 *  This operator requires that the LHS and RHS are both of the
 *  same Class.
 *
 *  @version $Id: ASTEQNode.java,v 1.9.4.1 2004/03/03 23:22:58 geirm Exp $
 */
public class ASTEQNode extends SimpleNode
{
    public ASTEQNode(int id)
    {
        super(id);
    }
    public ASTEQNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *   Calculates the value of the logical expression
     *
     *     arg1 == arg2
     *
     *   All class types are supported.   Uses equals() to 
     *   determine equivalence.  This should work as we represent
     *   with the types we already support, and anything else that
     *   implements equals() to mean more than identical references.
     *
     *
     *  @param context  internal context used to evaluate the LHS and RHS
     *  @return true if equivalent, false if not equivalent,
     *          false if not compatible arguments, or false
     *          if either LHS or RHS is null
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        Object left = jjtGetChild(0).value(context);
        Object right = jjtGetChild(1).value(context);
        /*
         *  they could be null if they are references and not in the context
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) 
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal() 
                           + "") of '==' operation ""
                           + ""has null value. "" 
                           + ""If a reference, it may not be in the context.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        /*
         *  check to see if they are the same class.  I don't think this is slower
         *  as I don't think that getClass() results in object creation, and we can
         *  extend == to handle all classes
         */
        if (left.getClass().equals( right.getClass() ) )
        {
            return left.equals( right );
        }
        else
        {
            rsvc.error(""Error in evaluation of == expression.""
                          + "" Both arguments must be of the same Class.""
                          + "" Currently left = "" + left.getClass() + "", right = "" 
                          + right.getClass() + "". ""
                          + context.getCurrentTemplateName() + "" [line "" + getLine() 
                          + "", column "" + getColumn() + ""] (ASTEQNode)"");
        }
        return false;    
    }
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTEscape,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling Escapes
 *  in VTL.
 * 
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTEscape.java,v 1.6.4.1 2004/03/03 23:22:58 geirm Exp $ 
 */
public class ASTEscape extends SimpleNode 
{
    public String val;
    private char[] ctext;
    public ASTEscape(int id)
    {
        super(id);
    }
    public ASTEscape(Parser p, int id) 
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data) 
    {
        return visitor.visit(this, data);
    }
    public Object init( InternalContextAdapter context, Object data) 
        throws Exception
    {
        ctext =  val.toCharArray();
        return data;
    }
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException
    {
        writer.write(ctext);
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTEscapedDirective,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling EscapedDirectives
 *  in VTL.
 * 
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTEscapedDirective.java,v 1.3.14.1 2004/03/03 23:22:58 geirm Exp $ 
 */
public class ASTEscapedDirective extends SimpleNode 
{  
    public ASTEscapedDirective(int id) 
    {
        super(id);
    }
    public ASTEscapedDirective(Parser p, int id) 
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data) 
    {
        return visitor.visit(this, data);
    }
    public boolean render(InternalContextAdapter context, Writer writer)
        throws IOException
    {
        writer.write(getFirstToken().image);
        return true;
    }    
}
"
org.apache.velocity.runtime.parser.node.ASTExpression,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTExpression extends SimpleNode
{
    public ASTExpression(int id)
    {
        super(id);
    }
    public ASTExpression(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return jjtGetChild(0).evaluate(context);
    }
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return jjtGetChild(0).value(context);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTFalse,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
public class ASTFalse extends SimpleNode
{
    private static Boolean value = Boolean.FALSE;
    public ASTFalse(int id)
    {
        super(id);
    }
    public ASTFalse(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate( InternalContextAdapter context)
    {
        return false;
    }
    public Object value( InternalContextAdapter context)
    {
        return value;
    }        
}
"
org.apache.velocity.runtime.parser.node.ASTGENode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTGENode extends SimpleNode
{
    public ASTGENode(int id)
    {
        super(id);
    }
    public ASTGENode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) 
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal() 
                           + "") of '>=' operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" 
                           + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of '>=' operation is not a valid type. ""
                           + "" It is a "" + ( !( left instanceof Integer ) ? left.getClass() : right.getClass() ) 
                           + "". Currently only integers (1,2,3...) and Integer type is supported. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        return ( (Integer) left).intValue() >=  ((Integer) right).intValue(); 
    }
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTGTNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTGTNode extends SimpleNode
{
    public ASTGTNode(int id)
    {
        super(id);
    }
    public ASTGTNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate(InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) 
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '>' operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" 
                           + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of '>' operation is not a valid type. ""
                           + "" It is a "" + ( !( left instanceof Integer ) ? left.getClass() : right.getClass() ) 
                           + "". Currently only integers (1,2,3...) and Integer type is supported. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        return ((Integer) left).intValue() > ((Integer) right).intValue();
    }
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIdentifier,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.util.introspection.VelPropertyGet;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.app.event.EventCartridge;
import java.lang.reflect.InvocationTargetException;
/**
 *  ASTIdentifier.java
 *
 *  Method support for identifiers :  $foo
 *
 *  mainly used by ASTRefrence
 *
 *  Introspection is now moved to 'just in time' or at render / execution
 *  time. There are many reasons why this has to be done, but the
 *  primary two are   thread safety, to remove any context-derived
 *  information from class member  variables.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTIdentifier.java,v 1.19.4.1 2004/03/03 23:22:58 geirm Exp $
 */
public class ASTIdentifier extends SimpleNode
{
    private String identifier = """";
    /**
     *  This is really immutable after the init, so keep one for this node
     */
    protected Info uberInfo;
    public ASTIdentifier(int id)
    {
        super(id);
    }
    public ASTIdentifier(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  simple init - don't do anything that is context specific.
     *  just get what we need from the AST, which is static.
     */
    public  Object init(InternalContextAdapter context, Object data)
        throws Exception
    {
        super.init(context, data);
        identifier = getFirstToken().image;
        uberInfo = new Info(context.getCurrentTemplateName(),
                getLine(), getColumn());
        return data;
    }
    /**
     *  invokes the method on the object passed in
     */
    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {
        VelPropertyGet vg = null;
        try
        {
            Class c = o.getClass();
            /*
             *  first, see if we have this information cached.
             */
            IntrospectionCacheData icd = context.icacheGet(this);
            /*
             * if we have the cache data and the class of the object we are
             * invoked with is the same as that in the cache, then we must
             * be allright.  The last 'variable' is the method name, and
             * that is fixed in the template :)
             */
            if (icd != null && icd.contextData == c)
            {
                vg = (VelPropertyGet) icd.thingy;
            }
            else
            {
                /*
                 *  otherwise, do the introspection, and cache it.  Use the
                 *  uberspector
                 */
                vg = rsvc.getUberspect().getPropertyGet(o,identifier, uberInfo);
                if (vg != null && vg.isCacheable())
                {
                    icd = new IntrospectionCacheData();
                    icd.contextData = c;
                    icd.thingy = vg;
                    context.icachePut(this,icd);
                }
            }
        }
        catch(Exception e)
        {
            rsvc.error(""ASTIdentifier.execute() : identifier = ""
                               + identifier + "" : "" + e);
        }
        /*
         *  we have no getter... punt...
         */
        if (vg == null)
        {
            return null;
        }
        /*
         *  now try and execute.  If we get a MIE, throw that
         *  as the app wants to get these.  If not, log and punt.
         */
        try
        {
            return vg.invoke(o);
        }
        catch(InvocationTargetException ite)
        {
            EventCartridge ec = context.getEventCartridge();
            /*
             *  if we have an event cartridge, see if it wants to veto
             *  also, let non-Exception Throwables go...
             */
            if (ec != null
                    && ite.getTargetException() instanceof java.lang.Exception)
            {
                try
                {
                    return ec.methodException(o.getClass(), vg.getMethodName(),
                            (Exception)ite.getTargetException());
                }
                catch(Exception e)
                {
                    throw new MethodInvocationException(
                      ""Invocation of method '"" + vg.getMethodName() + ""'""
                      + "" in  "" + o.getClass()
                      + "" threw exception ""
                      + ite.getTargetException().getClass() + "" : ""
                      + ite.getTargetException().getMessage(),
                      ite.getTargetException(), vg.getMethodName());
                }
            }
            else
            {
                /*
                 * no event cartridge to override. Just throw
                 */
                throw  new MethodInvocationException(
                ""Invocation of method '"" + vg.getMethodName() + ""'""
                + "" in  "" + o.getClass()
                + "" threw exception ""
                + ite.getTargetException().getClass() + "" : ""
                + ite.getTargetException().getMessage(),
                ite.getTargetException(), vg.getMethodName());
            }
        }
        catch(IllegalArgumentException iae)
        {
            return null;
        }
        catch(Exception e)
        {
            rsvc.error(""ASTIdentifier() : exception invoking method ""
                        + ""for identifier '"" + identifier + ""' in ""
                        + o.getClass() + "" : "" + e);
        }
        return null;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIfStatement,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTIfStatement.java,v 1.9.8.1 2004/03/03 23:22:58 geirm Exp $ 
*/
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.*;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
public class ASTIfStatement extends SimpleNode
{    
    public ASTIfStatement(int id)
    {
        super(id);
    }
    public ASTIfStatement(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException,
        	ResourceNotFoundException, ParseErrorException
    {
        /*
         * Check if the #if(expression) construct evaluates to true:
         * if so render and leave immediately because there
         * is nothing left to do!
         */
        if (jjtGetChild(0).evaluate(context))
        {
            jjtGetChild(1).render(context, writer);
            return true;
        }
        int totalNodes = jjtGetNumChildren();
        /*
         * Now check the remaining nodes left in the
         * if construct. The nodes are either elseif
         *  nodes or else nodes. Each of these node
         * types knows how to evaluate themselves. If
         * a node evaluates to true then the node will
         * render itself and this method will return
         * as there is nothing left to do.
         */
        for (int i = 2; i < totalNodes; i++)
        {
            if (jjtGetChild(i).evaluate(context))
            {
                jjtGetChild(i).render(context, writer);
                return true;
            }
        }
        /*
         * This is reached when an ASTIfStatement
         * consists of an if/elseif sequence where
         * none of the nodes evaluate to true.
         */
        return true;
    }
    public void process( InternalContextAdapter context, ParserVisitor visitor)
    {
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIncludeStatement,"/* Generated By:JJTree: Do not edit this line. ASTIncludeStatement.java */
package org.apache.velocity.runtime.parser.node;
import org.apache.velocity.runtime.parser.*;
public class ASTIncludeStatement extends SimpleNode
{
    public ASTIncludeStatement(int id)
    {
        super(id);
    }
    public ASTIncludeStatement(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIntegerRange,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * handles the range 'operator'  [ n .. m ]
 * 
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTIntegerRange.java,v 1.4.10.1 2004/03/03 23:22:58 geirm Exp $ 
*/
import java.util.ArrayList;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTIntegerRange extends SimpleNode {
    public ASTIntegerRange(int id) 
    {
        super(id);
    }
    public ASTIntegerRange(Parser p, int id) 
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data) 
    {
        return visitor.visit(this, data);
    }
    /**
     *  does the real work.  Creates an Vector of Integers with the
     *  right value range
     *
     *  @param context  app context used if Left or Right of .. is a ref
     *  @return Object array of Integers
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    { 
        /*
         *  get the two range ends
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) + "" side of range operator [n..m] has null value.""
                           + "" Operation not possible. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of range operator is not a valid type. ""
                           + ""Currently only integers (1,2,3...) and Integer type is supported. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  get the two integer values of the ends of the range
         */
        int l = ( (Integer) left ).intValue() ;
        int r = (  (Integer) right ).intValue();
        /*
         *  find out how many there are
         */
        int num = Math.abs( l - r );
        num += 1;
        /*
         *  see if your increment is Pos or Neg
         */
        int delta = ( l >= r ) ? -1 : 1;
        /*
         *  make the vector and fill it
         */
        ArrayList foo = new ArrayList();
        int val = l;
        for(int i =0; i < num; i++)
        {
            foo.add( new Integer( val ));
            val += delta;
        }
        return foo;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTLENode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTLENode extends SimpleNode
{
    public ASTLENode(int id)
    {
        super(id);
    }
    public ASTLENode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate( InternalContextAdapter context)
      throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) 
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '<=' operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" 
                           + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of '<=' operation is not a valid type. ""
                           + "" It is a "" + ( !( left instanceof Integer ) ? left.getClass() : right.getClass() ) 
                           + "". Currently only integers (1,2,3...) and Integer type is supported. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        return ((Integer) left).intValue() <=  ((Integer) right).intValue();
    }
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTLTNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTLTNode extends SimpleNode
{
    public ASTLTNode(int id)
    {
        super(id);
    }
    public ASTLTNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate(InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) 
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '<' operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" 
                           + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of '<' operation is not a valid type. ""
                           + "" It is a "" + ( !( left instanceof Integer ) ? left.getClass() : right.getClass() ) 
                           + "". Currently only integers (1,2,3...) and Integer type is supported. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        return ((Integer) left).intValue() < ((Integer) right).intValue();
    }
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTMethod,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.*;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.util.introspection.VelMethod;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.exception.MethodInvocationException;
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.app.event.EventCartridge;
/**
 *  ASTMethod.java
 *
 *  Method support for references :  $foo.method()
 *
 *  NOTE :
 *
 *  introspection is now done at render time.
 *
 *  Please look at the Parser.jjt file which is
 *  what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTMethod.java,v 1.24.4.1 2004/03/03 23:22:59 geirm Exp $ 
 */
public class ASTMethod extends SimpleNode
{
    private String methodName = """";
    private int paramCount = 0;
    public ASTMethod(int id)
    {
        super(id);
    }
    public ASTMethod(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  simple init - init our subtree and get what we can from 
     *  the AST
     */
    public Object init(  InternalContextAdapter context, Object data)
        throws Exception
    {
        super.init(  context, data );
        /*
         *  this is about all we can do
         */
        methodName = getFirstToken().image;
        paramCount = jjtGetNumChildren() - 1;
        return data;
    }
    /**
     *  invokes the method.  Returns null if a problem, the
     *  actual return if the method returns something, or 
     *  an empty string """" if the method returns void
     */
    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  new strategy (strategery!) for introspection. Since we want 
         *  to be thread- as well as context-safe, we *must* do it now,
         *  at execution time.  There can be no in-node caching,
         *  but if we are careful, we can do it in the context.
         */
        VelMethod method = null;
        Object [] params = new Object[paramCount];
        try
        {
            /*
             *   check the cache 
             */
            IntrospectionCacheData icd =  context.icacheGet( this );
            Class c = o.getClass();
            /*
             *  like ASTIdentifier, if we have cache information, and the
             *  Class of Object o is the same as that in the cache, we are
             *  safe.
             */
            if ( icd != null && icd.contextData == c )
            {
                /*
                 * sadly, we do need recalc the values of the args, as this can 
                 * change from visit to visit
                 */
                for (int j = 0; j < paramCount; j++)
                    params[j] = jjtGetChild(j + 1).value(context);
                /*
                 * and get the method from the cache
                 */
                method = (VelMethod) icd.thingy;
            }
            else
            {
                /*
                 *  otherwise, do the introspection, and then
                 *  cache it
                 */
                for (int j = 0; j < paramCount; j++)
                    params[j] = jjtGetChild(j + 1).value(context);
                method = rsvc.getUberspect().getMethod(o, methodName, params, new Info("""",1,1));
                if (method != null)
                {    
                    icd = new IntrospectionCacheData();
                    icd.contextData = c;
                    icd.thingy = method;
                    context.icachePut( this, icd );
                }
            }
            /*
             *  if we still haven't gotten the method, either we are calling 
             *  a method that doesn't exist (which is fine...)  or I screwed
             *  it up.
             */
            if (method == null)
                return null;
        }
        catch( MethodInvocationException mie )
        {
            /*
             *  this can come from the doIntrospection(), as the arg values
             *  are evaluated to find the right method signature.  We just
             *  want to propogate it here, not do anything fancy
             */
            throw mie;
        }
        catch( Exception e )
        {
            /*
             *  can come from the doIntropection() also, from Introspector
             */
            rsvc.error(""ASTMethod.execute() : exception from introspection : "" + e);
            return null;
        }
        try
        {
            /*
             *  get the returned object.  It may be null, and that is
             *  valid for something declared with a void return type.
             *  Since the caller is expecting something to be returned,
             *  as long as things are peachy, we can return an empty 
             *  String so ASTReference() correctly figures out that
             *  all is well.
             */
            Object obj = method.invoke(o, params);
            if (obj == null)
            {
                if( method.getReturnType() == Void.TYPE)
                     return new String("""");
            }
            return obj;
        }
        catch( InvocationTargetException ite )
        {
            /*
             *  In the event that the invocation of the method
             *  itself throws an exception, we want to catch that
             *  wrap it, and throw.  We don't log here as we want to figure
             *  out which reference threw the exception, so do that 
             *  above
             */
            EventCartridge ec = context.getEventCartridge();
            /*
             *  if we have an event cartridge, see if it wants to veto
             *  also, let non-Exception Throwables go...
             */
            if ( ec != null && ite.getTargetException() instanceof java.lang.Exception)
            {
                try
                {
                    return ec.methodException( o.getClass(), methodName, (Exception)ite.getTargetException() );
                }
                catch( Exception e )
                {
                    throw new MethodInvocationException( 
                        ""Invocation of method '"" 
                        + methodName + ""' in  "" + o.getClass() 
                        + "" threw exception "" 
                        + e.getClass() + "" : "" + e.getMessage(), 
                        e, methodName );
                }
            }
            else
            {
                /*
                 * no event cartridge to override. Just throw
                 */
                throw new MethodInvocationException( 
                ""Invocation of method '"" 
                + methodName + ""' in  "" + o.getClass() 
                + "" threw exception "" 
                + ite.getTargetException().getClass() + "" : ""
                + ite.getTargetException().getMessage(), 
                ite.getTargetException(), methodName );
            }
        }
        catch( Exception e )
        {
            rsvc.error(""ASTMethod.execute() : exception invoking method '"" 
                               + methodName + ""' in "" + o.getClass() + "" : ""  + e );
            return null;
        }            
    }
}
"
org.apache.velocity.runtime.parser.node.ASTModNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Handles integer modulus division
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTModNode.java,v 1.6.10.1 2004/03/03 23:22:59 geirm Exp $ 
*/
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTModNode extends SimpleNode
{
    public ASTModNode(int id)
    {
        super(id);
    }
    public ASTModNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of modulus operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of modulus operation is not a valid type. ""
                           + ""Currently only integers (1,2,3...) and Integer type is supported. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  check for divide by 0
         */
        if ( ( (Integer) right).intValue() == 0 )
        {
            rsvc.error( ""Right side of modulus operation is zero. Must be non-zero. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        return new Integer( ( (Integer) left ).intValue() % (  (Integer) right ).intValue() );
    }
}
"
org.apache.velocity.runtime.parser.node.ASTMulNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
/**
 * Handles integer multiplication
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTMulNode.java,v 1.7.8.1 2004/03/03 23:22:59 geirm Exp $ 
*/
public class ASTMulNode extends SimpleNode
{
    public ASTMulNode(int id)
    {
        super(id);
    }
    public ASTMulNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  computes the product of the two args.  Returns null if either arg is null
     *  or if either arg is not an integer
     */
    public Object value( InternalContextAdapter context )
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of multiplication operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of multiplication operation is not a valid type. ""
                           + ""Currently only integers (1,2,3...) and Integer type is supported. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        return new Integer( ( (Integer) left ).intValue() * (  (Integer) right ).intValue() );
    }
}
"
org.apache.velocity.runtime.parser.node.ASTNENode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTNENode extends SimpleNode
{
    public ASTNENode(int id)
    {
        super(id);
    }
    public ASTNENode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate(  InternalContextAdapter context)
        throws MethodInvocationException
    {
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  null check
         */
        if ( left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '!=' operation has null value.""
                           + "" Operation not possible. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return false;
        }
        /*
         *  check to see if they are the same class.  I don't think this is slower
         *  as I don't think that getClass() results in object creation, and we can
         *  extend == to handle all classes
         */
        if (left.getClass().equals( right.getClass() ) )
        {
            return !(left.equals( right ));
        }
        else
        {
            rsvc.error(""Error in evaluation of != expression.""
                          + "" Both arguments must be of the same Class.""
                          + "" Currently left = "" + left.getClass() + "", right = "" 
                          + right.getClass() + "". ""
                          + context.getCurrentTemplateName() + "" [line "" + getLine() 
                          + "", column "" + getColumn() + ""] (ASTEQNode)"");
            return false;
        }
    }
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTNotNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.*;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTNotNode extends SimpleNode
{
    public ASTNotNode(int id)
    {
        super(id);
    }
    public ASTNotNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        if (jjtGetChild(0).evaluate(context))
            return false;
        else
            return true;
    }
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return (jjtGetChild(0).evaluate( context ) ? Boolean.FALSE : Boolean.TRUE) ;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTNumberLiteral,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
public class ASTNumberLiteral extends SimpleNode
{
    private Integer value = null;
    public ASTNumberLiteral(int id)
    {
        super(id);
    }
    public ASTNumberLiteral(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  Initialization method - doesn't do much but do the object
     *  creation.  We only need to do it once.
     */
    public Object init( InternalContextAdapter context, Object data) 
        throws Exception
    {
        /*
         *  init the tree correctly
         */
        super.init( context, data );
        value = new Integer( getFirstToken().image );
        return data;
    } 
    public Object value( InternalContextAdapter context)
    {
        return value;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTObjectArray,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.ArrayList;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
public class ASTObjectArray extends SimpleNode
{
    public ASTObjectArray(int id)
    {
        super(id);
    }
    public ASTObjectArray(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        int size = jjtGetNumChildren();
        ArrayList objectArray = new ArrayList();
        for (int i = 0; i < size; i++)
        {
            objectArray.add(  jjtGetChild(i).value(context) );
        }            
        return objectArray;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTOrNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
/**
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTOrNode.java,v 1.6.8.1 2004/03/03 23:22:59 geirm Exp $ 
*/
public class ASTOrNode extends SimpleNode
{
    public ASTOrNode(int id)
    {
        super(id);
    }
    public ASTOrNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  Returns the value of the expression.
     *  Since the value of the expression is simply the boolean
     *  result of evaluate(), lets return that.
     */
    public Object value(InternalContextAdapter context )
        throws MethodInvocationException
    {
        return new Boolean( evaluate( context ) );
    }
    /**
     *  the logical or :
     *    the rule :
     *      left || null -> left
     *      null || right -> right
     *      null || null -> false
     *      left || right ->  left || right
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        Node left = jjtGetChild(0);
        Node right = jjtGetChild(1);
        /*
         *  if the left is not null and true, then true
         */
        if (left != null && left.evaluate( context ) )
            return true;
        /*
         *  same for right
         */
        if ( right != null && right.evaluate( context ) )
            return true;
        return false;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTParameters,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Parser;
public class ASTParameters extends SimpleNode
{
    public ASTParameters(int id)
    {
        super(id);
    }
    public ASTParameters(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTprocess,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Parser;
public class ASTprocess extends SimpleNode
{
    public ASTprocess(int id)
    {
        super(id);
    }
    public ASTprocess(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTReference,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.exception.ReferenceException;
import org.apache.velocity.runtime.parser.*;
import org.apache.velocity.util.introspection.VelPropertySet;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.app.event.EventCartridge;
/**
 * This class is responsible for handling the references in
 * VTL ($foo).
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @author <a href=""mailto:kjohnson@transparent.com>Kent Johnson</a>
 * @version $Id: ASTReference.java,v 1.49.4.1 2004/03/03 23:22:59 geirm Exp $
*/
public class ASTReference extends SimpleNode
{
    /* Reference types */
    private static final int NORMAL_REFERENCE = 1;
    private static final int FORMAL_REFERENCE = 2;
    private static final int QUIET_REFERENCE = 3;
    private static final int RUNT = 4;
    private int referenceType;
    private String nullString;
    private String rootString;
    private boolean escaped = false;
    private boolean computableReference = true;
    private String escPrefix = """";
    private String morePrefix = """";
    private String identifier = """";
    private String literal = null;
    private int numChildren = 0;
    protected Info uberInfo;
    public ASTReference(int id)
    {
        super(id);
    }
    public ASTReference(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public Object init(InternalContextAdapter context, Object data)
        throws Exception
    {
        /*
         *  init our children
         */
        super.init(context, data);
        /*
         *  the only thing we can do in init() is getRoot()
         *  as that is template based, not context based,
         *  so it's thread- and context-safe
         */
        rootString = getRoot();
        numChildren = jjtGetNumChildren();
        /*
         * and if appropriate...
         */
        if (numChildren > 0 )
        {
            identifier = jjtGetChild(numChildren - 1).getFirstToken().image;
        }
        /*
         * make an uberinfo - saves new's later on
         */
        uberInfo = new Info(context.getCurrentTemplateName(),
                getLine(),getColumn());
        return data;
    }
    /**
     *  Returns the 'root string', the reference key
     */
     public String getRootString()
     {
        return rootString;
     }
    /**
     *   gets an Object that 'is' the value of the reference
     *
     *   @param o   unused Object parameter
     *   @param context context used to generate value
     */
    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {
        if (referenceType == RUNT)
            return null;
        /*
         *  get the root object from the context
         */
        Object result = getVariableValue(context, rootString);
        if (result == null)
        {
            return null;
        }
        /*
         * Iteratively work 'down' (it's flat...) the reference
         * to get the value, but check to make sure that
         * every result along the path is valid. For example:
         *
         * $hashtable.Customer.Name
         *
         * The $hashtable may be valid, but there is no key
         * 'Customer' in the hashtable so we want to stop
         * when we find a null value and return the null
         * so the error gets logged.
         */
        try
        {
            for (int i = 0; i < numChildren; i++)
            {
                result = jjtGetChild(i).execute(result,context);
                if (result == null)
                {
                    return null;
                }
            }
            return result;
        }
        catch(MethodInvocationException mie)
        {
            /*
             *  someone tossed their cookies
             */
            rsvc.error(""Method "" + mie.getMethodName()
                        + "" threw exception for reference $""
                        + rootString
                        + "" in template "" + context.getCurrentTemplateName()
                        + "" at "" +  "" ["" + this.getLine() + "",""
                        + this.getColumn() + ""]"");
            mie.setReferenceName(rootString);
            throw mie;
        }
    }
    /**
     *  gets the value of the reference and outputs it to the
     *  writer.
     *
     *  @param context  context of data to use in getting value
     *  @param writer   writer to render to
     */
    public boolean render(InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException
    {
        if (referenceType == RUNT)
        {
            writer.write(rootString);
            return true;
        }
        Object value = execute(null, context);
        /*
         *  if this reference is escaped (\$foo) then we want to do one of two things :
         *  1) if this is a reference in the context, then we want to print $foo
         *  2) if not, then \$foo  (its considered shmoo, not VTL)
         */
        if (escaped)
        {
            if (value == null)
            {
                writer.write(escPrefix);
                writer.write(""\\"");
                writer.write(nullString);
            }
            else
            {
                writer.write(escPrefix);
                writer.write(nullString);
            }
            return true;
        }
        /*
         *  the normal processing
         *
         *  if we have an event cartridge, get a new value object
         */
        EventCartridge ec = context.getEventCartridge();
        if (ec != null)
        {
            value =  ec.referenceInsert(literal(), value);
        }
        /*
         *  if value is null...
         */
        if (value == null)
        {
            /*
             *  write prefix twice, because it's shmoo, so the \ don't escape each other...
             */
            writer.write(escPrefix);
            writer.write(escPrefix);
            writer.write(morePrefix);
            writer.write(nullString);
            if (referenceType != QUIET_REFERENCE
                && rsvc.getBoolean(RuntimeConstants.RUNTIME_LOG_REFERENCE_LOG_INVALID,
                        true))
            {
               rsvc.warn(new ReferenceException(""reference : template = ""
                                + context.getCurrentTemplateName(), this));
            }
            return true;
        }
        else
        {
            /*
             *  non-null processing
             */
            writer.write(escPrefix);
            writer.write(morePrefix);
            writer.write(value.toString());
            return true;
        }
    }
    /**
     *   Computes boolean value of this reference
     *   Returns the actual value of reference return type
     *   boolean, and 'true' if value is not null
     *
     *   @param context context to compute value with
     */
    public boolean evaluate(InternalContextAdapter context)
        throws MethodInvocationException
    {
        Object value = execute(null, context);
        if (value == null)
        {
            return false;
        }
        else if (value instanceof Boolean)
        {
            if (((Boolean) value).booleanValue())
                return true;
            else
                return false;
        }
        else
            return true;
    }
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        return (computableReference ? execute(null, context) : null);
    }
    /**
     *  Sets the value of a complex reference (something like $foo.bar)
     *  Currently used by ASTSetReference()
     *
     *  @see ASTSetDirective
     *
     *  @param context context object containing this reference
     *  @param value Object to set as value
     *  @return true if successful, false otherwise
     */
    public boolean setValue( InternalContextAdapter context, Object value)
      throws MethodInvocationException
    {
        if (jjtGetNumChildren() == 0)
        {
            context.put(rootString, value);
            return true;
        }
        /*
         *  The rootOfIntrospection is the object we will
         *  retrieve from the Context. This is the base
         *  object we will apply reflection to.
         */
        Object result = getVariableValue(context, rootString);
        if (result == null)
        {
            rsvc.error(new ReferenceException(""reference set : template = ""
                    + context.getCurrentTemplateName(), this));
            return false;
        }
        /*
         * How many child nodes do we have?
         */
        for (int i = 0; i < numChildren - 1; i++)
        {
            result = jjtGetChild(i).execute(result, context);
            if (result == null)
            {
                rsvc.error(new ReferenceException(""reference set : template = ""
                        + context.getCurrentTemplateName(), this));
                return false;
            }
        }
        /*
         *  We support two ways of setting the value in a #set($ref.foo = $value ) :
         *  1) ref.setFoo( value )
         *  2) ref,put(""foo"", value ) to parallel the get() map introspection
         */
        try
        {
            VelPropertySet vs =
                    rsvc.getUberspect().getPropertySet(result, identifier,
                            value, uberInfo);
            if (vs == null)
                return false;
            vs.invoke(result, value);
        }
        catch(InvocationTargetException ite)
        {
            /*
             *  this is possible
             */
            throw  new MethodInvocationException(
                ""ASTReference : Invocation of method '""
                + identifier + ""' in  "" + result.getClass()
                + "" threw exception ""
                + ite.getTargetException().getClass(),
               ite.getTargetException(), identifier );
        }
        catch(Exception e)
        {
            /*
             *  maybe a security exception?
             */
            rsvc.error(""ASTReference setValue() : exception : "" + e
                                  + "" template = "" + context.getCurrentTemplateName()
                                  + "" ["" + this.getLine() + "","" + this.getColumn() + ""]"");
            return false;
         }
        return true;
    }
    private String getRoot()
    {
        Token t = getFirstToken();
        /*
         *  we have a special case where something like
         *  $(\\)*!, where the user want's to see something
         *  like $!blargh in the output, but the ! prevents it from showing.
         *  I think that at this point, this isn't a reference.
         */
        /* so, see if we have ""\\!"" */
        int slashbang = t.image.indexOf(""\\!"");
        if (slashbang != -1)
        {
            /*
             *  lets do all the work here.  I would argue that if this occurrs,
             *  it's not a reference at all, so preceeding \ characters in front
             *  of the $ are just schmoo.  So we just do the escape processing
             *  trick (even | odd) and move on.  This kind of breaks the rule
             *  pattern of $ and # but '!' really tosses a wrench into things.
             */
             /*
              *  count the escapes : even # -> not escaped, odd -> escaped
              */
            int i = 0;
            int len = t.image.length();
            i = t.image.indexOf('$');
            if (i == -1)
            {
                /* yikes! */
                rsvc.error(""ASTReference.getRoot() : internal error : ""
                            + ""no $ found for slashbang."");
                computableReference = false;
                nullString = t.image;
                return nullString;
            }
            while (i < len && t.image.charAt(i) != '\\')
            {
                i++;
            }
            /*  ok, i is the first \ char */
            int start = i;
            int count = 0;
            while (i < len && t.image.charAt(i++) == '\\')
            {
                count++;
            }
            /*
             *  now construct the output string.  We really don't care about
             *  leading  slashes as this is not a reference.  It's quasi-schmoo
             */
            nullString = t.image.substring(0,start); // prefix up to the first
            nullString += t.image.substring(start, start + count-1 ); // get the slashes
            nullString += t.image.substring(start+count); // and the rest, including the
            /*
             *  this isn't a valid reference, so lets short circuit the value
             *  and set calcs
             */
            computableReference = false;
            return nullString;
        }
        /*
         *  we need to see if this reference is escaped.  if so
         *  we will clean off the leading \'s and let the
         *  regular behavior determine if we should output this
         *  as \$foo or $foo later on in render(). Lazyness..
         */
        escaped = false;
        if (t.image.startsWith(""\\""))
        {
            /*
             *  count the escapes : even # -> not escaped, odd -> escaped
             */
            int i = 0;
            int len = t.image.length();
            while (i < len && t.image.charAt(i) == '\\')
            {
                i++;
            }
            if ((i % 2) != 0)
                escaped = true;
            if (i > 0)
                escPrefix = t.image.substring(0, i / 2 );
            t.image = t.image.substring(i);
        }
        /*
         *  Look for preceeding stuff like '#' and '$'
         *  and snip it off, except for the
         *  last $
         */
        int loc1 = t.image.lastIndexOf('$');
        /*
         *  if we have extra stuff, loc > 0
         *  ex. '#$foo' so attach that to
         *  the prefix.
         */
        if (loc1 > 0)
        {
            morePrefix = morePrefix + t.image.substring(0, loc1);
            t.image = t.image.substring(loc1);
        }
        /*
         *  Now it should be clean. Get the literal in case this reference
         *  isn't backed by the context at runtime, and then figure out what
         *  we are working with.
         */
        nullString = literal();
        if (t.image.startsWith(""$!""))
        {
            referenceType = QUIET_REFERENCE;
            /*
             *  only if we aren't escaped do we want to null the output
             */
            if (!escaped)
                nullString = """";
            if (t.image.startsWith(""$!{""))
            {
                /*
                 *  ex : $!{provider.Title}
                 */
                return t.next.image;
            }
            else
            {
                /*
                 *  ex : $!provider.Title
                 */
                return t.image.substring(2);
            }
        }
        else if (t.image.equals(""${""))
        {
            /*
             *  ex : ${provider.Title}
             */
            referenceType = FORMAL_REFERENCE;
            return t.next.image;
        }
        else if (t.image.startsWith(""$""))
        {
            /*
             *  just nip off the '$' so we have
             *  the root
             */
            referenceType = NORMAL_REFERENCE;
            return t.image.substring(1);
        }
        else
        {
            /*
             * this is a 'RUNT', which can happen in certain circumstances where
             *  the parser is fooled into believeing that an IDENTIFIER is a real
             *  reference.  Another 'dreaded' MORE hack :).
             */
            referenceType = RUNT;
            return t.image;
        }
    }
    public Object getVariableValue(Context context, String variable)
    {
        return context.get(variable);
    }
    /**
     *  Routine to allow the literal representation to be
     *  externally overridden.  Used now in the VM system
     *  to override a reference in a VM tree with the
     *  literal of the calling arg to make it work nicely
     *  when calling arg is null.  It seems a bit much, but
     *  does keep things consistant.
     *
     *  Note, you can only set the literal once...
     *
     *  @param literal String to render to when null
     */
    public void setLiteral(String literal)
    {
        /*
         * do only once
         */
        if( this.literal == null)
            this.literal = literal;
    }
    /**
     *  Override of the SimpleNode method literal()
     *  Returns the literal representation of the
     *  node.  Should be something like
     *  $<token>.
     */
    public String literal()
    {
        if (literal != null)
            return literal;
        return super.literal();
    }
}
"
org.apache.velocity.runtime.parser.node.ASTSetDirective,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.app.event.EventCartridge;
/**
 * Node for the #set directive
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTSetDirective.java,v 1.22.4.1 2004/03/03 23:22:59 geirm Exp $
 */
public class ASTSetDirective extends SimpleNode
{
    private String leftReference = """";
    private Node right;
    private ASTReference left;
    boolean blather = false;
    public ASTSetDirective(int id)
    {
        super(id);
    }
    public ASTSetDirective(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  simple init.  We can get the RHS and LHS as the the tree structure is static
     */
    public Object init(InternalContextAdapter context, Object data)
            throws Exception
    {
        /*
         *  init the tree correctly
         */
        super.init( context, data );
        right = getRightHandSide();
        left = getLeftHandSide();
        blather = rsvc.getBoolean(RuntimeConstants.RUNTIME_LOG_REFERENCE_LOG_INVALID, true);
        /*
         *  grab this now.  No need to redo each time
         */
        leftReference = left.getFirstToken().image.substring(1);
        return data;
    }        
    /**
     *   puts the value of the RHS into the context under the key of the LHS
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException
    {
        /*
         *  get the RHS node, and it's value
         */
        Object value = right.value(context);
        /*
         * it's an error if we don't have a value of some sort
         */
        if ( value  == null)
        {
            /*
             *  first, are we supposed to say anything anyway?
             */
            if(blather)
            {
                EventCartridge ec = context.getEventCartridge();
                boolean doit = true;
                /*
                 *  if we have an EventCartridge...
                 */
                if (ec != null)
                {
                    doit = ec.shouldLogOnNullSet( left.literal(), right.literal() );
                }
                if (doit)
                {
                    rsvc.error(""RHS of #set statement is null. Context will not be modified. "" 
                                  + context.getCurrentTemplateName() + "" [line "" + getLine() 
                                  + "", column "" + getColumn() + ""]"");
                }
            }
            return false;
        }                
        /*
         *  if the LHS is simple, just punch the value into the context
         *  otherwise, use the setValue() method do to it.
         *  Maybe we should always use setValue()
         */
        if (left.jjtGetNumChildren() == 0)
        {
            context.put( leftReference, value);
        }
        else
        {
            left.setValue(context, value);
        }
        return true;
    }
    /**
     *  returns the ASTReference that is the LHS of the set statememt
     */
    private ASTReference getLeftHandSide()
    {
        return (ASTReference) jjtGetChild(0);
     //   return (ASTReference) jjtGetChild(0).jjtGetChild(0).jjtGetChild(0);
    }
    /**
     *  returns the RHS Node of the set statement
     */
    private Node getRightHandSide()
    {
        return jjtGetChild(1);
//        return jjtGetChild(0).jjtGetChild(0).jjtGetChild(1).jjtGetChild(0);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTStringLiteral,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import java.io.StringWriter;
import java.io.BufferedReader;
import java.io.StringReader;
import org.apache.velocity.runtime.RuntimeConstants;
/**
 * ASTStringLiteral support.  Will interpolate!
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: ASTStringLiteral.java,v 1.17.4.1 2004/03/03 23:22:59 geirm Exp $
 */
public class ASTStringLiteral extends SimpleNode
{
    /* cache the value of the interpolation switch */
    private boolean interpolate = true;
    private SimpleNode nodeTree = null;
    private String image = """";
    private String interpolateimage = """";
    public ASTStringLiteral(int id)
    {
        super(id);
    }
    public ASTStringLiteral(Parser p, int id)
    {
        super(p, id);
    }
    /**
     *  init : we don't have to do much.  Init the tree (there 
     *  shouldn't be one) and then see if interpolation is turned on.
     */
    public Object init(InternalContextAdapter context, Object data) 
        throws Exception
    {
        /*
         *  simple habit...  we prollie don't have an AST beneath us
         */
        super.init(context, data);
        /*
         *  the stringlit is set at template parse time, so we can 
         *  do this here for now.  if things change and we can somehow 
         * create stringlits at runtime, this must
         *  move to the runtime execution path
         *
         *  so, only if interpolation is turned on AND it starts 
         *  with a "" AND it has a  directive or reference, then we 
         *  can  interpolate.  Otherwise, don't bother.
         */
        interpolate = rsvc.getBoolean(RuntimeConstants.INTERPOLATE_STRINGLITERALS , true)
            && getFirstToken().image.startsWith(""\"""")
            && ((getFirstToken().image.indexOf('$') != -1) 
                 || (getFirstToken().image.indexOf('#') != -1));
        /*
         *  get the contents of the string, minus the '/"" at each end
         */
        image = getFirstToken().image.substring(1, 
                                                getFirstToken().image.length() - 1);
        /*
         * tack a space on the end (dreaded <MORE> kludge)
         */
        interpolateimage = image + "" "";
        if (interpolate)
        {
            /*
             *  now parse and init the nodeTree
             */
            BufferedReader br = new BufferedReader(new StringReader(interpolateimage));
            /*
             * it's possible to not have an initialization context - or we don't
             * want to trust the caller - so have a fallback value if so
             *
             *  Also, do *not* dump the VM namespace for this template
             */
            nodeTree  = rsvc.parse(br, (context != null) ?
                    context.getCurrentTemplateName() : ""StringLiteral"", false);
            /*
             *  init with context. It won't modify anything
             */
            nodeTree.init(context, rsvc);
        }
        return data;
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  renders the value of the string literal
     *  If the properties allow, and the string literal contains a $ or a #
     *  the literal is rendered against the context
     *  Otherwise, the stringlit is returned.
     */
    public Object value(InternalContextAdapter context)
    {
        if (interpolate)
        {          
            try
            {
                /*
                 *  now render against the real context
                 */
                StringWriter writer = new StringWriter();
                nodeTree.render(context, writer);
                /*
                 * and return the result as a String
                 */
                String ret = writer.toString();
                /*
                 *  remove the space from the end (dreaded <MORE> kludge)
                 */
                return ret.substring(0, ret.length() - 1);
            }
            catch(Exception e)
            {
                /* 
                 *  eh.  If anything wrong, just punt 
                 *  and output the literal 
                 */
                rsvc.error(""Error in interpolating string literal : "" + e);
            }
        }
        /*
         *  ok, either not allowed to interpolate, there wasn't 
         *  a ref or directive, or we failed, so
         *  just output the literal
         */
        return image;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTSubtractNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.exception.MethodInvocationException;
/**
 * Handles integer subtraction of nodes (in #set() )
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTSubtractNode.java,v 1.7.8.1 2004/03/03 23:22:59 geirm Exp $ 
 */
public class ASTSubtractNode extends SimpleNode
{
    public ASTSubtractNode(int id)
    {
        super(id);
    }
    public ASTSubtractNode(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  computes the value of the subtraction.  Currently
     *  limited to integers
     *  @return Integer(value) or null
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            rsvc.error( ( left == null ? ""Left"" : ""Right"" ) + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of subtraction operation has null value.""
                           + "" Operation not possible. ""
                           +  context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        /*
         *  if not an Integer, not much we can do either
         */
        if ( !( left instanceof Integer )  || !( right instanceof Integer ))
        {
            rsvc.error( ( !( left instanceof Integer ) ? ""Left"" : ""Right"" ) 
                           + "" side of subtraction operation is not a valid type. ""
                           + ""Currently only integers (1,2,3...) and Integer type is supported. ""
                           + context.getCurrentTemplateName() + "" [line "" + getLine() 
                           + "", column "" + getColumn() + ""]"");
            return null;
        }
        return new Integer( ( (Integer) left ).intValue() - (  (Integer) right ).intValue() );
    }
}
"
org.apache.velocity.runtime.parser.node.ASTText,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
public class ASTText extends SimpleNode
{
    private char[] ctext;
    public ASTText(int id)
    {
        super(id);
    }
    public ASTText(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public Object init( InternalContextAdapter context, Object data) 
        throws Exception
    {
        Token t = getFirstToken();
        String text = NodeUtils.tokenLiteral( t );
        ctext = text.toCharArray();
        return data;
    }
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException
    {
        writer.write(ctext);
        return true;
    }    
}
"
org.apache.velocity.runtime.parser.node.ASTTrue,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
public class ASTTrue extends SimpleNode
{
    private static Boolean value = Boolean.TRUE;
    public ASTTrue(int id)
    {
        super(id);
    }
    public ASTTrue(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    public boolean evaluate(InternalContextAdapter context)
    {
        return true;
    }        
    public Object value(InternalContextAdapter context)
    {
        return value;
    }        
}
"
org.apache.velocity.runtime.parser.node.ASTVariable,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Parser;
public class ASTVariable extends SimpleNode
{
    public ASTVariable(int id)
    {
        super(id);
    }
    public ASTVariable(Parser p, int id)
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTWord,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Parser;
public class ASTWord extends SimpleNode 
{
    public ASTWord(int id) 
    {
        super(id);
    }
    public ASTWord(Parser p, int id) 
    {
        super(p, id);
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data) 
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.BooleanPropertyExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.runtime.RuntimeLogger;
/**
 *  Handles discovery and valuation of a
 *  boolean object property, of the
 *  form public boolean is<property> when executed.
 *
 *  We do this separately as to preserve the current
 *  quasi-broken semantics of get<as is property>
 *  get< flip 1st char> get(""property"") and now followed
 *  by is<Property>
 *
 *  @author <a href=""geirm@apache.org"">Geir Magnusson Jr.</a>
 *  @version $Id: BooleanPropertyExecutor.java,v 1.3.4.1 2004/03/03 23:22:59 geirm Exp $
 */
public class BooleanPropertyExecutor extends PropertyExecutor
{
    public BooleanPropertyExecutor(RuntimeLogger rlog, Introspector is, Class clazz, String property)
    {
        super(rlog, is, clazz, property);
    }
    protected void discover(Class clazz, String property)
    {
        try
        {
            char c;
            StringBuffer sb;
            Object[] params = {  };
            /*
             *  now look for a boolean isFoo
             */
            sb = new StringBuffer(""is"");
            sb.append(property);
            c = sb.charAt(2);
            if (Character.isLowerCase(c))
            {
                sb.setCharAt(2, Character.toUpperCase(c));
            }
            methodUsed = sb.toString();
            method = introspector.getMethod(clazz, methodUsed, params);
            if (method != null)
            {
                /*
                 *  now, this has to return a boolean
                 */
                if (method.getReturnType() == Boolean.TYPE)
                    return;
                method = null;
            }
        }
        catch(Exception e)
        {
            rlog.error(""PROGRAMMER ERROR : BooleanPropertyExector() : "" + e);
        }
    }
}
"
org.apache.velocity.runtime.parser.node.GetExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.util.introspection.Introspector;
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.RuntimeLogger;
/**
 * Executor that simply tries to execute a get(key)
 * operation. This will try to find a get(key) method
 * for any type of object, not just objects that
 * implement the Map interface as was previously
 * the case.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: GetExecutor.java,v 1.8.4.1 2004/03/03 23:22:59 geirm Exp $
 */
public class GetExecutor extends AbstractExecutor
{
    /**
     * Container to hold the 'key' part of 
     * get(key).
     */
    private Object[] args = new Object[1];
    /**
     * Default constructor.
     */
    public GetExecutor(RuntimeLogger r, Introspector ispect, Class c, String key)
        throws Exception
    {
        rlog = r;
        args[0] = key;
        method = ispect.getMethod(c, ""get"", args);
    }
    /**
     * Execute method against context.
     */
    public Object execute(Object o)
        throws IllegalAccessException, InvocationTargetException
    {
        if (method == null)
            return null;
        return method.invoke(o, args);
    }
    /**
     * Execute method against context.
     */
    public Object OLDexecute(Object o, InternalContextAdapter context)
        throws IllegalAccessException, MethodInvocationException
    {
        if (method == null)
            return null;
        try 
        {
            return method.invoke(o, args);  
        }
        catch(InvocationTargetException ite)
        {
            /*
             *  the method we invoked threw an exception.
             *  package and pass it up
             */
            throw  new MethodInvocationException( 
                ""Invocation of method 'get(\"""" + args[0] + ""\"")'"" 
                + "" in  "" + o.getClass() 
                + "" threw exception "" 
                + ite.getTargetException().getClass(), 
                ite.getTargetException(), ""get"");
        }
        catch(IllegalArgumentException iae)
        {
            return null;
        }
    }
}
"
org.apache.velocity.runtime.parser.node.Node,"/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.velocity.runtime.parser.node;
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 *  All AST nodes must implement this interface.  It provides basic
 *  machinery for constructing the parent and child relationships
 *  between nodes. 
 */
public interface Node
{
    /**
     *  This method is called after the node has been made the current
     *  node.  It indicates that child nodes can now be added to it. 
     */
    public void jjtOpen();
    /** 
     *  This method is called after all the child nodes have been
     *  added. 
     */
    public void jjtClose();
    /** 
     *  This pair of methods are used to inform the node of its
     *  parent. 
     */
    public void jjtSetParent(Node n);
    public Node jjtGetParent();
    /** 
     *  This method tells the node to add its argument to the node's
     *   list of children.  
     */
    public void jjtAddChild(Node n, int i);
    /** 
     *  This method returns a child node.  The children are numbered
     *  from zero, left to right. 
     */
    public Node jjtGetChild(int i);
    /** Return the number of children the node has. */
    public int jjtGetNumChildren();
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data);
    public Object childrenAccept(ParserVisitor visitor, Object data);
    // added
    public Token getFirstToken();
    public Token getLastToken();
    public int getType();
    public Object init( InternalContextAdapter context, Object data) throws Exception;
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException;
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException;
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException, ParseErrorException, ResourceNotFoundException;
    public Object execute(Object o, InternalContextAdapter context)
      throws MethodInvocationException;
    public void setInfo(int info);
    public int getInfo();
    public String literal();
    public void setInvalid();
    public boolean isInvalid();
    public int getLine();
    public int getColumn();
}
"
org.apache.velocity.runtime.parser.node.NodeUtils,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.context.Context;
import org.apache.velocity.runtime.parser.*;
/**
 * Utilities for dealing with the AST node structure.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: NodeUtils.java,v 1.16.4.1 2004/03/03 23:22:59 geirm Exp $
 */
public class NodeUtils
{
    /**
     * Collect all the <SPECIAL_TOKEN>s that
     * are carried along with a token. Special
     * tokens do not participate in parsing but
     * can still trigger certain lexical actions.
     * In some cases you may want to retrieve these
     * special tokens, this is simply a way to
     * extract them.
     */
    public static String specialText(Token t)
    {
        String specialText = """";
        if (t.specialToken == null || t.specialToken.image.startsWith(""##"") )
            return specialText;
        Token tmp_t = t.specialToken;
        while (tmp_t.specialToken != null)
        {
            tmp_t = tmp_t.specialToken;
        }
        while (tmp_t != null)
        {
            String st = tmp_t.image;
            StringBuffer sb = new StringBuffer();
            for(int i = 0; i < st.length(); i++)
            {
                char c = st.charAt(i);
                if ( c == '#' || c == '$' )
                {
                    sb.append( c );
                }
                /*
                 *  more dreaded MORE hack :)
                 * 
                 *  looking for (""\\"")*""$"" sequences
                 */
                if ( c == '\\')
                {
                    boolean ok = true;
                    boolean term = false;
                    int j = i;
                    for( ok = true; ok && j < st.length(); j++)
                    {
                        char cc = st.charAt( j );
                        if (cc == '\\')
                        {
                            /*
                             *  if we see a \, keep going
                             */
                            continue;
                        }
                        else if( cc == '$' )
                        {
                            /*
                             *  a $ ends it correctly
                             */
                            term = true;
                            ok = false;
                        }
                        else
                        {
                            /*
                             *  nah...
                             */
                            ok = false;
                        }
                    }
                    if (term)
                    {
                        String foo =  st.substring( i, j );
                        sb.append( foo );
                        i = j;
                    }
                }
            }
            specialText += sb.toString();
            tmp_t = tmp_t.next;
        }            
        return specialText;
    }
    /**
     *  complete node literal
     *
     */
    public static String tokenLiteral( Token t )
    {
        return specialText( t ) + t.image;
    }
    /**
     * Utility method to interpolate context variables
     * into string literals. So that the following will
     * work:
     *
     * #set $name = ""candy""
     * $image.getURI(""${name}.jpg"")
     *
     * And the string literal argument will
     * be transformed into ""candy.jpg"" before
     * the method is executed.
     */
    public static String interpolate(String argStr, Context vars)
    {
        StringBuffer argBuf = new StringBuffer();
        for (int cIdx = 0 ; cIdx < argStr.length();)
        {
            char ch = argStr.charAt(cIdx);
            switch (ch)
            {
                case '$':
                    StringBuffer nameBuf = new StringBuffer();
                    for (++cIdx ; cIdx < argStr.length(); ++cIdx)
                    {
                        ch = argStr.charAt(cIdx);
                        if (ch == '_' || ch == '-' 
                            || Character.isLetterOrDigit(ch))
                            nameBuf.append(ch);
                        else if (ch == '{' || ch == '}')
                            continue;  
                        else
                            break;
                    }
                    if (nameBuf.length() > 0)
                    {
                        Object value = vars.get(nameBuf.toString());
                        if (value == null)
                            argBuf.append(""$"").append(nameBuf.toString());
                        else
                            argBuf.append(value.toString());
                    }
                    break;
                default:
                    argBuf.append(ch);
                    ++cIdx;
                    break;
            }
        }
        return argBuf.toString();
    }
}
"
org.apache.velocity.runtime.parser.node.ParserVisitor,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
public interface ParserVisitor
{
  public Object visit(SimpleNode node, Object data);
  public Object visit(ASTprocess node, Object data);
  public Object visit(ASTComment node, Object data);
  public Object visit(ASTNumberLiteral node, Object data);
  public Object visit(ASTStringLiteral node, Object data);
  public Object visit(ASTIdentifier node, Object data);
  public Object visit(ASTWord node, Object data);
  public Object visit(ASTDirective node, Object data);
  public Object visit(ASTBlock node, Object data);
  public Object visit(ASTObjectArray node, Object data);
  public Object visit(ASTMethod node, Object data);
  public Object visit(ASTReference node, Object data);
  public Object visit(ASTTrue node, Object data);
  public Object visit(ASTFalse node, Object data);
  public Object visit(ASTText node, Object data);
  public Object visit(ASTIfStatement node, Object data);
  public Object visit(ASTElseStatement node, Object data);
  public Object visit(ASTElseIfStatement node, Object data);
  public Object visit(ASTSetDirective node, Object data);
  public Object visit(ASTExpression node, Object data);
  public Object visit(ASTAssignment node, Object data);
  public Object visit(ASTOrNode node, Object data);
  public Object visit(ASTAndNode node, Object data);
  public Object visit(ASTEQNode node, Object data);
  public Object visit(ASTNENode node, Object data);
  public Object visit(ASTLTNode node, Object data);
  public Object visit(ASTGTNode node, Object data);
  public Object visit(ASTLENode node, Object data);
  public Object visit(ASTGENode node, Object data);
  public Object visit(ASTAddNode node, Object data);
  public Object visit(ASTSubtractNode node, Object data);
  public Object visit(ASTMulNode node, Object data);
  public Object visit(ASTDivNode node, Object data);
  public Object visit(ASTModNode node, Object data);
  public Object visit(ASTNotNode node, Object data);
}
"
org.apache.velocity.runtime.parser.node.PropertyExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Copyright 2000-2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.runtime.RuntimeLogger;
/**
 * Returned the value of object property when executed.
 */
public class PropertyExecutor extends AbstractExecutor
{
    protected Introspector introspector = null;
    protected String methodUsed = null;
    public PropertyExecutor(RuntimeLogger r, Introspector ispctr,
                            Class clazz, String property)
    {
        rlog = r;
        introspector = ispctr;
        discover(clazz, property);
    }
    protected void discover(Class clazz, String property)
    {
        /*
         *  this is gross and linear, but it keeps it straightforward.
         */
        try
        {
            char c;
            StringBuffer sb;
            Object[] params = {  };
            /*
             *  start with get<property>
             *  this leaves the property name 
             *  as is...
             */
            sb = new StringBuffer(""get"");
            sb.append(property);
            methodUsed = sb.toString();
            method = introspector.getMethod(clazz, methodUsed, params);
            if (method != null)
                return;
            /*
             *  now the convenience, flip the 1st character
             */
            sb = new StringBuffer(""get"");
            sb.append(property);
            c = sb.charAt(3);
            if (Character.isLowerCase(c))
            {
                sb.setCharAt(3, Character.toUpperCase(c));
            }
            else
            {
                sb.setCharAt(3, Character.toLowerCase(c));
            }
            methodUsed = sb.toString();
            method = introspector.getMethod(clazz, methodUsed, params);
            if (method != null)
                return; 
        }
        catch(Exception e)
        {
            rlog.error(""PROGRAMMER ERROR : PropertyExector() : "" + e );
        }
    }
    /**
     * Execute method against context.
     */
    public Object execute(Object o)
        throws IllegalAccessException,  InvocationTargetException
    {
        if (method == null)
            return null;
        return method.invoke(o, null);
    }
}
"
org.apache.velocity.runtime.parser.node.SimpleNode,"/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.velocity.runtime.parser.node;
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.exception.ReferenceException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
public class SimpleNode implements Node
{
    protected RuntimeServices rsvc = null;
    protected Node parent;
    protected Node[] children;
    protected int id;
    protected Parser parser;
    protected int info; // added
    public boolean state;
    protected boolean invalid = false;
    /* Added */
    protected Token first, last;
    public SimpleNode(int i)
    {
        id = i;
    }
    public SimpleNode(Parser p, int i)
    {
        this(i);
        parser = p;
    }
    public void jjtOpen()
    {
        first = parser.getToken(1); // added
    }
    public void jjtClose()
    {
        last = parser.getToken(0); // added
    }
    public void setFirstToken(Token t)
    {
        this.first = t;
    }
    public Token getFirstToken()
    {
        return first;
    }
    public Token getLastToken()
    {
        return last;
    }
    public void jjtSetParent(Node n)
    {
        parent = n;
    }
    public Node jjtGetParent()
    {
        return parent;
    }
    public void jjtAddChild(Node n, int i)
    {
        if (children == null)
        {
            children = new Node[i + 1];
        }
        else if (i >= children.length)
        {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }
    public Node jjtGetChild(int i)
    {
        return children[i];
    }
    public int jjtGetNumChildren()
    {
        return (children == null) ? 0 : children.length;
    }
    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /** Accept the visitor. **/
    public Object childrenAccept(ParserVisitor visitor, Object data)
    {
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                children[i].jjtAccept(visitor, data);
            }
        }
        return data;
    }
    /* You can override these two methods in subclasses of SimpleNode to
        customize the way the node appears when the tree is dumped.  If
        your output uses more than one line you should override
        toString(String), otherwise overriding toString() is probably all
        you need to do. */
    //    public String toString()
    // {
    //    return ParserTreeConstants.jjtNodeName[id];
    // }
    public String toString(String prefix)
    {
        return prefix + toString();
    }
    /* Override this method if you want to customize how the node dumps
        out its children. */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + "" "");
                }
            }
        }
    }
    // All additional methods
    public String literal()
    {
        Token t = first;
        StringBuffer sb = new StringBuffer(t.image);
        while (t != last)
        {
            t = t.next;
            sb.append(t.image);
        }
        return sb.toString();
    }
    public Object init( InternalContextAdapter context, Object data) throws Exception
    {
        /*
         * hold onto the RuntimeServices
         */
        rsvc = (RuntimeServices) data;
        int i, k = jjtGetNumChildren();
        for (i = 0; i < k; i++)
        {
            try
            {
                jjtGetChild(i).init( context, data);
            }
            catch (ReferenceException re)
            {
                rsvc.error(re);
            }
        }            
        return data;
    }
    public boolean evaluate( InternalContextAdapter  context)
        throws MethodInvocationException
    {
        return false;
    }        
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return null;
    }        
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException, ParseErrorException, ResourceNotFoundException
    {
        int i, k = jjtGetNumChildren();
        for (i = 0; i < k; i++)
            jjtGetChild(i).render(context, writer);
        return true;
    }
    public Object execute(Object o, InternalContextAdapter context)
      throws MethodInvocationException
    {
        return null;
    }
    public int getType()
    {
        return id;
    }
    public void setInfo(int info)
    {
        this.info = info;
    }
    public int getInfo()
    {
        return info;
    }        
    public void setInvalid()
    {
        invalid = true;
    }        
    public boolean isInvalid()
    {
        return invalid;
    }        
    public int getLine()
    {
        return first.beginLine;
    }
    public int getColumn()
    {
        return first.beginColumn;
    }        
}
"
org.apache.velocity.runtime.resource.ContentResource,"package org.apache.velocity.runtime.resource;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.StringWriter;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 * This class represent a general text resource that may have been
 * retrieved from any number of possible sources.
 *
 * Also of interest is Velocity's {@link org.apache.velocity.Template}
 * <code>Resource</code>.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ContentResource.java,v 1.10.4.1 2004/03/03 23:23:01 geirm Exp $
 */
public class ContentResource extends Resource
{
    /** Default empty constructor */
    public ContentResource()
    {
    }
    /**
     * Pull in static content and store it.
     *
     * @exception ResourceNotFoundException Resource could not be
     * found.
     */
    public boolean process()
        throws ResourceNotFoundException
    {
        BufferedReader reader = null;
        try
        {
            StringWriter sw = new StringWriter();
            reader = new BufferedReader(
                new InputStreamReader(resourceLoader.getResourceStream(name),
                                      encoding));
            char buf[] = new char[1024];
            int len = 0;
            while ( ( len = reader.read( buf, 0, 1024 )) != -1)
                sw.write( buf, 0, len );
            setData(sw.toString());
            return true;
        }
        catch ( ResourceNotFoundException e )
        {
            // Tell the ContentManager to continue to look through any
            // remaining configured ResourceLoaders.
            throw e;
        }
        catch ( Exception e ) 
        {
            rsvc.error(""Cannot process content resource : "" + e.toString() );
            return false;
        }
        finally
        {
            if (reader != null)
            {
                try
                {
                    reader.close();
                }
                catch (Exception ignored)
                {
                }
            }
        }
    }
}
"
org.apache.velocity.runtime.resource.Resource,"package org.apache.velocity.runtime.resource;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.resource.loader.ResourceLoader;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
/**
 * This class represent a general text resource that
 * may have been retrieved from any number of possible
 * sources.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Resource.java,v 1.12.4.1 2004/03/03 23:23:01 geirm Exp $
 */
public abstract class Resource
{
    protected RuntimeServices rsvc = null;
    /**
     * The template loader that initially loaded the input
     * stream for this template, and knows how to check the
     * source of the input stream for modification.
     */
    protected ResourceLoader resourceLoader;
    /**
     * The number of milliseconds in a minute, used to calculate the
     * check interval.
     */
    protected static final long MILLIS_PER_SECOND =  1000;
    /**
     * How often the file modification time is checked (in seconds).
     */
    protected long modificationCheckInterval = 0;
    /**
     * The file modification time (in milliseconds) for the cached template.
     */
    protected long lastModified = 0;
    /**
     * The next time the file modification time will be checked (in 
     * milliseconds).
     */
    protected long nextCheck = 0;
    /**
     *  Name of the resource
     */
    protected String name;
    /**
     *  Character encoding of this resource
     */
    protected String encoding = RuntimeConstants.ENCODING_DEFAULT;
    /** 
     *  Resource might require ancillary storage of some kind 
     */
    protected Object data = null;
    /** 
     *  Default constructor 
     */
    public Resource()
    {
    }
    public void setRuntimeServices( RuntimeServices rs )
    {
        rsvc = rs;
    }
    /**
     * Perform any subsequent processing that might need
     * to be done by a resource. In the case of a template
     * the actual parsing of the input stream needs to be
     * performed.
     *
     * @return Whether the resource could be processed successfully.
     * For a {@link org.apache.velocity.Template} or {@link
     * org.apache.velocity.runtime.resource.ContentResource}, this
     * indicates whether the resource could be read.
     * @exception ResourceNotFoundException Similar in semantics as
     * returning <code>false</code>.
     */
    public abstract boolean process() 
        throws ResourceNotFoundException, ParseErrorException, Exception;
    public boolean isSourceModified()
    {
        return resourceLoader.isSourceModified(this);
    }
    /**
     * Set the modification check interval.
     * @param interval The interval (in seconds).
     */
    public void setModificationCheckInterval(long modificationCheckInterval)
    {
        this.modificationCheckInterval = modificationCheckInterval;
    }
    /**
     * Is it time to check to see if the resource
     * source has been updated?
     */
    public boolean requiresChecking()
    {
        /*
         *  short circuit this if modificationCheckInterval == 0
         *  as this means ""don't check""
         */
        if (modificationCheckInterval <= 0 )
        {
           return false;
        }
        /*
         *  see if we need to check now
         */
        return ( System.currentTimeMillis() >= nextCheck );
    }
    /**
     * 'Touch' this template and thereby resetting
     * the nextCheck field.
     */
    public void touch()
    {
        nextCheck = System.currentTimeMillis() + ( MILLIS_PER_SECOND *  modificationCheckInterval);
    }
    /**
     * Set the name of this resource, for example
     * test.vm.
     */
    public void setName(String name)
    {
        this.name = name;
    }        
    /**
     * Get the name of this template.
     */
    public String getName()
    {
        return name;
    }        
    /**
     *  set the encoding of this resource
     *  for example, ""ISO-8859-1""
     */
    public void setEncoding( String encoding )
    {
        this.encoding = encoding;
    }
    /**
     *  get the encoding of this resource
     *  for example, ""ISO-8859-1""
     */
    public String getEncoding()
    {
        return encoding;
    }
    /**
     * Return the lastModifed time of this
     * template.
     */
    public long getLastModified()
    {
        return lastModified;
    }        
    /**
     * Set the last modified time for this
     * template.
     */
    public void setLastModified(long lastModified)
    {
        this.lastModified = lastModified;
    }        
    /**
     * Return the template loader that pulled
     * in the template stream
     */
    public ResourceLoader getResourceLoader()
    {
        return resourceLoader;
    }
    /**
     * Set the template loader for this template. Set
     * when the Runtime determines where this template
     * came from the list of possible sources.
     */
    public void setResourceLoader(ResourceLoader resourceLoader)
    {
        this.resourceLoader = resourceLoader;
    }        
    /** 
     * Set arbitrary data object that might be used
     * by the resource.
     */
    public void setData(Object data)
    {
        this.data = data;
    }
    /**
     * Get arbitrary data object that might be used
     * by the resource.
     */
    public Object getData()
    {
        return data;
    }        
}
"
org.apache.velocity.runtime.resource.ResourceCache,"package org.apache.velocity.runtime.resource;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Interface that defines the shape of a pluggable resource cache
 *  for the included ResourceManager
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceCache.java,v 1.1.8.1 2004/03/03 23:23:01 geirm Exp $
 */
public interface ResourceCache
{
    /**
     *  initializes the ResourceCache.  Will be 
     *  called before any utilization
     *
     *  @param rs RuntimeServices to use for logging, etc
     */
    public void initialize( RuntimeServices rs );
    /**
     *  retrieves a Resource from the
     *  cache
     *
     *  @param resourceKey key for Resource to be retrieved
     *  @return Resource specified or null if not found
     */
    public Resource get( Object resourceKey );
    /**
     *  stores a Resource in the cache
     *
     *  @param resourceKey key to associate with the Resource
     *  @param resource Resource to be stored
     *  @return existing Resource stored under this key, or null if none
     */
    public Resource put( Object resourceKey, Resource resource );
    /**
     *  removes a Resource from the cache
     *
     *  @param resourceKey resource to be removed
     *  @param Resource stored under key
     */
    public Resource remove( Object resourceKey );
    /**
     *  returns an Iterator of Keys in the cache
     */
     public Iterator enumerateKeys();
}
"
org.apache.velocity.runtime.resource.ResourceCacheImpl,"package org.apache.velocity.runtime.resource;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Hashtable;
import java.util.Map;
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Default implementation of the resource cache for the default
 * ResourceManager.
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @version $Id: ResourceCacheImpl.java,v 1.2.8.1 2004/03/03 23:23:01 geirm Exp $
 */
public class ResourceCacheImpl implements ResourceCache
{
    /**
     * Cache storage, assumed to be thread-safe.
     */
    protected Map cache = new Hashtable();
    /**
     * Runtime services, generally initialized by the
     * <code>initialize()</code> method.
     */
    protected RuntimeServices rsvc = null;
    public void initialize( RuntimeServices rs )
    {
        rsvc = rs;
        rsvc.info(""ResourceCache : initialized. ("" + this.getClass() + "")"");
    }
    public Resource get( Object key )
    {
        return (Resource) cache.get( key );
    }
    public Resource put( Object key, Resource value )
    {
        return (Resource) cache.put( key, value );
    }
    public Resource remove( Object key )
    {
        return (Resource) cache.remove( key );
    }
    public Iterator enumerateKeys()
    {
        return cache.keySet().iterator();
    }
}
"
org.apache.velocity.runtime.resource.ResourceFactory,"package org.apache.velocity.runtime.resource;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.Template;
/**
 * Class responsible for instantiating <code>Resource</code> objects,
 * given name and type.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceFactory.java,v 1.5.8.1 2004/03/03 23:23:01 geirm Exp $
 */
public class ResourceFactory
{
    public static Resource getResource(String resourceName, int resourceType)
    {
        Resource resource = null;
        switch (resourceType)
        {
            case ResourceManager.RESOURCE_TEMPLATE:
                resource = new Template();
                break;
            case ResourceManager.RESOURCE_CONTENT:
                resource = new ContentResource();
                break;
        }
        return resource;
    }
}
"
org.apache.velocity.runtime.resource.ResourceManager,"package org.apache.velocity.runtime.resource;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
/**
 * Class to manage the text resource for the Velocity
 * Runtime.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceManager.java,v 1.34.4.1 2004/03/03 23:23:01 geirm Exp $
 */
public interface ResourceManager
{
    /**
     * A template resources.
     */
    public static final int RESOURCE_TEMPLATE = 1;
    /**
     * A static content resource.
     */
    public static final int RESOURCE_CONTENT = 2;
    /**
     * Initialize the ResourceManager.
     */
    public void initialize( RuntimeServices rs ) throws Exception;
    /**
     * Gets the named resource.  Returned class type corresponds to specified type
     * (i.e. <code>Template</code> to <code>RESOURCE_TEMPLATE</code>).
     *
     * @param resourceName The name of the resource to retrieve.
     * @param resourceType The type of resource (<code>RESOURCE_TEMPLATE</code>,
     *                     <code>RESOURCE_CONTENT</code>, etc.).
     * @param encoding  The character encoding to use.
     * @return Resource with the template parsed and ready.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if a problem in parse
     */
    public Resource getResource(String resourceName, int resourceType, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     *  Determines is a template exists, and returns name of the loader that 
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public String getLoaderNameForResource(String resourceName );
}
"
org.apache.velocity.runtime.resource.ResourceManagerImpl,"package org.apache.velocity.runtime.resource;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Vector;
import java.io.InputStream;
import java.io.IOException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.resource.ResourceFactory;
import org.apache.velocity.runtime.resource.loader.ResourceLoader;
import org.apache.velocity.runtime.resource.loader.ResourceLoaderFactory;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * Class to manage the text resource for the Velocity
 * Runtime.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceManagerImpl.java,v 1.7.4.1 2004/03/03 23:23:01 geirm Exp $
 */
public class ResourceManagerImpl implements ResourceManager
{
    /**
     * A template resources.
     */
    public static final int RESOURCE_TEMPLATE = 1;
    /**
     * A static content resource.
     */
    public static final int RESOURCE_CONTENT = 2;
    /**
     * token used to identify the loader internally
     */
    private static final String RESOURCE_LOADER_IDENTIFIER = ""_RESOURCE_LOADER_IDENTIFIER_"";
    /**
     *  Object implementing ResourceCache to 
     *  be our resource manager's Resource cache.
     */
    protected ResourceCache globalCache = null;
    /**
     * The List of templateLoaders that the Runtime will
     * use to locate the InputStream source of a template.
     */
    protected  ArrayList resourceLoaders = new ArrayList();
    /**
     * This is a list of the template input stream source
     * initializers, basically properties for a particular
     * template stream source. The order in this list
     * reflects numbering of the properties i.e.
     *
     * <loader-id>.resource.loader.<property> = <value>
     */
    private  ArrayList sourceInitializerList = new ArrayList();
    /**
     * This is a map of public name of the template
     * stream source to it's initializer. This is so
     * that clients of velocity can set properties of
     * a template source stream with its public name.
     * So for example, a client could set the 
     * File.resource.path property and this would
     * change the resource.path property for the
     * file template stream source.
     */
    private  Hashtable sourceInitializerMap = new Hashtable();
    /**
     * Each loader needs a configuration object for
     * its initialization, this flags keeps track of whether
     * or not the configuration objects have been created
     * for the resource loaders.
     */
    private  boolean resourceLoaderInitializersActive = false;
    /**
     *  switch to turn off log notice when a resource is found for
     *  the first time.
     */
    private  boolean logWhenFound = true;
    protected RuntimeServices rsvc = null;
    /**
     * Initialize the ResourceManager.
     */
    public void initialize( RuntimeServices rs ) 
        throws Exception
    {
        rsvc = rs;
        rsvc.info(""Default ResourceManager initializing. ("" + this.getClass() + "")"");
        ResourceLoader resourceLoader;
        assembleResourceLoaderInitializers();
        for (int i = 0; i < sourceInitializerList.size(); i++)
        {
            ExtendedProperties configuration = (ExtendedProperties) sourceInitializerList.get(i);
            String loaderClass = configuration.getString(""class"");
            if ( loaderClass == null)
            {
                rsvc.error(  ""Unable to find '""
                                + configuration.getString(RESOURCE_LOADER_IDENTIFIER)
                                + "".resource.loader.class' specification in configuation.""
                                + "" This is a critical value.  Please adjust configuration."");
                continue;
            }
            resourceLoader = ResourceLoaderFactory.getLoader( rsvc, loaderClass);
            resourceLoader.commonInit( rsvc, configuration);
            resourceLoader.init(configuration);
            resourceLoaders.add(resourceLoader);
        }
        /*
         * now see if this is overridden by configuration
         */
        logWhenFound = rsvc.getBoolean( RuntimeConstants.RESOURCE_MANAGER_LOGWHENFOUND, true );
        /*
         *  now, is a global cache specified?
         */
        String claz = rsvc.getString( RuntimeConstants.RESOURCE_MANAGER_CACHE_CLASS );
        Object o = null;
        if ( claz != null && claz.length() > 0 )
        {
            try
            {
               o = Class.forName( claz ).newInstance();
            }
            catch (ClassNotFoundException cnfe )
            {
                String err = ""The specified class for ResourceCache (""
                    + claz    
                    + "") does not exist (or is not accessible to the current classlaoder)."";
                 rsvc.error( err );
                 o = null;
            }
            if (!(o instanceof ResourceCache) )
            {
                String err = ""The specified class for ResourceCache (""
                    + claz 
                    + "") does not implement org.apache.runtime.resource.ResourceCache.""
                    + "" ResourceManager. Using default ResourceCache implementation."";
                rsvc.error( err);
                o = null;
            }
        }
        /*
         *  if we didn't get through that, just use the default.
         */
        if ( o == null)
            o = new ResourceCacheImpl();
         globalCache = (ResourceCache) o;
         globalCache.initialize( rsvc );        
         rsvc.info(""Default ResourceManager initialization complete."");
        }
    /**
     * This will produce a List of Hashtables, each
     * hashtable contains the intialization info for
     * a particular resource loader. This Hastable
     * will be passed in when initializing the
     * the template loader.
     */
    private void assembleResourceLoaderInitializers()
    {
        if (resourceLoaderInitializersActive)
        {
            return;
        }            
        Vector resourceLoaderNames = 
            rsvc.getConfiguration().getVector(RuntimeConstants.RESOURCE_LOADER);
        for (int i = 0; i < resourceLoaderNames.size(); i++)
        {
            /*
             * The loader id might look something like the following:
             *
             * file.resource.loader
             *
             * The loader id is the prefix used for all properties
             * pertaining to a particular loader.
             */
            String loaderID = 
                resourceLoaderNames.get(i) + ""."" + RuntimeConstants.RESOURCE_LOADER;
            ExtendedProperties loaderConfiguration =
                rsvc.getConfiguration().subset(loaderID);
            /*
             *  we can't really count on ExtendedProperties to give us an empty set
             */
            if ( loaderConfiguration == null)
            {
                rsvc.warn(""ResourceManager : No configuration information for resource loader named '"" 
                          + resourceLoaderNames.get(i) + ""'. Skipping."");
                continue;
            }
            /*
             *  add the loader name token to the initializer if we need it
             *  for reference later. We can't count on the user to fill
             *  in the 'name' field
             */
            loaderConfiguration.setProperty( RESOURCE_LOADER_IDENTIFIER, resourceLoaderNames.get(i));
            /*
             * Add resources to the list of resource loader
             * initializers.
             */
            sourceInitializerList.add(loaderConfiguration);
        }
        resourceLoaderInitializersActive = true;
    }
    /**
     * Gets the named resource.  Returned class type corresponds to specified type
     * (i.e. <code>Template</code> to <code>RESOURCE_TEMPLATE</code>).
     *
     * @param resourceName The name of the resource to retrieve.
     * @param resourceType The type of resource (<code>RESOURCE_TEMPLATE</code>,
     *                     <code>RESOURCE_CONTENT</code>, etc.).
     * @param encoding  The character encoding to use.
     * @return Resource with the template parsed and ready.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if a problem in parse
     */
    public Resource getResource(String resourceName, int resourceType, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        /* 
         * Check to see if the resource was placed in the cache.
         * If it was placed in the cache then we will use
         * the cached version of the resource. If not we
         * will load it.
         */
        Resource resource = globalCache.get(resourceName);
        if( resource != null)
        {
            /*
             *  refresh the resource
             */
            try
            {
                refreshResource( resource, encoding );
            }
            catch( ResourceNotFoundException rnfe )
            {
                /*
                 *  something exceptional happened to that resource
                 *  this could be on purpose, 
                 *  so clear the cache and try again
                 */
                 globalCache.remove( resourceName );
                 return getResource( resourceName, resourceType, encoding );
            }
            catch( ParseErrorException pee )
            {
                rsvc.error(
                    ""ResourceManager.getResource() exception: "" + pee);
                throw pee;
            }
            catch( Exception eee )
            {
                rsvc.error(
                    ""ResourceManager.getResource() exception: "" + eee);
                throw eee;
            }
        }
        else
        {            
            try
            {
                /*
                 *  it's not in the cache, so load it.
                 */
                resource = loadResource( resourceName, resourceType, encoding );
                if (resource.getResourceLoader().isCachingOn())
                {
                    globalCache.put(resourceName, resource);
                }                    
            }
            catch( ResourceNotFoundException rnfe2 )
            {
                rsvc.error(
                    ""ResourceManager : unable to find resource '"" + resourceName + 
                        ""' in any resource loader."");
                throw rnfe2;
            }
            catch( ParseErrorException pee )
            {
                rsvc.error(
                    ""ResourceManager.getResource() parse exception: "" + pee);
                throw pee;
            }
            catch( Exception ee )
            {
                rsvc.error(
                    ""ResourceManager.getResource() exception new: "" + ee);
                throw ee;
            }
        }
        return resource;
    }
    /**
     *  Loads a resource from the current set of resource loaders
     *
     * @param resourceName The name of the resource to retrieve.
     * @param resourceType The type of resource (<code>RESOURCE_TEMPLATE</code>,
     *                     <code>RESOURCE_CONTENT</code>, etc.).
     * @param encoding  The character encoding to use.
     * @return Resource with the template parsed and ready.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if a problem in parse
     */    
    protected Resource loadResource(String resourceName, int resourceType, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        Resource resource = ResourceFactory.getResource(resourceName, resourceType);
        resource.setRuntimeServices( rsvc );
        resource.setName( resourceName );
        resource.setEncoding( encoding );
        /* 
         * Now we have to try to find the appropriate
         * loader for this resource. We have to cycle through
         * the list of available resource loaders and see
         * which one gives us a stream that we can use to
         * make a resource with.
         */
        long howOldItWas = 0;  // Initialize to avoid warnings
        ResourceLoader resourceLoader = null;
        for (int i = 0; i < resourceLoaders.size(); i++)
        {
            resourceLoader = (ResourceLoader) resourceLoaders.get(i);
            resource.setResourceLoader(resourceLoader);
            /*
             *  catch the ResourceNotFound exception
             *  as that is ok in our new multi-loader environment
             */
            try 
            {
                if (resource.process())
                {
                     /*
                      *  FIXME  (gmj)
                      *  moved in here - technically still 
                      *  a problem - but the resource needs to be 
                      *  processed before the loader can figure 
                      *  it out due to to the new 
                      *  multi-path support - will revisit and fix
                      */
                     if ( logWhenFound )
                     {
                         rsvc.info(""ResourceManager : found "" + resourceName + 
                                      "" with loader "" + resourceLoader.getClassName() );
                     }
                     howOldItWas = resourceLoader.getLastModified( resource );
                     break;
                 }
            }
            catch( ResourceNotFoundException rnfe )
            {
                /*
                 *  that's ok - it's possible to fail in
                 *  multi-loader environment
                 */
            }
        }
        /*
         * Return null if we can't find a resource.
         */
        if (resource.getData() == null)
        {
            throw new ResourceNotFoundException(
                ""Unable to find resource '"" + resourceName + ""'"");
        }
        /*
         *  some final cleanup
         */
        resource.setLastModified( howOldItWas );
        resource.setModificationCheckInterval(
            resourceLoader.getModificationCheckInterval());
        resource.touch();
        return resource;            
    }
    /**
     *  Takes an existing resource, and 'refreshes' it.  This
     *  generally means that the source of the resource is checked
     *  for changes according to some cache/check algorithm
     *  and if the resource changed, then the resource data is
     *  reloaded and re-parsed.
     *
     *  @param resource resource to refresh
     *
     * @throws ResourceNotFoundException if template not found
     *          from current source for this Resource
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if a problem in parse
     */
    protected void refreshResource( Resource resource, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        /* 
         * The resource knows whether it needs to be checked
         * or not, and the resource's loader can check to
         * see if the source has been modified. If both
         * these conditions are true then we must reload
         * the input stream and parse it to make a new
         * AST for the resource.
         */
        if ( resource.requiresChecking() )
        {
            /*
             *  touch() the resource to reset the counters
             */
            resource.touch();
            if(  resource.isSourceModified() )
            {
                /*
                 *  now check encoding info.  It's possible that the newly declared
                 *  encoding is different than the encoding already in the resource
                 *  this strikes me as bad...
                 */
                if (!resource.getEncoding().equals( encoding ) )
                {
                    rsvc.error(""Declared encoding for template '"" + resource.getName() 
                                  + ""' is different on reload.  Old = '"" + resource.getEncoding()
                                  + ""'  New = '"" + encoding );
                    resource.setEncoding( encoding );
                }
                /*
                 *  read how old the resource is _before_
                 *  processing (=>reading) it
                 */
                long howOldItWas = resource.getResourceLoader().getLastModified( resource );
                /*
                 *  read in the fresh stream and parse
                 */
                resource.process();
                /*
                 *  now set the modification info and reset
                 *  the modification check counters
                 */
                resource.setLastModified( howOldItWas );
            }
        }
    }
     /**
     * Gets the named resource.  Returned class type corresponds to specified type
     * (i.e. <code>Template</code> to <code>RESOURCE_TEMPLATE</code>).
     *
     * @param resourceName The name of the resource to retrieve.
     * @param resourceType The type of resource (<code>RESOURCE_TEMPLATE</code>,
     *                     <code>RESOURCE_CONTENT</code>, etc.).
     * @return Resource with the template parsed and ready.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if a problem in parse
     *
     *  @deprecated Use
     *  {@link #getResource(String resourceName, int resourceType, 
     *          String encoding )}
     */
    public Resource getResource(String resourceName, int resourceType  )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {  
        return getResource( resourceName, resourceType, RuntimeConstants.ENCODING_DEFAULT);
    }
    /**
     *  Determines is a template exists, and returns name of the loader that 
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public String getLoaderNameForResource(String resourceName )
    {
        ResourceLoader resourceLoader = null;
        /*
         *  loop through our loaders...
         */
        for (int i = 0; i < resourceLoaders.size(); i++)
        { 
            resourceLoader = (ResourceLoader) resourceLoaders.get(i);
            InputStream is = null;
            /*
             *  if we find one that can provide the resource,
             *  return the name of the loaders's Class
             */
            try
            {
                is=resourceLoader.getResourceStream( resourceName );
                if( is != null)
                {
                    return resourceLoader.getClass().toString();
                }
            }
            catch( ResourceNotFoundException e)
            {
                /*
                 * this isn't a problem.  keep going
                 */
            }
            finally
            {
                /*
                 *  if we did find one, clean up because we were 
                 *  returned an open stream
                 */
                if (is != null)
                {
                    try
                    {
                        is.close();
                    }
                    catch( IOException ioe)
                    {
                    }
                }
            }
        }
        return null;
    }
}
"
org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.commons.collections.ExtendedProperties;
/**
 *  ClasspathResourceLoader is a simple loader that will load
 *  templates from the classpath.
 *  <br>
 *  <br>
 *  Will load templates from  from multiple instances of 
 *  and arbitrary combinations of :
 *  <ul>
 *  <li> jar files
 *  <li> zip files
 *  <li> template directories (any directory containing templates)
 *  </ul>
 *  This is a configuration-free loader, in that there are no
 *  parameters to be specified in the configuration properties,
 *  other than specifying this as the loader to use.  For example
 *  the following is all that the loader needs to be functional :
 *  <br>
 *  <br>
 *  resource.loader = class
 *  class.resource.loader.class =
 *    org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader
 *  <br>
 *  <br>
 *  To use, put your template directories, jars
 *  and zip files into the classpath or other mechanisms that make
 *  resources accessable to the classloader.
 *  <br>
 *  <br>
 *  This makes deployment trivial for web applications running in
 *  any Servlet 2.2 compliant servlet runner, such as Tomcat 3.2 
 *  and others.
 *  <br>
 *  <br>
 *  For a Servlet Spec v2.2 servlet runner, 
 *  just drop the jars of template files into the WEB-INF/lib
 *  directory of your webapp, and you won't have to worry about setting
 *  template paths or altering them with the root of the webapp
 *  before initializing.
 *  <br>
 *  <br>
 *  I have also tried it with a WAR deployment, and that seemed to
 *  work just fine.
 *  
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ClasspathResourceLoader.java,v 1.8.4.1 2004/03/03 23:23:02 geirm Exp $
 */
public class ClasspathResourceLoader extends ResourceLoader
{
    /**
     *  This is abstract in the base class, so we need it
     */
    public void init( ExtendedProperties configuration)
    {
        rsvc.info(""ClasspathResourceLoader : initialization starting."");
        rsvc.info(""ClasspathResourceLoader : initialization complete."");
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param name name of template to get
     * @return InputStream containing the template
     * @throws ResourceNotFoundException if template not found
     *         in  classpath.
     */
    public synchronized InputStream getResourceStream( String name )
        throws ResourceNotFoundException
    {
        InputStream result = null;
        if (name == null || name.length() == 0)
        {
            throw new ResourceNotFoundException (""No template name provided"");
        }
        try 
        {
            ClassLoader classLoader = this.getClass().getClassLoader();
            result= classLoader.getResourceAsStream( name );
        }
        catch( Exception fnfe )
        {
            /*
             *  log and convert to a general Velocity ResourceNotFoundException
             */
            throw new ResourceNotFoundException( fnfe.getMessage() );
        }
        return result;
    }
    /**
     * Defaults to return false.
     */
    public boolean isSourceModified(Resource resource)
    {
        return false;
    }
    /**
     * Defaults to return 0
     */
    public long getLastModified(Resource resource)
    {
        return 0;
    }
}
"
org.apache.velocity.runtime.resource.loader.DataSourceResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Copyright 2001-2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.util.Hashtable;
import javax.sql.DataSource;
import javax.naming.InitialContext;
import org.apache.velocity.runtime.Runtime;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.commons.collections.ExtendedProperties;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.SQLException;
/**
 * This is a simple template file loader that loads templates
 * from a DataSource instead of plain files.
 *
 * It can be configured with a datasource name, a table name,
 * id column (name), content column (the template body) and a
 * datetime column (for last modification info).
 * <br>
 * <br>
 * Example configuration snippet for velocity.properties:
 * <br>
 * <br>
 * resource.loader = file, ds <br>
 * <br>
 * ds.resource.loader.public.name = DataSource <br>
 * ds.resource.loader.description = Velocity DataSource Resource Loader <br>
 * ds.resource.loader.class = org.apache.velocity.runtime.resource.loader.DataSourceResourceLoader <br>
 * ds.resource.loader.resource.datasource = java:comp/env/jdbc/Velocity <br>
 * ds.resource.loader.resource.table = tb_velocity_template <br>
 * ds.resource.loader.resource.keycolumn = id_template <br>
 * ds.resource.loader.resource.templatecolumn = template_definition <br>
 * ds.resource.loader.resource.timestampcolumn = template_timestamp <br>
 * ds.resource.loader.cache = false <br>
 * ds.resource.loader.modificationCheckInterval = 60 <br>
 * <br>
 * Example WEB-INF/web.xml: <br>
 * <br>
 *	<resource-ref> <br>
 *	 <description>Velocity template DataSource</description> <br>
 *	 <res-ref-name>jdbc/Velocity</res-ref-name> <br>
 *	 <res-type>javax.sql.DataSource</res-type> <br>
 *	 <res-auth>Container</res-auth> <br>
 *	</resource-ref> <br>
 * <br>
 *  <br>
 * and Tomcat 4 server.xml file: <br>
 *  [...] <br>
 *  <Context path=""/exampleVelocity"" docBase=""exampleVelocity"" debug=""0""> <br>
 *  [...] <br>
 *   <ResourceParams name=""jdbc/Velocity""> <br>
 *    <parameter> <br>
 *      <name>driverClassName</name> <br>
 *      <value>org.hsql.jdbcDriver</value> <br>
 *    </parameter> <br>
 *    <parameter> <br>
 *     <name>driverName</name> <br>
 *     <value>jdbc:HypersonicSQL:database</value> <br>
 *    </parameter> <br>
 *    <parameter> <br>
 *     <name>user</name> <br>
 *     <value>database_username</value> <br>
 *    </parameter> <br>
 *    <parameter> <br>
 *     <name>password</name> <br>
 *     <value>database_password</value> <br>
 *    </parameter> <br>
 *   </ResourceParams> <br>
 *  [...] <br>
 *  </Context> <br>
 *  [...] <br>
 * <br>
 *  Example sql script:<br>
 *  CREATE TABLE tb_velocity_template ( <br>
 *	id_template varchar (40) NOT NULL , <br>
 *	template_definition text (16) NOT NULL , <br>
 *	template_timestamp datetime NOT NULL  <br>
 *	) <br>
 *
 * @author <a href=""mailto:david.kinnvall@alertir.com"">David Kinnvall</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author <a href=""mailto:lachiewicz@plusnet.pl"">Sylwester Lachiewicz</a>
 * @version $Id: DataSourceResourceLoader.java,v 1.8.8.1 2004/03/03 23:23:02 geirm Exp $
 */
public class DataSourceResourceLoader extends ResourceLoader
{
     private String dataSourceName;
     private String tableName;
     private String keyColumn;
     private String templateColumn;
     private String timestampColumn;
     private InitialContext ctx;
     private DataSource dataSource;
     public void init( ExtendedProperties configuration)
     {
         dataSourceName  = configuration.getString(""resource.datasource"");
         tableName       = configuration.getString(""resource.table"");
         keyColumn       = configuration.getString(""resource.keycolumn"");
         templateColumn  = configuration.getString(""resource.templatecolumn"");
         timestampColumn = configuration.getString(""resource.timestampcolumn"");
         Runtime.info(""Resources Loaded From: "" + dataSourceName + ""/"" + tableName);
         Runtime.info( ""Resource Loader using columns: "" + keyColumn + "", ""
                       + templateColumn + "" and "" + timestampColumn);
         Runtime.info(""Resource Loader Initalized."");
     }
     public boolean isSourceModified(Resource resource)
     {
         return (resource.getLastModified() !=
                 readLastModified(resource, ""checking timestamp""));
     }
     public long getLastModified(Resource resource)
     {
         return readLastModified(resource, ""getting timestamp"");
     }
     /**
      * Get an InputStream so that the Runtime can build a
      * template with it.
      *
      *  @param name name of template
      *  @return InputStream containing template
      */
     public synchronized InputStream getResourceStream( String name )
         throws ResourceNotFoundException
     {
         if (name == null || name.length() == 0)
         {
             throw new ResourceNotFoundException (""Need to specify a template name!"");
         }
         try
         {
             Connection conn = openDbConnection();
             try
             {
                 ResultSet rs = readData(conn, templateColumn, name);
                 try
                 {
                     if (rs.next())
                     {
                         return new
                             BufferedInputStream(rs.getAsciiStream(templateColumn));
                     }
                     else
                     {
                         String msg = ""DataSourceResourceLoader Error: cannot find resource ""
                             + name;
                         Runtime.error(msg );
                         throw new ResourceNotFoundException (msg);
                     }
                 }
                 finally
                 {
                     rs.close();
                 }
             }
             finally
             {
                 closeDbConnection(conn);
             }
         }
         catch(Exception e)
         {
             String msg =  ""DataSourceResourceLoader Error: database problem trying to load resource ""
                 + name + "": "" + e.toString();
             Runtime.error( msg );
             throw new ResourceNotFoundException (msg);
         }
     }
    /**
     *  Fetches the last modification time of the resource
     *
     *  @param resource Resource object we are finding timestamp of
     *  @param i_operation string for logging, indicating caller's intention
     *
     *  @return timestamp as long
     */
     private long readLastModified(Resource resource, String i_operation)
     {
         /*
          *  get the template name from the resource
          */
         String name = resource.getName();
         try
         {
             Connection conn = openDbConnection();
             try
             {
                 ResultSet rs = readData(conn, timestampColumn, name);
                 try
                 {
                     if (rs.next())
                     {
	                     return rs.getTimestamp(timestampColumn).getTime();
                     }
                     else
                     {
                         Runtime.error(""DataSourceResourceLoader Error: while ""
                                       + i_operation
                                       + "" could not find resource "" + name);
                     }
                 }
                 finally
                 {
                     rs.close();
                 }
             }
             finally
             {
                 closeDbConnection(conn);
             }
         }
         catch(Exception e)
         {
             Runtime.error( ""DataSourceResourceLoader Error: error while ""
                 + i_operation + "" when trying to load resource ""
                 + name + "": "" + e.toString() );
         }
         return 0;
     }
    /**
     *   gets connection to the datasource specified through the configuration
     *  parameters.
     *
     *  @return connection
     */
     private Connection openDbConnection()
         throws Exception
    {
         if(ctx == null)
         {
             ctx = new InitialContext();
         }
         if(dataSource == null)
         {
             dataSource = (DataSource)ctx.lookup(dataSourceName);
         }
         return dataSource.getConnection();
     }
    /**
     *  Closes connection to the datasource
     */
     private void closeDbConnection(Connection conn)
     {
         try
         {
             conn.close();
         }
         catch (Exception e)
         {
             Runtime.info(
                 ""DataSourceResourceLoader Quirk: problem when closing connection: ""
                 + e.toString());
         }
     }
    /**
     *  Reads the data from the datasource.  It simply does the following query :
     *  <br>
     *   SELECT <i>columnNames</i> FROM <i>tableName</i> WHERE <i>keyColumn</i>
     *      = '<i>templateName</i>'
     *  <br>
     *  where <i>keyColumn</i> is a class member set in init()
     *
     *  @param conn connection to datasource
     *  @param columnNames columns to fetch from datasource
     *  @param templateName name of template to fetch
     *  @return result set from query
     */
     private ResultSet readData(Connection conn, String columnNames, String templateName)
         throws SQLException
     {
         Statement stmt = conn.createStatement();
         String sql = ""SELECT "" + columnNames
                      + "" FROM "" + tableName
                      + "" WHERE "" + keyColumn + "" = '"" + templateName + ""'"";
         return stmt.executeQuery(sql);
     }
}
"
org.apache.velocity.runtime.resource.loader.FileResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.BufferedInputStream;
import java.io.FileNotFoundException;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * A loader for templates stored on the file system.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: FileResourceLoader.java,v 1.19.4.1 2004/03/03 23:23:02 geirm Exp $
 */
public class FileResourceLoader extends ResourceLoader
{
    /**
     * The paths to search for templates.
     */
    private Vector paths = null;
    /**
     * Used to map the path that a template was found on
     * so that we can properly check the modification
     * times of the files.
     */
    private Hashtable templatePaths = new Hashtable();
    public void init( ExtendedProperties configuration)
    {
        rsvc.info(""FileResourceLoader : initialization starting."");
        paths = configuration.getVector(""path"");
        /*
         *  lets tell people what paths we will be using
         */
        int sz = paths.size();
        for( int i=0; i < sz; i++)
        {
            rsvc.info(""FileResourceLoader : adding path '"" + (String) paths.get(i) + ""'"");
        }
        rsvc.info(""FileResourceLoader : initialization complete."");
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param name name of template to get
     * @return InputStream containing the template
     * @throws ResourceNotFoundException if template not found
     *         in the file template path.
     */
    public synchronized InputStream getResourceStream(String templateName)
        throws ResourceNotFoundException
    {
        /*
         * Make sure we have a valid templateName.
         */
        if (templateName == null || templateName.length() == 0)
        {
            /*
             * If we don't get a properly formed templateName then
             * there's not much we can do. So we'll forget about
             * trying to search any more paths for the template.
             */
            throw new ResourceNotFoundException(
                ""Need to specify a file name or file path!"");
        }
        String template = StringUtils.normalizePath(templateName);
        if ( template == null || template.length() == 0 )
        {
            String msg = ""File resource error : argument "" + template + 
                "" contains .. and may be trying to access "" + 
                ""content outside of template root.  Rejected."";
            rsvc.error( ""FileResourceLoader : "" + msg );
            throw new ResourceNotFoundException ( msg );
        }
        /*
         *  if a / leads off, then just nip that :)
         */
        if (template.startsWith(""/""))
        {
            template = template.substring(1);
        }
        int size = paths.size();
        for (int i = 0; i < size; i++)
        {
            String path = (String) paths.get(i);
            InputStream inputStream = findTemplate(path, template);
            if (inputStream != null)
            {
                /*
                 * Store the path that this template came
                 * from so that we can check its modification
                 * time.
                 */
                templatePaths.put(templateName, path);
                return inputStream;
            }                
        }
        /*
         * We have now searched all the paths for
         * templates and we didn't find anything so
         * throw an exception.
         */
         String msg = ""FileResourceLoader Error: cannot find resource "" +
          template;
         throw new ResourceNotFoundException( msg );
    }
    /**
     * Try to find a template given a normalized path.
     * 
     * @param String a normalized path
     * @return InputStream input stream that will be parsed
     *
     */
    private InputStream findTemplate(String path, String template)
    {
        try 
        {
            File file = new File( path, template );   
            if ( file.canRead() )
            {
                return new BufferedInputStream(
                    new FileInputStream(file.getAbsolutePath()));
            }
            else
            {                
                return null;
            }                
        }
        catch( FileNotFoundException fnfe )
        {
            /*
             *  log and convert to a general Velocity ResourceNotFoundException
             */
            return null;
        }
    }
    /**
     * How to keep track of all the modified times
     * across the paths.  Note that a file might have
     * appeared in a directory which is earlier in the
     * path; so we should search the path and see if
     * the file we find that way is the same as the one
     * that we have cached.
     */
    public boolean isSourceModified(Resource resource)
    {
        /*
         * we assume that the file needs to be reloaded; 
         * if we find the original file and it's unchanged,
         * then we'll flip this.
         */
        boolean modified = true;
        String fileName = resource.getName();
        String path = (String) templatePaths.get(fileName);
        File currentFile = null;
        for (int i = 0; currentFile == null && i < paths.size(); i++)
        {
            String testPath = (String) paths.get(i);
            File testFile = new File(testPath, fileName);
            if (testFile.canRead())
            {
                currentFile = testFile;
            }
        }
        File file = new File(path, fileName);
        if (currentFile == null || !file.exists())
        {
            /*
             * noop: if the file is missing now (either the cached
             * file is gone, or the file can no longer be found)
             * then we leave modified alone (it's set to true); a 
             * reload attempt will be done, which will either use
             * a new template or fail with an appropriate message
             * about how the file couldn't be found.
             */
        }
        else if (currentFile.equals(file) && file.canRead())
        {
            /*
             * if only if currentFile is the same as file and
             * file.lastModified() is the same as
             * resource.getLastModified(), then we should use the
             * cached version.
             */
            modified = (file.lastModified() != resource.getLastModified());
        }
        /*
         * rsvc.debug(""isSourceModified for "" + fileName + "": "" + modified);
         */
        return modified;
    }
    public long getLastModified(Resource resource)
    {
        String path = (String) templatePaths.get(resource.getName());
        File file = new File(path, resource.getName());
        if (file.canRead())
        {
            return file.lastModified();
        }            
        else
        {
            return 0;
        }            
    }
}
"
org.apache.velocity.runtime.resource.loader.JarHolder,"package org.apache.velocity.runtime.resource.loader;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import java.net.JarURLConnection;
import java.net.URL;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.Hashtable;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.exception.ResourceNotFoundException;
/**
 * A small wrapper around a Jar
 *
 * @author <a href=""mailto:daveb@miceda-data.com"">Dave Bryson</a>
 * @version $Id: JarHolder.java,v 1.8.4.1 2004/03/03 23:23:02 geirm Exp $
 */
public class JarHolder
{
    private String urlpath = null;
    private JarFile theJar = null;
    private JarURLConnection conn = null;
    private RuntimeServices rsvc = null;
    public JarHolder( RuntimeServices rs, String urlpath )
    {
        rsvc = rs;
        this.urlpath=urlpath;
        init();
        rsvc.info(""  JarHolder : initialized JAR: "" + urlpath );
    }
    public void init()
    {
        try
        {
            rsvc.info(""  JarHolder : attempting to connect to ""+ urlpath);
            URL url = new URL( urlpath );
            conn = (JarURLConnection) url.openConnection();
            conn.setAllowUserInteraction(false);
            conn.setDoInput(true);
            conn.setDoOutput(false);
            conn.connect();
            theJar = conn.getJarFile();
        } 
        catch (Exception e)
        {
            rsvc.error(""  JarHolder : error establishing connection to JAR ""+ e);
        }
    }
    public void close() 
    {
        try
        {
            theJar.close();
        }
        catch ( Exception e )
        {
            rsvc.error(""  JarHolder : error Closing JAR the file "" +  e);
        }
        theJar = null;
        conn = null;
        rsvc.info(""  JarHolder : JAR file closed"");
    }
    public InputStream getResource( String theentry )
     throws ResourceNotFoundException {
        InputStream data = null;
        try 
        {
            JarEntry entry = theJar.getJarEntry( theentry );
            if ( entry != null )
            {                
                data =  theJar.getInputStream( entry );
            }
        }
        catch( Exception fnfe )
        {
            rsvc.error(""  JarHolder : getResource() error : exception : "" + fnfe );
            throw new ResourceNotFoundException( fnfe.getMessage() );
        }
        return data;
    }
    public Hashtable getEntries()
    {
        Hashtable allEntries = new Hashtable(559);
        Enumeration all  = theJar.entries();
        while ( all.hasMoreElements() )
        {
            JarEntry je = (JarEntry)all.nextElement();
            // We don't map plain directory entries
            if ( !je.isDirectory() )
            {
                allEntries.put( je.getName(), this.urlpath );   
            }
        }
        return allEntries;
    }
    public String getUrlPath()
    {
        return urlpath;
    }
}
"
org.apache.velocity.runtime.resource.loader.JarResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Vector;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * <p>
 * ResourceLoader to load templates from multiple Jar files.
 * </p>
 * <p>
 * The configuration of the JarResourceLoader is straightforward -
 * You simply add the JarResourceLoader to the configuration via
 * </p>
 * <p><pre>
 *    resource.loader = jar
 *    jar.resource.loader.class = org.apache.velocity.runtime.resource.loader.JarResourceLoader
 *    jar.resource.loader.path = list of JAR &lt;URL&gt;s
 * </pre></p>
 *
 * <p> So for example, if you had a jar file on your local filesystem, you could simply do
 *    <pre>
 *    jar.resource.loader.path = jar:file:/opt/myfiles/jar1.jar
 *    </pre>
 * </p>
 * <p> Note that jar specification for the <code>.path</code> configuration property
 * conforms to the same rules for the java.net.JarUrlConnection class.
 * </p>
 *
 * <p> For a working example, see the unit test case, 
 *  org.apache.velocity.test.MultiLoaderTestCase class
 * </p>
 * 
 * @author <a href=""mailto:daveb@miceda-data.com"">Dave Bryson</a>
 * @version $Id: JarResourceLoader.java,v 1.16.4.1 2004/03/03 23:23:02 geirm Exp $
 */
public class JarResourceLoader extends ResourceLoader
{
    /**
     * Maps entries to the parent JAR File
     * Key = the entry *excluding* plain directories
     * Value = the JAR URL
     */
    private Hashtable entryDirectory = new Hashtable(559);
    /**
     * Maps JAR URLs to the actual JAR
     * Key = the JAR URL
     * Value = the JAR
     */
    private Hashtable jarfiles = new Hashtable(89);
    /**
     * Called by Velocity to initialize the loader
     */
    public void init( ExtendedProperties configuration)
    {
        rsvc.info(""JarResourceLoader : initialization starting."");
        Vector paths = configuration.getVector(""path"");
        /*
         *  support the old version but deprecate with a log message
         */
        if( paths == null || paths.size() == 0)
        {
            paths = configuration.getVector(""resource.path"");
            if (paths != null && paths.size() > 0)
            {
                rsvc.warn(""JarResourceLoader : you are using a deprecated configuration""
                             + "" property for the JarResourceLoader -> '<name>.resource.loader.resource.path'.""
                             + "" Please change to the conventional '<name>.resource.loader.path'."");
            }
        }
        rsvc.info(""JarResourceLoader # of paths : "" + paths.size() );
        for ( int i=0; i<paths.size(); i++ )
        {
            loadJar( (String)paths.get(i) );
        }
        rsvc.info(""JarResourceLoader : initialization complete."");
    }
    private void loadJar( String path )
    {
        rsvc.info(""JarResourceLoader : trying to load: "" + path);
        // Check path information
        if ( path == null )
        {
            rsvc.error(""JarResourceLoader : can not load JAR - JAR path is null"");
        }
        if ( !path.startsWith(""jar:"") )
        {
            rsvc.error(""JarResourceLoader : JAR path must start with jar: -> "" +
                ""see java.net.JarURLConnection for information"");
        }
        if ( !path.endsWith(""!/"") )
        {
            path += ""!/"";
        }
        // Close the jar if it's already open
        // this is useful for a reload
        closeJar( path );
        // Create a new JarHolder
        JarHolder temp = new JarHolder( rsvc,  path );
        // Add it's entries to the entryCollection
        addEntries( temp.getEntries() );
        // Add it to the Jar table
        jarfiles.put( temp.getUrlPath(), temp );
    }
    /**
     * Closes a Jar file and set its URLConnection 
     * to null.
     */
    private void closeJar( String path )
    {
        if ( jarfiles.containsKey(path) )
        {
            JarHolder theJar = (JarHolder)jarfiles.get(path);
            theJar.close();
        }
    }
    /**
     * Copy all the entries into the entryDirectory
     * It will overwrite any duplicate keys.
     */
    private synchronized void addEntries( Hashtable entries )
    {
        entryDirectory.putAll( entries );
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param name name of template to get
     * @return InputStream containing the template
     * @throws ResourceNotFoundException if template not found
     *         in the file template path.
     */
    public synchronized InputStream getResourceStream( String source )
        throws ResourceNotFoundException
    {
        InputStream results = null;
        if ( source == null || source.length() == 0)
        {
            throw new ResourceNotFoundException(""Need to have a resource!"");
        }
        String normalizedPath = StringUtils.normalizePath( source );
        if ( normalizedPath == null || normalizedPath.length() == 0 )
        {
            String msg = ""JAR resource error : argument "" + normalizedPath + 
                "" contains .. and may be trying to access "" + 
                ""content outside of template root.  Rejected."";
            rsvc.error( ""JarResourceLoader : "" + msg );
            throw new ResourceNotFoundException ( msg );
        }
        /*
         *  if a / leads off, then just nip that :)
         */
        if ( normalizedPath.startsWith(""/"") )
        {
            normalizedPath = normalizedPath.substring(1);
        }
        if ( entryDirectory.containsKey( normalizedPath ) )
        {
            String jarurl  = (String)entryDirectory.get( normalizedPath );
            if ( jarfiles.containsKey( jarurl ) )
            {
                JarHolder holder = (JarHolder)jarfiles.get( jarurl );
                results =  holder.getResource( normalizedPath );
                return results;
            }
        }
        throw new ResourceNotFoundException( ""JarResourceLoader Error: cannot find resource "" +
          source );
    }
    // TO DO BELOW 
    // SHOULD BE DELEGATED TO THE JARHOLDER
    public boolean isSourceModified(Resource resource)
    {
        return true;
    }
    public long getLastModified(Resource resource)
    {
        return 0;
    }
}
"
org.apache.velocity.runtime.resource.loader.ResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * This is abstract class the all text resource loaders should
 * extend.
 * 
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceLoader.java,v 1.14.4.1 2004/03/03 23:23:02 geirm Exp $
 */
public abstract class ResourceLoader
{
    /** 
     * Does this loader want templates produced with it
     * cached in the Runtime.
     */
     protected boolean isCachingOn = false;
    /**
     * This property will be passed on to the templates
     * that are created with this loader.
     */
    protected long modificationCheckInterval = 2;
    /**
     * Class name for this loader, for logging/debuggin
     * purposes.
     */
    protected String className = null;
    protected RuntimeServices rsvc = null;
    /**
     * This initialization is used by all resource
     * loaders and must be called to set up common
     * properties shared by all resource loaders
     */
    public void commonInit( RuntimeServices rs, ExtendedProperties configuration)
    {
        this.rsvc = rs;
        /*
         *  these two properties are not required for all loaders.
         *  For example, for ClasspathLoader, what would cache mean? 
         *  so adding default values which I think are the safest
         *
         *  don't cache, and modCheckInterval irrelevant...
         */
        isCachingOn = configuration.getBoolean(""cache"", false);
        modificationCheckInterval = configuration.getLong(""modificationCheckInterval"", 0);
        /*
         * this is a must!
         */
        className = configuration.getString(""class"");
    }
    /** 
     * Initialize the template loader with a
     * a resources class.
     */
    public abstract void init( ExtendedProperties configuration);
    /** 
     * Get the InputStream that the Runtime will parse
     * to create a template.
     */
    public abstract InputStream getResourceStream( String source ) 
        throws ResourceNotFoundException;
    /**
     * Given a template, check to see if the source of InputStream
     * has been modified.
     */
    public abstract boolean isSourceModified(Resource resource);
    /**
     * Get the last modified time of the InputStream source
     * that was used to create the template. We need the template
     * here because we have to extract the name of the template
     * in order to locate the InputStream source.
     */
    public abstract long getLastModified(Resource resource);
    /**
     * Return the class name of this resource Loader
     */
    public String getClassName()
    {
        return className;
    }
    /**
     * Set the caching state. If true, then this loader
     * would like the Runtime to cache templates that
     * have been created with InputStreams provided
     * by this loader.
     */
    public void setCachingOn(boolean value)
    {
        isCachingOn = value;
    }
    /**
     * The Runtime uses this to find out whether this
     * template loader wants the Runtime to cache
     * templates created with InputStreams provided
     * by this loader.
     */
    public boolean isCachingOn()
    {
        return isCachingOn;
    }
    /**
     * Set the interval at which the InputStream source
     * should be checked for modifications.
     */
    public void setModificationCheckInterval(long modificationCheckInterval)
    {
        this.modificationCheckInterval = modificationCheckInterval;
    }
    /**
     * Get the interval at which the InputStream source
     * should be checked for modifications.
     */
    public long getModificationCheckInterval()
    {
        return modificationCheckInterval;
    }
}
"
org.apache.velocity.runtime.resource.loader.ResourceLoaderFactory,"package org.apache.velocity.runtime.resource.loader;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.StringUtils;
/**
 * Factory to grab a template loader.
 * 
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: ResourceLoaderFactory.java,v 1.6.8.1 2004/03/03 23:23:02 geirm Exp $
 */
public class ResourceLoaderFactory
{
    /**
     * Gets the loader specified in the configuration file.
     * @return TemplateLoader
     */
    public static ResourceLoader getLoader(RuntimeServices rs, String loaderClassName)
     throws Exception
    {
        ResourceLoader loader = null;
        try
        {
            loader = ((ResourceLoader)Class.forName(loaderClassName)
                .newInstance());
            rs.info(""Resource Loader Instantiated: "" + 
                loader.getClass().getName());
            return loader;
        }
        catch( Exception e)
        {
            rs.error(""Problem instantiating the template loader.\n"" +
                          ""Look at your properties file and make sure the\n"" +
                          ""name of the template loader is correct. Here is the\n"" +
                          ""error: "" + StringUtils.stackTrace(e));
            throw new Exception(""Problem initializing template loader: "" + loaderClassName + 
            ""\nError is: "" + StringUtils.stackTrace(e));
        }
    }
}
"
org.apache.velocity.runtime.visitor.BaseVisitor,"package org.apache.velocity.runtime.visitor;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.node.*;
/**
 * This is the base class for all visitors.
 * For each AST node, this class will provide
 * a bare-bones method for traversal.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: BaseVisitor.java,v 1.12.4.1 2004/03/03 23:23:02 geirm Exp $
 */
public abstract class BaseVisitor implements ParserVisitor
{
    /** Context used during traversal */
    protected InternalContextAdapter context;
    /** Writer used as the output sink */
    protected Writer writer;
    public void setWriter( Writer writer )
    {
        this.writer = writer;
    }        
    public void setContext( InternalContextAdapter context)
    {
        this.context = context;
    }
    public Object visit(SimpleNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTprocess node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTExpression node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTAssignment node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTOrNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTAndNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTEQNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTNENode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTLTNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTGTNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTLENode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTGENode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTAddNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTSubtractNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTMulNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTDivNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTModNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTNotNode node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTNumberLiteral node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTStringLiteral node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTIdentifier node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTMethod node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTReference node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTTrue node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTFalse node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTBlock node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTText node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTIfStatement node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTElseStatement node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTElseIfStatement node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTComment node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTObjectArray node, Object data)
    { 
        data = node.childrenAccept(this, data); 
        return data; 
    }
    public Object visit(ASTWord node, Object data)
    { 
        data = node.childrenAccept(this, data);   
        return data;
    }
    public Object visit(ASTSetDirective node, Object data)
    { 
        data = node.childrenAccept(this, data);   
        return data;
    }
    public Object visit(ASTDirective node, Object data)
    { 
        data = node.childrenAccept(this, data);   
        return data;
    }
}
"
org.apache.velocity.runtime.visitor.NodeViewMode,"package org.apache.velocity.runtime.visitor;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.runtime.parser.node.*;
/**
 * This class is simply a visitor implementation
 * that traverses the AST, produced by the Velocity
 * parsing process, and creates a visual structure
 * of the AST. This is primarily used for
 * debugging, but it useful for documentation
 * as well.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: NodeViewMode.java,v 1.6.4.1 2004/03/03 23:23:03 geirm Exp $
 */
public class NodeViewMode extends BaseVisitor
{
    private int indent = 0;
    private boolean showTokens = true;
    /** Indent child nodes to help visually identify
      *  the structure of the AST.
      */
    private String indentString()
    {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < indent; ++i)
        {
            sb.append(""  "");
        }
        return sb.toString();
    }
    /**
      * Display the type of nodes and optionally the
      * first token.
      */
    private Object showNode(Node node, Object data)
    {
        String tokens = """";
        String special = """";
        Token t;
        if (showTokens)
        {
            t = node.getFirstToken();
            if (t.specialToken != null && ! t.specialToken.image.startsWith(""##""))
                special = t.specialToken.image;
            tokens = "" -> "" + special + t.image;
        }            
        System.out.println(indentString() + node + tokens);
        ++indent;
        data = node.childrenAccept(this, data);
        --indent;
        return data;
    }
    /** Display a SimpleNode */
    public Object visit(SimpleNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTprocess node */
    public Object visit(ASTprocess node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTExpression node */
    public Object visit(ASTExpression node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTAssignment node ( = ) */
    public Object visit(ASTAssignment node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTOrNode ( || ) */
    public Object visit(ASTOrNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTAndNode ( && ) */
    public Object visit(ASTAndNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTEQNode ( == ) */
    public Object visit(ASTEQNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTNENode ( != ) */
    public Object visit(ASTNENode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTLTNode ( < ) */
    public Object visit(ASTLTNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTGTNode ( > ) */
    public Object visit(ASTGTNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTLENode ( <= ) */
    public Object visit(ASTLENode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTGENode ( >= ) */
    public Object visit(ASTGENode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTAddNode ( + ) */
    public Object visit(ASTAddNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTSubtractNode ( - ) */
    public Object visit(ASTSubtractNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTMulNode ( * ) */
    public Object visit(ASTMulNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTDivNode ( / ) */
    public Object visit(ASTDivNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTModNode ( % ) */
    public Object visit(ASTModNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTNotNode ( ! ) */
    public Object visit(ASTNotNode node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTNumberLiteral node  */
    public Object visit(ASTNumberLiteral node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTStringLiteral node */
    public Object visit(ASTStringLiteral node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTIdentifier node */
    public Object visit(ASTIdentifier node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTMethod node */
    public Object visit(ASTMethod node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTReference node */
    public Object visit(ASTReference node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTTrue node */
    public Object visit(ASTTrue node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTFalse node */
    public Object visit(ASTFalse node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTBlock node */
    public Object visit(ASTBlock node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTText node */
    public Object visit(ASTText node, Object data)
    { 
        return showNode(node,data); 
    }
    /** Display an ASTIfStatement node */
    public Object visit(ASTIfStatement node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTElseStatement node */
    public Object visit(ASTElseStatement node, Object data)
    { 
        return showNode(node,data);
    }
    /** Display an ASTElseIfStatement node */
    public Object visit(ASTElseIfStatement node, Object data)
    { 
        return showNode(node,data);
    }
    public Object visit(ASTObjectArray node, Object data)
    { 
        return showNode(node,data);
    }
    public Object visit(ASTDirective node, Object data)
    { 
        return showNode(node,data);
    }
    public Object visit(ASTWord node, Object data)
    { 
        return showNode(node,data);
    }
    public Object visit(ASTSetDirective node, Object data)
    { 
        return showNode(node,data);
    }
}
"
org.apache.velocity.runtime.visitor.VMReferenceMungeVisitor,"package org.apache.velocity.runtime.visitor;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Map;
import org.apache.velocity.runtime.parser.node.ASTReference;
/**
 *  This class is a visitor used by the VM proxy to change the 
 *  literal representation of a reference in a VM.  The reason is
 *  to preserve the 'render literal if null' behavior w/o making
 *  the VMProxy stuff more complicated than it is already.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VMReferenceMungeVisitor.java,v 1.2.4.1 2004/03/03 23:23:03 geirm Exp $
 */ 
public class VMReferenceMungeVisitor extends BaseVisitor
{
    /**
     *  Map containing VM arg to instance-use reference
     *  Passed in with CTOR
     */
    private Map argmap = null;
    /**
     *  CTOR - takes a map of args to reference
     */
    public VMReferenceMungeVisitor( Map map )
    {
        argmap = map;
    }
    /**
     *  Visitor method - if the literal is right, will
     *  set the literal in the ASTReference node
     *
     *  @param node ASTReference to work on
     *  @param data Object to pass down from caller
     */
    public Object visit( ASTReference node, Object data)
    {
        /*
         *  see if there is an override value for this
         *  reference
         */
        String override = (String) argmap.get( node.literal().substring(1) );
        /*
         *  if so, set in the node
         */
        if( override != null)
        {
            node.setLiteral( override );
        }
        /*
         *  feed the children...
         */
        data = node.childrenAccept(this, data);   
        return data;
    }
}
"
org.apache.velocity.servlet.VelocityServlet,"package org.apache.velocity.servlet;
/*
 * Copyright 2000-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.OutputStreamWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.util.Properties;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.io.VelocityWriter;
import org.apache.velocity.util.SimplePool;
import org.apache.velocity.context.Context;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.MethodInvocationException;
/**
 * Base class which simplifies the use of Velocity with Servlets.
 * Extend this class, implement the <code>handleRequest()</code> method, 
 * and add your data to the context.  Then call 
 * <code>getTemplate(""myTemplate.wm"")</code>.
 * 
 * This class puts some things into the context object that you should
 * be aware of:
 * <pre>
 * ""req"" - The HttpServletRequest object
 * ""res"" - The HttpServletResponse object
 * </pre>
 *
 * There are other methods you can override to access, alter or control
 * any part of the request processing chain.  Please see the javadocs for
 * more information on :
 * <ul>
 * <li> loadConfiguration() : for setting up the Velocity runtime
 * <li> createContext() : for creating and loading the Context
 * <li> setContentType() : for changing the content type on a request
 *                         by request basis
 * <li> handleRequest() : you <b>must</b> implement this 
 * <li> mergeTemplate()  : the template rendering process
 * <li> requestCleanup() : post rendering resource or other cleanup
 * <li> error() : error handling
 * </ul>
 * <br>
 * If you put a contentType object into the context within either your
 * serlvet or within your template, then that will be used to override
 * the default content type specified in the properties file.
 *
 * ""contentType"" - The value for the Content-Type: header
 *
 * @author Dave Bryson
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""kjohnson@transparent.com"">Kent Johnson</a>
 * @author <a href=""dlr@finemaltcoding.com"">Daniel Rall</a>
 * $Id: VelocityServlet.java,v 1.52.4.1 2004/03/03 23:23:03 geirm Exp $
 */
public abstract class VelocityServlet extends HttpServlet
{
    /**
     * The context key for the HTTP request object.
     */
    public static final String REQUEST = ""req"";
    /**
     * The context key for the HTTP response object.
     */
    public static final String RESPONSE = ""res"";
    /**
     * The HTTP content type context key.
     */
    public static final String CONTENT_TYPE = ""default.contentType"";
    /**
     *  The default content type for the response
     */
    public static final String DEFAULT_CONTENT_TYPE = ""text/html"";
    /**
     *  Encoding for the output stream
     */
    public static final String DEFAULT_OUTPUT_ENCODING = ""ISO-8859-1"";
    /**
     * The default content type, itself defaulting to {@link
     * #DEFAULT_CONTENT_TYPE} if not configured.
     */
    private static String defaultContentType;
    /**
     * This is the string that is looked for when getInitParameter is
     * called (<code>org.apache.velocity.properties</code>).
     */
    protected static final String INIT_PROPS_KEY =
        ""org.apache.velocity.properties"";
    /**
     * Use of this properties key has been deprecated, and will be
     * removed in Velocity version 1.5.
     */
    private static final String OLD_INIT_PROPS_KEY = ""properties"";
    /**
     * Cache of writers
     */
    private static SimplePool writerPool = new SimplePool(40);
    /** 
     * Performs initialization of this servlet.  Called by the servlet 
     * container on loading.
     *
     * @param config The servlet configuration to apply.
     *
     * @exception ServletException
     */
    public void init( ServletConfig config )
        throws ServletException
    {
        super.init( config );
        /*
         *  do whatever we have to do to init Velocity
         */                
        initVelocity( config );
        /*
         *  Now that Velocity is initialized, cache some config.
         */
        defaultContentType = RuntimeSingleton.getString(CONTENT_TYPE,
                                                        DEFAULT_CONTENT_TYPE);
    }
    /**
     *  Initializes the Velocity runtime, first calling 
     *  loadConfiguration(ServletConvig) to get a 
     *  java.util.Properties of configuration information
     *  and then calling Velocity.init().  Override this
     *  to do anything to the environment before the 
     *  initialization of the singelton takes place, or to 
     *  initialize the singleton in other ways.
     */
    protected void initVelocity( ServletConfig config )
         throws ServletException
    {
        try
        {
            /*
             *  call the overridable method to allow the 
             *  derived classes a shot at altering the configuration
             *  before initializing Runtime
             */
            Properties props = loadConfiguration( config );
            Velocity.init( props );
        }
        catch( Exception e )
        {
            throw new ServletException(""Error initializing Velocity: "" + e, e);
        }   
    }    
    /**
     *  Loads the configuration information and returns that 
     *  information as a Properties, which will be used to 
     *  initialize the Velocity runtime.
     *  <br><br>
     *  Currently, this method gets the initialization parameter
     *  VelocityServlet.INIT_PROPS_KEY, which should be a file containing
     *  the configuration information.
     *  <br><br>
     *  To configure your Servlet Spec 2.2 compliant servlet runner to pass
     *  this to you, put the following in your WEB-INF/web.xml file
     *  <br>
     *  <pre>
     *    &lt;servlet&gt;
     *      &lt;servlet-name&gt; YourServlet &lt/servlet-name&gt;
     *      &lt;servlet-class&gt; your.package.YourServlet &lt;/servlet-class&gt;
     *      &lt;init-param&gt;
     *         &lt;param-name&gt; org.apache.velocity.properties &lt;/param-name&gt;
     *         &lt;param-value&gt; velocity.properties &lt;/param-value&gt;
     *      &lt;/init-param&gt;
     *    &lt;/servlet&gt;
     *   </pre>
     *
     * Alternately, if you wish to configure an entire context in this
     * fashion, you may use the following:
     *  <br>
     *  <pre>
     *    &lt;context-param&gt;
     *       &lt;param-name&gt; org.apache.velocity.properties &lt;/param-name&gt;
     *       &lt;param-value&gt; velocity.properties &lt;/param-value&gt;
     *       &lt;description&gt; Path to Velocity configuration &lt;/description&gt;
     *    &lt;/context-param&gt;
     *   </pre>
     * 
     *  Derived classes may do the same, or take advantage of this code to do the loading for them via :
     *   <pre>
     *      Properties p = super.loadConfiguration( config );
     *   </pre>
     *  and then add or modify the configuration values from the file.
     *  <br>
     *
     *  @param config ServletConfig passed to the servlets init() function
     *                Can be used to access the real path via ServletContext (hint)
     *  @return java.util.Properties loaded with configuration values to be used
     *          to initialize the Velocity runtime.
     *  @throws FileNotFoundException if a specified file is not found.
     *  @throws IOException I/O problem accessing the specified file, if specified.
     */
    protected Properties loadConfiguration(ServletConfig config)
        throws IOException, FileNotFoundException
    {
        // This is a little overly complex because of legacy support
        // for the initialization properties key ""properties"".
        // References to OLD_INIT_PROPS_KEY should be removed at
        // Velocity version 1.5.
        String propsFile = config.getInitParameter(INIT_PROPS_KEY);
        if (propsFile == null || propsFile.length() == 0)
        {
            ServletContext sc = config.getServletContext();
            propsFile = config.getInitParameter(OLD_INIT_PROPS_KEY);
            if (propsFile == null || propsFile.length() == 0)
            {
                propsFile = sc.getInitParameter(INIT_PROPS_KEY);
                if (propsFile == null || propsFile.length() == 0)
                {
                    propsFile = sc.getInitParameter(OLD_INIT_PROPS_KEY);
                    if (propsFile != null && propsFile.length() > 0)
                    {
                        sc.log(""Use of the properties initialization "" +
                               ""parameter '"" + OLD_INIT_PROPS_KEY + ""' has "" +
                               ""been deprecated by '"" + INIT_PROPS_KEY + '\'');
                    }
                }
            }
            else
            {
                sc.log(""Use of the properties initialization parameter '"" +
                       OLD_INIT_PROPS_KEY + ""' has been deprecated by '"" +
                       INIT_PROPS_KEY + '\'');
            }
        }
        /*
         * This will attempt to find the location of the properties
         * file from the relative path to the WAR archive (ie:
         * docroot). Since JServ returns null for getRealPath()
         * because it was never implemented correctly, then we know we
         * will not have an issue with using it this way. I don't know
         * if this will break other servlet engines, but it probably
         * shouldn't since WAR files are the future anyways.
         */
        Properties p = new Properties();
        if ( propsFile != null )
        {
            String realPath = getServletContext().getRealPath(propsFile);
            if ( realPath != null )
            {
                propsFile = realPath;
            }
            p.load( new FileInputStream(propsFile) );
        }
        return p;
    }
    /**
     * Handles HTTP <code>GET</code> requests by calling {@link
     * #doRequest()}.
     */
    public void doGet( HttpServletRequest request, HttpServletResponse response )
        throws ServletException, IOException
    {
        doRequest(request, response);
    }
    /**
     * Handles HTTP <code>POST</code> requests by calling {@link
     * #doRequest()}.
     */
    public void doPost( HttpServletRequest request, HttpServletResponse response )
        throws ServletException, IOException
    {
        doRequest(request, response);
    }
    /**
     *  Handles all requests (by default).
     *
     *  @param request  HttpServletRequest object containing client request
     *  @param response HttpServletResponse object for the response
     */
    protected void doRequest(HttpServletRequest request, HttpServletResponse response )
         throws ServletException, IOException
    {
        Context context = null;
        try
        {
            /*
             *  first, get a context
             */
            context = createContext( request, response );
            /*
             *   set the content type 
             */
            setContentType( request, response );
            /*
             *  let someone handle the request
             */
            Template template = handleRequest( request, response, context );        
            /*
             *  bail if we can't find the template
             */
            if ( template == null )
            {
                return;
            }
            /*
             *  now merge it
             */
            mergeTemplate( template, context, response );
        }
        catch (Exception e)
        {
            /*
             *  call the error handler to let the derived class
             *  do something useful with this failure.
             */
            error( request, response, e);
        }
        finally
        {
            /*
             *  call cleanup routine to let a derived class do some cleanup
             */
            requestCleanup( request, response, context );
        }
    }
    /**
     *  A cleanup routine which is called at the end of the {@link
     *  #doRequest(HttpServletRequest, HttpServletResponse)}
     *  processing sequence, allowing a derived class to do resource
     *  cleanup or other end of process cycle tasks.
     *
     *  @param request servlet request from client 
     *  @param response servlet reponse 
     *  @param context  context created by the createContext() method
     */
    protected void requestCleanup( HttpServletRequest request, HttpServletResponse response, Context context )
    {
        return;
    }
    /**
     *  merges the template with the context.  Only override this if you really, really
     *  really need to. (And don't call us with questions if it breaks :)
     *
     *  @param template template object returned by the handleRequest() method
     *  @param context  context created by the createContext() method
     *  @param response servlet reponse (use this to get the output stream or Writer
     */
    protected void mergeTemplate( Template template, Context context, HttpServletResponse response )
        throws ResourceNotFoundException, ParseErrorException, 
               MethodInvocationException, IOException, UnsupportedEncodingException, Exception
    {
        ServletOutputStream output = response.getOutputStream();
        VelocityWriter vw = null;
        // ASSUMPTION: response.setContentType() has been called.
        String encoding = response.getCharacterEncoding();
        try
        {
            vw = (VelocityWriter) writerPool.get();
            if (vw == null)
            {
                vw = new VelocityWriter(new OutputStreamWriter(output,
                                                               encoding),
                                        4 * 1024, true);
            }
            else
            {
                vw.recycle(new OutputStreamWriter(output, encoding));
            }
            template.merge(context, vw);
        }
        finally
        {
            try
            {
                if (vw != null)
                {
                    /*
                     *  flush and put back into the pool
                     *  don't close to allow us to play
                     *  nicely with others.
                     */
                    vw.flush();
                    /*
                     * Clear the VelocityWriter's reference to its
                     * internal OutputStreamWriter to allow the latter
                     * to be GC'd while vw is pooled.
                     */
                    vw.recycle(null);
                    writerPool.put(vw);
                }
            }
            catch (Exception e)
            {
                // do nothing
            }
        }
    }
    /**
     * Sets the content type of the response, defaulting to {@link
     * #defaultContentType} if not overriden.  Delegates to {@link
     * #chooseCharacterEncoding(HttpServletRequest)} to select the
     * appropriate character encoding.
     *
     * @param request The servlet request from the client.
     * @param response The servlet reponse to the client.
     */
    protected void setContentType(HttpServletRequest request,
                                  HttpServletResponse response)
    {
        String contentType = defaultContentType;
        int index = contentType.lastIndexOf(';') + 1;
        if (index <= 0 || (index < contentType.length() &&
                           contentType.indexOf(""charset"", index) == -1))
        {
            // Append the character encoding which we'd like to use.
            String encoding = chooseCharacterEncoding(request);
            //System.out.println(""Chose output encoding of '"" +
            //                   encoding + '\'');
            if (!DEFAULT_OUTPUT_ENCODING.equalsIgnoreCase(encoding))
            {
                contentType += ""; charset="" + encoding;
            }
        }
        response.setContentType(contentType);
        //System.out.println(""Response Content-Type set to '"" +
        //                   contentType + '\'');
    }
    /**
     * Chooses the output character encoding to be used as the value
     * for the ""charset="" portion of the HTTP Content-Type header (and
     * thus returned by <code>response.getCharacterEncoding()</code>).
     * Called by {@link #setContentType(HttpServletRequest,
     * HttpServletResponse)} if an encoding isn't already specified by
     * Content-Type.  By default, chooses the value of
     * RuntimeSingleton's <code>output.encoding</code> property.
     *
     * @param request The servlet request from the client.
     */
    protected String chooseCharacterEncoding(HttpServletRequest request)
    {
        return RuntimeSingleton.getString(RuntimeConstants.OUTPUT_ENCODING,
                                          DEFAULT_OUTPUT_ENCODING);
    }
    /**
     *  Returns a context suitable to pass to the handleRequest() method
     *  <br><br>
     *  Default implementation will create a VelocityContext object,
     *   put the HttpServletRequest and HttpServletResponse
     *  into the context accessable via the keys VelocityServlet.REQUEST and
     *  VelocityServlet.RESPONSE, respectively.
     *
     *  @param request servlet request from client
     *  @param response servlet reponse to client
     *
     *  @return context
     */
    protected Context createContext(HttpServletRequest request,  HttpServletResponse response )
    {
        /*
         *   create a new context
         */
        VelocityContext context = new VelocityContext();
        /*
         *   put the request/response objects into the context
         *   wrap the HttpServletRequest to solve the introspection
         *   problems 
         */
        context.put( REQUEST,  request );
        context.put( RESPONSE, response );
        return context;
    }
    /**
     * Retrieves the requested template.
     *
     * @param name The file name of the template to retrieve relative to the 
     *             template root.
     * @return     The requested template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate( String name )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate(name);
    }
    /**
     * Retrieves the requested template with the specified
     * character encoding.
     *
     * @param name The file name of the template to retrieve relative to the 
     *             template root.
     * @param encoding the character encoding of the template
     *
     * @return     The requested template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     *     
     *  @since Velocity v1.1
     */
    public Template getTemplate( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name, encoding );
    }
    /**
     * Implement this method to add your application data to the context, 
     * calling the <code>getTemplate()</code> method to produce your return 
     * value.
     * <br><br>
     * In the event of a problem, you may handle the request directly
     * and return <code>null</code> or throw a more meaningful exception
     * for the error handler to catch.
     *
     *  @param request servlet request from client 
     *  @param response servlet reponse 
     *  @param ctx The context to add your data to.
     *  @return    The template to merge with your context or null, indicating
     *    that you handled the processing.
     *
     *  @since Velocity v1.1
     */
    protected Template handleRequest( HttpServletRequest request, HttpServletResponse response, Context ctx ) 
        throws Exception
    {
        /*
         * invoke handleRequest
         */
        Template t =  handleRequest( ctx );
        /*
         *  if it returns null, this is the 'old' deprecated 
         *  way, and we want to mimic the behavior for a little 
         *  while anyway
         */
        if (t == null)
        {
            throw new Exception (""handleRequest(Context) returned null - no template selected!"" );
        }
        return t;
    }
    /**
     * Implement this method to add your application data to the context, 
     * calling the <code>getTemplate()</code> method to produce your return 
     * value.
     * <br><br>
     * In the event of a problem, you may simple return <code>null</code>
     * or throw a more meaningful exception.
     *
     * @deprecated Use
     * {@link #handleRequest( HttpServletRequest request, 
     * HttpServletResponse response, Context ctx )}
     *
     * @param ctx The context to add your data to.
     * @return    The template to merge with your context.
     */
    protected Template handleRequest( Context ctx ) 
        throws Exception
    {
        throw new Exception (""You must override VelocityServlet.handleRequest( Context) ""
                             + "" or VelocityServlet.handleRequest( HttpServletRequest, ""
                             + "" HttpServletResponse, Context)"" );
    }
    /**
     * Invoked when there is an error thrown in any part of doRequest() processing.
     * <br><br>
     * Default will send a simple HTML response indicating there was a problem.
     * 
     * @param request original HttpServletRequest from servlet container.
     * @param response HttpServletResponse object from servlet container.
     * @param cause  Exception that was thrown by some other part of process.
     */
    protected void error( HttpServletRequest request, HttpServletResponse response, Exception cause )
        throws ServletException, IOException
    {
        StringBuffer html = new StringBuffer();
        html.append(""<html>"");
        html.append(""<title>Error</title>"");
        html.append(""<body bgcolor=\""#ffffff\"">"");
        html.append(""<h2>VelocityServlet: Error processing the template</h2>"");
        html.append(""<pre>"");
        String why = cause.getMessage();
        if (why != null && why.trim().length() > 0)
        {
            html.append(why);
            html.append(""<br>"");
        }
        StringWriter sw = new StringWriter();
        cause.printStackTrace( new PrintWriter( sw ) );
        html.append( sw.toString()  );
        html.append(""</pre>"");
        html.append(""</body>"");
        html.append(""</html>"");
        response.getOutputStream().print( html.toString() );
    }
}
"
org.apache.velocity.test.AnakiaTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is a test case for Anakia. Right now, it simply will compare
 * two index.html files together. These are produced as a result of
 * first running Anakia and then running this test.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: AnakiaTestCase.java,v 1.6.4.1 2004/03/03 23:23:04 geirm Exp $
 */
public class AnakiaTestCase extends BaseTestCase
{
    private static final String COMPARE_DIR = ""../test/anakia/compare"";
    private static final String RESULTS_DIR = ""../test/anakia/results"";
    private static final String FILE_EXT = "".html"";
    /**
     * Creates a new instance.
     *
     */
    public AnakiaTestCase()
    {
        super(""AnakiaTestCase"");
    }
    public static junit.framework.Test suite()
    {
        return new AnakiaTestCase();
    }
    /**
     * Runs the test. This is empty on purpose because the
     * code to do the Anakia output is in the .xml file that runs
     * this test.
     */
    public void runTest ()
    {
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            if (!isMatch(RESULTS_DIR,COMPARE_DIR,""index"",FILE_EXT,FILE_EXT))
            {
                fail(""Output is incorrect!"");
            }
            else
            {
                System.out.println (""Passed!"");
            }
        }            
        catch(Exception e)
        {
            /*
             * do nothing.
             */
        }
    }
}
"
org.apache.velocity.test.BaseTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.util.StringUtils;
import junit.framework.TestCase;
import org.apache.oro.text.perl.Perl5Util;
/**
 * Base test case that provides a few utility methods for
 * the rest of the tests.
 *
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @version $Id: BaseTestCase.java,v 1.12.4.1 2004/03/03 23:23:04 geirm Exp $
 */
public class BaseTestCase extends TestCase
{
    /**
     *  used for nomalization of output and compare data
     */
    private Perl5Util perl = new Perl5Util();    
    /**
     * Default constructor.
     */
    public BaseTestCase(String name)
    {
        super(name);
    }
    /**
     * Concatenates the file name parts together appropriately.
     *
     * @return The full path to the file.
     */
    protected static String getFileName (String dir, String base, String ext)
    {
        StringBuffer buf = new StringBuffer();
        if (dir != null)
        {
            buf.append(dir).append('/');
        }
        buf.append(base).append('.').append(ext);
        return buf.toString();
    }
    /**
     * Assures that the results directory exists.  If the results directory
     * cannot be created, fails the test.
     */
    protected static void assureResultsDirectoryExists (String resultsDirectory)
    {
        File dir = new File(resultsDirectory);
        if (!dir.exists())
        {
            RuntimeSingleton.info(""Template results directory does not exist"");
            if (dir.mkdirs())
            {
                RuntimeSingleton.info(""Created template results directory"");
            }
            else
            {
                String errMsg = ""Unable to create template results directory"";
                RuntimeSingleton.warn(errMsg);
                fail(errMsg);
            }
        }
    }
    /**
     * Normalizes lines to account for platform differences.  Macs use
     * a single \r, DOS derived operating systems use \r\n, and Unix
     * uses \n.  Replace each with a single \n.
     *
     * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
     * @return source with all line terminations changed to Unix style
     */
    protected String normalizeNewlines (String source)
    {
        return perl.substitute(""s/\r[\n]/\n/g"", source);
    }
    /**
     * Returns whether the processed template matches the 
     * content of the provided comparison file.
     *
     * @return Whether the output matches the contents 
     *         of the comparison file.
     *
     * @exception Exception Test failure condition.
     */
    protected boolean isMatch (String resultsDir,
                               String compareDir,
                               String baseFileName, 
                               String resultExt,
                               String compareExt)
        throws Exception
    {
        String result = StringUtils.fileContentsToString
            (getFileName(resultsDir, baseFileName, resultExt));
        String compare = StringUtils.fileContentsToString
             (getFileName(compareDir, baseFileName, compareExt));
        /*
         *  normalize each wrt newline
         */
        return normalizeNewlines(result).equals( 
                           normalizeNewlines( compare ) );
    }
    /**
     * Turns a base file name into a test case name.
     *
     * @param s The base file name.
     * @return  The test case name.
     */
    protected  static final String getTestCaseName (String s)
    {
        StringBuffer name = new StringBuffer();
        name.append(Character.toTitleCase(s.charAt(0)));
        name.append(s.substring(1, s.length()).toLowerCase());
        return name.toString();
    }
}
"
org.apache.velocity.test.ClassloaderChangeTest,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.lang.ClassLoader;
import java.io.File;
import java.io.FileInputStream;
import java.io.StringWriter;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.runtime.log.LogSystem;
import org.apache.velocity.util.introspection.Introspector;
import junit.framework.TestCase;
/**
 * Tests if we can hand Velocity an arbitrary class for logging.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ClassloaderChangeTest.java,v 1.1.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class ClassloaderChangeTest extends TestCase implements LogSystem
{
    private VelocityEngine ve = null;
    private boolean sawCacheDump = false;
    private static String OUTPUT = ""Hello From Foo"";
    /**
     * Default constructor.
     */
    public ClassloaderChangeTest()
    {
        super(""ClassloaderChangeTest"");
        try
        {
            /*
             *  use an alternative logger.  Set it up here and pass it in.
             */
            ve = new VelocityEngine();
            ve.setProperty(VelocityEngine.RUNTIME_LOG_LOGSYSTEM, this );
            ve.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup ClassloaderChnageTest : "" + e);
            System.exit(1);
        }            
    }
    public void init( RuntimeServices rs )
    {
        // do nothing with it
    }
    public static junit.framework.Test suite ()
    {
        return new ClassloaderChangeTest();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        sawCacheDump = false;
        try
        {
            VelocityContext vc = new VelocityContext();
            Object foo = null;
            /*
             *  first, we need a classloader to make our foo object
             */
            TestClassloader cl = new TestClassloader();
            Class fooclass = cl.loadClass(""Foo"");
            foo = fooclass.newInstance();
            /*
             *  put it into the context
             */
            vc.put(""foo"", foo);
            /*
             *  and render something that would use it
             *  that will get it into the introspector cache
             */
            StringWriter writer = new StringWriter();
            ve.evaluate( vc, writer, ""test"", ""$foo.doIt()"");
            /*
             *  Check to make sure ok.  note the obvious
             *  dependency on the Foo class...
             */
            if ( !writer.toString().equals( OUTPUT ))
            {
               fail(""Output from doIt() incorrect"");
            }
            /*
             * and do it again :)
             */
            cl = new TestClassloader();
            fooclass = cl.loadClass(""Foo"");
            foo = fooclass.newInstance();
            vc.put(""foo"", foo);
            writer = new StringWriter(); 
            ve.evaluate( vc, writer, ""test"", ""$foo.doIt()"");
            if ( !writer.toString().equals( OUTPUT ))
            {
               fail(""Output from doIt() incorrect"");
            }   
        }
        catch( Exception ee )
        {
            System.out.println(""ClassloaderChangeTest : "" + ee );
        }   
        if (!sawCacheDump)
        {
            fail(""Didn't see introspector cache dump."");
        }
    }
    /**
     *  method to catch Velocity log messages.  When we
     *  see the introspector dump message, then set the flag
     */
    public void logVelocityMessage(int level, String message)
    {
        if (message.equals( Introspector.CACHEDUMP_MSG) )
        {
            sawCacheDump = true;
        }       
    }
}
/**
 *  Simple (real simple...) classloader that depends
 *  on a Foo.class being located in the classloader
 *  directory under test
 */
class TestClassloader extends ClassLoader
{
    private final static String testclass = 
        ""../test/classloader/Foo.class"";
    private Class fooClass = null;
    public TestClassloader()
    {
        try
        {
            File f = new File( testclass );
            byte[] barr = new byte[ (int) f.length() ];
            FileInputStream fis = new FileInputStream( f );
            fis.read( barr );
            fis.close();
            fooClass = defineClass(""Foo"", barr, 0, barr.length);
        }
        catch( Exception e )
        {
            System.out.println(""TestClassloader : exception : "" + e );
        }        
    }
    public Class findClass(String name)     
    {
        return fooClass;
    }
}
"
org.apache.velocity.test.ClasspathResourceTest,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.runtime.RuntimeSingleton;
/**
 * Load templates from the Classpath.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:daveb@miceda-data.com"">Dave Bryson</a>
 * @version $Id: ClasspathResourceTest.java,v 1.9.4.1 2004/03/03 23:23:04 geirm Exp $
 */
public class ClasspathResourceTest extends BaseTestCase
{
     /**
     * VTL file extension.
     */
    private static final String TMPL_FILE_EXT = ""vm"";
    /**
     * Comparison file extension.
     */
    private static final String CMP_FILE_EXT = ""cmp"";
    /**
     * Comparison file extension.
     */
    private static final String RESULT_FILE_EXT = ""res"";
    /**
     * Results relative to the build directory.
     */
    private static final String RESULTS_DIR = ""../test/cpload/results"";
    /**
     * Results relative to the build directory.
     */
    private static final String COMPARE_DIR = ""../test/cpload/compare"";
    /**
     * Default constructor.
     */
    public ClasspathResourceTest()
    {
        super(""ClasspathResourceTest"");
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            Velocity.setProperty(Velocity.RESOURCE_LOADER, ""classpath"");
            /*
             * I don't think I should have to do this, these should
             * be in the default config file.
             */
            Velocity.addProperty(
                ""classpath."" + Velocity.RESOURCE_LOADER + "".class"",
                    ""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
            Velocity.setProperty(
                ""classpath."" + Velocity.RESOURCE_LOADER + "".cache"", ""false"");
            Velocity.setProperty(
                ""classpath."" + Velocity.RESOURCE_LOADER + "".modificationCheckInterval"",
                    ""2"");
            Velocity.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup ClasspathResourceTest!"");
            e.printStackTrace();
            System.exit(1);
        }            
    }
    public static junit.framework.Test suite ()
    {
        return new ClasspathResourceTest();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            /*
             *  lets ensure the results directory exists
             */
            assureResultsDirectoryExists(RESULTS_DIR);
            Template template1 = RuntimeSingleton.getTemplate(
                getFileName(null, ""template/test1"", TMPL_FILE_EXT));
            Template template2 = RuntimeSingleton.getTemplate(
                getFileName(null, ""template/test2"", TMPL_FILE_EXT));
            FileOutputStream fos1 = 
                new FileOutputStream (
                    getFileName(RESULTS_DIR, ""test1"", RESULT_FILE_EXT));
            FileOutputStream fos2 = 
                new FileOutputStream (
                    getFileName(RESULTS_DIR, ""test2"", RESULT_FILE_EXT));
            Writer writer1 = new BufferedWriter(new OutputStreamWriter(fos1));
            Writer writer2 = new BufferedWriter(new OutputStreamWriter(fos2));
            /*
             *  put the Vector into the context, and merge both
             */
            VelocityContext context = new VelocityContext();
            template1.merge(context, writer1);
            writer1.flush();
            writer1.close();
            template2.merge(context, writer2);
            writer2.flush();
            writer2.close();
            if (!isMatch(RESULTS_DIR,COMPARE_DIR,""test1"",RESULT_FILE_EXT,CMP_FILE_EXT) ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""test2"",RESULT_FILE_EXT,CMP_FILE_EXT))
            {
                fail(""Output is incorrect!"");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.CommonsExtPropTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.FileWriter;
import java.util.Iterator;
import java.util.Vector;
import org.apache.commons.collections.ExtendedProperties;
/**
 * Tests for the Commons ExtendedProperties class. This is an identical
 *  copy of the ConfigurationTestCase, which will disappear when
 *  the Configuration class does
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: CommonsExtPropTestCase.java,v 1.2.4.1 2004/03/03 23:23:04 geirm Exp $
 */
public class CommonsExtPropTestCase extends BaseTestCase
{
    /**
     * Comparison directory.
     */
    private static final String COMPARE_DIR = 
        ""../test/configuration/compare"";
    /**
     * Results directory.
     */
    private static final String RESULTS_DIR = 
        ""../test/configuration/results"";
    /**
     * Test configuration
     */
    private static final String TEST_CONFIG = 
        ""../test/configuration/test.config"";
    /**
     * Creates a new instance.
     *
     */
    public CommonsExtPropTestCase()
    {
        super(""CommonsExtPropTestCase"");
    }
    public static junit.framework.Test suite()
    {
        return new CommonsExtPropTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            ExtendedProperties c = new ExtendedProperties(TEST_CONFIG);
            FileWriter result = new FileWriter(
                getFileName(RESULTS_DIR, ""output"", ""res""));
            message(result, ""Testing order of keys ..."");
            showIterator(result, c.getKeys());
            message(result, ""Testing retrieval of CSV values ..."");
            showVector(result, c.getVector(""resource.loader""));            
            message(result, ""Testing subset(prefix).getKeys() ..."");
            ExtendedProperties subset = c.subset(""file.resource.loader"");
            showIterator(result, subset.getKeys());
            message(result, ""Testing getVector(prefix) ..."");
            showVector(result, subset.getVector(""path""));            
            message(result, ""Testing getString(key) ..."");
            result.write(c.getString(""config.string.value""));
            result.write(""\n\n"");
            message(result, ""Testing getBoolean(key) ..."");
            result.write(new Boolean(c.getBoolean(""config.boolean.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getByte(key) ..."");
            result.write(new Byte(c.getByte(""config.byte.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getShort(key) ..."");
            result.write(new Short(c.getShort(""config.short.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getInt(key) ..."");
            result.write(new Integer(c.getInt(""config.int.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getLong(key) ..."");
            result.write(new Long(c.getLong(""config.long.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getFloat(key) ..."");
            result.write(new Float(c.getFloat(""config.float.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getDouble(key) ..."");
            result.write(new Double(c.getDouble(""config.double.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing escaped-comma scalar..."");
            result.write( c.getString(""escape.comma1""));
            result.write(""\n\n"");
            message(result, ""Testing escaped-comma vector..."");
            showVector(result,  c.getVector(""escape.comma2""));
            result.write(""\n\n"");
            result.flush();
            result.close();
            if (!isMatch(RESULTS_DIR, COMPARE_DIR, ""output"",""res"",""cmp""))
            {
                fail(""Output incorrect."");
            }
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup CommonsExtPropTestCase!"");
            e.printStackTrace();
            System.exit(1);
        }
    }
    private void showIterator(FileWriter result, Iterator i)
        throws Exception
    {
        while(i.hasNext())
        {
            result.write((String) i.next());
            result.write(""\n"");
        }
        result.write(""\n"");
    }
    private void showVector(FileWriter result, Vector v)
        throws Exception
    {
        for (int j = 0; j < v.size(); j++)
        {
            result.write((String) v.get(j));
            result.write(""\n"");
        }
        result.write(""\n"");
    }
    private void message(FileWriter result, String message)
        throws Exception
    {
        result.write(""--------------------------------------------------\n"");
        result.write(message + ""\n"");
        result.write(""--------------------------------------------------\n"");
        result.write(""\n"");
    }
}
"
org.apache.velocity.test.ConfigurationTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.FileWriter;
import java.util.Iterator;
import java.util.Vector;
import org.apache.velocity.runtime.configuration.Configuration;
/**
 * Tests for the Configuration class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: ConfigurationTestCase.java,v 1.5.4.1 2004/03/03 23:23:04 geirm Exp $
 *
 * @deprecated Will be removed when Configuration class is removed
 */
public class ConfigurationTestCase extends BaseTestCase
{
    /**
     * Comparison directory.
     */
    private static final String COMPARE_DIR = 
        ""../test/configuration/compare"";
    /**
     * Results directory.
     */
    private static final String RESULTS_DIR = 
        ""../test/configuration/results"";
    /**
     * Test configuration
     */
    private static final String TEST_CONFIG = 
        ""../test/configuration/test.config"";
    /**
     * Creates a new instance.
     *
     */
    public ConfigurationTestCase()
    {
        super(""ConfigurationTestCase"");
    }
    public static junit.framework.Test suite()
    {
        return new ConfigurationTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            Configuration c = new Configuration(TEST_CONFIG);
            FileWriter result = new FileWriter(
                getFileName(RESULTS_DIR, ""output"", ""res""));
            message(result, ""Testing order of keys ..."");
            showIterator(result, c.getKeys());
            message(result, ""Testing retrieval of CSV values ..."");
            showVector(result, c.getVector(""resource.loader""));            
            message(result, ""Testing subset(prefix).getKeys() ..."");
            Configuration subset = c.subset(""file.resource.loader"");
            showIterator(result, subset.getKeys());
            message(result, ""Testing getVector(prefix) ..."");
            showVector(result, subset.getVector(""path""));            
            message(result, ""Testing getString(key) ..."");
            result.write(c.getString(""config.string.value""));
            result.write(""\n\n"");
            message(result, ""Testing getBoolean(key) ..."");
            result.write(new Boolean(c.getBoolean(""config.boolean.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getByte(key) ..."");
            result.write(new Byte(c.getByte(""config.byte.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getShort(key) ..."");
            result.write(new Short(c.getShort(""config.short.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getInt(key) ..."");
            result.write(new Integer(c.getInt(""config.int.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getLong(key) ..."");
            result.write(new Long(c.getLong(""config.long.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getFloat(key) ..."");
            result.write(new Float(c.getFloat(""config.float.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing getDouble(key) ..."");
            result.write(new Double(c.getDouble(""config.double.value"")).toString());
            result.write(""\n\n"");
            message(result, ""Testing escaped-comma scalar..."");
            result.write( c.getString(""escape.comma1""));
            result.write(""\n\n"");
            message(result, ""Testing escaped-comma vector..."");
            showVector(result,  c.getVector(""escape.comma2""));
            result.write(""\n\n"");
            result.flush();
            result.close();
            if (!isMatch(RESULTS_DIR, COMPARE_DIR, ""output"",""res"",""cmp""))
            {
                fail(""Output incorrect."");
            }
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup ConfigurationTestCase!"");
            e.printStackTrace();
            System.exit(1);
        }
    }
    private void showIterator(FileWriter result, Iterator i)
        throws Exception
    {
        while(i.hasNext())
        {
            result.write((String) i.next());
            result.write(""\n"");
        }
        result.write(""\n"");
    }
    private void showVector(FileWriter result, Vector v)
        throws Exception
    {
        for (int j = 0; j < v.size(); j++)
        {
            result.write((String) v.get(j));
            result.write(""\n"");
        }
        result.write(""\n"");
    }
    private void message(FileWriter result, String message)
        throws Exception
    {
        result.write(""--------------------------------------------------\n"");
        result.write(message + ""\n"");
        result.write(""--------------------------------------------------\n"");
        result.write(""\n"");
    }
}
"
org.apache.velocity.test.ContextSafetyTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Vector;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.runtime.RuntimeSingleton;
/**
 * Tests if we are context safe : can we switch objects in the context
 * and re-merge the template safely.
 *
 * NOTE:
 * This class should not extend RuntimeTestCase because this test
 * is run from the VelocityTestSuite which in effect a runtime
 * test suite and the test suite initializes the Runtime. Extending
 * RuntimeTestCase causes the Runtime to be initialized twice.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ContextSafetyTestCase.java,v 1.10.4.1 2004/03/03 23:23:04 geirm Exp $
 */
public class ContextSafetyTestCase extends BaseTestCase implements TemplateTestBase
{
    public ContextSafetyTestCase()
    {
        super(""ContextSafetyTestCase"");
        try
        {
	        Velocity.setProperty(
	            Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
             Velocity.init();
	    }
	    catch (Exception e)
	    {
            System.err.println(""Cannot setup ContextSafetyTestCase!"");
            e.printStackTrace();
            System.exit(1);
	    }
    }
    public static junit.framework.Test suite()
    {
        return new ContextSafetyTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        /*
         *  make a Vector and String array because
         *  they are treated differently in Foreach()
         */
        Vector v = new Vector();
        v.addElement( new String(""vector hello 1"") );
        v.addElement( new String(""vector hello 2"") );
        v.addElement( new String(""vector hello 3"") );
        String strArray[] = new String[3];
        strArray[0] = ""array hello 1"";
        strArray[1] = ""array hello 2"";
        strArray[2] = ""array hello 3"";
        VelocityContext context = new VelocityContext();
        try
        {
            assureResultsDirectoryExists(RESULT_DIR);
            /*
             *  get the template and the output
             */
            Template template = RuntimeSingleton.getTemplate(
                getFileName(null, ""context_safety"", TMPL_FILE_EXT));
            FileOutputStream fos1 = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""context_safety1"", RESULT_FILE_EXT));
            FileOutputStream fos2 = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""context_safety2"", RESULT_FILE_EXT));
            Writer writer1 = new BufferedWriter(new OutputStreamWriter(fos1));
            Writer writer2 = new BufferedWriter(new OutputStreamWriter(fos2));
            /*
             *  put the Vector into the context, and merge
             */
            context.put(""vector"", v);  
            template.merge(context, writer1);
            writer1.flush();
            writer1.close();
            /*
             *  now put the string array into the context, and merge
             */
            context.put(""vector"", strArray);  
            template.merge(context, writer2);
            writer2.flush();
            writer2.close();
            if (!isMatch(RESULT_DIR,COMPARE_DIR,""context_safety1"",
                    RESULT_FILE_EXT,CMP_FILE_EXT) ||
                !isMatch(RESULT_DIR,COMPARE_DIR,""context_safety2"",
                    RESULT_FILE_EXT,CMP_FILE_EXT))
            {
                fail(""Output incorrect."");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.EncodingTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Vector;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.util.StringUtils;
import junit.framework.TestCase;
/**
 * Tests input encoding handling.  The input target is UTF-8, having
 * chinese and and a spanish enyay (n-twiddle)
 *
 *  Thanks to Kent Johnson for the example input file.
 *
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: EncodingTestCase.java,v 1.4.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class EncodingTestCase extends BaseTestCase implements TemplateTestBase
{
    public EncodingTestCase()
    {
        super(""EncodingTestCase"");
        try
        {
	        Velocity.setProperty(
	            Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
            Velocity.setProperty( Velocity.INPUT_ENCODING, ""UTF-8"" );
            Velocity.init();
	    }
	    catch (Exception e)
	    {
            System.err.println(""Cannot setup EncodingTestCase!"");
            e.printStackTrace();
            System.exit(1);
	    }
    }
    public static junit.framework.Test suite()
    {
        return new EncodingTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        VelocityContext context = new VelocityContext();
        try
        {
            assureResultsDirectoryExists(RESULT_DIR);
            /*
             *  get the template and the output
             */
            /*
             *  Chinese and spanish
             */
            Template template = Velocity.getTemplate(
                getFileName(null, ""encodingtest"", TMPL_FILE_EXT), ""UTF-8"");
            FileOutputStream fos = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""encodingtest"", RESULT_FILE_EXT));
            Writer writer = new BufferedWriter(new OutputStreamWriter(fos, ""UTF-8""));
            template.merge(context, writer);
            writer.flush();
            writer.close();
            if (!isMatch(RESULT_DIR,COMPARE_DIR,""encodingtest"",
                    RESULT_FILE_EXT,CMP_FILE_EXT) )
            {
                fail(""Output 1 incorrect."");
            }
            /*
             *  a 'high-byte' chinese example from Michael Zhou
             */
            template = Velocity.getTemplate( 
                  getFileName( null, ""encodingtest2"", TMPL_FILE_EXT), ""UTF-8"");
            fos = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""encodingtest2"", RESULT_FILE_EXT));
            writer = new BufferedWriter(new OutputStreamWriter(fos, ""UTF-8""));
            template.merge(context, writer);
            writer.flush();
            writer.close();
            if (!isMatch(RESULT_DIR,COMPARE_DIR,""encodingtest2"",
                    RESULT_FILE_EXT,CMP_FILE_EXT) )
            {
                fail(""Output 2 incorrect."");
            }
            /*
             *  a 'high-byte' chinese from Ilkka
             */
            template = Velocity.getTemplate( 
                  getFileName( null, ""encodingtest3"", TMPL_FILE_EXT), ""GBK"");
            fos = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""encodingtest3"", RESULT_FILE_EXT));
            writer = new BufferedWriter(new OutputStreamWriter(fos, ""GBK""));
            template.merge(context, writer);
            writer.flush();
            writer.close();
            if (!isMatch(RESULT_DIR,COMPARE_DIR,""encodingtest3"",
                    RESULT_FILE_EXT,CMP_FILE_EXT) )
            {
                fail(""Output 3 incorrect."");
            }
            /*
             *  Russian example from Vitaly Repetenko
             */
            template = Velocity.getTemplate( 
                  getFileName( null, ""encodingtest_KOI8-R"", TMPL_FILE_EXT), ""KOI8-R"");
            fos = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""encodingtest_KOI8-R"", RESULT_FILE_EXT));
            writer = new BufferedWriter(new OutputStreamWriter(fos, ""KOI8-R""));
            template.merge(context, writer);
            writer.flush();
            writer.close();
            if (!isMatch(RESULT_DIR,COMPARE_DIR,""encodingtest_KOI8-R"",
                    RESULT_FILE_EXT,CMP_FILE_EXT) )
            {
                fail(""Output 4 incorrect."");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.EventHandlingTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.StringWriter;
import junit.framework.TestCase;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.runtime.log.LogSystem;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.app.event.ReferenceInsertionEventHandler;
import org.apache.velocity.app.event.MethodExceptionEventHandler;
import org.apache.velocity.app.event.NullSetEventHandler;
import org.apache.velocity.runtime.RuntimeServices;
/**
 *  Tests event handling
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: EventHandlingTestCase.java,v 1.5.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class EventHandlingTestCase extends TestCase implements ReferenceInsertionEventHandler, 
                                     NullSetEventHandler, MethodExceptionEventHandler,
                                     LogSystem
{
    private String logString = null;
    private boolean exceptionSwitch = true;
    private static String NO_REFERENCE_VALUE =  ""<no reference value>"";
    private static String REFERENCE_VALUE =  ""<reference value>"";
    /**
     * Default constructor.
     */
    public EventHandlingTestCase()
    {
        super(""EventHandlingTestCase"");
        try
        {
            /*
             *  use an alternative logger.  Set it up here and pass it in.
             */
            Velocity.setProperty(Velocity.RUNTIME_LOG_LOGSYSTEM, this );
            Velocity.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup event handling test : "" + e);
            System.exit(1);
        }            
    }
    public void init( RuntimeServices rs )
    {
        /* don't need it...*/
    }
    public static junit.framework.Test suite ()
    {
        return new EventHandlingTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        /* 
         *  lets make a Context and add the event cartridge
         */
        VelocityContext inner = new VelocityContext();
        /*
         *  Now make an event cartridge, register all the 
         *  event handlers (at once) and attach it to the
         *  Context
         */
        EventCartridge ec = new EventCartridge();
        ec.addEventHandler(this);
        ec.attachToContext( inner );
        /*
         *  now wrap the event cartridge - we want to make sure that
         *  we can do this w/o harm
         */
        VelocityContext context = new VelocityContext( inner );
        context.put(""name"", ""Velocity"");
        try
        {
            /*
             *  First, the reference insertion handler
             */
            String s = ""$name"";
            StringWriter w = new StringWriter();
            Velocity.evaluate( context, w, ""mystring"", s );
            if ( !w.toString().equals( REFERENCE_VALUE ))
            {
                fail( ""Reference insertion test 1"");
            }
            /*
             *  using the same handler, we can deal with 
             *  null references as well
             */
            s = ""$floobie"";
            w = new StringWriter();
            Velocity.evaluate( context, w, ""mystring"", s );
            if ( !w.toString().equals( NO_REFERENCE_VALUE ))
            {
                fail( ""Reference insertion test 2"");
            }
            /*
             *  now lets test setting a null value - this test
             *  should result in *no* log output.
             */
            s = ""#set($settest = $NotAReference)"";
            w = new StringWriter();
            logString = null;
            Velocity.evaluate( context, w, ""mystring"", s );
            if( logString != null)
            {
                fail( ""NullSetEventHandler test 1"");
            }
            /*
             *  now lets test setting a null value - this test
             *  should result in log output.
             */
            s = ""#set($logthis = $NotAReference)"";
            w = new StringWriter();
            logString = null;           
            Velocity.evaluate( context, w, ""mystring"", s );
            if( logString == null)
            {
                fail( ""NullSetEventHandler test 1"");
            }
            /*
             *  finally, we test a method exception event - we do this 
             *  by putting this class in the context, and calling 
             *  a method that does nothing but throw an exception.
             *  we use a little switch to turn the event handling
             *  on and off
             *
             *  Note also how the reference insertion process
             *  happens as well
             */
            exceptionSwitch = true;
            context.put(""this"", this );
            s = "" $this.throwException()"";
            w = new StringWriter();
            try
            {
                Velocity.evaluate( context, w, ""mystring"", s );
            }
            catch( MethodInvocationException mee )
            {
                fail(""MethodExceptionEvent test 1"");
            }
            catch( Exception e )
            {
                fail(""MethodExceptionEvent test 1"");
            }
            /*
             *  now, we turn the switch off, and we can see that the 
             *  exception will propgate all the way up here, and 
             *  wil be caught by the catch() block below
             */
            exceptionSwitch = false;
            s = "" $this.throwException()"";
            w = new StringWriter();
            try
            {
                Velocity.evaluate( context, w, ""mystring"", s );
                fail(""MethodExceptionEvent test 2"");
            }
            catch( MethodInvocationException mee )
            {
                /*
                 * correct - should land here...
                 */
            }
            catch( Exception e )
            {
                fail(""MethodExceptionEvent test 2"");
            }
        }
        catch( ParseErrorException pee )
        {
            fail(""ParseErrorException"" + pee);
        }
        catch( MethodInvocationException mee )
        {
            fail(""MethodInvocationException"" + mee);
        }
        catch( Exception e )
        {
            fail(""Exception"" + e);
         }
    }
    /**
     *  silly method to throw an exception to test
     *  the method invocation exception event handling
     */
    public void throwException()
        throws Exception
    {
        throw new Exception(""Hello from throwException()"");
    }
    /**
     *  Event handler for when a reference is inserted into the output stream.
     */
    public Object referenceInsert( String reference, Object value  )
    {
        /*
         *  if we have a value
         *  return a known value
         */
        String s = null;
        if( value != null )
        {
            s = REFERENCE_VALUE;
        }
        else
        {
            /*
             * we only want to deal with $floobie - anything
             *  else we let go
             */
            if ( reference.equals(""$floobie"") )
            {
                s = NO_REFERENCE_VALUE;
            }
        }
        return s;
    }
    /**
     *  Event handler for when the right hand side of
     *  a #set() directive is null, which results in 
     *  a log message.  This method gives the application
     *  a chance to 'vote' on msg generation
     */
    public boolean shouldLogOnNullSet( String lhs, String rhs )
    {
        if (lhs.equals(""$settest""))
            return false;
        return true;
    }
    /**
     *  Handles exceptions thrown during in-template method access
     */
    public Object methodException( Class claz, String method, Exception e )
         throws Exception
    {
        /*
         *  only do processing if the switch is on
         */
        if( exceptionSwitch && method.equals(""throwException""))
        {
            return ""handler"";
        }
        throw e;
    } 
    /**
     *  handler for LogSystem interface
     */
    public void logVelocityMessage(int level, String message)
    {
        logString = message;
    }
}
"
org.apache.velocity.test.ExternalLoggerTest,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.LogSystem;
import junit.framework.TestCase;
/**
 * Tests if we can hand Velocity an arbitrary class for logging.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ExternalLoggerTest.java,v 1.4.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class ExternalLoggerTest extends TestCase implements LogSystem
{
    private String logString = null;
    private VelocityEngine ve = null;
    /**
     * Default constructor.
     */
    public ExternalLoggerTest()
    {
        super(""LoggerTest"");
        try
        {
            /*
             *  use an alternative logger.  Set it up here and pass it in.
             */
            ve = new VelocityEngine();
            ve.setProperty(VelocityEngine.RUNTIME_LOG_LOGSYSTEM, this );
            ve.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup LoggerTest : "" + e);
            System.exit(1);
        }            
    }
    public void init( RuntimeServices rs )
    {
        // do nothing with it
    }
    public static junit.framework.Test suite ()
    {
        return new ExternalLoggerTest();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        /*
         *  simply log something and see if we get it.
         */
        logString = null;
        String testString = ""This is a test."";
        ve.warn( testString );
        if (logString == null || !logString.equals( VelocityEngine.WARN_PREFIX +  testString ) )
        {
            fail(""Didn't recieve log message."");
        }
    }
    public void logVelocityMessage(int level, String message)
    {
        String out = """";
        /*
         * Start with the appropriate prefix
         */
        switch( level ) 
        {
            case LogSystem.DEBUG_ID :
                out = VelocityEngine.DEBUG_PREFIX;
                break;
            case LogSystem.INFO_ID :
                out = VelocityEngine.INFO_PREFIX;
                break;
            case LogSystem.WARN_ID :
                out = VelocityEngine.WARN_PREFIX;
                break;
            case LogSystem.ERROR_ID : 
                out = VelocityEngine.ERROR_PREFIX;
                break;
            default :
                out = VelocityEngine.UNKNOWN_PREFIX;
                break;
        }
        logString =  out + message;
    }
}
"
org.apache.velocity.test.InlineScopeVMTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Properties;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.runtime.VelocimacroFactory;
import junit.framework.TestCase;
/**
 * Tests if the VM template-locality is working.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:dlr@collab.net"">Daniel Rall</a>
 * @version $Id: InlineScopeVMTestCase.java,v 1.11.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class InlineScopeVMTestCase extends BaseTestCase implements TemplateTestBase
{
    /**
     * The name of this test case.
     */
    private static final String TEST_CASE_NAME = ""InlineScopeVMTestCase"";
    InlineScopeVMTestCase()
    {
        super(TEST_CASE_NAME);
        try
        {
            /*
             *  do our properties locally, and just override the ones we want
             *  changed
             */
            Velocity.setProperty( 
                Velocity.VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL, ""true"");
            Velocity.setProperty( 
                Velocity.VM_PERM_INLINE_LOCAL, ""true"");
            Velocity.setProperty( 
                Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
            Velocity.init();    
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup "" + TEST_CASE_NAME);
            System.exit(1);
        } 
    }
    public static junit.framework.Test suite ()
    {
        return new InlineScopeVMTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            assureResultsDirectoryExists(RESULT_DIR);
            /*
             * Get the template and the output. Do them backwards. 
             * vm_test2 uses a local VM and vm_test1 doesn't
             */
            Template template2 = RuntimeSingleton.getTemplate(
                getFileName(null, ""vm_test2"", TMPL_FILE_EXT));
            Template template1 = RuntimeSingleton.getTemplate(
                getFileName(null, ""vm_test1"", TMPL_FILE_EXT));
            FileOutputStream fos1 = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""vm_test1"", RESULT_FILE_EXT));
            FileOutputStream fos2 = 
                new FileOutputStream (
                    getFileName(RESULT_DIR, ""vm_test2"", RESULT_FILE_EXT));
            Writer writer1 = new BufferedWriter(new OutputStreamWriter(fos1));
            Writer writer2 = new BufferedWriter(new OutputStreamWriter(fos2));
            /*
             *  put the Vector into the context, and merge both
             */
            VelocityContext context = new VelocityContext();
            template1.merge(context, writer1);
            writer1.flush();
            writer1.close();
            template2.merge(context, writer2);
            writer2.flush();
            writer2.close();
            if (!isMatch(RESULT_DIR,COMPARE_DIR,""vm_test1"",
                    RESULT_FILE_EXT,CMP_FILE_EXT) ||
                !isMatch(RESULT_DIR,COMPARE_DIR,""vm_test2"",
                    RESULT_FILE_EXT,CMP_FILE_EXT))
            {
                fail(""Output incorrect."");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.IntrospectorTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.ArrayList;
import java.lang.reflect.Method;
import org.apache.velocity.runtime.RuntimeSingleton;
import junit.framework.TestCase;
/**
 * Test case for the Velocity Introspector which uses
 * the Java Reflection API to determine the correct
 * signature of the methods used in VTL templates.
 *
 * This should be split into separate tests for each
 * of the methods searched for but this is a start
 * for now.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: IntrospectorTestCase.java,v 1.10.8.1 2004/03/03 23:23:04 geirm Exp $
 */
public class IntrospectorTestCase extends BaseTestCase
{
    private Method method;
    private String result;
    private String type;
    private ArrayList failures = new ArrayList();
    IntrospectorTestCase()
    {
        super(""IntrospectorTestCase"");
    }
    /**
      * Creates a new instance.
      */
    public IntrospectorTestCase (String name)
    {
        super(name);
    }
    /**
      * Get the containing <code>TestSuite</code>.  This is always
      * <code>VelocityTestSuite</code>.
      *
      * @return The <code>TestSuite</code> to run.
      */
    public static junit.framework.Test suite ()
    {
        return new IntrospectorTestCase();
    }
    public void runTest()
    {
        MethodProvider mp = new MethodProvider();
        try
        {
            // Test boolean primitive.
            Object[] booleanParams = { new Boolean(true) };
            type = ""boolean"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", booleanParams);
            result = (String) method.invoke(mp, booleanParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test byte primitive.
            Object[] byteParams = { new Byte(""1"") };
            type = ""byte"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", byteParams);
            result = (String) method.invoke(mp, byteParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test char primitive.
            Object[] characterParams = { new Character('a') };
            type = ""character"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", characterParams);
            result = (String) method.invoke(mp, characterParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test double primitive.
            Object[] doubleParams = { new Double((double)1) };
            type = ""double"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", doubleParams);
            result = (String) method.invoke(mp, doubleParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test float primitive.
            Object[] floatParams = { new Float((float)1) };
            type = ""float"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", floatParams);
            result = (String) method.invoke(mp, floatParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test integer primitive.
            Object[] integerParams = { new Integer((int)1) };
            type = ""integer"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", integerParams);
            result = (String) method.invoke(mp, integerParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test long primitive.
            Object[] longParams = { new Long((long)1) };
            type = ""long"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", longParams);
            result = (String) method.invoke(mp, longParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test short primitive.
            Object[] shortParams = { new Short((short)1) };
            type = ""short"";
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, type + ""Method"", shortParams);
            result = (String) method.invoke(mp, shortParams);
            if (!result.equals(type))
                failures.add(type + ""Method could not be found!"");
            // Test untouchable
            Object[] params = {};
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, ""untouchable"", params);
            if (method != null)
                failures.add(type + ""able to access a private-access method."");      
            // Test really untouchable
            method = RuntimeSingleton.getIntrospector().getMethod(
                MethodProvider.class, ""reallyuntouchable"", params);
            if (method != null)
                failures.add(type + ""able to access a default-access method."");      
            // There were any failures then show all the
            // errors that occured.
            int totalFailures = failures.size();
            if (totalFailures > 0)
            {
                StringBuffer sb = new StringBuffer(""\nIntrospection Errors:\n"");
                for (int i = 0; i < totalFailures; i++)
                    sb.append((String) failures.get(i)).append(""\n"");
                fail(sb.toString());
            }                    
        }
        catch (Exception e)
        {
            fail( e.toString() );
        }
    }
    public static class MethodProvider
    {
        /*
         * Methods with native parameter types.
         */
        public String booleanMethod (boolean p) { return ""boolean""; }
        public String byteMethod (byte p) { return ""byte""; }
        public String characterMethod (char p) { return ""character""; }
        public String doubleMethod (double p) { return ""double""; }
        public String floatMethod (float p) { return ""float""; }
        public String integerMethod (int p) { return ""integer""; }
        public String longMethod (long p) { return ""long""; }
        public String shortMethod (short p) { return ""short""; }
        String untouchable() { return ""yech"";}
        private String reallyuntouchable() { return ""yech!""; }
    }
}
"
org.apache.velocity.test.IntrospectorTestCase2,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.ArrayList;
import java.lang.reflect.Method;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.runtime.RuntimeSingleton;
import junit.framework.TestCase;
/**
 * Test case for the Velocity Introspector which
 *  tests the ability to find a 'best match'
 *
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: IntrospectorTestCase2.java,v 1.1.8.1 2004/03/03 23:23:04 geirm Exp $
 */
public class IntrospectorTestCase2 extends BaseTestCase
{
    IntrospectorTestCase2()
    {
        super(""IntrospectorTestCase2"");
    }
    /**
      * Creates a new instance.
      */
    public IntrospectorTestCase2(String name)
    {
        super(name);
    }
    /**
      * Get the containing <code>TestSuite</code>. 
      *
      * @return The <code>TestSuite</code> to run.
      */
    public static junit.framework.Test suite ()
    {
        return new IntrospectorTestCase2();
    }
    public void runTest()
    {
        try
        {
            Velocity.init();
            Method method;
            String result;
            Tester t = new Tester();
            Object[] params = { new Foo(), new Foo() };
            method = RuntimeSingleton.getIntrospector()
                .getMethod( Tester.class, ""find"", params );
            if ( method == null)
                fail(""Returned method was null"");
            result = (String) method.invoke( t, params);
            if ( !result.equals( ""Bar-Bar"" ) )
            {
                fail(""Should have gotten 'Bar-Bar' : recieved '"" + result + ""'"");
            }
            /*
             *  now test for failure due to ambiguity
             */
            method = RuntimeSingleton.getIntrospector()
                .getMethod( Tester2.class, ""find"", params );
            if ( method != null)
                fail(""Introspector shouldn't have found a method as it's ambiguous."");
        }
        catch (Exception e)
        {
            fail( e.toString() );
        }
    }
    public interface Woogie
    {
    }
    public static class Bar implements Woogie
    {
        int i;
    }
    public static class Foo extends Bar
    {
        int j;
    }
    public static class Tester
    {
        public static String find(Woogie w, Object o )
        {
            return ""Woogie-Object"";
        }
        public static String find(Object w, Bar o )
        {
            return ""Object-Bar"";
        }
        public static String find(Bar w, Bar o )
        {
            return ""Bar-Bar"";
        }
        public static String find( Object o )
        {
            return ""Object"";
        }
        public static String find( Woogie o )
        {
            return ""Woogie"";
        }        
    }
    public static class Tester2
    {
        public static String find(Woogie w, Object o )
        {
            return ""Woogie-Object"";
        }
        public static String find(Object w, Bar o )
        {
            return ""Object-Bar"";
        }
        public static String find(Bar w, Object o )
        {
            return ""Bar-Object"";
        }
        public static String find( Object o )
        {
            return ""Object"";
        }
        public static String find( Woogie o )
        {
            return ""Woogie"";
        }        
    }
}
"
org.apache.velocity.test.IntrospectorTestCase3,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.ArrayList;
import java.util.List;
import java.lang.reflect.Method;
import org.apache.velocity.runtime.RuntimeSingleton;
import junit.framework.TestCase;
import junit.framework.Test;
import junit.framework.TestSuite;
/**
 *  Simple introspector test case for primitive problem found in 1.3
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: IntrospectorTestCase3.java,v 1.2.4.1 2004/03/03 23:23:04 geirm Exp $
 */
public class IntrospectorTestCase3 extends BaseTestCase
{
    /**
      * Creates a new instance.
      */
    public IntrospectorTestCase3(String name)
    {
        super(name);
    }
    public static Test suite()
    {
        return new TestSuite(IntrospectorTestCase3.class);
    }
    public void testSimple()
        throws Exception
    {
        Method method;
        String result;
        String type;
        MethodProvider mp = new MethodProvider();
        /*
         * string integer
         */
        Object[] listIntInt = { new ArrayList(), new Integer(1), new Integer(2) };
        Object[] listLongList = { new ArrayList(), new Long(1), new ArrayList() };
        Object[] listLongInt = { new ArrayList(), new Long(1), new Integer(2) };
        Object[] intInt = {  new Integer(1), new Integer(2) };
        Object[] longInt = {  new Long(1), new Integer(2) };
        Object[] longLong = {  new Long(1), new Long(2) };
        method = RuntimeSingleton.getIntrospector().getMethod(
            MethodProvider.class, ""lii"", listIntInt);
        result = (String) method.invoke(mp, listIntInt);
        assertTrue(result.equals(""lii""));
        method = RuntimeSingleton.getIntrospector().getMethod(
            MethodProvider.class, ""ii"", intInt);
        result = (String) method.invoke(mp, intInt);
        assertTrue(result.equals(""ii""));
        method = RuntimeSingleton.getIntrospector().getMethod(
            MethodProvider.class, ""ll"", longInt);
        result = (String) method.invoke(mp, longInt);
        assertTrue(result.equals(""ll""));
        /*
         * test overloading with primitives
         */
        method = RuntimeSingleton.getIntrospector().getMethod(
            MethodProvider.class, ""ll"", longLong);
        result = (String) method.invoke(mp, longLong);
        assertTrue(result.equals(""ll""));
        method = RuntimeSingleton.getIntrospector().getMethod(
            MethodProvider.class, ""lll"", listLongList);
        result = (String) method.invoke(mp, listLongList);
        assertTrue(result.equals(""lll""));
        /*
         *  test invocation with nulls
         */
        Object [] oa = {null, new Integer(0)};
        method = RuntimeSingleton.getIntrospector().getMethod(
            MethodProvider.class, ""lll"", oa );
        result = (String) method.invoke(mp, oa);
        assertTrue(result.equals(""Listl""));
    }
    public static class MethodProvider
    {
        public String ii(int p, int d)
        {
            return ""ii"";
        }
        public String lii(List s, int p, int d)
        {
            return ""lii"";
        }
        public String lll(List s, long p, List d)
        {
            return ""lll"";
        }
        public String lll(List s, long p, int d)
        {
            return ""lli"";
        }
        public String lll(List s, long p)
        {
            return ""Listl"";
        }
        public String ll(long p, long d)
        {
            return ""ll"";
        }
    }
}
"
org.apache.velocity.test.MethodInvocationExceptionTest,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.StringWriter;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.runtime.log.LogSystem;
import org.apache.velocity.exception.MethodInvocationException;
import junit.framework.TestCase;
/**
 * Tests if we can hand Velocity an arbitrary class for logging.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: MethodInvocationExceptionTest.java,v 1.6.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class MethodInvocationExceptionTest extends TestCase 
{
   /**
     * Default constructor.
     */
    public MethodInvocationExceptionTest()
    {
        super(""MethodInvocationExceptionTest"");
        try
        {
            /*
             *  init() Runtime with defaults
             */
            Velocity.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup MethodInvocationExceptionTest : "" + e);
            System.exit(1);
        }            
    }
    public static junit.framework.Test suite ()
    {
        return new MethodInvocationExceptionTest();
    }
    /**
     * Runs the test :
     *
     *  uses the Velocity class to eval a string
     *  which accesses a method that throws an 
     *  exception.
     */
    public void runTest ()
    {
        String template = ""$woogie.doException() boing!"";
        VelocityContext vc = new VelocityContext();
        vc.put(""woogie"", this );
        StringWriter w = new StringWriter();
        try
        {
            Velocity.evaluate( vc,  w, ""test"", template );
            fail(""No exception thrown"");
        }
        catch( MethodInvocationException mie )
        {
            System.out.println(""Caught MIE (good!) :"" );
            System.out.println(""  reference = "" + mie.getReferenceName() );
            System.out.println(""  method    = "" + mie.getMethodName() );
            Throwable t = mie.getWrappedThrowable();
            System.out.println(""  throwable = "" + t );
            if( t instanceof Exception)
            {
                System.out.println(""  exception = "" + ( (Exception) t).getMessage() );
            }
        }
        catch( Exception e)
        {
            fail(""Wrong exception thrown, first test."" + e);
            e.printStackTrace();
        }
        /*
         *  second test - to ensure that methods accessed via get+ construction
         *  also work
         */
        template = ""$woogie.foo boing!"";
        try
        {
            Velocity. evaluate( vc,  w, ""test"", template );
            fail(""No exception thrown, second test."");
        }
        catch( MethodInvocationException mie )
        {
            System.out.println(""Caught MIE (good!) :"" );
            System.out.println(""  reference = "" + mie.getReferenceName() );
            System.out.println(""  method    = "" + mie.getMethodName() );
            Throwable t = mie.getWrappedThrowable();
            System.out.println(""  throwable = "" + t );
            if( t instanceof Exception)
            {
                System.out.println(""  exception = "" + ( (Exception) t).getMessage() );
            }
        }
        catch( Exception e)
        {
            fail(""Wrong exception thrown, second test"");
        }
        template = ""$woogie.Foo boing!"";
        try
        {
            Velocity. evaluate( vc,  w, ""test"", template );
            fail(""No exception thrown, third test."");
        }
        catch( MethodInvocationException mie )
        {
            System.out.println(""Caught MIE (good!) :"" );
            System.out.println(""  reference = "" + mie.getReferenceName() );
            System.out.println(""  method    = "" + mie.getMethodName() );
            Throwable t = mie.getWrappedThrowable();
            System.out.println(""  throwable = "" + t );
            if( t instanceof Exception)
            {
                System.out.println(""  exception = "" + ( (Exception) t).getMessage() );
            }
        }
        catch( Exception e)
        {
            fail(""Wrong exception thrown, third test"");
        }
        template = ""#set($woogie.foo = 'lala') boing!"";
        try
        {
            Velocity. evaluate( vc,  w, ""test"", template );
            fail(""No exception thrown, set test."");
        }
        catch( MethodInvocationException mie )
        {
            System.out.println(""Caught MIE (good!) :"" );
            System.out.println(""  reference = "" + mie.getReferenceName() );
            System.out.println(""  method    = "" + mie.getMethodName() );
            Throwable t = mie.getWrappedThrowable();
            System.out.println(""  throwable = "" + t );
            if( t instanceof Exception)
            {
                System.out.println(""  exception = "" + ( (Exception) t).getMessage() );
            }
        }
        catch( Exception e)
        {
            fail(""Wrong exception thrown, set test"");
        }
    }
    public void doException()
        throws Exception
    {
        throw new NullPointerException();
    }
    public void getFoo()
        throws Exception
    {
        throw new Exception(""Hello from getFoo()"" );
    }
    public void  setFoo( String foo )
        throws Exception
    {
        throw new Exception(""Hello from setFoo()"");
    }
}
"
org.apache.velocity.test.MiscTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import junit.framework.TestCase;
import junit.framework.Test;
import org.apache.velocity.util.StringUtils;
/**
 * Test case for any miscellaneous stuff.  If it isn't big, and doesn't fit
 * anywhere else, it goes here
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: MiscTestCase.java,v 1.1.8.1 2004/03/03 23:23:04 geirm Exp $
 */
public class MiscTestCase extends BaseTestCase
{
    public MiscTestCase()
    {
        super(""MiscTestCase"");
    }
    public MiscTestCase (String name)
    {
        super(name);
    }
    public static Test suite ()
    {
        return new MiscTestCase();
    }
    public void runTest()
    {
        /*
         *  some StringUtils tests
         */
        String eol = ""XY"";
        String arg = ""XY"";
        String res = StringUtils.chop(arg, 1, eol );
        assertTrue( ""Test 1"", res.equals("""") );
        arg = ""X"";
        res = StringUtils.chop( arg, 1, eol );
        assertTrue( ""Test 2"", res.equals("""") );
        arg = ""ZXY"";
        res = StringUtils.chop( arg, 1, eol );
        assertTrue( ""Test 3"", res.equals(""Z"") );
        arg = ""Hello!"";
        res = StringUtils.chop( arg, 2, eol );
        assertTrue( ""Test 4"", res.equals(""Hell""));
    }
}
"
org.apache.velocity.test.MultiLoaderTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.io.File;
import java.util.Properties;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.runtime.VelocimacroFactory;
import junit.framework.TestCase;
/**
 * Load templates from the Classpath.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:daveb@miceda-data.com"">Dave Bryson</a>
 * @version $Id: MultiLoaderTestCase.java,v 1.4.8.1 2004/03/03 23:23:04 geirm Exp $
 */
public class MultiLoaderTestCase extends BaseTestCase
{
     /**
     * VTL file extension.
     */
    private static final String TMPL_FILE_EXT = ""vm"";
    /**
     * Comparison file extension.
     */
    private static final String CMP_FILE_EXT = ""cmp"";
    /**
     * Comparison file extension.
     */
    private static final String RESULT_FILE_EXT = ""res"";
    /**
     * Results relative to the build directory.
     */
    private static final String RESULTS_DIR = ""../test/multiloader/results"";
    /**
     * Path for templates. This property will override the
     * value in the default velocity properties file.
     */
    private final static String FILE_RESOURCE_LOADER_PATH = ""../test/multiloader"";
    /**
     * Results relative to the build directory.
     */
    private static final String COMPARE_DIR = ""../test/multiloader/compare"";
    /**
     * Default constructor.
     */
    public MultiLoaderTestCase()
    {
        super(""MultiLoaderTestCase"");
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            /*
             * Set up the file loader.
             */
            Velocity.setProperty(Velocity.RESOURCE_LOADER, ""file"");
            Velocity.setProperty(
                Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
            Velocity.addProperty(Velocity.RESOURCE_LOADER, ""classpath"");
            Velocity.addProperty(Velocity.RESOURCE_LOADER, ""jar"");
            /*
             *  Set up the classpath loader.
             */
            Velocity.setProperty(
                ""classpath."" + Velocity.RESOURCE_LOADER + "".class"",
                    ""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
            Velocity.setProperty(
                ""classpath."" + Velocity.RESOURCE_LOADER + "".cache"", ""false"");
            Velocity.setProperty(
                ""classpath."" + Velocity.RESOURCE_LOADER + "".modificationCheckInterval"",
                    ""2"");
            /*
             *  setup the Jar loader
             */
            Velocity.setProperty(
                                 ""jar."" + Velocity.RESOURCE_LOADER + "".class"",
                                 ""org.apache.velocity.runtime.resource.loader.JarResourceLoader"");
            Velocity.setProperty( ""jar."" + Velocity.RESOURCE_LOADER + "".path"",  
                                  ""jar:file:"" + FILE_RESOURCE_LOADER_PATH + ""/test2.jar"" );
            Velocity.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup MultiLoaderTestCase!"");
            e.printStackTrace();
            System.exit(1);
        }            
    }
    public static junit.framework.Test suite ()
    {
        return new MultiLoaderTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            /*
             *  lets ensure the results directory exists
             */
            assureResultsDirectoryExists(RESULTS_DIR);
            /*
             * Template to find with the file loader.
             */
            Template template1 = Velocity.getTemplate(
                getFileName(null, ""path1"", TMPL_FILE_EXT));
            /*
             * Template to find with the classpath loader.
             */
            Template template2 = Velocity.getTemplate(
                getFileName(null, ""template/test1"", TMPL_FILE_EXT));
            /*
             * Template to find with the jar loader
             */
            Template template3 = Velocity.getTemplate(
               getFileName(null, ""template/test2"", TMPL_FILE_EXT));
            /*
             * and the results files
             */
            FileOutputStream fos1 = 
                new FileOutputStream (
                    getFileName(RESULTS_DIR, ""path1"", RESULT_FILE_EXT));
            FileOutputStream fos2 = 
                new FileOutputStream (
                    getFileName(RESULTS_DIR, ""test2"", RESULT_FILE_EXT));
            FileOutputStream fos3 = 
                new FileOutputStream (
                    getFileName(RESULTS_DIR, ""test3"", RESULT_FILE_EXT));
            Writer writer1 = new BufferedWriter(new OutputStreamWriter(fos1));
            Writer writer2 = new BufferedWriter(new OutputStreamWriter(fos2));
            Writer writer3 = new BufferedWriter(new OutputStreamWriter(fos3));
            /*
             *  put the Vector into the context, and merge both
             */
            VelocityContext context = new VelocityContext();
            template1.merge(context, writer1);
            writer1.flush();
            writer1.close();
            template2.merge(context, writer2);
            writer2.flush();
            writer2.close();
            template3.merge(context, writer3);
            writer3.flush();
            writer3.close();
            if (!isMatch(RESULTS_DIR,COMPARE_DIR,""path1"",RESULT_FILE_EXT,CMP_FILE_EXT))
            {
                fail(""Output incorrect for FileResourceLoader test."");
            }
            if (!isMatch(RESULTS_DIR,COMPARE_DIR,""test2"",RESULT_FILE_EXT,CMP_FILE_EXT) )
            {
                fail(""Output incorrect for ClasspathResourceLoader test."");
            }
            if( !isMatch(RESULTS_DIR,COMPARE_DIR,""test3"",RESULT_FILE_EXT,CMP_FILE_EXT))
            {
                fail(""Output incorrect for JarResourceLoader test."");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.MultipleFileResourcePathTest,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.io.File;
import java.util.Properties;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.runtime.VelocimacroFactory;
import junit.framework.TestCase;
/**
 * Multiple paths in the file resource loader.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: MultipleFileResourcePathTest.java,v 1.8.8.1 2004/03/03 23:23:04 geirm Exp $
 */
public class MultipleFileResourcePathTest extends BaseTestCase
{
     /**
     * VTL file extension.
     */
    private static final String TMPL_FILE_EXT = ""vm"";
    /**
     * Comparison file extension.
     */
    private static final String CMP_FILE_EXT = ""cmp"";
    /**
     * Comparison file extension.
     */
    private static final String RESULT_FILE_EXT = ""res"";
    /**
     * Path for templates. This property will override the
     * value in the default velocity properties file.
     */
    private final static String FILE_RESOURCE_LOADER_PATH1 = ""../test/multi/path1"";
    /**
     * Path for templates. This property will override the
     * value in the default velocity properties file.
     */
    private final static String FILE_RESOURCE_LOADER_PATH2 = ""../test/multi/path2"";
    /**
     * Results relative to the build directory.
     */
    private static final String RESULTS_DIR = ""../test/multi/results"";
    /**
     * Results relative to the build directory.
     */
    private static final String COMPARE_DIR = ""../test/multi/compare"";
    /**
     * Default constructor.
     */
    MultipleFileResourcePathTest()
    {
        super(""MultipleFileResourcePathTest"");
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            Velocity.addProperty(
                Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH1);
            Velocity.addProperty(
                Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH2);
            Velocity.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup MultipleFileResourcePathTest!"");
            e.printStackTrace();
            System.exit(1);
        }            
    }
    public static junit.framework.Test suite ()
    {
        return new MultipleFileResourcePathTest();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            Template template1 = RuntimeSingleton.getTemplate(
                getFileName(null, ""path1"", TMPL_FILE_EXT));
            Template template2 = RuntimeSingleton.getTemplate(
                getFileName(null, ""path2"", TMPL_FILE_EXT));
            FileOutputStream fos1 = 
                new FileOutputStream (
                    getFileName(RESULTS_DIR, ""path1"", RESULT_FILE_EXT));
            FileOutputStream fos2 = 
                new FileOutputStream (
                    getFileName(RESULTS_DIR, ""path2"", RESULT_FILE_EXT));
            Writer writer1 = new BufferedWriter(new OutputStreamWriter(fos1));
            Writer writer2 = new BufferedWriter(new OutputStreamWriter(fos2));
            /*
             *  put the Vector into the context, and merge both
             */
            VelocityContext context = new VelocityContext();
            template1.merge(context, writer1);
            writer1.flush();
            writer1.close();
            template2.merge(context, writer2);
            writer2.flush();
            writer2.close();
            if (!isMatch(RESULTS_DIR, COMPARE_DIR, ""path1"", 
                    RESULT_FILE_EXT, CMP_FILE_EXT) ||
                !isMatch(RESULTS_DIR, COMPARE_DIR, ""path2"", 
                    RESULT_FILE_EXT, CMP_FILE_EXT))
            {
                fail(""Output incorrect."");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.ParserTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.exception.ParseErrorException;
import java.io.StringWriter;
/**
 *  More specific parser tests where just templating
 *  isn't enough.
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: ParserTestCase.java,v 1.1.4.1 2004/03/03 23:23:04 geirm Exp $
 */
public class ParserTestCase extends TestCase
{
    public ParserTestCase(String testName)
    {
        super(testName);
    }
    public static Test suite()
    {
       return new TestSuite(ParserTestCase.class);
    }
    /**
     *  Test to make sure that using '=' in #if() throws a PEE
     */
    public void testEquals()
        throws Exception
    {
        VelocityEngine ve = new VelocityEngine();
        ve.init();
        /*
         *  this should parse fine -> uses ==
         */
        String template = ""#if($a == $b) foo #end"";
        ve.evaluate(new VelocityContext(), new StringWriter(), ""foo"", template);
        /*
         *  this should throw an exception
         */
        template = ""#if($a = $b) foo #end"";
        try
        {
            ve.evaluate(new VelocityContext(), new StringWriter(), ""foo"", template);
            assertTrue(false);
        }
        catch(ParseErrorException pe)
        {
        }
    }
    /**
     *  Test to see if we force the first arg to #macro() to be a word
     */
    public void testMacro()
        throws Exception
    {
        VelocityEngine ve = new VelocityEngine();
        ve.init();
        /*
         * this should work
         */
        String template = ""#macro(foo) foo #end"";
        ve.evaluate(new VelocityContext(), new StringWriter(), ""foo"", template);
         /*
         *  this should throw an exception
         */
        template = ""#macro($x) foo #end"";
        try
        {
            ve.evaluate(new VelocityContext(), new StringWriter(), ""foo"", template);
            assertTrue(false);
        }
        catch(ParseErrorException pe)
        {
        }
    }
    /**
     *  Test to see if don't tolerage passing word tokens in anything but the
     *  0th arg to #macro() and the 1th arg to foreach()
     */
    public void testArgs()
        throws Exception
    {
        VelocityEngine ve = new VelocityEngine();
        ve.init();
        /*
         * this should work
         */
        String template = ""#macro(foo) foo #end"";
        ve.evaluate(new VelocityContext(), new StringWriter(), ""foo"", template);
         /*
         *  this should work - spaces intentional
         */
        template = ""#foreach(  $i     in  $woogie   ) end #end"";
        ve.evaluate(new VelocityContext(), new StringWriter(), ""foo"", template);
        /*
        *  this should bomb
        */
       template = ""#macro(   foo $a) $a #end #foo(woogie)"";
        try
        {
            ve.evaluate(new VelocityContext(), new StringWriter(), ""foo"", template);
            assertTrue(false);
        }
        catch(ParseErrorException pe)
        {
            System.out.println(""Caught pee!"");
        }
    }
}
"
org.apache.velocity.test.TemplateTestBase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is a base interface that contains a bunch of static final
 * strings that are of use when testing templates.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: TemplateTestBase.java,v 1.2.14.1 2004/03/03 23:23:04 geirm Exp $
 */
public interface TemplateTestBase
{
    /**
     * VTL file extension.
     */
    public final static String TMPL_FILE_EXT = ""vm"";
    /**
     * Comparison file extension.
     */
    public final static String CMP_FILE_EXT = ""cmp"";
    /**
     * Comparison file extension.
     */
    public final static String RESULT_FILE_EXT = ""res"";
    /**
     * Path for templates. This property will override the
     * value in the default velocity properties file.
     */
    public final static String FILE_RESOURCE_LOADER_PATH = 
                          ""../test/templates"";
    /**
     * Properties file that lists which template tests to run.
     */
    public final static String TEST_CASE_PROPERTIES = 
                          FILE_RESOURCE_LOADER_PATH + ""/templates.properties"";
    /**
     * Results relative to the build directory.
     */
    public final static String RESULT_DIR = 
                          FILE_RESOURCE_LOADER_PATH + ""/results"";
    /**
     * Results relative to the build directory.
     */
    public final static String COMPARE_DIR = 
                          FILE_RESOURCE_LOADER_PATH + ""/compare"";
}
"
org.apache.velocity.test.TemplateTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.HashMap;
import java.util.Vector;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.test.provider.BoolObj;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.app.FieldMethodizer;
import junit.framework.TestCase;
/**
 * Easily add test cases which evaluate templates and check their output.
 *
 * NOTE:
 * This class DOES NOT extend RuntimeTestCase because the TemplateTestSuite
 * already initializes the Velocity runtime and adds the template
 * test cases. Having this class extend RuntimeTestCase causes the
 * Runtime to be initialized twice which is not good. I only discovered
 * this after a couple hours of wondering why all the properties
 * being setup were ending up as Vectors. At first I thought it
 * was a problem with the Configuration class, but the Runtime
 * was being initialized twice: so the first time the property
 * is seen it's stored as a String, the second time it's seen
 * the Configuration class makes a Vector with both Strings.
 * As a result all the getBoolean(property) calls were failing because
 * the Configurations class was trying to create a Boolean from
 * a Vector which doesn't really work that well. I have learned
 * my lesson and now have to add some code to make sure the
 * Runtime isn't initialized more then once :-)
 *
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: TemplateTestCase.java,v 1.34.8.1 2004/03/03 23:23:04 geirm Exp $
 */
public class TemplateTestCase extends BaseTestCase implements TemplateTestBase
{
    /**
     * The base file name of the template and comparison file (i.e. array for 
     * array.vm and array.cmp).
     */
    protected String baseFileName;
    private TestProvider provider;
    private ArrayList al;
    private Hashtable h;
    private VelocityContext context;
    private VelocityContext context1;
    private VelocityContext context2;
    private Vector vec;
    /**
     * Creates a new instance.
     *
     * @param baseFileName The base name of the template and comparison file to 
     *                     use (i.e. array for array.vm and array.cmp).
     */
    public TemplateTestCase (String baseFileName)
    {
        super(getTestCaseName(baseFileName));
        this.baseFileName = baseFileName;
    }
    public static junit.framework.Test suite()
    {
        return new TemplateTestSuite();
    }
    /**
     * Sets up the test.
     */
    protected void setUp ()
    {
        provider = new TestProvider();
        al = provider.getCustomers();
        h = new Hashtable();
        h.put(""Bar"", ""this is from a hashtable!"");
        h.put(""Foo"", ""this is from a hashtable too!"");
        /*
         *  lets set up a vector of objects to test late introspection. See ASTMethod.java
         */
        vec = new Vector();
        vec.addElement(new String(""string1""));
        vec.addElement(new String(""string2""));
        /*
         *  set up 3 chained contexts, and add our data 
         *  throught the 3 of them.
         */
        context2 = new VelocityContext();
        context1 = new VelocityContext( context2 );
        context = new VelocityContext( context1 );
        context.put(""provider"", provider);
        context1.put(""name"", ""jason"");
        context2.put(""providers"", provider.getCustomers2());
        context.put(""list"", al);
        context1.put(""hashtable"", h);
        context2.put(""hashmap"", new HashMap());
        context2.put(""search"", provider.getSearch());
        context.put(""relatedSearches"", provider.getRelSearches());
        context1.put(""searchResults"", provider.getRelSearches());
        context2.put(""stringarray"", provider.getArray());
        context.put(""vector"", vec );
        context.put(""mystring"", new String());
        context.put(""runtime"", new FieldMethodizer( ""org.apache.velocity.runtime.RuntimeSingleton"" ));
        context.put(""fmprov"", new FieldMethodizer( provider ));
        context.put(""Floog"", ""floogie woogie"");
        context.put(""boolobj"", new BoolObj() );
        /*
         *  we want to make sure we test all types of iterative objects
         *  in #foreach()
         */
        Object[] oarr = { ""a"",""b"",""c"",""d"" } ;
       int intarr[] = { 10, 20, 30, 40, 50 };
        context.put( ""collection"", vec );
        context2.put(""iterator"", vec.iterator());
        context1.put(""map"", h );
        context.put(""obarr"", oarr );
        context.put(""enumerator"", vec.elements());
        context.put(""intarr"", intarr );
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            Template template = RuntimeSingleton.getTemplate
                (getFileName(null, baseFileName, TMPL_FILE_EXT));
            assureResultsDirectoryExists(RESULT_DIR);
            /* get the file to write to */
            FileOutputStream fos = 
                new FileOutputStream (getFileName(
                    RESULT_DIR, baseFileName, RESULT_FILE_EXT));
            Writer writer = new BufferedWriter(new OutputStreamWriter(fos));
            /* process the template */
            template.merge( context, writer);
            /* close the file */
            writer.flush();
            writer.close();
            if (!isMatch(RESULT_DIR,COMPARE_DIR,baseFileName,
                    RESULT_FILE_EXT,CMP_FILE_EXT))
            {
                fail(""Processed template did not match expected output"");
            }
        }
        catch (Exception e)
        {
            System.out.println(""EXCEPTION : "" + e );
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.TemplateTestSuite,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.FileInputStream;
import java.util.Properties;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import org.apache.velocity.app.Velocity;
import junit.framework.TestSuite;
/**
 * Test suite for Templates.
 *
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: TemplateTestSuite.java,v 1.6.8.1 2004/03/03 23:23:04 geirm Exp $
 */
public class TemplateTestSuite extends TestSuite implements TemplateTestBase
{
    private Properties testProperties;
    /**
     * Creates an instace of the Apache Velocity test suite.
     */
    public TemplateTestSuite()
    {
        try
        {
            Velocity.setProperty(
                Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
            Velocity.setProperty(Velocity.RUNTIME_LOG_ERROR_STACKTRACE, ""true"");
            Velocity.setProperty(Velocity.RUNTIME_LOG_WARN_STACKTRACE, ""true"");
            Velocity.setProperty(Velocity.RUNTIME_LOG_INFO_STACKTRACE, ""true"");
            Velocity.init();
            testProperties = new Properties();
            testProperties.load(new FileInputStream(TEST_CASE_PROPERTIES));
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup TemplateTestSuite!"");
            e.printStackTrace();
            System.exit(1);
        }            
        addTemplateTestCases();
    }
    /**
     * Adds the template test cases to run to this test suite.  Template test
     * cases are listed in the <code>TEST_CASE_PROPERTIES</code> file.
     */
    private void addTemplateTestCases()
    {
        String template;
        for (int i = 1 ;; i++)
        {
            template = testProperties.getProperty(getTemplateTestKey(i));
            if (template != null)
            {
                System.out.println(""Adding TemplateTestCase : "" + template);
                addTest(new TemplateTestCase(template));
            }
            else
            {
                // Assume we're done adding template test cases.
                break;
            }
        }
    }
    /**
     * Macro which returns the properties file key for the specified template
     * test number.
     *
     * @param nbr The template test number to return a property key for.
     * @return    The property key.
     */
    private static final String getTemplateTestKey(int nbr)
    {
        return (""test.template."" + nbr);
    }
}
"
org.apache.velocity.test.TexenClasspathTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.util.StringUtils;
import junit.framework.TestCase;
/**
 * This is a test case for Texen. Simply executes a simple
 * generative task and compares the output.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: TexenClasspathTestCase.java,v 1.3.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class TexenClasspathTestCase 
    extends BaseTestCase
{
    /**
     * Directory where results are generated.
     */
    private static final String RESULTS_DIR = ""../test/texen-classpath/results"";
    /**
     * Directory where comparison output is stored.
     */
    private static final String COMPARE_DIR = ""../test/texen-classpath/compare"";
    /**
     * Creates a new instance.
     *
     */
    public TexenClasspathTestCase()
    {
        super(""TexenClasspathTestCase"");
    }
    public static junit.framework.Test suite()
    {
        return new TexenClasspathTestCase();
    }
    /**
     * Sets up the test.
     */
    protected void setUp ()
    {
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            if (!isMatch(RESULTS_DIR,COMPARE_DIR,""TurbineWeather"",""java"",""java"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""TurbineWeatherService"",""java"",""java"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""WeatherService"",""java"",""java"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""book"",""txt"",""txt"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""Test"",""txt"",""txt""))
            {
                fail(""Output is incorrect!"");
            }
        }            
        catch(Exception e)
        {
            /*
             * do nothing.
             */
        }
    }
}
"
org.apache.velocity.test.TexenTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.util.StringUtils;
import junit.framework.TestCase;
/**
 * This is a test case for Texen. Simply executes a simple
 * generative task and compares the output.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: TexenTestCase.java,v 1.6.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class TexenTestCase extends BaseTestCase
{
    /**
     * Directory where results are generated.
     */
    private static final String RESULTS_DIR = ""../test/texen/results"";
    /**
     * Directory where comparison output is stored.
     */
    private static final String COMPARE_DIR = ""../test/texen/compare"";
    /**
     * Creates a new instance.
     *
     */
    public TexenTestCase()
    {
        super(""TexenTestCase"");
    }
    public static junit.framework.Test suite()
    {
        return new TexenTestCase();
    }
    /**
     * Sets up the test.
     */
    protected void setUp ()
    {
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        try
        {
            assureResultsDirectoryExists(RESULTS_DIR);
            if (!isMatch(RESULTS_DIR,COMPARE_DIR,""TurbineWeather"",""java"",""java"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""TurbineWeatherService"",""java"",""java"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""WeatherService"",""java"",""java"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""book"",""txt"",""txt"") ||
                !isMatch(RESULTS_DIR,COMPARE_DIR,""Test"",""txt"",""txt""))
            {
                fail(""Output is incorrect!"");
            }
        }            
        catch(Exception e)
        {
            /*
             * do nothing.
             */
        }
    }
}
"
org.apache.velocity.test.VelocimacroTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.util.Vector;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.app.Velocity;
import junit.framework.TestCase;
/**
 * This class tests strange Velocimacro issues.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelocimacroTestCase.java,v 1.1.10.1 2004/03/03 23:23:04 geirm Exp $
 */
public class VelocimacroTestCase extends TestCase 
{
    private String template1 = ""#macro(foo $a)$a#end #macro(bar $b)#foo($b)#end #foreach($i in [1..3])#bar($i)#end"";
    private String result1 = ""  123"";
    public VelocimacroTestCase()
    {
        super(""VelocimacroTestCase"");
        try
        {
            /*
             *  setup local scope for templates
             */
            Velocity.setProperty( Velocity.VM_PERM_INLINE_LOCAL, Boolean.TRUE);
            Velocity.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup VelocimacroTestCase!"");
            System.exit(1);
        }
    }
    public static junit.framework.Test suite()
    {
        return new VelocimacroTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        VelocityContext context = new VelocityContext();
        try
        {
            StringWriter writer = new StringWriter();
            Velocity.evaluate(context, writer, ""vm_chain1"", template1);
            String out = writer.toString();
            if( !result1.equals( out ) )
            {
                fail(""output incorrect."");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.VelocityAppTestCase,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.util.Vector;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.app.Velocity;
import junit.framework.TestCase;
/**
 * This class is intended to test the app.Velocity.java class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: VelocityAppTestCase.java,v 1.3.14.1 2004/03/03 23:23:04 geirm Exp $
 */
public class VelocityAppTestCase extends BaseTestCase implements TemplateTestBase
{
    private StringWriter compare1 = new StringWriter();
    private String input1 = ""My name is $name -> $Floog"";
    private String result1 = ""My name is jason -> floogie woogie"";
    public VelocityAppTestCase()
    {
        super(""VelocityAppTestCase"");
        try
        {
            Velocity.setProperty(
	           Velocity.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
            Velocity.init();
        }
        catch (Exception e)
        {
            System.err.println(""Cannot setup VelocityAppTestCase!"");
            e.printStackTrace();
            System.exit(1);
        }
    }
    public static junit.framework.Test suite()
    {
        return new VelocityAppTestCase();
    }
    /**
     * Runs the test.
     */
    public void runTest ()
    {
        VelocityContext context = new VelocityContext();
        context.put(""name"", ""jason"");
        context.put(""Floog"", ""floogie woogie"");
        try
        {
            Velocity.evaluate(context, compare1, ""evaltest"", input1);
/*
            FIXME: Not tested right now.
            StringWriter result2 = new StringWriter();
            Velocity.mergeTemplate(""mergethis.vm"",  context, result2);
            StringWriter result3 = new StringWriter();
            Velocity.invokeVelocimacro(""floog"", ""test"", new String[2], 
                                        context, result3);
*/
            if (!result1.equals(compare1.toString()))
            {
                fail(""Output incorrect."");
            }
        }
        catch (Exception e)
        {
            fail(e.getMessage());
        }
    }
}
"
org.apache.velocity.test.VelocityServletTest,"package org.apache.velocity.test;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.InputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;
import java.util.Properties;
import javax.servlet.RequestDispatcher;
import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.servlet.VelocityServlet;
import junit.framework.TestCase;
/**
 * Tests our VelocityServlet implementation.
 *
 * @author <a href=""mailto:dlr@apache.org"">Daniel Rall</a>
 */
public class VelocityServletTest extends TestCase
{
    /**
     * Default constructor.
     */
    public VelocityServletTest()
    {
        super(""VelocityServletTest"");
    }
    public static junit.framework.Test suite ()
    {
        return new VelocityServletTest();
    }
    /**
     * Runs the test.
     */
    public void runTest()
    {
        /*
         * Assure we have the encoding we think we should.
         */
        MockVelocityServlet servlet = new MockVelocityServlet();
        try
        {
            servlet.init(new MockServletConfig());
        }
        catch (ServletException e)
        {
            e.printStackTrace();
        }
        System.out.println(RuntimeConstants.OUTPUT_ENCODING + ""="" +
                           RuntimeSingleton.getProperty
                           (RuntimeConstants.OUTPUT_ENCODING));
        HttpServletResponse res = new MockHttpServletResponse();
        servlet.visibleSetContentType(null, res);
        assertEquals(""Character encoding not set to UTF-8"",
                     ""UTF-8"", res.getCharacterEncoding());
    }
    class MockVelocityServlet extends VelocityServlet
    {
        void visibleSetContentType(HttpServletRequest req,
                                   HttpServletResponse res)
        {
            setContentType(req, res);
        }
        protected Properties loadConfiguration(ServletConfig config)
            throws IOException
        {
            Properties p = new Properties();
            p.setProperty(RuntimeConstants.OUTPUT_ENCODING, ""UTF-8"");
            return p;
        }
        public ServletConfig getServletConfig()
        {
            return new MockServletConfig();
        }
    }
    static class MockServletConfig implements ServletConfig
    {
        public String getInitParameter(String ignored)
        {
            return null;
        }
        public Enumeration getInitParameterNames()
        {
            return null;
        }
        public ServletContext getServletContext()
        {
            return new MockServletContext();
        }
        public String getServletName()
        {
            return ""VelocityServlet"";
        }            
    }
    static class MockServletContext implements ServletContext
    {
        public Object getAttribute(String ignored)
        {
            return null;
        }
        public Enumeration getAttributeNames()
        {
            return null;
        }
        public ServletContext getContext(String ignored)
        {
            return this;
        }
        public String getInitParameter(String ignored)
        {
            return null;
        }
        public Enumeration getInitParameterNames()
        {
            return null;
        }
        public int getMajorVersion()
        {
            return -1;
        }
        public String getMimeType(String ignored)
        {
            return null;
        }
        public int getMinorVersion()
        {
            return -1;
        }
        public RequestDispatcher getNamedDispatcher(String ignored)
        {
            return null;
        }
        public String getRealPath(String ignored)
        {
            return null;
        }
        public RequestDispatcher getRequestDispatcher(String ignored)
        {
            return null;
        }
        public URL getResource(String ignored)
            throws MalformedURLException
        {
            return null;
        }
        public InputStream getResourceAsStream(String ignored)
        {
            return null;
        }
        public String getServerInfo()
        {
            return ""Velocity Test Suite"";
        }
        public Servlet getServlet(String ignored)
            throws ServletException
        {
            return null;
        }
        public Enumeration getServletNames()
        {
            return null;
        }
        public Enumeration getServlets()
        {
            return null;
        }
        public void log(Exception e, String msg)
        {
        }
        public void log(String msg)
        {
        }
        public void log(String msg, Throwable t)
        {
        }
        public void removeAttribute(String name)
        {
        }
        public void setAttribute(String name, Object value)
        {
        }
    }
    static class MockHttpServletResponse implements HttpServletResponse
    {
        private String encoding;
        // ---- ServletResponse implementation -----------------------------
        public void flushBuffer() throws IOException
        {
        }
        public int getBufferSize()
        {
            return -1;
        }
        public String getCharacterEncoding()
        {
            return (encoding != null ? encoding : ""ISO-8859-1"");
        }
        public java.util.Locale getLocale()
        {
            return null;
        }
        public javax.servlet.ServletOutputStream getOutputStream()
            throws IOException
        {
            return null;
        }
        public java.io.PrintWriter getWriter() throws IOException
        {
            return null;
        }
        public boolean isCommitted()
        {
            return false;
        }
        public void reset()
        {
        }
        public void setBufferSize(int i)
        {
        }
        public void setContentLength(int i)
        {
        }
        /**
         * Records the character encoding.
         */
        public void setContentType(String contentType)
        {
            if (contentType != null)
            {
                int index = contentType.lastIndexOf(';') + 1;
                if (0 <= index || index < contentType.length())
                {
                    index = contentType.indexOf(""charset="", index);
                    if (index != -1)
                    {
                        index += 8;
                        this.encoding = contentType.substring(index).trim();
                    }
                }
            }
        }
        public void setLocale(java.util.Locale l)
        {
        }
        // ---- HttpServletResponse implementation ------------------------- 
        public void addCookie(javax.servlet.http.Cookie c)
        {
        }
        public void addDateHeader(String s, long l)
        {
        }
        public void addHeader(String name, String value)
        {
        }
        public void addIntHeader(String name, int value)
        {
        }
        public boolean containsHeader(String name)
        {
            return false;
        }
        public String encodeRedirectURL(String url)
        {
            return url;
        }
        public String encodeRedirectUrl(String url)
        {
            return url;
        }
        public String encodeURL(String url)
        {
            return url;
        }
        public String encodeUrl(String url)
        {
            return url;
        }
        public void sendError(int i) throws IOException
        {
        }
        public void sendError(int i, String s) throws IOException
        {
        }
        public void sendRedirect(String s) throws IOException
        {
        }
        public void setDateHeader(String s, long l)
        {
        }
        public void setHeader(String name, String value)
        {
        }
        public void setIntHeader(String s, int i)
        {
        }
        public void setStatus(int i)
        {
        }
        public void setStatus(int i , String s)
        {
        }
    }
}
"
org.apache.velocity.test.misc.Test,"package org.apache.velocity.test.misc;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.HashMap;
import java.util.Properties;
import java.util.Stack;
import java.util.Vector;
import java.util.Enumeration;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.Template;
import org.apache.velocity.app.FieldMethodizer;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.test.provider.TestProvider;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.app.event.ReferenceInsertionEventHandler;
import org.apache.velocity.app.event.MethodExceptionEventHandler;
import org.apache.velocity.app.event.NullSetEventHandler;
import org.apache.velocity.context.Context;
/**
 * This class the testbed for Velocity. It is used to
 * test all the directives support by Velocity.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Test.java,v 1.34.8.1 2004/03/03 23:23:05 geirm Exp $
 */
public class Test implements ReferenceInsertionEventHandler, 
                             NullSetEventHandler,
                             MethodExceptionEventHandler
{
    /**
     * Cache of writers
     */
    private static Stack writerStack = new Stack();
    public Test(String templateFile, String encoding)
    {
        Writer writer = null;
        TestProvider provider = new TestProvider();
        ArrayList al = provider.getCustomers();
        Hashtable h = new Hashtable();
        /*
         *  put this in to test introspection $h.Bar or $h.get(""Bar"") etc
         */
        h.put(""Bar"", ""this is from a hashtable!"");
        h.put(""Foo"", ""this is from a hashtable too!"");
        /*
         *  adding simple vector with strings for testing late introspection stuff
         */
        Vector v = new Vector();
        String str = ""mystr"";
        v.addElement( new String(""hello"") );
        v.addElement( new String(""hello2"") );
        v.addElement( str );
        try
        {
            /*
             *  this is another way to do properties when initializing Runtime.
             *  make a Properties 
             */
            Properties p = new Properties();
            /*
             *  now, if you want to, load it from a file (or whatever)
             */
            try
            {
                FileInputStream fis =  new FileInputStream( 
                    new File(""velocity.properties"" ));
                if( fis != null)
                    p.load( fis );
            }
            catch (Exception ex)
            {
                /* no worries. no file... */
            }
            /*
             *  iterate out the properties
             */
            for( Enumeration e = p.propertyNames(); e.hasMoreElements(); )
            {
                String el = (String) e.nextElement();
                Velocity.setProperty( el, p.getProperty( el ) );
            }
            /*
             *  add some individual properties if you wish
             */
            Velocity.setProperty(Velocity.RUNTIME_LOG_ERROR_STACKTRACE, ""true"");
            Velocity.setProperty(Velocity.RUNTIME_LOG_WARN_STACKTRACE, ""true"");
            Velocity.setProperty(Velocity.RUNTIME_LOG_INFO_STACKTRACE, ""true"");
            /*
             *  use an alternative logger.  Set it up here and pass it in.
             */
            //            SimpleLogSystem sls = new SimpleLogSystem(""velocity_simple.log"");
            // Velocity.setProperty(Velocity.RUNTIME_LOG_LOGSYSTEM, sls );
            /*
             *  and now call init
             */
            Velocity.init();
            /*
             *  now, do what we want to do.  First, get the Template
             */
            if (templateFile == null)
            {
                templateFile = ""examples/example.vm"";
            }                
            Template template = null;
            try 
            {
                template = RuntimeSingleton.getTemplate(templateFile, encoding);
            }
            catch( ResourceNotFoundException rnfe )
            {
                System.out.println(""Test : RNFE : Cannot find template "" + templateFile );
            }
            catch( ParseErrorException pee )
            {
                System.out.println(""Test : Syntax error in template "" + templateFile + "":"" + pee );
            }
            /*
             * now, make a Context object and populate it.
             */
            VelocityContext context = new VelocityContext();
            context.put(""provider"", provider);
            context.put(""name"", ""jason"");
            context.put(""providers"", provider.getCustomers2());
            context.put(""list"", al);
            context.put(""hashtable"", h);
            context.put(""search"", provider.getSearch());
            context.put(""relatedSearches"", provider.getRelSearches());
            context.put(""searchResults"", provider.getRelSearches());
            context.put(""menu"", provider.getMenu());
            context.put(""stringarray"", provider.getArray());
            context.put(""vector"", v);
            context.put(""mystring"", new String());
            context.put(""hashmap"", new HashMap() );
            context.put(""runtime"", new FieldMethodizer( ""org.apache.velocity.runtime.RuntimeSingleton"" ));
            context.put(""fmprov"", new FieldMethodizer( provider ));
            context.put(""Floog"", ""floogie woogie"");
            context.put(""geirstring"", str );
            context.put(""mylong"", new Long(5) );
            /*
             *  we want to make sure we test all types of iterative objects
             *  in #foreach()
             */
            int intarr[] = { 10, 20, 30, 40, 50 };
            Object[] oarr = { ""a"",""b"",""c"",""d"" } ;
            context.put( ""collection"", v );
            context.put(""iterator"", v.iterator());
            context.put(""map"", h );
            context.put(""obarr"", oarr );
            context.put(""intarr"", intarr );
            String stest = "" My name is $name -> $Floog"";
            StringWriter w = new StringWriter();
            //            Velocity.evaluate( context, w, ""evaltest"",stest );
            //            System.out.println(""Eval = "" + w );
            w = new StringWriter();
            //Velocity.mergeTemplate( ""mergethis.vm"",  context, w );
            //System.out.println(""Merge = "" + w );
            w = new StringWriter();
            //Velocity.invokeVelocimacro( ""floog"", ""test"", new String[2],  context,  w );
            //System.out.println(""Invoke = "" + w );
            /*
             *  event cartridge stuff
             */
            EventCartridge ec = new EventCartridge();
            ec.addEventHandler(this);
            ec.attachToContext( context );
            /*
             *  make a writer, and merge the template 'against' the context
             */
            VelocityContext vc = new VelocityContext( context );
            if( template != null)
            {
                writer = new BufferedWriter(new OutputStreamWriter(System.out, encoding));
                template.merge( vc , writer);
                writer.flush();
                writer.close();
            }
        }
        catch( MethodInvocationException mie )
        {
            System.out.println(""MIE : "" + mie );
        }
        catch( Exception e )
        {
            RuntimeSingleton.error( ""Test- exception : "" + e);
            e.printStackTrace();
        }
    }
    public Object referenceInsert( String reference, Object value  )
    {
        if (value != null)
            ; // System.out.println(""Woo! referenceInsert : "" + reference + "" = "" + value.toString() );
        return value;
    }
    public boolean shouldLogOnNullSet( String lhs, String rhs )
    {
        //        System.out.println(""Woo2! nullSetLogMessage : "" + lhs + "" :  RHS = "" + rhs);
        if (lhs.equals(""$woogie""))
            return false;
        return true;
    }
   public Object methodException( Class claz, String method, Exception e )
         throws Exception
    {
        if (method.equals(""getThrow""))
            return ""I should have thrown"";
        throw e;
    }
    public static void main(String[] args)
    {
        Test t;
        String encoding = ""ISO-8859-1"";
        if( args.length > 1 )
            encoding = args[1];
        t = new Test(args[0], encoding);
    }
}
"
org.apache.velocity.test.provider.BoolObj,"package org.apache.velocity.test.provider;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  simple class to test boolean property
 *  introspection - can't use TestProvider
 *  as there is a get( String )
 *  and that comes before isProperty
 *  in the search pattern
 *
 *  @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 */
public class BoolObj
{
    public boolean isBoolean()
    {
        return true;
    }
    /*
     *  not isProperty as it's not
     *  boolean return valued...
     */
    public String  isNotboolean()
    {
        return ""hello"";
    }
}
"
org.apache.velocity.test.provider.Child,"package org.apache.velocity.test.provider;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Rudimentary class used in the testbed to test
 * introspection with subclasses of a particular
 * class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Child.java,v 1.5.8.1 2004/03/03 23:23:06 geirm Exp $
 */
public class Child extends Person
{
    public String getName()
    {
        return ""Child"";
    }        
}
"
org.apache.velocity.test.provider.Person,"package org.apache.velocity.test.provider;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Rudimentary class used in the testbed to test
 * introspection with subclasses of a particular
 * class.
 *
 * This class need to be greatly extended to
 * be useful :-)
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Person.java,v 1.5.8.1 2004/03/03 23:23:06 geirm Exp $
 */
public class Person
{
    public String getName()
    {
        return ""Person"";
    }        
}
"
org.apache.velocity.test.provider.TestProvider,"package org.apache.velocity.test.provider;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.*;
/**
 * This class is used by the testbed. Instances of the class
 * are fed into the context that is set before the AST
 * is traversed and dynamic content generated.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: TestProvider.java,v 1.21.8.1 2004/03/03 23:23:06 geirm Exp $
 */
public class TestProvider
{
    String title = ""lunatic"";
    boolean state;
    Object ob = null;
    public static String PUB_STAT_STRING = ""Public Static String"";
    int stateint = 0;
    public String getName()
    {
        return ""jason"";
    }
    public Stack getStack()
    {
        Stack stack = new Stack();
        stack.push(""stack element 1"");
        stack.push(""stack element 2"");
        stack.push(""stack element 3"");
        return stack;
    }
    public List getEmptyList()
    {
        List list = new ArrayList();
        return list;
    }
    public List getList()
    {
        List list = new ArrayList();
        list.add(""list element 1"");
        list.add(""list element 2"");
        list.add(""list element 3"");
        return list;
    }
    public Hashtable getSearch()
    {
        Hashtable h = new Hashtable();
        h.put(""Text"", ""this is some text"");
        h.put(""EscText"", ""this is escaped text"");
        h.put(""Title"", ""this is the title"");
        h.put(""Index"", ""this is the index"");
        h.put(""URL"", ""http://periapt.com"");
        ArrayList al = new ArrayList();
        al.add(h);
        h.put(""RelatedLinks"", al);
        return h;
    }        
    public Hashtable getHashtable()
    {
        Hashtable h = new Hashtable();
        h.put(""key0"", ""value0"");
        h.put(""key1"", ""value1"");
        h.put(""key2"", ""value2"");
        return h;
    }        
    public ArrayList getRelSearches()
    {
        ArrayList al = new ArrayList();
        al.add(getSearch());
        return al;
    }        
    public String getTitle()
    {
        return title;
    }
    public void setTitle(String title)
    {
        this.title = title;
    }
    public Object[] getMenu()
    {
        //ArrayList al = new ArrayList();
        Object[] menu = new Object[3];
        for (int i = 0; i < 3; i++)
        {
            Hashtable item = new Hashtable();
            item.put(""id"", ""item"" + Integer.toString(i+1));
            item.put(""name"", ""name"" + Integer.toString(i+1));
            item.put(""label"", ""label"" + Integer.toString(i+1));
            //al.add(item);
            menu[i] = item;
        }            
        //return al;
        return menu;
    }
    public ArrayList getCustomers()
    {
        ArrayList list = new ArrayList();
        list.add(""ArrayList element 1"");
        list.add(""ArrayList element 2"");
        list.add(""ArrayList element 3"");
        list.add(""ArrayList element 4"");
        return list;
    }
    public ArrayList getCustomers2()
    {
        ArrayList list = new ArrayList();
        list.add(new TestProvider());
        list.add(new TestProvider());
        list.add(new TestProvider());
        list.add(new TestProvider());
        return list;
    }
    public Object me()
    {
        return this;
    }        
    public String toString()
    {
        return (""test provider"");
    }        
    public Vector getVector()
    {
        Vector list = new Vector();
        list.addElement(""vector element 1"");
        list.addElement(""vector element 2"");
        return list;
    }
    public String[] getArray()
    {
        String[] strings = new String[2];
        strings[0] = ""first element"";
        strings[1] = ""second element"";
        return strings;
    }
    public boolean theAPLRules()
    {
        return true;
    }
    public boolean getStateTrue()
    {
        return true;
    }
    public boolean getStateFalse()
    {
        return false;
    }        
    public String objectArrayMethod(Object[] o)
    {
        return ""result of objectArrayMethod"";
    }
    public String concat(Object[] strings)
    {
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < strings.length; i++)
        {
            result.append((String) strings[i]).append(' ');
        }
        return result.toString();
    }
    public String concat(List strings)
    {
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < strings.size(); i++)
        {
            result.append((String) strings.get(i)).append(' ');
        }
        return result.toString();
    }
    public String objConcat(List objects)
    {
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < objects.size(); i++)
        {
            result.append(objects.get(i)).append(' ');
        }
        return result.toString();
    }
    public String parse(String a, Object o, String c, String d)
    {
        return a + o.toString() + c + d;
    }
    public String concat(String a, String b)
    {
        return a + b;
    }        
    // These two are for testing subclasses.
    public Person getPerson()
    {
        return new Person();
    }
    public Child getChild()
    {
        return new Child();
    }        
    public String showPerson(Person person)
    {
        return person.getName();
    }        
    /**
     * Chop i characters off the end of a string.
     *
     * @param string String to chop.
     * @param i Number of characters to chop.
     * @return String with processed answer.
     */
    public String chop(String string, int i)
    {
        return(string.substring(0, string.length() - i));
    }
    public boolean allEmpty(Object[] list)
    {
        int size = list.length;
        for (int i = 0; i < size; i++)
            if (list[i].toString().length() > 0)
                return false;
        return true;
    }
    /*
     * This can't have the signature
    public void setState(boolean state)
    or dynamically invoking the method
    doesn't work ... you would have to
    put a wrapper around a method for a
    real boolean property that takes a 
    Boolean object if you wanted this to
    work. Not really sure how useful it
    is anyway. Who cares about boolean
    values you can just set a variable.
    */
    public void setState(Boolean state)
    {
    }
    public void setBangStart( Integer i )
    {
        System.out.println(""SetBangStart() : called with val = "" + i );
        stateint = i.intValue();
    }
    public Integer bang()
    {
        System.out.println(""Bang! : "" + stateint );
        Integer ret = new Integer( stateint );
        stateint++;
        return ret;
    }
    /**
     * Test the ability of vel to use a get(key)
     * method for any object type, not just one
     * that implements the Map interface.
     */
    public String get(String key)
    {
        return key;
    }        
    /**
     * Test the ability of vel to use a put(key)
     * method for any object type, not just one
     * that implements the Map interface.
     */
    public String put(String key, Object o)
    {
        ob = o;
        return key;
    }        
    public String getFoo()
        throws Exception
    {
        System.out.println(""Hello from getfoo"");
        throw new Exception(""From getFoo()"");
    }
    public String getThrow()
        throws Exception
    {
        System.out.println(""Hello from geThrow"");
       throw new Exception(""From getThrow()"");
    }
}
"
org.apache.velocity.test.view.TemplateNodeView,"package org.apache.velocity.test.view;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.IOException;
import java.io.PrintWriter;
import java.io.FileInputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.runtime.visitor.NodeViewMode;
import org.apache.velocity.runtime.parser.node.SimpleNode;
/**
 * Simple class for dumping the AST for a template.
 * Good for debugging and writing new directives.
 */
public class TemplateNodeView
{
    /** 
     * Root of the AST node structure that results from
     * parsing a template.
     */
    private SimpleNode document;
    /**
     * Visitor used to traverse the AST node structure
     * and produce a visual representation of the
     * node structure. Very good for debugging and
     * writing new directives.
     */
    private NodeViewMode visitor;
    /**
     * Default constructor: sets up the Velocity
     * Runtime, creates the visitor for traversing
     * the node structure and then produces the
     * visual representation by the visitation.
     */
    public TemplateNodeView(String template)
    {
        try
        {
            RuntimeSingleton.init(""velocity.properties"");
            InputStreamReader isr = new InputStreamReader(
                                       new FileInputStream(template),
                                       RuntimeSingleton.getString(RuntimeSingleton.INPUT_ENCODING));
            BufferedReader br = new BufferedReader( isr );
            document = RuntimeSingleton.parse( br, template);
            visitor = new NodeViewMode();
            visitor.setContext(null);
            visitor.setWriter(new PrintWriter(System.out));
            document.jjtAccept(visitor, null);
        }
        catch (Exception e)
        {
            System.out.println(e);
            e.printStackTrace();
        }
    }
    /** For testing */
    public static void main(String args[])
    {
        TemplateNodeView v = new TemplateNodeView(args[0]);
    }        
}
"
org.apache.velocity.texen.Generator,"package org.apache.velocity.texen;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.BufferedInputStream;
import java.io.Writer;
import java.io.FileWriter;
import java.io.StringWriter;
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Properties;
import org.apache.velocity.Template;
import org.apache.velocity.context.Context;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
/**
 * A text/code generator class
 *
 * @author <a href=""mailto:leon@opticode.co.za"">Leon Messerschmidt</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Generator.java,v 1.20.4.1 2004/03/03 23:23:07 geirm Exp $ 
 */
public class Generator
{
    /**
     * Where the texen output will placed.
     */
    public static final String OUTPUT_PATH = ""output.path"";
    /**
     * Where the velocity templates live.
     */
    public static final String TEMPLATE_PATH = ""template.path"";
    /**
     * Default properties file used for controlling the
     * tools placed in the context.
     */
    private static final String DEFAULT_TEXEN_PROPERTIES =
        ""org/apache/velocity/texen/defaults/texen.properties"";
    /**
     * Default properties used by texen.
     */
    private Properties props = new Properties();
    /**
     * Context used for generating the texen output.
     */
    private Context controlContext;
    /**
     * Keep track of the file writers used for outputting
     * to files. If we come across a file writer more
     * then once then the additional output will be
     * appended to the file instead of overwritting
     * the contents.
     */
    private Hashtable writers = new Hashtable();
    /**
     * The generator tools used for creating additional
     * output withing the control template. This could
     * use some cleaning up.
     */
    private static Generator instance = new Generator();
    /**
     * This is the encoding for the output file(s).
     */
    protected String outputEncoding;
    /**
     * This is the encoding for the input file(s)
     * (templates).
     */
    protected String inputEncoding;
    /**
     * Velocity engine.
     */
    protected VelocityEngine ve;
    /**
     * Default constructor.
     */
    private Generator()
    {
        setDefaultProps();
    }
    /**
     * Create a new generator object with default properties.
     *
     * @return Generator generator used in the control context.
     */
    public static Generator getInstance()
    {
        return instance;
    }
    /**
     * Set the velocity engine.
     */
    public void setVelocityEngine(VelocityEngine ve)
    {
        this.ve = ve;
    }        
    /**
     * Create a new generator object with properties loaded from
     * a file.  If the file does not exist or any other exception
     * occurs during the reading operation the default properties
     * are used.
     *
     * @param String properties used to help populate the control context.
     * @return Generator generator used in the control context.
     */
    public Generator (String propFile)
    {
        try
        {
            BufferedInputStream bi = null;
            try
            {
                bi = new BufferedInputStream (new FileInputStream (propFile));
                props.load (bi);
            }
            finally
            {
                if (bi != null)
                {
                    bi.close();
                }
            }
        }
        catch (Exception e)
        {
            /*
             * If something goes wrong we use default properties
             */
            setDefaultProps();
        }
    }
    /**
     * Create a new Generator object with a given property
     * set. The property set will be duplicated.
     *
     * @param Properties properties object to help populate the control context.
     */
    public Generator (Properties props)
    {
        this.props = (Properties)props.clone();
    }
    /**
     * Set default properties.
     */
    protected void setDefaultProps()
    {
        ClassLoader classLoader = VelocityEngine.class.getClassLoader();
        try
        {
            InputStream inputStream = null;
            try
            {
                inputStream = classLoader.getResourceAsStream(
                    DEFAULT_TEXEN_PROPERTIES);
                props.load( inputStream );
            }
            finally
            {
                if (inputStream != null)
                {
                    inputStream.close();
                }
            }
        }
        catch (Exception ioe)
        {
            System.err.println(""Cannot get default properties!"");
        }
    }
    /**
     * Set the template path, where Texen will look
     * for Velocity templates.
     *
     * @param String template path for velocity templates.
     */
    public void setTemplatePath(String templatePath)
    {
        props.put(TEMPLATE_PATH, templatePath);
    }
    /**
     * Get the template path.
     *
     * @return String template path for velocity templates.
     */
    public String getTemplatePath()
    {
        return props.getProperty(TEMPLATE_PATH);
    }
    /**
     * Set the output path for the generated
     * output.
     *
     * @return String output path for texen output.
     */
    public void setOutputPath(String outputPath)
    {
        props.put(OUTPUT_PATH, outputPath);
    }
    /**
     * Get the output path for the generated
     * output.
     *
     * @return String output path for texen output.
     */
    public String getOutputPath()
    {
        return props.getProperty(OUTPUT_PATH);
    }
    /**
     * Set the output encoding.
     */
    public void setOutputEncoding(String outputEncoding)
    {
        this.outputEncoding = outputEncoding;
    }
    /**
     * Set the input (template) encoding.
     */
    public void setInputEncoding(String inputEncoding)
    {
        this.inputEncoding = inputEncoding;
    }
    /**
     * Returns a writer, based on encoding and path.
     *
     * @param path      path to the output file
     * @param encoding  output encoding
     */
    public Writer getWriter(String path, String encoding) throws Exception {
        Writer writer;
        if (encoding == null || encoding.length() == 0 || encoding.equals(""8859-1"") || encoding.equals(""8859_1"")) {
            writer = new FileWriter(path);
        }
        else {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path), encoding));
        }
        return writer;
    }
    /**
     * Returns a template, based on encoding and path.
     *
     * @param templateName  name of the template
     * @param encoding      template encoding
     */
    public Template getTemplate(String templateName, String encoding) throws Exception {
        Template template;
        if (encoding == null || encoding.length() == 0 || encoding.equals(""8859-1"") || encoding.equals(""8859_1"")) {
            template = ve.getTemplate(templateName);
        }
        else {
            template = ve.getTemplate(templateName, encoding);
        }
        return template;
    }
    /**
     * Parse an input and write the output to an output file.  If the
     * output file parameter is null or an empty string the result is
     * returned as a string object.  Otherwise an empty string is returned.
     *
     * @param String input template
     * @param String output file
     */ 
    public String parse (String inputTemplate, String outputFile) 
        throws Exception
    {
        return parse(inputTemplate, outputFile, null, null);
    }
    /**
     * Parse an input and write the output to an output file.  If the
     * output file parameter is null or an empty string the result is
     * returned as a string object.  Otherwise an empty string is returned.
     * You can add objects to the context with the objs Hashtable.
     *
     * @param String input template
     * @param String output file
     * @param String id for object to be placed in the control context
     * @param String object to be placed in the context
     * @return String generated output from velocity
     */
    public String parse (String inputTemplate,
                         String outputFile,
                         String objectID,
                         Object object)
        throws Exception
    {
        return parse(inputTemplate, null, outputFile, null, objectID, object);
    }
    /**
     * Parse an input and write the output to an output file.  If the
     * output file parameter is null or an empty string the result is
     * returned as a string object.  Otherwise an empty string is returned.
     * You can add objects to the context with the objs Hashtable.
     *
     * @param String input template
     * @param String inputEncoding template encoding
     * @param String output file
     * @param String outputEncoding encoding of output file
     * @param String id for object to be placed in the control context
     * @param String object to be placed in the context
     * @return String generated output from velocity
     */ 
    public String parse (String inputTemplate, 
                         String intputEncoding,
                         String outputFile,
                         String outputEncoding,
                         String objectID,
                         Object object)
        throws Exception
    {
        if (objectID != null && object != null)
        {
            controlContext.put(objectID, object);
        }            
        Template template = getTemplate(inputTemplate, inputEncoding != null ? inputEncoding : this.inputEncoding);
        if (outputFile == null || outputFile.equals(""""))
        {
            StringWriter sw = new StringWriter();
            template.merge (controlContext,sw);
            return sw.toString();
        }
        else
        {
            Writer writer = null;
            if (writers.get(outputFile) == null)
            {
                /*
                 * We have never seen this file before so create
                 * a new file writer for it.
                 */
                writer = getWriter(
                            getOutputPath() + File.separator + outputFile,
                            outputEncoding != null ? outputEncoding : this.outputEncoding
                         );
                /*
                 * Place the file writer in our collection
                 * of file writers.
                 */
                writers.put(outputFile, writer);
            }
            else
            {
                writer = (Writer) writers.get(outputFile);
            }                
            VelocityContext vc = new VelocityContext( controlContext );
            template.merge (vc,writer);
            // commented because it is closed in shutdown();
            //fw.close();
            return """";
        }
    }
    /**
     * Parse the control template and merge it with the control
     * context. This is the starting point in texen.
     *
     * @param String control template
     * @param Context control context
     * @return String generated output
     */
    public String parse (String controlTemplate, Context controlContext)
        throws Exception
    {
        this.controlContext = controlContext;
        fillContextDefaults(this.controlContext);
        fillContextProperties(this.controlContext);
        Template template = getTemplate(controlTemplate, inputEncoding);
        StringWriter sw = new StringWriter();
        template.merge (controlContext,sw);
        return sw.toString();
    }
    /**
     * Create a new context and fill it with the elements of the
     * objs Hashtable.  Default objects and objects that comes from
     * the properties of this Generator object is also added.
     *
     * @param Hashtable objects to place in the control context
     * @return Context context filled with objects
     */ 
    protected Context getContext (Hashtable objs)
    {
        fillContextHash (controlContext,objs);
        return controlContext;
    }
    /** 
     * Add all the contents of a Hashtable to the context.
     *
     * @param Context context to fill with objects
     * @param Hashtable source of objects
     */
    protected void fillContextHash (Context context, Hashtable objs)
    {
        Enumeration enum = objs.keys();
        while (enum.hasMoreElements())
        {
            String key = enum.nextElement().toString();
            context.put (key, objs.get(key));
        }
    }
    /**
     * Add properties that will aways be in the context by default
     *
     * @param Context control context to fill with default values.
     */
    protected void fillContextDefaults (Context context)
    {
        context.put (""generator"", instance);
        context.put (""outputDirectory"", getOutputPath());
    }
    /**
     * Add objects to the context from the current properties.
     *
     * @param Context control context to fill with objects
     *                that are specified in the default.properties
     *                file
     */
    protected void fillContextProperties (Context context)
    {
        Enumeration enum = props.propertyNames();
        while (enum.hasMoreElements())
        {
            String nm = (String)enum.nextElement();
            if (nm.startsWith (""context.objects.""))
            {
                String contextObj = props.getProperty (nm);
                int colon = nm.lastIndexOf ('.');
                String contextName = nm.substring (colon+1);
                try
                {
                    Class cls = Class.forName (contextObj);
                    Object o = cls.newInstance();
                    context.put (contextName,o);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                    //TO DO: Log Something Here
                }
            }
        }
    }
    /**
     * Properly shut down the generator, right now
     * this is simply flushing and closing the file
     * writers that we have been holding on to.
     */
    public void shutdown()
    {
        Iterator iterator = writers.values().iterator();
        while(iterator.hasNext())
        {
            Writer writer = (Writer) iterator.next();
            try
            {
                writer.flush();
                writer.close();
            }
            catch (Exception e)
            {
                /* do nothing */
            }
        }
        // clear the file writers cache
        writers.clear();
    }
}
"
org.apache.velocity.texen.ant.TexenTask,"package org.apache.velocity.texen.ant;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.StringTokenizer;
import java.util.Date;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.io.File;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;
import org.apache.velocity.texen.Generator;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * An ant task for generating output by using Velocity
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""robertdonkin@mac.com"">Robert Burrell Donkin</a>
 * @version $Id: TexenTask.java,v 1.39.4.1 2004/03/03 23:23:07 geirm Exp $
 */
public class TexenTask 
    extends Task
{
    /**
     * This message fragment (telling users to consult the log or
     * invoke ant with the -debug flag) is appended to rethrown
     * exception messages.
     */
    private final static String ERR_MSG_FRAGMENT = 
        "". For more information consult the velocity log, or invoke ant "" +
        ""with the -debug flag."";
    /**
     * This is the control template that governs the output.
     * It may or may not invoke the services of worker
     * templates.
     */
    protected String controlTemplate;
    /**
     * This is where Velocity will look for templates
     * using the file template loader.
     */
    protected String templatePath;
    /**
     * This is where texen will place all the output
     * that is a product of the generation process.
     */
    protected String outputDirectory;
    /**
     * This is the file where the generated text
     * will be placed.
     */
    protected String outputFile;
    /**
     * This is the encoding for the output file(s).
     */
    protected String outputEncoding;
    /**
     * This is the encoding for the input file(s)
     * (templates).
     */
    protected String inputEncoding;
    /**
     * <p>
     * These are properties that are fed into the
     * initial context from a properties file. This
     * is simply a convenient way to set some values
     * that you wish to make available in the context.
     * </p>
     * <p>
     * These values are not critical, like the template path
     * or output path, but allow a convenient way to
     * set a value that may be specific to a particular
     * generation task.
     * </p>
     * <p>
     * For example, if you are generating scripts to allow
     * user to automatically create a database, then
     * you might want the <code>$databaseName</code> 
     * to be placed
     * in the initial context so that it is available
     * in a script that might look something like the
     * following:
     * <code><pre>
     * #!bin/sh
     * 
     * echo y | mysqladmin create $databaseName
     * </pre></code>
     * The value of <code>$databaseName</code> isn't critical to
     * output, and you obviously don't want to change
     * the ant task to simply take a database name.
     * So initial context values can be set with
     * properties file.
     */
    protected ExtendedProperties contextProperties;
    /**
     * Property which controls whether the classpath
     * will be used when trying to locate templates.
     */
    protected boolean useClasspath;
    /**
     * Path separator.
     */
    private String fileSeparator = System.getProperty(""file.separator"");
    /**
     * [REQUIRED] Set the control template for the
     * generating process.
     */
    public void setControlTemplate (String controlTemplate)
    {
        this.controlTemplate = controlTemplate;
    }
    /**
     * Get the control template for the
     * generating process.
     */
    public String getControlTemplate()
    {
        return controlTemplate;
    }
    /**
     * [REQUIRED] Set the path where Velocity will look
     * for templates using the file template
     * loader.
     */
    public void setTemplatePath(String templatePath) throws Exception
    {
        StringBuffer resolvedPath = new StringBuffer();
        StringTokenizer st = new StringTokenizer(templatePath, "","");
        while ( st.hasMoreTokens() )
        {
            // resolve relative path from basedir and leave
            // absolute path untouched.
            File fullPath = project.resolveFile(st.nextToken());
            resolvedPath.append(fullPath.getCanonicalPath());
            if ( st.hasMoreTokens() )
            {
                resolvedPath.append("","");
            }
        }
        this.templatePath = resolvedPath.toString();
        System.out.println(templatePath);
     }
    /**
     * Get the path where Velocity will look
     * for templates using the file template
     * loader.
     */
    public String getTemplatePath()
    {
        return templatePath;
    }        
    /**
     * [REQUIRED] Set the output directory. It will be
     * created if it doesn't exist.
     */
    public void setOutputDirectory(File outputDirectory)
    {
        try
        {
            this.outputDirectory = outputDirectory.getCanonicalPath();
        }
        catch (java.io.IOException ioe)
        {
            throw new BuildException(ioe);
        }
    }
    /**
     * Get the output directory.
     */
    public String getOutputDirectory()
    {
        return outputDirectory;
    }        
    /**
     * [REQUIRED] Set the output file for the
     * generation process.
     */
    public void setOutputFile(String outputFile)
    {
        this.outputFile = outputFile;
    }
    /**
     * Set the output encoding.
     */
    public void setOutputEncoding(String outputEncoding)
    {
        this.outputEncoding = outputEncoding;
    }
    /**
     * Set the input (template) encoding.
     */
    public void setInputEncoding(String inputEncoding)
    {
        this.inputEncoding = inputEncoding;
    }
    /**
     * Get the output file for the
     * generation process.
     */
    public String getOutputFile()
    {
        return outputFile;
    }        
    /**
     * Set the context properties that will be
     * fed into the initial context be the
     * generating process starts.
     */
    public void setContextProperties( String file )
    {
        String[] sources = StringUtils.split(file,"","");
        contextProperties = new ExtendedProperties();
        // Always try to get the context properties resource
        // from a file first. Templates may be taken from a JAR
        // file but the context properties resource may be a 
        // resource in the filesystem. If this fails than attempt
        // to get the context properties resource from the
        // classpath.
        for (int i = 0; i < sources.length; i++)
        {
            ExtendedProperties source = new ExtendedProperties();
            try
            {
                // resolve relative path from basedir and leave
                // absolute path untouched.
                File fullPath = project.resolveFile(sources[i]);
                log(""Using contextProperties file: "" + fullPath);
                source.load(new FileInputStream(fullPath));
            }
            catch (Exception e)
            {
                ClassLoader classLoader = this.getClass().getClassLoader();
                try
                {
                    InputStream inputStream = classLoader.getResourceAsStream(sources[i]);
                    if (inputStream == null)
                    {
                        throw new BuildException(""Context properties file "" + sources[i] +
                            "" could not be found in the file system or on the classpath!"");
                    }
                    else
                    {
                        source.load(inputStream);
                    }
                }
                catch (IOException ioe)
                {
                    source = null;
                }
            }
            Iterator j = source.getKeys();
            while (j.hasNext())
            {
                String name = (String) j.next();
                String value = source.getString(name);
                contextProperties.setProperty(name,value);
            }
        }
    }
    /**
     * Get the context properties that will be
     * fed into the initial context be the
     * generating process starts.
     */
    public ExtendedProperties getContextProperties()
    {
        return contextProperties;
    }
    /**
     * Set the use of the classpath in locating templates
     *
     * @param boolean true means the classpath will be used.
     */
    public void setUseClasspath(boolean useClasspath)
    {
        this.useClasspath = useClasspath;
    }        
    /**
     * Creates a VelocityContext.
     *
     * @return new Context
     * @throws Exception the execute method will catch 
     *         and rethrow as a <code>BuildException</code>
     */
    public Context initControlContext() 
        throws Exception
    {
        return new VelocityContext();
    }
    /**
     * Execute the input script with Velocity
     *
     * @throws BuildException  
     * BuildExceptions are thrown when required attributes are missing.
     * Exceptions thrown by Velocity are rethrown as BuildExceptions.
     */
    public void execute () 
        throws BuildException
    {
        // Make sure the template path is set.
        if (templatePath == null && useClasspath == false)
        {
            throw new BuildException(
                ""The template path needs to be defined if you are not using "" +
                ""the classpath for locating templates!"");
        }            
        // Make sure the control template is set.
        if (controlTemplate == null)
        {
            throw new BuildException(""The control template needs to be defined!"");
        }            
        // Make sure the output directory is set.
        if (outputDirectory == null)
        {
            throw new BuildException(""The output directory needs to be defined!"");
        }            
        // Make sure there is an output file.
        if (outputFile == null)
        {
            throw new BuildException(""The output file needs to be defined!"");
        }            
        VelocityEngine ve = new VelocityEngine();
        try
        {
            // Setup the Velocity Runtime.
            if (templatePath != null)
            {
            	log(""Using templatePath: "" + templatePath, project.MSG_VERBOSE);
                ve.setProperty(
                    ve.FILE_RESOURCE_LOADER_PATH, templatePath);
            }
            if (useClasspath)
            {
            	log(""Using classpath"");
                ve.addProperty(
                    VelocityEngine.RESOURCE_LOADER, ""classpath"");
                ve.setProperty(
                    ""classpath."" + VelocityEngine.RESOURCE_LOADER + "".class"",
                        ""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
                ve.setProperty(
                    ""classpath."" + VelocityEngine.RESOURCE_LOADER + 
                        "".cache"", ""false"");
                ve.setProperty(
                    ""classpath."" + VelocityEngine.RESOURCE_LOADER + 
                        "".modificationCheckInterval"", ""2"");
            }
            ve.init();
            // Create the text generator.
            Generator generator = Generator.getInstance();
            generator.setVelocityEngine(ve);
            generator.setOutputPath(outputDirectory);
            generator.setInputEncoding(inputEncoding);
            generator.setOutputEncoding(outputEncoding);
            if (templatePath != null)
            {
                generator.setTemplatePath(templatePath);
            }
            // Make sure the output directory exists, if it doesn't
            // then create it.
            File file = new File(outputDirectory);
            if (! file.exists())
            {
                file.mkdirs();
            }
            String path = outputDirectory + File.separator + outputFile;
            log(""Generating to file "" + path, project.MSG_INFO);
            Writer writer = generator.getWriter(path, outputEncoding);
            // The generator and the output path should
            // be placed in the init context here and
            // not in the generator class itself.
            Context c = initControlContext();
            // Everything in the generator class should be
            // pulled out and placed in here. What the generator
            // class does can probably be added to the Velocity
            // class and the generator class can probably
            // be removed all together.
            populateInitialContext(c);
            // Feed all the options into the initial
            // control context so they are available
            // in the control/worker templates.
            if (contextProperties != null)
            {
                Iterator i = contextProperties.getKeys();
                while (i.hasNext())
                {
                    String property = (String) i.next();
                    String value = contextProperties.getString(property);
                    // Now lets quickly check to see if what
                    // we have is numeric and try to put it
                    // into the context as an Integer.
                    try
                    {
                        c.put(property, new Integer(value)); 
                    }
                    catch (NumberFormatException nfe)
                    {
                        // Now we will try to place the value into
                        // the context as a boolean value if it
                        // maps to a valid boolean value.
                        String booleanString = 
                            contextProperties.testBoolean(value);
                        if (booleanString != null)
                        {    
                            c.put(property, new Boolean(booleanString));
                        }
                        else
                        {
                            // We are going to do something special
                            // for properties that have a ""file.contents""
                            // suffix: for these properties will pull
                            // in the contents of the file and make
                            // them available in the context. So for
                            // a line like the following in a properties file:
                            //
                            // license.file.contents = license.txt
                            //
                            // We will pull in the contents of license.txt
                            // and make it available in the context as
                            // $license. This should make texen a little
                            // more flexible.
                            if (property.endsWith(""file.contents""))
                            {
                                // We need to turn the license file from relative to
                                // absolute, and let Ant help :)
                                value = StringUtils.fileContentsToString(   
                                    project.resolveFile(value).getCanonicalPath());
                                property = property.substring(
                                    0, property.indexOf(""file.contents"") - 1);
                            }
                            c.put(property, value);
                        }
                    }
                }
            }
            writer.write(generator.parse(controlTemplate, c));
            writer.flush();
            writer.close();
            generator.shutdown();
            cleanup();
        }
        catch( BuildException e)
        {
            throw e;
        }
        catch( MethodInvocationException e )
        {
            throw new BuildException(
                ""Exception thrown by '"" + e.getReferenceName() + ""."" + 
                    e.getMethodName() +""'"" + ERR_MSG_FRAGMENT,
                        e.getWrappedThrowable());
        }       
        catch( ParseErrorException e )
        {
            throw new BuildException(""Velocity syntax error"" + ERR_MSG_FRAGMENT ,e);
        }        
        catch( ResourceNotFoundException e )
        {
            throw new BuildException(""Resource not found"" + ERR_MSG_FRAGMENT,e);
        }
        catch( Exception e )
        {
            throw new BuildException(""Generation failed"" + ERR_MSG_FRAGMENT ,e);
        }
    }
    /**
     * <p>Place useful objects into the initial context.</p>
     *
     * <p>TexenTask places <code>Date().toString()</code> into the
     * context as <code>$now</code>.  Subclasses who want to vary the
     * objects in the context should override this method.</p>
     *
     * <p><code>$generator</code> is not put into the context in this
     * method.</p>
     *
     * @param context The context to populate, as retrieved from
     * {@link #initControlContext()}.
     *
     * @throws Exception Error while populating context.  The {@link
     * #execute()} method will catch and rethrow as a
     * <code>BuildException</code>.
     */
    protected void populateInitialContext(Context context) 
        throws Exception
    {
        context.put(""now"", new Date().toString());
    }
    /**
     * A hook method called at the end of {@link #execute()} which can
     * be overridden to perform any necessary cleanup activities (such
     * as the release of database connections, etc.).  By default,
     * does nothing.
     *
     * @exception Exception Problem cleaning up.
     */
    protected void cleanup()
        throws Exception
    {
    }
}
"
org.apache.velocity.texen.util.FileUtil,"package org.apache.velocity.texen.util;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
/**
 * A general file utility for use in the context
 *
 * @author <a href=""mailto:leon@opticode.co.za"">Leon Messerschmidt</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: FileUtil.java,v 1.9.8.1 2004/03/03 23:23:07 geirm Exp $ 
 */
public class FileUtil
{
    /**
     * Creates the directory s (and any parent directories needed).
     *
     * @param String path/directory to create.
     * @param String report of path/directory creation.
     */
    static public String mkdir (String s)
    {
        try
        {
            if ((new File(s)).mkdirs())
                return ""Created dir: ""+s;
            else
                return ""Failed to create dir or dir already exists: ""+s;
        }
        catch (Exception e)
        {
            return e.toString();
        }
    }
    /**
     * A method to get a File object.
     *
     * @param String path to file object to create.
     * @return File created file object.
     */
    public static File file(String s)
    {
        File f = new File(s);
        return f;
    }
    /**
     * A method to get a File object.
     *
     * @param String base path
     * @param String file name
     * @return File created file object.
     */
    public static File file(String base, String s)
    {
        File f = new File(base, s);
        return f;
    }
}
"
org.apache.velocity.texen.util.PropertiesUtil,"package org.apache.velocity.texen.util;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Properties;
import java.util.StringTokenizer;
import org.apache.velocity.texen.Generator;
/**
 * A property utility class for the texen text/code generator
 * Usually this class is only used from a Velocity context.
 *
 * @author <a href=""mailto:leon@opticode.co.za"">Leon Messerschmidt</a>
 * @author <a href=""mailto:sbailliez@apache.org"">Stephane Bailliez</a>
 * @version $Id: PropertiesUtil.java,v 1.9.8.1 2004/03/03 23:23:07 geirm Exp $ 
 */
public class PropertiesUtil
{
    /**
     * Load properties from either a file in the templatePath if there
     * is one or the classPath.
     *
     * @param propertiesFile the properties file to load through
     * either the templatePath or the classpath.
     * @return a properties instance filled with the properties found
     * in the file or an empty instance if no file was found.
     */
    public Properties load(String propertiesFile)
    {
        Properties properties = new Properties();
        String templatePath = Generator.getInstance().getTemplatePath();
        if (templatePath != null)
        {
            properties = loadFromTemplatePath(propertiesFile);
        }
        else
        {
            properties = loadFromClassPath(propertiesFile);
        }
        return properties;
    }
    /**
     * Load a properties file from the templatePath defined in the
     * generator. As the templatePath can contains multiple paths,
     * it will cycle through them to find the file. The first file
     * that can be successfully loaded is considered. (kind of
     * like the java classpath), it is done to clone the Velocity
     * process of loading templates.
     *
     * @param propertiesFile the properties file to load. It must be
     * a relative pathname.
     * @return a properties instance loaded with the properties from
     * the file. If no file can be found it returns an empty instance.
     */
    protected Properties loadFromTemplatePath(String propertiesFile)
    {
        Properties properties = new Properties();
        String templatePath = Generator.getInstance().getTemplatePath();
        // We might have something like the following:
        //
        // #set ($dbprops = $properties.load(""$generator.templatePath/path/props"")
        //
        // as we have in Torque but we want people to start using
        //
        // #set ($dbprops = $properties.load(""path/props"")
        //
        // so that everything works from the filesystem or from
        // a JAR. So the actual Generator.getTemplatePath()
        // is not deprecated but it's use in templates
        // should be.
        StringTokenizer st = new StringTokenizer(templatePath, "","");
        while (st.hasMoreTokens())
        {
            String templateDir = st.nextToken();
            try
            {
                // If the properties file is being pulled from the
                // file system and someone is using the method whereby
                // the properties file is assumed to be in the template
                // path and they are simply using:
                //
                // #set ($dbprops = $properties.load(""props"") (1)
                // 
                // than we have to tack on the templatePath in order
                // for the properties file to be found. We want (1)
                // to work whether the generation is being run from
                // the file system or from a JAR file.
                String fullPath = propertiesFile;
                // FIXME probably not that clever since there could be
                // a mix of file separators and the test will fail :-(
                if (!fullPath.startsWith(templateDir))
                {
                    fullPath = templateDir + ""/"" + propertiesFile;
                }
                properties.load(new FileInputStream(fullPath));
                // first pick wins, we don't need to go further since
                // we found a valid file.
                break;
            }
            catch (Exception e)
            {
                // do nothing
            }
        } 
        return properties;
    }
    /**
     * Load a properties file from the classpath
     *
     * @param propertiesFile the properties file to load.
     * @return a properties instance loaded with the properties from
     * the file. If no file can be found it returns an empty instance.
     */ 
    protected Properties loadFromClassPath(String propertiesFile)
    {
        Properties properties = new Properties();
        ClassLoader classLoader = this.getClass().getClassLoader();
        try
        {
            // This is a hack for now to make sure that properties
            // files referenced in the filesystem work in
            // a JAR file. We have to deprecate the use
            // of $generator.templatePath in templates first
            // and this hack will allow those same templates
            // that use $generator.templatePath to work in
            // JAR files.
            if (propertiesFile.startsWith(""$generator""))
            {
                propertiesFile = propertiesFile.substring(
                    ""$generator.templatePath/"".length());
            }
            InputStream inputStream = classLoader.getResourceAsStream(propertiesFile);
            properties.load(inputStream);
        }
        catch (IOException ioe)
        {
            // do nothing
        }
        return properties;
    }
}
"
org.apache.velocity.util.ArrayIterator,"package org.apache.velocity.util;
/*
 * Copyright 1999-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.reflect.Array;
/**
 *  <p>
 *  An Iterator wrapper for an Object[]. This will
 *  allow us to deal with all array like structures
 *  in a consistent manner.
 *  </p>
 *  <p>
 *  WARNING : this class's operations are NOT synchronized.
 *  It is meant to be used in a single thread, newly created
 *  for each use in the #foreach() directive.
 *  If this is used or shared, synchronize in the
 *  next() method.
 *  </p>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: ArrayIterator.java,v 1.6.8.1 2004/03/03 23:23:07 geirm Exp $
 */
public class ArrayIterator implements Iterator
{
    /**
     * The objects to iterate.
     */
    private Object array;
    /**
     * The current position and size in the array.
     */
    private int pos;
    private int size;
    /**
     * Creates a new iterator instance for the specified array.
     *
     * @param array The array for which an iterator is desired.
     */
    public ArrayIterator(Object array)
    {
        /*
         * if this isn't an array, then throw.  Note that this is 
         * for internal use - so this should never happen - if it does
         *  we screwed up.
         */
        if ( !array.getClass().isArray() )
        {   
            throw new IllegalArgumentException( 
                ""Programmer error : internal ArrayIterator invoked w/o array"");
        }
        this.array = array;
        pos = 0;
        size = Array.getLength( this.array );
    }
    /**
     * Move to next element in the array.
     *
     * @return The next object in the array.
     */
    public Object next()
    {
        if (pos < size )
            return Array.get( array, pos++);
        /*
         *  we screwed up...
         */
        throw new NoSuchElementException(""No more elements: "" + pos +
                                         "" / "" + size);
    }
    /**
     * Check to see if there is another element in the array.
     *
     * @return Whether there is another element.
     */
    public boolean hasNext()
    {
        return (pos < size );
    }
    /**
     * No op--merely added to satify the <code>Iterator</code> interface.
     */
    public void remove()
    {
        throw new UnsupportedOperationException();
    }
}
"
org.apache.velocity.util.EnumerationIterator,"package org.apache.velocity.util;
/*
 * Copyright 1999-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Iterator;
import java.util.Enumeration;
/**
 * An Iterator wrapper for an Enumeration.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: EnumerationIterator.java,v 1.1.14.1 2004/03/03 23:23:07 geirm Exp $
 */
public class EnumerationIterator implements Iterator
{
    /**
     * The enumeration to iterate.
     */
    private Enumeration enum = null;
    /**
     * Creates a new iteratorwrapper instance for the specified 
     * Enumeration.
     *
     * @param enum  The Enumeration to wrap.
     */
    public EnumerationIterator( Enumeration enum)
    {
        this.enum = enum;
    }
    /**
     * Move to next element in the array.
     *
     * @return The next object in the array.
     */
    public Object next()
    {
        return enum.nextElement();
    }
    /**
     * Check to see if there is another element in the array.
     *
     * @return Whether there is another element.
     */
    public boolean hasNext()
    {
        return enum.hasMoreElements();
    }
    /**
     *  Unimplemented.  No analogy in Enumeration
     */
    public void remove()
    {
        // not implemented
    }
}
"
org.apache.velocity.util.SimplePool,"package org.apache.velocity.util;
/*
 * Copyright 1999-2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Simple object pool. Based on ThreadPool and few other classes
 *
 * The pool will ignore overflow and return null if empty.
 *
 * @author Gal Shachor
 * @author Costin
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: SimplePool.java,v 1.2.14.1 2004/03/03 23:23:07 geirm Exp $
 */
public final class SimplePool  
{
    /*
     * Where the objects are held.
     */
    private Object pool[];
    /**
     *  max amount of objects to be managed
     *  set via CTOR
     */
    private int max;    
    /**
     *  index of previous to next
     *  free slot
     */
    private int current=-1;
    public SimplePool(int max) 
    {
        this.max = max;
        pool = new Object[max];
    } 
    /**
     * Add the object to the pool, silent nothing if the pool is full
     */
    public void put(Object o) 
    {
        int idx=-1;
        synchronized( this ) 
        {
            /*
             *  if we aren't full
             */
            if( current < max - 1 )
            {
                /*
                 *  then increment the 
                 *  current index.
                 */
                idx = ++current;
            }
            if( idx >= 0 ) 
            {
                pool[idx] = o;
            }
        }
    }
    /**
     * Get an object from the pool, null if the pool is empty.
     */
    public  Object get() 
    {
        int idx = -1;
        synchronized( this ) 
        {
            /*
             *  if we have any in the pool
             */
            if( current >= 0 )
            {
                /*
                 *  take one out, so to speak -
                 *  separate the two operations
                 *  to make it clear that you
                 *  don't want idx = --current; :)
                 */
                idx = current;
                current--;
                /*
                 *  and since current was >= 0
                 *  to get in here, idx must be as well
                 *  so save the if() opration
                 */
                return pool[idx];
            }
        }
        return null;
    }
    /** Return the size of the pool
     */
    public int getMax() 
    {
        return max;
    }
}
"
org.apache.velocity.util.StringUtils,"package org.apache.velocity.util;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.File;
import java.io.FileReader;
import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Map;
/**
 * This class provides some methods for dynamically
 * invoking methods in objects, and some string
 * manipulation methods used by torque. The string
 * methods will soon be moved into the turbine
 * string utilities class.
 *
 *  @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 *  @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 *  @version $Id: StringUtils.java,v 1.16.8.1 2004/03/03 23:23:07 geirm Exp $
 */
public class StringUtils
{
    /**
     * Line separator for the OS we are operating on.
     */
    private static final String EOL = System.getProperty(""line.separator"");
    /**
     * Length of the line separator.
     */
    private static final int EOL_LENGTH = EOL.length();
    /**
     * Concatenates a list of objects as a String.
     *
     * @param list The list of objects to concatenate.
     * @return     A text representation of the concatenated objects.
     */
    public String concat(List list)
    {
        StringBuffer sb = new StringBuffer();
        int size = list.size();
        for (int i = 0; i < size; i++)
        {
            sb.append(list.get(i).toString());
        }
        return sb.toString();
    }
    /**
     * Return a package name as a relative path name
     *
     * @param String package name to convert to a directory.
     * @return String directory path.
     */
    static public String getPackageAsPath(String pckge)
    {
        return pckge.replace( '.', File.separator.charAt(0) ) + File.separator;
    }
    /**
     * <p>
     * Remove underscores from a string and replaces first
     * letters with capitals.  Other letters are changed to lower case. 
     * </p>
     *
     * <p> 
     * For example <code>foo_bar</code> becomes <code>FooBar</code>
     * but <code>foo_barBar</code> becomes <code>FooBarbar</code>.
     * </p>
     *
     * @param data string to remove underscores from.
     * @return String 
     * @deprecated Use the org.apache.commons.util.StringUtils class
     * instead.  Using its firstLetterCaps() method in conjunction
     * with a StringTokenizer will achieve the same result.
     */
    static public String removeUnderScores (String data)
    {
        String temp = null;
        StringBuffer out = new StringBuffer();
        temp = data;
        StringTokenizer st = new StringTokenizer(temp, ""_"");
        while (st.hasMoreTokens())
        {
            String element = (String) st.nextElement();
            out.append ( firstLetterCaps(element));
        }
        return out.toString();
    }
    /**
     * <p> 
     *  'Camels Hump' replacement of underscores.
     * </p>
     *
     * <p> 
     * Remove underscores from a string but leave the capitalization of the
     * other letters unchanged.
     * </p>
     *
     * <p> 
     * For example <code>foo_barBar</code> becomes <code>FooBarBar</code>.
     * </p>
     *
     * @param data string to hump
     * @return String 
     */
    static public String removeAndHump (String data)
    {
        return removeAndHump(data,""_"");
    }
    /**
     * <p>
     * 'Camels Hump' replacement.
     * </p>
     *
     * <p> 
     * Remove one string from another string but leave the capitalization of the
     * other letters unchanged.
     * </p>
     *
     * <p>
     * For example, removing ""_"" from <code>foo_barBar</code> becomes <code>FooBarBar</code>.
     * </p>
     *
     * @param data string to hump
     * @param replaceThis string to be replaced
     * @return String 
     */
    static public String removeAndHump (String data,String replaceThis)
    {
        String temp = null;
        StringBuffer out = new StringBuffer();
        temp = data;
        StringTokenizer st = new StringTokenizer(temp, replaceThis);
        while (st.hasMoreTokens())
        {
            String element = (String) st.nextElement();
            out.append ( capitalizeFirstLetter(element));
        }//while
        return out.toString();
    }
    /**
     * <p> 
     *  Makes the first letter caps and the rest lowercase.
     * </p>
     *
     * <p> 
     *  For example <code>fooBar</code> becomes <code>Foobar</code>.
     * </p>
     *
     * @param data capitalize this
     * @return String
     */
    static public String firstLetterCaps ( String data )
    {
        String firstLetter = data.substring(0,1).toUpperCase();
        String restLetters = data.substring(1).toLowerCase();
        return firstLetter + restLetters;
    }
    /**
     * <p> 
     * Capitalize the first letter but leave the rest as they are. 
     * </p>
     *
     * <p> 
     *  For example <code>fooBar</code> becomes <code>FooBar</code>.
     * </p>
     *
     * @param data capitalize this
     * @return String
     */
    static public String capitalizeFirstLetter ( String data )
    {
        String firstLetter = data.substring(0,1).toUpperCase();
        String restLetters = data.substring(1);
        return firstLetter + restLetters;
    }
    /**
     * Create a string array from a string separated by delim
     *
     * @param line the line to split
     * @param delim the delimter to split by
     * @return a string array of the split fields
     */
    public static String [] split(String line, String delim)
    {
        List list = new ArrayList();
        StringTokenizer t = new StringTokenizer(line, delim);
        while (t.hasMoreTokens())
        {
            list.add(t.nextToken());
        }
        return (String []) list.toArray(new String[list.size()]);
    }
    /**
     * Chop i characters off the end of a string.
     * This method assumes that any EOL characters in String s 
     * and the platform EOL will be the same.
     * A 2 character EOL will count as 1 character. 
     *
     * @param string String to chop.
     * @param i Number of characters to chop.
     * @return String with processed answer.
     */
    public static String chop(String s, int i)
    {
        return chop(s, i, EOL);
    }
    /**
     * Chop i characters off the end of a string. 
     * A 2 character EOL will count as 1 character. 
     *
     * @param string String to chop.
     * @param i Number of characters to chop.
     * @param eol A String representing the EOL (end of line).
     * @return String with processed answer.
     */
    public static String chop(String s, int i, String eol)
    {
        if ( i == 0 || s == null || eol == null )
        {
           return s;
        }
        int length = s.length();
        /*
         * if it is a 2 char EOL and the string ends with
         * it, nip it off.  The EOL in this case is treated like 1 character
         */
        if ( eol.length() == 2 && s.endsWith(eol ))
        {
            length -= 2;
            i -= 1;
        }
        if ( i > 0)
        {
            length -= i;
        }
        if ( length < 0)
        {
            length = 0;
        }
        return s.substring( 0, length);
    }
    public static StringBuffer stringSubstitution( String argStr,
                                                   Hashtable vars )
    {
        return stringSubstitution( argStr, (Map) vars );
    }
    /**
     * Perform a series of substitutions. The substitions
     * are performed by replacing $variable in the target
     * string with the value of provided by the key ""variable""
     * in the provided hashtable.
     *
     * @param String target string
     * @param Hashtable name/value pairs used for substitution
     * @return String target string with replacements.
     */
    public static StringBuffer stringSubstitution(String argStr,
            Map vars)
    {
        StringBuffer argBuf = new StringBuffer();
        for (int cIdx = 0 ; cIdx < argStr.length();)
        {
            char ch = argStr.charAt(cIdx);
            switch (ch)
            {
                case '$':
                    StringBuffer nameBuf = new StringBuffer();
                    for (++cIdx ; cIdx < argStr.length(); ++cIdx)
                    {
                        ch = argStr.charAt(cIdx);
                        if (ch == '_' || Character.isLetterOrDigit(ch))
                            nameBuf.append(ch);
                        else
                            break;
                    }
                    if (nameBuf.length() > 0)
                    {
                        String value =
                                (String) vars.get(nameBuf.toString());
                        if (value != null)
                        {
                            argBuf.append(value);
                        }
                    }
                    break;
                default:
                    argBuf.append(ch);
                    ++cIdx;
                    break;
            }
        }
        return argBuf;
    }
    /**
     * Read the contents of a file and place them in
     * a string object.
     *
     * @param String path to file.
     * @return String contents of the file.
     */
    public static String fileContentsToString(String file)
    {
        String contents = """";
        File f = new File(file);
        if (f.exists())
        {
            try
            {
                FileReader fr = new FileReader(f);
                char[] template = new char[(int) f.length()];
                fr.read(template);
                contents = new String(template);
            }
            catch (Exception e)
            {
                System.out.println(e);
                e.printStackTrace();
            }
        }
        return contents;
    }
    /**
     * Remove/collapse multiple newline characters.
     *
     * @param String string to collapse newlines in.
     * @return String
     */
    public static String collapseNewlines(String argStr)
    {
        char last = argStr.charAt(0);
        StringBuffer argBuf = new StringBuffer();
        for (int cIdx = 0 ; cIdx < argStr.length(); cIdx++)
        {
            char ch = argStr.charAt(cIdx);
            if (ch != '\n' || last != '\n')
            {
                argBuf.append(ch);
                last = ch;
            }
        }
        return argBuf.toString();
    }
    /**
     * Remove/collapse multiple spaces.
     *
     * @param String string to remove multiple spaces from.
     * @return String
     */
    public static String collapseSpaces(String argStr)
    {
        char last = argStr.charAt(0);
        StringBuffer argBuf = new StringBuffer();
        for (int cIdx = 0 ; cIdx < argStr.length(); cIdx++)
        {
            char ch = argStr.charAt(cIdx);
            if (ch != ' ' || last != ' ')
            {
                argBuf.append(ch);
                last = ch;
            }
        }
        return argBuf.toString();
    }
    /**
      * Replaces all instances of oldString with newString in line.
      * Taken from the Jive forum package.
      *
      * @param String original string.
      * @param String string in line to replace.
      * @param String replace oldString with this.
      * @return String string with replacements.
      */
    public static final String sub(String line, String oldString,
            String newString)
    {
        int i = 0;
        if ((i = line.indexOf(oldString, i)) >= 0)
        {
            char [] line2 = line.toCharArray();
            char [] newString2 = newString.toCharArray();
            int oLength = oldString.length();
            StringBuffer buf = new StringBuffer(line2.length);
            buf.append(line2, 0, i).append(newString2);
            i += oLength;
            int j = i;
            while ((i = line.indexOf(oldString, i)) > 0)
            {
                buf.append(line2, j, i - j).append(newString2);
                i += oLength;
                j = i;
            }
            buf.append(line2, j, line2.length - j);
            return buf.toString();
        }
        return line;
    }
    /**
     * Returns the output of printStackTrace as a String.
     *
     * @param e A Throwable.
     * @return A String.
     */
    public static final String stackTrace(Throwable e)
    {
        String foo = null;
        try
        {
            // And show the Error Screen.
            ByteArrayOutputStream ostr = new ByteArrayOutputStream();
            e.printStackTrace( new PrintWriter(ostr,true) );
            foo = ostr.toString();
        }
        catch (Exception f)
        {
            // Do nothing.
        }
        return foo;
    }
    /**
     * Return a context-relative path, beginning with a ""/"", that represents
     * the canonical version of the specified path after "".."" and ""."" elements
     * are resolved out.  If the specified path attempts to go outside the
     * boundaries of the current context (i.e. too many "".."" path elements
     * are present), return <code>null</code> instead.
     *
     * @param path Path to be normalized
     * @return String normalized path
     */
    public static final String normalizePath(String path)
    {
        // Normalize the slashes and add leading slash if necessary
        String normalized = path;
        if (normalized.indexOf('\\') >= 0)
        {
            normalized = normalized.replace('\\', '/');
        }
        if (!normalized.startsWith(""/""))
        {
            normalized = ""/"" + normalized;
        }
        // Resolve occurrences of ""//"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""//"");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) +
            normalized.substring(index + 1);
        }
        // Resolve occurrences of ""%20"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""%20"");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) + "" "" +
            normalized.substring(index + 3);
        }
        // Resolve occurrences of ""/./"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""/./"");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) +
            normalized.substring(index + 2);
        }
        // Resolve occurrences of ""/../"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""/../"");
            if (index < 0)
                break;
            if (index == 0)
                return (null);  // Trying to go outside our context
            int index2 = normalized.lastIndexOf('/', index - 1);
            normalized = normalized.substring(0, index2) +
            normalized.substring(index + 3);
        }
        // Return the normalized path that we have completed
        return (normalized);
    }
    /**
     * If state is true then return the trueString, else
     * return the falseString.
     *
     * @param boolean 
     * @param String trueString
     * @param String falseString
     */
    public String select(boolean state, String trueString, String falseString)
    {
        if (state)
        {
            return trueString;
        }            
        else
        {
            return falseString;
        }            
    }            
    /**
     * Check to see if all the string objects passed
     * in are empty.
     *
     * @param list A list of {@link java.lang.String} objects.
     * @return     Whether all strings are empty.
     */
    public boolean allEmpty(List list)
    {
        int size = list.size();
        for (int i = 0; i < size; i++)
        {
            if (list.get(i) != null && list.get(i).toString().length() > 0)
            {
                return false;
            }
        }            
        return true;
    }
}
"
org.apache.velocity.util.introspection.ClassMap,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Map;
import java.util.List;
import java.util.Hashtable;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
/**
 * A cache of introspection information for a specific class instance.
 * Keys {@link java.lang.Method} objects by a concatenation of the
 * method name and the names of classes that make up the parameters.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ClassMap.java,v 1.20.8.1 2004/03/03 23:23:08 geirm Exp $
 */
public class ClassMap
{
    private static final class CacheMiss { }
    private static final CacheMiss CACHE_MISS = new CacheMiss();
    private static final Object OBJECT = new Object();
    /** 
     * Class passed into the constructor used to as
     * the basis for the Method map.
     */
    private Class clazz;
    /**
     * Cache of Methods, or CACHE_MISS, keyed by method
     * name and actual arguments used to find it.
     */
    private Map methodCache = new Hashtable();
    private MethodMap methodMap = new MethodMap();
    /**
     * Standard constructor
     */
    public ClassMap( Class clazz)
    {
        this.clazz = clazz;
        populateMethodCache();
    }
    private ClassMap()
    {
    }
    /**
     * @return the class object whose methods are cached by this map.
     */
     Class getCachedClass()
     {
         return clazz;
     }
    /**
     * Find a Method using the methodKey
     * provided.
     *
     * Look in the methodMap for an entry.  If found,
     * it'll either be a CACHE_MISS, in which case we
     * simply give up, or it'll be a Method, in which
     * case, we return it.
     *
     * If nothing is found, then we must actually go
     * and introspect the method from the MethodMap.
     */
    public Method findMethod(String name, Object[] params)
        throws MethodMap.AmbiguousException
    {
        String methodKey = makeMethodKey(name, params);
        Object cacheEntry = methodCache.get( methodKey );
        if (cacheEntry == CACHE_MISS)
        {
            return null;
        }
        if (cacheEntry == null)
        {
            try
            {
                cacheEntry = methodMap.find( name,
                                             params );
            }
            catch( MethodMap.AmbiguousException ae )
            {
                /*
                 *  that's a miss :)
                 */
                methodCache.put( methodKey,
                                 CACHE_MISS );
                throw ae;
            }
            if ( cacheEntry == null )
            {
                methodCache.put( methodKey,
                                 CACHE_MISS );
            }
            else
            {
                methodCache.put( methodKey,
                                 cacheEntry );
            }
        }
        // Yes, this might just be null.
        return (Method) cacheEntry;
    }
    /**
     * Populate the Map of direct hits. These
     * are taken from all the public methods
     * that our class provides.
     */
    private void populateMethodCache()
    {
        StringBuffer methodKey;
        /*
         *  get all publicly accessible methods
         */
        Method[] methods = getAccessibleMethods(clazz);
        /*
         * map and cache them
         */
        for (int i = 0; i < methods.length; i++)
        {
            Method method = methods[i];
            /*
             *  now get the 'public method', the method declared by a 
             *  public interface or class. (because the actual implementing
             *  class may be a facade...
             */
            Method publicMethod = getPublicMethod( method );
            /*
             *  it is entirely possible that there is no public method for
             *  the methods of this class (i.e. in the facade, a method
             *  that isn't on any of the interfaces or superclass
             *  in which case, ignore it.  Otherwise, map and cache
             */
            if ( publicMethod != null)
            {
                methodMap.add( publicMethod );
                methodCache.put(  makeMethodKey( publicMethod), publicMethod);
            }
        }            
    }
    /**
     * Make a methodKey for the given method using
     * the concatenation of the name and the
     * types of the method parameters.
     */
    private String makeMethodKey(Method method)
    {
        Class[] parameterTypes = method.getParameterTypes();
        StringBuffer methodKey = new StringBuffer(method.getName());
        for (int j = 0; j < parameterTypes.length; j++)
        {
            /*
             * If the argument type is primitive then we want
             * to convert our primitive type signature to the 
             * corresponding Object type so introspection for
             * methods with primitive types will work correctly.
             */
            if (parameterTypes[j].isPrimitive())
            {
                if (parameterTypes[j].equals(Boolean.TYPE))
                    methodKey.append(""java.lang.Boolean"");
                else if (parameterTypes[j].equals(Byte.TYPE))
                    methodKey.append(""java.lang.Byte"");
                else if (parameterTypes[j].equals(Character.TYPE))
                    methodKey.append(""java.lang.Character"");
                else if (parameterTypes[j].equals(Double.TYPE))
                    methodKey.append(""java.lang.Double"");
                else if (parameterTypes[j].equals(Float.TYPE))
                    methodKey.append(""java.lang.Float"");
                else if (parameterTypes[j].equals(Integer.TYPE))
                    methodKey.append(""java.lang.Integer"");
                else if (parameterTypes[j].equals(Long.TYPE))
                    methodKey.append(""java.lang.Long"");
                else if (parameterTypes[j].equals(Short.TYPE))
                    methodKey.append(""java.lang.Short"");
            }                
            else
            {
                methodKey.append(parameterTypes[j].getName());
            }
        }            
        return methodKey.toString();
    }
    private static String makeMethodKey(String method, Object[] params)
    {
        StringBuffer methodKey = new StringBuffer().append(method);
        for (int j = 0; j < params.length; j++)
        {
            Object arg = params[j];
            if (arg == null)
            {
                arg = OBJECT;
            }
            methodKey.append(arg.getClass().getName());
        }
        return methodKey.toString();
    }
    /**
     * Retrieves public methods for a class. In case the class is not
     * public, retrieves methods with same signature as its public methods
     * from public superclasses and interfaces (if they exist). Basically
     * upcasts every method to the nearest acccessible method.
     */
    private static Method[] getAccessibleMethods(Class clazz)
    {
        Method[] methods = clazz.getMethods();
        /*
         *  Short circuit for the (hopefully) majority of cases where the
         *  clazz is public
         */
        if (Modifier.isPublic(clazz.getModifiers()))
        {
            return methods;
        }
        /*
         *  No luck - the class is not public, so we're going the longer way.
         */
        MethodInfo[] methodInfos = new MethodInfo[methods.length];
        for(int i = methods.length; i-- > 0; )
        {
            methodInfos[i] = new MethodInfo(methods[i]);
        }
        int upcastCount = getAccessibleMethods(clazz, methodInfos, 0);
        /*
         *  Reallocate array in case some method had no accessible counterpart.
         */
        if(upcastCount < methods.length)
        {
            methods = new Method[upcastCount];
        }
        int j = 0;
        for(int i = 0; i < methodInfos.length; ++i)
        {
            MethodInfo methodInfo = methodInfos[i];
            if(methodInfo.upcast)
            {
                methods[j++] = methodInfo.method;
            }
        }
        return methods;
    }
    /**
     *  Recursively finds a match for each method, starting with the class, and then
     *  searching the superclass and interfaces.
     *
     *  @param clazz Class to check
     *  @param methodInfos array of methods we are searching to match
     *  @param upcastCount current number of methods we have matched
     *  @return count of matched methods
     */
    private static int getAccessibleMethods( Class clazz, MethodInfo[] methodInfos, int upcastCount)
    {
        int l = methodInfos.length;
        /*
         *  if this class is public, then check each of the currently
         *  'non-upcasted' methods to see if we have a match
         */
        if( Modifier.isPublic(clazz.getModifiers()) )
        {
            for(int i = 0; i < l && upcastCount < l; ++i)
            {
                try
                {
                    MethodInfo methodInfo = methodInfos[i];
                    if(!methodInfo.upcast)
                    {
                        methodInfo.tryUpcasting(clazz);
                        upcastCount++;
                    }
                }
                catch(NoSuchMethodException e)
                {
                    /*
                     *  Intentionally ignored - it means
                     *  it wasn't found in the current class
                     */
                }
            }
            /*
             *  Short circuit if all methods were upcast
             */
            if(upcastCount == l)
            {
                return upcastCount;
            }
        }
        /*
         *   Examine superclass
         */
        Class superclazz = clazz.getSuperclass();
        if(superclazz != null)
        {
            upcastCount = getAccessibleMethods(superclazz , methodInfos, upcastCount);
            /*
             *  Short circuit if all methods were upcast
             */
            if(upcastCount == l)
            {
                return upcastCount;
            }
        }
        /*
         *  Examine interfaces. Note we do it even if superclazz == null.
         *  This is redundant as currently java.lang.Object does not implement
         *  any interfaces, however nothing guarantees it will not in future.
         */
        Class[] interfaces = clazz.getInterfaces();
        for(int i = interfaces.length; i-- > 0; )
        {
            upcastCount = getAccessibleMethods(interfaces[i], methodInfos, upcastCount);
            /*
             *  Short circuit if all methods were upcast
             */
            if(upcastCount == l)
            {
                return upcastCount;
            }
        }
        return upcastCount;
    }
    /**
     *  For a given method, retrieves its publicly accessible counterpart. 
     *  This method will look for a method with same name
     *  and signature declared in a public superclass or implemented interface of this 
     *  method's declaring class. This counterpart method is publicly callable.
     *
     *  @param method a method whose publicly callable counterpart is requested.
     *  @return the publicly callable counterpart method. Note that if the parameter
     *  method is itself declared by a public class, this method is an identity
     *  function.
     */
    public static Method getPublicMethod(Method method)
    {
        Class clazz = method.getDeclaringClass();
        /*
         *   Short circuit for (hopefully the majority of) cases where the declaring
         *   class is public.
         */
        if((clazz.getModifiers() & Modifier.PUBLIC) != 0)
        {
            return method;
        }
        return getPublicMethod(clazz, method.getName(), method.getParameterTypes());
    }
    /**
     *  Looks up the method with specified name and signature in the first public
     *  superclass or implemented interface of the class. 
     * 
     *  @param class the class whose method is sought
     *  @param name the name of the method
     *  @param paramTypes the classes of method parameters
     */
    private static Method getPublicMethod(Class clazz, String name, Class[] paramTypes)
    {
        /*
         *  if this class is public, then try to get it
         */
        if((clazz.getModifiers() & Modifier.PUBLIC) != 0)
        {
            try
            {
                return clazz.getMethod(name, paramTypes);
            }
            catch(NoSuchMethodException e)
            {
                /*
                 *  If the class does not have the method, then neither its
                 *  superclass nor any of its interfaces has it so quickly return
                 *  null.
                 */
                 return null;
            }
        }
        /*
         *  try the superclass
         */
        Class superclazz = clazz.getSuperclass();
        if ( superclazz != null )
        {
            Method superclazzMethod = getPublicMethod(superclazz, name, paramTypes);
            if(superclazzMethod != null)
            {
                return superclazzMethod;
            }
        }
        /*
         *  and interfaces
         */
        Class[] interfaces = clazz.getInterfaces();
        for(int i = 0; i < interfaces.length; ++i)
        {
            Method interfaceMethod = getPublicMethod(interfaces[i], name, paramTypes);
            if(interfaceMethod != null)
            {
                return interfaceMethod;
            }
        }
        return null;
    }
    /**
     *  Used for the iterative discovery process for public methods.
     */
    private static final class MethodInfo
    {
        Method method;
        String name;
        Class[] parameterTypes;
        boolean upcast;
        MethodInfo(Method method)
        {
            this.method = null;
            name = method.getName();
            parameterTypes = method.getParameterTypes();
            upcast = false;
        }
        void tryUpcasting(Class clazz)
            throws NoSuchMethodException
        {
            method = clazz.getMethod(name, parameterTypes);
            name = null;
            parameterTypes = null;
            upcast = true;
        }
    }
}
"
org.apache.velocity.util.introspection.Info,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Little class to carry in info such as template name, line and column
 *  for information error reporting from the uberspector implementations
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Info.java,v 1.1.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public class Info
{
    private int line;
    private int column;
    private String templateName;
    public Info(String tn, int l, int c)
    {
        templateName = tn;
        line = l;
        column = c;
    }
    private Info()
    {
    }
    public String getTemplateName()
    {
        return templateName;
    }
    public int getLine()
    {
        return line;
    }
    public int getColumn()
    {
        return column;
    }
}
"
org.apache.velocity.util.introspection.IntrospectionCacheData,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Holds information for node-local context data introspection
 *  information.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: IntrospectionCacheData.java,v 1.3.14.1 2004/03/03 23:23:08 geirm Exp $
 */
public class IntrospectionCacheData
{
    /**  
     *  Object to pair with class - currently either a Method or 
     *  AbstractExecutor. It can be used in any way the using node
     *  wishes. 
     */
    public Object thingy;
    /*
     *  Class of context data object associated with the introspection
     *  information
     */
    public Class  contextData;
}
"
org.apache.velocity.util.introspection.Introspector,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import java.util.HashSet;
import java.lang.reflect.Method;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeLogger;
/**
 * This basic function of this class is to return a Method
 * object for a particular class given the name of a method
 * and the parameters to the method in the form of an Object[]
 *
 * The first time the Introspector sees a 
 * class it creates a class method map for the
 * class in question. Basically the class method map
 * is a Hastable where Method objects are keyed by a
 * concatenation of the method name and the names of
 * classes that make up the parameters.
 *
 * For example, a method with the following signature:
 *
 * public void method(String a, StringBuffer b)
 *
 * would be mapped by the key:
 *
 * ""method"" + ""java.lang.String"" + ""java.lang.StringBuffer""
 *
 * This mapping is performed for all the methods in a class
 * and stored for 
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @version $Id: Introspector.java,v 1.21.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public class Introspector extends IntrospectorBase
{
    /**
     *  define a public string so that it can be looked for
     *  if interested
     */
    public final static String CACHEDUMP_MSG = 
        ""Introspector : detected classloader change. Dumping cache."";
    /**
     *  our engine runtime services
     */
    private RuntimeLogger rlog = null;
    /**
     *  Recieves our RuntimeServices object
     */
    public Introspector(RuntimeLogger logger)
    {
        this.rlog = logger;
    }
    /**
     * Gets the method defined by <code>name</code> and
     * <code>params</code> for the Class <code>c</code>.
     *
     * @param c Class in which the method search is taking place
     * @param name Name of the method being searched for
     * @param params An array of Objects (not Classes) that describe the
     *               the parameters
     *
     * @return The desired Method object.
     */
    public Method getMethod(Class c, String name, Object[] params)
        throws Exception
    {
        /*
         *  just delegate to the base class
         */
        try
        {
            return super.getMethod( c, name, params );
        }
        catch( MethodMap.AmbiguousException ae )
        {
            /*
             *  whoops.  Ambiguous.  Make a nice log message and return null...
             */
            String msg = ""Introspection Error : Ambiguous method invocation ""
                + name + ""( "";
            for (int i = 0; i < params.length; i++)
            {
                if ( i > 0)
                    msg = msg + "", "";
                msg = msg + params[i].getClass().getName();
            }
            msg = msg + "") for class "" + c;
            rlog.error( msg );
        }
        return null;
    }
    /**
     * Clears the classmap and classname
     * caches, and logs that we did so
     */
    protected void clearCache()
    {
        super.clearCache();
        rlog.info( CACHEDUMP_MSG );
    }
}
"
org.apache.velocity.util.introspection.IntrospectorBase,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import java.util.HashSet;
import java.lang.reflect.Method;
/**
 * This basic function of this class is to return a Method
 * object for a particular class given the name of a method
 * and the parameters to the method in the form of an Object[]
 *
 * The first time the Introspector sees a 
 * class it creates a class method map for the
 * class in question. Basically the class method map
 * is a Hastable where Method objects are keyed by a
 * concatenation of the method name and the names of
 * classes that make up the parameters.
 *
 * For example, a method with the following signature:
 *
 * public void method(String a, StringBuffer b)
 *
 * would be mapped by the key:
 *
 * ""method"" + ""java.lang.String"" + ""java.lang.StringBuffer""
 *
 * This mapping is performed for all the methods in a class
 * and stored for 
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @version $Id: IntrospectorBase.java,v 1.2.8.1 2004/03/03 23:23:08 geirm Exp $
 */
public class IntrospectorBase
{   
    /**
     * Holds the method maps for the classes we know about, keyed by
     * Class object.
     */ 
    protected  Map classMethodMaps = new HashMap();
    /**
     * Holds the qualified class names for the classes
     * we hold in the classMethodMaps hash
     */
    protected Set cachedClassNames = new HashSet();
    /**
     * Gets the method defined by <code>name</code> and
     * <code>params</code> for the Class <code>c</code>.
     *
     * @param c Class in which the method search is taking place
     * @param name Name of the method being searched for
     * @param params An array of Objects (not Classes) that describe the
     *               the parameters
     *
     * @return The desired Method object.
     */
    public Method getMethod(Class c, String name, Object[] params)
        throws Exception
    {
        if (c == null)
        {
            throw new Exception ( 
                ""Introspector.getMethod(): Class method key was null: "" + name );
        }                
        ClassMap classMap = null;
        synchronized(classMethodMaps)
        {
            classMap = (ClassMap)classMethodMaps.get(c);
            /*
             *  if we don't have this, check to see if we have it
             *  by name.  if so, then we have a classloader change
             *  so dump our caches.
             */
            if (classMap == null)
            {                
                if ( cachedClassNames.contains( c.getName() ))
                {
                    /*
                     * we have a map for a class with same name, but not
                     * this class we are looking at.  This implies a 
                     * classloader change, so dump
                     */
                    clearCache();                    
                }
                classMap = createClassMap(c);
            }
        }
        return classMap.findMethod(name, params);
    }
    /**
     * Creates a class map for specific class and registers it in the
     * cache.  Also adds the qualified name to the name->class map
     * for later Classloader change detection.
     */
    protected ClassMap createClassMap(Class c)
    {        
        ClassMap classMap = new ClassMap( c );        
        classMethodMaps.put(c, classMap);
        cachedClassNames.add( c.getName() );
        return classMap;
    }
    /**
     * Clears the classmap and classname
     * caches
     */
    protected void clearCache()
    {
        /*
         *  since we are synchronizing on this
         *  object, we have to clear it rather than
         *  just dump it.
         */            
        classMethodMaps.clear();
        /*
         * for speed, we can just make a new one
         * and let the old one be GC'd
         */
        cachedClassNames = new HashSet();
    }
}
"
org.apache.velocity.util.introspection.MethodMap,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2001,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.Hashtable;
import java.lang.reflect.Method;
/**
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: MethodMap.java,v 1.15.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public class MethodMap
{
    private static final int MORE_SPECIFIC = 0;
    private static final int LESS_SPECIFIC = 1;
    private static final int INCOMPARABLE = 2;
    /**
     * Keep track of all methods with the same name.
     */
    Map methodByNameMap = new Hashtable();
    /**
     * Add a method to a list of methods by name.
     * For a particular class we are keeping track
     * of all the methods with the same name.
     */
    public void add(Method method)
    {
        String methodName = method.getName();
        List l = get( methodName );
        if ( l == null)
        {
            l = new ArrayList();
            methodByNameMap.put(methodName, l);
        }
        l.add(method);
        return;
    }
    /**
     * Return a list of methods with the same name.
     *
     * @param String key
     * @return List list of methods
     */
    public List get(String key)
    {
        return (List) methodByNameMap.get(key);
    }
    /**
     *  <p>
     *  Find a method.  Attempts to find the
     *  most specific applicable method using the
     *  algorithm described in the JLS section
     *  15.12.2 (with the exception that it can't
     *  distinguish a primitive type argument from
     *  an object type argument, since in reflection
     *  primitive type arguments are represented by
     *  their object counterparts, so for an argument of
     *  type (say) java.lang.Integer, it will not be able
     *  to decide between a method that takes int and a
     *  method that takes java.lang.Integer as a parameter.
     *  </p>
     *
     *  <p>
     *  This turns out to be a relatively rare case
     *  where this is needed - however, functionality
     *  like this is needed.
     *  </p>
     *
     *  @param methodName name of method
     *  @param args the actual arguments with which the method is called
     *  @return the most specific applicable method, or null if no
     *  method is applicable.
     *  @throws AmbiguousException if there is more than one maximally
     *  specific applicable method
     */
    public Method find(String methodName, Object[] args)
        throws AmbiguousException
    {
        List methodList = get(methodName);
        if (methodList == null)
        {
            return null;
        }
        int l = args.length;
        Class[] classes = new Class[l];
        for(int i = 0; i < l; ++i)
        {
            Object arg = args[i];
            /*
             * if we are careful down below, a null argument goes in there
             * so we can know that the null was passed to the method
             */
            classes[i] =
                    arg == null ? null : arg.getClass();
        }
        return getMostSpecific(methodList, classes);
    }
    /**
     *  simple distinguishable exception, used when
     *  we run across ambiguous overloading
     */
    public static class AmbiguousException extends Exception
    {
    }
    private static Method getMostSpecific(List methods, Class[] classes)
        throws AmbiguousException
    {
        LinkedList applicables = getApplicables(methods, classes);
        if(applicables.isEmpty())
        {
            return null;
        }
        if(applicables.size() == 1)
        {
            return (Method)applicables.getFirst();
        }
        /*
         * This list will contain the maximally specific methods. Hopefully at
         * the end of the below loop, the list will contain exactly one method,
         * (the most specific method) otherwise we have ambiguity.
         */
        LinkedList maximals = new LinkedList();
        for (Iterator applicable = applicables.iterator();
             applicable.hasNext();)
        {
            Method app = (Method) applicable.next();
            Class[] appArgs = app.getParameterTypes();
            boolean lessSpecific = false;
            for (Iterator maximal = maximals.iterator();
                 !lessSpecific && maximal.hasNext();)
            {
                Method max = (Method) maximal.next();
                switch(moreSpecific(appArgs, max.getParameterTypes()))
                {
                    case MORE_SPECIFIC:
                    {
                        /*
                         * This method is more specific than the previously
                         * known maximally specific, so remove the old maximum.
                         */
                        maximal.remove();
                        break;
                    }
                    case LESS_SPECIFIC:
                    {
                        /*
                         * This method is less specific than some of the
                         * currently known maximally specific methods, so we
                         * won't add it into the set of maximally specific
                         * methods
                         */
                        lessSpecific = true;
                        break;
                    }
                }
            }
            if(!lessSpecific)
            {
                maximals.addLast(app);
            }
        }
        if(maximals.size() > 1)
        {
            // We have more than one maximally specific method
            throw new AmbiguousException();
        }
        return (Method)maximals.getFirst();
    }
    /**
     * Determines which method signature (represented by a class array) is more
     * specific. This defines a partial ordering on the method signatures.
     * @param c1 first signature to compare
     * @param c2 second signature to compare
     * @return MORE_SPECIFIC if c1 is more specific than c2, LESS_SPECIFIC if
     * c1 is less specific than c2, INCOMPARABLE if they are incomparable.
     */
    private static int moreSpecific(Class[] c1, Class[] c2)
    {
        boolean c1MoreSpecific = false;
        boolean c2MoreSpecific = false;
        for(int i = 0; i < c1.length; ++i)
        {
            if(c1[i] != c2[i])
            {
                c1MoreSpecific =
                    c1MoreSpecific ||
                    isStrictMethodInvocationConvertible(c2[i], c1[i]);
                c2MoreSpecific =
                    c2MoreSpecific ||
                    isStrictMethodInvocationConvertible(c1[i], c2[i]);
            }
        }
        if(c1MoreSpecific)
        {
            if(c2MoreSpecific)
            {
                /*
                 *  Incomparable due to cross-assignable arguments (i.e.
                 * foo(String, Object) vs. foo(Object, String))
                 */
                return INCOMPARABLE;
            }
            return MORE_SPECIFIC;
        }
        if(c2MoreSpecific)
        {
            return LESS_SPECIFIC;
        }
        /*
         * Incomparable due to non-related arguments (i.e.
         * foo(Runnable) vs. foo(Serializable))
         */
        return INCOMPARABLE;
    }
    /**
     * Returns all methods that are applicable to actual argument types.
     * @param methods list of all candidate methods
     * @param classes the actual types of the arguments
     * @return a list that contains only applicable methods (number of
     * formal and actual arguments matches, and argument types are assignable
     * to formal types through a method invocation conversion).
     */
    private static LinkedList getApplicables(List methods, Class[] classes)
    {
        LinkedList list = new LinkedList();
        for (Iterator imethod = methods.iterator(); imethod.hasNext();)
        {
            Method method = (Method) imethod.next();
            if(isApplicable(method, classes))
            {
                list.add(method);
            }
        }
        return list;
    }
    /**
     * Returns true if the supplied method is applicable to actual
     * argument types.
     */
    private static boolean isApplicable(Method method, Class[] classes)
    {
        Class[] methodArgs = method.getParameterTypes();
        if(methodArgs.length != classes.length)
        {
            return false;
        }
        for(int i = 0; i < classes.length; ++i)
        {
            if(!isMethodInvocationConvertible(methodArgs[i], classes[i]))
            {
                return false;
            }
        }
        return true;
    }
    /**
     * Determines whether a type represented by a class object is
     * convertible to another type represented by a class object using a
     * method invocation conversion, treating object types of primitive
     * types as if they were primitive types (that is, a Boolean actual
     * parameter type matches boolean primitive formal type). This behavior
     * is because this method is used to determine applicable methods for
     * an actual parameter list, and primitive types are represented by
     * their object duals in reflective method calls.
     *
     * @param formal the formal parameter type to which the actual
     * parameter type should be convertible
     * @param actual the actual parameter type.
     * @return true if either formal type is assignable from actual type,
     * or formal is a primitive type and actual is its corresponding object
     * type or an object type of a primitive type that can be converted to
     * the formal type.
     */
    private static boolean isMethodInvocationConvertible(Class formal,
                                                         Class actual)
    {
        /*
         * if it's a null, it means the arg was null
         */
        if (actual == null && !formal.isPrimitive())
        {
            return true;
        }
        /*
         *  Check for identity or widening reference conversion
         */
        if (actual != null && formal.isAssignableFrom(actual))
        {
            return true;
        }
        /*
         * Check for boxing with widening primitive conversion. Note that
         * actual parameters are never primitives.
         */
        if (formal.isPrimitive())
        {
            if(formal == Boolean.TYPE && actual == Boolean.class)
                return true;
            if(formal == Character.TYPE && actual == Character.class)
                return true;
            if(formal == Byte.TYPE && actual == Byte.class)
                return true;
            if(formal == Short.TYPE &&
               (actual == Short.class || actual == Byte.class))
                return true;
            if(formal == Integer.TYPE &&
               (actual == Integer.class || actual == Short.class ||
                actual == Byte.class))
                return true;
            if(formal == Long.TYPE &&
               (actual == Long.class || actual == Integer.class ||
                actual == Short.class || actual == Byte.class))
                return true;
            if(formal == Float.TYPE &&
               (actual == Float.class || actual == Long.class ||
                actual == Integer.class || actual == Short.class ||
                actual == Byte.class))
                return true;
            if(formal == Double.TYPE &&
               (actual == Double.class || actual == Float.class ||
                actual == Long.class || actual == Integer.class ||
                actual == Short.class || actual == Byte.class))
                return true;
        }
        return false;
    }
    /**
     * Determines whether a type represented by a class object is
     * convertible to another type represented by a class object using a
     * method invocation conversion, without matching object and primitive
     * types. This method is used to determine the more specific type when
     * comparing signatures of methods.
     *
     * @param formal the formal parameter type to which the actual
     * parameter type should be convertible
     * @param actual the actual parameter type.
     * @return true if either formal type is assignable from actual type,
     * or formal and actual are both primitive types and actual can be
     * subject to widening conversion to formal.
     */
    private static boolean isStrictMethodInvocationConvertible(Class formal,
                                                               Class actual)
    {
        /*
         * we shouldn't get a null into, but if so
         */
        if (actual == null && !formal.isPrimitive())
        {
            return true;
        }
        /*
         *  Check for identity or widening reference conversion
         */
        if(formal.isAssignableFrom(actual))
        {
            return true;
        }
        /*
         *  Check for widening primitive conversion.
         */
        if(formal.isPrimitive())
        {
            if(formal == Short.TYPE && (actual == Byte.TYPE))
                return true;
            if(formal == Integer.TYPE &&
               (actual == Short.TYPE || actual == Byte.TYPE))
                return true;
            if(formal == Long.TYPE &&
               (actual == Integer.TYPE || actual == Short.TYPE ||
                actual == Byte.TYPE))
                return true;
            if(formal == Float.TYPE &&
               (actual == Long.TYPE || actual == Integer.TYPE ||
                actual == Short.TYPE || actual == Byte.TYPE))
                return true;
            if(formal == Double.TYPE &&
               (actual == Float.TYPE || actual == Long.TYPE ||
                actual == Integer.TYPE || actual == Short.TYPE ||
                actual == Byte.TYPE))
                return true;
        }
        return false;
    }
}
"
org.apache.velocity.util.introspection.Uberspect,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.RuntimeLogger;
import java.util.Iterator;
import java.lang.reflect.Method;
/**
 * 'Federated' introspection/reflection interface to allow the introspection
 *  behavior in Velocity to be customized.
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magusson Jr.</a>
 * @version $Id: Uberspect.java,v 1.1.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public interface Uberspect
{
    /**
     *  Initializer - will be called before use
     */
    public void init() throws Exception;
    /**
     *  To support iteratives - #foreach()
     */
    public Iterator getIterator(Object obj, Info info) throws Exception;
    /**
     *  Returns a general method, corresponding to $foo.bar( $woogie )
     */
    public VelMethod getMethod(Object obj, String method, Object[] args, Info info) throws Exception;
    /**
     * Property getter - returns VelPropertyGet appropos for #set($foo = $bar.woogie)
     */
    public VelPropertyGet getPropertyGet(Object obj, String identifier, Info info) throws Exception;
    /**
     * Property setter - returns VelPropertySet appropos for #set($foo.bar = ""geir"")
     */
    public VelPropertySet getPropertySet(Object obj, String identifier, Object arg, Info info) throws Exception;
}
"
org.apache.velocity.util.introspection.UberspectImpl,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.util.ArrayIterator;
import org.apache.velocity.util.EnumerationIterator;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeLogger;
import org.apache.velocity.runtime.parser.node.AbstractExecutor;
import org.apache.velocity.runtime.parser.node.PropertyExecutor;
import org.apache.velocity.runtime.parser.node.GetExecutor;
import org.apache.velocity.runtime.parser.node.BooleanPropertyExecutor;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.Collection;
import java.util.Map;
import java.util.Enumeration;
import java.util.ArrayList;
/**
 *  Implementation of Uberspect to provide the default introspective
 *  functionality of Velocity
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: UberspectImpl.java,v 1.2.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public class UberspectImpl implements Uberspect, UberspectLoggable
{
    /**
     *  Our runtime logger.
     */
    private RuntimeLogger rlog;
    /**
     *  the default Velocity introspector
     */
    private static Introspector introspector;
    /**
     *  init - does nothing - we need to have setRuntimeLogger
     *  called before getting our introspector, as the default
     *  vel introspector depends upon it.
     */
    public void init()
        throws Exception
    {
    }
    /**
     *  Sets the runtime logger - this must be called before anything
     *  else besides init() as to get the logger.  Makes the pull
     *  model appealing...
     */
    public void setRuntimeLogger(RuntimeLogger runtimeLogger)
    {
        rlog = runtimeLogger;
        introspector = new Introspector(rlog);
    }
    /**
     *  To support iteratives - #foreach()
     */
    public Iterator getIterator(Object obj, Info i)
            throws Exception
    {
        if (obj.getClass().isArray())
        {
            return new ArrayIterator(obj);
        }
        else if (obj instanceof Collection)
        {
            return ((Collection) obj).iterator();
        }
        else if (obj instanceof Map)
        {
            return ((Map) obj).values().iterator();
        }
        else if (obj instanceof Iterator)
        {
            rlog.warn (""Warning! The iterative ""
                          + "" is an Iterator in the #foreach() loop at [""
                          + i.getLine() + "","" + i.getColumn() + ""]""
                          + "" in template "" + i.getTemplateName()
                          + "". Because it's not resetable,""
                          + "" if used in more than once, this may lead to""
                          + "" unexpected results."");
            return ((Iterator) obj);
        }
        else if (obj instanceof Enumeration)
        {
            rlog.warn (""Warning! The iterative ""
                          + "" is an Enumeration in the #foreach() loop at [""
                          + i.getLine() + "","" + i.getColumn() + ""]""
                          + "" in template "" + i.getTemplateName()
                          + "". Because it's not resetable,""
                          + "" if used in more than once, this may lead to""
                          + "" unexpected results."");
            return new EnumerationIterator((Enumeration) obj);
        }
        /*  we have no clue what this is  */
        rlog.warn (""Could not determine type of iterator in ""
                      +  ""#foreach loop ""
                      + "" at ["" + i.getLine() + "","" + i.getColumn() + ""]""
                      + "" in template "" + i.getTemplateName() );
        return null;
    }
    /**
     *  Method
     */
    public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i)
            throws Exception
    {
        if (obj == null)
            return null;
        Method m = introspector.getMethod(obj.getClass(), methodName, args);
        return (m != null) ? new VelMethodImpl(m) : null;
    }
    /**
     * Property  getter
     */
    public VelPropertyGet getPropertyGet(Object obj, String identifier, Info i)
            throws Exception
    {
        AbstractExecutor executor;
        Class claz = obj.getClass();
        /*
         *  first try for a getFoo() type of property
         *  (also getfoo() )
         */
        executor = new PropertyExecutor(rlog,introspector, claz, identifier);
        /*
         *  if that didn't work, look for get(""foo"")
         */
        if (executor.isAlive() == false)
        {
            executor = new GetExecutor(rlog, introspector, claz, identifier);
        }
        /*
         *  finally, look for boolean isFoo()
         */
        if( executor.isAlive() == false)
        {
            executor = new BooleanPropertyExecutor(rlog, introspector, claz, identifier);
        }
        return (executor != null) ? new VelGetterImpl(executor) : null;
    }
    /**
     * Property setter
     */
    public VelPropertySet getPropertySet(Object obj, String identifier, Object arg, Info i)
            throws Exception
    {
        Class claz = obj.getClass();
        VelPropertySet vs = null;
        VelMethod vm = null;
        try
        {
            /*
             *  first, we introspect for the set<identifier> setter method
             */
            Object[] params = {arg};
            try
            {
                vm = getMethod(obj, ""set"" + identifier, params, i);
                if (vm == null)
                {
                   throw new NoSuchMethodException();
                }
            }
            catch(NoSuchMethodException nsme2)
            {
                StringBuffer sb = new StringBuffer(""set"");
                sb.append(identifier);
                if (Character.isLowerCase( sb.charAt(3)))
                {
                    sb.setCharAt(3, Character.toUpperCase(sb.charAt(3)));
                }
                else
                {
                    sb.setCharAt(3, Character.toLowerCase(sb.charAt(3)));
                }
                vm = getMethod(obj, sb.toString(), params, i);
                if (vm == null)
                {
                   throw new NoSuchMethodException();
                }
            }
        }
        catch (NoSuchMethodException nsme)
        {
            /*
             *  right now, we only support the Map interface
             */
            if (Map.class.isAssignableFrom(claz))
            {
                Object[] params = {new Object(), new Object()};
                vm = getMethod(obj, ""put"", params, i);
                if (vm!=null)
                    return new VelSetterImpl(vm, identifier);
            }
       }
       return (vm!=null) ?  new VelSetterImpl(vm) : null;
    }
    /**
     *  Implementation of VelMethod
     */
    public class VelMethodImpl implements VelMethod
    {
        Method method = null;
        public VelMethodImpl(Method m)
        {
            method = m;
        }
        private VelMethodImpl()
        {
        }
        public Object invoke(Object o, Object[] params)
            throws Exception
        {
            return method.invoke(o, params);
        }
        public boolean isCacheable()
        {
            return true;
        }
        public String getMethodName()
        {
            return method.getName();
        }
        public Class getReturnType()
        {
            return method.getReturnType();
        }
    }
    public class VelGetterImpl implements VelPropertyGet
    {
        AbstractExecutor ae = null;
        public VelGetterImpl(AbstractExecutor exec)
        {
            ae = exec;
        }
        private VelGetterImpl()
        {
        }
        public Object invoke(Object o)
            throws Exception
        {
            return ae.execute(o);
        }
        public boolean isCacheable()
        {
            return true;
        }
        public String getMethodName()
        {
            return ae.getMethod().getName();
        }
    }
    public class VelSetterImpl implements VelPropertySet
    {
        VelMethod vm = null;
        String putKey = null;
        public VelSetterImpl(VelMethod velmethod)
        {
            this.vm = velmethod;
        }
        public VelSetterImpl(VelMethod velmethod, String key)
        {
            this.vm = velmethod;
            putKey = key;
        }
        private VelSetterImpl()
        {
        }
        public Object invoke(Object o, Object value)
            throws Exception
        {
            ArrayList al = new ArrayList();
            if (putKey != null)
            {
                al.add(putKey);
                al.add(value);
            }
            else
            {
                al.add(value);
            }
            return vm.invoke(o,al.toArray());
        }
        public boolean isCacheable()
        {
            return true;
        }
        public String getMethodName()
        {
            return vm.getMethodName();
        }
    }
}
"
org.apache.velocity.util.introspection.UberspectLoggable,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.velocity.runtime.RuntimeLogger;
/**
 *  Marker interface to let an uberspector indicate it can and wants to
 *  log
 *
 *  Thanks to Paulo for the suggestion
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: UberspectLoggable.java,v 1.1.4.1 2004/03/03 23:23:08 geirm Exp $
 *
 */
public interface UberspectLoggable
{
    /**
     *  Sets the logger.  This will be called before any calls to the
     *  uberspector
     */
    public void setRuntimeLogger(RuntimeLogger logger);
}
"
org.apache.velocity.util.introspection.VelMethod,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Method used for regular method invocation
 *
 *    $foo.bar()
 *
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelMethod.java,v 1.2.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public interface VelMethod
{
    /**
     *  invocation method - called when the method invocationshould be
     *  preformed and a value returned
     */
    public Object invoke(Object o, Object[] params)
        throws Exception;
    /**
     *  specifies if this VelMethod is cacheable and able to be
     *  reused for this class of object it was returned for
     *
     *  @return true if can be reused for this class, false if not
     */
    public boolean isCacheable();
    /**
     *  returns the method name used
     */
    public String getMethodName();
    /**
     *  returns the return type of the method invoked
     */
    public Class getReturnType();
}
"
org.apache.velocity.util.introspection.VelPropertyGet,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Interface defining a 'getter'.  For uses when looking for resolution of
 *  property references
 *
 *       $foo.bar
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelPropertyGet.java,v 1.1.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public interface VelPropertyGet
{
    /**
     *  invocation method - called when the 'get action' should be
     *  preformed and a value returned
     */
    public Object invoke(Object o) throws Exception;
    /**
     *  specifies if this VelPropertyGet is cacheable and able to be
     *  reused for this class of object it was returned for
     *
     *  @return true if can be reused for this class, false if not
     */
    public boolean isCacheable();
    /**
     *  returns the method name used to return this 'property'
     */
    public String getMethodName();
}
"
org.apache.velocity.util.introspection.VelPropertySet,"package org.apache.velocity.util.introspection;
/*
 * Copyright 2002,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  Interface used for setting values that appear to be properties in
 *  Velocity.  Ex.
 *
 *      #set($foo.bar = ""hello"")
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelPropertySet.java,v 1.1.4.1 2004/03/03 23:23:08 geirm Exp $
 */
public interface VelPropertySet
{
    /**
     *  method used to set the value in the object
     *
     *  @param o Object on which the method will be called with the arg
     *  @param arg value to be set
     *  @return the value returned from the set operation (impl specific)
     */
    public Object invoke(Object o, Object arg) throws Exception;
    /**
     *  specifies if this VelPropertySet is cacheable and able to be
     *  reused for this class of object it was returned for
     *
     *  @return true if can be reused for this class, false if not
     */
    public boolean isCacheable();
    /**
     *  returns the method name used to set this 'property'
     */
    public String getMethodName();
}
"
