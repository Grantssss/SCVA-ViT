metric_name,file
org.apache.lucene.LucenePackage,"/*    */ package org.apache.lucene;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LucenePackage
/*    */ {
/* 27 */   public static Package get() { return LucenePackage.class.getPackage(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\LucenePackage.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Analyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Analyzer
/*    */ {
/*    */   public abstract TokenStream tokenStream(String paramString, Reader paramReader);
/*    */   
/* 56 */   public int getPositionIncrementGap(String fieldName) { return 0; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\Analyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.CachingTokenFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.LinkedList;
/*    */ import java.util.List;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CachingTokenFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   private List cache;
/*    */   private int index;
/*    */   
/* 39 */   public CachingTokenFilter(TokenStream input) { super(input); }
/*    */ 
/*    */   
/*    */   public Token next() throws IOException {
/* 43 */     if (this.cache == null) {
/*    */       
/* 45 */       this.cache = new LinkedList();
/* 46 */       fillCache();
/*    */     } 
/*    */     
/* 49 */     if (this.index == this.cache.size())
/*    */     {
/* 51 */       return null;
/*    */     }
/*    */     
/* 54 */     return this.cache.get(this.index++);
/*    */   }
/*    */ 
/*    */   
/* 58 */   public void reset() throws IOException { this.index = 0; }
/*    */ 
/*    */   
/*    */   private void fillCache() throws IOException {
/*    */     Token token;
/* 63 */     while ((token = this.input.next()) != null)
/* 64 */       this.cache.add(token); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\CachingTokenFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.CharTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class CharTokenizer
/*    */   extends Tokenizer
/*    */ {
/*    */   private int offset;
/*    */   private int bufferIndex;
/*    */   private int dataLen;
/*    */   private static final int MAX_WORD_LEN = 255;
/*    */   private static final int IO_BUFFER_SIZE = 1024;
/*    */   private final char[] buffer;
/*    */   private final char[] ioBuffer;
/*    */   
/*    */   public CharTokenizer(Reader input) {
/* 26 */     super(input);
/*    */ 
/*    */     
/* 29 */     this.offset = 0; this.bufferIndex = 0; this.dataLen = 0;
/*    */ 
/*    */     
/* 32 */     this.buffer = new char[255];
/* 33 */     this.ioBuffer = new char[1024];
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected abstract boolean isTokenChar(char paramChar);
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 45 */   protected char normalize(char c) { return c; }
/*    */ 
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 50 */     int length = 0;
/* 51 */     int start = this.offset;
/*    */ 
/*    */     
/*    */     while (true) {
/* 55 */       this.offset++;
/* 56 */       if (this.bufferIndex >= this.dataLen) {
/* 57 */         this.dataLen = this.input.read(this.ioBuffer);
/* 58 */         this.bufferIndex = 0;
/*    */       } 
/*    */       
/* 61 */       if (this.dataLen == -1) {
/* 62 */         if (length > 0) {
/*    */           break;
/*    */         }
/* 65 */         return null;
/*    */       } 
/* 67 */       char c = this.ioBuffer[this.bufferIndex++];
/*    */       
/* 69 */       if (isTokenChar(c)) {
/*    */         
/* 71 */         if (length == 0) {
/* 72 */           start = this.offset - 1;
/*    */         }
/* 74 */         this.buffer[length++] = normalize(c);
/*    */         
/* 76 */         if (length == 255)
/*    */           break;  continue;
/*    */       } 
/* 79 */       if (length > 0) {
/*    */         break;
/*    */       }
/*    */     } 
/*    */     
/* 84 */     return new Token(new String(this.buffer, 0, length), start, start + length);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\CharTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.ISOLatin1AccentFilter,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ISOLatin1AccentFilter
/*     */   extends TokenFilter
/*     */ {
/*  29 */   public ISOLatin1AccentFilter(TokenStream input) { super(input); }
/*     */ 
/*     */   
/*     */   public final Token next() throws IOException {
/*  33 */     Token t = this.input.next();
/*  34 */     if (t != null)
/*  35 */       t.setTermText(removeAccents(t.termText())); 
/*  36 */     return t;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final String removeAccents(String input) {
/*  43 */     StringBuffer output = new StringBuffer();
/*  44 */     for (int i = 0; i < input.length(); i++) {
/*  45 */       switch (input.charAt(i)) {
/*     */         case 'À':
/*     */         case 'Á':
/*     */         case 'Â':
/*     */         case 'Ã':
/*     */         case 'Ä':
/*     */         case 'Å':
/*  52 */           output.append(""A"");
/*     */           break;
/*     */         case 'Æ':
/*  55 */           output.append(""AE"");
/*     */           break;
/*     */         case 'Ç':
/*  58 */           output.append(""C"");
/*     */           break;
/*     */         case 'È':
/*     */         case 'É':
/*     */         case 'Ê':
/*     */         case 'Ë':
/*  64 */           output.append(""E"");
/*     */           break;
/*     */         case 'Ì':
/*     */         case 'Í':
/*     */         case 'Î':
/*     */         case 'Ï':
/*  70 */           output.append(""I"");
/*     */           break;
/*     */         case 'Ð':
/*  73 */           output.append(""D"");
/*     */           break;
/*     */         case 'Ñ':
/*  76 */           output.append(""N"");
/*     */           break;
/*     */         case 'Ò':
/*     */         case 'Ó':
/*     */         case 'Ô':
/*     */         case 'Õ':
/*     */         case 'Ö':
/*     */         case 'Ø':
/*  84 */           output.append(""O"");
/*     */           break;
/*     */         case 'Œ':
/*  87 */           output.append(""OE"");
/*     */           break;
/*     */         case 'Þ':
/*  90 */           output.append(""TH"");
/*     */           break;
/*     */         case 'Ù':
/*     */         case 'Ú':
/*     */         case 'Û':
/*     */         case 'Ü':
/*  96 */           output.append(""U"");
/*     */           break;
/*     */         case 'Ý':
/*     */         case 'Ÿ':
/* 100 */           output.append(""Y"");
/*     */           break;
/*     */         case 'à':
/*     */         case 'á':
/*     */         case 'â':
/*     */         case 'ã':
/*     */         case 'ä':
/*     */         case 'å':
/* 108 */           output.append(""a"");
/*     */           break;
/*     */         case 'æ':
/* 111 */           output.append(""ae"");
/*     */           break;
/*     */         case 'ç':
/* 114 */           output.append(""c"");
/*     */           break;
/*     */         case 'è':
/*     */         case 'é':
/*     */         case 'ê':
/*     */         case 'ë':
/* 120 */           output.append(""e"");
/*     */           break;
/*     */         case 'ì':
/*     */         case 'í':
/*     */         case 'î':
/*     */         case 'ï':
/* 126 */           output.append(""i"");
/*     */           break;
/*     */         case 'ð':
/* 129 */           output.append(""d"");
/*     */           break;
/*     */         case 'ñ':
/* 132 */           output.append(""n"");
/*     */           break;
/*     */         case 'ò':
/*     */         case 'ó':
/*     */         case 'ô':
/*     */         case 'õ':
/*     */         case 'ö':
/*     */         case 'ø':
/* 140 */           output.append(""o"");
/*     */           break;
/*     */         case 'œ':
/* 143 */           output.append(""oe"");
/*     */           break;
/*     */         case 'ß':
/* 146 */           output.append(""ss"");
/*     */           break;
/*     */         case 'þ':
/* 149 */           output.append(""th"");
/*     */           break;
/*     */         case 'ù':
/*     */         case 'ú':
/*     */         case 'û':
/*     */         case 'ü':
/* 155 */           output.append(""u"");
/*     */           break;
/*     */         case 'ý':
/*     */         case 'ÿ':
/* 159 */           output.append(""y"");
/*     */           break;
/*     */         default:
/* 162 */           output.append(input.charAt(i));
/*     */           break;
/*     */       } 
/*     */     } 
/* 166 */     return output.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\ISOLatin1AccentFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.KeywordAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class KeywordAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 29 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new KeywordTokenizer(reader); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\KeywordAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.KeywordTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class KeywordTokenizer
/*    */   extends Tokenizer
/*    */ {
/*    */   private static final int DEFAULT_BUFFER_SIZE = 256;
/*    */   private boolean done;
/*    */   private final char[] buffer;
/*    */   
/* 34 */   public KeywordTokenizer(Reader input) { this(input, 256); }
/*    */ 
/*    */   
/*    */   public KeywordTokenizer(Reader input, int bufferSize) {
/* 38 */     super(input);
/* 39 */     this.buffer = new char[bufferSize];
/* 40 */     this.done = false;
/*    */   }
/*    */   
/*    */   public Token next() throws IOException {
/* 44 */     if (!this.done) {
/* 45 */       this.done = true;
/* 46 */       StringBuffer buffer = new StringBuffer();
/*    */       
/*    */       while (true) {
/* 49 */         int length = this.input.read(this.buffer);
/* 50 */         if (length == -1)
/*    */           break; 
/* 52 */         buffer.append(this.buffer, 0, length);
/*    */       } 
/* 54 */       String text = buffer.toString();
/* 55 */       return new Token(text, 0, text.length());
/*    */     } 
/* 57 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\KeywordTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LengthFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LengthFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   final int min;
/*    */   final int max;
/*    */   
/*    */   public LengthFilter(TokenStream in, int min, int max) {
/* 39 */     super(in);
/* 40 */     this.min = min;
/* 41 */     this.max = max;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 50 */     for (Token token = this.input.next(); token != null; token = this.input.next()) {
/*    */       
/* 52 */       int len = token.termText().length();
/* 53 */       if (len >= this.min && len <= this.max) {
/* 54 */         return token;
/*    */       }
/*    */     } 
/*    */ 
/*    */     
/* 59 */     return null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\LengthFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LetterTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LetterTokenizer
/*    */   extends CharTokenizer
/*    */ {
/* 32 */   public LetterTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 38 */   protected boolean isTokenChar(char c) { return Character.isLetter(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\LetterTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LowerCaseFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LowerCaseFilter
/*    */   extends TokenFilter
/*    */ {
/* 29 */   public LowerCaseFilter(TokenStream in) { super(in); }
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 33 */     Token t = this.input.next();
/*    */     
/* 35 */     if (t == null) {
/* 36 */       return null;
/*    */     }
/* 38 */     t.termText = t.termText.toLowerCase();
/*    */     
/* 40 */     return t;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\LowerCaseFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.LowerCaseTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class LowerCaseTokenizer
/*    */   extends LetterTokenizer
/*    */ {
/* 35 */   public LowerCaseTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   protected char normalize(char c) { return Character.toLowerCase(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\LowerCaseTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PerFieldAnalyzerWrapper,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PerFieldAnalyzerWrapper
/*    */   extends Analyzer
/*    */ {
/*    */   private Analyzer defaultAnalyzer;
/* 46 */   private Map analyzerMap = new HashMap();
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 56 */   public PerFieldAnalyzerWrapper(Analyzer defaultAnalyzer) { this.defaultAnalyzer = defaultAnalyzer; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 66 */   public void addAnalyzer(String fieldName, Analyzer analyzer) { this.analyzerMap.put(fieldName, analyzer); }
/*    */ 
/*    */   
/*    */   public TokenStream tokenStream(String fieldName, Reader reader) {
/* 70 */     Analyzer analyzer = (Analyzer)this.analyzerMap.get(fieldName);
/* 71 */     if (analyzer == null) {
/* 72 */       analyzer = this.defaultAnalyzer;
/*    */     }
/*    */     
/* 75 */     return analyzer.tokenStream(fieldName, reader);
/*    */   }
/*    */ 
/*    */   
/*    */   public int getPositionIncrementGap(String fieldName) {
/* 80 */     Analyzer analyzer = (Analyzer)this.analyzerMap.get(fieldName);
/* 81 */     if (analyzer == null)
/* 82 */       analyzer = this.defaultAnalyzer; 
/* 83 */     return analyzer.getPositionIncrementGap(fieldName);
/*    */   }
/*    */ 
/*    */   
/* 87 */   public String toString() { return ""PerFieldAnalyzerWrapper("" + this.analyzerMap + "", default="" + this.defaultAnalyzer + "")""; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\PerFieldAnalyzerWrapper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PorterStemFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class PorterStemFilter
/*    */   extends TokenFilter
/*    */ {
/*    */   private PorterStemmer stemmer;
/*    */   
/*    */   public PorterStemFilter(TokenStream in) {
/* 44 */     super(in);
/* 45 */     this.stemmer = new PorterStemmer();
/*    */   }
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 50 */     Token token = this.input.next();
/* 51 */     if (token == null) {
/* 52 */       return null;
/*    */     }
/* 54 */     String s = this.stemmer.stem(token.termText);
/* 55 */     if (s != token.termText)
/* 56 */       token.termText = s; 
/* 57 */     return token;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\PorterStemFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.PorterStemmer,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.FileInputStream;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class PorterStemmer
/*     */ {
/*     */   private char[] b;
/*     */   private int i;
/*     */   private int j;
/*     */   private int k;
/*     */   private int k0;
/*     */   private boolean dirty = false;
/*     */   private static final int INC = 50;
/*     */   private static final int EXTRA = 1;
/*     */   
/*     */   public PorterStemmer() {
/*  68 */     this.b = new char[50];
/*  69 */     this.i = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   public void reset() { this.i = 0; this.dirty = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(char ch) {
/*  84 */     if (this.b.length <= this.i + 1) {
/*  85 */       char[] new_b = new char[this.b.length + 50];
/*  86 */       for (int c = 0; c < this.b.length; c++)
/*  87 */         new_b[c] = this.b[c]; 
/*  88 */       this.b = new_b;
/*     */     } 
/*  90 */     this.b[this.i++] = ch;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   public String toString() { return new String(this.b, 0, this.i); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   public int getResultLength() { return this.i; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 110 */   public char[] getResultBuffer() { return this.b; }
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean cons(int i) {
/* 115 */     switch (this.b[i]) { case 'a': case 'e': case 'i': case 'o':
/*     */       case 'u':
/* 117 */         return false;
/*     */       case 'y':
/* 119 */         return (i == this.k0) ? true : (!cons(i - 1)); }
/*     */     
/* 121 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int m() {
/* 137 */     int n = 0;
/* 138 */     int i = this.k0;
/*     */     while (true) {
/* 140 */       if (i > this.j)
/* 141 */         return n; 
/* 142 */       if (!cons(i))
/*     */         break; 
/* 144 */       i++;
/*     */     } 
/* 146 */     i++;
/*     */     
/*     */     while (true) {
/* 149 */       if (i > this.j)
/* 150 */         return n; 
/* 151 */       if (cons(i)) {
/*     */ 
/*     */ 
/*     */         
/* 155 */         i++;
/* 156 */         n++;
/*     */         while (true) {
/* 158 */           if (i > this.j)
/* 159 */             return n; 
/* 160 */           if (!cons(i))
/*     */             break; 
/* 162 */           i++;
/*     */         } 
/* 164 */         i++;
/*     */         continue;
/*     */       } 
/*     */       i++;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final boolean vowelinstem() {
/* 172 */     for (int i = this.k0; i <= this.j; i++) {
/* 173 */       if (!cons(i))
/* 174 */         return true; 
/* 175 */     }  return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean doublec(int j) {
/* 181 */     if (j < this.k0 + 1)
/* 182 */       return false; 
/* 183 */     if (this.b[j] != this.b[j - 1])
/* 184 */       return false; 
/* 185 */     return cons(j);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final boolean cvc(int i) {
/* 198 */     if (i < this.k0 + 2 || !cons(i) || cons(i - 1) || !cons(i - 2)) {
/* 199 */       return false;
/*     */     }
/* 201 */     int ch = this.b[i];
/* 202 */     if (ch == 119 || ch == 120 || ch == 121) return false;
/*     */     
/* 204 */     return true;
/*     */   }
/*     */   
/*     */   private final boolean ends(String s) {
/* 208 */     int l = s.length();
/* 209 */     int o = this.k - l + 1;
/* 210 */     if (o < this.k0)
/* 211 */       return false; 
/* 212 */     for (int i = 0; i < l; i++) {
/* 213 */       if (this.b[o + i] != s.charAt(i))
/* 214 */         return false; 
/* 215 */     }  this.j = this.k - l;
/* 216 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setto(String s) {
/* 223 */     int l = s.length();
/* 224 */     int o = this.j + 1;
/* 225 */     for (int i = 0; i < l; i++)
/* 226 */       this.b[o + i] = s.charAt(i); 
/* 227 */     this.k = this.j + l;
/* 228 */     this.dirty = true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 233 */   void r(String s) { if (m() > 0) setto(s);
/*     */      }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void step1() {
/* 258 */     if (this.b[this.k] == 's')
/* 259 */       if (ends(""sses"")) { this.k -= 2; }
/* 260 */       else if (ends(""ies"")) { setto(""i""); }
/* 261 */       else if (this.b[this.k - 1] != 's') { this.k--; }
/*     */        
/* 263 */     if (ends(""eed"")) {
/* 264 */       if (m() > 0) {
/* 265 */         this.k--;
/*     */       }
/* 267 */     } else if ((ends(""ed"") || ends(""ing"")) && vowelinstem()) {
/* 268 */       this.k = this.j;
/* 269 */       if (ends(""at"")) { setto(""ate""); }
/* 270 */       else if (ends(""bl"")) { setto(""ble""); }
/* 271 */       else if (ends(""iz"")) { setto(""ize""); }
/* 272 */       else if (doublec(this.k))
/* 273 */       { int ch = this.b[this.k--];
/* 274 */         if (ch == 108 || ch == 115 || ch == 122) {
/* 275 */           this.k++;
/*     */         } }
/* 277 */       else if (m() == 1 && cvc(this.k))
/* 278 */       { setto(""e""); }
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step2() {
/* 285 */     if (ends(""y"") && vowelinstem()) {
/* 286 */       this.b[this.k] = 'i';
/* 287 */       this.dirty = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void step3() {
/* 296 */     if (this.k == this.k0)
/* 297 */       return;  switch (this.b[this.k - 1]) {
/*     */       case 'a':
/* 299 */         if (ends(""ational"")) { r(""ate""); break; }
/* 300 */          if (ends(""tional"")) r(""tion""); 
/*     */         break;
/*     */       case 'c':
/* 303 */         if (ends(""enci"")) { r(""ence""); break; }
/* 304 */          if (ends(""anci"")) r(""ance""); 
/*     */         break;
/*     */       case 'e':
/* 307 */         if (ends(""izer"")) r(""ize""); 
/*     */         break;
/*     */       case 'l':
/* 310 */         if (ends(""bli"")) { r(""ble""); break; }
/* 311 */          if (ends(""alli"")) { r(""al""); break; }
/* 312 */          if (ends(""entli"")) { r(""ent""); break; }
/* 313 */          if (ends(""eli"")) { r(""e""); break; }
/* 314 */          if (ends(""ousli"")) r(""ous""); 
/*     */         break;
/*     */       case 'o':
/* 317 */         if (ends(""ization"")) { r(""ize""); break; }
/* 318 */          if (ends(""ation"")) { r(""ate""); break; }
/* 319 */          if (ends(""ator"")) r(""ate""); 
/*     */         break;
/*     */       case 's':
/* 322 */         if (ends(""alism"")) { r(""al""); break; }
/* 323 */          if (ends(""iveness"")) { r(""ive""); break; }
/* 324 */          if (ends(""fulness"")) { r(""ful""); break; }
/* 325 */          if (ends(""ousness"")) r(""ous""); 
/*     */         break;
/*     */       case 't':
/* 328 */         if (ends(""aliti"")) { r(""al""); break; }
/* 329 */          if (ends(""iviti"")) { r(""ive""); break; }
/* 330 */          if (ends(""biliti"")) r(""ble""); 
/*     */         break;
/*     */       case 'g':
/* 333 */         if (ends(""logi"")) r(""log"");
/*     */         
/*     */         break;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void step4() {
/* 340 */     switch (this.b[this.k]) {
/*     */       case 'e':
/* 342 */         if (ends(""icate"")) { r(""ic""); break; }
/* 343 */          if (ends(""ative"")) { r(""""); break; }
/* 344 */          if (ends(""alize"")) r(""al""); 
/*     */         break;
/*     */       case 'i':
/* 347 */         if (ends(""iciti"")) r(""ic""); 
/*     */         break;
/*     */       case 'l':
/* 350 */         if (ends(""ical"")) { r(""ic""); break; }
/* 351 */          if (ends(""ful"")) r(""""); 
/*     */         break;
/*     */       case 's':
/* 354 */         if (ends(""ness"")) r("""");
/*     */         
/*     */         break;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step5() {
/* 362 */     if (this.k == this.k0)
/* 363 */       return;  switch (this.b[this.k - 1]) {
/*     */       case 'a':
/* 365 */         if (ends(""al""))
/*     */           break;  return;
/*     */       case 'c':
/* 368 */         if (ends(""ance"") || 
/* 369 */           ends(""ence""))
/*     */           break;  return;
/*     */       case 'e':
/* 372 */         if (ends(""er""))
/*     */           break;  return;
/* 374 */       case 'i': if (ends(""ic""))
/*     */           break;  return;
/* 376 */       case 'l': if (ends(""able"") || 
/* 377 */           ends(""ible""))
/*     */           break;  return;
/* 379 */       case 'n': if (ends(""ant"") || 
/* 380 */           ends(""ement"") || 
/* 381 */           ends(""ment""))
/*     */           break; 
/* 383 */         if (ends(""ent""))
/*     */           break;  return;
/*     */       case 'o':
/* 386 */         if (ends(""ion"") && this.j >= 0 && (this.b[this.j] == 's' || this.b[this.j] == 't'))
/*     */           break; 
/* 388 */         if (ends(""ou""))
/*     */           break; 
/*     */         return;
/*     */       case 's':
/* 392 */         if (ends(""ism""))
/*     */           break;  return;
/*     */       case 't':
/* 395 */         if (ends(""ate"") || 
/* 396 */           ends(""iti""))
/*     */           break;  return;
/*     */       case 'u':
/* 399 */         if (ends(""ous""))
/*     */           break;  return;
/*     */       case 'v':
/* 402 */         if (ends(""ive""))
/*     */           break;  return;
/*     */       case 'z':
/* 405 */         if (ends(""ize""))
/*     */           break;  return;
/*     */       default:
/*     */         return;
/*     */     } 
/* 410 */     if (m() > 1) {
/* 411 */       this.k = this.j;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private final void step6() {
/* 417 */     this.j = this.k;
/* 418 */     if (this.b[this.k] == 'e') {
/* 419 */       int a = m();
/* 420 */       if (a > 1 || (a == 1 && !cvc(this.k - 1)))
/* 421 */         this.k--; 
/*     */     } 
/* 423 */     if (this.b[this.k] == 'l' && doublec(this.k) && m() > 1) {
/* 424 */       this.k--;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String stem(String s) {
/* 432 */     if (stem(s.toCharArray(), s.length())) {
/* 433 */       return toString();
/*     */     }
/* 435 */     return s;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 443 */   public boolean stem(char[] word) { return stem(word, word.length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean stem(char[] wordBuffer, int offset, int wordLen) {
/* 452 */     reset();
/* 453 */     if (this.b.length < wordLen) {
/* 454 */       char[] new_b = new char[wordLen + 1];
/* 455 */       this.b = new_b;
/*     */     } 
/* 457 */     for (int j = 0; j < wordLen; j++)
/* 458 */       this.b[j] = wordBuffer[offset + j]; 
/* 459 */     this.i = wordLen;
/* 460 */     return stem(0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 469 */   public boolean stem(char[] word, int wordLen) { return stem(word, 0, wordLen); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 478 */   public boolean stem() { return stem(0); }
/*     */ 
/*     */   
/*     */   public boolean stem(int i0) {
/* 482 */     this.k = this.i - 1;
/* 483 */     this.k0 = i0;
/* 484 */     if (this.k > this.k0 + 1) {
/* 485 */       step1(); step2(); step3(); step4(); step5(); step6();
/*     */     } 
/*     */ 
/*     */     
/* 489 */     if (this.i != this.k + 1)
/* 490 */       this.dirty = true; 
/* 491 */     this.i = this.k + 1;
/* 492 */     return this.dirty;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) {
/* 500 */     PorterStemmer s = new PorterStemmer();
/*     */     
/* 502 */     for (int i = 0; i < args.length; i++) {
/*     */       try {
/* 504 */         InputStream in = new FileInputStream(args[i]);
/* 505 */         byte[] buffer = new byte[1024];
/*     */ 
/*     */         
/* 508 */         int bufferLen = in.read(buffer);
/* 509 */         int offset = 0;
/* 510 */         s.reset();
/*     */         while (true) {
/*     */           int ch;
/* 513 */           if (offset < bufferLen) {
/* 514 */             ch = buffer[offset++];
/*     */           } else {
/* 516 */             bufferLen = in.read(buffer);
/* 517 */             offset = 0;
/* 518 */             if (bufferLen < 0) {
/* 519 */               ch = -1;
/*     */             } else {
/* 521 */               ch = buffer[offset++];
/*     */             } 
/*     */           } 
/* 524 */           if (Character.isLetter((char)ch)) {
/* 525 */             s.add(Character.toLowerCase((char)ch));
/*     */             continue;
/*     */           } 
/* 528 */           s.stem();
/* 529 */           System.out.print(s.toString());
/* 530 */           s.reset();
/* 531 */           if (ch < 0) {
/*     */             break;
/*     */           }
/* 534 */           System.out.print((char)ch);
/*     */         } 
/*     */ 
/*     */ 
/*     */         
/* 539 */         in.close();
/*     */       }
/* 541 */       catch (IOException e) {
/* 542 */         System.out.println(""error reading "" + args[i]);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\PorterStemmer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.SimpleAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class SimpleAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 26 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new LowerCaseTokenizer(reader); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\SimpleAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.StopAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ import java.util.Set;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class StopAnalyzer
/*    */   extends Analyzer
/*    */ {
/*    */   private Set stopWords;
/* 32 */   public static final String[] ENGLISH_STOP_WORDS = new String[] { ""a"", ""an"", ""and"", ""are"", ""as"", ""at"", ""be"", ""but"", ""by"", ""for"", ""if"", ""in"", ""into"", ""is"", ""it"", ""no"", ""not"", ""of"", ""on"", ""or"", ""such"", ""that"", ""the"", ""their"", ""then"", ""there"", ""these"", ""they"", ""this"", ""to"", ""was"", ""will"", ""with"" };
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 42 */   public StopAnalyzer() { this.stopWords = StopFilter.makeStopSet(ENGLISH_STOP_WORDS); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public StopAnalyzer(Set stopWords) { this.stopWords = stopWords; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 53 */   public StopAnalyzer(String[] stopWords) { this.stopWords = StopFilter.makeStopSet(stopWords); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 60 */   public StopAnalyzer(File stopwordsFile) throws IOException { this.stopWords = WordlistLoader.getWordSet(stopwordsFile); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 67 */   public StopAnalyzer(Reader stopwords) throws IOException { this.stopWords = WordlistLoader.getWordSet(stopwords); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 72 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new StopFilter(new LowerCaseTokenizer(reader), this.stopWords); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\StopAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.StopFilter,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Set;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class StopFilter
/*     */   extends TokenFilter
/*     */ {
/*     */   private final Set stopWords;
/*     */   private final boolean ignoreCase;
/*     */   
/*  38 */   public StopFilter(TokenStream input, String[] stopWords) { this(input, stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StopFilter(TokenStream in, String[] stopWords, boolean ignoreCase) {
/*  46 */     super(in);
/*  47 */     this.ignoreCase = ignoreCase;
/*  48 */     this.stopWords = makeStopSet(stopWords, ignoreCase);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public StopFilter(TokenStream input, Set stopWords, boolean ignoreCase) {
/*  60 */     super(input);
/*  61 */     this.ignoreCase = ignoreCase;
/*  62 */     this.stopWords = stopWords;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  74 */   public StopFilter(TokenStream in, Set stopWords) { this(in, stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public static final Set makeStopSet(String[] stopWords) { return makeStopSet(stopWords, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final Set makeStopSet(String[] stopWords, boolean ignoreCase) {
/*  96 */     HashSet stopTable = new HashSet(stopWords.length);
/*  97 */     for (int i = 0; i < stopWords.length; i++)
/*  98 */       stopTable.add(ignoreCase ? stopWords[i].toLowerCase() : stopWords[i]); 
/*  99 */     return stopTable;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Token next() throws IOException {
/* 107 */     for (Token token = this.input.next(); token != null; token = this.input.next()) {
/*     */       
/* 109 */       String termText = this.ignoreCase ? token.termText.toLowerCase() : token.termText;
/* 110 */       if (!this.stopWords.contains(termText)) {
/* 111 */         return token;
/*     */       }
/*     */     } 
/* 114 */     return null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\StopFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Token,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import org.apache.lucene.index.Payload;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Token
/*     */   implements Cloneable
/*     */ {
/*     */   String termText;
/*     */   int startOffset;
/*     */   int endOffset;
/*  54 */   String type = ""word"";
/*     */   
/*     */   Payload payload;
/*     */   
/*  58 */   private int positionIncrement = 1;
/*     */ 
/*     */ 
/*     */   
/*     */   public Token(String text, int start, int end) {
/*  63 */     this.termText = text;
/*  64 */     this.startOffset = start;
/*  65 */     this.endOffset = end;
/*     */   }
/*     */ 
/*     */   
/*     */   public Token(String text, int start, int end, String typ) {
/*  70 */     this.termText = text;
/*  71 */     this.startOffset = start;
/*  72 */     this.endOffset = end;
/*  73 */     this.type = typ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setPositionIncrement(int positionIncrement) {
/* 102 */     if (positionIncrement < 0) {
/* 103 */       throw new IllegalArgumentException(""Increment must be zero or greater: "" + positionIncrement);
/*     */     }
/* 105 */     this.positionIncrement = positionIncrement;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 111 */   public int getPositionIncrement() { return this.positionIncrement; }
/*     */ 
/*     */ 
/*     */   
/* 115 */   public void setTermText(String text) { this.termText = text; }
/*     */ 
/*     */ 
/*     */   
/* 119 */   public final String termText() { return this.termText; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 127 */   public final int startOffset() { return this.startOffset; }
/*     */ 
/*     */ 
/*     */   
/* 131 */   public final int endOffset() { return this.endOffset; }
/*     */ 
/*     */   
/* 134 */   public final String type() { return this.type; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public void setPayload(Payload payload) { this.payload = payload; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 157 */   public Payload getPayload() { return this.payload; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 161 */     StringBuffer sb = new StringBuffer();
/* 162 */     sb.append(""("" + this.termText + "","" + this.startOffset + "","" + this.endOffset);
/* 163 */     if (!this.type.equals(""word""))
/* 164 */       sb.append("",type="" + this.type); 
/* 165 */     if (this.positionIncrement != 1)
/* 166 */       sb.append("",posIncr="" + this.positionIncrement); 
/* 167 */     sb.append("")"");
/* 168 */     return sb.toString();
/*     */   }
/*     */   
/*     */   public Object clone() {
/*     */     try {
/* 173 */       return super.clone();
/* 174 */     } catch (CloneNotSupportedException e) {
/* 175 */       throw new RuntimeException(e);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.TokenFilter,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TokenFilter
/*    */   extends TokenStream
/*    */ {
/*    */   protected TokenStream input;
/*    */   
/* 32 */   protected TokenFilter(TokenStream input) { this.input = input; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 37 */   public void close() throws IOException { this.input.close(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\TokenFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.Tokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Tokenizer
/*    */   extends TokenStream
/*    */ {
/*    */   protected Reader input;
/*    */   
/*    */   protected Tokenizer() {}
/*    */   
/* 37 */   protected Tokenizer(Reader input) { this.input = input; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 42 */   public void close() throws IOException { this.input.close(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\Tokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.TokenStream,"package org.apache.lucene.analysis;
import java.io.IOException;
public abstract class TokenStream {
  public abstract Token next() throws IOException;
  public void reset() throws IOException {}
  public void close() throws IOException {}
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\TokenStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WhitespaceAnalyzer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class WhitespaceAnalyzer
/*    */   extends Analyzer
/*    */ {
/* 26 */   public TokenStream tokenStream(String fieldName, Reader reader) { return new WhitespaceTokenizer(reader); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\WhitespaceAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WhitespaceTokenizer,"/*    */ package org.apache.lucene.analysis;
/*    */ 
/*    */ import java.io.Reader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class WhitespaceTokenizer
/*    */   extends CharTokenizer
/*    */ {
/* 28 */   public WhitespaceTokenizer(Reader in) { super(in); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 34 */   protected boolean isTokenChar(char c) { return !Character.isWhitespace(c); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\WhitespaceTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.WordlistLoader,"/*     */ package org.apache.lucene.analysis;
/*     */ 
/*     */ import java.io.BufferedReader;
/*     */ import java.io.File;
/*     */ import java.io.FileReader;
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class WordlistLoader
/*     */ {
/*     */   public static HashSet getWordSet(File wordfile) throws IOException {
/*  46 */     HashSet result = new HashSet();
/*  47 */     FileReader reader = null;
/*     */     try {
/*  49 */       reader = new FileReader(wordfile);
/*  50 */       result = getWordSet(reader);
/*     */     } finally {
/*     */       
/*  53 */       if (reader != null)
/*  54 */         reader.close(); 
/*     */     } 
/*  56 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static HashSet getWordSet(Reader reader) throws IOException {
/*  69 */     HashSet result = new HashSet();
/*  70 */     BufferedReader br = null;
/*     */     try {
/*  72 */       if (reader instanceof BufferedReader) {
/*  73 */         br = (BufferedReader)reader;
/*     */       } else {
/*  75 */         br = new BufferedReader(reader);
/*     */       } 
/*  77 */       String word = null;
/*  78 */       while ((word = br.readLine()) != null) {
/*  79 */         result.add(word.trim());
/*     */       }
/*     */     } finally {
/*     */       
/*  83 */       if (br != null)
/*  84 */         br.close(); 
/*     */     } 
/*  86 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static HashMap getStemDict(File wordstemfile) throws IOException {
/*  98 */     if (wordstemfile == null)
/*  99 */       throw new NullPointerException(""wordstemfile may not be null""); 
/* 100 */     HashMap result = new HashMap();
/* 101 */     BufferedReader br = null;
/* 102 */     FileReader fr = null;
/*     */     try {
/* 104 */       fr = new FileReader(wordstemfile);
/* 105 */       br = new BufferedReader(fr);
/*     */       String line;
/* 107 */       while ((line = br.readLine()) != null) {
/* 108 */         String[] wordstem = line.split(""\t"", 2);
/* 109 */         result.put(wordstem[0], wordstem[1]);
/*     */       } 
/*     */     } finally {
/* 112 */       if (fr != null)
/* 113 */         fr.close(); 
/* 114 */       if (br != null)
/* 115 */         br.close(); 
/*     */     } 
/* 117 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\WordlistLoader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.CharStream,"package org.apache.lucene.analysis.standard;
import java.io.IOException;
public interface CharStream {
  char readChar() throws IOException;
  int getColumn();
  int getLine();
  int getEndColumn();
  int getEndLine();
  int getBeginColumn();
  int getBeginLine();
  void backup(int paramInt);
  char BeginToken() throws IOException;
  String GetImage();
  char[] GetSuffix(int paramInt);
  void Done();
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\CharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.FastCharStream,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FastCharStream
/*     */   implements CharStream
/*     */ {
/*  28 */   char[] buffer = null;
/*     */   
/*  30 */   int bufferLength = 0;
/*  31 */   int bufferPosition = 0;
/*     */   
/*  33 */   int tokenStart = 0;
/*  34 */   int bufferStart = 0;
/*     */ 
/*     */   
/*     */   Reader input;
/*     */ 
/*     */   
/*  40 */   public FastCharStream(Reader r) { this.input = r; }
/*     */ 
/*     */   
/*     */   public final char readChar() throws IOException {
/*  44 */     if (this.bufferPosition >= this.bufferLength)
/*  45 */       refill(); 
/*  46 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */   
/*     */   private final void refill() throws IOException {
/*  50 */     int newPosition = this.bufferLength - this.tokenStart;
/*     */     
/*  52 */     if (this.tokenStart == 0) {
/*  53 */       if (this.buffer == null) {
/*  54 */         this.buffer = new char[2048];
/*  55 */       } else if (this.bufferLength == this.buffer.length) {
/*  56 */         char[] newBuffer = new char[this.buffer.length * 2];
/*  57 */         System.arraycopy(this.buffer, 0, newBuffer, 0, this.bufferLength);
/*  58 */         this.buffer = newBuffer;
/*     */       } 
/*     */     } else {
/*  61 */       System.arraycopy(this.buffer, this.tokenStart, this.buffer, 0, newPosition);
/*     */     } 
/*     */     
/*  64 */     this.bufferLength = newPosition;
/*  65 */     this.bufferPosition = newPosition;
/*  66 */     this.bufferStart += this.tokenStart;
/*  67 */     this.tokenStart = 0;
/*     */     
/*  69 */     int charsRead = this.input.read(this.buffer, newPosition, this.buffer.length - newPosition);
/*     */     
/*  71 */     if (charsRead == -1) {
/*  72 */       throw new IOException(""read past eof"");
/*     */     }
/*  74 */     this.bufferLength += charsRead;
/*     */   }
/*     */   
/*     */   public final char BeginToken() throws IOException {
/*  78 */     this.tokenStart = this.bufferPosition;
/*  79 */     return readChar();
/*     */   }
/*     */ 
/*     */   
/*  83 */   public final void backup(int amount) { this.bufferPosition -= amount; }
/*     */ 
/*     */ 
/*     */   
/*  87 */   public final String GetImage() { return new String(this.buffer, this.tokenStart, this.bufferPosition - this.tokenStart); }
/*     */ 
/*     */   
/*     */   public final char[] GetSuffix(int len) {
/*  91 */     char[] value = new char[len];
/*  92 */     System.arraycopy(this.buffer, this.bufferPosition - len, value, 0, len);
/*  93 */     return value;
/*     */   }
/*     */   
/*     */   public final void Done() {
/*     */     try {
/*  98 */       this.input.close();
/*  99 */     } catch (IOException e) {
/* 100 */       System.err.println(""Caught: "" + e + ""; ignoring."");
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 105 */   public final int getColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 108 */   public final int getLine() { return 1; }
/*     */ 
/*     */   
/* 111 */   public final int getEndColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 114 */   public final int getEndLine() { return 1; }
/*     */ 
/*     */   
/* 117 */   public final int getBeginColumn() { return this.bufferStart + this.tokenStart; }
/*     */ 
/*     */   
/* 120 */   public final int getBeginLine() { return 1; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\FastCharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.ParseException,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParseException
/*     */   extends IOException
/*     */ {
/*     */   protected boolean specialConstructor;
/*     */   public Token currentToken;
/*     */   public int[][] expectedTokenSequences;
/*     */   public String[] tokenImage;
/*     */   protected String eol;
/*     */   
/*     */   public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
/*  35 */     super("""");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 142 */     this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = true; this.currentToken = currentTokenVal; this.expectedTokenSequences = expectedTokenSequencesVal; this.tokenImage = tokenImageVal; } public ParseException() { this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = false; } public ParseException(String message) { super(message); this.eol = System.getProperty(""line.separator"", ""\n"");
/*     */     this.specialConstructor = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected String add_escapes(String str) {
/* 150 */     StringBuffer retval = new StringBuffer();
/*     */     
/* 152 */     for (int i = 0; i < str.length(); i++) {
/* 153 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/* 158 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/* 161 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/* 164 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/* 167 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/* 170 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/* 173 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/* 176 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/* 179 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/* 182 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/* 183 */             String s = ""0000"" + Integer.toString(ch, 16);
/* 184 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/* 186 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/* 191 */     return retval.toString();
/*     */   }
/*     */   
/*     */   public String getMessage() {
/*     */     if (!this.specialConstructor)
/*     */       return super.getMessage(); 
/*     */     String expected = """";
/*     */     int maxSize = 0;
/*     */     for (int i = 0; i < this.expectedTokenSequences.length; i++) {
/*     */       if (maxSize < (this.expectedTokenSequences[i]).length)
/*     */         maxSize = (this.expectedTokenSequences[i]).length; 
/*     */       for (int j = 0; j < (this.expectedTokenSequences[i]).length; j++)
/*     */         expected = expected + this.tokenImage[this.expectedTokenSequences[i][j]] + "" ""; 
/*     */       if (this.expectedTokenSequences[i][(this.expectedTokenSequences[i]).length - 1] != 0)
/*     */         expected = expected + ""...""; 
/*     */       expected = expected + this.eol + ""    "";
/*     */     } 
/*     */     String retval = ""Encountered \"""";
/*     */     Token tok = this.currentToken.next;
/*     */     for (int i = 0; i < maxSize; i++) {
/*     */       if (i != 0)
/*     */         retval = retval + "" ""; 
/*     */       if (tok.kind == 0) {
/*     */         retval = retval + this.tokenImage[0];
/*     */         break;
/*     */       } 
/*     */       retval = retval + add_escapes(tok.image);
/*     */       tok = tok.next;
/*     */     } 
/*     */     retval = retval + ""\"" at line "" + this.currentToken.next.beginLine + "", column "" + this.currentToken.next.beginColumn + ""."" + this.eol;
/*     */     if (this.expectedTokenSequences.length == 1) {
/*     */       retval = retval + ""Was expecting:"" + this.eol + ""    "";
/*     */     } else {
/*     */       retval = retval + ""Was expecting one of:"" + this.eol + ""    "";
/*     */     } 
/*     */     retval = retval + expected;
/*     */     return retval;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\ParseException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardAnalyzer,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.IOException;
/*    */ import java.io.Reader;
/*    */ import java.util.Set;
/*    */ import org.apache.lucene.analysis.Analyzer;
/*    */ import org.apache.lucene.analysis.LowerCaseFilter;
/*    */ import org.apache.lucene.analysis.StopAnalyzer;
/*    */ import org.apache.lucene.analysis.StopFilter;
/*    */ import org.apache.lucene.analysis.TokenStream;
/*    */ import org.apache.lucene.analysis.WordlistLoader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StandardAnalyzer
/*    */   extends Analyzer
/*    */ {
/*    */   private Set stopSet;
/* 38 */   public static final String[] STOP_WORDS = StopAnalyzer.ENGLISH_STOP_WORDS;
/*    */ 
/*    */ 
/*    */   
/* 42 */   public StandardAnalyzer() { this(STOP_WORDS); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 47 */   public StandardAnalyzer(Set stopWords) { this.stopSet = stopWords; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 52 */   public StandardAnalyzer(String[] stopWords) { this.stopSet = StopFilter.makeStopSet(stopWords); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public StandardAnalyzer(File stopwords) throws IOException { this.stopSet = WordlistLoader.getWordSet(stopwords); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 66 */   public StandardAnalyzer(Reader stopwords) throws IOException { this.stopSet = WordlistLoader.getWordSet(stopwords); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public TokenStream tokenStream(String fieldName, Reader reader) {
/* 72 */     StandardTokenizer standardTokenizer = new StandardTokenizer(reader);
/* 73 */     StandardFilter standardFilter = new StandardFilter((TokenStream)standardTokenizer);
/* 74 */     LowerCaseFilter lowerCaseFilter = new LowerCaseFilter((TokenStream)standardFilter);
/* 75 */     return (TokenStream)new StopFilter((TokenStream)lowerCaseFilter, this.stopSet);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\StandardAnalyzer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardFilter,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.analysis.Token;
/*    */ import org.apache.lucene.analysis.TokenFilter;
/*    */ import org.apache.lucene.analysis.TokenStream;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class StandardFilter
/*    */   extends TokenFilter
/*    */   implements StandardTokenizerConstants
/*    */ {
/* 30 */   public StandardFilter(TokenStream in) { super(in); }
/*    */ 
/*    */   
/* 33 */   private static final String APOSTROPHE_TYPE = tokenImage[2];
/* 34 */   private static final String ACRONYM_TYPE = tokenImage[3];
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public final Token next() throws IOException {
/* 41 */     Token t = this.input.next();
/*    */     
/* 43 */     if (t == null) {
/* 44 */       return null;
/*    */     }
/* 46 */     String text = t.termText();
/* 47 */     String type = t.type();
/*    */     
/* 49 */     if (type == APOSTROPHE_TYPE && (text.endsWith(""'s"") || text.endsWith(""'S"")))
/*    */     {
/* 51 */       return new Token(text.substring(0, text.length() - 2), t.startOffset(), t.endOffset(), type);
/*    */     }
/*    */ 
/*    */     
/* 55 */     if (type == ACRONYM_TYPE) {
/* 56 */       StringBuffer trimmed = new StringBuffer();
/* 57 */       for (int i = 0; i < text.length(); i++) {
/* 58 */         char c = text.charAt(i);
/* 59 */         if (c != '.')
/* 60 */           trimmed.append(c); 
/*    */       } 
/* 62 */       return new Token(trimmed.toString(), t.startOffset(), t.endOffset(), type);
/*    */     } 
/*    */ 
/*    */     
/* 66 */     return t;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\StandardFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizer,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.Tokenizer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class StandardTokenizer
/*     */   extends Tokenizer
/*     */   implements StandardTokenizerConstants
/*     */ {
/*     */   public StandardTokenizerTokenManager token_source;
/*     */   public Token token;
/*     */   public Token jj_nt;
/*     */   private int jj_ntk;
/*     */   private int jj_gen;
/*     */   
/*     */   public StandardTokenizer(Reader reader) {
/*  26 */     this(new FastCharStream(reader));
/*  27 */     this.input = reader;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Token next() throws ParseException, IOException {
/*  35 */     Token token = null;
/*  36 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*     */       case 1:
/*  38 */         token = jj_consume_token(1);
/*     */         break;
/*     */       case 2:
/*  41 */         token = jj_consume_token(2);
/*     */         break;
/*     */       case 3:
/*  44 */         token = jj_consume_token(3);
/*     */         break;
/*     */       case 4:
/*  47 */         token = jj_consume_token(4);
/*     */         break;
/*     */       case 5:
/*  50 */         token = jj_consume_token(5);
/*     */         break;
/*     */       case 6:
/*  53 */         token = jj_consume_token(6);
/*     */         break;
/*     */       case 7:
/*  56 */         token = jj_consume_token(7);
/*     */         break;
/*     */       case 12:
/*  59 */         token = jj_consume_token(12);
/*     */         break;
/*     */       case 0:
/*  62 */         token = jj_consume_token(0);
/*     */         break;
/*     */       default:
/*  65 */         this.jj_la1[0] = this.jj_gen;
/*  66 */         jj_consume_token(-1);
/*  67 */         throw new ParseException();
/*     */     } 
/*  69 */     if (token.kind == 0) {
/*  70 */       return null;
/*     */     }
/*  72 */     return new Token(token.image, token.beginColumn, token.endColumn, tokenImage[token.kind]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   private final int[] jj_la1 = new int[1]; private static int[] jj_la1_0; private Vector jj_expentries; private int[] jj_expentry; private int jj_kind;
/*     */   
/*     */   static  {
/*  87 */     jj_la1_0();
/*     */   }
/*     */   
/*  90 */   private static void jj_la1_0() { jj_la1_0 = new int[] { 4351 }; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void ReInit(CharStream stream) {
/* 102 */     this.token_source.ReInit(stream);
/* 103 */     this.token = new Token();
/* 104 */     this.jj_ntk = -1;
/* 105 */     this.jj_gen = 0;
/* 106 */     for (int i = 0; i < 1; ) { this.jj_la1[i] = -1; i++; }
/*     */   
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void ReInit(StandardTokenizerTokenManager tm) {
/* 118 */     this.token_source = tm;
/* 119 */     this.token = new Token();
/* 120 */     this.jj_ntk = -1;
/* 121 */     this.jj_gen = 0;
/* 122 */     for (int i = 0; i < 1; ) { this.jj_la1[i] = -1; i++; }
/*     */   
/*     */   }
/*     */   private final Token jj_consume_token(int kind) throws ParseException {
/*     */     Token oldToken;
/* 127 */     if ((oldToken = this.token).next != null) { this.token = this.token.next; }
/* 128 */     else { this.token = this.token.next = this.token_source.getNextToken(); }
/* 129 */      this.jj_ntk = -1;
/* 130 */     if (this.token.kind == kind) {
/* 131 */       this.jj_gen++;
/* 132 */       return this.token;
/*     */     } 
/* 134 */     this.token = oldToken;
/* 135 */     this.jj_kind = kind;
/* 136 */     throw generateParseException();
/*     */   }
/*     */   
/*     */   public final Token getNextToken() {
/* 140 */     if (this.token.next != null) { this.token = this.token.next; }
/* 141 */     else { this.token = this.token.next = this.token_source.getNextToken(); }
/* 142 */      this.jj_ntk = -1;
/* 143 */     this.jj_gen++;
/* 144 */     return this.token;
/*     */   }
/*     */   
/*     */   public final Token getToken(int index) {
/* 148 */     Token t = this.token;
/* 149 */     for (int i = 0; i < index; i++) {
/* 150 */       if (t.next != null) { t = t.next; }
/* 151 */       else { t = t.next = this.token_source.getNextToken(); }
/*     */     
/* 153 */     }  return t;
/*     */   }
/*     */   
/*     */   private final int jj_ntk() {
/* 157 */     if ((this.jj_nt = this.token.next) == null) {
/* 158 */       return this.jj_ntk = (this.token.next = this.token_source.getNextToken()).kind;
/*     */     }
/* 160 */     return this.jj_ntk = this.jj_nt.kind;
/*     */   }
/*     */   
/* 163 */   public StandardTokenizer(CharStream stream) { this.jj_expentries = new Vector();
/*     */     
/* 165 */     this.jj_kind = -1; this.token_source = new StandardTokenizerTokenManager(stream); this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 1; ) { this.jj_la1[i] = -1; i++; }  } public StandardTokenizer(StandardTokenizerTokenManager tm) { this.jj_expentries = new Vector(); this.jj_kind = -1; this.token_source = tm; this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 1; ) {
/*     */       this.jj_la1[i] = -1;
/*     */       i++;
/* 168 */     }  } public ParseException generateParseException() { this.jj_expentries.removeAllElements();
/* 169 */     boolean[] la1tokens = new boolean[16];
/* 170 */     for (int i = 0; i < 16; i++) {
/* 171 */       la1tokens[i] = false;
/*     */     }
/* 173 */     if (this.jj_kind >= 0) {
/* 174 */       la1tokens[this.jj_kind] = true;
/* 175 */       this.jj_kind = -1;
/*     */     } 
/* 177 */     for (int i = 0; i < 1; i++) {
/* 178 */       if (this.jj_la1[i] == this.jj_gen) {
/* 179 */         for (int j = 0; j < 32; j++) {
/* 180 */           if ((jj_la1_0[i] & 1 << j) != 0) {
/* 181 */             la1tokens[j] = true;
/*     */           }
/*     */         } 
/*     */       }
/*     */     } 
/* 186 */     for (int i = 0; i < 16; i++) {
/* 187 */       if (la1tokens[i]) {
/* 188 */         this.jj_expentry = new int[1];
/* 189 */         this.jj_expentry[0] = i;
/* 190 */         this.jj_expentries.addElement(this.jj_expentry);
/*     */       } 
/*     */     } 
/* 193 */     int[][] exptokseq = new int[this.jj_expentries.size()][];
/* 194 */     for (int i = 0; i < this.jj_expentries.size(); i++) {
/* 195 */       exptokseq[i] = this.jj_expentries.elementAt(i);
/*     */     }
/* 197 */     return new ParseException(this.token, exptokseq, tokenImage); }
/*     */ 
/*     */   
/*     */   public final void enable_tracing() {}
/*     */   
/*     */   public final void disable_tracing() {}
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizerConstants,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface StandardTokenizerConstants
/*    */ {
/*    */   public static final int EOF = 0;
/*    */   public static final int ALPHANUM = 1;
/*    */   public static final int APOSTROPHE = 2;
/*    */   public static final int ACRONYM = 3;
/*    */   public static final int COMPANY = 4;
/*    */   public static final int EMAIL = 5;
/*    */   public static final int HOST = 6;
/*    */   public static final int NUM = 7;
/*    */   public static final int P = 8;
/*    */   public static final int HAS_DIGIT = 9;
/*    */   public static final int ALPHA = 10;
/*    */   public static final int LETTER = 11;
/*    */   public static final int CJ = 12;
/*    */   public static final int KOREAN = 13;
/*    */   public static final int DIGIT = 14;
/*    */   public static final int NOISE = 15;
/*    */   public static final int DEFAULT = 0;
/* 25 */   public static final String[] tokenImage = new String[] { ""<EOF>"", ""<ALPHANUM>"", ""<APOSTROPHE>"", ""<ACRONYM>"", ""<COMPANY>"", ""<EMAIL>"", ""<HOST>"", ""<NUM>"", ""<P>"", ""<HAS_DIGIT>"", ""<ALPHA>"", ""<LETTER>"", ""<CJ>"", ""<KOREAN>"", ""<DIGIT>"", ""<NOISE>"" };
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizerConstants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.StandardTokenizerTokenManager,"/*      */ package org.apache.lucene.analysis.standard;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ 
/*      */ public class StandardTokenizerTokenManager implements StandardTokenizerConstants {
/*    7 */   public PrintStream debugStream = System.out;
/*    8 */   public void setDebugStream(PrintStream ds) { this.debugStream = ds; }
/*      */ 
/*      */   
/*   11 */   private final int jjMoveStringLiteralDfa0_0() { return jjMoveNfa_0(0, 0); }
/*      */ 
/*      */   
/*      */   private final void jjCheckNAdd(int state) {
/*   15 */     if (this.jjrounds[state] != this.jjround) {
/*      */       
/*   17 */       this.jjstateSet[this.jjnewStateCnt++] = state;
/*   18 */       this.jjrounds[state] = this.jjround;
/*      */     } 
/*      */   }
/*      */   
/*      */   private final void jjAddStates(int start, int end) {
/*      */     do {
/*   24 */       this.jjstateSet[this.jjnewStateCnt++] = jjnextStates[start];
/*   25 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddTwoStates(int state1, int state2) {
/*   29 */     jjCheckNAdd(state1);
/*   30 */     jjCheckNAdd(state2);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start, int end) {
/*      */     do {
/*   35 */       jjCheckNAdd(jjnextStates[start]);
/*   36 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start) {
/*   40 */     jjCheckNAdd(jjnextStates[start]);
/*   41 */     jjCheckNAdd(jjnextStates[start + 1]);
/*      */   }
/*   43 */   static final long[] jjbitVec0 = new long[] { -4503599627370496L, -8193L, 4294967295L, 432345564227567616L };
/*      */ 
/*      */   
/*   46 */   static final long[] jjbitVec2 = new long[] { 0L, -1L, -1L, -1L };
/*      */ 
/*      */   
/*   49 */   static final long[] jjbitVec3 = new long[] { -1L, -1L, 65535L, -281474976710656L };
/*      */ 
/*      */   
/*   52 */   static final long[] jjbitVec4 = new long[] { -1L, -1L, 0L, 0L };
/*      */ 
/*      */   
/*   55 */   static final long[] jjbitVec5 = new long[] { -1L, -1L, -1L, 0L };
/*      */ 
/*      */   
/*   58 */   static final long[] jjbitVec6 = new long[] { 0L, -137438953472L, 4294967295L, 0L };
/*      */ 
/*      */   
/*   61 */   static final long[] jjbitVec7 = new long[] { 131072L, 0L, -17592186044416L, 8388607L };
/*      */ 
/*      */   
/*   64 */   static final long[] jjbitVec8 = new long[] { -1L, -1L, 281474976710655L, 0L };
/*      */ 
/*      */   
/*   67 */   static final long[] jjbitVec9 = new long[] { 4294967294L, 0L, 0L, 0L };
/*      */ 
/*      */   
/*   70 */   static final long[] jjbitVec10 = new long[] { 0L, 0L, 0L, -36028797027352577L };
/*      */ 
/*      */   
/*   73 */   static final long[] jjbitVec11 = new long[] { 0L, 0L, -4294967296L, 536870911L };
/*      */ 
/*      */   
/*   76 */   static final long[] jjbitVec12 = new long[] { 5632L, 0L, 0L, 0L };
/*      */ 
/*      */   
/*   79 */   static final long[] jjbitVec13 = new long[] { 0L, 281200098803712L, 0L, 281200098803712L };
/*      */ 
/*      */   
/*   82 */   static final long[] jjbitVec14 = new long[] { 0L, 4393751543808L, 0L, 287948901175001088L };
/*      */ 
/*      */   
/*   85 */   static final long[] jjbitVec15 = new long[] { 0L, 281200098803712L, 0L, 280925220896768L };
/*      */ 
/*      */   
/*   88 */   static final long[] jjbitVec16 = new long[] { 0L, 281200098803712L, 0L, 0L };
/*      */ 
/*      */   
/*   91 */   static final long[] jjbitVec17 = new long[] { 0L, 67043328L, 0L, 67043328L };
/*      */ 
/*      */   
/*   94 */   static final long[] jjbitVec18 = new long[] { 0L, 1023L, 0L, 0L };
/*      */ 
/*      */   
/*   97 */   static final long[] jjbitVec19 = new long[] { 4294967294L, 0L, -17592186044416L, 8388607L };
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_0(int startState, int curPos) {
/*  103 */     int startsAt = 0;
/*  104 */     this.jjnewStateCnt = 75;
/*  105 */     int i = 1;
/*  106 */     this.jjstateSet[0] = startState;
/*  107 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  110 */       if (++this.jjround == Integer.MAX_VALUE)
/*  111 */         ReInitRounds(); 
/*  112 */       if (this.curChar < '@') {
/*      */         
/*  114 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  117 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  120 */               if ((0x3FF000000000000L & l) != 0L) {
/*      */                 
/*  122 */                 if (kind > 1)
/*  123 */                   kind = 1; 
/*  124 */                 jjCheckNAddStates(0, 11);
/*      */               } 
/*  126 */               if ((0x3FF000000000000L & l) != 0L)
/*  127 */                 jjCheckNAddStates(12, 17); 
/*  128 */               if ((0x3FF000000000000L & l) != 0L)
/*  129 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 2:
/*  132 */               if ((0x3FF000000000000L & l) != 0L)
/*  133 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 3:
/*  136 */               if ((0x3FF000000000000L & l) != 0L)
/*  137 */                 jjCheckNAddTwoStates(3, 4); 
/*      */               break;
/*      */             case 4:
/*      */             case 5:
/*  141 */               if ((0x3FF000000000000L & l) != 0L)
/*  142 */                 jjCheckNAddTwoStates(5, 6); 
/*      */               break;
/*      */             case 6:
/*  145 */               if ((0xF00000000000L & l) != 0L)
/*  146 */                 jjCheckNAdd(7); 
/*      */               break;
/*      */             case 7:
/*  149 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  151 */               if (kind > 7)
/*  152 */                 kind = 7; 
/*  153 */               jjCheckNAdd(7);
/*      */               break;
/*      */             case 8:
/*  156 */               if ((0x3FF000000000000L & l) != 0L)
/*  157 */                 jjCheckNAddTwoStates(8, 9); 
/*      */               break;
/*      */             case 9:
/*      */             case 10:
/*  161 */               if ((0x3FF000000000000L & l) != 0L)
/*  162 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 11:
/*  165 */               if ((0xF00000000000L & l) != 0L)
/*  166 */                 jjCheckNAdd(12); 
/*      */               break;
/*      */             case 12:
/*  169 */               if ((0x3FF000000000000L & l) != 0L)
/*  170 */                 jjCheckNAddTwoStates(12, 13); 
/*      */               break;
/*      */             case 13:
/*  173 */               if ((0xF00000000000L & l) != 0L)
/*  174 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 14:
/*  177 */               if ((0x3FF000000000000L & l) != 0L)
/*  178 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 15:
/*      */             case 16:
/*  182 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  184 */               if (kind > 7)
/*  185 */                 kind = 7; 
/*  186 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 17:
/*  189 */               if ((0x3FF000000000000L & l) != 0L)
/*  190 */                 jjCheckNAddTwoStates(17, 18); 
/*      */               break;
/*      */             case 18:
/*      */             case 19:
/*  194 */               if ((0x3FF000000000000L & l) != 0L)
/*  195 */                 jjCheckNAddTwoStates(19, 20); 
/*      */               break;
/*      */             case 20:
/*  198 */               if ((0xF00000000000L & l) != 0L)
/*  199 */                 jjCheckNAdd(21); 
/*      */               break;
/*      */             case 21:
/*  202 */               if ((0x3FF000000000000L & l) != 0L)
/*  203 */                 jjCheckNAddTwoStates(21, 22); 
/*      */               break;
/*      */             case 22:
/*  206 */               if ((0xF00000000000L & l) != 0L)
/*  207 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 23:
/*  210 */               if ((0x3FF000000000000L & l) != 0L)
/*  211 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 24:
/*      */             case 25:
/*  215 */               if ((0x3FF000000000000L & l) != 0L)
/*  216 */                 jjCheckNAddTwoStates(25, 26); 
/*      */               break;
/*      */             case 26:
/*  219 */               if ((0xF00000000000L & l) != 0L)
/*  220 */                 jjCheckNAdd(27); 
/*      */               break;
/*      */             case 27:
/*  223 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  225 */               if (kind > 7)
/*  226 */                 kind = 7; 
/*  227 */               jjCheckNAddTwoStates(22, 27);
/*      */               break;
/*      */             case 28:
/*  230 */               if ((0x3FF000000000000L & l) != 0L)
/*  231 */                 jjCheckNAddStates(12, 17); 
/*      */               break;
/*      */             case 29:
/*  234 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  236 */               if (kind > 1)
/*  237 */                 kind = 1; 
/*  238 */               jjCheckNAddStates(0, 11);
/*      */               break;
/*      */             case 30:
/*  241 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  243 */               if (kind > 1)
/*  244 */                 kind = 1; 
/*  245 */               jjCheckNAdd(30);
/*      */               break;
/*      */             case 31:
/*  248 */               if ((0x3FF000000000000L & l) != 0L)
/*  249 */                 jjCheckNAddStates(24, 26); 
/*      */               break;
/*      */             case 32:
/*  252 */               if ((0x600000000000L & l) != 0L)
/*  253 */                 jjCheckNAdd(33); 
/*      */               break;
/*      */             case 33:
/*  256 */               if ((0x3FF000000000000L & l) != 0L)
/*  257 */                 jjCheckNAddStates(27, 29); 
/*      */               break;
/*      */             case 35:
/*  260 */               if ((0x3FF000000000000L & l) != 0L)
/*  261 */                 jjCheckNAddTwoStates(35, 36); 
/*      */               break;
/*      */             case 36:
/*  264 */               if ((0x600000000000L & l) != 0L)
/*  265 */                 jjCheckNAdd(37); 
/*      */               break;
/*      */             case 37:
/*  268 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  270 */               if (kind > 5)
/*  271 */                 kind = 5; 
/*  272 */               jjCheckNAddTwoStates(36, 37);
/*      */               break;
/*      */             case 38:
/*  275 */               if ((0x3FF000000000000L & l) != 0L)
/*  276 */                 jjCheckNAddTwoStates(38, 39); 
/*      */               break;
/*      */             case 39:
/*  279 */               if (this.curChar == '.')
/*  280 */                 jjCheckNAdd(40); 
/*      */               break;
/*      */             case 40:
/*  283 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  285 */               if (kind > 6)
/*  286 */                 kind = 6; 
/*  287 */               jjCheckNAddTwoStates(39, 40);
/*      */               break;
/*      */             case 41:
/*  290 */               if ((0x3FF000000000000L & l) != 0L)
/*  291 */                 jjCheckNAddTwoStates(41, 42); 
/*      */               break;
/*      */             case 42:
/*  294 */               if ((0xF00000000000L & l) != 0L)
/*  295 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 43:
/*  298 */               if ((0x3FF000000000000L & l) != 0L)
/*  299 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 44:
/*      */             case 45:
/*  303 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  305 */               if (kind > 7)
/*  306 */                 kind = 7; 
/*  307 */               jjCheckNAdd(45);
/*      */               break;
/*      */             case 46:
/*  310 */               if ((0x3FF000000000000L & l) != 0L)
/*  311 */                 jjCheckNAddTwoStates(46, 47); 
/*      */               break;
/*      */             case 47:
/*  314 */               if ((0xF00000000000L & l) != 0L)
/*  315 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 48:
/*  318 */               if ((0x3FF000000000000L & l) != 0L)
/*  319 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 49:
/*      */             case 50:
/*  323 */               if ((0x3FF000000000000L & l) != 0L)
/*  324 */                 jjCheckNAddTwoStates(50, 51); 
/*      */               break;
/*      */             case 51:
/*  327 */               if ((0xF00000000000L & l) != 0L)
/*  328 */                 jjCheckNAdd(52); 
/*      */               break;
/*      */             case 52:
/*  331 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  333 */               if (kind > 7)
/*  334 */                 kind = 7; 
/*  335 */               jjCheckNAddTwoStates(47, 52);
/*      */               break;
/*      */             case 53:
/*  338 */               if ((0x3FF000000000000L & l) != 0L)
/*  339 */                 jjCheckNAddTwoStates(53, 54); 
/*      */               break;
/*      */             case 54:
/*  342 */               if ((0xF00000000000L & l) != 0L)
/*  343 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 55:
/*  346 */               if ((0x3FF000000000000L & l) != 0L)
/*  347 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 56:
/*      */             case 57:
/*  351 */               if ((0x3FF000000000000L & l) != 0L)
/*  352 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 58:
/*  355 */               if ((0xF00000000000L & l) != 0L)
/*  356 */                 jjCheckNAdd(59); 
/*      */               break;
/*      */             case 59:
/*  359 */               if ((0x3FF000000000000L & l) != 0L)
/*  360 */                 jjCheckNAddTwoStates(59, 60); 
/*      */               break;
/*      */             case 60:
/*  363 */               if ((0xF00000000000L & l) != 0L)
/*  364 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 61:
/*  367 */               if ((0x3FF000000000000L & l) != 0L)
/*  368 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 62:
/*      */             case 63:
/*  372 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  374 */               if (kind > 7)
/*  375 */                 kind = 7; 
/*  376 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 66:
/*  379 */               if (this.curChar == '\'')
/*  380 */                 this.jjstateSet[this.jjnewStateCnt++] = 67; 
/*      */               break;
/*      */             case 69:
/*  383 */               if (this.curChar == '.')
/*  384 */                 jjCheckNAdd(70); 
/*      */               break;
/*      */             case 71:
/*  387 */               if (this.curChar != '.')
/*      */                 break; 
/*  389 */               if (kind > 3)
/*  390 */                 kind = 3; 
/*  391 */               jjCheckNAdd(70);
/*      */               break;
/*      */             case 73:
/*  394 */               if (this.curChar == '&') {
/*  395 */                 this.jjstateSet[this.jjnewStateCnt++] = 74;
/*      */               }
/*      */               break;
/*      */           } 
/*  399 */         } while (i != startsAt);
/*      */       }
/*  401 */       else if (this.curChar < '') {
/*      */         
/*  403 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  406 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  409 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  410 */                 jjCheckNAddStates(30, 35); 
/*  411 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L) {
/*      */                 
/*  413 */                 if (kind > 1)
/*  414 */                   kind = 1; 
/*  415 */                 jjCheckNAddStates(0, 11);
/*      */               } 
/*  417 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  418 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 2:
/*  421 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  422 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 3:
/*  425 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  426 */                 jjCheckNAddTwoStates(3, 4); 
/*      */               break;
/*      */             case 5:
/*  429 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  430 */                 jjAddStates(36, 37); 
/*      */               break;
/*      */             case 6:
/*  433 */               if (this.curChar == '_')
/*  434 */                 jjCheckNAdd(7); 
/*      */               break;
/*      */             case 7:
/*  437 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  439 */               if (kind > 7)
/*  440 */                 kind = 7; 
/*  441 */               jjCheckNAdd(7);
/*      */               break;
/*      */             case 8:
/*  444 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  445 */                 jjCheckNAddTwoStates(8, 9); 
/*      */               break;
/*      */             case 10:
/*  448 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  449 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 11:
/*  452 */               if (this.curChar == '_')
/*  453 */                 jjCheckNAdd(12); 
/*      */               break;
/*      */             case 12:
/*  456 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  457 */                 jjCheckNAddTwoStates(12, 13); 
/*      */               break;
/*      */             case 13:
/*  460 */               if (this.curChar == '_')
/*  461 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 14:
/*  464 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  465 */                 jjCheckNAddTwoStates(14, 15); 
/*      */               break;
/*      */             case 16:
/*  468 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  470 */               if (kind > 7)
/*  471 */                 kind = 7; 
/*  472 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 17:
/*  475 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  476 */                 jjCheckNAddTwoStates(17, 18); 
/*      */               break;
/*      */             case 19:
/*  479 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  480 */                 jjAddStates(38, 39); 
/*      */               break;
/*      */             case 20:
/*  483 */               if (this.curChar == '_')
/*  484 */                 jjCheckNAdd(21); 
/*      */               break;
/*      */             case 21:
/*  487 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  488 */                 jjCheckNAddTwoStates(21, 22); 
/*      */               break;
/*      */             case 22:
/*  491 */               if (this.curChar == '_')
/*  492 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 23:
/*  495 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  496 */                 jjCheckNAddTwoStates(23, 24); 
/*      */               break;
/*      */             case 25:
/*  499 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  500 */                 jjAddStates(40, 41); 
/*      */               break;
/*      */             case 26:
/*  503 */               if (this.curChar == '_')
/*  504 */                 jjCheckNAdd(27); 
/*      */               break;
/*      */             case 27:
/*  507 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  509 */               if (kind > 7)
/*  510 */                 kind = 7; 
/*  511 */               jjCheckNAddTwoStates(22, 27);
/*      */               break;
/*      */             case 29:
/*  514 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  516 */               if (kind > 1)
/*  517 */                 kind = 1; 
/*  518 */               jjCheckNAddStates(0, 11);
/*      */               break;
/*      */             case 30:
/*  521 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  523 */               if (kind > 1)
/*  524 */                 kind = 1; 
/*  525 */               jjCheckNAdd(30);
/*      */               break;
/*      */             case 31:
/*  528 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  529 */                 jjCheckNAddStates(24, 26); 
/*      */               break;
/*      */             case 32:
/*  532 */               if (this.curChar == '_')
/*  533 */                 jjCheckNAdd(33); 
/*      */               break;
/*      */             case 33:
/*  536 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  537 */                 jjCheckNAddStates(27, 29); 
/*      */               break;
/*      */             case 34:
/*  540 */               if (this.curChar == '@')
/*  541 */                 jjCheckNAdd(35); 
/*      */               break;
/*      */             case 35:
/*  544 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  545 */                 jjCheckNAddTwoStates(35, 36); 
/*      */               break;
/*      */             case 37:
/*  548 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  550 */               if (kind > 5)
/*  551 */                 kind = 5; 
/*  552 */               jjCheckNAddTwoStates(36, 37);
/*      */               break;
/*      */             case 38:
/*  555 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  556 */                 jjCheckNAddTwoStates(38, 39); 
/*      */               break;
/*      */             case 40:
/*  559 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  561 */               if (kind > 6)
/*  562 */                 kind = 6; 
/*  563 */               jjCheckNAddTwoStates(39, 40);
/*      */               break;
/*      */             case 41:
/*  566 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  567 */                 jjCheckNAddTwoStates(41, 42); 
/*      */               break;
/*      */             case 42:
/*  570 */               if (this.curChar == '_')
/*  571 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 43:
/*  574 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  575 */                 jjCheckNAddTwoStates(43, 44); 
/*      */               break;
/*      */             case 45:
/*  578 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  580 */               if (kind > 7)
/*  581 */                 kind = 7; 
/*  582 */               this.jjstateSet[this.jjnewStateCnt++] = 45;
/*      */               break;
/*      */             case 46:
/*  585 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  586 */                 jjCheckNAddTwoStates(46, 47); 
/*      */               break;
/*      */             case 47:
/*  589 */               if (this.curChar == '_')
/*  590 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 48:
/*  593 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  594 */                 jjCheckNAddTwoStates(48, 49); 
/*      */               break;
/*      */             case 50:
/*  597 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  598 */                 jjAddStates(42, 43); 
/*      */               break;
/*      */             case 51:
/*  601 */               if (this.curChar == '_')
/*  602 */                 jjCheckNAdd(52); 
/*      */               break;
/*      */             case 52:
/*  605 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  607 */               if (kind > 7)
/*  608 */                 kind = 7; 
/*  609 */               jjCheckNAddTwoStates(47, 52);
/*      */               break;
/*      */             case 53:
/*  612 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  613 */                 jjCheckNAddTwoStates(53, 54); 
/*      */               break;
/*      */             case 54:
/*  616 */               if (this.curChar == '_')
/*  617 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 55:
/*  620 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  621 */                 jjCheckNAddTwoStates(55, 56); 
/*      */               break;
/*      */             case 57:
/*  624 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  625 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 58:
/*  628 */               if (this.curChar == '_')
/*  629 */                 jjCheckNAdd(59); 
/*      */               break;
/*      */             case 59:
/*  632 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  633 */                 jjCheckNAddTwoStates(59, 60); 
/*      */               break;
/*      */             case 60:
/*  636 */               if (this.curChar == '_')
/*  637 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 61:
/*  640 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  641 */                 jjCheckNAddTwoStates(61, 62); 
/*      */               break;
/*      */             case 63:
/*  644 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  646 */               if (kind > 7)
/*  647 */                 kind = 7; 
/*  648 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 64:
/*  651 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  652 */                 jjCheckNAddStates(30, 35); 
/*      */               break;
/*      */             case 65:
/*  655 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  656 */                 jjCheckNAddTwoStates(65, 66); 
/*      */               break;
/*      */             case 67:
/*  659 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  661 */               if (kind > 2)
/*  662 */                 kind = 2; 
/*  663 */               jjCheckNAddTwoStates(66, 67);
/*      */               break;
/*      */             case 68:
/*  666 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  667 */                 jjCheckNAddTwoStates(68, 69); 
/*      */               break;
/*      */             case 70:
/*  670 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  671 */                 jjAddStates(44, 45); 
/*      */               break;
/*      */             case 72:
/*  674 */               if ((0x7FFFFFE07FFFFFEL & l) != 0L)
/*  675 */                 jjCheckNAddTwoStates(72, 73); 
/*      */               break;
/*      */             case 73:
/*  678 */               if (this.curChar == '@')
/*  679 */                 jjCheckNAdd(74); 
/*      */               break;
/*      */             case 74:
/*  682 */               if ((0x7FFFFFE07FFFFFEL & l) == 0L)
/*      */                 break; 
/*  684 */               if (kind > 4)
/*  685 */                 kind = 4; 
/*  686 */               jjCheckNAdd(74);
/*      */               break;
/*      */           } 
/*      */         
/*  690 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  694 */         int hiByte = this.curChar >> 8;
/*  695 */         int i1 = hiByte >> 6;
/*  696 */         long l1 = 1L << (hiByte & 0x3F);
/*  697 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  698 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  701 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  704 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */               {
/*  706 */                 if (kind > 12)
/*  707 */                   kind = 12; 
/*      */               }
/*  709 */               if (jjCanMove_1(hiByte, i1, i2, l1, l2))
/*      */               {
/*  711 */                 if (kind > 13)
/*  712 */                   kind = 13; 
/*      */               }
/*  714 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  715 */                 jjCheckNAddStates(18, 23); 
/*  716 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  717 */                 jjCheckNAddStates(12, 17); 
/*  718 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2)) {
/*      */                 
/*  720 */                 if (kind > 1)
/*  721 */                   kind = 1; 
/*  722 */                 jjCheckNAddStates(0, 11);
/*      */               } 
/*  724 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  725 */                 jjCheckNAddStates(30, 35); 
/*      */               break;
/*      */             case 1:
/*  728 */               if (jjCanMove_1(hiByte, i1, i2, l1, l2) && kind > 13)
/*  729 */                 kind = 13; 
/*      */               break;
/*      */             case 2:
/*  732 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  733 */                 jjCheckNAddStates(18, 23); 
/*      */               break;
/*      */             case 3:
/*  736 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  737 */                 jjCheckNAddTwoStates(3, 4); 
/*      */               break;
/*      */             case 4:
/*  740 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  741 */                 jjCheckNAddTwoStates(5, 6); 
/*      */               break;
/*      */             case 5:
/*  744 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  745 */                 jjCheckNAddTwoStates(5, 6); 
/*      */               break;
/*      */             case 7:
/*  748 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  750 */               if (kind > 7)
/*  751 */                 kind = 7; 
/*  752 */               this.jjstateSet[this.jjnewStateCnt++] = 7;
/*      */               break;
/*      */             case 8:
/*  755 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  756 */                 jjCheckNAddTwoStates(8, 9); 
/*      */               break;
/*      */             case 9:
/*  759 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  760 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 10:
/*  763 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  764 */                 jjCheckNAddTwoStates(10, 11); 
/*      */               break;
/*      */             case 12:
/*  767 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  768 */                 jjAddStates(46, 47); 
/*      */               break;
/*      */             case 14:
/*  771 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  772 */                 jjAddStates(48, 49); 
/*      */               break;
/*      */             case 15:
/*  775 */               if (!jjCanMove_3(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  777 */               if (kind > 7)
/*  778 */                 kind = 7; 
/*  779 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 16:
/*  782 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  784 */               if (kind > 7)
/*  785 */                 kind = 7; 
/*  786 */               jjCheckNAddTwoStates(11, 16);
/*      */               break;
/*      */             case 17:
/*  789 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  790 */                 jjCheckNAddTwoStates(17, 18); 
/*      */               break;
/*      */             case 18:
/*  793 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  794 */                 jjCheckNAddTwoStates(19, 20); 
/*      */               break;
/*      */             case 19:
/*  797 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  798 */                 jjCheckNAddTwoStates(19, 20); 
/*      */               break;
/*      */             case 21:
/*  801 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  802 */                 jjCheckNAddTwoStates(21, 22); 
/*      */               break;
/*      */             case 23:
/*  805 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  806 */                 jjAddStates(50, 51); 
/*      */               break;
/*      */             case 24:
/*  809 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  810 */                 jjCheckNAddTwoStates(25, 26); 
/*      */               break;
/*      */             case 25:
/*  813 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  814 */                 jjCheckNAddTwoStates(25, 26); 
/*      */               break;
/*      */             case 27:
/*  817 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  819 */               if (kind > 7)
/*  820 */                 kind = 7; 
/*  821 */               jjCheckNAddTwoStates(22, 27);
/*      */               break;
/*      */             case 28:
/*  824 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  825 */                 jjCheckNAddStates(12, 17); 
/*      */               break;
/*      */             case 29:
/*  828 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  830 */               if (kind > 1)
/*  831 */                 kind = 1; 
/*  832 */               jjCheckNAddStates(0, 11);
/*      */               break;
/*      */             case 30:
/*  835 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  837 */               if (kind > 1)
/*  838 */                 kind = 1; 
/*  839 */               jjCheckNAdd(30);
/*      */               break;
/*      */             case 31:
/*  842 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  843 */                 jjCheckNAddStates(24, 26); 
/*      */               break;
/*      */             case 33:
/*  846 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  847 */                 jjCheckNAddStates(27, 29); 
/*      */               break;
/*      */             case 35:
/*  850 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  851 */                 jjCheckNAddTwoStates(35, 36); 
/*      */               break;
/*      */             case 37:
/*  854 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  856 */               if (kind > 5)
/*  857 */                 kind = 5; 
/*  858 */               jjCheckNAddTwoStates(36, 37);
/*      */               break;
/*      */             case 38:
/*  861 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  862 */                 jjCheckNAddTwoStates(38, 39); 
/*      */               break;
/*      */             case 40:
/*  865 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  867 */               if (kind > 6)
/*  868 */                 kind = 6; 
/*  869 */               jjCheckNAddTwoStates(39, 40);
/*      */               break;
/*      */             case 41:
/*  872 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  873 */                 jjCheckNAddTwoStates(41, 42); 
/*      */               break;
/*      */             case 43:
/*  876 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  877 */                 jjAddStates(52, 53); 
/*      */               break;
/*      */             case 44:
/*  880 */               if (!jjCanMove_3(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  882 */               if (kind > 7)
/*  883 */                 kind = 7; 
/*  884 */               jjCheckNAdd(45);
/*      */               break;
/*      */             case 45:
/*  887 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  889 */               if (kind > 7)
/*  890 */                 kind = 7; 
/*  891 */               jjCheckNAdd(45);
/*      */               break;
/*      */             case 46:
/*  894 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  895 */                 jjCheckNAddTwoStates(46, 47); 
/*      */               break;
/*      */             case 48:
/*  898 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  899 */                 jjAddStates(54, 55); 
/*      */               break;
/*      */             case 49:
/*  902 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  903 */                 jjCheckNAddTwoStates(50, 51); 
/*      */               break;
/*      */             case 50:
/*  906 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  907 */                 jjCheckNAddTwoStates(50, 51); 
/*      */               break;
/*      */             case 52:
/*  910 */               if (!jjCanMove_4(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  912 */               if (kind > 7)
/*  913 */                 kind = 7; 
/*  914 */               jjCheckNAddTwoStates(47, 52);
/*      */               break;
/*      */             case 53:
/*  917 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  918 */                 jjCheckNAddTwoStates(53, 54); 
/*      */               break;
/*      */             case 55:
/*  921 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  922 */                 jjAddStates(56, 57); 
/*      */               break;
/*      */             case 56:
/*  925 */               if (jjCanMove_3(hiByte, i1, i2, l1, l2))
/*  926 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 57:
/*  929 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  930 */                 jjCheckNAddTwoStates(57, 58); 
/*      */               break;
/*      */             case 59:
/*  933 */               if (jjCanMove_4(hiByte, i1, i2, l1, l2))
/*  934 */                 jjAddStates(58, 59); 
/*      */               break;
/*      */             case 61:
/*  937 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  938 */                 jjAddStates(60, 61); 
/*      */               break;
/*      */             case 62:
/*  941 */               if (!jjCanMove_3(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  943 */               if (kind > 7)
/*  944 */                 kind = 7; 
/*  945 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 63:
/*  948 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  950 */               if (kind > 7)
/*  951 */                 kind = 7; 
/*  952 */               jjCheckNAddTwoStates(58, 63);
/*      */               break;
/*      */             case 64:
/*  955 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  956 */                 jjCheckNAddStates(30, 35); 
/*      */               break;
/*      */             case 65:
/*  959 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  960 */                 jjCheckNAddTwoStates(65, 66); 
/*      */               break;
/*      */             case 67:
/*  963 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  965 */               if (kind > 2)
/*  966 */                 kind = 2; 
/*  967 */               jjCheckNAddTwoStates(66, 67);
/*      */               break;
/*      */             case 68:
/*  970 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  971 */                 jjCheckNAddTwoStates(68, 69); 
/*      */               break;
/*      */             case 70:
/*  974 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  975 */                 jjAddStates(44, 45); 
/*      */               break;
/*      */             case 72:
/*  978 */               if (jjCanMove_2(hiByte, i1, i2, l1, l2))
/*  979 */                 jjCheckNAddTwoStates(72, 73); 
/*      */               break;
/*      */             case 74:
/*  982 */               if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  984 */               if (kind > 4)
/*  985 */                 kind = 4; 
/*  986 */               this.jjstateSet[this.jjnewStateCnt++] = 74;
/*      */               break;
/*      */           } 
/*      */         
/*  990 */         } while (i != startsAt);
/*      */       } 
/*  992 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  994 */         this.jjmatchedKind = kind;
/*  995 */         this.jjmatchedPos = curPos;
/*  996 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  998 */       curPos++;
/*  999 */       if ((i = this.jjnewStateCnt) == (startsAt = 75 - (this.jjnewStateCnt = startsAt)))
/* 1000 */         return curPos;  
/* 1001 */       try { this.curChar = this.input_stream.readChar(); }
/* 1002 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/* 1005 */   } static final int[] jjnextStates = new int[] { 30, 31, 32, 34, 38, 39, 41, 42, 46, 47, 53, 54, 5, 6, 10, 11, 19, 20, 3, 4, 8, 9, 17, 18, 31, 32, 34, 32, 33, 34, 65, 66, 68, 69, 72, 73, 5, 6, 19, 20, 25, 26, 50, 51, 70, 71, 12, 13, 14, 15, 23, 24, 43, 44, 48, 49, 55, 56, 59, 60, 61, 62 };
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
/* 1013 */     switch (hiByte) {
/*      */       
/*      */       case 48:
/* 1016 */         return ((jjbitVec2[i2] & l2) != 0L);
/*      */       case 49:
/* 1018 */         return ((jjbitVec3[i2] & l2) != 0L);
/*      */       case 51:
/* 1020 */         return ((jjbitVec4[i2] & l2) != 0L);
/*      */       case 77:
/* 1022 */         return ((jjbitVec5[i2] & l2) != 0L);
/*      */       case 255:
/* 1024 */         return ((jjbitVec6[i2] & l2) != 0L);
/*      */     } 
/* 1026 */     if ((jjbitVec0[i1] & l1) != 0L)
/* 1027 */       return true; 
/* 1028 */     return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2) {
/* 1033 */     switch (hiByte) {
/*      */       
/*      */       case 215:
/* 1036 */         return ((jjbitVec8[i2] & l2) != 0L);
/*      */     } 
/* 1038 */     if ((jjbitVec7[i1] & l1) != 0L)
/* 1039 */       return true; 
/* 1040 */     return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2) {
/* 1045 */     switch (hiByte) {
/*      */       
/*      */       case 0:
/* 1048 */         return ((jjbitVec10[i2] & l2) != 0L);
/*      */       case 255:
/* 1050 */         return ((jjbitVec11[i2] & l2) != 0L);
/*      */     } 
/* 1052 */     if ((jjbitVec9[i1] & l1) != 0L)
/* 1053 */       return true; 
/* 1054 */     return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_3(int hiByte, int i1, int i2, long l1, long l2) {
/* 1059 */     switch (hiByte) {
/*      */       
/*      */       case 6:
/* 1062 */         return ((jjbitVec14[i2] & l2) != 0L);
/*      */       case 11:
/* 1064 */         return ((jjbitVec15[i2] & l2) != 0L);
/*      */       case 13:
/* 1066 */         return ((jjbitVec16[i2] & l2) != 0L);
/*      */       case 14:
/* 1068 */         return ((jjbitVec17[i2] & l2) != 0L);
/*      */       case 16:
/* 1070 */         return ((jjbitVec18[i2] & l2) != 0L);
/*      */     } 
/* 1072 */     if ((jjbitVec12[i1] & l1) != 0L) {
/* 1073 */       if ((jjbitVec13[i2] & l2) == 0L) {
/* 1074 */         return false;
/*      */       }
/* 1076 */       return true;
/* 1077 */     }  return false;
/*      */   }
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_4(int hiByte, int i1, int i2, long l1, long l2) {
/* 1082 */     switch (hiByte) {
/*      */       
/*      */       case 0:
/* 1085 */         return ((jjbitVec10[i2] & l2) != 0L);
/*      */       case 215:
/* 1087 */         return ((jjbitVec8[i2] & l2) != 0L);
/*      */       case 255:
/* 1089 */         return ((jjbitVec11[i2] & l2) != 0L);
/*      */     } 
/* 1091 */     if ((jjbitVec19[i1] & l1) != 0L)
/* 1092 */       return true; 
/* 1093 */     return false;
/*      */   }
/*      */   
/* 1096 */   public static final String[] jjstrLiteralImages = new String[] { """", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };
/*      */ 
/*      */   
/* 1099 */   public static final String[] lexStateNames = new String[] { ""DEFAULT"" };
/*      */ 
/*      */   
/* 1102 */   static final long[] jjtoToken = new long[] { 12543L };
/*      */ 
/*      */   
/* 1105 */   static final long[] jjtoSkip = new long[] { 32768L };
/*      */   
/*      */   protected CharStream input_stream;
/*      */   
/* 1109 */   private final int[] jjrounds = new int[75];
/* 1110 */   private final int[] jjstateSet = new int[150]; protected char curChar; int curLexState;
/*      */   int defaultLexState;
/*      */   int jjnewStateCnt;
/*      */   int jjround;
/*      */   int jjmatchedPos;
/*      */   int jjmatchedKind;
/*      */   
/*      */   public StandardTokenizerTokenManager(CharStream stream, int lexState) {
/* 1118 */     this(stream);
/* 1119 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream) {
/* 1123 */     this.jjmatchedPos = this.jjnewStateCnt = 0;
/* 1124 */     this.curLexState = this.defaultLexState;
/* 1125 */     this.input_stream = stream;
/* 1126 */     ReInitRounds();
/*      */   }
/*      */ 
/*      */   
/*      */   private final void ReInitRounds() {
/* 1131 */     this.jjround = -2147483647;
/* 1132 */     for (int i = 75; i-- > 0;)
/* 1133 */       this.jjrounds[i] = Integer.MIN_VALUE; 
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream, int lexState) {
/* 1137 */     ReInit(stream);
/* 1138 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void SwitchTo(int lexState) {
/* 1142 */     if (lexState >= 1 || lexState < 0) {
/* 1143 */       throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", 2);
/*      */     }
/* 1145 */     this.curLexState = lexState;
/*      */   }
/*      */ 
/*      */   
/*      */   protected Token jjFillToken() {
/* 1150 */     Token t = Token.newToken(this.jjmatchedKind);
/* 1151 */     t.kind = this.jjmatchedKind;
/* 1152 */     String im = jjstrLiteralImages[this.jjmatchedKind];
/* 1153 */     t.image = (im == null) ? this.input_stream.GetImage() : im;
/* 1154 */     t.beginLine = this.input_stream.getBeginLine();
/* 1155 */     t.beginColumn = this.input_stream.getBeginColumn();
/* 1156 */     t.endLine = this.input_stream.getEndLine();
/* 1157 */     t.endColumn = this.input_stream.getEndColumn();
/* 1158 */     return t;
/*      */   }
/*      */   public StandardTokenizerTokenManager(CharStream stream) {
/* 1161 */     this.curLexState = 0;
/* 1162 */     this.defaultLexState = 0;
/*      */     this.input_stream = stream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Token getNextToken() {
/* 1171 */     Token specialToken = null;
/*      */     
/* 1173 */     int curPos = 0;
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     while (true) {
/*      */       try {
/* 1180 */         this.curChar = this.input_stream.BeginToken();
/*      */       }
/* 1182 */       catch (IOException e) {
/*      */         
/* 1184 */         this.jjmatchedKind = 0;
/* 1185 */         Token matchedToken = jjFillToken();
/* 1186 */         return matchedToken;
/*      */       } 
/*      */       
/* 1189 */       this.jjmatchedKind = Integer.MAX_VALUE;
/* 1190 */       this.jjmatchedPos = 0;
/* 1191 */       curPos = jjMoveStringLiteralDfa0_0();
/* 1192 */       if (this.jjmatchedPos == 0 && this.jjmatchedKind > 15)
/*      */       {
/* 1194 */         this.jjmatchedKind = 15;
/*      */       }
/* 1196 */       if (this.jjmatchedKind != Integer.MAX_VALUE) {
/*      */         
/* 1198 */         if (this.jjmatchedPos + 1 < curPos)
/* 1199 */           this.input_stream.backup(curPos - this.jjmatchedPos - 1); 
/* 1200 */         if ((jjtoToken[this.jjmatchedKind >> 6] & 1L << (this.jjmatchedKind & 0x3F)) != 0L) {
/*      */           
/* 1202 */           Token matchedToken = jjFillToken();
/* 1203 */           return matchedToken;
/*      */         } 
/*      */         
/*      */         continue;
/*      */       } 
/*      */       break;
/*      */     } 
/* 1210 */     int error_line = this.input_stream.getEndLine();
/* 1211 */     int error_column = this.input_stream.getEndColumn();
/* 1212 */     String error_after = null;
/* 1213 */     boolean EOFSeen = false; try {
/* 1214 */       this.input_stream.readChar(); this.input_stream.backup(1);
/* 1215 */     } catch (IOException e1) {
/* 1216 */       EOFSeen = true;
/* 1217 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/* 1218 */       if (this.curChar == '\n' || this.curChar == '\r') {
/* 1219 */         error_line++;
/* 1220 */         error_column = 0;
/*      */       } else {
/*      */         
/* 1223 */         error_column++;
/*      */       } 
/* 1225 */     }  if (!EOFSeen) {
/* 1226 */       this.input_stream.backup(1);
/* 1227 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/*      */     } 
/* 1229 */     throw new TokenMgrError(EOFSeen, this.curLexState, error_line, error_column, error_after, this.curChar, 0);
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\StandardTokenizerTokenManager.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.Token,"/*    */ package org.apache.lucene.analysis.standard;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Token
/*    */ {
/*    */   public int kind;
/*    */   public int beginLine;
/*    */   public int beginColumn;
/*    */   public int endLine;
/*    */   public int endColumn;
/*    */   public String image;
/*    */   public Token next;
/*    */   public Token specialToken;
/*    */   
/* 58 */   public String toString() { return this.image; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static final Token newToken(int ofKind) {
/* 75 */     switch (ofKind) {
/*    */     
/* 77 */     }  return new Token();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.analysis.standard.TokenMgrError,"/*     */ package org.apache.lucene.analysis.standard;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TokenMgrError
/*     */   extends Error
/*     */ {
/*     */   static final int LEXICAL_ERROR = 0;
/*     */   static final int STATIC_LEXER_ERROR = 1;
/*     */   static final int INVALID_LEXICAL_STATE = 2;
/*     */   static final int LOOP_DETECTED = 3;
/*     */   int errorCode;
/*     */   
/*     */   protected static final String addEscapes(String str) {
/*  41 */     StringBuffer retval = new StringBuffer();
/*     */     
/*  43 */     for (int i = 0; i < str.length(); i++) {
/*  44 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/*  49 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/*  52 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/*  55 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/*  58 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/*  61 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/*  64 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/*  67 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/*  70 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/*  73 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/*  74 */             String s = ""0000"" + Integer.toString(ch, 16);
/*  75 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/*  77 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/*  82 */     return retval.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) { return ""Lexical error at line "" + errorLine + "", column "" + errorColumn + "".  Encountered: "" + (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""" + "" ("" + curChar + ""), "")) + ""after : \"""" + addEscapes(errorAfter) + ""\""""; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public String getMessage() { return super.getMessage(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError() {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError(String message, int reason) {
/* 126 */     super(message);
/* 127 */     this.errorCode = reason;
/*     */   }
/*     */ 
/*     */   
/* 131 */   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) { this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\analysis\standard\TokenMgrError.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.AbstractField,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class AbstractField
/*     */   implements Fieldable
/*     */ {
/*  25 */   protected String name = ""body"";
/*     */   protected boolean storeTermVector = false;
/*     */   protected boolean storeOffsetWithTermVector = false;
/*     */   protected boolean storePositionWithTermVector = false;
/*     */   protected boolean omitNorms = false;
/*     */   protected boolean isStored = false;
/*     */   protected boolean isIndexed = true;
/*     */   protected boolean isTokenized = true;
/*     */   protected boolean isBinary = false;
/*     */   protected boolean isCompressed = false;
/*     */   protected boolean lazy = false;
/*  36 */   protected float boost = 1.0F;
/*     */   
/*  38 */   protected Object fieldsData = null;
/*     */ 
/*     */ 
/*     */   
/*     */   protected AbstractField() {}
/*     */ 
/*     */   
/*     */   protected AbstractField(String name, Field.Store store, Field.Index index, Field.TermVector termVector) {
/*  46 */     if (name == null)
/*  47 */       throw new NullPointerException(""name cannot be null""); 
/*  48 */     this.name = name.intern();
/*     */     
/*  50 */     if (store == Field.Store.YES) {
/*  51 */       this.isStored = true;
/*  52 */       this.isCompressed = false;
/*     */     }
/*  54 */     else if (store == Field.Store.COMPRESS) {
/*  55 */       this.isStored = true;
/*  56 */       this.isCompressed = true;
/*     */     }
/*  58 */     else if (store == Field.Store.NO) {
/*  59 */       this.isStored = false;
/*  60 */       this.isCompressed = false;
/*     */     } else {
/*     */       
/*  63 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/*  65 */     if (index == Field.Index.NO) {
/*  66 */       this.isIndexed = false;
/*  67 */       this.isTokenized = false;
/*  68 */     } else if (index == Field.Index.TOKENIZED) {
/*  69 */       this.isIndexed = true;
/*  70 */       this.isTokenized = true;
/*  71 */     } else if (index == Field.Index.UN_TOKENIZED) {
/*  72 */       this.isIndexed = true;
/*  73 */       this.isTokenized = false;
/*  74 */     } else if (index == Field.Index.NO_NORMS) {
/*  75 */       this.isIndexed = true;
/*  76 */       this.isTokenized = false;
/*  77 */       this.omitNorms = true;
/*     */     } else {
/*  79 */       throw new IllegalArgumentException(""unknown index parameter "" + index);
/*     */     } 
/*     */     
/*  82 */     this.isBinary = false;
/*     */     
/*  84 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 104 */   public void setBoost(float boost) { this.boost = boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 119 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 125 */   public String name() { return this.name; }
/*     */   
/*     */   protected void setStoreTermVector(Field.TermVector termVector) {
/* 128 */     if (termVector == Field.TermVector.NO) {
/* 129 */       this.storeTermVector = false;
/* 130 */       this.storePositionWithTermVector = false;
/* 131 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 133 */     else if (termVector == Field.TermVector.YES) {
/* 134 */       this.storeTermVector = true;
/* 135 */       this.storePositionWithTermVector = false;
/* 136 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 138 */     else if (termVector == Field.TermVector.WITH_POSITIONS) {
/* 139 */       this.storeTermVector = true;
/* 140 */       this.storePositionWithTermVector = true;
/* 141 */       this.storeOffsetWithTermVector = false;
/*     */     }
/* 143 */     else if (termVector == Field.TermVector.WITH_OFFSETS) {
/* 144 */       this.storeTermVector = true;
/* 145 */       this.storePositionWithTermVector = false;
/* 146 */       this.storeOffsetWithTermVector = true;
/*     */     }
/* 148 */     else if (termVector == Field.TermVector.WITH_POSITIONS_OFFSETS) {
/* 149 */       this.storeTermVector = true;
/* 150 */       this.storePositionWithTermVector = true;
/* 151 */       this.storeOffsetWithTermVector = true;
/*     */     } else {
/*     */       
/* 154 */       throw new IllegalArgumentException(""unknown termVector parameter "" + termVector);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 161 */   public final boolean isStored() { return this.isStored; }
/*     */ 
/*     */ 
/*     */   
/* 165 */   public final boolean isIndexed() { return this.isIndexed; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 170 */   public final boolean isTokenized() { return this.isTokenized; }
/*     */ 
/*     */   
/* 173 */   public final boolean isCompressed() { return this.isCompressed; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 183 */   public final boolean isTermVectorStored() { return this.storeTermVector; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 190 */   public boolean isStoreOffsetWithTermVector() { return this.storeOffsetWithTermVector; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 197 */   public boolean isStorePositionWithTermVector() { return this.storePositionWithTermVector; }
/*     */ 
/*     */ 
/*     */   
/* 201 */   public final boolean isBinary() { return this.isBinary; }
/*     */ 
/*     */   
/* 204 */   public boolean getOmitNorms() { return this.omitNorms; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 211 */   public void setOmitNorms(boolean omitNorms) { this.omitNorms = omitNorms; }
/*     */ 
/*     */   
/* 214 */   public boolean isLazy() { return this.lazy; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final String toString() {
/* 219 */     StringBuffer result = new StringBuffer();
/* 220 */     if (this.isStored) {
/* 221 */       result.append(""stored"");
/* 222 */       if (this.isCompressed) {
/* 223 */         result.append(""/compressed"");
/*     */       } else {
/* 225 */         result.append(""/uncompressed"");
/*     */       } 
/* 227 */     }  if (this.isIndexed) {
/* 228 */       if (result.length() > 0)
/* 229 */         result.append("",""); 
/* 230 */       result.append(""indexed"");
/*     */     } 
/* 232 */     if (this.isTokenized) {
/* 233 */       if (result.length() > 0)
/* 234 */         result.append("",""); 
/* 235 */       result.append(""tokenized"");
/*     */     } 
/* 237 */     if (this.storeTermVector) {
/* 238 */       if (result.length() > 0)
/* 239 */         result.append("",""); 
/* 240 */       result.append(""termVector"");
/*     */     } 
/* 242 */     if (this.storeOffsetWithTermVector) {
/* 243 */       if (result.length() > 0)
/* 244 */         result.append("",""); 
/* 245 */       result.append(""termVectorOffsets"");
/*     */     } 
/* 247 */     if (this.storePositionWithTermVector) {
/* 248 */       if (result.length() > 0)
/* 249 */         result.append("",""); 
/* 250 */       result.append(""termVectorPosition"");
/*     */     } 
/* 252 */     if (this.isBinary) {
/* 253 */       if (result.length() > 0)
/* 254 */         result.append("",""); 
/* 255 */       result.append(""binary"");
/*     */     } 
/* 257 */     if (this.omitNorms) {
/* 258 */       result.append("",omitNorms"");
/*     */     }
/* 260 */     if (this.lazy) {
/* 261 */       result.append("",lazy"");
/*     */     }
/* 263 */     result.append('<');
/* 264 */     result.append(this.name);
/* 265 */     result.append(':');
/*     */     
/* 267 */     if (this.fieldsData != null && !this.lazy) {
/* 268 */       result.append(this.fieldsData);
/*     */     }
/*     */     
/* 271 */     result.append('>');
/* 272 */     return result.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\AbstractField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.DateField,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.util.Date;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DateField
/*     */ {
/*  49 */   private static int DATE_LEN = Long.toString(31536000000000L, 36).length();
/*     */ 
/*     */ 
/*     */   
/*  53 */   public static String MIN_DATE_STRING() { return timeToString(0L); }
/*     */ 
/*     */   
/*     */   public static String MAX_DATE_STRING() {
/*  57 */     char[] buffer = new char[DATE_LEN];
/*  58 */     char c = Character.forDigit(35, 36);
/*  59 */     for (int i = 0; i < DATE_LEN; i++)
/*  60 */       buffer[i] = c; 
/*  61 */     return new String(buffer);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  70 */   public static String dateToString(Date date) { return timeToString(date.getTime()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String timeToString(long time) {
/*  78 */     if (time < 0L) {
/*  79 */       throw new RuntimeException(""time '"" + time + ""' is too early, must be >= 0"");
/*     */     }
/*  81 */     String s = Long.toString(time, 36);
/*     */     
/*  83 */     if (s.length() > DATE_LEN) {
/*  84 */       throw new RuntimeException(""time '"" + time + ""' is too late, length of string "" + ""representation must be <= "" + DATE_LEN);
/*     */     }
/*     */ 
/*     */     
/*  88 */     if (s.length() < DATE_LEN) {
/*  89 */       StringBuffer sb = new StringBuffer(s);
/*  90 */       while (sb.length() < DATE_LEN)
/*  91 */         sb.insert(0, 0); 
/*  92 */       s = sb.toString();
/*     */     } 
/*     */     
/*  95 */     return s;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 100 */   public static long stringToTime(String s) { return Long.parseLong(s, 36); }
/*     */ 
/*     */ 
/*     */   
/* 104 */   public static Date stringToDate(String s) { return new Date(stringToTime(s)); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\DateField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.DateTools,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.text.ParseException;
/*     */ import java.text.SimpleDateFormat;
/*     */ import java.util.Calendar;
/*     */ import java.util.Date;
/*     */ import java.util.TimeZone;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DateTools
/*     */ {
/*  42 */   private static final TimeZone GMT = TimeZone.getTimeZone(""GMT"");
/*     */   
/*  44 */   private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(""yyyy"");
/*  45 */   private static final SimpleDateFormat MONTH_FORMAT = new SimpleDateFormat(""yyyyMM"");
/*  46 */   private static final SimpleDateFormat DAY_FORMAT = new SimpleDateFormat(""yyyyMMdd"");
/*  47 */   private static final SimpleDateFormat HOUR_FORMAT = new SimpleDateFormat(""yyyyMMddHH"");
/*  48 */   private static final SimpleDateFormat MINUTE_FORMAT = new SimpleDateFormat(""yyyyMMddHHmm"");
/*  49 */   private static final SimpleDateFormat SECOND_FORMAT = new SimpleDateFormat(""yyyyMMddHHmmss"");
/*  50 */   private static final SimpleDateFormat MILLISECOND_FORMAT = new SimpleDateFormat(""yyyyMMddHHmmssSSS"");
/*     */ 
/*     */   
/*     */   static  {
/*  54 */     YEAR_FORMAT.setTimeZone(GMT);
/*  55 */     MONTH_FORMAT.setTimeZone(GMT);
/*  56 */     DAY_FORMAT.setTimeZone(GMT);
/*  57 */     HOUR_FORMAT.setTimeZone(GMT);
/*  58 */     MINUTE_FORMAT.setTimeZone(GMT);
/*  59 */     SECOND_FORMAT.setTimeZone(GMT);
/*  60 */     MILLISECOND_FORMAT.setTimeZone(GMT);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public static String dateToString(Date date, Resolution resolution) { return timeToString(date.getTime(), resolution); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String timeToString(long time, Resolution resolution) {
/*     */     String result;
/*  89 */     Calendar cal = Calendar.getInstance(GMT);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  94 */     cal.setTime(new Date(round(time, resolution)));
/*     */ 
/*     */     
/*  97 */     if (resolution == Resolution.YEAR) {
/*  98 */       synchronized (YEAR_FORMAT) {
/*  99 */         result = YEAR_FORMAT.format(cal.getTime());
/*     */       } 
/* 101 */     } else if (resolution == Resolution.MONTH) {
/* 102 */       synchronized (MONTH_FORMAT) {
/* 103 */         result = MONTH_FORMAT.format(cal.getTime());
/*     */       } 
/* 105 */     } else if (resolution == Resolution.DAY) {
/* 106 */       synchronized (DAY_FORMAT) {
/* 107 */         result = DAY_FORMAT.format(cal.getTime());
/*     */       } 
/* 109 */     } else if (resolution == Resolution.HOUR) {
/* 110 */       synchronized (HOUR_FORMAT) {
/* 111 */         result = HOUR_FORMAT.format(cal.getTime());
/*     */       } 
/* 113 */     } else if (resolution == Resolution.MINUTE) {
/* 114 */       synchronized (MINUTE_FORMAT) {
/* 115 */         result = MINUTE_FORMAT.format(cal.getTime());
/*     */       } 
/* 117 */     } else if (resolution == Resolution.SECOND) {
/* 118 */       synchronized (SECOND_FORMAT) {
/* 119 */         result = SECOND_FORMAT.format(cal.getTime());
/*     */       } 
/* 121 */     } else if (resolution == Resolution.MILLISECOND) {
/* 122 */       synchronized (MILLISECOND_FORMAT) {
/* 123 */         result = MILLISECOND_FORMAT.format(cal.getTime());
/*     */       } 
/*     */     } else {
/* 126 */       throw new IllegalArgumentException(""unknown resolution "" + resolution);
/*     */     } 
/* 128 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 142 */   public static long stringToTime(String dateString) throws ParseException { return stringToDate(dateString).getTime(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Date stringToDate(String dateString) throws ParseException {
/*     */     Date date;
/* 157 */     if (dateString.length() == 4) {
/* 158 */       synchronized (YEAR_FORMAT) {
/* 159 */         date = YEAR_FORMAT.parse(dateString);
/*     */       } 
/* 161 */     } else if (dateString.length() == 6) {
/* 162 */       synchronized (MONTH_FORMAT) {
/* 163 */         date = MONTH_FORMAT.parse(dateString);
/*     */       } 
/* 165 */     } else if (dateString.length() == 8) {
/* 166 */       synchronized (DAY_FORMAT) {
/* 167 */         date = DAY_FORMAT.parse(dateString);
/*     */       } 
/* 169 */     } else if (dateString.length() == 10) {
/* 170 */       synchronized (HOUR_FORMAT) {
/* 171 */         date = HOUR_FORMAT.parse(dateString);
/*     */       } 
/* 173 */     } else if (dateString.length() == 12) {
/* 174 */       synchronized (MINUTE_FORMAT) {
/* 175 */         date = MINUTE_FORMAT.parse(dateString);
/*     */       } 
/* 177 */     } else if (dateString.length() == 14) {
/* 178 */       synchronized (SECOND_FORMAT) {
/* 179 */         date = SECOND_FORMAT.parse(dateString);
/*     */       } 
/* 181 */     } else if (dateString.length() == 17) {
/* 182 */       synchronized (MILLISECOND_FORMAT) {
/* 183 */         date = MILLISECOND_FORMAT.parse(dateString);
/*     */       } 
/*     */     } else {
/* 186 */       throw new ParseException(""Input is not valid date string: "" + dateString, 0);
/*     */     } 
/* 188 */     return date;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 201 */   public static Date round(Date date, Resolution resolution) { return new Date(round(date.getTime(), resolution)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long round(long time, Resolution resolution) {
/* 215 */     Calendar cal = Calendar.getInstance(GMT);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 220 */     cal.setTime(new Date(time));
/*     */     
/* 222 */     if (resolution == Resolution.YEAR) {
/* 223 */       cal.set(2, 0);
/* 224 */       cal.set(5, 1);
/* 225 */       cal.set(11, 0);
/* 226 */       cal.set(12, 0);
/* 227 */       cal.set(13, 0);
/* 228 */       cal.set(14, 0);
/* 229 */     } else if (resolution == Resolution.MONTH) {
/* 230 */       cal.set(5, 1);
/* 231 */       cal.set(11, 0);
/* 232 */       cal.set(12, 0);
/* 233 */       cal.set(13, 0);
/* 234 */       cal.set(14, 0);
/* 235 */     } else if (resolution == Resolution.DAY) {
/* 236 */       cal.set(11, 0);
/* 237 */       cal.set(12, 0);
/* 238 */       cal.set(13, 0);
/* 239 */       cal.set(14, 0);
/* 240 */     } else if (resolution == Resolution.HOUR) {
/* 241 */       cal.set(12, 0);
/* 242 */       cal.set(13, 0);
/* 243 */       cal.set(14, 0);
/* 244 */     } else if (resolution == Resolution.MINUTE) {
/* 245 */       cal.set(13, 0);
/* 246 */       cal.set(14, 0);
/* 247 */     } else if (resolution == Resolution.SECOND) {
/* 248 */       cal.set(14, 0);
/* 249 */     } else if (resolution != Resolution.MILLISECOND) {
/*     */ 
/*     */       
/* 252 */       throw new IllegalArgumentException(""unknown resolution "" + resolution);
/*     */     } 
/* 254 */     return cal.getTime().getTime();
/*     */   }
/*     */ 
/*     */   
/*     */   public static class Resolution
/*     */   {
/* 260 */     public static final Resolution YEAR = new Resolution(""year"");
/* 261 */     public static final Resolution MONTH = new Resolution(""month"");
/* 262 */     public static final Resolution DAY = new Resolution(""day"");
/* 263 */     public static final Resolution HOUR = new Resolution(""hour"");
/* 264 */     public static final Resolution MINUTE = new Resolution(""minute"");
/* 265 */     public static final Resolution SECOND = new Resolution(""second"");
/* 266 */     public static final Resolution MILLISECOND = new Resolution(""millisecond"");
/*     */     
/*     */     private String resolution;
/*     */ 
/*     */     
/*     */     private Resolution() {}
/*     */ 
/*     */     
/* 274 */     private Resolution(String resolution) { this.resolution = resolution; }
/*     */ 
/*     */ 
/*     */     
/* 278 */     public String toString() { return this.resolution; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\DateTools.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Document,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Enumeration;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Vector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Document
/*     */   implements Serializable
/*     */ {
/*  41 */   List fields = new Vector();
/*  42 */   private float boost = 1.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  58 */   public void setBoost(float boost) { this.boost = boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  73 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   public final void add(Fieldable field) { this.fields.add(field); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void removeField(String name) {
/* 101 */     Iterator it = this.fields.iterator();
/* 102 */     while (it.hasNext()) {
/* 103 */       Fieldable field = it.next();
/* 104 */       if (field.name().equals(name)) {
/* 105 */         it.remove();
/*     */         return;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void removeFields(String name) {
/* 121 */     Iterator it = this.fields.iterator();
/* 122 */     while (it.hasNext()) {
/* 123 */       Fieldable field = it.next();
/* 124 */       if (field.name().equals(name)) {
/* 125 */         it.remove();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Field getField(String name) {
/* 136 */     for (int i = 0; i < this.fields.size(); i++) {
/* 137 */       Field field = this.fields.get(i);
/* 138 */       if (field.name().equals(name))
/* 139 */         return field; 
/*     */     } 
/* 141 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Fieldable getFieldable(String name) {
/* 150 */     for (int i = 0; i < this.fields.size(); i++) {
/* 151 */       Fieldable field = this.fields.get(i);
/* 152 */       if (field.name().equals(name))
/* 153 */         return field; 
/*     */     } 
/* 155 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String get(String name) {
/* 164 */     for (int i = 0; i < this.fields.size(); i++) {
/* 165 */       Fieldable field = this.fields.get(i);
/* 166 */       if (field.name().equals(name) && !field.isBinary())
/* 167 */         return field.stringValue(); 
/*     */     } 
/* 169 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 176 */   public final Enumeration fields() { return ((Vector)this.fields).elements(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 185 */   public final List getFields() { return this.fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Field[] getFields(String name) {
/* 197 */     List result = new ArrayList();
/* 198 */     for (int i = 0; i < this.fields.size(); i++) {
/* 199 */       Field field = this.fields.get(i);
/* 200 */       if (field.name().equals(name)) {
/* 201 */         result.add(field);
/*     */       }
/*     */     } 
/*     */     
/* 205 */     if (result.size() == 0) {
/* 206 */       return null;
/*     */     }
/* 208 */     return result.toArray(new Field[result.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Fieldable[] getFieldables(String name) {
/* 220 */     List result = new ArrayList();
/* 221 */     for (int i = 0; i < this.fields.size(); i++) {
/* 222 */       Fieldable field = this.fields.get(i);
/* 223 */       if (field.name().equals(name)) {
/* 224 */         result.add(field);
/*     */       }
/*     */     } 
/*     */     
/* 228 */     if (result.size() == 0) {
/* 229 */       return null;
/*     */     }
/* 231 */     return result.toArray(new Fieldable[result.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final String[] getValues(String name) {
/* 243 */     List result = new ArrayList();
/* 244 */     for (int i = 0; i < this.fields.size(); i++) {
/* 245 */       Fieldable field = this.fields.get(i);
/* 246 */       if (field.name().equals(name) && !field.isBinary()) {
/* 247 */         result.add(field.stringValue());
/*     */       }
/*     */     } 
/* 250 */     if (result.size() == 0) {
/* 251 */       return null;
/*     */     }
/* 253 */     return result.toArray(new String[result.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final byte[][] getBinaryValues(String name) {
/* 265 */     List result = new ArrayList();
/* 266 */     for (int i = 0; i < this.fields.size(); i++) {
/* 267 */       Fieldable field = this.fields.get(i);
/* 268 */       if (field.name().equals(name) && field.isBinary()) {
/* 269 */         result.add(field.binaryValue());
/*     */       }
/*     */     } 
/* 272 */     if (result.size() == 0) {
/* 273 */       return (byte[][])null;
/*     */     }
/* 275 */     return result.toArray(new byte[result.size()][]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final byte[] getBinaryValue(String name) {
/* 288 */     for (int i = 0; i < this.fields.size(); i++) {
/* 289 */       Fieldable field = this.fields.get(i);
/* 290 */       if (field.name().equals(name) && field.isBinary())
/* 291 */         return field.binaryValue(); 
/*     */     } 
/* 293 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   public final String toString() {
/* 298 */     StringBuffer buffer = new StringBuffer();
/* 299 */     buffer.append(""Document<"");
/* 300 */     for (int i = 0; i < this.fields.size(); i++) {
/* 301 */       Fieldable field = this.fields.get(i);
/* 302 */       buffer.append(field.toString());
/* 303 */       if (i != this.fields.size() - 1)
/* 304 */         buffer.append("" ""); 
/*     */     } 
/* 306 */     buffer.append("">"");
/* 307 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\Document.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Field,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ import java.io.Reader;
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.util.Parameter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Field
/*     */   extends AbstractField
/*     */   implements Fieldable, Serializable
/*     */ {
/*     */   public static final class Store
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  41 */     private Store(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  47 */     public static final Store COMPRESS = new Store(""COMPRESS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  54 */     public static final Store YES = new Store(""YES"");
/*     */ 
/*     */     
/*  57 */     public static final Store NO = new Store(""NO"");
/*     */   }
/*     */   
/*     */   public static final class Index
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  64 */     private Index(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  70 */     public static final Index NO = new Index(""NO"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  76 */     public static final Index TOKENIZED = new Index(""TOKENIZED"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  82 */     public static final Index UN_TOKENIZED = new Index(""UN_TOKENIZED"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  94 */     public static final Index NO_NORMS = new Index(""NO_NORMS"");
/*     */   }
/*     */ 
/*     */   
/*     */   public static final class TermVector
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/* 102 */     private TermVector(String name) { super(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 107 */     public static final TermVector NO = new TermVector(""NO"");
/*     */ 
/*     */ 
/*     */     
/* 111 */     public static final TermVector YES = new TermVector(""YES"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 118 */     public static final TermVector WITH_POSITIONS = new TermVector(""WITH_POSITIONS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 125 */     public static final TermVector WITH_OFFSETS = new TermVector(""WITH_OFFSETS"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 134 */     public static final TermVector WITH_POSITIONS_OFFSETS = new TermVector(""WITH_POSITIONS_OFFSETS"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 141 */   public String stringValue() { return (this.fieldsData instanceof String) ? (String)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 146 */   public Reader readerValue() { return (this.fieldsData instanceof Reader) ? (Reader)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 151 */   public byte[] binaryValue() { return (this.fieldsData instanceof byte[]) ? (byte[])this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 156 */   public TokenStream tokenStreamValue() { return (this.fieldsData instanceof TokenStream) ? (TokenStream)this.fieldsData : null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 171 */   public Field(String name, String value, Store store, Index index) { this(name, value, store, index, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, String value, Store store, Index index, TermVector termVector) {
/* 192 */     if (name == null)
/* 193 */       throw new NullPointerException(""name cannot be null""); 
/* 194 */     if (value == null)
/* 195 */       throw new NullPointerException(""value cannot be null""); 
/* 196 */     if (name.length() == 0 && value.length() == 0)
/* 197 */       throw new IllegalArgumentException(""name and value cannot both be empty""); 
/* 198 */     if (index == Index.NO && store == Store.NO) {
/* 199 */       throw new IllegalArgumentException(""it doesn't make sense to have a field that is neither indexed nor stored"");
/*     */     }
/* 201 */     if (index == Index.NO && termVector != TermVector.NO) {
/* 202 */       throw new IllegalArgumentException(""cannot store term vector information for a field that is not indexed"");
/*     */     }
/*     */     
/* 205 */     this.name = name.intern();
/* 206 */     this.fieldsData = value;
/*     */     
/* 208 */     if (store == Store.YES) {
/* 209 */       this.isStored = true;
/* 210 */       this.isCompressed = false;
/*     */     }
/* 212 */     else if (store == Store.COMPRESS) {
/* 213 */       this.isStored = true;
/* 214 */       this.isCompressed = true;
/*     */     }
/* 216 */     else if (store == Store.NO) {
/* 217 */       this.isStored = false;
/* 218 */       this.isCompressed = false;
/*     */     } else {
/*     */       
/* 221 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/* 223 */     if (index == Index.NO) {
/* 224 */       this.isIndexed = false;
/* 225 */       this.isTokenized = false;
/* 226 */     } else if (index == Index.TOKENIZED) {
/* 227 */       this.isIndexed = true;
/* 228 */       this.isTokenized = true;
/* 229 */     } else if (index == Index.UN_TOKENIZED) {
/* 230 */       this.isIndexed = true;
/* 231 */       this.isTokenized = false;
/* 232 */     } else if (index == Index.NO_NORMS) {
/* 233 */       this.isIndexed = true;
/* 234 */       this.isTokenized = false;
/* 235 */       this.omitNorms = true;
/*     */     } else {
/* 237 */       throw new IllegalArgumentException(""unknown index parameter "" + index);
/*     */     } 
/*     */     
/* 240 */     this.isBinary = false;
/*     */     
/* 242 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 256 */   public Field(String name, Reader reader) { this(name, reader, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, Reader reader, TermVector termVector) {
/* 271 */     if (name == null)
/* 272 */       throw new NullPointerException(""name cannot be null""); 
/* 273 */     if (reader == null) {
/* 274 */       throw new NullPointerException(""reader cannot be null"");
/*     */     }
/* 276 */     this.name = name.intern();
/* 277 */     this.fieldsData = reader;
/*     */     
/* 279 */     this.isStored = false;
/* 280 */     this.isCompressed = false;
/*     */     
/* 282 */     this.isIndexed = true;
/* 283 */     this.isTokenized = true;
/*     */     
/* 285 */     this.isBinary = false;
/*     */     
/* 287 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 302 */   public Field(String name, TokenStream tokenStream) { this(name, tokenStream, TermVector.NO); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, TokenStream tokenStream, TermVector termVector) {
/* 318 */     if (name == null)
/* 319 */       throw new NullPointerException(""name cannot be null""); 
/* 320 */     if (tokenStream == null) {
/* 321 */       throw new NullPointerException(""tokenStream cannot be null"");
/*     */     }
/* 323 */     this.name = name.intern();
/* 324 */     this.fieldsData = tokenStream;
/*     */     
/* 326 */     this.isStored = false;
/* 327 */     this.isCompressed = false;
/*     */     
/* 329 */     this.isIndexed = true;
/* 330 */     this.isTokenized = true;
/*     */     
/* 332 */     this.isBinary = false;
/*     */     
/* 334 */     setStoreTermVector(termVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Field(String name, byte[] value, Store store) {
/* 347 */     if (name == null)
/* 348 */       throw new IllegalArgumentException(""name cannot be null""); 
/* 349 */     if (value == null) {
/* 350 */       throw new IllegalArgumentException(""value cannot be null"");
/*     */     }
/* 352 */     this.name = name.intern();
/* 353 */     this.fieldsData = value;
/*     */     
/* 355 */     if (store == Store.YES) {
/* 356 */       this.isStored = true;
/* 357 */       this.isCompressed = false;
/*     */     }
/* 359 */     else if (store == Store.COMPRESS) {
/* 360 */       this.isStored = true;
/* 361 */       this.isCompressed = true;
/*     */     } else {
/* 363 */       if (store == Store.NO) {
/* 364 */         throw new IllegalArgumentException(""binary values can't be unstored"");
/*     */       }
/* 366 */       throw new IllegalArgumentException(""unknown store parameter "" + store);
/*     */     } 
/* 368 */     this.isIndexed = false;
/* 369 */     this.isTokenized = false;
/*     */     
/* 371 */     this.isBinary = true;
/*     */     
/* 373 */     setStoreTermVector(TermVector.NO);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\Field.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.Fieldable,"package org.apache.lucene.document;
import java.io.Reader;
import java.io.Serializable;
import org.apache.lucene.analysis.TokenStream;
public interface Fieldable extends Serializable {
  void setBoost(float paramFloat);
  float getBoost();
  String name();
  String stringValue();
  Reader readerValue();
  byte[] binaryValue();
  TokenStream tokenStreamValue();
  boolean isStored();
  boolean isIndexed();
  boolean isTokenized();
  boolean isCompressed();
  boolean isTermVectorStored();
  boolean isStoreOffsetWithTermVector();
  boolean isStorePositionWithTermVector();
  boolean isBinary();
  boolean getOmitNorms();
  void setOmitNorms(boolean paramBoolean);
  boolean isLazy();
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\Fieldable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.FieldSelector,"package org.apache.lucene.document;
import java.io.Serializable;
public interface FieldSelector extends Serializable {
  FieldSelectorResult accept(String paramString);
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\FieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.FieldSelectorResult,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class FieldSelectorResult
/*    */   implements Serializable
/*    */ {
/* 33 */   public static final transient FieldSelectorResult LOAD = new FieldSelectorResult(0);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   public static final transient FieldSelectorResult LAZY_LOAD = new FieldSelectorResult(1);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 48 */   public static final transient FieldSelectorResult NO_LOAD = new FieldSelectorResult(2);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 56 */   public static final transient FieldSelectorResult LOAD_AND_BREAK = new FieldSelectorResult(3);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 63 */   public static final transient FieldSelectorResult LOAD_FOR_MERGE = new FieldSelectorResult(4);
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 69 */   public static final transient FieldSelectorResult SIZE = new FieldSelectorResult(5);
/*    */ 
/*    */   
/* 72 */   public static final transient FieldSelectorResult SIZE_AND_BREAK = new FieldSelectorResult(6);
/*    */ 
/*    */   
/*    */   private int id;
/*    */ 
/*    */ 
/*    */   
/* 79 */   private FieldSelectorResult(int id) { this.id = id; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 83 */     if (this == o) return true; 
/* 84 */     if (o == null || getClass() != o.getClass()) return false;
/*    */     
/* 86 */     FieldSelectorResult that = (FieldSelectorResult)o;
/*    */     
/* 88 */     if (this.id != that.id) return false;
/*    */     
/* 90 */     return true;
/*    */   }
/*    */ 
/*    */   
/* 94 */   public int hashCode() { return this.id; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\FieldSelectorResult.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.LoadFirstFieldSelector,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LoadFirstFieldSelector
/*    */   implements FieldSelector
/*    */ {
/* 27 */   public FieldSelectorResult accept(String fieldName) { return FieldSelectorResult.LOAD_AND_BREAK; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\LoadFirstFieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.MapFieldSelector,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ import java.util.HashMap;
/*    */ import java.util.List;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class MapFieldSelector
/*    */   implements FieldSelector
/*    */ {
/*    */   Map fieldSelections;
/*    */   
/* 37 */   public MapFieldSelector(Map fieldSelections) { this.fieldSelections = fieldSelections; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public MapFieldSelector(List fields) {
/* 44 */     this.fieldSelections = new HashMap(fields.size() * 5 / 3);
/* 45 */     for (int i = 0; i < fields.size(); i++) {
/* 46 */       this.fieldSelections.put(fields.get(i), FieldSelectorResult.LOAD);
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public MapFieldSelector(String[] fields) {
/* 53 */     this.fieldSelections = new HashMap(fields.length * 5 / 3);
/* 54 */     for (int i = 0; i < fields.length; i++) {
/* 55 */       this.fieldSelections.put(fields[i], FieldSelectorResult.LOAD);
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldSelectorResult accept(String field) {
/* 63 */     FieldSelectorResult selection = (FieldSelectorResult)this.fieldSelections.get(field);
/* 64 */     return (selection != null) ? selection : FieldSelectorResult.NO_LOAD;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\MapFieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.NumberTools,"/*     */ package org.apache.lucene.document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class NumberTools
/*     */ {
/*     */   private static final int RADIX = 36;
/*     */   private static final char NEGATIVE_PREFIX = '-';
/*     */   private static final char POSITIVE_PREFIX = '0';
/*     */   public static final String MIN_STRING_VALUE = ""-0000000000000"";
/*     */   public static final String MAX_STRING_VALUE = ""01y2p0ij32e8e7"";
/*  61 */   public static final int STR_SIZE = ""-0000000000000"".length();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static String longToString(long l) {
/*  68 */     if (l == Long.MIN_VALUE)
/*     */     {
/*  70 */       return ""-0000000000000"";
/*     */     }
/*     */     
/*  73 */     StringBuffer buf = new StringBuffer(STR_SIZE);
/*     */     
/*  75 */     if (l < 0L) {
/*  76 */       buf.append('-');
/*  77 */       l = Long.MAX_VALUE + l + 1L;
/*     */     } else {
/*  79 */       buf.append('0');
/*     */     } 
/*  81 */     String num = Long.toString(l, 36);
/*     */     
/*  83 */     int padLen = STR_SIZE - num.length() - buf.length();
/*  84 */     while (padLen-- > 0) {
/*  85 */       buf.append('0');
/*     */     }
/*  87 */     buf.append(num);
/*     */     
/*  89 */     return buf.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long stringToLong(String str) {
/* 103 */     if (str == null) {
/* 104 */       throw new NullPointerException(""string cannot be null"");
/*     */     }
/* 106 */     if (str.length() != STR_SIZE) {
/* 107 */       throw new NumberFormatException(""string is the wrong size"");
/*     */     }
/*     */     
/* 110 */     if (str.equals(""-0000000000000"")) {
/* 111 */       return Long.MIN_VALUE;
/*     */     }
/*     */     
/* 114 */     char prefix = str.charAt(0);
/* 115 */     long l = Long.parseLong(str.substring(1), 36);
/*     */     
/* 117 */     if (prefix != '0')
/*     */     {
/* 119 */       if (prefix == '-') {
/* 120 */         l = l - Long.MAX_VALUE - 1L;
/*     */       } else {
/* 122 */         throw new NumberFormatException(""string does not begin with the correct prefix"");
/*     */       } 
/*     */     }
/*     */     
/* 126 */     return l;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\NumberTools.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.document.SetBasedFieldSelector,"/*    */ package org.apache.lucene.document;
/*    */ 
/*    */ import java.util.Set;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SetBasedFieldSelector
/*    */   implements FieldSelector
/*    */ {
/*    */   private Set fieldsToLoad;
/*    */   private Set lazyFieldsToLoad;
/*    */   
/*    */   public SetBasedFieldSelector(Set fieldsToLoad, Set lazyFieldsToLoad) {
/* 38 */     this.fieldsToLoad = fieldsToLoad;
/* 39 */     this.lazyFieldsToLoad = lazyFieldsToLoad;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldSelectorResult accept(String fieldName) {
/* 51 */     FieldSelectorResult result = FieldSelectorResult.NO_LOAD;
/* 52 */     if (this.fieldsToLoad.contains(fieldName) == true) {
/* 53 */       result = FieldSelectorResult.LOAD;
/*    */     }
/* 55 */     if (this.lazyFieldsToLoad.contains(fieldName) == true) {
/* 56 */       result = FieldSelectorResult.LAZY_LOAD;
/*    */     }
/* 58 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\document\SetBasedFieldSelector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CompoundFileReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import org.apache.lucene.store.BufferedIndexInput;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.Lock;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class CompoundFileReader
/*     */   extends Directory
/*     */ {
/*     */   private int readBufferSize;
/*     */   private Directory directory;
/*     */   private String fileName;
/*     */   private IndexInput stream;
/*     */   
/*     */   private static final class FileEntry
/*     */   {
/*     */     long offset;
/*     */     long length;
/*     */     
/*     */     private FileEntry() {}
/*     */   }
/*  53 */   private HashMap entries = new HashMap();
/*     */ 
/*     */ 
/*     */   
/*  57 */   public CompoundFileReader(Directory dir, String name) throws IOException { this(dir, name, 1024); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public CompoundFileReader(Directory dir, String name, int readBufferSize) throws IOException {
/*  63 */     this.directory = dir;
/*  64 */     this.fileName = name;
/*  65 */     this.readBufferSize = readBufferSize;
/*     */     
/*  67 */     boolean success = false;
/*     */     
/*     */     try {
/*  70 */       this.stream = dir.openInput(name, readBufferSize);
/*     */ 
/*     */       
/*  73 */       int count = this.stream.readVInt();
/*  74 */       FileEntry entry = null;
/*  75 */       for (int i = 0; i < count; i++) {
/*  76 */         long offset = this.stream.readLong();
/*  77 */         String id = this.stream.readString();
/*     */         
/*  79 */         if (entry != null)
/*     */         {
/*  81 */           entry.length = offset - entry.offset;
/*     */         }
/*     */         
/*  84 */         entry = new FileEntry();
/*  85 */         entry.offset = offset;
/*  86 */         this.entries.put(id, entry);
/*     */       } 
/*     */ 
/*     */       
/*  90 */       if (entry != null) {
/*  91 */         entry.length = this.stream.length() - entry.offset;
/*     */       }
/*     */       
/*  94 */       success = true;
/*     */     } finally {
/*     */       
/*  97 */       if (!success && this.stream != null) {
/*     */         try {
/*  99 */           this.stream.close();
/* 100 */         } catch (IOException e) {}
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 106 */   public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */   
/* 110 */   public String getName() { return this.fileName; }
/*     */ 
/*     */   
/*     */   public synchronized void close() throws IOException {
/* 114 */     if (this.stream == null) {
/* 115 */       throw new IOException(""Already closed"");
/*     */     }
/* 117 */     this.entries.clear();
/* 118 */     this.stream.close();
/* 119 */     this.stream = null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public synchronized IndexInput openInput(String id) throws IOException { return openInput(id, this.readBufferSize); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized IndexInput openInput(String id, int readBufferSize) throws IOException {
/* 132 */     if (this.stream == null) {
/* 133 */       throw new IOException(""Stream closed"");
/*     */     }
/* 135 */     FileEntry entry = (FileEntry)this.entries.get(id);
/* 136 */     if (entry == null) {
/* 137 */       throw new IOException(""No sub-file with id "" + id + "" found"");
/*     */     }
/* 139 */     return (IndexInput)new CSIndexInput(this.stream, entry.offset, entry.length, readBufferSize);
/*     */   }
/*     */ 
/*     */   
/*     */   public String[] list() {
/* 144 */     String[] res = new String[this.entries.size()];
/* 145 */     return (String[])this.entries.keySet().toArray((Object[])res);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 150 */   public boolean fileExists(String name) { return this.entries.containsKey(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public long fileModified(String name) throws IOException { return this.directory.fileModified(this.fileName); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public void touchFile(String name) throws IOException { this.directory.touchFile(this.fileName); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 167 */   public void deleteFile(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 174 */   public void renameFile(String from, String to) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long fileLength(String name) throws IOException {
/* 182 */     FileEntry e = (FileEntry)this.entries.get(name);
/* 183 */     if (e == null)
/* 184 */       throw new IOException(""File "" + name + "" does not exist""); 
/* 185 */     return e.length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 192 */   public IndexOutput createOutput(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 199 */   public Lock makeLock(String name) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/*     */   static final class CSIndexInput
/*     */     extends BufferedIndexInput
/*     */   {
/*     */     IndexInput base;
/*     */ 
/*     */     
/*     */     long fileOffset;
/*     */ 
/*     */     
/*     */     long length;
/*     */ 
/*     */     
/* 215 */     CSIndexInput(IndexInput base, long fileOffset, long length) { this(base, fileOffset, length, 1024); }
/*     */ 
/*     */ 
/*     */     
/*     */     CSIndexInput(IndexInput base, long fileOffset, long length, int readBufferSize) {
/* 220 */       super(readBufferSize);
/* 221 */       this.base = base;
/* 222 */       this.fileOffset = fileOffset;
/* 223 */       this.length = length;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected void readInternal(byte[] b, int offset, int len) throws IOException {
/* 235 */       synchronized (this.base) {
/* 236 */         long start = getFilePointer();
/* 237 */         if (start + len > this.length)
/* 238 */           throw new IOException(""read past EOF""); 
/* 239 */         this.base.seek(this.fileOffset + start);
/* 240 */         this.base.readBytes(b, offset, len);
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     protected void seekInternal(long pos) {}
/*     */ 
/*     */ 
/*     */     
/*     */     public void close() {}
/*     */ 
/*     */ 
/*     */     
/* 254 */     public long length() { return this.length; }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\CompoundFileReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CompoundFileWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class CompoundFileWriter
/*     */ {
/*     */   private Directory directory;
/*     */   private String fileName;
/*     */   private HashSet ids;
/*     */   private LinkedList entries;
/*     */   
/*     */   private static final class FileEntry
/*     */   {
/*     */     String file;
/*     */     long directoryOffset;
/*     */     long dataOffset;
/*     */     
/*     */     private FileEntry() {}
/*     */   }
/*     */   private boolean merged = false;
/*     */   
/*     */   public CompoundFileWriter(Directory dir, String name) {
/*  78 */     if (dir == null)
/*  79 */       throw new NullPointerException(""directory cannot be null""); 
/*  80 */     if (name == null) {
/*  81 */       throw new NullPointerException(""name cannot be null"");
/*     */     }
/*  83 */     this.directory = dir;
/*  84 */     this.fileName = name;
/*  85 */     this.ids = new HashSet();
/*  86 */     this.entries = new LinkedList();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  91 */   public Directory getDirectory() { return this.directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   public String getName() { return this.fileName; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addFile(String file) {
/* 108 */     if (this.merged) {
/* 109 */       throw new IllegalStateException(""Can't add extensions after merge has been called"");
/*     */     }
/*     */     
/* 112 */     if (file == null) {
/* 113 */       throw new NullPointerException(""file cannot be null"");
/*     */     }
/*     */     
/* 116 */     if (!this.ids.add(file)) {
/* 117 */       throw new IllegalArgumentException(""File "" + file + "" already added"");
/*     */     }
/*     */     
/* 120 */     FileEntry entry = new FileEntry();
/* 121 */     entry.file = file;
/* 122 */     this.entries.add(entry);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 133 */     if (this.merged) {
/* 134 */       throw new IllegalStateException(""Merge already performed"");
/*     */     }
/*     */     
/* 137 */     if (this.entries.isEmpty()) {
/* 138 */       throw new IllegalStateException(""No entries to merge have been defined"");
/*     */     }
/*     */     
/* 141 */     this.merged = true;
/*     */ 
/*     */     
/* 144 */     IndexOutput os = null;
/*     */     try {
/* 146 */       os = this.directory.createOutput(this.fileName);
/*     */ 
/*     */       
/* 149 */       os.writeVInt(this.entries.size());
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 154 */       Iterator it = this.entries.iterator();
/* 155 */       while (it.hasNext()) {
/* 156 */         FileEntry fe = it.next();
/* 157 */         fe.directoryOffset = os.getFilePointer();
/* 158 */         os.writeLong(0L);
/* 159 */         os.writeString(fe.file);
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 164 */       byte[] buffer = new byte[16384];
/* 165 */       it = this.entries.iterator();
/* 166 */       while (it.hasNext()) {
/* 167 */         FileEntry fe = it.next();
/* 168 */         fe.dataOffset = os.getFilePointer();
/* 169 */         copyFile(fe, os, buffer);
/*     */       } 
/*     */ 
/*     */       
/* 173 */       it = this.entries.iterator();
/* 174 */       while (it.hasNext()) {
/* 175 */         FileEntry fe = it.next();
/* 176 */         os.seek(fe.directoryOffset);
/* 177 */         os.writeLong(fe.dataOffset);
/*     */       } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 184 */       IndexOutput tmp = os;
/* 185 */       os = null;
/* 186 */       tmp.close();
/*     */     } finally {
/*     */       
/* 189 */       if (os != null) try { os.close(); } catch (IOException e) {}
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void copyFile(FileEntry source, IndexOutput os, byte[] buffer) throws IOException {
/* 200 */     IndexInput is = null;
/*     */     try {
/* 202 */       long startPtr = os.getFilePointer();
/*     */       
/* 204 */       is = this.directory.openInput(source.file);
/* 205 */       long length = is.length();
/* 206 */       long remainder = length;
/* 207 */       int chunk = buffer.length;
/*     */       
/* 209 */       while (remainder > 0L) {
/* 210 */         int len = (int)Math.min(chunk, remainder);
/* 211 */         is.readBytes(buffer, 0, len);
/* 212 */         os.writeBytes(buffer, len);
/* 213 */         remainder -= len;
/*     */       } 
/*     */ 
/*     */       
/* 217 */       if (remainder != 0L) {
/* 218 */         throw new IOException(""Non-zero remainder length after copying: "" + remainder + "" (id: "" + source.file + "", length: "" + length + "", buffer size: "" + chunk + "")"");
/*     */       }
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 224 */       long endPtr = os.getFilePointer();
/* 225 */       long diff = endPtr - startPtr;
/* 226 */       if (diff != length) {
/* 227 */         throw new IOException(""Difference in the output file offsets "" + diff + "" does not match the original file length "" + length);
/*     */       }
/*     */     }
/*     */     finally {
/*     */       
/* 232 */       if (is != null) is.close(); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\CompoundFileWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.CorruptIndexException,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CorruptIndexException
/*    */   extends IOException
/*    */ {
/* 28 */   public CorruptIndexException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\CorruptIndexException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DefaultSkipListReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DefaultSkipListReader
/*     */   extends MultiLevelSkipListReader
/*     */ {
/*     */   private boolean currentFieldStoresPayloads;
/*     */   private long[] freqPointer;
/*     */   private long[] proxPointer;
/*     */   private int[] payloadLength;
/*     */   private long lastFreqPointer;
/*     */   private long lastProxPointer;
/*     */   private int lastPayloadLength;
/*     */   
/*     */   DefaultSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval) {
/*  42 */     super(skipStream, maxSkipLevels, skipInterval);
/*  43 */     this.freqPointer = new long[maxSkipLevels];
/*  44 */     this.proxPointer = new long[maxSkipLevels];
/*  45 */     this.payloadLength = new int[maxSkipLevels];
/*     */   }
/*     */   
/*     */   void init(long skipPointer, long freqBasePointer, long proxBasePointer, int df, boolean storesPayloads) {
/*  49 */     init(skipPointer, df);
/*  50 */     this.currentFieldStoresPayloads = storesPayloads;
/*  51 */     this.lastFreqPointer = freqBasePointer;
/*  52 */     this.lastProxPointer = proxBasePointer;
/*     */     
/*  54 */     Arrays.fill(this.freqPointer, freqBasePointer);
/*  55 */     Arrays.fill(this.proxPointer, proxBasePointer);
/*  56 */     Arrays.fill(this.payloadLength, 0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  62 */   long getFreqPointer() { return this.lastFreqPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   long getProxPointer() { return this.lastProxPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  75 */   int getPayloadLength() { return this.lastPayloadLength; }
/*     */ 
/*     */   
/*     */   protected void seekChild(int level) throws IOException {
/*  79 */     super.seekChild(level);
/*  80 */     this.freqPointer[level] = this.lastFreqPointer;
/*  81 */     this.proxPointer[level] = this.lastProxPointer;
/*  82 */     this.payloadLength[level] = this.lastPayloadLength;
/*     */   }
/*     */   
/*     */   protected void setLastSkipData(int level) {
/*  86 */     super.setLastSkipData(level);
/*  87 */     this.lastFreqPointer = this.freqPointer[level];
/*  88 */     this.lastProxPointer = this.proxPointer[level];
/*  89 */     this.lastPayloadLength = this.payloadLength[level];
/*     */   }
/*     */ 
/*     */   
/*     */   protected int readSkipData(int level, IndexInput skipStream) throws IOException {
/*     */     int delta;
/*  95 */     if (this.currentFieldStoresPayloads) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 101 */       delta = skipStream.readVInt();
/* 102 */       if ((delta & 0x1) != 0) {
/* 103 */         this.payloadLength[level] = skipStream.readVInt();
/*     */       }
/* 105 */       delta >>>= 1;
/*     */     } else {
/* 107 */       delta = skipStream.readVInt();
/*     */     } 
/* 109 */     this.freqPointer[level] = this.freqPointer[level] + skipStream.readVInt();
/* 110 */     this.proxPointer[level] = this.proxPointer[level] + skipStream.readVInt();
/*     */     
/* 112 */     return delta;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\DefaultSkipListReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DefaultSkipListWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DefaultSkipListWriter
/*     */   extends MultiLevelSkipListWriter
/*     */ {
/*     */   private int[] lastSkipDoc;
/*     */   private int[] lastSkipPayloadLength;
/*     */   private long[] lastSkipFreqPointer;
/*     */   private long[] lastSkipProxPointer;
/*     */   private IndexOutput freqOutput;
/*     */   private IndexOutput proxOutput;
/*     */   private int curDoc;
/*     */   private boolean curStorePayloads;
/*     */   private int curPayloadLength;
/*     */   private long curFreqPointer;
/*     */   private long curProxPointer;
/*     */   
/*     */   DefaultSkipListWriter(int skipInterval, int numberOfSkipLevels, int docCount, IndexOutput freqOutput, IndexOutput proxOutput) {
/*  47 */     super(skipInterval, numberOfSkipLevels, docCount);
/*  48 */     this.freqOutput = freqOutput;
/*  49 */     this.proxOutput = proxOutput;
/*     */     
/*  51 */     this.lastSkipDoc = new int[numberOfSkipLevels];
/*  52 */     this.lastSkipPayloadLength = new int[numberOfSkipLevels];
/*  53 */     this.lastSkipFreqPointer = new long[numberOfSkipLevels];
/*  54 */     this.lastSkipProxPointer = new long[numberOfSkipLevels];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setSkipData(int doc, boolean storePayloads, int payloadLength) {
/*  61 */     this.curDoc = doc;
/*  62 */     this.curStorePayloads = storePayloads;
/*  63 */     this.curPayloadLength = payloadLength;
/*  64 */     this.curFreqPointer = this.freqOutput.getFilePointer();
/*  65 */     this.curProxPointer = this.proxOutput.getFilePointer();
/*     */   }
/*     */   
/*     */   protected void resetSkip() {
/*  69 */     super.resetSkip();
/*  70 */     Arrays.fill(this.lastSkipDoc, 0);
/*  71 */     Arrays.fill(this.lastSkipPayloadLength, -1);
/*  72 */     Arrays.fill(this.lastSkipFreqPointer, this.freqOutput.getFilePointer());
/*  73 */     Arrays.fill(this.lastSkipProxPointer, this.proxOutput.getFilePointer());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void writeSkipData(int level, IndexOutput skipBuffer) throws IOException {
/*  97 */     if (this.curStorePayloads) {
/*  98 */       int delta = this.curDoc - this.lastSkipDoc[level];
/*  99 */       if (this.curPayloadLength == this.lastSkipPayloadLength[level]) {
/*     */ 
/*     */         
/* 102 */         skipBuffer.writeVInt(delta * 2);
/*     */       }
/*     */       else {
/*     */         
/* 106 */         skipBuffer.writeVInt(delta * 2 + 1);
/* 107 */         skipBuffer.writeVInt(this.curPayloadLength);
/* 108 */         this.lastSkipPayloadLength[level] = this.curPayloadLength;
/*     */       } 
/*     */     } else {
/*     */       
/* 112 */       skipBuffer.writeVInt(this.curDoc - this.lastSkipDoc[level]);
/*     */     } 
/* 114 */     skipBuffer.writeVInt((int)(this.curFreqPointer - this.lastSkipFreqPointer[level]));
/* 115 */     skipBuffer.writeVInt((int)(this.curProxPointer - this.lastSkipProxPointer[level]));
/*     */     
/* 117 */     this.lastSkipDoc[level] = this.curDoc;
/*     */ 
/*     */     
/* 120 */     this.lastSkipFreqPointer[level] = this.curFreqPointer;
/* 121 */     this.lastSkipProxPointer[level] = this.curProxPointer;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\DefaultSkipListWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.DocumentWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.io.Reader;
/*     */ import java.io.StringReader;
/*     */ import java.util.Arrays;
/*     */ import java.util.BitSet;
/*     */ import java.util.Enumeration;
/*     */ import java.util.Hashtable;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class DocumentWriter
/*     */ {
/*     */   private Analyzer analyzer;
/*     */   private Directory directory;
/*     */   private Similarity similarity;
/*     */   private FieldInfos fieldInfos;
/*     */   private int maxFieldLength;
/*  47 */   private int termIndexInterval = 128;
/*     */ 
/*     */   
/*     */   private PrintStream infoStream;
/*     */ 
/*     */   
/*     */   private final Hashtable postingTable;
/*     */ 
/*     */   
/*     */   private int[] fieldLengths;
/*     */ 
/*     */   
/*     */   private int[] fieldPositions;
/*     */ 
/*     */   
/*     */   private int[] fieldOffsets;
/*     */ 
/*     */   
/*     */   private float[] fieldBoosts;
/*     */ 
/*     */   
/*     */   private BitSet fieldStoresPayloads;
/*     */   
/*     */   private List openTokenStreams;
/*     */   
/*     */   private final Term termBuffer;
/*     */ 
/*     */   
/*     */   final void addDocument(String segment, Document doc) throws CorruptIndexException, IOException {
/*  76 */     this.fieldInfos = new FieldInfos();
/*  77 */     this.fieldInfos.add(doc);
/*     */ 
/*     */     
/*  80 */     this.postingTable.clear();
/*  81 */     this.fieldLengths = new int[this.fieldInfos.size()];
/*  82 */     this.fieldPositions = new int[this.fieldInfos.size()];
/*  83 */     this.fieldOffsets = new int[this.fieldInfos.size()];
/*  84 */     this.fieldStoresPayloads = new BitSet(this.fieldInfos.size());
/*     */     
/*  86 */     this.fieldBoosts = new float[this.fieldInfos.size()];
/*  87 */     Arrays.fill(this.fieldBoosts, doc.getBoost());
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/*  95 */       invertDocument(doc);
/*     */ 
/*     */       
/*  98 */       Posting[] postings = sortPostingTable();
/*     */ 
/*     */       
/* 101 */       this.fieldInfos.write(this.directory, segment + "".fnm"");
/*     */ 
/*     */       
/* 104 */       FieldsWriter fieldsWriter = new FieldsWriter(this.directory, segment, this.fieldInfos);
/*     */       
/*     */       try {
/* 107 */         fieldsWriter.addDocument(doc);
/*     */       } finally {
/* 109 */         fieldsWriter.close();
/*     */       } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 126 */       writePostings(postings, segment);
/*     */ 
/*     */       
/* 129 */       writeNorms(segment);
/*     */     } finally {
/*     */       
/* 132 */       IOException ex = null;
/*     */       
/* 134 */       Iterator it = this.openTokenStreams.iterator();
/* 135 */       while (it.hasNext()) {
/*     */         try {
/* 137 */           ((TokenStream)it.next()).close();
/* 138 */         } catch (IOException e) {
/* 139 */           if (ex != null) {
/* 140 */             ex = e;
/*     */           }
/*     */         } 
/*     */       } 
/* 144 */       this.openTokenStreams.clear();
/*     */       
/* 146 */       if (ex != null) {
/* 147 */         throw ex;
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   DocumentWriter(Directory directory, Analyzer analyzer, Similarity similarity, int maxFieldLength)
/*     */   {
/* 154 */     this.postingTable = new Hashtable();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 166 */     this.openTokenStreams = new LinkedList();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 261 */     this.termBuffer = new Term("""", """"); this.directory = directory; this.analyzer = analyzer; this.similarity = similarity; this.maxFieldLength = maxFieldLength; } DocumentWriter(Directory directory, Analyzer analyzer, IndexWriter writer) { this.postingTable = new Hashtable(); this.openTokenStreams = new LinkedList(); this.termBuffer = new Term("""", """"); this.directory = directory; this.analyzer = analyzer;
/*     */     this.similarity = writer.getSimilarity();
/*     */     this.maxFieldLength = writer.getMaxFieldLength();
/* 264 */     this.termIndexInterval = writer.getTermIndexInterval(); } private final void addPosition(String field, String text, int position, Payload payload, TermVectorOffsetInfo offset) { this.termBuffer.set(field, text);
/*     */     
/* 266 */     Posting ti = (Posting)this.postingTable.get(this.termBuffer);
/* 267 */     if (ti != null) {
/* 268 */       int freq = ti.freq;
/* 269 */       if (ti.positions.length == freq) {
/* 270 */         int[] newPositions = new int[freq * 2];
/* 271 */         int[] positions = ti.positions;
/* 272 */         System.arraycopy(positions, 0, newPositions, 0, freq);
/* 273 */         ti.positions = newPositions;
/*     */         
/* 275 */         if (ti.payloads != null) {
/*     */           
/* 277 */           Payload[] newPayloads = new Payload[freq * 2];
/* 278 */           Payload[] payloads = ti.payloads;
/* 279 */           System.arraycopy(payloads, 0, newPayloads, 0, payloads.length);
/* 280 */           ti.payloads = newPayloads;
/*     */         } 
/*     */       } 
/* 283 */       ti.positions[freq] = position;
/*     */       
/* 285 */       if (payload != null) {
/* 286 */         if (ti.payloads == null)
/*     */         {
/* 288 */           ti.payloads = new Payload[ti.positions.length];
/*     */         }
/* 290 */         ti.payloads[freq] = payload;
/*     */       } 
/*     */       
/* 293 */       if (offset != null) {
/* 294 */         if (ti.offsets.length == freq) {
/* 295 */           TermVectorOffsetInfo[] newOffsets = new TermVectorOffsetInfo[freq * 2];
/* 296 */           TermVectorOffsetInfo[] offsets = ti.offsets;
/* 297 */           System.arraycopy(offsets, 0, newOffsets, 0, freq);
/* 298 */           ti.offsets = newOffsets;
/*     */         } 
/* 300 */         ti.offsets[freq] = offset;
/*     */       } 
/* 302 */       ti.freq = freq + 1;
/*     */     } else {
/* 304 */       Term term = new Term(field, text, false);
/* 305 */       this.postingTable.put(term, new Posting(term, position, payload, offset));
/*     */     }  }
/*     */ 
/*     */ 
/*     */   
/*     */   private final Posting[] sortPostingTable() {
/* 311 */     Posting[] array = new Posting[this.postingTable.size()];
/* 312 */     Enumeration postings = this.postingTable.elements();
/* 313 */     for (int i = 0; postings.hasMoreElements(); i++) {
/* 314 */       array[i] = postings.nextElement();
/*     */     }
/*     */     
/* 317 */     quickSort(array, 0, array.length - 1);
/*     */     
/* 319 */     return array; }
/*     */   private final void invertDocument(Document doc) throws IOException { Iterator fieldIterator = doc.getFields().iterator(); while (fieldIterator.hasNext()) { Fieldable field = fieldIterator.next(); String fieldName = field.name(); int fieldNumber = this.fieldInfos.fieldNumber(fieldName); int length = this.fieldLengths[fieldNumber]; int position = this.fieldPositions[fieldNumber]; if (length > 0) position += this.analyzer.getPositionIncrementGap(fieldName);  int offset = this.fieldOffsets[fieldNumber]; if (field.isIndexed()) { if (!field.isTokenized()) { String stringValue = field.stringValue(); if (field.isStoreOffsetWithTermVector()) { addPosition(fieldName, stringValue, position++, null, new TermVectorOffsetInfo(offset, offset + stringValue.length())); } else { addPosition(fieldName, stringValue, position++, null, null); }  offset += stringValue.length(); length++; } else { TokenStream stream = field.tokenStreamValue(); if (stream == null) { Reader reader; if (field.readerValue() != null) { reader = field.readerValue(); } else if (field.stringValue() != null) { reader = new StringReader(field.stringValue()); } else { throw new IllegalArgumentException(""field must have either String or Reader value""); }  stream = this.analyzer.tokenStream(fieldName, reader); }  this.openTokenStreams.add(stream); stream.reset(); Token lastToken = null; for (Token t = stream.next(); t != null; t = stream.next()) { TermVectorOffsetInfo termVectorOffsetInfo; position += t.getPositionIncrement() - 1; Payload payload = t.getPayload(); if (payload != null) this.fieldStoresPayloads.set(fieldNumber);  if (field.isStoreOffsetWithTermVector()) { termVectorOffsetInfo = new TermVectorOffsetInfo(offset + t.startOffset(), offset + t.endOffset()); } else { termVectorOffsetInfo = null; }  addPosition(fieldName, t.termText(), position++, payload, termVectorOffsetInfo); lastToken = t; if (++length >= this.maxFieldLength) { if (this.infoStream != null)
/*     */                 this.infoStream.println(""maxFieldLength "" + this.maxFieldLength + "" reached, ignoring following tokens"");  break; }  }  if (lastToken != null)
/*     */             offset += lastToken.endOffset() + 1;  }  this.fieldLengths[fieldNumber] = length; this.fieldPositions[fieldNumber] = position; this.fieldBoosts[fieldNumber] = this.fieldBoosts[fieldNumber] * field.getBoost(); this.fieldOffsets[fieldNumber] = offset; }  }  for (int i = this.fieldStoresPayloads.nextSetBit(0); i >= 0; i = this.fieldStoresPayloads.nextSetBit(i + 1))
/* 323 */       (this.fieldInfos.fieldInfo(i)).storePayloads = true;  } private static final void quickSort(Posting[] postings, int lo, int hi) { if (lo >= hi) {
/*     */       return;
/*     */     }
/* 326 */     int mid = (lo + hi) / 2;
/*     */     
/* 328 */     if ((postings[lo]).term.compareTo((postings[mid]).term) > 0) {
/* 329 */       Posting tmp = postings[lo];
/* 330 */       postings[lo] = postings[mid];
/* 331 */       postings[mid] = tmp;
/*     */     } 
/*     */     
/* 334 */     if ((postings[mid]).term.compareTo((postings[hi]).term) > 0) {
/* 335 */       Posting tmp = postings[mid];
/* 336 */       postings[mid] = postings[hi];
/* 337 */       postings[hi] = tmp;
/*     */       
/* 339 */       if ((postings[lo]).term.compareTo((postings[mid]).term) > 0) {
/* 340 */         Posting tmp2 = postings[lo];
/* 341 */         postings[lo] = postings[mid];
/* 342 */         postings[mid] = tmp2;
/*     */       } 
/*     */     } 
/*     */     
/* 346 */     int left = lo + 1;
/* 347 */     int right = hi - 1;
/*     */     
/* 349 */     if (left >= right) {
/*     */       return;
/*     */     }
/* 352 */     Term partition = (postings[mid]).term;
/*     */     
/*     */     while (true) {
/* 355 */       while ((postings[right]).term.compareTo(partition) > 0) {
/* 356 */         right--;
/*     */       }
/* 358 */       while (left < right && (postings[left]).term.compareTo(partition) <= 0) {
/* 359 */         left++;
/*     */       }
/* 361 */       if (left < right) {
/* 362 */         Posting tmp = postings[left];
/* 363 */         postings[left] = postings[right];
/* 364 */         postings[right] = tmp;
/* 365 */         right--;
/*     */         
/*     */         continue;
/*     */       } 
/*     */       break;
/*     */     } 
/* 371 */     quickSort(postings, lo, left);
/* 372 */     quickSort(postings, left + 1, hi); }
/*     */ 
/*     */ 
/*     */   
/*     */   private final void writePostings(Posting[] postings, String segment) throws CorruptIndexException, IOException {
/* 377 */     IndexOutput freq = null, prox = null;
/* 378 */     TermInfosWriter tis = null;
/* 379 */     TermVectorsWriter termVectorWriter = null;
/*     */     
/*     */     try {
/* 382 */       freq = this.directory.createOutput(segment + "".frq"");
/* 383 */       prox = this.directory.createOutput(segment + "".prx"");
/* 384 */       tis = new TermInfosWriter(this.directory, segment, this.fieldInfos, this.termIndexInterval);
/*     */       
/* 386 */       TermInfo ti = new TermInfo();
/* 387 */       String currentField = null;
/* 388 */       boolean currentFieldHasPayloads = false;
/*     */       
/* 390 */       for (int i = 0; i < postings.length; i++) {
/* 391 */         Posting posting = postings[i];
/*     */ 
/*     */         
/* 394 */         String termField = posting.term.field();
/* 395 */         if (currentField != termField) {
/*     */           
/* 397 */           currentField = termField;
/* 398 */           FieldInfo fi = this.fieldInfos.fieldInfo(currentField);
/* 399 */           currentFieldHasPayloads = fi.storePayloads;
/* 400 */           if (fi.storeTermVector) {
/* 401 */             if (termVectorWriter == null) {
/* 402 */               termVectorWriter = new TermVectorsWriter(this.directory, segment, this.fieldInfos);
/*     */               
/* 404 */               termVectorWriter.openDocument();
/*     */             } 
/* 406 */             termVectorWriter.openField(currentField);
/*     */           }
/* 408 */           else if (termVectorWriter != null) {
/* 409 */             termVectorWriter.closeField();
/*     */           } 
/*     */         } 
/*     */ 
/*     */         
/* 414 */         ti.set(1, freq.getFilePointer(), prox.getFilePointer(), -1);
/* 415 */         tis.add(posting.term, ti);
/*     */ 
/*     */         
/* 418 */         int postingFreq = posting.freq;
/* 419 */         if (postingFreq == 1) {
/* 420 */           freq.writeVInt(1);
/*     */         } else {
/* 422 */           freq.writeVInt(0);
/* 423 */           freq.writeVInt(postingFreq);
/*     */         } 
/*     */         
/* 426 */         int lastPosition = 0;
/* 427 */         int[] positions = posting.positions;
/* 428 */         Payload[] payloads = posting.payloads;
/* 429 */         int lastPayloadLength = -1;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 450 */         for (int j = 0; j < postingFreq; j++) {
/* 451 */           int position = positions[j];
/* 452 */           int delta = position - lastPosition;
/* 453 */           if (currentFieldHasPayloads) {
/* 454 */             int payloadLength = 0;
/* 455 */             Payload payload = null;
/* 456 */             if (payloads != null) {
/* 457 */               payload = payloads[j];
/* 458 */               if (payload != null) {
/* 459 */                 payloadLength = payload.length;
/*     */               }
/*     */             } 
/* 462 */             if (payloadLength == lastPayloadLength) {
/*     */ 
/*     */ 
/*     */               
/* 466 */               prox.writeVInt(delta * 2);
/*     */             
/*     */             }
/*     */             else {
/*     */               
/* 471 */               prox.writeVInt(delta * 2 + 1);
/* 472 */               prox.writeVInt(payloadLength);
/* 473 */               lastPayloadLength = payloadLength;
/*     */             } 
/* 475 */             if (payloadLength > 0)
/*     */             {
/* 477 */               prox.writeBytes(payload.data, payload.offset, payload.length);
/*     */             }
/*     */           } else {
/*     */             
/* 481 */             prox.writeVInt(delta);
/*     */           } 
/* 483 */           lastPosition = position;
/*     */         } 
/* 485 */         if (termVectorWriter != null && termVectorWriter.isFieldOpen()) {
/* 486 */           termVectorWriter.addTerm(posting.term.text(), postingFreq, posting.positions, posting.offsets);
/*     */         }
/*     */       } 
/* 489 */       if (termVectorWriter != null) {
/* 490 */         termVectorWriter.closeDocument();
/*     */       }
/*     */     } finally {
/*     */       
/* 494 */       IOException keep = null;
/* 495 */       if (freq != null) try { freq.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 496 */           if (prox != null) try { prox.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 497 */           if (tis != null) try { tis.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 498 */           if (termVectorWriter != null) try { termVectorWriter.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/* 499 */           if (keep != null) throw (IOException)keep.fillInStackTrace(); 
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void writeNorms(String segment) throws IOException {
/* 504 */     for (int n = 0; n < this.fieldInfos.size(); n++) {
/* 505 */       FieldInfo fi = this.fieldInfos.fieldInfo(n);
/* 506 */       if (fi.isIndexed && !fi.omitNorms) {
/* 507 */         float norm = this.fieldBoosts[n] * this.similarity.lengthNorm(fi.name, this.fieldLengths[n]);
/* 508 */         IndexOutput norms = this.directory.createOutput(segment + "".f"" + n);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 521 */   void setInfoStream(PrintStream infoStream) { this.infoStream = infoStream; }
/*     */ 
/*     */ 
/*     */   
/* 525 */   int getNumFields() { return this.fieldInfos.size(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\DocumentWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class FieldInfo
/*    */ {
/*    */   String name;
/*    */   boolean isIndexed;
/*    */   int number;
/*    */   boolean storeTermVector;
/*    */   boolean storeOffsetWithTermVector;
/*    */   boolean storePositionWithTermVector;
/*    */   boolean omitNorms;
/*    */   boolean storePayloads;
/*    */   
/*    */   FieldInfo(String na, boolean tk, int nu, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads) {
/* 37 */     this.name = na;
/* 38 */     this.isIndexed = tk;
/* 39 */     this.number = nu;
/* 40 */     this.storeTermVector = storeTermVector;
/* 41 */     this.storeOffsetWithTermVector = storeOffsetWithTermVector;
/* 42 */     this.storePositionWithTermVector = storePositionWithTermVector;
/* 43 */     this.omitNorms = omitNorms;
/* 44 */     this.storePayloads = storePayloads;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\FieldInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldInfos,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldInfos
/*     */ {
/*     */   static final byte IS_INDEXED = 1;
/*     */   static final byte STORE_TERMVECTOR = 2;
/*     */   static final byte STORE_POSITIONS_WITH_TERMVECTOR = 4;
/*     */   static final byte STORE_OFFSET_WITH_TERMVECTOR = 8;
/*     */   static final byte OMIT_NORMS = 16;
/*     */   static final byte STORE_PAYLOADS = 32;
/*  44 */   private ArrayList byNumber = new ArrayList();
/*  45 */   private HashMap byName = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldInfos() {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldInfos(Directory d, String name) throws IOException {
/*  57 */     IndexInput input = d.openInput(name);
/*     */     try {
/*  59 */       read(input);
/*     */     } finally {
/*  61 */       input.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public void add(Document doc) {
/*  67 */     List fields = doc.getFields();
/*  68 */     Iterator fieldIterator = fields.iterator();
/*  69 */     while (fieldIterator.hasNext()) {
/*  70 */       Fieldable field = fieldIterator.next();
/*  71 */       add(field.name(), field.isIndexed(), field.isTermVectorStored(), field.isStorePositionWithTermVector(), field.isStoreOffsetWithTermVector(), field.getOmitNorms());
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addIndexed(Collection names, boolean storeTermVectors, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) {
/*  86 */     Iterator i = names.iterator();
/*  87 */     while (i.hasNext()) {
/*  88 */       add(i.next(), true, storeTermVectors, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Collection names, boolean isIndexed) {
/* 101 */     Iterator i = names.iterator();
/* 102 */     while (i.hasNext()) {
/* 103 */       add(i.next(), isIndexed);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public void add(String name, boolean isIndexed) { add(name, isIndexed, false, false, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 126 */   public void add(String name, boolean isIndexed, boolean storeTermVector) { add(name, isIndexed, storeTermVector, false, false, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 143 */   public void add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) { add(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public void add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms) { add(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FieldInfo add(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads) {
/* 180 */     FieldInfo fi = fieldInfo(name);
/* 181 */     if (fi == null) {
/* 182 */       return addInternal(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads);
/*     */     }
/* 184 */     if (fi.isIndexed != isIndexed) {
/* 185 */       fi.isIndexed = true;
/*     */     }
/* 187 */     if (fi.storeTermVector != storeTermVector) {
/* 188 */       fi.storeTermVector = true;
/*     */     }
/* 190 */     if (fi.storePositionWithTermVector != storePositionWithTermVector) {
/* 191 */       fi.storePositionWithTermVector = true;
/*     */     }
/* 193 */     if (fi.storeOffsetWithTermVector != storeOffsetWithTermVector) {
/* 194 */       fi.storeOffsetWithTermVector = true;
/*     */     }
/* 196 */     if (fi.omitNorms != omitNorms) {
/* 197 */       fi.omitNorms = false;
/*     */     }
/* 199 */     if (fi.storePayloads != storePayloads) {
/* 200 */       fi.storePayloads = true;
/*     */     }
/*     */ 
/*     */     
/* 204 */     return fi;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private FieldInfo addInternal(String name, boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads) {
/* 210 */     FieldInfo fi = new FieldInfo(name, isIndexed, this.byNumber.size(), storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads);
/*     */ 
/*     */     
/* 213 */     this.byNumber.add(fi);
/* 214 */     this.byName.put(name, fi);
/* 215 */     return fi;
/*     */   }
/*     */   
/*     */   public int fieldNumber(String fieldName) {
/*     */     try {
/* 220 */       FieldInfo fi = fieldInfo(fieldName);
/* 221 */       if (fi != null) {
/* 222 */         return fi.number;
/*     */       }
/* 224 */     } catch (IndexOutOfBoundsException ioobe) {
/* 225 */       return -1;
/*     */     } 
/* 227 */     return -1;
/*     */   }
/*     */ 
/*     */   
/* 231 */   public FieldInfo fieldInfo(String fieldName) { return (FieldInfo)this.byName.get(fieldName); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String fieldName(int fieldNumber) {
/*     */     try {
/* 243 */       return (fieldInfo(fieldNumber)).name;
/*     */     }
/* 245 */     catch (NullPointerException npe) {
/* 246 */       return """";
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FieldInfo fieldInfo(int fieldNumber) {
/*     */     try {
/* 258 */       return this.byNumber.get(fieldNumber);
/*     */     }
/* 260 */     catch (IndexOutOfBoundsException ioobe) {
/* 261 */       return null;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 266 */   public int size() { return this.byNumber.size(); }
/*     */ 
/*     */   
/*     */   public boolean hasVectors() {
/* 270 */     boolean hasVectors = false;
/* 271 */     for (int i = 0; i < size(); i++) {
/* 272 */       if ((fieldInfo(i)).storeTermVector) {
/* 273 */         hasVectors = true;
/*     */         break;
/*     */       } 
/*     */     } 
/* 277 */     return hasVectors;
/*     */   }
/*     */   
/*     */   public void write(Directory d, String name) throws IOException {
/* 281 */     IndexOutput output = d.createOutput(name);
/*     */     try {
/* 283 */       write(output);
/*     */     } finally {
/* 285 */       output.close();
/*     */     } 
/*     */   }
/*     */   
/*     */   public void write(IndexOutput output) throws IOException {
/* 290 */     output.writeVInt(size());
/* 291 */     for (int i = 0; i < size(); i++) {
/* 292 */       FieldInfo fi = fieldInfo(i);
/* 293 */       byte bits = 0;
/* 294 */       if (fi.isIndexed) bits = (byte)(bits | 0x1); 
/* 295 */       if (fi.storeTermVector) bits = (byte)(bits | 0x2); 
/* 296 */       if (fi.storePositionWithTermVector) bits = (byte)(bits | 0x4); 
/* 297 */       if (fi.storeOffsetWithTermVector) bits = (byte)(bits | 0x8); 
/* 298 */       if (fi.omitNorms) bits = (byte)(bits | 0x10); 
/* 299 */       if (fi.storePayloads) bits = (byte)(bits | 0x20); 
/* 300 */       output.writeString(fi.name);
/* 301 */       output.writeByte(bits);
/*     */     } 
/*     */   }
/*     */   
/*     */   private void read(IndexInput input) throws IOException {
/* 306 */     int size = input.readVInt();
/* 307 */     for (int i = 0; i < size; i++) {
/* 308 */       String name = input.readString().intern();
/* 309 */       byte bits = input.readByte();
/* 310 */       boolean isIndexed = ((bits & 0x1) != 0);
/* 311 */       boolean storeTermVector = ((bits & 0x2) != 0);
/* 312 */       boolean storePositionsWithTermVector = ((bits & 0x4) != 0);
/* 313 */       boolean storeOffsetWithTermVector = ((bits & 0x8) != 0);
/* 314 */       boolean omitNorms = ((bits & 0x10) != 0);
/* 315 */       boolean storePayloads = ((bits & 0x20) != 0);
/*     */       
/* 317 */       addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\FieldInfos.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldReaderException,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FieldReaderException
/*    */   extends RuntimeException
/*    */ {
/*    */   public FieldReaderException() {}
/*    */   
/* 47 */   public FieldReaderException(Throwable cause) { super(cause); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public FieldReaderException(String message) { super(message); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 77 */   public FieldReaderException(String message, Throwable cause) { super(message, cause); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\FieldReaderException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldsReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.ByteArrayOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ import java.util.zip.DataFormatException;
/*     */ import java.util.zip.Inflater;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.document.AbstractField;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Field;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.document.FieldSelectorResult;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.store.AlreadyClosedException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldsReader
/*     */ {
/*     */   private final FieldInfos fieldInfos;
/*     */   private final IndexInput cloneableFieldsStream;
/*     */   private final IndexInput fieldsStream;
/*     */   private final IndexInput indexStream;
/*     */   private int size;
/*     */   private boolean closed;
/*  54 */   private ThreadLocal fieldsStreamTL = new ThreadLocal();
/*     */ 
/*     */   
/*  57 */   FieldsReader(Directory d, String segment, FieldInfos fn) throws IOException { this(d, segment, fn, 1024); }
/*     */ 
/*     */   
/*     */   FieldsReader(Directory d, String segment, FieldInfos fn, int readBufferSize) throws IOException {
/*  61 */     this.fieldInfos = fn;
/*     */     
/*  63 */     this.cloneableFieldsStream = d.openInput(segment + "".fdt"", readBufferSize);
/*  64 */     this.fieldsStream = (IndexInput)this.cloneableFieldsStream.clone();
/*  65 */     this.indexStream = d.openInput(segment + "".fdx"", readBufferSize);
/*  66 */     this.size = (int)(this.indexStream.length() / 8L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final void ensureOpen() throws AlreadyClosedException {
/*  73 */     if (this.closed) {
/*  74 */       throw new AlreadyClosedException(""this FieldsReader is closed"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/*  85 */     if (!this.closed) {
/*  86 */       this.fieldsStream.close();
/*  87 */       this.cloneableFieldsStream.close();
/*  88 */       this.indexStream.close();
/*  89 */       IndexInput localFieldsStream = this.fieldsStreamTL.get();
/*  90 */       if (localFieldsStream != null) {
/*  91 */         localFieldsStream.close();
/*  92 */         this.fieldsStreamTL.set(null);
/*     */       } 
/*  94 */       this.closed = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*  99 */   final int size() { return this.size; }
/*     */ 
/*     */   
/*     */   final Document doc(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 103 */     this.indexStream.seek(n * 8L);
/* 104 */     long position = this.indexStream.readLong();
/* 105 */     this.fieldsStream.seek(position);
/*     */     
/* 107 */     Document doc = new Document();
/* 108 */     int numFields = this.fieldsStream.readVInt();
/* 109 */     for (int i = 0; i < numFields; i++) {
/* 110 */       int fieldNumber = this.fieldsStream.readVInt();
/* 111 */       FieldInfo fi = this.fieldInfos.fieldInfo(fieldNumber);
/* 112 */       FieldSelectorResult acceptField = (fieldSelector == null) ? FieldSelectorResult.LOAD : fieldSelector.accept(fi.name);
/*     */       
/* 114 */       byte bits = this.fieldsStream.readByte();
/* 115 */       boolean compressed = ((bits & 0x4) != 0);
/* 116 */       boolean tokenize = ((bits & 0x1) != 0);
/* 117 */       boolean binary = ((bits & 0x2) != 0);
/*     */ 
/*     */       
/* 120 */       if (acceptField.equals(FieldSelectorResult.LOAD)) {
/* 121 */         addField(doc, fi, binary, compressed, tokenize);
/*     */       }
/* 123 */       else if (acceptField.equals(FieldSelectorResult.LOAD_FOR_MERGE)) {
/* 124 */         addFieldForMerge(doc, fi, binary, compressed, tokenize);
/*     */       } else {
/* 126 */         if (acceptField.equals(FieldSelectorResult.LOAD_AND_BREAK)) {
/* 127 */           addField(doc, fi, binary, compressed, tokenize);
/*     */           break;
/*     */         } 
/* 130 */         if (acceptField.equals(FieldSelectorResult.LAZY_LOAD)) {
/* 131 */           addFieldLazy(doc, fi, binary, compressed, tokenize);
/*     */         }
/* 133 */         else if (acceptField.equals(FieldSelectorResult.SIZE)) {
/* 134 */           skipField(binary, compressed, addFieldSize(doc, fi, binary, compressed));
/*     */         } else {
/* 136 */           if (acceptField.equals(FieldSelectorResult.SIZE_AND_BREAK)) {
/* 137 */             addFieldSize(doc, fi, binary, compressed);
/*     */             
/*     */             break;
/*     */           } 
/* 141 */           skipField(binary, compressed);
/*     */         } 
/*     */       } 
/*     */     } 
/* 145 */     return doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 153 */   private void skipField(boolean binary, boolean compressed) throws IOException { skipField(binary, compressed, this.fieldsStream.readVInt()); }
/*     */ 
/*     */   
/*     */   private void skipField(boolean binary, boolean compressed, int toRead) throws IOException {
/* 157 */     if (binary || compressed) {
/* 158 */       long pointer = this.fieldsStream.getFilePointer();
/* 159 */       this.fieldsStream.seek(pointer + toRead);
/*     */     } else {
/*     */       
/* 162 */       this.fieldsStream.skipChars(toRead);
/*     */     } 
/*     */   }
/*     */   
/*     */   private void addFieldLazy(Document doc, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) throws IOException {
/* 167 */     if (binary == true) {
/* 168 */       int toRead = this.fieldsStream.readVInt();
/* 169 */       long pointer = this.fieldsStream.getFilePointer();
/* 170 */       if (compressed) {
/*     */         
/* 172 */         doc.add(new LazyField(fi.name, Field.Store.COMPRESS, toRead, pointer));
/*     */       } else {
/*     */         
/* 175 */         doc.add(new LazyField(fi.name, Field.Store.YES, toRead, pointer));
/*     */       } 
/*     */       
/* 178 */       this.fieldsStream.seek(pointer + toRead);
/*     */     } else {
/* 180 */       Fieldable f; Field.Store store = Field.Store.YES;
/* 181 */       Field.Index index = getIndexType(fi, tokenize);
/* 182 */       Field.TermVector termVector = getTermVectorType(fi);
/*     */ 
/*     */       
/* 185 */       if (compressed) {
/* 186 */         store = Field.Store.COMPRESS;
/* 187 */         int toRead = this.fieldsStream.readVInt();
/* 188 */         long pointer = this.fieldsStream.getFilePointer();
/* 189 */         f = new LazyField(fi.name, store, toRead, pointer);
/*     */         
/* 191 */         this.fieldsStream.seek(pointer + toRead);
/* 192 */         f.setOmitNorms(fi.omitNorms);
/*     */       } else {
/* 194 */         int length = this.fieldsStream.readVInt();
/* 195 */         long pointer = this.fieldsStream.getFilePointer();
/*     */         
/* 197 */         this.fieldsStream.skipChars(length);
/* 198 */         f = new LazyField(fi.name, store, index, termVector, length, pointer);
/* 199 */         f.setOmitNorms(fi.omitNorms);
/*     */       } 
/* 201 */       doc.add(f);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void addFieldForMerge(Document doc, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) throws IOException {
/*     */     Object data;
/* 210 */     if (binary || compressed) {
/* 211 */       int toRead = this.fieldsStream.readVInt();
/* 212 */       byte[] b = new byte[toRead];
/* 213 */       this.fieldsStream.readBytes(b, 0, b.length);
/* 214 */       data = b;
/*     */     } else {
/* 216 */       data = this.fieldsStream.readString();
/*     */     } 
/*     */     
/* 219 */     doc.add((Fieldable)new FieldForMerge(data, fi, binary, compressed, tokenize));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void addField(Document doc, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) throws CorruptIndexException, IOException {
/* 225 */     if (binary) {
/* 226 */       int toRead = this.fieldsStream.readVInt();
/* 227 */       byte[] b = new byte[toRead];
/* 228 */       this.fieldsStream.readBytes(b, 0, b.length);
/* 229 */       if (compressed) {
/* 230 */         doc.add((Fieldable)new Field(fi.name, uncompress(b), Field.Store.COMPRESS));
/*     */       } else {
/* 232 */         doc.add((Fieldable)new Field(fi.name, b, Field.Store.YES));
/*     */       } 
/*     */     } else {
/* 235 */       Field field; Field.Store store = Field.Store.YES;
/* 236 */       Field.Index index = getIndexType(fi, tokenize);
/* 237 */       Field.TermVector termVector = getTermVectorType(fi);
/*     */ 
/*     */       
/* 240 */       if (compressed) {
/* 241 */         store = Field.Store.COMPRESS;
/* 242 */         int toRead = this.fieldsStream.readVInt();
/*     */         
/* 244 */         byte[] b = new byte[toRead];
/* 245 */         this.fieldsStream.readBytes(b, 0, b.length);
/* 246 */         field = new Field(fi.name, new String(uncompress(b), ""UTF-8""), store, index, termVector);
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 251 */         field.setOmitNorms(fi.omitNorms);
/*     */       } else {
/* 253 */         field = new Field(fi.name, this.fieldsStream.readString(), store, index, termVector);
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 258 */         field.setOmitNorms(fi.omitNorms);
/*     */       } 
/* 260 */       doc.add((Fieldable)field);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private int addFieldSize(Document doc, FieldInfo fi, boolean binary, boolean compressed) throws IOException {
/* 268 */     int size = this.fieldsStream.readVInt(), bytesize = (binary || compressed) ? size : (2 * size);
/* 269 */     byte[] sizebytes = new byte[4];
/* 270 */     sizebytes[0] = (byte)(bytesize >>> 24);
/* 271 */     sizebytes[1] = (byte)(bytesize >>> 16);
/* 272 */     sizebytes[2] = (byte)(bytesize >>> 8);
/* 273 */     sizebytes[3] = (byte)bytesize;
/* 274 */     doc.add((Fieldable)new Field(fi.name, sizebytes, Field.Store.YES));
/* 275 */     return size;
/*     */   }
/*     */   
/*     */   private Field.TermVector getTermVectorType(FieldInfo fi) {
/* 279 */     Field.TermVector termVector = null;
/* 280 */     if (fi.storeTermVector) {
/* 281 */       if (fi.storeOffsetWithTermVector) {
/* 282 */         if (fi.storePositionWithTermVector) {
/* 283 */           termVector = Field.TermVector.WITH_POSITIONS_OFFSETS;
/*     */         } else {
/* 285 */           termVector = Field.TermVector.WITH_OFFSETS;
/*     */         } 
/* 287 */       } else if (fi.storePositionWithTermVector) {
/* 288 */         termVector = Field.TermVector.WITH_POSITIONS;
/*     */       } else {
/* 290 */         termVector = Field.TermVector.YES;
/*     */       } 
/*     */     } else {
/* 293 */       termVector = Field.TermVector.NO;
/*     */     } 
/* 295 */     return termVector;
/*     */   }
/*     */   
/*     */   private Field.Index getIndexType(FieldInfo fi, boolean tokenize) {
/*     */     Field.Index index;
/* 300 */     if (fi.isIndexed && tokenize) {
/* 301 */       index = Field.Index.TOKENIZED;
/* 302 */     } else if (fi.isIndexed && !tokenize) {
/* 303 */       index = Field.Index.UN_TOKENIZED;
/*     */     } else {
/* 305 */       index = Field.Index.NO;
/* 306 */     }  return index;
/*     */   }
/*     */   
/*     */   private class LazyField
/*     */     extends AbstractField
/*     */     implements Fieldable
/*     */   {
/*     */     private int toRead;
/*     */     private long pointer;
/*     */     private final FieldsReader this$0;
/*     */     
/*     */     public LazyField(String name, Field.Store store, int toRead, long pointer) {
/* 318 */       super(name, store, Field.Index.NO, Field.TermVector.NO);
/* 319 */       this.toRead = toRead;
/* 320 */       this.pointer = pointer;
/* 321 */       this.lazy = true;
/*     */     }
/*     */     
/*     */     public LazyField(String name, Field.Store store, Field.Index index, Field.TermVector termVector, int toRead, long pointer) {
/* 325 */       super(name, store, index, termVector);
/* 326 */       this.toRead = toRead;
/* 327 */       this.pointer = pointer;
/* 328 */       this.lazy = true;
/*     */     }
/*     */     
/*     */     private IndexInput getFieldStream() {
/* 332 */       IndexInput localFieldsStream = FieldsReader.this.fieldsStreamTL.get();
/* 333 */       if (localFieldsStream == null) {
/* 334 */         localFieldsStream = (IndexInput)FieldsReader.this.cloneableFieldsStream.clone();
/* 335 */         FieldsReader.this.fieldsStreamTL.set(localFieldsStream);
/*     */       } 
/* 337 */       return localFieldsStream;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public byte[] binaryValue() {
/* 344 */       FieldsReader.this.ensureOpen();
/* 345 */       if (this.fieldsData == null) {
/* 346 */         byte[] b = new byte[this.toRead];
/* 347 */         IndexInput localFieldsStream = getFieldStream();
/*     */ 
/*     */         
/*     */         try {
/* 351 */           localFieldsStream.seek(this.pointer);
/* 352 */           localFieldsStream.readBytes(b, 0, b.length);
/* 353 */           if (this.isCompressed == true) {
/* 354 */             this.fieldsData = FieldsReader.this.uncompress(b);
/*     */           } else {
/* 356 */             this.fieldsData = b;
/*     */           } 
/* 358 */         } catch (IOException e) {
/* 359 */           throw new FieldReaderException(e);
/*     */         } 
/*     */       } 
/* 362 */       return (this.fieldsData instanceof byte[]) ? (byte[])this.fieldsData : null;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Reader readerValue() {
/* 369 */       FieldsReader.this.ensureOpen();
/* 370 */       return (this.fieldsData instanceof Reader) ? (Reader)this.fieldsData : null;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public TokenStream tokenStreamValue() {
/* 377 */       FieldsReader.this.ensureOpen();
/* 378 */       return (this.fieldsData instanceof TokenStream) ? (TokenStream)this.fieldsData : null;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public String stringValue() {
/* 386 */       FieldsReader.this.ensureOpen();
/* 387 */       if (this.fieldsData == null) {
/* 388 */         IndexInput localFieldsStream = getFieldStream();
/*     */         try {
/* 390 */           localFieldsStream.seek(this.pointer);
/* 391 */           if (this.isCompressed) {
/* 392 */             byte[] b = new byte[this.toRead];
/* 393 */             localFieldsStream.readBytes(b, 0, b.length);
/* 394 */             this.fieldsData = new String(FieldsReader.this.uncompress(b), ""UTF-8"");
/*     */           } else {
/*     */             
/* 397 */             char[] chars = new char[this.toRead];
/* 398 */             localFieldsStream.readChars(chars, 0, this.toRead);
/* 399 */             this.fieldsData = new String(chars);
/*     */           } 
/* 401 */         } catch (IOException e) {
/* 402 */           throw new FieldReaderException(e);
/*     */         } 
/*     */       } 
/* 405 */       return (this.fieldsData instanceof String) ? (String)this.fieldsData : null;
/*     */     }
/*     */     
/*     */     public long getPointer() {
/* 409 */       FieldsReader.this.ensureOpen();
/* 410 */       return this.pointer;
/*     */     }
/*     */     
/*     */     public void setPointer(long pointer) {
/* 414 */       FieldsReader.this.ensureOpen();
/* 415 */       this.pointer = pointer;
/*     */     }
/*     */     
/*     */     public int getToRead() {
/* 419 */       FieldsReader.this.ensureOpen();
/* 420 */       return this.toRead;
/*     */     }
/*     */     
/*     */     public void setToRead(int toRead) {
/* 424 */       FieldsReader.this.ensureOpen();
/* 425 */       this.toRead = toRead;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private final byte[] uncompress(byte[] input) throws CorruptIndexException, IOException {
/* 432 */     Inflater decompressor = new Inflater();
/* 433 */     decompressor.setInput(input);
/*     */ 
/*     */     
/* 436 */     ByteArrayOutputStream bos = new ByteArrayOutputStream(input.length);
/*     */ 
/*     */     
/* 439 */     byte[] buf = new byte[1024];
/* 440 */     while (!decompressor.finished()) {
/*     */       try {
/* 442 */         int count = decompressor.inflate(buf);
/* 443 */         bos.write(buf, 0, count);
/*     */       }
/* 445 */       catch (DataFormatException e) {
/*     */         
/* 447 */         CorruptIndexException newException = new CorruptIndexException(""field data are in wrong format: "" + e.toString());
/* 448 */         newException.initCause(e);
/* 449 */         throw newException;
/*     */       } 
/*     */     } 
/*     */     
/* 453 */     decompressor.end();
/*     */ 
/*     */     
/* 456 */     return bos.toByteArray();
/*     */   }
/*     */ 
/*     */   
/*     */   static final class FieldForMerge
/*     */     extends AbstractField
/*     */   {
/* 463 */     public String stringValue() { return (String)this.fieldsData; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 468 */     public Reader readerValue() { return null; }
/*     */ 
/*     */ 
/*     */     
/* 472 */     public byte[] binaryValue() { return (byte[])this.fieldsData; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 477 */     public TokenStream tokenStreamValue() { return null; }
/*     */ 
/*     */     
/*     */     public FieldForMerge(Object value, FieldInfo fi, boolean binary, boolean compressed, boolean tokenize) {
/* 481 */       this.isStored = true;
/* 482 */       this.fieldsData = value;
/* 483 */       this.isCompressed = compressed;
/* 484 */       this.isBinary = binary;
/* 485 */       this.isTokenized = tokenize;
/*     */       
/* 487 */       this.name = fi.name.intern();
/* 488 */       this.isIndexed = fi.isIndexed;
/* 489 */       this.omitNorms = fi.omitNorms;
/* 490 */       this.storeOffsetWithTermVector = fi.storeOffsetWithTermVector;
/* 491 */       this.storePositionWithTermVector = fi.storePositionWithTermVector;
/* 492 */       this.storeTermVector = fi.storeTermVector;
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\FieldsReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FieldsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.ByteArrayOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.zip.Deflater;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class FieldsWriter
/*     */ {
/*     */   static final byte FIELD_IS_TOKENIZED = 1;
/*     */   static final byte FIELD_IS_BINARY = 2;
/*     */   static final byte FIELD_IS_COMPRESSED = 4;
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexOutput fieldsStream;
/*     */   private IndexOutput indexStream;
/*     */   
/*     */   FieldsWriter(Directory d, String segment, FieldInfos fn) throws IOException {
/*  42 */     this.fieldInfos = fn;
/*  43 */     this.fieldsStream = d.createOutput(segment + "".fdt"");
/*  44 */     this.indexStream = d.createOutput(segment + "".fdx"");
/*     */   }
/*     */   
/*     */   final void close() throws IOException {
/*  48 */     this.fieldsStream.close();
/*  49 */     this.indexStream.close();
/*     */   }
/*     */   
/*     */   final void addDocument(Document doc) throws IOException {
/*  53 */     this.indexStream.writeLong(this.fieldsStream.getFilePointer());
/*     */     
/*  55 */     int storedCount = 0;
/*  56 */     Iterator fieldIterator = doc.getFields().iterator();
/*  57 */     while (fieldIterator.hasNext()) {
/*  58 */       Fieldable field = fieldIterator.next();
/*  59 */       if (field.isStored())
/*  60 */         storedCount++; 
/*     */     } 
/*  62 */     this.fieldsStream.writeVInt(storedCount);
/*     */     
/*  64 */     fieldIterator = doc.getFields().iterator();
/*  65 */     while (fieldIterator.hasNext()) {
/*  66 */       Fieldable field = fieldIterator.next();
/*     */ 
/*     */ 
/*     */       
/*  70 */       boolean disableCompression = field instanceof FieldsReader.FieldForMerge;
/*  71 */       if (field.isStored()) {
/*  72 */         this.fieldsStream.writeVInt(this.fieldInfos.fieldNumber(field.name()));
/*     */         
/*  74 */         byte bits = 0;
/*  75 */         if (field.isTokenized())
/*  76 */           bits = (byte)(bits | 0x1); 
/*  77 */         if (field.isBinary())
/*  78 */           bits = (byte)(bits | 0x2); 
/*  79 */         if (field.isCompressed()) {
/*  80 */           bits = (byte)(bits | 0x4);
/*     */         }
/*  82 */         this.fieldsStream.writeByte(bits);
/*     */         
/*  84 */         if (field.isCompressed()) {
/*     */           
/*  86 */           byte[] data = null;
/*     */           
/*  88 */           if (disableCompression) {
/*     */ 
/*     */             
/*  91 */             data = field.binaryValue();
/*     */           
/*     */           }
/*  94 */           else if (field.isBinary()) {
/*  95 */             data = compress(field.binaryValue());
/*     */           } else {
/*     */             
/*  98 */             data = compress(field.stringValue().getBytes(""UTF-8""));
/*     */           } 
/*     */           
/* 101 */           int len = data.length;
/* 102 */           this.fieldsStream.writeVInt(len);
/* 103 */           this.fieldsStream.writeBytes(data, len);
/*     */           
/*     */           continue;
/*     */         } 
/* 107 */         if (field.isBinary()) {
/* 108 */           byte[] data = field.binaryValue();
/* 109 */           int len = data.length;
/* 110 */           this.fieldsStream.writeVInt(len);
/* 111 */           this.fieldsStream.writeBytes(data, len);
/*     */           continue;
/*     */         } 
/* 114 */         this.fieldsStream.writeString(field.stringValue());
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final byte[] compress(byte[] input) {
/* 124 */     Deflater compressor = new Deflater();
/* 125 */     compressor.setLevel(9);
/*     */ 
/*     */     
/* 128 */     compressor.setInput(input);
/* 129 */     compressor.finish();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 137 */     ByteArrayOutputStream bos = new ByteArrayOutputStream(input.length);
/*     */ 
/*     */     
/* 140 */     byte[] buf = new byte[1024];
/* 141 */     while (!compressor.finished()) {
/* 142 */       int count = compressor.deflate(buf);
/* 143 */       bos.write(buf, 0, count);
/*     */     } 
/*     */     
/* 146 */     compressor.end();
/*     */ 
/*     */     
/* 149 */     return bos.toByteArray();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\FieldsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.FilterIndexReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilterIndexReader
/*     */   extends IndexReader
/*     */ {
/*     */   protected IndexReader in;
/*     */   
/*     */   public static class FilterTermDocs
/*     */     implements TermDocs
/*     */   {
/*     */     protected TermDocs in;
/*     */     
/*  41 */     public FilterTermDocs(TermDocs in) { this.in = in; }
/*     */     
/*  43 */     public void seek(Term term) throws IOException { this.in.seek(term); }
/*  44 */     public void seek(TermEnum termEnum) throws IOException { this.in.seek(termEnum); }
/*  45 */     public int doc() { return this.in.doc(); }
/*  46 */     public int freq() { return this.in.freq(); }
/*  47 */     public boolean next() throws IOException { return this.in.next(); }
/*     */     
/*  49 */     public int read(int[] docs, int[] freqs) throws IOException { return this.in.read(docs, freqs); }
/*     */     
/*  51 */     public boolean skipTo(int i) throws IOException { return this.in.skipTo(i); }
/*  52 */     public void close() throws IOException { this.in.close(); }
/*     */   }
/*     */   
/*     */   public static class FilterTermPositions
/*     */     extends FilterTermDocs
/*     */     implements TermPositions
/*     */   {
/*  59 */     public FilterTermPositions(TermPositions in) { super(in); }
/*     */ 
/*     */     
/*  62 */     public int nextPosition() throws IOException { return ((TermPositions)this.in).nextPosition(); }
/*     */ 
/*     */ 
/*     */     
/*  66 */     public int getPayloadLength() { return ((TermPositions)this.in).getPayloadLength(); }
/*     */ 
/*     */ 
/*     */     
/*  70 */     public byte[] getPayload(byte[] data, int offset) throws IOException { return ((TermPositions)this.in).getPayload(data, offset); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  76 */     public boolean isPayloadAvailable() { return ((TermPositions)this.in).isPayloadAvailable(); }
/*     */   }
/*     */   
/*     */   public static class FilterTermEnum
/*     */     extends TermEnum
/*     */   {
/*     */     protected TermEnum in;
/*     */     
/*  84 */     public FilterTermEnum(TermEnum in) { this.in = in; }
/*     */     
/*  86 */     public boolean next() throws IOException { return this.in.next(); }
/*  87 */     public Term term() { return this.in.term(); }
/*  88 */     public int docFreq() { return this.in.docFreq(); }
/*  89 */     public void close() throws IOException { this.in.close(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FilterIndexReader(IndexReader in) {
/* 102 */     super(in.directory());
/* 103 */     this.in = in;
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int docNumber) throws IOException {
/* 108 */     ensureOpen();
/* 109 */     return this.in.getTermFreqVectors(docNumber);
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int docNumber, String field) throws IOException {
/* 114 */     ensureOpen();
/* 115 */     return this.in.getTermFreqVector(docNumber, field);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 120 */   public int numDocs() { return this.in.numDocs(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 125 */   public int maxDoc() { return this.in.maxDoc(); }
/*     */ 
/*     */   
/*     */   public Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 129 */     ensureOpen();
/* 130 */     return this.in.document(n, fieldSelector);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 135 */   public boolean isDeleted(int n) { return this.in.isDeleted(n); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 140 */   public boolean hasDeletions() { return this.in.hasDeletions(); }
/*     */ 
/*     */   
/* 143 */   protected void doUndeleteAll() throws CorruptIndexException, IOException { this.in.undeleteAll(); }
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 146 */     ensureOpen();
/* 147 */     return this.in.hasNorms(field);
/*     */   }
/*     */   
/*     */   public byte[] norms(String f) throws IOException {
/* 151 */     ensureOpen();
/* 152 */     return this.in.norms(f);
/*     */   }
/*     */   
/*     */   public void norms(String f, byte[] bytes, int offset) throws IOException {
/* 156 */     ensureOpen();
/* 157 */     this.in.norms(f, bytes, offset);
/*     */   }
/*     */ 
/*     */   
/* 161 */   protected void doSetNorm(int d, String f, byte b) throws CorruptIndexException, IOException { this.in.setNorm(d, f, b); }
/*     */ 
/*     */   
/*     */   public TermEnum terms() throws IOException {
/* 165 */     ensureOpen();
/* 166 */     return this.in.terms();
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term t) throws IOException {
/* 170 */     ensureOpen();
/* 171 */     return this.in.terms(t);
/*     */   }
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 175 */     ensureOpen();
/* 176 */     return this.in.docFreq(t);
/*     */   }
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 180 */     ensureOpen();
/* 181 */     return this.in.termDocs();
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 185 */     ensureOpen();
/* 186 */     return this.in.termPositions();
/*     */   }
/*     */   
/* 189 */   protected void doDelete(int n) throws CorruptIndexException, IOException { this.in.deleteDocument(n); }
/* 190 */   protected void doCommit() throws IOException { this.in.commit(); }
/* 191 */   protected void doClose() throws IOException { this.in.close(); }
/*     */ 
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 195 */     ensureOpen();
/* 196 */     return this.in.getFieldNames(fieldNames);
/*     */   }
/*     */   
/*     */   public long getVersion() {
/* 200 */     ensureOpen();
/* 201 */     return this.in.getVersion();
/*     */   }
/*     */   
/*     */   public boolean isCurrent() throws CorruptIndexException, IOException {
/* 205 */     ensureOpen();
/* 206 */     return this.in.isCurrent();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\FilterIndexReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexCommitPoint,"package org.apache.lucene.index;
public interface IndexCommitPoint {
  String getSegmentsFileName();
  void delete();
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexCommitPoint.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexDeletionPolicy,"package org.apache.lucene.index;
import java.io.IOException;
import java.util.List;
public interface IndexDeletionPolicy {
  void onInit(List paramList) throws IOException;
  void onCommit(List paramList) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexDeletionPolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileDeleter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collections;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class IndexFileDeleter
/*     */ {
/*     */   private List deletable;
/*  81 */   private Map refCounts = new HashMap();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  88 */   private List commits = new ArrayList();
/*     */ 
/*     */ 
/*     */   
/*  92 */   private List lastFiles = new ArrayList();
/*     */ 
/*     */   
/*  95 */   private List commitsToDelete = new ArrayList();
/*     */   
/*     */   private PrintStream infoStream;
/*     */   
/*     */   private Directory directory;
/*     */   private IndexDeletionPolicy policy;
/*     */   
/* 102 */   void setInfoStream(PrintStream infoStream) { this.infoStream = infoStream; }
/*     */ 
/*     */ 
/*     */   
/* 106 */   private void message(String message) { this.infoStream.println(this + "" "" + Thread.currentThread().getName() + "": "" + message); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream) throws CorruptIndexException, IOException {
/* 122 */     this.infoStream = infoStream;
/* 123 */     this.policy = policy;
/* 124 */     this.directory = directory;
/*     */ 
/*     */ 
/*     */     
/* 128 */     long currentGen = segmentInfos.getGeneration();
/* 129 */     IndexFileNameFilter filter = IndexFileNameFilter.getFilter();
/*     */     
/* 131 */     String[] files = directory.list();
/* 132 */     if (files == null) {
/* 133 */       throw new IOException(""cannot read directory "" + directory + "": list() returned null"");
/*     */     }
/* 135 */     CommitPoint currentCommitPoint = null;
/*     */     
/* 137 */     for (int i = 0; i < files.length; i++) {
/*     */       
/* 139 */       String fileName = files[i];
/*     */       
/* 141 */       if (filter.accept(null, fileName) && !fileName.equals(""segments.gen"")) {
/*     */ 
/*     */         
/* 144 */         getRefCount(fileName);
/*     */         
/* 146 */         if (fileName.startsWith(""segments""))
/*     */         {
/*     */ 
/*     */ 
/*     */           
/* 151 */           if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {
/* 152 */             if (infoStream != null) {
/* 153 */               message(""init: load commit \"""" + fileName + ""\"""");
/*     */             }
/* 155 */             SegmentInfos sis = new SegmentInfos();
/* 156 */             sis.read(directory, fileName);
/* 157 */             CommitPoint commitPoint = new CommitPoint(sis);
/* 158 */             if (sis.getGeneration() == segmentInfos.getGeneration()) {
/* 159 */               currentCommitPoint = commitPoint;
/*     */             }
/* 161 */             this.commits.add(commitPoint);
/* 162 */             incRef(sis, true);
/*     */           } 
/*     */         }
/*     */       } 
/*     */     } 
/*     */     
/* 168 */     if (currentCommitPoint == null) {
/* 169 */       throw new CorruptIndexException(""failed to locate current segments_N file"");
/*     */     }
/*     */ 
/*     */     
/* 173 */     Collections.sort(this.commits);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 178 */     Iterator it = this.refCounts.keySet().iterator();
/* 179 */     while (it.hasNext()) {
/* 180 */       String fileName = it.next();
/* 181 */       RefCount rc = (RefCount)this.refCounts.get(fileName);
/* 182 */       if (0 == rc.count) {
/* 183 */         if (infoStream != null) {
/* 184 */           message(""init: removing unreferenced file \"""" + fileName + ""\"""");
/*     */         }
/* 186 */         deleteFile(fileName);
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 192 */     policy.onInit(this.commits);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 197 */     if (currentCommitPoint.deleted) {
/* 198 */       checkpoint(segmentInfos, false);
/*     */     }
/*     */     
/* 201 */     deleteCommits();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void deleteCommits() throws IOException {
/* 210 */     int size = this.commitsToDelete.size();
/*     */     
/* 212 */     if (size > 0) {
/*     */ 
/*     */ 
/*     */       
/* 216 */       for (int i = 0; i < size; i++) {
/* 217 */         CommitPoint commit = this.commitsToDelete.get(i);
/* 218 */         if (this.infoStream != null) {
/* 219 */           message(""deleteCommits: now remove commit \"""" + commit.getSegmentsFileName() + ""\"""");
/*     */         }
/* 221 */         int size2 = commit.files.size();
/* 222 */         for (int j = 0; j < size2; j++) {
/* 223 */           decRef(commit.files.get(j));
/*     */         }
/* 225 */         decRef(commit.getSegmentsFileName());
/*     */       } 
/* 227 */       this.commitsToDelete.clear();
/*     */ 
/*     */       
/* 230 */       size = this.commits.size();
/* 231 */       int readFrom = 0;
/* 232 */       int writeTo = 0;
/* 233 */       while (readFrom < size) {
/* 234 */         CommitPoint commit = this.commits.get(readFrom);
/* 235 */         if (!commit.deleted) {
/* 236 */           if (writeTo != readFrom) {
/* 237 */             this.commits.set(writeTo, this.commits.get(readFrom));
/*     */           }
/* 239 */           writeTo++;
/*     */         } 
/* 241 */         readFrom++;
/*     */       } 
/*     */       
/* 244 */       while (size > writeTo) {
/* 245 */         this.commits.remove(size - 1);
/* 246 */         size--;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void refresh() throws IOException {
/* 258 */     String[] files = this.directory.list();
/* 259 */     if (files == null)
/* 260 */       throw new IOException(""cannot read directory "" + this.directory + "": list() returned null""); 
/* 261 */     IndexFileNameFilter filter = IndexFileNameFilter.getFilter();
/* 262 */     for (int i = 0; i < files.length; i++) {
/* 263 */       String fileName = files[i];
/* 264 */       if (filter.accept(null, fileName) && !this.refCounts.containsKey(fileName) && !fileName.equals(""segments.gen"")) {
/*     */         
/* 266 */         if (this.infoStream != null) {
/* 267 */           message(""refresh: removing newly created unreferenced file \"""" + fileName + ""\"""");
/*     */         }
/* 269 */         deleteFile(fileName);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void checkpoint(SegmentInfos segmentInfos, boolean isCommit) throws IOException {
/* 296 */     if (this.infoStream != null) {
/* 297 */       message(""now checkpoint \"""" + segmentInfos.getCurrentSegmentFileName() + ""\"" [isCommit = "" + isCommit + ""]"");
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 302 */     if (this.deletable != null) {
/* 303 */       List oldDeletable = this.deletable;
/* 304 */       this.deletable = null;
/* 305 */       int size = oldDeletable.size();
/* 306 */       for (int i = 0; i < size; i++) {
/* 307 */         deleteFile(oldDeletable.get(i));
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 312 */     incRef(segmentInfos, isCommit);
/*     */     
/* 314 */     if (isCommit) {
/*     */       
/* 316 */       this.commits.add(new CommitPoint(segmentInfos));
/*     */ 
/*     */       
/* 319 */       this.policy.onCommit(this.commits);
/*     */ 
/*     */       
/* 322 */       deleteCommits();
/*     */     } 
/*     */ 
/*     */     
/* 326 */     int size = this.lastFiles.size();
/* 327 */     if (size > 0) {
/* 328 */       for (int i = 0; i < size; i++) {
/* 329 */         decRef(this.lastFiles.get(i));
/*     */       }
/* 331 */       this.lastFiles.clear();
/*     */     } 
/*     */     
/* 334 */     if (!isCommit) {
/*     */       
/* 336 */       size = segmentInfos.size();
/* 337 */       for (int i = 0; i < size; i++) {
/* 338 */         SegmentInfo segmentInfo = segmentInfos.info(i);
/* 339 */         if (segmentInfo.dir == this.directory) {
/* 340 */           this.lastFiles.add(segmentInfo.files());
/*     */         }
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   void incRef(SegmentInfos segmentInfos, boolean isCommit) throws IOException {
/* 347 */     int size = segmentInfos.size();
/* 348 */     for (int i = 0; i < size; i++) {
/* 349 */       SegmentInfo segmentInfo = segmentInfos.info(i);
/* 350 */       if (segmentInfo.dir == this.directory) {
/* 351 */         incRef(segmentInfo.files());
/*     */       }
/*     */     } 
/*     */     
/* 355 */     if (isCommit)
/*     */     {
/*     */       
/* 358 */       getRefCount(segmentInfos.getCurrentSegmentFileName()).IncRef();
/*     */     }
/*     */   }
/*     */   
/*     */   private void incRef(List files) throws IOException {
/* 363 */     int size = files.size();
/* 364 */     for (int i = 0; i < size; i++) {
/* 365 */       String fileName = files.get(i);
/* 366 */       RefCount rc = getRefCount(fileName);
/* 367 */       if (this.infoStream != null) {
/* 368 */         message(""  IncRef \"""" + fileName + ""\"": pre-incr count is "" + rc.count);
/*     */       }
/* 370 */       rc.IncRef();
/*     */     } 
/*     */   }
/*     */   
/*     */   private void decRef(List files) throws IOException {
/* 375 */     int size = files.size();
/* 376 */     for (int i = 0; i < size; i++) {
/* 377 */       decRef(files.get(i));
/*     */     }
/*     */   }
/*     */   
/*     */   private void decRef(String fileName) throws IOException {
/* 382 */     RefCount rc = getRefCount(fileName);
/* 383 */     if (this.infoStream != null) {
/* 384 */       message(""  DecRef \"""" + fileName + ""\"": pre-decr count is "" + rc.count);
/*     */     }
/* 386 */     if (0 == rc.DecRef()) {
/*     */ 
/*     */       
/* 389 */       deleteFile(fileName);
/* 390 */       this.refCounts.remove(fileName);
/*     */     } 
/*     */   }
/*     */   
/*     */   void decRef(SegmentInfos segmentInfos) throws IOException {
/* 395 */     int size = segmentInfos.size();
/* 396 */     for (int i = 0; i < size; i++) {
/* 397 */       SegmentInfo segmentInfo = segmentInfos.info(i);
/* 398 */       if (segmentInfo.dir == this.directory) {
/* 399 */         decRef(segmentInfo.files());
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   private RefCount getRefCount(String fileName) {
/*     */     RefCount rc;
/* 406 */     if (!this.refCounts.containsKey(fileName)) {
/* 407 */       rc = new RefCount();
/* 408 */       this.refCounts.put(fileName, rc);
/*     */     } else {
/* 410 */       rc = (RefCount)this.refCounts.get(fileName);
/*     */     } 
/* 412 */     return rc;
/*     */   }
/*     */ 
/*     */   
/*     */   private void deleteFile(String fileName) throws IOException {
/*     */     try {
/* 418 */       if (this.infoStream != null) {
/* 419 */         message(""delete \"""" + fileName + ""\"""");
/*     */       }
/* 421 */       this.directory.deleteFile(fileName);
/* 422 */     } catch (IOException e) {
/* 423 */       if (this.directory.fileExists(fileName)) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 432 */         if (this.infoStream != null) {
/* 433 */           message(""IndexFileDeleter: unable to remove file \"""" + fileName + ""\"": "" + e.toString() + ""; Will re-try later."");
/*     */         }
/* 435 */         if (this.deletable == null) {
/* 436 */           this.deletable = new ArrayList();
/*     */         }
/* 438 */         this.deletable.add(fileName);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void deleteDirect(Directory otherDir, List segments) throws IOException {
/* 450 */     int size = segments.size();
/* 451 */     for (int i = 0; i < size; i++) {
/* 452 */       List filestoDelete = ((SegmentInfo)segments.get(i)).files();
/* 453 */       int size2 = filestoDelete.size();
/* 454 */       for (int j = 0; j < size2; j++) {
/* 455 */         otherDir.deleteFile(filestoDelete.get(j));
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private static final class RefCount
/*     */   {
/*     */     int count;
/*     */ 
/*     */     
/*     */     private RefCount() {}
/*     */     
/* 468 */     private final int IncRef() { return ++this.count; }
/*     */ 
/*     */ 
/*     */     
/* 472 */     private final int DecRef() { return --this.count; }
/*     */   }
/*     */ 
/*     */   
/*     */   private final class CommitPoint
/*     */     implements Comparable, IndexCommitPoint
/*     */   {
/*     */     long gen;
/*     */     
/*     */     List files;
/*     */     
/*     */     String segmentsFileName;
/*     */     
/*     */     boolean deleted;
/*     */     
/*     */     private final IndexFileDeleter this$0;
/*     */ 
/*     */     
/*     */     public CommitPoint(SegmentInfos segmentInfos) throws IOException {
/* 491 */       this.segmentsFileName = segmentInfos.getCurrentSegmentFileName();
/* 492 */       int size = segmentInfos.size();
/* 493 */       this.files = new ArrayList(size);
/* 494 */       this.gen = segmentInfos.getGeneration();
/* 495 */       for (int i = 0; i < size; i++) {
/* 496 */         SegmentInfo segmentInfo = segmentInfos.info(i);
/* 497 */         if (segmentInfo.dir == IndexFileDeleter.this.directory) {
/* 498 */           this.files.add(segmentInfo.files());
/*     */         }
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 507 */     public String getSegmentsFileName() { return this.segmentsFileName; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public void delete() {
/* 515 */       if (!this.deleted) {
/* 516 */         this.deleted = true;
/* 517 */         IndexFileDeleter.this.commitsToDelete.add(this);
/*     */       } 
/*     */     }
/*     */     
/*     */     public int compareTo(Object obj) {
/* 522 */       CommitPoint commit = (CommitPoint)obj;
/* 523 */       if (this.gen < commit.gen)
/* 524 */         return -1; 
/* 525 */       if (this.gen > commit.gen) {
/* 526 */         return 1;
/*     */       }
/* 528 */       return 0;
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexFileDeleter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileNameFilter,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.FilenameFilter;
/*    */ import java.util.HashSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class IndexFileNameFilter
/*    */   implements FilenameFilter
/*    */ {
/* 32 */   static IndexFileNameFilter singleton = new IndexFileNameFilter();
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 37 */   private HashSet extensions = new HashSet(); public IndexFileNameFilter() {
/* 38 */     for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS.length; i++) {
/* 39 */       this.extensions.add(IndexFileNames.INDEX_EXTENSIONS[i]);
/*    */     }
/* 41 */     this.extensionsInCFS = new HashSet();
/* 42 */     for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE.length; i++) {
/* 43 */       this.extensionsInCFS.add(IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE[i]);
/*    */     }
/*    */   }
/*    */ 
/*    */   
/*    */   private HashSet extensionsInCFS;
/*    */   
/*    */   public boolean accept(File dir, String name) {
/* 51 */     int i = name.lastIndexOf('.');
/* 52 */     if (i != -1) {
/* 53 */       String extension = name.substring(1 + i);
/* 54 */       if (this.extensions.contains(extension))
/* 55 */         return true; 
/* 56 */       if (extension.startsWith(""f"") && extension.matches(""f\\d+""))
/*    */       {
/* 58 */         return true; } 
/* 59 */       if (extension.startsWith(""s"") && extension.matches(""s\\d+""))
/*    */       {
/* 61 */         return true;
/*    */       }
/*    */     } else {
/* 64 */       if (name.equals(""deletable"")) return true; 
/* 65 */       if (name.startsWith(""segments"")) return true; 
/*    */     } 
/* 67 */     return false;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean isCFSFile(String name) {
/* 77 */     int i = name.lastIndexOf('.');
/* 78 */     if (i != -1) {
/* 79 */       String extension = name.substring(1 + i);
/* 80 */       if (this.extensionsInCFS.contains(extension)) {
/* 81 */         return true;
/*    */       }
/* 83 */       if (extension.startsWith(""f"") && extension.matches(""f\\d+""))
/*    */       {
/* 85 */         return true;
/*    */       }
/*    */     } 
/* 88 */     return false;
/*    */   }
/*    */ 
/*    */   
/* 92 */   public static IndexFileNameFilter getFilter() { return singleton; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexFileNameFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexFileNames,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class IndexFileNames
/*    */ {
/*    */   static final String SEGMENTS = ""segments"";
/*    */   static final String SEGMENTS_GEN = ""segments.gen"";
/*    */   static final String DELETABLE = ""deletable"";
/*    */   static final String NORMS_EXTENSION = ""nrm"";
/*    */   static final String COMPOUND_FILE_EXTENSION = ""cfs"";
/*    */   static final String DELETES_EXTENSION = ""del"";
/*    */   static final String PLAIN_NORMS_EXTENSION = ""f"";
/*    */   static final String SEPARATE_NORMS_EXTENSION = ""s"";
/* 61 */   static final String[] INDEX_EXTENSIONS = new String[] { ""cfs"", ""fnm"", ""fdx"", ""fdt"", ""tii"", ""tis"", ""frq"", ""prx"", ""del"", ""tvx"", ""tvd"", ""tvf"", ""gen"", ""nrm"" };
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 68 */   static final String[] INDEX_EXTENSIONS_IN_COMPOUND_FILE = new String[] { ""fnm"", ""fdx"", ""fdt"", ""tii"", ""tis"", ""frq"", ""prx"", ""tvx"", ""tvd"", ""tvf"", ""nrm"" };
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 74 */   static final String[] COMPOUND_EXTENSIONS = new String[] { ""fnm"", ""frq"", ""prx"", ""fdx"", ""fdt"", ""tii"", ""tis"" };
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 79 */   static final String[] VECTOR_EXTENSIONS = new String[] { ""tvx"", ""tvd"", ""tvf"" };
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   static final String fileNameFromGeneration(String base, String extension, long gen) {
/* 94 */     if (gen == -1L)
/* 95 */       return null; 
/* 96 */     if (gen == 0L) {
/* 97 */       return base + extension;
/*    */     }
/* 99 */     return base + ""_"" + Long.toString(gen, 36) + extension;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexFileNames.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexModifier,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.FSDirectory;
/*     */ import org.apache.lucene.store.LockObtainFailedException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IndexModifier
/*     */ {
/*  95 */   protected IndexWriter indexWriter = null;
/*  96 */   protected IndexReader indexReader = null;
/*     */   
/*  98 */   protected Directory directory = null;
/*  99 */   protected Analyzer analyzer = null;
/*     */   
/*     */   protected boolean open = false;
/*     */   
/* 103 */   protected PrintStream infoStream = null;
/*     */   protected boolean useCompoundFile = true;
/* 105 */   protected int maxBufferedDocs = 10;
/* 106 */   protected int maxFieldLength = 10000;
/* 107 */   protected int mergeFactor = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 123 */   public IndexModifier(Directory directory, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { init(directory, analyzer, create); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexModifier(String dirName, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 140 */     FSDirectory fSDirectory = FSDirectory.getDirectory(dirName);
/* 141 */     init((Directory)fSDirectory, analyzer, create);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IndexModifier(File file, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 158 */     FSDirectory fSDirectory = FSDirectory.getDirectory(file);
/* 159 */     init((Directory)fSDirectory, analyzer, create);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void init(Directory directory, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 171 */     this.directory = directory;
/* 172 */     synchronized (this.directory) {
/* 173 */       this.analyzer = analyzer;
/* 174 */       this.indexWriter = new IndexWriter(directory, analyzer, create);
/* 175 */       this.open = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void assureOpen() {
/* 184 */     if (!this.open) {
/* 185 */       throw new IllegalStateException(""Index is closed"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void createIndexWriter() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 198 */     if (this.indexWriter == null) {
/* 199 */       if (this.indexReader != null) {
/* 200 */         this.indexReader.close();
/* 201 */         this.indexReader = null;
/*     */       } 
/* 203 */       this.indexWriter = new IndexWriter(this.directory, this.analyzer, false);
/* 204 */       this.indexWriter.setInfoStream(this.infoStream);
/* 205 */       this.indexWriter.setUseCompoundFile(this.useCompoundFile);
/* 206 */       this.indexWriter.setMaxBufferedDocs(this.maxBufferedDocs);
/* 207 */       this.indexWriter.setMaxFieldLength(this.maxFieldLength);
/* 208 */       this.indexWriter.setMergeFactor(this.mergeFactor);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void createIndexReader() throws CorruptIndexException, IOException {
/* 218 */     if (this.indexReader == null) {
/* 219 */       if (this.indexWriter != null) {
/* 220 */         this.indexWriter.close();
/* 221 */         this.indexWriter = null;
/*     */       } 
/* 223 */       this.indexReader = IndexReader.open(this.directory);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 236 */     synchronized (this.directory) {
/* 237 */       assureOpen();
/* 238 */       if (this.indexWriter != null) {
/* 239 */         this.indexWriter.close();
/* 240 */         this.indexWriter = null;
/* 241 */         createIndexWriter();
/*     */       } else {
/* 243 */         this.indexReader.close();
/* 244 */         this.indexReader = null;
/* 245 */         createIndexReader();
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void addDocument(Document doc, Analyzer docAnalyzer) throws CorruptIndexException, LockObtainFailedException, IOException {
/* 264 */     synchronized (this.directory) {
/* 265 */       assureOpen();
/* 266 */       createIndexWriter();
/* 267 */       if (docAnalyzer != null) {
/* 268 */         this.indexWriter.addDocument(doc, docAnalyzer);
/*     */       } else {
/* 270 */         this.indexWriter.addDocument(doc);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 287 */   public void addDocument(Document doc) throws CorruptIndexException, LockObtainFailedException, IOException { addDocument(doc, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int deleteDocuments(Term term) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 308 */     synchronized (this.directory) {
/* 309 */       assureOpen();
/* 310 */       createIndexReader();
/* 311 */       return this.indexReader.deleteDocuments(term);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void deleteDocument(int docNum) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 327 */     synchronized (this.directory) {
/* 328 */       assureOpen();
/* 329 */       createIndexReader();
/* 330 */       this.indexReader.deleteDocument(docNum);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int docCount() {
/* 342 */     synchronized (this.directory) {
/* 343 */       assureOpen();
/* 344 */       if (this.indexWriter != null) {
/* 345 */         return this.indexWriter.docCount();
/*     */       }
/* 347 */       return this.indexReader.numDocs();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void optimize() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 364 */     synchronized (this.directory) {
/* 365 */       assureOpen();
/* 366 */       createIndexWriter();
/* 367 */       this.indexWriter.optimize();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setInfoStream(PrintStream infoStream) {
/* 379 */     synchronized (this.directory) {
/* 380 */       assureOpen();
/* 381 */       if (this.indexWriter != null) {
/* 382 */         this.indexWriter.setInfoStream(infoStream);
/*     */       }
/* 384 */       this.infoStream = infoStream;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public PrintStream getInfoStream() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 397 */     synchronized (this.directory) {
/* 398 */       assureOpen();
/* 399 */       createIndexWriter();
/* 400 */       return this.indexWriter.getInfoStream();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setUseCompoundFile(boolean useCompoundFile) {
/* 412 */     synchronized (this.directory) {
/* 413 */       assureOpen();
/* 414 */       if (this.indexWriter != null) {
/* 415 */         this.indexWriter.setUseCompoundFile(useCompoundFile);
/*     */       }
/* 417 */       this.useCompoundFile = useCompoundFile;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean getUseCompoundFile() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 430 */     synchronized (this.directory) {
/* 431 */       assureOpen();
/* 432 */       createIndexWriter();
/* 433 */       return this.indexWriter.getUseCompoundFile();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxFieldLength(int maxFieldLength) {
/* 452 */     synchronized (this.directory) {
/* 453 */       assureOpen();
/* 454 */       if (this.indexWriter != null) {
/* 455 */         this.indexWriter.setMaxFieldLength(maxFieldLength);
/*     */       }
/* 457 */       this.maxFieldLength = maxFieldLength;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMaxFieldLength() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 470 */     synchronized (this.directory) {
/* 471 */       assureOpen();
/* 472 */       createIndexWriter();
/* 473 */       return this.indexWriter.getMaxFieldLength();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMaxBufferedDocs(int maxBufferedDocs) {
/* 491 */     synchronized (this.directory) {
/* 492 */       assureOpen();
/* 493 */       if (this.indexWriter != null) {
/* 494 */         this.indexWriter.setMaxBufferedDocs(maxBufferedDocs);
/*     */       }
/* 496 */       this.maxBufferedDocs = maxBufferedDocs;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMaxBufferedDocs() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 509 */     synchronized (this.directory) {
/* 510 */       assureOpen();
/* 511 */       createIndexWriter();
/* 512 */       return this.indexWriter.getMaxBufferedDocs();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setMergeFactor(int mergeFactor) {
/* 530 */     synchronized (this.directory) {
/* 531 */       assureOpen();
/* 532 */       if (this.indexWriter != null) {
/* 533 */         this.indexWriter.setMergeFactor(mergeFactor);
/*     */       }
/* 535 */       this.mergeFactor = mergeFactor;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int getMergeFactor() throws CorruptIndexException, LockObtainFailedException, IOException {
/* 548 */     synchronized (this.directory) {
/* 549 */       assureOpen();
/* 550 */       createIndexWriter();
/* 551 */       return this.indexWriter.getMergeFactor();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws CorruptIndexException, IOException {
/* 563 */     synchronized (this.directory) {
/* 564 */       if (!this.open)
/* 565 */         throw new IllegalStateException(""Index is closed already""); 
/* 566 */       if (this.indexWriter != null) {
/* 567 */         this.indexWriter.close();
/* 568 */         this.indexWriter = null;
/*     */       } else {
/* 570 */         this.indexReader.close();
/* 571 */         this.indexReader = null;
/*     */       } 
/* 573 */       this.open = false;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 578 */   public String toString() { return ""Index@"" + this.directory; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexModifier.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileOutputStream;
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Collection;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.store.AlreadyClosedException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.FSDirectory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.Lock;
/*     */ import org.apache.lucene.store.LockObtainFailedException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexReader
/*     */ {
/*     */   private Directory directory;
/*     */   private boolean directoryOwner;
/*     */   private boolean closeDirectory;
/*     */   private IndexDeletionPolicy deletionPolicy;
/*     */   private boolean closed;
/*     */   private SegmentInfos segmentInfos;
/*     */   private Lock writeLock;
/*     */   private boolean stale;
/*     */   private boolean hasChanges;
/*     */   private boolean rollbackHasChanges;
/*     */   private SegmentInfos rollbackSegmentInfos;
/*     */   
/*     */   public static final class FieldOption
/*     */   {
/*     */     private String option;
/*     */     
/*     */     private FieldOption() {}
/*     */     
/*  61 */     private FieldOption(String option) { this.option = option; }
/*     */ 
/*     */     
/*  64 */     public String toString() { return this.option; }
/*     */ 
/*     */     
/*  67 */     public static final FieldOption ALL = new FieldOption(""ALL"");
/*     */     
/*  69 */     public static final FieldOption INDEXED = new FieldOption(""INDEXED"");
/*     */     
/*  71 */     public static final FieldOption STORES_PAYLOADS = new FieldOption(""STORES_PAYLOADS"");
/*     */     
/*  73 */     public static final FieldOption UNINDEXED = new FieldOption(""UNINDEXED"");
/*     */     
/*  75 */     public static final FieldOption INDEXED_WITH_TERMVECTOR = new FieldOption(""INDEXED_WITH_TERMVECTOR"");
/*     */     
/*  77 */     public static final FieldOption INDEXED_NO_TERMVECTOR = new FieldOption(""INDEXED_NO_TERMVECTOR"");
/*     */     
/*  79 */     public static final FieldOption TERMVECTOR = new FieldOption(""TERMVECTOR"");
/*     */     
/*  81 */     public static final FieldOption TERMVECTOR_WITH_POSITION = new FieldOption(""TERMVECTOR_WITH_POSITION"");
/*     */     
/*  83 */     public static final FieldOption TERMVECTOR_WITH_OFFSET = new FieldOption(""TERMVECTOR_WITH_OFFSET"");
/*     */     
/*  85 */     public static final FieldOption TERMVECTOR_WITH_POSITION_OFFSET = new FieldOption(""TERMVECTOR_WITH_POSITION_OFFSET"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   protected IndexReader(Directory directory) { this.directory = directory; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   IndexReader(Directory directory, SegmentInfos segmentInfos, boolean closeDirectory) { init(directory, segmentInfos, closeDirectory, true); }
/*     */ 
/*     */   
/*     */   void init(Directory directory, SegmentInfos segmentInfos, boolean closeDirectory, boolean directoryOwner) {
/* 111 */     this.directory = directory;
/* 112 */     this.segmentInfos = segmentInfos;
/* 113 */     this.directoryOwner = directoryOwner;
/* 114 */     this.closeDirectory = closeDirectory;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final void ensureOpen() throws AlreadyClosedException {
/* 127 */     if (this.closed) {
/* 128 */       throw new AlreadyClosedException(""this IndexReader is closed"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 148 */   public static IndexReader open(String path) throws CorruptIndexException, IOException { return open((Directory)FSDirectory.getDirectory(path), true, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 158 */   public static IndexReader open(File path) throws CorruptIndexException, IOException { return open((Directory)FSDirectory.getDirectory(path), true, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 167 */   public static IndexReader open(Directory directory) throws CorruptIndexException, IOException { return open(directory, false, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 180 */   public static IndexReader open(Directory directory, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException { return open(directory, false, deletionPolicy); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 185 */   private static IndexReader open(Directory directory, final boolean closeDirectory, final IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException { return (IndexReader)(new SegmentInfos.FindSegmentsFile(directory)
/*     */       {
/*     */         protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
/*     */           IndexReader reader;
/* 189 */           SegmentInfos infos = new SegmentInfos();
/* 190 */           infos.read(this.directory, segmentFileName);
/*     */ 
/*     */ 
/*     */           
/* 194 */           if (infos.size() == 1) {
/* 195 */             reader = SegmentReader.get(infos, infos.info(0), closeDirectory);
/*     */ 
/*     */           
/*     */           }
/*     */           else {
/*     */ 
/*     */ 
/*     */             
/* 203 */             IndexReader[] readers = new IndexReader[infos.size()];
/* 204 */             for (int i = infos.size() - 1; i >= 0; i--) {
/*     */               try {
/* 206 */                 readers[i] = SegmentReader.get(infos.info(i));
/* 207 */               } catch (IOException e) {
/*     */                 
/* 209 */                 for (; ++i < infos.size(); i++) {
/* 210 */                   readers[i].close();
/*     */                 }
/* 212 */                 throw e;
/*     */               } 
/*     */             } 
/*     */             
/* 216 */             reader = new MultiReader(this.directory, infos, closeDirectory, readers);
/*     */           } 
/* 218 */           reader.deletionPolicy = deletionPolicy;
/* 219 */           return reader;
/*     */         }
/*     */         
/*     */         private final boolean val$closeDirectory;
/*     */         private final IndexDeletionPolicy val$deletionPolicy;
/*     */       }).run(); }
/*     */   
/*     */   public Directory directory() {
/* 227 */     ensureOpen();
/* 228 */     return this.directory;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 239 */   public static long lastModified(String directory) throws CorruptIndexException, IOException { return lastModified(new File(directory)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 250 */   public static long lastModified(File fileDirectory) throws CorruptIndexException, IOException { return ((Long)(new SegmentInfos.FindSegmentsFile(fileDirectory)
/*     */       {
/* 252 */         public Object doBody(String segmentFileName) { return new Long(FSDirectory.fileModified(this.fileDirectory, segmentFileName)); }
/*     */       }).run()).longValue(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 265 */   public static long lastModified(final Directory directory2) throws CorruptIndexException, IOException { return ((Long)(new SegmentInfos.FindSegmentsFile(directory2)
/*     */       {
/* 267 */         public Object doBody(String segmentFileName) throws IOException { return new Long(directory2.fileModified(segmentFileName)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*     */         private final Directory val$directory2;
/*     */       }).run()).longValue(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 283 */   public static long getCurrentVersion(String directory) throws CorruptIndexException, IOException { return getCurrentVersion(new File(directory)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long getCurrentVersion(File directory) throws CorruptIndexException, IOException {
/* 297 */     FSDirectory fSDirectory = FSDirectory.getDirectory(directory);
/* 298 */     long version = getCurrentVersion((Directory)fSDirectory);
/* 299 */     fSDirectory.close();
/* 300 */     return version;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 314 */   public static long getCurrentVersion(Directory directory) throws CorruptIndexException, IOException { return SegmentInfos.readCurrentVersion(directory); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long getVersion() {
/* 321 */     ensureOpen();
/* 322 */     return this.segmentInfos.getVersion();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isCurrent() throws CorruptIndexException, IOException {
/* 340 */     ensureOpen();
/* 341 */     return (SegmentInfos.readCurrentVersion(this.directory) == this.segmentInfos.getVersion());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isOptimized() {
/* 349 */     ensureOpen();
/* 350 */     return (this.segmentInfos.size() == 1 && !hasDeletions());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 396 */   public static boolean indexExists(String directory) { return indexExists(new File(directory)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 407 */   public static boolean indexExists(File directory) { return (SegmentInfos.getCurrentSegmentGeneration(directory.list()) != -1L); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 418 */   public static boolean indexExists(Directory directory) throws IOException { return (SegmentInfos.getCurrentSegmentGeneration(directory) != -1L); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Document document(int n) throws CorruptIndexException, IOException {
/* 436 */     ensureOpen();
/* 437 */     return document(n, null);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 475 */     ensureOpen();
/* 476 */     return (norms(field) != null);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void setNorm(int doc, String field, byte value) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 512 */     ensureOpen();
/* 513 */     if (this.directoryOwner)
/* 514 */       acquireWriteLock(); 
/* 515 */     this.hasChanges = true;
/* 516 */     doSetNorm(doc, field, value);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setNorm(int doc, String field, float value) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 539 */     ensureOpen();
/* 540 */     setNorm(doc, field, Similarity.encodeNorm(value));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermDocs termDocs(Term term) throws IOException {
/* 579 */     ensureOpen();
/* 580 */     TermDocs termDocs = termDocs();
/* 581 */     termDocs.seek(term);
/* 582 */     return termDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermPositions termPositions(Term term) throws IOException {
/* 608 */     ensureOpen();
/* 609 */     TermPositions termPositions = termPositions();
/* 610 */     termPositions.seek(term);
/* 611 */     return termPositions;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void acquireWriteLock() throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 632 */     ensureOpen();
/* 633 */     if (this.stale) {
/* 634 */       throw new StaleReaderException(""IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"");
/*     */     }
/* 636 */     if (this.writeLock == null) {
/* 637 */       Lock writeLock = this.directory.makeLock(""write.lock"");
/* 638 */       if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT))
/* 639 */         throw new LockObtainFailedException(""Index locked for write: "" + writeLock); 
/* 640 */       this.writeLock = writeLock;
/*     */ 
/*     */ 
/*     */       
/* 644 */       if (SegmentInfos.readCurrentVersion(this.directory) > this.segmentInfos.getVersion()) {
/* 645 */         this.stale = true;
/* 646 */         this.writeLock.release();
/* 647 */         this.writeLock = null;
/* 648 */         throw new StaleReaderException(""IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"");
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void deleteDocument(int docNum) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 670 */     ensureOpen();
/* 671 */     if (this.directoryOwner)
/* 672 */       acquireWriteLock(); 
/* 673 */     this.hasChanges = true;
/* 674 */     doDelete(docNum);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int deleteDocuments(Term term) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 702 */     ensureOpen();
/* 703 */     TermDocs docs = termDocs(term);
/* 704 */     if (docs == null) return 0; 
/* 705 */     int n = 0;
/*     */     try {
/* 707 */       while (docs.next()) {
/* 708 */         deleteDocument(docs.doc());
/* 709 */         n++;
/*     */       } 
/*     */     } finally {
/* 712 */       docs.close();
/*     */     } 
/* 714 */     return n;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void undeleteAll() throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
/* 728 */     ensureOpen();
/* 729 */     if (this.directoryOwner)
/* 730 */       acquireWriteLock(); 
/* 731 */     this.hasChanges = true;
/* 732 */     doUndeleteAll();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void startCommit() {
/* 743 */     if (this.directoryOwner) {
/* 744 */       this.rollbackSegmentInfos = (SegmentInfos)this.segmentInfos.clone();
/*     */     }
/* 746 */     this.rollbackHasChanges = this.hasChanges;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void rollbackCommit() {
/* 755 */     if (this.directoryOwner) {
/* 756 */       for (int i = 0; i < this.segmentInfos.size(); i++)
/*     */       {
/*     */ 
/*     */ 
/*     */         
/* 761 */         this.segmentInfos.info(i).reset(this.rollbackSegmentInfos.info(i));
/*     */       }
/* 763 */       this.rollbackSegmentInfos = null;
/*     */     } 
/*     */     
/* 766 */     this.hasChanges = this.rollbackHasChanges;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final synchronized void commit() throws IOException {
/* 779 */     if (this.hasChanges)
/* 780 */       if (this.directoryOwner) {
/*     */ 
/*     */ 
/*     */         
/* 784 */         IndexFileDeleter deleter = new IndexFileDeleter(this.directory, (this.deletionPolicy == null) ? new KeepOnlyLastCommitDeletionPolicy() : this.deletionPolicy, this.segmentInfos, null);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 790 */         startCommit();
/*     */         
/* 792 */         boolean success = false;
/*     */         try {
/* 794 */           doCommit();
/* 795 */           this.segmentInfos.write(this.directory);
/* 796 */           success = true;
/*     */         } finally {
/*     */           
/* 799 */           if (!success) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 806 */             rollbackCommit();
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 811 */             deleter.refresh();
/*     */           } 
/*     */         } 
/*     */ 
/*     */ 
/*     */         
/* 817 */         deleter.checkpoint(this.segmentInfos, true);
/*     */         
/* 819 */         if (this.writeLock != null) {
/* 820 */           this.writeLock.release();
/* 821 */           this.writeLock = null;
/*     */         } 
/*     */       } else {
/*     */         
/* 825 */         doCommit();
/*     */       }  
/* 827 */     this.hasChanges = false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void close() throws IOException {
/* 840 */     if (!this.closed) {
/* 841 */       commit();
/* 842 */       doClose();
/* 843 */       if (this.directoryOwner)
/* 844 */         this.closed = true; 
/* 845 */       if (this.closeDirectory) {
/* 846 */         this.directory.close();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void finalize() throws Throwable {
/*     */     try {
/* 856 */       if (this.writeLock != null) {
/* 857 */         this.writeLock.release();
/* 858 */         this.writeLock = null;
/*     */       } 
/*     */     } finally {
/* 861 */       super.finalize();
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 882 */   public static boolean isLocked(Directory directory) throws IOException { return directory.makeLock(""write.lock"").isLocked(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static boolean isLocked(String directory) throws IOException {
/* 893 */     FSDirectory fSDirectory = FSDirectory.getDirectory(directory);
/* 894 */     boolean result = isLocked((Directory)fSDirectory);
/* 895 */     fSDirectory.close();
/* 896 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 907 */   public static void unlock(Directory directory) throws IOException { directory.makeLock(""write.lock"").release(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) {
/* 918 */     String filename = null;
/* 919 */     boolean extract = false;
/*     */     
/* 921 */     for (int i = 0; i < args.length; i++) {
/* 922 */       if (args[i].equals(""-extract"")) {
/* 923 */         extract = true;
/* 924 */       } else if (filename == null) {
/* 925 */         filename = args[i];
/*     */       } 
/*     */     } 
/*     */     
/* 929 */     if (filename == null) {
/* 930 */       System.out.println(""Usage: org.apache.lucene.index.IndexReader [-extract] <cfsfile>"");
/*     */       
/*     */       return;
/*     */     } 
/* 934 */     Object object = null;
/* 935 */     CompoundFileReader cfr = null;
/*     */     
/*     */     try {
/* 938 */       File file = new File(filename);
/* 939 */       String dirname = file.getAbsoluteFile().getParent();
/* 940 */       filename = file.getName();
/* 941 */       object = FSDirectory.getDirectory(dirname);
/* 942 */       cfr = new CompoundFileReader((Directory)object, filename);
/*     */       
/* 944 */       String[] files = cfr.list();
/* 945 */       Arrays.sort((Object[])files);
/*     */       
/* 947 */       for (int i = 0; i < files.length; i++) {
/* 948 */         long len = cfr.fileLength(files[i]);
/*     */         
/* 950 */         if (extract)
/* 951 */         { System.out.println(""extract "" + files[i] + "" with "" + len + "" bytes to local directory..."");
/* 952 */           IndexInput ii = cfr.openInput(files[i]);
/*     */           
/* 954 */           FileOutputStream f = new FileOutputStream(files[i]);
/*     */ 
/*     */           
/* 957 */           byte[] buffer = new byte[1024];
/* 958 */           int chunk = buffer.length;
/* 959 */           while (len > 0L) {
/* 960 */             int bufLen = (int)Math.min(chunk, len);
/* 961 */             ii.readBytes(buffer, 0, bufLen);
/* 962 */             f.write(buffer, 0, bufLen);
/* 963 */             len -= bufLen;
/*     */           } 
/*     */           
/* 966 */           f.close();
/* 967 */           ii.close(); }
/*     */         else
/*     */         
/* 970 */         { System.out.println(files[i] + "": "" + len + "" bytes""); } 
/*     */       } 
/* 972 */     } catch (IOException ioe) {
/* 973 */       ioe.printStackTrace();
/*     */     } finally {
/*     */       
/*     */       try {
/* 977 */         if (object != null)
/* 978 */           object.close(); 
/* 979 */         if (cfr != null) {
/* 980 */           cfr.close();
/*     */         }
/* 982 */       } catch (IOException ioe) {
/* 983 */         ioe.printStackTrace();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public abstract TermFreqVector[] getTermFreqVectors(int paramInt) throws IOException;
/*     */   
/*     */   public abstract TermFreqVector getTermFreqVector(int paramInt, String paramString) throws IOException;
/*     */   
/*     */   public abstract int numDocs();
/*     */   
/*     */   public abstract int maxDoc();
/*     */   
/*     */   public abstract Document document(int paramInt, FieldSelector paramFieldSelector) throws CorruptIndexException, IOException;
/*     */   
/*     */   public abstract boolean isDeleted(int paramInt);
/*     */   
/*     */   public abstract boolean hasDeletions();
/*     */   
/*     */   public abstract byte[] norms(String paramString) throws IOException;
/*     */   
/*     */   public abstract void norms(String paramString, byte[] paramArrayOfbyte, int paramInt) throws IOException;
/*     */   
/*     */   protected abstract void doSetNorm(int paramInt, String paramString, byte paramByte) throws CorruptIndexException, IOException;
/*     */   
/*     */   public abstract TermEnum terms() throws IOException;
/*     */   
/*     */   public abstract TermEnum terms(Term paramTerm) throws IOException;
/*     */   
/*     */   public abstract int docFreq(Term paramTerm) throws IOException;
/*     */   
/*     */   public abstract TermDocs termDocs() throws IOException;
/*     */   
/*     */   public abstract TermPositions termPositions() throws IOException;
/*     */   
/*     */   protected abstract void doDelete(int paramInt) throws CorruptIndexException, IOException;
/*     */   
/*     */   protected abstract void doUndeleteAll() throws CorruptIndexException, IOException;
/*     */   
/*     */   protected abstract void doCommit() throws IOException;
/*     */   
/*     */   protected abstract void doClose() throws IOException;
/*     */   
/*     */   public abstract Collection getFieldNames(FieldOption paramFieldOption);
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.IndexWriter,"/*      */ package org.apache.lucene.index;
/*      */ 
/*      */ import java.io.File;
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ import java.util.ArrayList;
/*      */ import java.util.HashMap;
/*      */ import java.util.Iterator;
/*      */ import java.util.List;
/*      */ import java.util.Map;
/*      */ import org.apache.lucene.analysis.Analyzer;
/*      */ import org.apache.lucene.document.Document;
/*      */ import org.apache.lucene.search.Similarity;
/*      */ import org.apache.lucene.store.AlreadyClosedException;
/*      */ import org.apache.lucene.store.Directory;
/*      */ import org.apache.lucene.store.FSDirectory;
/*      */ import org.apache.lucene.store.Lock;
/*      */ import org.apache.lucene.store.LockObtainFailedException;
/*      */ import org.apache.lucene.store.RAMDirectory;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class IndexWriter
/*      */ {
/*  167 */   public static long WRITE_LOCK_TIMEOUT = 1000L;
/*      */   
/*  169 */   private long writeLockTimeout = WRITE_LOCK_TIMEOUT;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final String WRITE_LOCK_NAME = ""write.lock"";
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MERGE_FACTOR = 10;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_BUFFERED_DOCS = 10;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_BUFFERED_DELETE_TERMS = 1000;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_MERGE_DOCS = 2147483647;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_MAX_FIELD_LENGTH = 10000;
/*      */ 
/*      */ 
/*      */   
/*      */   public static final int DEFAULT_TERM_INDEX_INTERVAL = 128;
/*      */ 
/*      */ 
/*      */   
/*      */   private static final int MERGE_READ_BUFFER_SIZE = 4096;
/*      */ 
/*      */ 
/*      */   
/*      */   private Directory directory;
/*      */ 
/*      */ 
/*      */   
/*      */   private Analyzer analyzer;
/*      */ 
/*      */ 
/*      */   
/*  217 */   private Similarity similarity = Similarity.getDefault();
/*      */   
/*      */   private boolean commitPending;
/*      */   
/*      */   private SegmentInfos rollbackSegmentInfos;
/*      */   
/*      */   private SegmentInfos localRollbackSegmentInfos;
/*      */   private boolean localAutoCommit;
/*      */   private boolean autoCommit = true;
/*  226 */   SegmentInfos segmentInfos = new SegmentInfos();
/*  227 */   SegmentInfos ramSegmentInfos = new SegmentInfos();
/*  228 */   private final RAMDirectory ramDirectory = new RAMDirectory();
/*      */   
/*      */   private IndexFileDeleter deleter;
/*      */   
/*      */   private Lock writeLock;
/*  233 */   private int termIndexInterval = 128;
/*      */ 
/*      */ 
/*      */   
/*  237 */   private int maxBufferedDeleteTerms = 1000;
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  242 */   private HashMap bufferedDeleteTerms = new HashMap();
/*  243 */   private int numBufferedDeleteTerms = 0;
/*      */   
/*      */   private boolean useCompoundFile = true;
/*      */   
/*      */   private boolean closeDir;
/*      */   
/*      */   private boolean closed;
/*      */   
/*      */   private int maxFieldLength;
/*      */   
/*      */   private int mergeFactor;
/*      */   
/*      */   private int minMergeDocs;
/*      */   
/*      */   private int maxMergeDocs;
/*      */   private PrintStream infoStream;
/*      */   
/*      */   protected final void ensureOpen() throws AlreadyClosedException {
/*  261 */     if (this.closed) {
/*  262 */       throw new AlreadyClosedException(""this IndexWriter is closed"");
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public boolean getUseCompoundFile() {
/*  272 */     ensureOpen();
/*  273 */     return this.useCompoundFile;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setUseCompoundFile(boolean value) {
/*  281 */     ensureOpen();
/*  282 */     this.useCompoundFile = value;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setSimilarity(Similarity similarity) {
/*  290 */     ensureOpen();
/*  291 */     this.similarity = similarity;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Similarity getSimilarity() {
/*  299 */     ensureOpen();
/*  300 */     return this.similarity;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setTermIndexInterval(int interval) {
/*  325 */     ensureOpen();
/*  326 */     this.termIndexInterval = interval;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getTermIndexInterval() {
/*  334 */     ensureOpen();
/*  335 */     return this.termIndexInterval;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void init(Directory d, Analyzer a, boolean closeDir, IndexDeletionPolicy deletionPolicy, boolean autoCommit) throws CorruptIndexException, LockObtainFailedException, IOException {
/*  578 */     if (IndexReader.indexExists(d)) {
/*  579 */       init(d, a, false, closeDir, deletionPolicy, autoCommit);
/*      */     } else {
/*  581 */       init(d, a, true, closeDir, deletionPolicy, autoCommit);
/*      */     } 
/*      */   }
/*      */ 
/*      */   
/*      */   private void init(Directory d, Analyzer a, boolean create, boolean closeDir, IndexDeletionPolicy deletionPolicy, boolean autoCommit) throws CorruptIndexException, LockObtainFailedException, IOException {
/*  587 */     this.closeDir = closeDir;
/*  588 */     this.directory = d;
/*  589 */     this.analyzer = a;
/*  590 */     this.infoStream = defaultInfoStream;
/*      */     
/*  592 */     if (create)
/*      */     {
/*  594 */       this.directory.clearLock(""write.lock"");
/*      */     }
/*      */     
/*  597 */     Lock writeLock = this.directory.makeLock(""write.lock"");
/*  598 */     if (!writeLock.obtain(this.writeLockTimeout))
/*  599 */       throw new LockObtainFailedException(""Index locked for write: "" + writeLock); 
/*  600 */     this.writeLock = writeLock;
/*      */     
/*      */     try {
/*  603 */       if (create) {
/*      */ 
/*      */         
/*      */         try {
/*      */ 
/*      */           
/*  609 */           this.segmentInfos.read(this.directory);
/*  610 */           this.segmentInfos.clear();
/*  611 */         } catch (IOException e) {}
/*      */ 
/*      */         
/*  614 */         this.segmentInfos.write(this.directory);
/*      */       } else {
/*  616 */         this.segmentInfos.read(this.directory);
/*      */       } 
/*      */       
/*  619 */       this.autoCommit = autoCommit;
/*  620 */       if (!autoCommit) {
/*  621 */         this.rollbackSegmentInfos = (SegmentInfos)this.segmentInfos.clone();
/*      */       }
/*      */ 
/*      */ 
/*      */       
/*  626 */       this.deleter = new IndexFileDeleter(this.directory, (deletionPolicy == null) ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy, this.segmentInfos, this.infoStream);
/*      */ 
/*      */     
/*      */     }
/*  630 */     catch (IOException e) {
/*  631 */       this.writeLock.release();
/*  632 */       this.writeLock = null;
/*  633 */       throw e;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxMergeDocs(int maxMergeDocs) {
/*  645 */     ensureOpen();
/*  646 */     this.maxMergeDocs = maxMergeDocs;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxMergeDocs() {
/*  655 */     ensureOpen();
/*  656 */     return this.maxMergeDocs;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxFieldLength(int maxFieldLength) {
/*  672 */     ensureOpen();
/*  673 */     this.maxFieldLength = maxFieldLength;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxFieldLength() {
/*  682 */     ensureOpen();
/*  683 */     return this.maxFieldLength;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxBufferedDocs(int maxBufferedDocs) {
/*  697 */     ensureOpen();
/*  698 */     if (maxBufferedDocs < 2)
/*  699 */       throw new IllegalArgumentException(""maxBufferedDocs must at least be 2""); 
/*  700 */     this.minMergeDocs = maxBufferedDocs;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxBufferedDocs() {
/*  709 */     ensureOpen();
/*  710 */     return this.minMergeDocs;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMaxBufferedDeleteTerms(int maxBufferedDeleteTerms) {
/*  723 */     ensureOpen();
/*  724 */     if (maxBufferedDeleteTerms < 1)
/*  725 */       throw new IllegalArgumentException(""maxBufferedDeleteTerms must at least be 1""); 
/*  726 */     this.maxBufferedDeleteTerms = maxBufferedDeleteTerms;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMaxBufferedDeleteTerms() {
/*  735 */     ensureOpen();
/*  736 */     return this.maxBufferedDeleteTerms;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setMergeFactor(int mergeFactor) {
/*  750 */     ensureOpen();
/*  751 */     if (mergeFactor < 2)
/*  752 */       throw new IllegalArgumentException(""mergeFactor cannot be less than 2""); 
/*  753 */     this.mergeFactor = mergeFactor;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public int getMergeFactor() {
/*  763 */     ensureOpen();
/*  764 */     return this.mergeFactor;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  772 */   public static void setDefaultInfoStream(PrintStream infoStream) { defaultInfoStream = infoStream; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  781 */   public static PrintStream getDefaultInfoStream() { return defaultInfoStream; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setInfoStream(PrintStream infoStream) {
/*  789 */     ensureOpen();
/*  790 */     this.infoStream = infoStream;
/*  791 */     this.deleter.setInfoStream(infoStream);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public PrintStream getInfoStream() {
/*  799 */     ensureOpen();
/*  800 */     return this.infoStream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setWriteLockTimeout(long writeLockTimeout) {
/*  808 */     ensureOpen();
/*  809 */     this.writeLockTimeout = writeLockTimeout;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public long getWriteLockTimeout() {
/*  817 */     ensureOpen();
/*  818 */     return this.writeLockTimeout;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  826 */   public static void setDefaultWriteLockTimeout(long writeLockTimeout) { WRITE_LOCK_TIMEOUT = writeLockTimeout; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  835 */   public static long getDefaultWriteLockTimeout() { return WRITE_LOCK_TIMEOUT; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void close() throws CorruptIndexException, IOException {
/*  873 */     if (!this.closed) {
/*  874 */       flushRamSegments();
/*      */       
/*  876 */       if (this.commitPending) {
/*  877 */         this.segmentInfos.write(this.directory);
/*  878 */         this.deleter.checkpoint(this.segmentInfos, true);
/*  879 */         this.commitPending = false;
/*  880 */         this.rollbackSegmentInfos = null;
/*      */       } 
/*      */       
/*  883 */       this.ramDirectory.close();
/*  884 */       if (this.writeLock != null) {
/*  885 */         this.writeLock.release();
/*  886 */         this.writeLock = null;
/*      */       } 
/*  888 */       this.closed = true;
/*      */       
/*  890 */       if (this.closeDir) {
/*  891 */         this.directory.close();
/*      */       }
/*      */     } 
/*      */   }
/*      */   
/*      */   protected void finalize() throws Throwable {
/*      */     try {
/*  898 */       if (this.writeLock != null) {
/*  899 */         this.writeLock.release();
/*  900 */         this.writeLock = null;
/*      */       } 
/*      */     } finally {
/*  903 */       super.finalize();
/*      */     } 
/*      */   }
/*      */ 
/*      */   
/*      */   public Directory getDirectory() {
/*  909 */     ensureOpen();
/*  910 */     return this.directory;
/*      */   }
/*      */ 
/*      */   
/*      */   public Analyzer getAnalyzer() {
/*  915 */     ensureOpen();
/*  916 */     return this.analyzer;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized int docCount() {
/*  922 */     ensureOpen();
/*  923 */     int count = this.ramSegmentInfos.size();
/*  924 */     for (int i = 0; i < this.segmentInfos.size(); i++) {
/*  925 */       SegmentInfo si = this.segmentInfos.info(i);
/*  926 */       count += si.docCount;
/*      */     } 
/*  928 */     return count;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public IndexWriter(String path, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException
/*      */   {
/*  944 */     this.maxFieldLength = 10000;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1126 */     this.mergeFactor = 10;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1137 */     this.minMergeDocs = 10;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1148 */     this.maxMergeDocs = Integer.MAX_VALUE;
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1153 */     this.infoStream = null; init((Directory)FSDirectory.getDirectory(path), a, create, true, null, true); } public IndexWriter(File path, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init((Directory)FSDirectory.getDirectory(path), a, create, true, null, true); } public IndexWriter(Directory d, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init(d, a, create, false, null, true); } public IndexWriter(String path, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init((Directory)FSDirectory.getDirectory(path), a, true, null, true); } public IndexWriter(File path, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init((Directory)FSDirectory.getDirectory(path), a, true, null, true); } public IndexWriter(Directory d, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init(d, a, false, null, true); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init(d, a, false, null, autoCommit); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init(d, a, create, false, null, autoCommit); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null; init(d, a, false, deletionPolicy, autoCommit); } public IndexWriter(Directory d, boolean autoCommit, Analyzer a, boolean create, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, LockObtainFailedException, IOException { this.maxFieldLength = 10000; this.mergeFactor = 10; this.minMergeDocs = 10; this.maxMergeDocs = Integer.MAX_VALUE; this.infoStream = null;
/* 1154 */     init(d, a, create, false, deletionPolicy, autoCommit); } public void addDocument(Document doc) throws CorruptIndexException, IOException { addDocument(doc, this.analyzer); } private static PrintStream defaultInfoStream = null;
/*      */ 
/*      */   
/*      */   public void addDocument(Document doc, Analyzer analyzer) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     SegmentInfo newSegmentInfo = buildSingleDocSegment(doc, analyzer);
/*      */     synchronized (this) {
/*      */       this.ramSegmentInfos.addElement((E)newSegmentInfo);
/*      */       maybeFlushRamSegments();
/*      */     } 
/*      */   }
/*      */   
/*      */   SegmentInfo buildSingleDocSegment(Document doc, Analyzer analyzer) throws CorruptIndexException, IOException {
/*      */     DocumentWriter dw = new DocumentWriter((Directory)this.ramDirectory, analyzer, this);
/*      */     dw.setInfoStream(this.infoStream);
/*      */     String segmentName = newRamSegmentName();
/*      */     dw.addDocument(segmentName, doc);
/*      */     SegmentInfo si = new SegmentInfo(segmentName, 1, (Directory)this.ramDirectory, false, false);
/*      */     si.setNumFields(dw.getNumFields());
/*      */     return si;
/*      */   }
/*      */   
/*      */   public synchronized void deleteDocuments(Term term) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     bufferDeleteTerm(term);
/*      */     maybeFlushRamSegments();
/*      */   }
/*      */   
/*      */   public synchronized void deleteDocuments(Term[] terms) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     for (int i = 0; i < terms.length; i++) {
/*      */       bufferDeleteTerm(terms[i]);
/*      */     }
/*      */     maybeFlushRamSegments();
/*      */   }
/*      */   
/*      */   public void updateDocument(Term term, Document doc) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     updateDocument(term, doc, getAnalyzer());
/*      */   }
/*      */   
/*      */   public void updateDocument(Term term, Document doc, Analyzer analyzer) throws CorruptIndexException, IOException {
/*      */     ensureOpen();
/*      */     SegmentInfo newSegmentInfo = buildSingleDocSegment(doc, analyzer);
/*      */     synchronized (this) {
/*      */       bufferDeleteTerm(term);
/*      */       this.ramSegmentInfos.addElement((E)newSegmentInfo);
/*      */       maybeFlushRamSegments();
/*      */     } 
/*      */   }
/*      */   
/*      */   final synchronized String newRamSegmentName() { return ""_ram_"" + Integer.toString(this.ramSegmentInfos.counter++, 36); }
/*      */   
/*      */   final synchronized int getSegmentCount() { return this.segmentInfos.size(); }
/*      */   
/*      */   final synchronized int getRamSegmentCount() { return this.ramSegmentInfos.size(); }
/*      */   
/*      */   final synchronized int getDocCount(int i) {
/*      */     if (i >= 0 && i < this.segmentInfos.size()) {
/*      */       return (this.segmentInfos.info(i)).docCount;
/*      */     }
/*      */     return -1;
/*      */   }
/*      */   
/*      */   final synchronized String newSegmentName() { return ""_"" + Integer.toString(this.segmentInfos.counter++, 36); }
/*      */   
/*      */   public synchronized void optimize() throws CorruptIndexException, IOException {
/* 1221 */     ensureOpen();
/* 1222 */     flushRamSegments();
/* 1223 */     while (this.segmentInfos.size() > 1 || (this.segmentInfos.size() == 1 && (SegmentReader.hasDeletions(this.segmentInfos.info(0)) || SegmentReader.hasSeparateNorms(this.segmentInfos.info(0)) || (this.segmentInfos.info(0)).dir != this.directory || (this.useCompoundFile && !SegmentReader.usesCompoundFile(this.segmentInfos.info(0)))))) {
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 1230 */       int minSegment = this.segmentInfos.size() - this.mergeFactor;
/* 1231 */       mergeSegments(this.segmentInfos, (minSegment < 0) ? 0 : minSegment, this.segmentInfos.size());
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void startTransaction() throws IOException {
/* 1245 */     this.localRollbackSegmentInfos = (SegmentInfos)this.segmentInfos.clone();
/* 1246 */     this.localAutoCommit = this.autoCommit;
/* 1247 */     if (this.localAutoCommit) {
/* 1248 */       flushRamSegments();
/*      */       
/* 1250 */       this.autoCommit = false;
/*      */     }
/*      */     else {
/*      */       
/* 1254 */       this.deleter.incRef(this.segmentInfos, false);
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void rollbackTransaction() throws IOException {
/* 1264 */     this.autoCommit = this.localAutoCommit;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1270 */     this.segmentInfos.clear();
/* 1271 */     this.segmentInfos.addAll(this.localRollbackSegmentInfos);
/* 1272 */     this.localRollbackSegmentInfos = null;
/*      */ 
/*      */ 
/*      */     
/* 1276 */     this.deleter.checkpoint(this.segmentInfos, false);
/*      */     
/* 1278 */     if (!this.autoCommit)
/*      */     {
/* 1280 */       this.deleter.decRef(this.segmentInfos);
/*      */     }
/* 1282 */     this.deleter.refresh();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void commitTransaction() throws IOException {
/* 1293 */     this.autoCommit = this.localAutoCommit;
/*      */     
/* 1295 */     boolean success = false;
/*      */     try {
/* 1297 */       checkpoint();
/* 1298 */       success = true;
/*      */     } finally {
/* 1300 */       if (!success) {
/* 1301 */         rollbackTransaction();
/*      */       }
/*      */     } 
/*      */     
/* 1305 */     if (!this.autoCommit)
/*      */     {
/* 1307 */       this.deleter.decRef(this.localRollbackSegmentInfos);
/*      */     }
/* 1309 */     this.localRollbackSegmentInfos = null;
/*      */ 
/*      */     
/* 1312 */     this.deleter.checkpoint(this.segmentInfos, this.autoCommit);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void abort() throws IOException {
/* 1328 */     ensureOpen();
/* 1329 */     if (!this.autoCommit) {
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 1335 */       this.segmentInfos.clear();
/* 1336 */       this.segmentInfos.addAll(this.rollbackSegmentInfos);
/*      */ 
/*      */ 
/*      */       
/* 1340 */       this.deleter.checkpoint(this.segmentInfos, false);
/* 1341 */       this.deleter.refresh();
/*      */       
/* 1343 */       this.ramSegmentInfos = new SegmentInfos();
/* 1344 */       this.bufferedDeleteTerms.clear();
/* 1345 */       this.numBufferedDeleteTerms = 0;
/*      */       
/* 1347 */       this.commitPending = false;
/* 1348 */       close();
/*      */     } else {
/*      */       
/* 1351 */       throw new IllegalStateException(""abort() can only be called when IndexWriter was opened with autoCommit=false"");
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void checkpoint() throws IOException {
/* 1363 */     if (this.autoCommit) {
/* 1364 */       this.segmentInfos.write(this.directory);
/*      */     } else {
/* 1366 */       this.commitPending = true;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void addIndexes(Directory[] dirs) throws CorruptIndexException, IOException {
/* 1419 */     ensureOpen();
/* 1420 */     optimize();
/*      */     
/* 1422 */     int start = this.segmentInfos.size();
/*      */     
/* 1424 */     boolean success = false;
/*      */     
/* 1426 */     startTransaction();
/*      */     
/*      */     try {
/* 1429 */       for (int i = 0; i < dirs.length; i++) {
/* 1430 */         SegmentInfos sis = new SegmentInfos();
/* 1431 */         sis.read(dirs[i]);
/* 1432 */         for (int j = 0; j < sis.size(); j++) {
/* 1433 */           this.segmentInfos.addElement((E)sis.info(j));
/*      */         }
/*      */       } 
/*      */ 
/*      */       
/* 1438 */       while (this.segmentInfos.size() > start + this.mergeFactor) {
/* 1439 */         for (int base = start; base < this.segmentInfos.size(); base++) {
/* 1440 */           int end = Math.min(this.segmentInfos.size(), base + this.mergeFactor);
/* 1441 */           if (end - base > 1) {
/* 1442 */             mergeSegments(this.segmentInfos, base, end);
/*      */           }
/*      */         } 
/*      */       } 
/* 1446 */       success = true;
/*      */     } finally {
/* 1448 */       if (success) {
/* 1449 */         commitTransaction();
/*      */       } else {
/* 1451 */         rollbackTransaction();
/*      */       } 
/*      */     } 
/*      */     
/* 1455 */     optimize();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void addIndexesNoOptimize(Directory[] dirs) throws CorruptIndexException, IOException {
/* 1505 */     ensureOpen();
/* 1506 */     flushRamSegments();
/*      */ 
/*      */     
/* 1509 */     int startUpperBound = this.minMergeDocs;
/*      */     
/* 1511 */     boolean success = false;
/*      */     
/* 1513 */     startTransaction();
/*      */ 
/*      */     
/*      */     try {
/* 1517 */       for (int i = 0; i < dirs.length; i++) {
/* 1518 */         if (this.directory == dirs[i])
/*      */         {
/* 1520 */           throw new IllegalArgumentException(""Cannot add this index to itself"");
/*      */         }
/*      */         
/* 1523 */         SegmentInfos sis = new SegmentInfos();
/* 1524 */         sis.read(dirs[i]);
/* 1525 */         for (int j = 0; j < sis.size(); j++) {
/* 1526 */           SegmentInfo info = sis.info(j);
/* 1527 */           this.segmentInfos.addElement((E)info);
/*      */           
/* 1529 */           while (startUpperBound < info.docCount) {
/* 1530 */             startUpperBound *= this.mergeFactor;
/* 1531 */             if (startUpperBound > this.maxMergeDocs)
/*      */             {
/* 1533 */               throw new IllegalArgumentException(""Upper bound cannot exceed maxMergeDocs"");
/*      */             }
/*      */           } 
/*      */         } 
/*      */       } 
/*      */ 
/*      */       
/* 1540 */       maybeMergeSegments(startUpperBound);
/*      */ 
/*      */       
/* 1543 */       int segmentCount = this.segmentInfos.size();
/* 1544 */       int numTailSegments = 0;
/*      */       
/* 1546 */       while (numTailSegments < segmentCount && startUpperBound >= (this.segmentInfos.info(segmentCount - 1 - numTailSegments)).docCount) {
/* 1547 */         numTailSegments++;
/*      */       }
/* 1549 */       if (numTailSegments == 0) {
/* 1550 */         success = true;
/*      */         
/*      */         return;
/*      */       } 
/*      */       
/* 1555 */       if (checkNonDecreasingLevels(segmentCount - numTailSegments)) {
/*      */         
/* 1557 */         int numSegmentsToCopy = 0;
/*      */         
/* 1559 */         while (numSegmentsToCopy < segmentCount && this.directory != (this.segmentInfos.info(segmentCount - 1 - numSegmentsToCopy)).dir) {
/* 1560 */           numSegmentsToCopy++;
/*      */         }
/* 1562 */         if (numSegmentsToCopy == 0) {
/* 1563 */           success = true;
/*      */           
/*      */           return;
/*      */         } 
/*      */         
/* 1568 */         for (int i = segmentCount - numSegmentsToCopy; i < segmentCount; i++) {
/* 1569 */           mergeSegments(this.segmentInfos, i, i + 1);
/*      */         }
/* 1571 */         if (checkNonDecreasingLevels(segmentCount - numSegmentsToCopy)) {
/* 1572 */           success = true;
/*      */           
/*      */           return;
/*      */         } 
/*      */       } 
/*      */       
/* 1578 */       mergeSegments(this.segmentInfos, segmentCount - numTailSegments, segmentCount);
/*      */ 
/*      */       
/* 1581 */       if ((this.segmentInfos.info(this.segmentInfos.size() - 1)).docCount > startUpperBound) {
/* 1582 */         maybeMergeSegments(startUpperBound * this.mergeFactor);
/*      */       }
/*      */       
/* 1585 */       success = true;
/*      */     } finally {
/* 1587 */       if (success) {
/* 1588 */         commitTransaction();
/*      */       } else {
/* 1590 */         rollbackTransaction();
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public synchronized void addIndexes(IndexReader[] readers) throws CorruptIndexException, IOException {
/*      */     SegmentInfo info;
/* 1609 */     ensureOpen();
/* 1610 */     optimize();
/*      */     
/* 1612 */     String mergedName = newSegmentName();
/* 1613 */     SegmentMerger merger = new SegmentMerger(this, mergedName);
/*      */ 
/*      */ 
/*      */     
/* 1617 */     IndexReader sReader = null;
/*      */     try {
/* 1619 */       if (this.segmentInfos.size() == 1) {
/* 1620 */         sReader = SegmentReader.get(this.segmentInfos.info(0));
/* 1621 */         merger.add(sReader);
/*      */       } 
/*      */       
/* 1624 */       for (int i = 0; i < readers.length; i++) {
/* 1625 */         merger.add(readers[i]);
/*      */       }
/* 1627 */       boolean success = false;
/*      */       
/* 1629 */       startTransaction();
/*      */       
/*      */       try {
/* 1632 */         int docCount = merger.merge();
/*      */         
/* 1634 */         if (sReader != null) {
/* 1635 */           sReader.close();
/* 1636 */           sReader = null;
/*      */         } 
/*      */         
/* 1639 */         this.segmentInfos.setSize(0);
/* 1640 */         info = new SegmentInfo(mergedName, docCount, this.directory, false, true);
/* 1641 */         this.segmentInfos.addElement((E)info);
/*      */         
/* 1643 */         success = true;
/*      */       } finally {
/*      */         
/* 1646 */         if (!success) {
/* 1647 */           rollbackTransaction();
/*      */         } else {
/* 1649 */           commitTransaction();
/*      */         } 
/*      */       } 
/*      */     } finally {
/* 1653 */       if (sReader != null) {
/* 1654 */         sReader.close();
/*      */       }
/*      */     } 
/*      */     
/* 1658 */     if (this.useCompoundFile) {
/*      */       
/* 1660 */       boolean success = false;
/*      */       
/* 1662 */       startTransaction();
/*      */       
/*      */       try {
/* 1665 */         merger.createCompoundFile(mergedName + "".cfs"");
/* 1666 */         info.setUseCompoundFile(true);
/*      */       } finally {
/* 1668 */         if (!success) {
/* 1669 */           rollbackTransaction();
/*      */         } else {
/* 1671 */           commitTransaction();
/*      */         } 
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   void doAfterFlush() throws IOException {}
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected final void maybeFlushRamSegments() throws CorruptIndexException, IOException {
/* 1726 */     if (this.ramSegmentInfos.size() >= this.minMergeDocs || this.numBufferedDeleteTerms >= this.maxBufferedDeleteTerms) {
/* 1727 */       flushRamSegments();
/*      */     }
/*      */   }
/*      */ 
/*      */ 
/*      */   
/* 1733 */   private final synchronized void flushRamSegments() throws CorruptIndexException, IOException { flushRamSegments(true); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected final synchronized void flushRamSegments(boolean triggerMerge) throws CorruptIndexException, IOException {
/* 1740 */     if (this.ramSegmentInfos.size() > 0 || this.bufferedDeleteTerms.size() > 0) {
/* 1741 */       mergeSegments(this.ramSegmentInfos, 0, this.ramSegmentInfos.size());
/* 1742 */       if (triggerMerge) maybeMergeSegments(this.minMergeDocs);
/*      */     
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final synchronized void flush() throws CorruptIndexException, IOException {
/* 1755 */     ensureOpen();
/* 1756 */     flushRamSegments();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final long ramSizeInBytes() {
/* 1763 */     ensureOpen();
/* 1764 */     return this.ramDirectory.sizeInBytes();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final synchronized int numRamDocs() {
/* 1771 */     ensureOpen();
/* 1772 */     return this.ramSegmentInfos.size();
/*      */   }
/*      */ 
/*      */   
/*      */   private final void maybeMergeSegments(int startUpperBound) throws CorruptIndexException, IOException {
/* 1777 */     long lowerBound = -1L;
/* 1778 */     long upperBound = startUpperBound;
/*      */     
/* 1780 */     while (upperBound < this.maxMergeDocs) {
/* 1781 */       int minSegment = this.segmentInfos.size();
/* 1782 */       int maxSegment = -1;
/*      */ 
/*      */       
/* 1785 */       while (--minSegment >= 0) {
/* 1786 */         SegmentInfo si = this.segmentInfos.info(minSegment);
/*      */         
/* 1788 */         if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {
/*      */           
/* 1790 */           maxSegment = minSegment; continue;
/* 1791 */         }  if (si.docCount > upperBound) {
/*      */           break;
/*      */         }
/*      */       } 
/*      */ 
/*      */       
/* 1797 */       minSegment++;
/* 1798 */       maxSegment++;
/* 1799 */       int numSegments = maxSegment - minSegment;
/*      */       
/* 1801 */       if (numSegments < this.mergeFactor) {
/*      */         break;
/*      */       }
/* 1804 */       boolean exceedsUpperLimit = false;
/*      */ 
/*      */ 
/*      */       
/* 1808 */       while (numSegments >= this.mergeFactor) {
/*      */ 
/*      */         
/* 1811 */         int docCount = mergeSegments(this.segmentInfos, minSegment, minSegment + this.mergeFactor);
/* 1812 */         numSegments -= this.mergeFactor;
/*      */         
/* 1814 */         if (docCount > upperBound) {
/*      */           
/* 1816 */           minSegment++;
/* 1817 */           exceedsUpperLimit = true;
/*      */           
/*      */           continue;
/*      */         } 
/* 1821 */         numSegments++;
/*      */       } 
/*      */ 
/*      */       
/* 1825 */       if (!exceedsUpperLimit) {
/*      */         break;
/*      */       }
/*      */ 
/*      */ 
/*      */       
/* 1831 */       lowerBound = upperBound;
/* 1832 */       upperBound *= this.mergeFactor;
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end) throws CorruptIndexException, IOException {
/* 1845 */     boolean doMerge = (end > 0);
/* 1846 */     String mergedName = newSegmentName();
/* 1847 */     SegmentMerger merger = null;
/*      */     
/* 1849 */     List ramSegmentsToDelete = new ArrayList();
/*      */     
/* 1851 */     SegmentInfo newSegment = null;
/*      */     
/* 1853 */     int mergedDocCount = 0;
/* 1854 */     boolean anyDeletes = (this.bufferedDeleteTerms.size() != 0);
/*      */ 
/*      */ 
/*      */     
/*      */     try {
/* 1859 */       if (doMerge) {
/* 1860 */         if (this.infoStream != null) this.infoStream.print(""merging segments""); 
/* 1861 */         merger = new SegmentMerger(this, mergedName);
/*      */         
/* 1863 */         for (int i = minSegment; i < end; i++) {
/* 1864 */           SegmentInfo si = sourceSegments.info(i);
/* 1865 */           if (this.infoStream != null)
/* 1866 */             this.infoStream.print("" "" + si.name + "" ("" + si.docCount + "" docs)""); 
/* 1867 */           IndexReader reader = SegmentReader.get(si, 4096);
/* 1868 */           merger.add(reader);
/* 1869 */           if (reader.directory() == this.ramDirectory) {
/* 1870 */             ramSegmentsToDelete.add(si);
/*      */           }
/*      */         } 
/*      */       } 
/*      */       
/* 1875 */       SegmentInfos rollback = null;
/* 1876 */       boolean success = false;
/*      */ 
/*      */ 
/*      */ 
/*      */       
/*      */       try {
/* 1882 */         if (doMerge) {
/* 1883 */           mergedDocCount = merger.merge();
/*      */           
/* 1885 */           if (this.infoStream != null) {
/* 1886 */             this.infoStream.println("" into "" + mergedName + "" ("" + mergedDocCount + "" docs)"");
/*      */           }
/*      */           
/* 1889 */           newSegment = new SegmentInfo(mergedName, mergedDocCount, this.directory, false, true);
/*      */         } 
/*      */ 
/*      */         
/* 1893 */         if (sourceSegments != this.ramSegmentInfos || anyDeletes)
/*      */         {
/*      */           
/* 1896 */           rollback = (SegmentInfos)this.segmentInfos.clone();
/*      */         }
/*      */         
/* 1899 */         if (doMerge) {
/* 1900 */           if (sourceSegments == this.ramSegmentInfos) {
/* 1901 */             this.segmentInfos.addElement((E)newSegment);
/*      */           } else {
/* 1903 */             for (int i = end - 1; i > minSegment; i--) {
/* 1904 */               sourceSegments.remove(i);
/*      */             }
/* 1906 */             this.segmentInfos.set(minSegment, (E)newSegment);
/*      */           } 
/*      */         }
/*      */         
/* 1910 */         if (sourceSegments == this.ramSegmentInfos) {
/* 1911 */           maybeApplyDeletes(doMerge);
/* 1912 */           doAfterFlush();
/*      */         } 
/*      */         
/* 1915 */         checkpoint();
/*      */         
/* 1917 */         success = true;
/*      */       }
/*      */       finally {
/*      */         
/* 1921 */         if (success) {
/*      */ 
/*      */ 
/*      */           
/* 1925 */           if (sourceSegments == this.ramSegmentInfos) {
/* 1926 */             this.ramSegmentInfos.removeAllElements();
/*      */           }
/*      */         }
/*      */         else {
/*      */           
/* 1931 */           if (sourceSegments == this.ramSegmentInfos && !anyDeletes) {
/*      */ 
/*      */ 
/*      */             
/* 1935 */             if (newSegment != null && this.segmentInfos.size() > 0 && this.segmentInfos.info(this.segmentInfos.size() - 1) == newSegment)
/*      */             {
/*      */               
/* 1938 */               this.segmentInfos.remove(this.segmentInfos.size() - 1);
/*      */             }
/* 1940 */           } else if (rollback != null) {
/*      */ 
/*      */ 
/*      */ 
/*      */             
/* 1945 */             this.segmentInfos.clear();
/* 1946 */             this.segmentInfos.addAll(rollback);
/*      */           } 
/*      */ 
/*      */           
/* 1950 */           this.deleter.refresh();
/*      */         } 
/*      */       } 
/*      */     } finally {
/*      */       
/* 1955 */       if (doMerge) merger.closeReaders();
/*      */     
/*      */     } 
/*      */     
/* 1959 */     this.deleter.deleteDirect((Directory)this.ramDirectory, ramSegmentsToDelete);
/*      */ 
/*      */     
/* 1962 */     this.deleter.checkpoint(this.segmentInfos, this.autoCommit);
/*      */     
/* 1964 */     if (this.useCompoundFile && doMerge) {
/*      */       
/* 1966 */       boolean success = false;
/*      */ 
/*      */       
/*      */       try {
/* 1970 */         merger.createCompoundFile(mergedName + "".cfs"");
/* 1971 */         newSegment.setUseCompoundFile(true);
/* 1972 */         checkpoint();
/* 1973 */         success = true;
/*      */       } finally {
/*      */         
/* 1976 */         if (!success) {
/*      */           
/* 1978 */           newSegment.setUseCompoundFile(false);
/* 1979 */           this.deleter.refresh();
/*      */         } 
/*      */       } 
/*      */ 
/*      */       
/* 1984 */       this.deleter.checkpoint(this.segmentInfos, this.autoCommit);
/*      */     } 
/*      */     
/* 1987 */     return mergedDocCount;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private final void maybeApplyDeletes(boolean doMerge) throws CorruptIndexException, IOException {
/* 1995 */     if (this.bufferedDeleteTerms.size() > 0) {
/* 1996 */       if (this.infoStream != null) {
/* 1997 */         this.infoStream.println(""flush "" + this.numBufferedDeleteTerms + "" buffered deleted terms on "" + this.segmentInfos.size() + "" segments."");
/*      */       }
/*      */       
/* 2000 */       if (doMerge) {
/* 2001 */         IndexReader reader = null;
/*      */         try {
/* 2003 */           reader = SegmentReader.get(this.segmentInfos.info(this.segmentInfos.size() - 1));
/*      */ 
/*      */ 
/*      */ 
/*      */           
/* 2008 */           applyDeletesSelectively(this.bufferedDeleteTerms, reader);
/*      */         } finally {
/* 2010 */           if (reader != null) {
/*      */             try {
/* 2012 */               reader.doCommit();
/*      */             } finally {
/* 2014 */               reader.doClose();
/*      */             } 
/*      */           }
/*      */         } 
/*      */       } 
/*      */       
/* 2020 */       int infosEnd = this.segmentInfos.size();
/* 2021 */       if (doMerge) {
/* 2022 */         infosEnd--;
/*      */       }
/*      */       
/* 2025 */       for (int i = 0; i < infosEnd; i++) {
/* 2026 */         IndexReader reader = null;
/*      */       }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 2045 */       this.bufferedDeleteTerms.clear();
/* 2046 */       this.numBufferedDeleteTerms = 0;
/*      */     } 
/*      */   }
/*      */   
/*      */   private final boolean checkNonDecreasingLevels(int start) {
/* 2051 */     int lowerBound = -1;
/* 2052 */     int upperBound = this.minMergeDocs;
/*      */     
/* 2054 */     for (int i = this.segmentInfos.size() - 1; i >= start; i--) {
/* 2055 */       int docCount = (this.segmentInfos.info(i)).docCount;
/* 2056 */       if (docCount <= lowerBound) {
/* 2057 */         return false;
/*      */       }
/*      */       
/* 2060 */       while (docCount > upperBound) {
/* 2061 */         lowerBound = upperBound;
/* 2062 */         upperBound *= this.mergeFactor;
/*      */       } 
/*      */     } 
/* 2065 */     return true;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/* 2070 */   final synchronized int getBufferedDeleteTermsSize() { return this.bufferedDeleteTerms.size(); }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/* 2075 */   final synchronized int getNumBufferedDeleteTerms() { return this.numBufferedDeleteTerms; }
/*      */ 
/*      */   
/*      */   private static class Num
/*      */   {
/*      */     private int num;
/*      */ 
/*      */     
/* 2083 */     Num(int num) { this.num = num; }
/*      */ 
/*      */ 
/*      */     
/* 2087 */     int getNum() { return this.num; }
/*      */ 
/*      */ 
/*      */     
/* 2091 */     void setNum(int num) { this.num = num; }
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private void bufferDeleteTerm(Term term) {
/* 2100 */     Num num = (Num)this.bufferedDeleteTerms.get(term);
/* 2101 */     if (num == null) {
/* 2102 */       this.bufferedDeleteTerms.put(term, new Num(this.ramSegmentInfos.size()));
/*      */     } else {
/* 2104 */       num.setNum(this.ramSegmentInfos.size());
/*      */     } 
/* 2106 */     this.numBufferedDeleteTerms++;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private final void applyDeletesSelectively(HashMap deleteTerms, IndexReader reader) throws CorruptIndexException, IOException {
/* 2114 */     Iterator iter = deleteTerms.entrySet().iterator();
/* 2115 */     while (iter.hasNext()) {
/* 2116 */       Map.Entry entry = iter.next();
/* 2117 */       Term term = (Term)entry.getKey();
/*      */       
/* 2119 */       TermDocs docs = reader.termDocs(term);
/* 2120 */       if (docs != null) {
/* 2121 */         int num = ((Num)entry.getValue()).getNum();
/*      */         try {
/* 2123 */           while (docs.next()) {
/* 2124 */             int doc = docs.doc();
/* 2125 */             if (doc >= num) {
/*      */               break;
/*      */             }
/* 2128 */             reader.deleteDocument(doc);
/*      */           } 
/*      */         } finally {
/* 2131 */           docs.close();
/*      */         } 
/*      */       } 
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   private final void applyDeletes(HashMap deleteTerms, IndexReader reader) throws CorruptIndexException, IOException {
/* 2140 */     Iterator iter = deleteTerms.entrySet().iterator();
/* 2141 */     while (iter.hasNext()) {
/* 2142 */       Map.Entry entry = iter.next();
/* 2143 */       reader.deleteDocuments((Term)entry.getKey());
/*      */     } 
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\IndexWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.util.List;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class KeepOnlyLastCommitDeletionPolicy
/*    */   implements IndexDeletionPolicy
/*    */ {
/* 36 */   public void onInit(List commits) { onCommit(commits); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void onCommit(List commits) {
/* 45 */     int size = commits.size();
/* 46 */     for (int i = 0; i < size - 1; i++)
/* 47 */       ((IndexCommitPoint)commits.get(i)).delete(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\KeepOnlyLastCommitDeletionPolicy.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiLevelSkipListReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import org.apache.lucene.store.BufferedIndexInput;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class MultiLevelSkipListReader
/*     */ {
/*     */   private int maxNumberOfSkipLevels;
/*     */   private int numberOfSkipLevels;
/*  49 */   private int numberOfLevelsToBuffer = 1;
/*     */   
/*     */   private int docCount;
/*     */   
/*     */   private boolean haveSkipped;
/*     */   
/*     */   private IndexInput[] skipStream;
/*     */   
/*     */   private long[] skipPointer;
/*     */   private int[] skipInterval;
/*     */   private int[] numSkipped;
/*     */   private int[] skipDoc;
/*     */   private int lastDoc;
/*     */   private long[] childPointer;
/*     */   private long lastChildPointer;
/*     */   private boolean inputIsBuffered;
/*     */   
/*     */   public MultiLevelSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval) {
/*  67 */     this.skipStream = new IndexInput[maxSkipLevels];
/*  68 */     this.skipPointer = new long[maxSkipLevels];
/*  69 */     this.childPointer = new long[maxSkipLevels];
/*  70 */     this.numSkipped = new int[maxSkipLevels];
/*  71 */     this.maxNumberOfSkipLevels = maxSkipLevels;
/*  72 */     this.skipInterval = new int[maxSkipLevels];
/*  73 */     this.skipStream[0] = skipStream;
/*  74 */     this.inputIsBuffered = skipStream instanceof BufferedIndexInput;
/*  75 */     this.skipInterval[0] = skipInterval;
/*  76 */     for (int i = 1; i < maxSkipLevels; i++)
/*     */     {
/*  78 */       this.skipInterval[i] = this.skipInterval[i - 1] * skipInterval;
/*     */     }
/*  80 */     this.skipDoc = new int[maxSkipLevels];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   int getDoc() { return this.lastDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   int skipTo(int target) throws IOException {
/*  95 */     if (!this.haveSkipped) {
/*     */       
/*  97 */       loadSkipLevels();
/*  98 */       this.haveSkipped = true;
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 103 */     int level = 0;
/* 104 */     while (level < this.numberOfSkipLevels - 1 && target > this.skipDoc[level + 1]) {
/* 105 */       level++;
/*     */     }
/*     */     
/* 108 */     while (level >= 0) {
/* 109 */       if (target > this.skipDoc[level]) {
/* 110 */         if (!loadNextSkip(level));
/*     */         
/*     */         continue;
/*     */       } 
/*     */       
/* 115 */       if (level > 0 && this.lastChildPointer > this.skipStream[level - 1].getFilePointer()) {
/* 116 */         seekChild(level - 1);
/*     */       }
/* 118 */       level--;
/*     */     } 
/*     */ 
/*     */     
/* 122 */     return this.numSkipped[0] - this.skipInterval[0] - 1;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean loadNextSkip(int level) throws IOException {
/* 128 */     setLastSkipData(level);
/*     */     
/* 130 */     this.numSkipped[level] = this.numSkipped[level] + this.skipInterval[level];
/*     */     
/* 132 */     if (this.numSkipped[level] > this.docCount) {
/*     */       
/* 134 */       this.skipDoc[level] = Integer.MAX_VALUE;
/* 135 */       if (this.numberOfSkipLevels > level) this.numberOfSkipLevels = level; 
/* 136 */       return false;
/*     */     } 
/*     */ 
/*     */     
/* 140 */     this.skipDoc[level] = this.skipDoc[level] + readSkipData(level, this.skipStream[level]);
/*     */     
/* 142 */     if (level != 0)
/*     */     {
/* 144 */       this.childPointer[level] = this.skipStream[level].readVLong() + this.skipPointer[level - 1];
/*     */     }
/*     */     
/* 147 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   protected void seekChild(int level) throws IOException {
/* 153 */     this.skipStream[level].seek(this.lastChildPointer);
/* 154 */     this.numSkipped[level] = this.numSkipped[level + 1] - this.skipInterval[level + 1];
/* 155 */     this.skipDoc[level] = this.lastDoc;
/* 156 */     if (level > 0) {
/* 157 */       this.childPointer[level] = this.skipStream[level].readVLong() + this.skipPointer[level - 1];
/*     */     }
/*     */   }
/*     */   
/*     */   void close() throws IOException {
/* 162 */     for (int i = 1; i < this.skipStream.length; i++) {
/* 163 */       if (this.skipStream[i] != null) {
/* 164 */         this.skipStream[i].close();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   void init(long skipPointer, int df) {
/* 171 */     this.skipPointer[0] = skipPointer;
/* 172 */     this.docCount = df;
/* 173 */     Arrays.fill(this.skipDoc, 0);
/* 174 */     Arrays.fill(this.numSkipped, 0);
/* 175 */     this.haveSkipped = false;
/* 176 */     for (int i = 1; i < this.numberOfSkipLevels; i++) {
/* 177 */       this.skipStream[0] = null;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private void loadSkipLevels() throws IOException {
/* 183 */     this.numberOfSkipLevels = (this.docCount == 0) ? 0 : (int)Math.floor(Math.log(this.docCount) / Math.log(this.skipInterval[0]));
/* 184 */     if (this.numberOfSkipLevels > this.maxNumberOfSkipLevels) {
/* 185 */       this.numberOfSkipLevels = this.maxNumberOfSkipLevels;
/*     */     }
/*     */     
/* 188 */     this.skipStream[0].seek(this.skipPointer[0]);
/*     */     
/* 190 */     int toBuffer = this.numberOfLevelsToBuffer;
/*     */     
/* 192 */     for (int i = this.numberOfSkipLevels - 1; i > 0; i--) {
/*     */       
/* 194 */       long length = this.skipStream[0].readVLong();
/*     */ 
/*     */       
/* 197 */       this.skipPointer[i] = this.skipStream[0].getFilePointer();
/* 198 */       if (toBuffer > 0) {
/*     */         
/* 200 */         this.skipStream[i] = new SkipBuffer(this.skipStream[0], (int)length);
/* 201 */         toBuffer--;
/*     */       } else {
/*     */         
/* 204 */         this.skipStream[i] = (IndexInput)this.skipStream[0].clone();
/* 205 */         if (this.inputIsBuffered && length < 1024L) {
/* 206 */           ((BufferedIndexInput)this.skipStream[i]).setBufferSize((int)length);
/*     */         }
/*     */ 
/*     */         
/* 210 */         this.skipStream[0].seek(this.skipStream[0].getFilePointer() + length);
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 215 */     this.skipPointer[0] = this.skipStream[0].getFilePointer();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract int readSkipData(int paramInt, IndexInput paramIndexInput) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void setLastSkipData(int level) {
/* 228 */     this.lastDoc = this.skipDoc[level];
/* 229 */     this.lastChildPointer = this.childPointer[level];
/*     */   }
/*     */   
/*     */   private static final class SkipBuffer
/*     */     extends IndexInput
/*     */   {
/*     */     private byte[] data;
/*     */     private long pointer;
/*     */     private int pos;
/*     */     
/*     */     SkipBuffer(IndexInput input, int length) throws IOException {
/* 240 */       this.data = new byte[length];
/* 241 */       this.pointer = input.getFilePointer();
/* 242 */       input.readBytes(this.data, 0, length);
/*     */     }
/*     */ 
/*     */     
/* 246 */     public void close() throws IOException { this.data = null; }
/*     */ 
/*     */ 
/*     */     
/* 250 */     public long getFilePointer() { return this.pointer + this.pos; }
/*     */ 
/*     */ 
/*     */     
/* 254 */     public long length() { return this.data.length; }
/*     */ 
/*     */ 
/*     */     
/* 258 */     public byte readByte() throws IOException { return this.data[this.pos++]; }
/*     */ 
/*     */     
/*     */     public void readBytes(byte[] b, int offset, int len) throws IOException {
/* 262 */       System.arraycopy(this.data, this.pos, b, offset, len);
/* 263 */       this.pos += len;
/*     */     }
/*     */ 
/*     */     
/* 267 */     public void seek(long pos) throws IOException { this.pos = (int)(pos - this.pointer); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\MultiLevelSkipListReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiLevelSkipListWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.store.RAMOutputStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class MultiLevelSkipListWriter
/*     */ {
/*     */   private int numberOfSkipLevels;
/*     */   private int skipInterval;
/*     */   private RAMOutputStream[] skipBuffer;
/*     */   
/*     */   protected MultiLevelSkipListWriter(int skipInterval, int maxSkipLevels, int df) {
/*  60 */     this.skipInterval = skipInterval;
/*     */ 
/*     */     
/*  63 */     this.numberOfSkipLevels = (df == 0) ? 0 : (int)Math.floor(Math.log(df) / Math.log(skipInterval));
/*     */ 
/*     */     
/*  66 */     if (this.numberOfSkipLevels > maxSkipLevels) {
/*  67 */       this.numberOfSkipLevels = maxSkipLevels;
/*     */     }
/*     */   }
/*     */   
/*     */   protected void init() {
/*  72 */     this.skipBuffer = new RAMOutputStream[this.numberOfSkipLevels];
/*  73 */     for (int i = 0; i < this.numberOfSkipLevels; i++) {
/*  74 */       this.skipBuffer[i] = new RAMOutputStream();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   protected void resetSkip() {
/*  80 */     if (this.skipBuffer == null) {
/*  81 */       init();
/*     */     } else {
/*  83 */       for (int i = 0; i < this.skipBuffer.length; i++) {
/*  84 */         this.skipBuffer[i].reset();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void writeSkipData(int paramInt, IndexOutput paramIndexOutput) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void bufferSkip(int df) throws IOException {
/*     */     int numLevels;
/* 108 */     for (numLevels = 0; df % this.skipInterval == 0 && numLevels < this.numberOfSkipLevels; df /= this.skipInterval) {
/* 109 */       numLevels++;
/*     */     }
/*     */     
/* 112 */     long childPointer = 0L;
/*     */     
/* 114 */     for (int level = 0; level < numLevels; level++) {
/* 115 */       writeSkipData(level, (IndexOutput)this.skipBuffer[level]);
/*     */       
/* 117 */       long newChildPointer = this.skipBuffer[level].getFilePointer();
/*     */       
/* 119 */       if (level != 0)
/*     */       {
/* 121 */         this.skipBuffer[level].writeVLong(childPointer);
/*     */       }
/*     */ 
/*     */       
/* 125 */       childPointer = newChildPointer;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   long writeSkip(IndexOutput output) throws IOException {
/* 136 */     long skipPointer = output.getFilePointer();
/* 137 */     if (this.skipBuffer == null || this.skipBuffer.length == 0) return skipPointer;
/*     */     
/* 139 */     for (int level = this.numberOfSkipLevels - 1; level > 0; level--) {
/* 140 */       long length = this.skipBuffer[level].getFilePointer();
/* 141 */       if (length > 0L) {
/* 142 */         output.writeVLong(length);
/* 143 */         this.skipBuffer[level].writeTo(output);
/*     */       } 
/*     */     } 
/* 146 */     this.skipBuffer[0].writeTo(output);
/*     */     
/* 148 */     return skipPointer;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\MultiLevelSkipListWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultipleTermPositions,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Iterator;
/*     */ import java.util.LinkedList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultipleTermPositions
/*     */   implements TermPositions
/*     */ {
/*     */   private int _doc;
/*     */   private int _freq;
/*     */   private TermPositionsQueue _termPositionsQueue;
/*     */   private IntQueue _posList;
/*     */   
/*     */   private static final class TermPositionsQueue
/*     */     extends PriorityQueue
/*     */   {
/*     */     TermPositionsQueue(List termPositions) throws IOException {
/*  38 */       initialize(termPositions.size());
/*     */       
/*  40 */       Iterator i = termPositions.iterator();
/*  41 */       while (i.hasNext()) {
/*  42 */         TermPositions tp = i.next();
/*  43 */         if (tp.next()) {
/*  44 */           put(tp);
/*     */         }
/*     */       } 
/*     */     }
/*     */     
/*  49 */     final TermPositions peek() { return (TermPositions)top(); }
/*     */ 
/*     */ 
/*     */     
/*  53 */     public final boolean lessThan(Object a, Object b) { return (((TermPositions)a).doc() < ((TermPositions)b).doc()); }
/*     */   }
/*     */   
/*     */   private static final class IntQueue
/*     */   {
/*  58 */     private int _arraySize = 16;
/*  59 */     private int _index = 0;
/*  60 */     private int _lastIndex = 0;
/*  61 */     private int[] _array = new int[this._arraySize];
/*     */     
/*     */     final void add(int i) {
/*  64 */       if (this._lastIndex == this._arraySize) {
/*  65 */         growArray();
/*     */       }
/*  67 */       this._array[this._lastIndex++] = i;
/*     */     }
/*     */ 
/*     */     
/*  71 */     final int next() { return this._array[this._index++]; }
/*     */ 
/*     */ 
/*     */     
/*  75 */     final void sort() { Arrays.sort(this._array, this._index, this._lastIndex); }
/*     */ 
/*     */     
/*     */     final void clear() {
/*  79 */       this._index = 0;
/*  80 */       this._lastIndex = 0;
/*     */     }
/*     */ 
/*     */     
/*  84 */     final int size() { return this._lastIndex - this._index; }
/*     */ 
/*     */     
/*     */     private void growArray() {
/*  88 */       int[] newArray = new int[this._arraySize * 2];
/*  89 */       System.arraycopy(this._array, 0, newArray, 0, this._arraySize);
/*  90 */       this._array = newArray;
/*  91 */       this._arraySize *= 2;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     private IntQueue() {}
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultipleTermPositions(IndexReader indexReader, Term[] terms) throws IOException {
/* 106 */     List termPositions = new LinkedList();
/*     */     
/* 108 */     for (int i = 0; i < terms.length; i++) {
/* 109 */       termPositions.add(indexReader.termPositions(terms[i]));
/*     */     }
/* 111 */     this._termPositionsQueue = new TermPositionsQueue(termPositions);
/* 112 */     this._posList = new IntQueue();
/*     */   }
/*     */   
/*     */   public final boolean next() throws IOException {
/* 116 */     if (this._termPositionsQueue.size() == 0) {
/* 117 */       return false;
/*     */     }
/* 119 */     this._posList.clear();
/* 120 */     this._doc = this._termPositionsQueue.peek().doc();
/*     */ 
/*     */     
/*     */     do {
/* 124 */       TermPositions tp = this._termPositionsQueue.peek();
/*     */       
/* 126 */       for (int i = 0; i < tp.freq(); i++) {
/* 127 */         this._posList.add(tp.nextPosition());
/*     */       }
/* 129 */       if (tp.next()) {
/* 130 */         this._termPositionsQueue.adjustTop();
/*     */       } else {
/* 132 */         this._termPositionsQueue.pop();
/* 133 */         tp.close();
/*     */       } 
/* 135 */     } while (this._termPositionsQueue.size() > 0 && this._termPositionsQueue.peek().doc() == this._doc);
/*     */     
/* 137 */     this._posList.sort();
/* 138 */     this._freq = this._posList.size();
/*     */     
/* 140 */     return true;
/*     */   }
/*     */ 
/*     */   
/* 144 */   public final int nextPosition() { return this._posList.next(); }
/*     */ 
/*     */   
/*     */   public final boolean skipTo(int target) throws IOException {
/* 148 */     while (this._termPositionsQueue.peek() != null && target > this._termPositionsQueue.peek().doc()) {
/* 149 */       TermPositions tp = (TermPositions)this._termPositionsQueue.pop();
/* 150 */       if (tp.skipTo(target)) {
/* 151 */         this._termPositionsQueue.put(tp); continue;
/*     */       } 
/* 153 */       tp.close();
/*     */     } 
/* 155 */     return next();
/*     */   }
/*     */ 
/*     */   
/* 159 */   public final int doc() { return this._doc; }
/*     */ 
/*     */ 
/*     */   
/* 163 */   public final int freq() { return this._freq; }
/*     */ 
/*     */   
/*     */   public final void close() throws IOException {
/* 167 */     while (this._termPositionsQueue.size() > 0) {
/* 168 */       ((TermPositions)this._termPositionsQueue.pop()).close();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 176 */   public void seek(Term arg0) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 184 */   public void seek(TermEnum termEnum) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 192 */   public int read(int[] arg0, int[] arg1) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 201 */   public int getPayloadLength() { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 209 */   public byte[] getPayload(byte[] data, int offset) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 218 */   public boolean isPayloadAvailable() { return false; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\MultipleTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.HashSet;
/*     */ import java.util.Hashtable;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiReader
/*     */   extends IndexReader
/*     */ {
/*     */   private IndexReader[] subReaders;
/*     */   private int[] starts;
/*  37 */   private Hashtable normsCache = new Hashtable();
/*  38 */   private int maxDoc = 0;
/*  39 */   private int numDocs = -1;
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean hasDeletions = false;
/*     */ 
/*     */   
/*     */   private byte[] ones;
/*     */ 
/*     */ 
/*     */   
/*     */   public MultiReader(IndexReader[] subReaders) throws IOException {
/*  51 */     super((subReaders.length == 0) ? null : subReaders[0].directory());
/*  52 */     initialize(subReaders);
/*     */   }
/*     */ 
/*     */   
/*     */   MultiReader(Directory directory, SegmentInfos sis, boolean closeDirectory, IndexReader[] subReaders) {
/*  57 */     super(directory, sis, closeDirectory);
/*  58 */     initialize(subReaders);
/*     */   }
/*     */   
/*     */   private void initialize(IndexReader[] subReaders) {
/*  62 */     this.subReaders = subReaders;
/*  63 */     this.starts = new int[subReaders.length + 1];
/*  64 */     for (int i = 0; i < subReaders.length; i++) {
/*  65 */       this.starts[i] = this.maxDoc;
/*  66 */       this.maxDoc += subReaders[i].maxDoc();
/*     */       
/*  68 */       if (subReaders[i].hasDeletions())
/*  69 */         this.hasDeletions = true; 
/*     */     } 
/*  71 */     this.starts[subReaders.length] = this.maxDoc;
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int n) throws IOException {
/*  76 */     ensureOpen();
/*  77 */     int i = readerIndex(n);
/*  78 */     return this.subReaders[i].getTermFreqVectors(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int n, String field) throws IOException {
/*  83 */     ensureOpen();
/*  84 */     int i = readerIndex(n);
/*  85 */     return this.subReaders[i].getTermFreqVector(n - this.starts[i], field);
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized int numDocs() {
/*  90 */     if (this.numDocs == -1) {
/*  91 */       int n = 0;
/*  92 */       for (int i = 0; i < this.subReaders.length; i++)
/*  93 */         n += this.subReaders[i].numDocs(); 
/*  94 */       this.numDocs = n;
/*     */     } 
/*  96 */     return this.numDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 106 */     ensureOpen();
/* 107 */     int i = readerIndex(n);
/* 108 */     return this.subReaders[i].document(n - this.starts[i], fieldSelector);
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean isDeleted(int n) {
/* 113 */     int i = readerIndex(n);
/* 114 */     return this.subReaders[i].isDeleted(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 119 */   public boolean hasDeletions() { return this.hasDeletions; }
/*     */ 
/*     */   
/*     */   protected void doDelete(int n) throws CorruptIndexException, IOException {
/* 123 */     this.numDocs = -1;
/* 124 */     int i = readerIndex(n);
/* 125 */     this.subReaders[i].deleteDocument(n - this.starts[i]);
/* 126 */     this.hasDeletions = true;
/*     */   }
/*     */   
/*     */   protected void doUndeleteAll() throws CorruptIndexException, IOException {
/* 130 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 131 */       this.subReaders[i].undeleteAll();
/*     */     }
/* 133 */     this.hasDeletions = false;
/* 134 */     this.numDocs = -1;
/*     */   }
/*     */   
/*     */   private int readerIndex(int n) {
/* 138 */     int lo = 0;
/* 139 */     int hi = this.subReaders.length - 1;
/*     */     
/* 141 */     while (hi >= lo) {
/* 142 */       int mid = lo + hi >> 1;
/* 143 */       int midValue = this.starts[mid];
/* 144 */       if (n < midValue) {
/* 145 */         hi = mid - 1; continue;
/* 146 */       }  if (n > midValue) {
/* 147 */         lo = mid + 1; continue;
/*     */       } 
/* 149 */       while (mid + 1 < this.subReaders.length && this.starts[mid + 1] == midValue) {
/* 150 */         mid++;
/*     */       }
/* 152 */       return mid;
/*     */     } 
/*     */     
/* 155 */     return hi;
/*     */   }
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 159 */     ensureOpen();
/* 160 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 161 */       if (this.subReaders[i].hasNorms(field)) return true; 
/*     */     } 
/* 163 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   private byte[] fakeNorms() {
/* 168 */     if (this.ones == null) this.ones = SegmentReader.createFakeNorms(maxDoc()); 
/* 169 */     return this.ones;
/*     */   }
/*     */   
/*     */   public synchronized byte[] norms(String field) throws IOException {
/* 173 */     ensureOpen();
/* 174 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 175 */     if (bytes != null)
/* 176 */       return bytes; 
/* 177 */     if (!hasNorms(field)) {
/* 178 */       return fakeNorms();
/*     */     }
/* 180 */     bytes = new byte[maxDoc()];
/* 181 */     for (int i = 0; i < this.subReaders.length; i++)
/* 182 */       this.subReaders[i].norms(field, bytes, this.starts[i]); 
/* 183 */     this.normsCache.put(field, bytes);
/* 184 */     return bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized void norms(String field, byte[] result, int offset) throws IOException {
/* 189 */     ensureOpen();
/* 190 */     byte[] bytes = (byte[])this.normsCache.get(field);
/* 191 */     if (bytes == null && !hasNorms(field)) bytes = fakeNorms(); 
/* 192 */     if (bytes != null) {
/* 193 */       System.arraycopy(bytes, 0, result, offset, maxDoc());
/*     */     }
/* 195 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 196 */       this.subReaders[i].norms(field, result, offset + this.starts[i]);
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doSetNorm(int n, String field, byte value) throws CorruptIndexException, IOException {
/* 201 */     this.normsCache.remove(field);
/* 202 */     int i = readerIndex(n);
/* 203 */     this.subReaders[i].setNorm(n - this.starts[i], field, value);
/*     */   }
/*     */   
/*     */   public TermEnum terms() throws IOException {
/* 207 */     ensureOpen();
/* 208 */     return new MultiTermEnum(this.subReaders, this.starts, null);
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term term) throws IOException {
/* 212 */     ensureOpen();
/* 213 */     return new MultiTermEnum(this.subReaders, this.starts, term);
/*     */   }
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 217 */     ensureOpen();
/* 218 */     int total = 0;
/* 219 */     for (int i = 0; i < this.subReaders.length; i++)
/* 220 */       total += this.subReaders[i].docFreq(t); 
/* 221 */     return total;
/*     */   }
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 225 */     ensureOpen();
/* 226 */     return new MultiTermDocs(this.subReaders, this.starts);
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 230 */     ensureOpen();
/* 231 */     return new MultiTermPositions(this.subReaders, this.starts);
/*     */   }
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 235 */     for (int i = 0; i < this.subReaders.length; i++)
/* 236 */       this.subReaders[i].commit(); 
/*     */   }
/*     */   
/*     */   void startCommit() {
/* 240 */     super.startCommit();
/* 241 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 242 */       this.subReaders[i].startCommit();
/*     */     }
/*     */   }
/*     */   
/*     */   void rollbackCommit() {
/* 247 */     super.rollbackCommit();
/* 248 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 249 */       this.subReaders[i].rollbackCommit();
/*     */     }
/*     */   }
/*     */   
/*     */   protected synchronized void doClose() throws IOException {
/* 254 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 255 */       this.subReaders[i].close();
/*     */     }
/*     */   }
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 260 */     ensureOpen();
/* 261 */     Set fieldSet = new HashSet();
/* 262 */     for (int i = 0; i < this.subReaders.length; i++) {
/* 263 */       IndexReader reader = this.subReaders[i];
/* 264 */       Collection names = reader.getFieldNames(fieldNames);
/* 265 */       fieldSet.addAll(names);
/*     */     } 
/* 267 */     return fieldSet;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\MultiReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiTermDocs,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiTermDocs
/*     */   implements TermDocs
/*     */ {
/*     */   protected IndexReader[] readers;
/*     */   protected int[] starts;
/*     */   protected Term term;
/* 342 */   protected int base = 0;
/* 343 */   protected int pointer = 0;
/*     */   
/*     */   private TermDocs[] readerTermDocs;
/*     */   protected TermDocs current;
/*     */   
/*     */   public MultiTermDocs(IndexReader[] r, int[] s) {
/* 349 */     this.readers = r;
/* 350 */     this.starts = s;
/*     */     
/* 352 */     this.readerTermDocs = new TermDocs[r.length];
/*     */   }
/*     */ 
/*     */   
/* 356 */   public int doc() { return this.base + this.current.doc(); }
/*     */ 
/*     */   
/* 359 */   public int freq() { return this.current.freq(); }
/*     */ 
/*     */   
/*     */   public void seek(Term term) {
/* 363 */     this.term = term;
/* 364 */     this.base = 0;
/* 365 */     this.pointer = 0;
/* 366 */     this.current = null;
/*     */   }
/*     */ 
/*     */   
/* 370 */   public void seek(TermEnum termEnum) throws IOException { seek(termEnum.term()); }
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/*     */     while (true) {
/* 375 */       if (this.current != null && this.current.next()) {
/* 376 */         return true;
/*     */       }
/* 378 */       if (this.pointer < this.readers.length) {
/* 379 */         this.base = this.starts[this.pointer];
/* 380 */         this.current = termDocs(this.pointer++); continue;
/*     */       }  break;
/* 382 */     }  return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int read(int[] docs, int[] freqs) throws IOException {
/*     */     int end;
/*     */     while (true) {
/* 390 */       while (this.current == null) {
/* 391 */         if (this.pointer < this.readers.length) {
/* 392 */           this.base = this.starts[this.pointer];
/* 393 */           this.current = termDocs(this.pointer++); continue;
/*     */         } 
/* 395 */         return 0;
/*     */       } 
/*     */       
/* 398 */       end = this.current.read(docs, freqs);
/* 399 */       if (end == 0) {
/* 400 */         this.current = null; continue;
/*     */       }  break;
/* 402 */     }  int b = this.base;
/* 403 */     for (int i = 0; i < end; i++)
/* 404 */       docs[i] = docs[i] + b; 
/* 405 */     return end;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*     */     while (true) {
/* 413 */       if (this.current != null && this.current.skipTo(target - this.base))
/* 414 */         return true; 
/* 415 */       if (this.pointer < this.readers.length) {
/* 416 */         this.base = this.starts[this.pointer];
/* 417 */         this.current = termDocs(this.pointer++); continue;
/*     */       }  break;
/* 419 */     }  return false;
/*     */   }
/*     */ 
/*     */   
/*     */   private TermDocs termDocs(int i) throws IOException {
/* 424 */     if (this.term == null)
/* 425 */       return null; 
/* 426 */     TermDocs result = this.readerTermDocs[i];
/* 427 */     if (result == null)
/* 428 */       result = this.readerTermDocs[i] = termDocs(this.readers[i]); 
/* 429 */     result.seek(this.term);
/* 430 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 435 */   protected TermDocs termDocs(IndexReader reader) throws IOException { return reader.termDocs(); }
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 439 */     for (int i = 0; i < this.readerTermDocs.length; i++) {
/* 440 */       if (this.readerTermDocs[i] != null)
/* 441 */         this.readerTermDocs[i].close(); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\MultiTermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiTermEnum,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiTermEnum
/*     */   extends TermEnum
/*     */ {
/*     */   private SegmentMergeQueue queue;
/*     */   private Term term;
/*     */   private int docFreq;
/*     */   
/*     */   public MultiTermEnum(IndexReader[] readers, int[] starts, Term t) throws IOException {
/* 280 */     this.queue = new SegmentMergeQueue(readers.length);
/* 281 */     for (int i = 0; i < readers.length; i++) {
/* 282 */       TermEnum termEnum; IndexReader reader = readers[i];
/*     */ 
/*     */       
/* 285 */       if (t != null) {
/* 286 */         termEnum = reader.terms(t);
/*     */       } else {
/* 288 */         termEnum = reader.terms();
/*     */       } 
/* 290 */       SegmentMergeInfo smi = new SegmentMergeInfo(starts[i], termEnum, reader);
/* 291 */       if ((t == null) ? smi.next() : (termEnum.term() != null)) {
/* 292 */         this.queue.put(smi);
/*     */       } else {
/* 294 */         smi.close();
/*     */       } 
/*     */     } 
/* 297 */     if (t != null && this.queue.size() > 0) {
/* 298 */       next();
/*     */     }
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/* 303 */     SegmentMergeInfo top = (SegmentMergeInfo)this.queue.top();
/* 304 */     if (top == null) {
/* 305 */       this.term = null;
/* 306 */       return false;
/*     */     } 
/*     */     
/* 309 */     this.term = top.term;
/* 310 */     this.docFreq = 0;
/*     */     
/* 312 */     while (top != null && this.term.compareTo(top.term) == 0) {
/* 313 */       this.queue.pop();
/* 314 */       this.docFreq += top.termEnum.docFreq();
/* 315 */       if (top.next()) {
/* 316 */         this.queue.put(top);
/*     */       } else {
/* 318 */         top.close();
/* 319 */       }  top = (SegmentMergeInfo)this.queue.top();
/*     */     } 
/* 321 */     return true;
/*     */   }
/*     */ 
/*     */   
/* 325 */   public Term term() { return this.term; }
/*     */ 
/*     */ 
/*     */   
/* 329 */   public int docFreq() { return this.docFreq; }
/*     */ 
/*     */ 
/*     */   
/* 333 */   public void close() throws IOException { this.queue.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\MultiTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.MultiTermPositions,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiTermPositions
/*     */   extends MultiTermDocs
/*     */   implements TermPositions
/*     */ {
/* 448 */   public MultiTermPositions(IndexReader[] r, int[] s) { super(r, s); }
/*     */ 
/*     */ 
/*     */   
/* 452 */   protected TermDocs termDocs(IndexReader reader) throws IOException { return reader.termPositions(); }
/*     */ 
/*     */ 
/*     */   
/* 456 */   public int nextPosition() throws IOException { return ((TermPositions)this.current).nextPosition(); }
/*     */ 
/*     */ 
/*     */   
/* 460 */   public int getPayloadLength() { return ((TermPositions)this.current).getPayloadLength(); }
/*     */ 
/*     */ 
/*     */   
/* 464 */   public byte[] getPayload(byte[] data, int offset) throws IOException { return ((TermPositions)this.current).getPayload(data, offset); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 470 */   public boolean isPayloadAvailable() { return ((TermPositions)this.current).isPayloadAvailable(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\MultiTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.ParallelReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import java.util.SortedMap;
/*     */ import java.util.TreeMap;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.document.FieldSelectorResult;
/*     */ import org.apache.lucene.document.Fieldable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParallelReader
/*     */   extends IndexReader
/*     */ {
/*  47 */   private List readers = new ArrayList();
/*  48 */   private SortedMap fieldToReader = new TreeMap();
/*  49 */   private Map readerToFields = new HashMap();
/*  50 */   private List storedFieldReaders = new ArrayList();
/*     */   
/*     */   private int maxDoc;
/*     */   
/*     */   private int numDocs;
/*     */   private boolean hasDeletions;
/*     */   
/*  57 */   public ParallelReader() throws IOException { super(null); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(IndexReader reader) throws IOException {
/*  63 */     ensureOpen();
/*  64 */     add(reader, false);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(IndexReader reader, boolean ignoreStoredFields) throws IOException {
/*  80 */     ensureOpen();
/*  81 */     if (this.readers.size() == 0) {
/*  82 */       this.maxDoc = reader.maxDoc();
/*  83 */       this.numDocs = reader.numDocs();
/*  84 */       this.hasDeletions = reader.hasDeletions();
/*     */     } 
/*     */     
/*  87 */     if (reader.maxDoc() != this.maxDoc) {
/*  88 */       throw new IllegalArgumentException(""All readers must have same maxDoc: "" + this.maxDoc + ""!="" + reader.maxDoc());
/*     */     }
/*  90 */     if (reader.numDocs() != this.numDocs) {
/*  91 */       throw new IllegalArgumentException(""All readers must have same numDocs: "" + this.numDocs + ""!="" + reader.numDocs());
/*     */     }
/*     */     
/*  94 */     Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);
/*  95 */     this.readerToFields.put(reader, fields);
/*  96 */     Iterator i = fields.iterator();
/*  97 */     while (i.hasNext()) {
/*  98 */       String field = i.next();
/*  99 */       if (this.fieldToReader.get(field) == null) {
/* 100 */         this.fieldToReader.put(field, reader);
/*     */       }
/*     */     } 
/* 103 */     if (!ignoreStoredFields)
/* 104 */       this.storedFieldReaders.add(reader); 
/* 105 */     this.readers.add(reader);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 110 */   public int numDocs() { return this.numDocs; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 120 */   public boolean hasDeletions() { return this.hasDeletions; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean isDeleted(int n) {
/* 126 */     if (this.readers.size() > 0)
/* 127 */       return ((IndexReader)this.readers.get(0)).isDeleted(n); 
/* 128 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doDelete(int n) throws CorruptIndexException, IOException {
/* 133 */     for (int i = 0; i < this.readers.size(); i++) {
/* 134 */       ((IndexReader)this.readers.get(i)).deleteDocument(n);
/*     */     }
/* 136 */     this.hasDeletions = true;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doUndeleteAll() throws CorruptIndexException, IOException {
/* 141 */     for (int i = 0; i < this.readers.size(); i++) {
/* 142 */       ((IndexReader)this.readers.get(i)).undeleteAll();
/*     */     }
/* 144 */     this.hasDeletions = false;
/*     */   }
/*     */ 
/*     */   
/*     */   public Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 149 */     ensureOpen();
/* 150 */     Document result = new Document();
/* 151 */     for (int i = 0; i < this.storedFieldReaders.size(); i++) {
/* 152 */       IndexReader reader = this.storedFieldReaders.get(i);
/*     */       
/* 154 */       boolean include = (fieldSelector == null);
/* 155 */       if (!include) {
/* 156 */         Iterator it = ((Collection)this.readerToFields.get(reader)).iterator();
/* 157 */         while (it.hasNext()) {
/* 158 */           if (fieldSelector.accept(it.next()) != FieldSelectorResult.NO_LOAD) {
/* 159 */             include = true; break;
/*     */           } 
/*     */         } 
/*     */       } 
/* 163 */       if (include) {
/* 164 */         Iterator fieldIterator = reader.document(n, fieldSelector).getFields().iterator();
/* 165 */         while (fieldIterator.hasNext()) {
/* 166 */           result.add(fieldIterator.next());
/*     */         }
/*     */       } 
/*     */     } 
/* 170 */     return result;
/*     */   }
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int n) throws IOException {
/* 175 */     ensureOpen();
/* 176 */     ArrayList results = new ArrayList();
/* 177 */     Iterator i = this.fieldToReader.entrySet().iterator();
/* 178 */     while (i.hasNext()) {
/* 179 */       Map.Entry e = i.next();
/* 180 */       String field = (String)e.getKey();
/* 181 */       IndexReader reader = (IndexReader)e.getValue();
/* 182 */       TermFreqVector vector = reader.getTermFreqVector(n, field);
/* 183 */       if (vector != null)
/* 184 */         results.add(vector); 
/*     */     } 
/* 186 */     return results.toArray(new TermFreqVector[results.size()]);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int n, String field) throws IOException {
/* 192 */     ensureOpen();
/* 193 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 194 */     return (reader == null) ? null : reader.getTermFreqVector(n, field);
/*     */   }
/*     */   
/*     */   public boolean hasNorms(String field) throws IOException {
/* 198 */     ensureOpen();
/* 199 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 200 */     return (reader == null) ? false : reader.hasNorms(field);
/*     */   }
/*     */   
/*     */   public byte[] norms(String field) throws IOException {
/* 204 */     ensureOpen();
/* 205 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 206 */     return (reader == null) ? null : reader.norms(field);
/*     */   }
/*     */ 
/*     */   
/*     */   public void norms(String field, byte[] result, int offset) throws IOException {
/* 211 */     ensureOpen();
/* 212 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 213 */     if (reader != null) {
/* 214 */       reader.norms(field, result, offset);
/*     */     }
/*     */   }
/*     */   
/*     */   protected void doSetNorm(int n, String field, byte value) throws CorruptIndexException, IOException {
/* 219 */     IndexReader reader = (IndexReader)this.fieldToReader.get(field);
/* 220 */     if (reader != null)
/* 221 */       reader.doSetNorm(n, field, value); 
/*     */   }
/*     */   
/*     */   public TermEnum terms() throws IOException {
/* 225 */     ensureOpen();
/* 226 */     return new ParallelTermEnum();
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term term) throws IOException {
/* 230 */     ensureOpen();
/* 231 */     return new ParallelTermEnum(term);
/*     */   }
/*     */   
/*     */   public int docFreq(Term term) throws IOException {
/* 235 */     ensureOpen();
/* 236 */     IndexReader reader = (IndexReader)this.fieldToReader.get(term.field());
/* 237 */     return (reader == null) ? 0 : reader.docFreq(term);
/*     */   }
/*     */   
/*     */   public TermDocs termDocs(Term term) throws IOException {
/* 241 */     ensureOpen();
/* 242 */     return new ParallelTermDocs(term);
/*     */   }
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 246 */     ensureOpen();
/* 247 */     return new ParallelTermDocs();
/*     */   }
/*     */   
/*     */   public TermPositions termPositions(Term term) throws IOException {
/* 251 */     ensureOpen();
/* 252 */     return new ParallelTermPositions(term);
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 256 */     ensureOpen();
/* 257 */     return new ParallelTermPositions();
/*     */   }
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 261 */     for (int i = 0; i < this.readers.size(); i++)
/* 262 */       ((IndexReader)this.readers.get(i)).commit(); 
/*     */   }
/*     */   
/*     */   protected synchronized void doClose() throws IOException {
/* 266 */     for (int i = 0; i < this.readers.size(); i++) {
/* 267 */       ((IndexReader)this.readers.get(i)).close();
/*     */     }
/*     */   }
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
/* 272 */     ensureOpen();
/* 273 */     Set fieldSet = new HashSet();
/* 274 */     for (int i = 0; i < this.readers.size(); i++) {
/* 275 */       IndexReader reader = this.readers.get(i);
/* 276 */       Collection names = reader.getFieldNames(fieldNames);
/* 277 */       fieldSet.addAll(names);
/*     */     } 
/* 279 */     return fieldSet;
/*     */   }
/*     */   
/*     */   private class ParallelTermEnum extends TermEnum { private String field;
/*     */     private Iterator fieldIterator;
/*     */     private TermEnum termEnum;
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermEnum() throws IOException {
/* 288 */       this.field = (String)ParallelReader.this.fieldToReader.firstKey();
/* 289 */       if (this.field != null)
/* 290 */         this.termEnum = ((IndexReader)ParallelReader.this.fieldToReader.get(this.field)).terms(); 
/*     */     }
/*     */     
/*     */     public ParallelTermEnum(Term term) throws IOException {
/* 294 */       this.field = term.field();
/* 295 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(this.field);
/* 296 */       if (reader != null)
/* 297 */         this.termEnum = reader.terms(term); 
/*     */     }
/*     */     
/*     */     public boolean next() throws IOException {
/* 301 */       if (this.termEnum == null) {
/* 302 */         return false;
/*     */       }
/*     */       
/* 305 */       if (this.termEnum.next() && this.termEnum.term().field() == this.field) {
/* 306 */         return true;
/*     */       }
/* 308 */       this.termEnum.close();
/*     */ 
/*     */       
/* 311 */       if (this.fieldIterator == null) {
/* 312 */         this.fieldIterator = ParallelReader.this.fieldToReader.tailMap(this.field).keySet().iterator();
/* 313 */         this.fieldIterator.next();
/*     */       } 
/* 315 */       while (this.fieldIterator.hasNext()) {
/* 316 */         this.field = this.fieldIterator.next();
/* 317 */         this.termEnum = ((IndexReader)ParallelReader.this.fieldToReader.get(this.field)).terms(new Term(this.field, """"));
/* 318 */         Term term = this.termEnum.term();
/* 319 */         if (term != null && term.field() == this.field) {
/* 320 */           return true;
/*     */         }
/* 322 */         this.termEnum.close();
/*     */       } 
/*     */       
/* 325 */       return false;
/*     */     }
/*     */     
/*     */     public Term term() {
/* 329 */       if (this.termEnum == null) {
/* 330 */         return null;
/*     */       }
/* 332 */       return this.termEnum.term();
/*     */     }
/*     */     
/*     */     public int docFreq() {
/* 336 */       if (this.termEnum == null) {
/* 337 */         return 0;
/*     */       }
/* 339 */       return this.termEnum.docFreq();
/*     */     }
/*     */     
/*     */     public void close() throws IOException {
/* 343 */       if (this.termEnum != null)
/* 344 */         this.termEnum.close(); 
/*     */     } }
/*     */ 
/*     */   
/*     */   private class ParallelTermDocs implements TermDocs {
/*     */     protected TermDocs termDocs;
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermDocs() {}
/*     */     
/* 354 */     public ParallelTermDocs(Term term) throws IOException { seek(term); }
/*     */     
/* 356 */     public int doc() { return this.termDocs.doc(); }
/* 357 */     public int freq() { return this.termDocs.freq(); }
/*     */     
/*     */     public void seek(Term term) throws IOException {
/* 360 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(term.field());
/* 361 */       this.termDocs = (reader != null) ? reader.termDocs(term) : null;
/*     */     }
/*     */ 
/*     */     
/* 365 */     public void seek(TermEnum termEnum) throws IOException { seek(termEnum.term()); }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/* 369 */       if (this.termDocs == null) {
/* 370 */         return false;
/*     */       }
/* 372 */       return this.termDocs.next();
/*     */     }
/*     */     
/*     */     public int read(int[] docs, int[] freqs) throws IOException {
/* 376 */       if (this.termDocs == null) {
/* 377 */         return 0;
/*     */       }
/* 379 */       return this.termDocs.read(docs, freqs);
/*     */     }
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 383 */       if (this.termDocs == null) {
/* 384 */         return false;
/*     */       }
/* 386 */       return this.termDocs.skipTo(target);
/*     */     }
/*     */     
/*     */     public void close() throws IOException {
/* 390 */       if (this.termDocs != null)
/* 391 */         this.termDocs.close(); 
/*     */     }
/*     */   }
/*     */   
/*     */   private class ParallelTermPositions extends ParallelTermDocs implements TermPositions {
/*     */     private final ParallelReader this$0;
/*     */     
/*     */     public ParallelTermPositions() {}
/*     */     
/* 400 */     public ParallelTermPositions(Term term) throws IOException { seek(term); }
/*     */     
/*     */     public void seek(Term term) throws IOException {
/* 403 */       IndexReader reader = (IndexReader)ParallelReader.this.fieldToReader.get(term.field());
/* 404 */       this.termDocs = (reader != null) ? reader.termPositions(term) : null;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 409 */     public int nextPosition() throws IOException { return ((TermPositions)this.termDocs).nextPosition(); }
/*     */ 
/*     */ 
/*     */     
/* 413 */     public int getPayloadLength() { return ((TermPositions)this.termDocs).getPayloadLength(); }
/*     */ 
/*     */ 
/*     */     
/* 417 */     public byte[] getPayload(byte[] data, int offset) throws IOException { return ((TermPositions)this.termDocs).getPayload(data, offset); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 423 */     public boolean isPayloadAvailable() { return ((TermPositions)this.termDocs).isPayloadAvailable(); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\ParallelReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.Payload,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Payload
/*     */   implements Serializable
/*     */ {
/*     */   protected byte[] data;
/*     */   protected int offset;
/*     */   protected int length;
/*     */   
/*     */   protected Payload() {}
/*     */   
/*  64 */   public Payload(byte[] data) { this(data, 0, data.length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Payload(byte[] data, int offset, int length) {
/*  75 */     if (offset < 0 || offset + length > data.length) {
/*  76 */       throw new IllegalArgumentException();
/*     */     }
/*  78 */     this.data = data;
/*  79 */     this.offset = offset;
/*  80 */     this.length = length;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   public int length() { return this.length; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public byte byteAt(int index) {
/*  94 */     if (0 <= index && index < this.length) {
/*  95 */       return this.data[this.offset + index];
/*     */     }
/*  97 */     throw new ArrayIndexOutOfBoundsException(index);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public byte[] toByteArray() {
/* 104 */     byte[] retArray = new byte[this.length];
/* 105 */     System.arraycopy(this.data, this.offset, retArray, 0, this.length);
/* 106 */     return retArray;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void copyTo(byte[] target, int targetOffset) {
/* 116 */     if (this.length > target.length + targetOffset) {
/* 117 */       throw new ArrayIndexOutOfBoundsException();
/*     */     }
/* 119 */     System.arraycopy(this.data, this.offset, target, targetOffset, this.length);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\Payload.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.Posting,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class Posting
/*     */ {
/*     */   Term term;
/*     */   int freq;
/*     */   int[] positions;
/*     */   Payload[] payloads;
/*     */   TermVectorOffsetInfo[] offsets;
/*     */   
/*     */   Posting(Term t, int position, Payload payload, TermVectorOffsetInfo offset) {
/* 538 */     this.term = t;
/* 539 */     this.freq = 1;
/* 540 */     this.positions = new int[1];
/* 541 */     this.positions[0] = position;
/*     */     
/* 543 */     if (payload != null) {
/* 544 */       this.payloads = new Payload[1];
/* 545 */       this.payloads[0] = payload;
/*     */     } else {
/* 547 */       this.payloads = null;
/*     */     } 
/*     */     
/* 550 */     if (offset != null) {
/* 551 */       this.offsets = new TermVectorOffsetInfo[1];
/* 552 */       this.offsets[0] = offset;
/*     */     } else {
/* 554 */       this.offsets = null;
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\Posting.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentInfo,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentInfo
/*     */ {
/*     */   static final int NO = -1;
/*     */   static final int YES = 1;
/*     */   static final int CHECK_DIR = 0;
/*     */   static final int WITHOUT_GEN = 0;
/*     */   public String name;
/*     */   public int docCount;
/*     */   public Directory dir;
/*     */   private boolean preLockless;
/*     */   private long delGen;
/*     */   private long[] normGen;
/*     */   private byte isCompoundFile;
/*     */   private boolean hasSingleNormFile;
/*     */   private List files;
/*     */   
/*     */   public SegmentInfo(String name, int docCount, Directory dir) {
/*  69 */     this.name = name;
/*  70 */     this.docCount = docCount;
/*  71 */     this.dir = dir;
/*  72 */     this.delGen = -1L;
/*  73 */     this.isCompoundFile = 0;
/*  74 */     this.preLockless = true;
/*  75 */     this.hasSingleNormFile = false;
/*     */   }
/*     */   
/*     */   public SegmentInfo(String name, int docCount, Directory dir, boolean isCompoundFile, boolean hasSingleNormFile) {
/*  79 */     this(name, docCount, dir);
/*  80 */     this.isCompoundFile = (byte)(isCompoundFile ? 1 : -1);
/*  81 */     this.hasSingleNormFile = hasSingleNormFile;
/*  82 */     this.preLockless = false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void reset(SegmentInfo src) {
/*  89 */     this.files = null;
/*  90 */     this.name = src.name;
/*  91 */     this.docCount = src.docCount;
/*  92 */     this.dir = src.dir;
/*  93 */     this.preLockless = src.preLockless;
/*  94 */     this.delGen = src.delGen;
/*  95 */     if (src.normGen == null) {
/*  96 */       this.normGen = null;
/*     */     } else {
/*  98 */       this.normGen = new long[src.normGen.length];
/*  99 */       System.arraycopy(src.normGen, 0, this.normGen, 0, src.normGen.length);
/*     */     } 
/* 101 */     this.isCompoundFile = src.isCompoundFile;
/* 102 */     this.hasSingleNormFile = src.hasSingleNormFile;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   SegmentInfo(Directory dir, int format, IndexInput input) throws IOException {
/* 114 */     this.dir = dir;
/* 115 */     this.name = input.readString();
/* 116 */     this.docCount = input.readInt();
/* 117 */     if (format <= -2) {
/* 118 */       this.delGen = input.readLong();
/* 119 */       if (format <= -3) {
/* 120 */         this.hasSingleNormFile = (1 == input.readByte());
/*     */       } else {
/* 122 */         this.hasSingleNormFile = false;
/*     */       } 
/* 124 */       int numNormGen = input.readInt();
/* 125 */       if (numNormGen == -1) {
/* 126 */         this.normGen = null;
/*     */       } else {
/* 128 */         this.normGen = new long[numNormGen];
/* 129 */         for (int j = 0; j < numNormGen; j++) {
/* 130 */           this.normGen[j] = input.readLong();
/*     */         }
/*     */       } 
/* 133 */       this.isCompoundFile = input.readByte();
/* 134 */       this.preLockless = (this.isCompoundFile == 0);
/*     */     } else {
/* 136 */       this.delGen = 0L;
/* 137 */       this.normGen = null;
/* 138 */       this.isCompoundFile = 0;
/* 139 */       this.preLockless = true;
/* 140 */       this.hasSingleNormFile = false;
/*     */     } 
/*     */   }
/*     */   
/*     */   void setNumFields(int numFields) {
/* 145 */     if (this.normGen == null) {
/*     */ 
/*     */ 
/*     */       
/* 149 */       this.normGen = new long[numFields];
/*     */       
/* 151 */       if (!this.preLockless)
/*     */       {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 158 */         for (int i = 0; i < numFields; i++) {
/* 159 */           this.normGen[i] = -1L;
/*     */         }
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean hasDeletions() throws IOException {
/* 181 */     if (this.delGen == -1L)
/* 182 */       return false; 
/* 183 */     if (this.delGen >= 1L) {
/* 184 */       return true;
/*     */     }
/* 186 */     return this.dir.fileExists(getDelFileName());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void advanceDelGen() {
/* 192 */     if (this.delGen == -1L) {
/* 193 */       this.delGen = 1L;
/*     */     } else {
/* 195 */       this.delGen++;
/*     */     } 
/* 197 */     this.files = null;
/*     */   }
/*     */   
/*     */   void clearDelGen() {
/* 201 */     this.delGen = -1L;
/* 202 */     this.files = null;
/*     */   }
/*     */   
/*     */   public Object clone() {
/* 206 */     SegmentInfo si = new SegmentInfo(this.name, this.docCount, this.dir);
/* 207 */     si.isCompoundFile = this.isCompoundFile;
/* 208 */     si.delGen = this.delGen;
/* 209 */     si.preLockless = this.preLockless;
/* 210 */     si.hasSingleNormFile = this.hasSingleNormFile;
/* 211 */     if (this.normGen != null) {
/* 212 */       si.normGen = (long[])this.normGen.clone();
/*     */     }
/* 214 */     return si;
/*     */   }
/*     */   
/*     */   String getDelFileName() {
/* 218 */     if (this.delGen == -1L)
/*     */     {
/*     */       
/* 221 */       return null;
/*     */     }
/*     */     
/* 224 */     return IndexFileNames.fileNameFromGeneration(this.name, "".del"", this.delGen);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean hasSeparateNorms(int fieldNumber) throws IOException {
/* 235 */     if ((this.normGen == null && this.preLockless) || (this.normGen != null && this.normGen[fieldNumber] == 0L)) {
/*     */       
/* 237 */       String fileName = this.name + "".s"" + fieldNumber;
/* 238 */       return this.dir.fileExists(fileName);
/* 239 */     }  if (this.normGen == null || this.normGen[fieldNumber] == -1L) {
/* 240 */       return false;
/*     */     }
/* 242 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean hasSeparateNorms() throws IOException {
/* 251 */     if (this.normGen == null) {
/* 252 */       if (!this.preLockless)
/*     */       {
/*     */         
/* 255 */         return false;
/*     */       }
/*     */ 
/*     */ 
/*     */       
/* 260 */       String[] result = this.dir.list();
/* 261 */       if (result == null) {
/* 262 */         throw new IOException(""cannot read directory "" + this.dir + "": list() returned null"");
/*     */       }
/*     */       
/* 265 */       String pattern = this.name + "".s"";
/* 266 */       int patternLength = pattern.length();
/* 267 */       for (int i = 0; i < result.length; i++) {
/* 268 */         if (result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))
/* 269 */           return true; 
/*     */       } 
/* 271 */       return false;
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 277 */     for (int i = 0; i < this.normGen.length; i++) {
/* 278 */       if (this.normGen[i] >= 1L) {
/* 279 */         return true;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 284 */     for (int i = 0; i < this.normGen.length; i++) {
/* 285 */       if (this.normGen[i] == 0L && 
/* 286 */         hasSeparateNorms(i)) {
/* 287 */         return true;
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/* 293 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void advanceNormGen(int fieldIndex) {
/* 303 */     if (this.normGen[fieldIndex] == -1L) {
/* 304 */       this.normGen[fieldIndex] = 1L;
/*     */     } else {
/* 306 */       this.normGen[fieldIndex] = this.normGen[fieldIndex] + 1L;
/*     */     } 
/* 308 */     this.files = null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   String getNormFileName(int number) throws IOException {
/*     */     long gen;
/* 320 */     if (this.normGen == null) {
/* 321 */       gen = 0L;
/*     */     } else {
/* 323 */       gen = this.normGen[number];
/*     */     } 
/*     */     
/* 326 */     if (hasSeparateNorms(number)) {
/*     */       
/* 328 */       String prefix = "".s"";
/* 329 */       return IndexFileNames.fileNameFromGeneration(this.name, prefix + number, gen);
/*     */     } 
/*     */     
/* 332 */     if (this.hasSingleNormFile) {
/*     */       
/* 334 */       String prefix = "".nrm"";
/* 335 */       return IndexFileNames.fileNameFromGeneration(this.name, prefix, 0L);
/*     */     } 
/*     */ 
/*     */     
/* 339 */     String prefix = "".f"";
/* 340 */     return IndexFileNames.fileNameFromGeneration(this.name, prefix + number, 0L);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setUseCompoundFile(boolean isCompoundFile) {
/* 350 */     if (isCompoundFile) {
/* 351 */       this.isCompoundFile = 1;
/*     */     } else {
/* 353 */       this.isCompoundFile = -1;
/*     */     } 
/* 355 */     this.files = null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   boolean getUseCompoundFile() throws IOException {
/* 363 */     if (this.isCompoundFile == -1)
/* 364 */       return false; 
/* 365 */     if (this.isCompoundFile == 1) {
/* 366 */       return true;
/*     */     }
/* 368 */     return this.dir.fileExists(this.name + ""."" + ""cfs"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void write(IndexOutput output) throws IOException {
/* 377 */     output.writeString(this.name);
/* 378 */     output.writeInt(this.docCount);
/* 379 */     output.writeLong(this.delGen);
/* 380 */     output.writeByte((byte)(this.hasSingleNormFile ? 1 : 0));
/* 381 */     if (this.normGen == null) {
/* 382 */       output.writeInt(-1);
/*     */     } else {
/* 384 */       output.writeInt(this.normGen.length);
/* 385 */       for (int j = 0; j < this.normGen.length; j++) {
/* 386 */         output.writeLong(this.normGen[j]);
/*     */       }
/*     */     } 
/* 389 */     output.writeByte(this.isCompoundFile);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public List files() throws IOException {
/* 400 */     if (this.files != null)
/*     */     {
/* 402 */       return this.files;
/*     */     }
/*     */     
/* 405 */     this.files = new ArrayList();
/*     */     
/* 407 */     boolean useCompoundFile = getUseCompoundFile();
/*     */     
/* 409 */     if (useCompoundFile) {
/* 410 */       this.files.add(this.name + ""."" + ""cfs"");
/*     */     } else {
/* 412 */       for (int i = 0; i < IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE.length; i++) {
/* 413 */         String ext = IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE[i];
/* 414 */         String fileName = this.name + ""."" + ext;
/* 415 */         if (this.dir.fileExists(fileName)) {
/* 416 */           this.files.add(fileName);
/*     */         }
/*     */       } 
/*     */     } 
/*     */     
/* 421 */     String delFileName = IndexFileNames.fileNameFromGeneration(this.name, "".del"", this.delGen);
/* 422 */     if (delFileName != null && (this.delGen >= 1L || this.dir.fileExists(delFileName))) {
/* 423 */       this.files.add(delFileName);
/*     */     }
/*     */ 
/*     */     
/* 427 */     if (this.normGen != null) {
/* 428 */       for (int i = 0; i < this.normGen.length; i++) {
/* 429 */         long gen = this.normGen[i];
/* 430 */         if (gen >= 1L) {
/*     */           
/* 432 */           this.files.add(IndexFileNames.fileNameFromGeneration(this.name, "".s"" + i, gen));
/* 433 */         } else if (-1L == gen) {
/*     */ 
/*     */           
/* 436 */           if (!this.hasSingleNormFile && !useCompoundFile) {
/* 437 */             String fileName = this.name + ""."" + ""f"" + i;
/* 438 */             if (this.dir.fileExists(fileName)) {
/* 439 */               this.files.add(fileName);
/*     */             }
/*     */           } 
/* 442 */         } else if (0L == gen) {
/*     */           
/* 444 */           String fileName = null;
/* 445 */           if (useCompoundFile) {
/* 446 */             fileName = this.name + ""."" + ""s"" + i;
/* 447 */           } else if (!this.hasSingleNormFile) {
/* 448 */             fileName = this.name + ""."" + ""f"" + i;
/*     */           } 
/* 450 */           if (fileName != null && this.dir.fileExists(fileName)) {
/* 451 */             this.files.add(fileName);
/*     */           }
/*     */         } 
/*     */       } 
/* 455 */     } else if (this.preLockless || (!this.hasSingleNormFile && !useCompoundFile)) {
/*     */       String prefix;
/*     */ 
/*     */       
/* 459 */       if (useCompoundFile) {
/* 460 */         prefix = this.name + ""."" + ""s"";
/*     */       } else {
/* 462 */         prefix = this.name + ""."" + ""f"";
/* 463 */       }  int prefixLength = prefix.length();
/* 464 */       String[] allFiles = this.dir.list();
/* 465 */       if (allFiles == null)
/* 466 */         throw new IOException(""cannot read directory "" + this.dir + "": list() returned null""); 
/* 467 */       for (int i = 0; i < allFiles.length; i++) {
/* 468 */         String fileName = allFiles[i];
/* 469 */         if (fileName.length() > prefixLength && Character.isDigit(fileName.charAt(prefixLength)) && fileName.startsWith(prefix)) {
/* 470 */           this.files.add(fileName);
/*     */         }
/*     */       } 
/*     */     } 
/* 474 */     return this.files;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentInfos,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileNotFoundException;
/*     */ import java.io.IOException;
/*     */ import java.io.PrintStream;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentInfos
/*     */   extends Vector
/*     */ {
/*     */   public static final int FORMAT = -1;
/*     */   public static final int FORMAT_LOCKLESS = -2;
/*     */   public static final int FORMAT_SINGLE_NORM_FILE = -3;
/*     */   private static final int CURRENT_FORMAT = -3;
/*  57 */   public int counter = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  62 */   private long version = System.currentTimeMillis();
/*     */   
/*  64 */   private long generation = 0L;
/*  65 */   private long lastGeneration = 0L;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static PrintStream infoStream;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  76 */   public final SegmentInfo info(int i) { return (SegmentInfo)elementAt(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long getCurrentSegmentGeneration(String[] files) {
/*  86 */     if (files == null) {
/*  87 */       return -1L;
/*     */     }
/*  89 */     long max = -1L;
/*  90 */     for (int i = 0; i < files.length; i++) {
/*  91 */       String file = files[i];
/*  92 */       if (file.startsWith(""segments"") && !file.equals(""segments.gen"")) {
/*  93 */         long gen = generationFromSegmentsFileName(file);
/*  94 */         if (gen > max) {
/*  95 */           max = gen;
/*     */         }
/*     */       } 
/*     */     } 
/*  99 */     return max;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long getCurrentSegmentGeneration(Directory directory) throws IOException {
/* 109 */     String[] files = directory.list();
/* 110 */     if (files == null)
/* 111 */       throw new IOException(""cannot read directory "" + directory + "": list() returned null""); 
/* 112 */     return getCurrentSegmentGeneration(files);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 123 */   public static String getCurrentSegmentFileName(String[] files) throws IOException { return IndexFileNames.fileNameFromGeneration(""segments"", """", getCurrentSegmentGeneration(files)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 135 */   public static String getCurrentSegmentFileName(Directory directory) throws IOException { return IndexFileNames.fileNameFromGeneration(""segments"", """", getCurrentSegmentGeneration(directory)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 144 */   public String getCurrentSegmentFileName() { return IndexFileNames.fileNameFromGeneration(""segments"", """", this.lastGeneration); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static long generationFromSegmentsFileName(String fileName) {
/* 154 */     if (fileName.equals(""segments""))
/* 155 */       return 0L; 
/* 156 */     if (fileName.startsWith(""segments"")) {
/* 157 */       return Long.parseLong(fileName.substring(1 + ""segments"".length()), 36);
/*     */     }
/*     */     
/* 160 */     throw new IllegalArgumentException(""fileName \"""" + fileName + ""\"" is not a segments file"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String getNextSegmentFileName() {
/*     */     long nextGeneration;
/* 171 */     if (this.generation == -1L) {
/* 172 */       nextGeneration = 1L;
/*     */     } else {
/* 174 */       nextGeneration = this.generation + 1L;
/*     */     } 
/* 176 */     return IndexFileNames.fileNameFromGeneration(""segments"", """", nextGeneration);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void read(Directory directory, String segmentFileName) throws CorruptIndexException, IOException {
/* 191 */     boolean success = false;
/*     */     
/* 193 */     IndexInput input = directory.openInput(segmentFileName);
/*     */     
/* 195 */     this.generation = generationFromSegmentsFileName(segmentFileName);
/*     */     
/* 197 */     this.lastGeneration = this.generation;
/*     */     
/*     */     try {
/* 200 */       int format = input.readInt();
/* 201 */       if (format < 0) {
/*     */         
/* 203 */         if (format < -3)
/* 204 */           throw new CorruptIndexException(""Unknown format version: "" + format); 
/* 205 */         this.version = input.readLong();
/* 206 */         this.counter = input.readInt();
/*     */       } else {
/*     */         
/* 209 */         this.counter = format;
/*     */       } 
/*     */       
/* 212 */       for (int i = input.readInt(); i > 0; i--) {
/* 213 */         addElement((E)new SegmentInfo(directory, format, input));
/*     */       }
/*     */       
/* 216 */       if (format >= 0)
/* 217 */         if (input.getFilePointer() >= input.length()) {
/* 218 */           this.version = System.currentTimeMillis();
/*     */         } else {
/* 220 */           this.version = input.readLong();
/*     */         }  
/* 222 */       success = true;
/*     */     } finally {
/*     */       
/* 225 */       input.close();
/* 226 */       if (!success)
/*     */       {
/*     */         
/* 229 */         clear();
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void read(Directory directory) throws CorruptIndexException, IOException {
/* 241 */     this.generation = this.lastGeneration = -1L;
/*     */     
/* 243 */     (new FindSegmentsFile(directory) { private final SegmentInfos this$0;
/*     */         
/*     */         protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
/* 246 */           SegmentInfos.this.read(this.directory, segmentFileName);
/* 247 */           return null;
/*     */         } }
/*     */       ).run();
/*     */   }
/*     */ 
/*     */   
/*     */   public final void write(Directory directory) throws IOException {
/* 254 */     String segmentFileName = getNextSegmentFileName();
/*     */ 
/*     */     
/* 257 */     if (this.generation == -1L) {
/* 258 */       this.generation = 1L;
/*     */     } else {
/* 260 */       this.generation++;
/*     */     } 
/*     */     
/* 263 */     IndexOutput output = directory.createOutput(segmentFileName);
/*     */     
/* 265 */     boolean success = false;
/*     */     
/*     */     try {
/* 268 */       output.writeInt(-3);
/* 269 */       output.writeLong(++this.version);
/*     */       
/* 271 */       output.writeInt(this.counter);
/* 272 */       output.writeInt(size());
/* 273 */       for (int i = 0; i < size(); i++) {
/* 274 */         info(i).write(output);
/*     */       }
/*     */     } finally {
/*     */       
/*     */       try {
/* 279 */         output.close();
/* 280 */         success = true;
/*     */       } finally {
/* 282 */         if (!success)
/*     */         {
/*     */           
/* 285 */           directory.deleteFile(segmentFileName);
/*     */         }
/*     */       } 
/*     */     } 
/*     */     
/*     */     try {
/* 291 */       output = directory.createOutput(""segments.gen"");
/*     */       try {
/* 293 */         output.writeInt(-2);
/* 294 */         output.writeLong(this.generation);
/* 295 */         output.writeLong(this.generation);
/*     */       } finally {
/* 297 */         output.close();
/*     */       } 
/* 299 */     } catch (IOException e) {}
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 304 */     this.lastGeneration = this.generation;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 313 */     SegmentInfos sis = (SegmentInfos)super.clone();
/* 314 */     for (int i = 0; i < sis.size(); i++) {
/* 315 */       sis.setElementAt((E)((SegmentInfo)sis.elementAt(i)).clone(), i);
/*     */     }
/* 317 */     return sis;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 324 */   public long getVersion() { return this.version; }
/*     */ 
/*     */   
/* 327 */   public long getGeneration() { return this.generation; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 338 */   public static long readCurrentVersion(Directory directory) throws CorruptIndexException, IOException { return ((Long)(new FindSegmentsFile(directory)
/*     */       {
/*     */         protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
/* 341 */           IndexInput input = this.directory.openInput(segmentFileName);
/*     */           
/* 343 */           int format = 0;
/* 344 */           long version = 0L;
/*     */           try {
/* 346 */             format = input.readInt();
/* 347 */             if (format < 0) {
/* 348 */               if (format < -3)
/* 349 */                 throw new CorruptIndexException(""Unknown format version: "" + format); 
/* 350 */               version = input.readLong();
/*     */             } 
/*     */           } finally {
/*     */             
/* 354 */             input.close();
/*     */           } 
/*     */           
/* 357 */           if (format < 0) {
/* 358 */             return new Long(version);
/*     */           }
/*     */ 
/*     */           
/* 362 */           SegmentInfos sis = new SegmentInfos();
/* 363 */           sis.read(this.directory, segmentFileName);
/* 364 */           return new Long(sis.getVersion());
/*     */         }
/*     */       }).run()).longValue(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 373 */   public static void setInfoStream(PrintStream infoStream) { SegmentInfos.infoStream = infoStream; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 378 */   private static int defaultGenFileRetryCount = 10;
/* 379 */   private static int defaultGenFileRetryPauseMsec = 50;
/* 380 */   private static int defaultGenLookaheadCount = 10;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 389 */   public static void setDefaultGenFileRetryCount(int count) { defaultGenFileRetryCount = count; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 396 */   public static int getDefaultGenFileRetryCount() { return defaultGenFileRetryCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 404 */   public static void setDefaultGenFileRetryPauseMsec(int msec) { defaultGenFileRetryPauseMsec = msec; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 411 */   public static int getDefaultGenFileRetryPauseMsec() { return defaultGenFileRetryPauseMsec; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 422 */   public static void setDefaultGenLookaheadCount(int count) { defaultGenLookaheadCount = count; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 428 */   public static int getDefaultGenLookahedCount() { return defaultGenLookaheadCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 435 */   public static PrintStream getInfoStream() { return infoStream; }
/*     */ 
/*     */   
/*     */   private static void message(String message) {
/* 439 */     if (infoStream != null) {
/* 440 */       infoStream.println(Thread.currentThread().getName() + "": "" + message);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static abstract class FindSegmentsFile
/*     */   {
/*     */     File fileDirectory;
/*     */ 
/*     */ 
/*     */     
/*     */     Directory directory;
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 459 */     public FindSegmentsFile(File directory) { this.fileDirectory = directory; }
/*     */ 
/*     */ 
/*     */     
/* 463 */     public FindSegmentsFile(Directory directory) { this.directory = directory; }
/*     */ 
/*     */     
/*     */     public Object run() throws CorruptIndexException, IOException {
/* 467 */       String segmentFileName = null;
/* 468 */       long lastGen = -1L;
/* 469 */       long gen = 0L;
/* 470 */       int genLookaheadCount = 0;
/* 471 */       IOException exc = null;
/* 472 */       boolean retry = false;
/*     */       
/* 474 */       int method = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*     */       while (true) {
/* 496 */         String[] files = null;
/*     */         
/* 498 */         if (0 == method) {
/* 499 */           if (this.directory != null) {
/* 500 */             files = this.directory.list();
/* 501 */             if (files == null)
/* 502 */               throw new FileNotFoundException(""cannot read directory "" + this.directory + "": list() returned null""); 
/*     */           } else {
/* 504 */             files = this.fileDirectory.list();
/* 505 */             if (files == null) {
/* 506 */               throw new FileNotFoundException(""cannot read directory "" + this.fileDirectory + "": list() returned null"");
/*     */             }
/*     */           } 
/* 509 */           gen = SegmentInfos.getCurrentSegmentGeneration(files);
/*     */           
/* 511 */           if (gen == -1L) {
/* 512 */             String s = """";
/* 513 */             for (int i = 0; i < files.length; i++) {
/* 514 */               s = s + "" "" + files[i];
/*     */             }
/* 516 */             throw new FileNotFoundException(""no segments* file found in "" + this.directory + "": files:"" + s);
/*     */           } 
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 523 */         if (1 == method || (0 == method && lastGen == gen && retry)) {
/*     */           
/* 525 */           method = 1;
/*     */           
/* 527 */           for (int i = 0; i < defaultGenFileRetryCount; i++) {
/* 528 */             IndexInput genInput = null;
/*     */             try {
/* 530 */               genInput = this.directory.openInput(""segments.gen"");
/* 531 */             } catch (IOException e) {
/* 532 */               SegmentInfos.message(""segments.gen open: IOException "" + e);
/*     */             } 
/* 534 */             if (genInput != null) {
/*     */ 
/*     */               
/* 537 */               try { int version = genInput.readInt();
/* 538 */                 if (version == -2)
/* 539 */                 { long gen0 = genInput.readLong();
/* 540 */                   long gen1 = genInput.readLong();
/* 541 */                   SegmentInfos.message(""fallback check: "" + gen0 + ""; "" + gen1);
/* 542 */                   if (gen0 == gen1)
/*     */                   
/* 544 */                   { if (gen0 > gen) {
/* 545 */                       SegmentInfos.message(""fallback to 'segments.gen' check: now try generation "" + gen0 + "" > "" + gen);
/* 546 */                       gen = gen0;
/*     */                     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */                     
/* 554 */                     genInput.close(); break; }  }  } catch (IOException err2) {  } finally { genInput.close(); }
/*     */             
/*     */             }
/*     */             try {
/* 558 */               Thread.sleep(defaultGenFileRetryPauseMsec);
/* 559 */             } catch (InterruptedException e) {}
/*     */           } 
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 569 */         if (2 == method || (1 == method && lastGen == gen && retry)) {
/*     */           
/* 571 */           method = 2;
/*     */           
/* 573 */           if (genLookaheadCount < defaultGenLookaheadCount) {
/* 574 */             gen++;
/* 575 */             genLookaheadCount++;
/* 576 */             SegmentInfos.message(""look ahead increment gen to "" + gen);
/*     */           } 
/*     */         } 
/*     */         
/* 580 */         if (lastGen == gen) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 587 */           if (retry)
/*     */           {
/*     */ 
/*     */ 
/*     */             
/* 592 */             throw exc;
/*     */           }
/* 594 */           retry = true;
/*     */         
/*     */         }
/*     */         else {
/*     */ 
/*     */           
/* 600 */           retry = false;
/*     */         } 
/*     */         
/* 603 */         lastGen = gen;
/*     */         
/* 605 */         segmentFileName = IndexFileNames.fileNameFromGeneration(""segments"", """", gen);
/*     */ 
/*     */ 
/*     */         
/*     */         try {
/* 610 */           Object v = doBody(segmentFileName);
/* 611 */           if (exc != null) {
/* 612 */             SegmentInfos.message(""success on "" + segmentFileName);
/*     */           }
/* 614 */           return v;
/* 615 */         } catch (IOException err) {
/*     */ 
/*     */           
/* 618 */           if (exc == null) {
/* 619 */             exc = err;
/*     */           }
/*     */           
/* 622 */           SegmentInfos.message(""primary Exception on '"" + segmentFileName + ""': "" + err + ""'; will retry: retry="" + retry + ""; gen = "" + gen);
/*     */           
/* 624 */           if (!retry && gen > 1L) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 631 */             String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(""segments"", """", gen - 1L);
/*     */ 
/*     */ 
/*     */             
/* 635 */             if (this.directory.fileExists(prevSegmentFileName)) {
/* 636 */               SegmentInfos.message(""fallback to prior segment file '"" + prevSegmentFileName + ""'"");
/*     */               try {
/* 638 */                 Object v = doBody(prevSegmentFileName);
/* 639 */                 if (exc != null) {
/* 640 */                   SegmentInfos.message(""success on fallback "" + prevSegmentFileName);
/*     */                 }
/* 642 */                 return v;
/* 643 */               } catch (IOException err2) {
/* 644 */                 SegmentInfos.message(""secondary Exception on '"" + prevSegmentFileName + ""': "" + err2 + ""'; will retry"");
/*     */               } 
/*     */             } 
/*     */           } 
/*     */         } 
/*     */       } 
/*     */     }
/*     */     
/*     */     protected abstract Object doBody(String param1String) throws CorruptIndexException, IOException;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentInfos.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMergeInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentMergeInfo
/*    */ {
/*    */   Term term;
/*    */   int base;
/*    */   TermEnum termEnum;
/*    */   IndexReader reader;
/*    */   private TermPositions postings;
/*    */   private int[] docMap;
/*    */   
/*    */   SegmentMergeInfo(int b, TermEnum te, IndexReader r) throws IOException {
/* 32 */     this.base = b;
/* 33 */     this.reader = r;
/* 34 */     this.termEnum = te;
/* 35 */     this.term = te.term();
/*    */   }
/*    */ 
/*    */   
/*    */   int[] getDocMap() {
/* 40 */     if (this.docMap == null)
/*    */     {
/* 42 */       if (this.reader.hasDeletions()) {
/* 43 */         int maxDoc = this.reader.maxDoc();
/* 44 */         this.docMap = new int[maxDoc];
/* 45 */         int j = 0;
/* 46 */         for (int i = 0; i < maxDoc; i++) {
/* 47 */           if (this.reader.isDeleted(i)) {
/* 48 */             this.docMap[i] = -1;
/*    */           } else {
/* 50 */             this.docMap[i] = j++;
/*    */           } 
/*    */         } 
/*    */       }  } 
/* 54 */     return this.docMap;
/*    */   }
/*    */   
/*    */   TermPositions getPositions() throws IOException {
/* 58 */     if (this.postings == null) {
/* 59 */       this.postings = this.reader.termPositions();
/*    */     }
/* 61 */     return this.postings;
/*    */   }
/*    */   
/*    */   final boolean next() throws IOException {
/* 65 */     if (this.termEnum.next()) {
/* 66 */       this.term = this.termEnum.term();
/* 67 */       return true;
/*    */     } 
/* 69 */     this.term = null;
/* 70 */     return false;
/*    */   }
/*    */ 
/*    */   
/*    */   final void close() throws IOException {
/* 75 */     this.termEnum.close();
/* 76 */     if (this.postings != null)
/* 77 */       this.postings.close(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentMergeInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMergeQueue,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class SegmentMergeQueue
/*    */   extends PriorityQueue
/*    */ {
/* 25 */   SegmentMergeQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object a, Object b) {
/* 29 */     SegmentMergeInfo stiA = (SegmentMergeInfo)a;
/* 30 */     SegmentMergeInfo stiB = (SegmentMergeInfo)b;
/* 31 */     int comparison = stiA.term.compareTo(stiB.term);
/* 32 */     if (comparison == 0) {
/* 33 */       return (stiA.base < stiB.base);
/*    */     }
/* 35 */     return (comparison < 0);
/*    */   }
/*    */   
/*    */   final void close() throws IOException {
/* 39 */     while (top() != null)
/* 40 */       ((SegmentMergeInfo)pop()).close(); 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentMergeQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentMerger,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.document.FieldSelectorResult;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentMerger
/*     */ {
/*  44 */   static final byte[] NORMS_HEADER = new byte[] { 78, 82, 77, -1 };
/*     */   
/*     */   private Directory directory;
/*     */   private String segment;
/*  48 */   private int termIndexInterval = 128;
/*     */   
/*  50 */   private Vector readers = new Vector();
/*     */ 
/*     */   
/*     */   private FieldInfos fieldInfos;
/*     */   
/*     */   private int mergedDocs;
/*     */   
/*     */   private IndexOutput freqOutput;
/*     */   
/*     */   private IndexOutput proxOutput;
/*     */   
/*     */   private TermInfosWriter termInfosWriter;
/*     */   
/*     */   private int skipInterval;
/*     */   
/*     */   private int maxSkipLevels;
/*     */   
/*     */   private SegmentMergeQueue queue;
/*     */   
/*     */   private DefaultSkipListWriter skipListWriter;
/*     */   
/*     */   private final TermInfo termInfo;
/*     */   
/*     */   private byte[] payloadBuffer;
/*     */ 
/*     */   
/*  76 */   final void add(IndexReader reader) { this.readers.addElement(reader); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   final IndexReader segmentReader(int i) { return this.readers.elementAt(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final int merge() throws CorruptIndexException, IOException {
/*  97 */     this.mergedDocs = mergeFields();
/*  98 */     mergeTerms();
/*  99 */     mergeNorms();
/*     */     
/* 101 */     if (this.fieldInfos.hasVectors()) {
/* 102 */       mergeVectors();
/*     */     }
/* 104 */     return this.mergedDocs;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void closeReaders() throws IOException {
/* 113 */     for (int i = 0; i < this.readers.size(); i++) {
/* 114 */       IndexReader reader = this.readers.elementAt(i);
/* 115 */       reader.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   final Vector createCompoundFile(String fileName) throws IOException {
/* 121 */     CompoundFileWriter cfsWriter = new CompoundFileWriter(this.directory, fileName);
/*     */ 
/*     */     
/* 124 */     Vector files = new Vector(IndexFileNames.COMPOUND_EXTENSIONS.length + 1);
/*     */ 
/*     */ 
/*     */     
/* 128 */     for (int i = 0; i < IndexFileNames.COMPOUND_EXTENSIONS.length; i++) {
/* 129 */       files.add(this.segment + ""."" + IndexFileNames.COMPOUND_EXTENSIONS[i]);
/*     */     }
/*     */ 
/*     */     
/* 133 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 134 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 135 */       if (fi.isIndexed && !fi.omitNorms) {
/* 136 */         files.add(this.segment + ""."" + ""nrm"");
/*     */         
/*     */         break;
/*     */       } 
/*     */     } 
/*     */     
/* 142 */     if (this.fieldInfos.hasVectors()) {
/* 143 */       for (int i = 0; i < IndexFileNames.VECTOR_EXTENSIONS.length; i++) {
/* 144 */         files.add(this.segment + ""."" + IndexFileNames.VECTOR_EXTENSIONS[i]);
/*     */       }
/*     */     }
/*     */ 
/*     */     
/* 149 */     Iterator it = files.iterator();
/* 150 */     while (it.hasNext()) {
/* 151 */       cfsWriter.addFile(it.next());
/*     */     }
/*     */ 
/*     */     
/* 155 */     cfsWriter.close();
/*     */     
/* 157 */     return files;
/*     */   }
/*     */ 
/*     */   
/*     */   private void addIndexed(IndexReader reader, FieldInfos fieldInfos, Collection names, boolean storeTermVectors, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean storePayloads) throws IOException {
/* 162 */     Iterator i = names.iterator();
/* 163 */     while (i.hasNext()) {
/* 164 */       String field = i.next();
/* 165 */       fieldInfos.add(field, true, storeTermVectors, storePositionWithTermVector, storeOffsetWithTermVector, !reader.hasNorms(field), storePayloads);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int mergeFields() throws CorruptIndexException, IOException {
/* 176 */     this.fieldInfos = new FieldInfos();
/* 177 */     int docCount = 0;
/* 178 */     for (int i = 0; i < this.readers.size(); i++) {
/* 179 */       IndexReader reader = this.readers.elementAt(i);
/* 180 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false);
/* 181 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false);
/* 182 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false);
/* 183 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR), true, false, false, false);
/* 184 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.STORES_PAYLOADS), false, false, false, true);
/* 185 */       addIndexed(reader, this.fieldInfos, reader.getFieldNames(IndexReader.FieldOption.INDEXED), false, false, false, false);
/* 186 */       this.fieldInfos.add(reader.getFieldNames(IndexReader.FieldOption.UNINDEXED), false);
/*     */     } 
/* 188 */     this.fieldInfos.write(this.directory, this.segment + "".fnm"");
/*     */     
/* 190 */     FieldsWriter fieldsWriter = new FieldsWriter(this.directory, this.segment, this.fieldInfos);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 195 */     FieldSelector fieldSelectorMerge = new FieldSelector() { private final SegmentMerger this$0;
/*     */         
/* 197 */         public FieldSelectorResult accept(String fieldName) { return FieldSelectorResult.LOAD_FOR_MERGE; }
/*     */          }
/*     */       ;
/*     */ 
/*     */     
/* 202 */     try { for (int i = 0; i < this.readers.size(); i++) {
/* 203 */         IndexReader reader = this.readers.elementAt(i);
/* 204 */         int maxDoc = reader.maxDoc();
/* 205 */         for (int j = 0; j < maxDoc; j++) {
/* 206 */           if (!reader.isDeleted(j)) {
/* 207 */             fieldsWriter.addDocument(reader.document(j, fieldSelectorMerge));
/* 208 */             docCount++;
/*     */           } 
/*     */         } 
/*     */       }  }
/* 212 */     finally { fieldsWriter.close(); }
/*     */     
/* 214 */     return docCount;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void mergeVectors() throws IOException {
/* 222 */     TermVectorsWriter termVectorsWriter = new TermVectorsWriter(this.directory, this.segment, this.fieldInfos);
/*     */ 
/*     */     
/*     */     try {
/* 226 */       for (int r = 0; r < this.readers.size(); r++) {
/* 227 */         IndexReader reader = this.readers.elementAt(r);
/* 228 */         int maxDoc = reader.maxDoc();
/* 229 */         for (int docNum = 0; docNum < maxDoc; docNum++) {
/*     */           
/* 231 */           if (!reader.isDeleted(docNum))
/*     */           {
/* 233 */             termVectorsWriter.addAllDocVectors(reader.getTermFreqVectors(docNum)); } 
/*     */         } 
/*     */       } 
/*     */     } finally {
/* 237 */       termVectorsWriter.close();
/*     */     } 
/*     */   }
/*     */   
/* 241 */   SegmentMerger(Directory dir, String name) { this.freqOutput = null;
/* 242 */     this.proxOutput = null;
/* 243 */     this.termInfosWriter = null;
/*     */ 
/*     */     
/* 246 */     this.queue = null;
/* 247 */     this.skipListWriter = null;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 309 */     this.termInfo = new TermInfo();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 336 */     this.payloadBuffer = null; this.directory = dir; this.segment = name; } SegmentMerger(IndexWriter writer, String name) { this.freqOutput = null; this.proxOutput = null; this.termInfosWriter = null; this.queue = null; this.skipListWriter = null; this.termInfo = new TermInfo(); this.payloadBuffer = null; this.directory = writer.getDirectory(); this.segment = name; this.termIndexInterval = writer.getTermIndexInterval(); }
/*     */   private final void mergeTerms() throws CorruptIndexException, IOException { try {
/*     */       this.freqOutput = this.directory.createOutput(this.segment + "".frq""); this.proxOutput = this.directory.createOutput(this.segment + "".prx""); this.termInfosWriter = new TermInfosWriter(this.directory, this.segment, this.fieldInfos, this.termIndexInterval); this.skipInterval = this.termInfosWriter.skipInterval; this.maxSkipLevels = this.termInfosWriter.maxSkipLevels; this.skipListWriter = new DefaultSkipListWriter(this.skipInterval, this.maxSkipLevels, this.mergedDocs, this.freqOutput, this.proxOutput);
/*     */       this.queue = new SegmentMergeQueue(this.readers.size());
/*     */       mergeTermInfos();
/*     */     } finally {
/*     */       if (this.freqOutput != null)
/*     */         this.freqOutput.close(); 
/*     */       if (this.proxOutput != null)
/*     */         this.proxOutput.close(); 
/*     */       if (this.termInfosWriter != null)
/*     */         this.termInfosWriter.close(); 
/*     */       if (this.queue != null)
/*     */         this.queue.close(); 
/* 350 */     }  } private final int appendPostings(SegmentMergeInfo[] smis, int n) throws CorruptIndexException, IOException { int lastDoc = 0;
/* 351 */     int df = 0;
/* 352 */     this.skipListWriter.resetSkip();
/* 353 */     boolean storePayloads = (this.fieldInfos.fieldInfo((smis[0]).term.field)).storePayloads;
/* 354 */     int lastPayloadLength = -1;
/* 355 */     for (int i = 0; i < n; i++) {
/* 356 */       SegmentMergeInfo smi = smis[i];
/* 357 */       TermPositions postings = smi.getPositions();
/* 358 */       int base = smi.base;
/* 359 */       int[] docMap = smi.getDocMap();
/* 360 */       postings.seek(smi.termEnum);
/* 361 */       while (postings.next()) {
/* 362 */         int doc = postings.doc();
/* 363 */         if (docMap != null)
/* 364 */           doc = docMap[doc]; 
/* 365 */         doc += base;
/*     */         
/* 367 */         if (doc < 0 || (df > 0 && doc <= lastDoc)) {
/* 368 */           throw new CorruptIndexException(""docs out of order ("" + doc + "" <= "" + lastDoc + "" )"");
/*     */         }
/*     */         
/* 371 */         df++;
/*     */         
/* 373 */         if (df % this.skipInterval == 0) {
/* 374 */           this.skipListWriter.setSkipData(lastDoc, storePayloads, lastPayloadLength);
/* 375 */           this.skipListWriter.bufferSkip(df);
/*     */         } 
/*     */         
/* 378 */         int docCode = doc - lastDoc << 1;
/* 379 */         lastDoc = doc;
/*     */         
/* 381 */         int freq = postings.freq();
/* 382 */         if (freq == 1) {
/* 383 */           this.freqOutput.writeVInt(docCode | 0x1);
/*     */         } else {
/* 385 */           this.freqOutput.writeVInt(docCode);
/* 386 */           this.freqOutput.writeVInt(freq);
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 392 */         int lastPosition = 0;
/* 393 */         for (int j = 0; j < freq; j++) {
/* 394 */           int position = postings.nextPosition();
/* 395 */           int delta = position - lastPosition;
/* 396 */           if (storePayloads) {
/* 397 */             int payloadLength = postings.getPayloadLength();
/* 398 */             if (payloadLength == lastPayloadLength) {
/* 399 */               this.proxOutput.writeVInt(delta * 2);
/*     */             } else {
/* 401 */               this.proxOutput.writeVInt(delta * 2 + 1);
/* 402 */               this.proxOutput.writeVInt(payloadLength);
/* 403 */               lastPayloadLength = payloadLength;
/*     */             } 
/* 405 */             if (payloadLength > 0) {
/* 406 */               if (this.payloadBuffer == null || this.payloadBuffer.length < payloadLength) {
/* 407 */                 this.payloadBuffer = new byte[payloadLength];
/*     */               }
/* 409 */               postings.getPayload(this.payloadBuffer, 0);
/* 410 */               this.proxOutput.writeBytes(this.payloadBuffer, 0, payloadLength);
/*     */             } 
/*     */           } else {
/* 413 */             this.proxOutput.writeVInt(delta);
/*     */           } 
/* 415 */           lastPosition = position;
/*     */         } 
/*     */       } 
/*     */     } 
/* 419 */     return df; }
/*     */   private final void mergeTermInfos() throws CorruptIndexException, IOException { int base = 0; for (int i = 0; i < this.readers.size(); i++) { IndexReader reader = this.readers.elementAt(i); TermEnum termEnum = reader.terms(); SegmentMergeInfo smi = new SegmentMergeInfo(base, termEnum, reader); base += reader.numDocs(); if (smi.next()) { this.queue.put(smi); } else { smi.close(); }  }  SegmentMergeInfo[] match = new SegmentMergeInfo[this.readers.size()]; while (this.queue.size() > 0) { int matchSize = 0; match[matchSize++] = (SegmentMergeInfo)this.queue.pop(); Term term = (match[0]).term; SegmentMergeInfo top = (SegmentMergeInfo)this.queue.top(); while (top != null && term.compareTo(top.term) == 0) { match[matchSize++] = (SegmentMergeInfo)this.queue.pop(); top = (SegmentMergeInfo)this.queue.top(); }  mergeTermInfo(match, matchSize); while (matchSize > 0) { SegmentMergeInfo smi = match[--matchSize]; if (smi.next()) { this.queue.put(smi); continue; }  smi.close(); }  }
/*     */      }
/*     */   private final void mergeTermInfo(SegmentMergeInfo[] smis, int n) throws CorruptIndexException, IOException { long freqPointer = this.freqOutput.getFilePointer(); long proxPointer = this.proxOutput.getFilePointer(); int df = appendPostings(smis, n); long skipPointer = this.skipListWriter.writeSkip(this.freqOutput); if (df > 0) { this.termInfo.set(df, freqPointer, proxPointer, (int)(skipPointer - freqPointer)); this.termInfosWriter.add((smis[0]).term, this.termInfo); }
/* 423 */      } private void mergeNorms() throws IOException { byte[] normBuffer = null;
/* 424 */     IndexOutput output = null;
/*     */     try {
/* 426 */       for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 427 */         FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 428 */         if (fi.isIndexed && !fi.omitNorms) {
/* 429 */           if (output == null) {
/* 430 */             output = this.directory.createOutput(this.segment + ""."" + ""nrm"");
/* 431 */             output.writeBytes(NORMS_HEADER, NORMS_HEADER.length);
/*     */           } 
/* 433 */           for (int j = 0; j < this.readers.size(); j++) {
/* 434 */             IndexReader reader = this.readers.elementAt(j);
/* 435 */             int maxDoc = reader.maxDoc();
/* 436 */             if (normBuffer == null || normBuffer.length < maxDoc)
/*     */             {
/* 438 */               normBuffer = new byte[maxDoc];
/*     */             }
/* 440 */             reader.norms(fi.name, normBuffer, 0);
/* 441 */             if (!reader.hasDeletions()) {
/*     */               
/* 443 */               output.writeBytes(normBuffer, maxDoc);
/*     */             }
/*     */             else {
/*     */               
/* 447 */               for (int k = 0; k < maxDoc; k++) {
/* 448 */                 if (!reader.isDeleted(k)) {
/* 449 */                   output.writeByte(normBuffer[k]);
/*     */                 }
/*     */               } 
/*     */             } 
/*     */           } 
/*     */         } 
/*     */       } 
/*     */     } finally {
/* 457 */       if (output != null)
/* 458 */         output.close(); 
/*     */     }  }
/*     */ 
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentMerger.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Collection;
/*     */ import java.util.Enumeration;
/*     */ import java.util.HashSet;
/*     */ import java.util.Hashtable;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.search.DefaultSimilarity;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.BitVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SegmentReader
/*     */   extends IndexReader
/*     */ {
/*     */   private String segment;
/*     */   private SegmentInfo si;
/*     */   FieldInfos fieldInfos;
/*     */   private FieldsReader fieldsReader;
/*     */   TermInfosReader tis;
/*  43 */   TermVectorsReader termVectorsReaderOrig = null;
/*  44 */   ThreadLocal termVectorsLocal = new ThreadLocal();
/*     */   
/*  46 */   BitVector deletedDocs = null;
/*     */   
/*     */   private boolean deletedDocsDirty = false;
/*     */   
/*     */   private boolean normsDirty = false;
/*     */   
/*     */   private boolean undeleteAll = false;
/*     */   
/*     */   private boolean rollbackDeletedDocsDirty = false;
/*     */   
/*     */   private boolean rollbackNormsDirty = false;
/*     */   
/*     */   private boolean rollbackUndeleteAll = false;
/*     */   IndexInput freqStream;
/*     */   IndexInput proxStream;
/*     */   private IndexInput singleNormStream;
/*  62 */   CompoundFileReader cfsReader = null;
/*     */   
/*     */   private class Norm
/*     */   {
/*     */     public Norm(IndexInput in, int number, long normSeek) {
/*  67 */       this.in = in;
/*  68 */       this.number = number;
/*  69 */       this.normSeek = normSeek;
/*     */     }
/*     */     
/*     */     private IndexInput in;
/*     */     private byte[] bytes;
/*     */     private boolean dirty;
/*     */     private int number;
/*     */     private long normSeek;
/*     */     private boolean rollbackDirty;
/*     */     private final SegmentReader this$0;
/*     */     
/*     */     private void reWrite(SegmentInfo si) throws IOException {
/*  81 */       si.advanceNormGen(this.number);
/*  82 */       IndexOutput out = SegmentReader.this.directory().createOutput(si.getNormFileName(this.number));
/*     */       try {
/*  84 */         out.writeBytes(this.bytes, SegmentReader.this.maxDoc());
/*     */       } finally {
/*  86 */         out.close();
/*     */       } 
/*  88 */       this.dirty = false;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public void close() throws IOException {
/*  96 */       if (this.in != null && this.in != SegmentReader.this.singleNormStream) {
/*  97 */         this.in.close();
/*     */       }
/*  99 */       this.in = null;
/*     */     }
/*     */   }
/*     */   
/* 103 */   private Hashtable norms = new Hashtable();
/*     */   private static Class IMPL;
/*     */   private byte[] ones;
/*     */   
/*     */   static  {
/*     */     try {
/* 109 */       String name = System.getProperty(""org.apache.lucene.SegmentReader.class"", SegmentReader.class.getName());
/*     */ 
/*     */       
/* 112 */       IMPL = Class.forName(name);
/* 113 */     } catch (ClassNotFoundException e) {
/* 114 */       throw new RuntimeException(""cannot load SegmentReader class: "" + e, e);
/* 115 */     } catch (SecurityException se) {
/*     */       try {
/* 117 */         IMPL = Class.forName(SegmentReader.class.getName());
/* 118 */       } catch (ClassNotFoundException e) {
/* 119 */         throw new RuntimeException(""cannot load default SegmentReader class: "" + e, e);
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/* 124 */   protected SegmentReader() { super(null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 131 */   public static SegmentReader get(SegmentInfo si) throws CorruptIndexException, IOException { return get(si.dir, si, null, false, false, 1024); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 139 */   public static SegmentReader get(SegmentInfo si, int readBufferSize) throws CorruptIndexException, IOException { return get(si.dir, si, null, false, false, readBufferSize); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 148 */   public static SegmentReader get(SegmentInfos sis, SegmentInfo si, boolean closeDir) throws CorruptIndexException, IOException { return get(si.dir, si, sis, closeDir, true, 1024); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static SegmentReader get(Directory dir, SegmentInfo si, SegmentInfos sis, boolean closeDir, boolean ownDir, int readBufferSize) throws CorruptIndexException, IOException {
/*     */     SegmentReader instance;
/*     */     try {
/* 162 */       instance = IMPL.newInstance();
/* 163 */     } catch (Exception e) {
/* 164 */       throw new RuntimeException(""cannot load SegmentReader class: "" + e, e);
/*     */     } 
/* 166 */     instance.init(dir, sis, closeDir, ownDir);
/* 167 */     instance.initialize(si, readBufferSize);
/* 168 */     return instance;
/*     */   }
/*     */   
/*     */   private void initialize(SegmentInfo si, int readBufferSize) throws CorruptIndexException, IOException {
/* 172 */     this.segment = si.name;
/* 173 */     this.si = si;
/*     */     
/* 175 */     boolean success = false;
/*     */ 
/*     */     
/*     */     try {
/* 179 */       Directory cfsDir = directory();
/* 180 */       if (si.getUseCompoundFile()) {
/* 181 */         this.cfsReader = new CompoundFileReader(directory(), this.segment + "".cfs"", readBufferSize);
/* 182 */         cfsDir = this.cfsReader;
/*     */       } 
/*     */ 
/*     */       
/* 186 */       this.fieldInfos = new FieldInfos(cfsDir, this.segment + "".fnm"");
/* 187 */       this.fieldsReader = new FieldsReader(cfsDir, this.segment, this.fieldInfos, readBufferSize);
/*     */ 
/*     */       
/* 190 */       if (this.fieldsReader.size() != si.docCount) {
/* 191 */         throw new CorruptIndexException(""doc counts differ for segment "" + si.name + "": fieldsReader shows "" + this.fieldsReader.size() + "" but segmentInfo shows "" + si.docCount);
/*     */       }
/*     */       
/* 194 */       this.tis = new TermInfosReader(cfsDir, this.segment, this.fieldInfos, readBufferSize);
/*     */ 
/*     */       
/* 197 */       if (hasDeletions(si)) {
/* 198 */         this.deletedDocs = new BitVector(directory(), si.getDelFileName());
/*     */ 
/*     */         
/* 201 */         if (this.deletedDocs.count() > maxDoc()) {
/* 202 */           throw new CorruptIndexException(""number of deletes ("" + this.deletedDocs.count() + "") exceeds max doc ("" + maxDoc() + "") for segment "" + si.name);
/*     */         }
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 208 */       this.freqStream = cfsDir.openInput(this.segment + "".frq"", readBufferSize);
/* 209 */       this.proxStream = cfsDir.openInput(this.segment + "".prx"", readBufferSize);
/* 210 */       openNorms(cfsDir, readBufferSize);
/*     */       
/* 212 */       if (this.fieldInfos.hasVectors()) {
/* 213 */         this.termVectorsReaderOrig = new TermVectorsReader(cfsDir, this.segment, this.fieldInfos, readBufferSize);
/*     */       }
/* 215 */       success = true;
/*     */ 
/*     */     
/*     */     }
/*     */     finally {
/*     */ 
/*     */ 
/*     */       
/* 223 */       if (!success) {
/* 224 */         doClose();
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   protected void doCommit() throws IOException {
/* 230 */     if (this.deletedDocsDirty) {
/* 231 */       this.si.advanceDelGen();
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 236 */       this.deletedDocs.write(directory(), this.si.getDelFileName());
/*     */     } 
/* 238 */     if (this.undeleteAll && this.si.hasDeletions()) {
/* 239 */       this.si.clearDelGen();
/*     */     }
/* 241 */     if (this.normsDirty) {
/* 242 */       this.si.setNumFields(this.fieldInfos.size());
/* 243 */       Enumeration values = this.norms.elements();
/* 244 */       while (values.hasMoreElements()) {
/* 245 */         Norm norm = values.nextElement();
/* 246 */         if (norm.dirty) {
/* 247 */           norm.reWrite(this.si);
/*     */         }
/*     */       } 
/*     */     } 
/* 251 */     this.deletedDocsDirty = false;
/* 252 */     this.normsDirty = false;
/* 253 */     this.undeleteAll = false;
/*     */   }
/*     */   
/*     */   protected void doClose() throws IOException {
/* 257 */     if (this.fieldsReader != null) {
/* 258 */       this.fieldsReader.close();
/*     */     }
/* 260 */     if (this.tis != null) {
/* 261 */       this.tis.close();
/*     */     }
/*     */     
/* 264 */     if (this.freqStream != null)
/* 265 */       this.freqStream.close(); 
/* 266 */     if (this.proxStream != null) {
/* 267 */       this.proxStream.close();
/*     */     }
/* 269 */     closeNorms();
/*     */     
/* 271 */     if (this.termVectorsReaderOrig != null) {
/* 272 */       this.termVectorsReaderOrig.close();
/*     */     }
/* 274 */     if (this.cfsReader != null) {
/* 275 */       this.cfsReader.close();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 280 */   static boolean hasDeletions(SegmentInfo si) throws IOException { return si.hasDeletions(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 285 */   public boolean hasDeletions() { return (this.deletedDocs != null); }
/*     */ 
/*     */ 
/*     */   
/* 289 */   static boolean usesCompoundFile(SegmentInfo si) throws IOException { return si.getUseCompoundFile(); }
/*     */ 
/*     */ 
/*     */   
/* 293 */   static boolean hasSeparateNorms(SegmentInfo si) throws IOException { return si.hasSeparateNorms(); }
/*     */ 
/*     */   
/*     */   protected void doDelete(int docNum) {
/* 297 */     if (this.deletedDocs == null)
/* 298 */       this.deletedDocs = new BitVector(maxDoc()); 
/* 299 */     this.deletedDocsDirty = true;
/* 300 */     this.undeleteAll = false;
/* 301 */     this.deletedDocs.set(docNum);
/*     */   }
/*     */   
/*     */   protected void doUndeleteAll() {
/* 305 */     this.deletedDocs = null;
/* 306 */     this.deletedDocsDirty = false;
/* 307 */     this.undeleteAll = true;
/*     */   }
/*     */ 
/*     */   
/* 311 */   Vector files() throws IOException { return new Vector(this.si.files()); }
/*     */ 
/*     */   
/*     */   public TermEnum terms() {
/* 315 */     ensureOpen();
/* 316 */     return this.tis.terms();
/*     */   }
/*     */   
/*     */   public TermEnum terms(Term t) throws IOException {
/* 320 */     ensureOpen();
/* 321 */     return this.tis.terms(t);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized Document document(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 329 */     ensureOpen();
/* 330 */     if (isDeleted(n)) {
/* 331 */       throw new IllegalArgumentException(""attempt to access a deleted document"");
/*     */     }
/* 333 */     return this.fieldsReader.doc(n, fieldSelector);
/*     */   }
/*     */ 
/*     */   
/* 337 */   public synchronized boolean isDeleted(int n) { return (this.deletedDocs != null && this.deletedDocs.get(n)); }
/*     */ 
/*     */   
/*     */   public TermDocs termDocs() throws IOException {
/* 341 */     ensureOpen();
/* 342 */     return new SegmentTermDocs(this);
/*     */   }
/*     */   
/*     */   public TermPositions termPositions() throws IOException {
/* 346 */     ensureOpen();
/* 347 */     return new SegmentTermPositions(this);
/*     */   }
/*     */   
/*     */   public int docFreq(Term t) throws IOException {
/* 351 */     ensureOpen();
/* 352 */     TermInfo ti = this.tis.get(t);
/* 353 */     if (ti != null) {
/* 354 */       return ti.docFreq;
/*     */     }
/* 356 */     return 0;
/*     */   }
/*     */ 
/*     */   
/*     */   public int numDocs() {
/* 361 */     int n = maxDoc();
/* 362 */     if (this.deletedDocs != null)
/* 363 */       n -= this.deletedDocs.count(); 
/* 364 */     return n;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 369 */   public int maxDoc() { return this.si.docCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getFieldNames(IndexReader.FieldOption fieldOption) {
/* 376 */     ensureOpen();
/*     */     
/* 378 */     Set fieldSet = new HashSet();
/* 379 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 380 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 381 */       if (fieldOption == IndexReader.FieldOption.ALL) {
/* 382 */         fieldSet.add(fi.name);
/*     */       }
/* 384 */       else if (!fi.isIndexed && fieldOption == IndexReader.FieldOption.UNINDEXED) {
/* 385 */         fieldSet.add(fi.name);
/*     */       }
/* 387 */       else if (fi.storePayloads && fieldOption == IndexReader.FieldOption.STORES_PAYLOADS) {
/* 388 */         fieldSet.add(fi.name);
/*     */       }
/* 390 */       else if (fi.isIndexed && fieldOption == IndexReader.FieldOption.INDEXED) {
/* 391 */         fieldSet.add(fi.name);
/*     */       }
/* 393 */       else if (fi.isIndexed && !fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_NO_TERMVECTOR) {
/* 394 */         fieldSet.add(fi.name);
/*     */       }
/* 396 */       else if (fi.storeTermVector == true && !fi.storePositionWithTermVector && !fi.storeOffsetWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR) {
/*     */ 
/*     */ 
/*     */         
/* 400 */         fieldSet.add(fi.name);
/*     */       }
/* 402 */       else if (fi.isIndexed && fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR) {
/* 403 */         fieldSet.add(fi.name);
/*     */       }
/* 405 */       else if (fi.storePositionWithTermVector && !fi.storeOffsetWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION) {
/* 406 */         fieldSet.add(fi.name);
/*     */       }
/* 408 */       else if (fi.storeOffsetWithTermVector && !fi.storePositionWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET) {
/* 409 */         fieldSet.add(fi.name);
/*     */       }
/* 411 */       else if (fi.storeOffsetWithTermVector && fi.storePositionWithTermVector && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET) {
/*     */         
/* 413 */         fieldSet.add(fi.name);
/*     */       } 
/*     */     } 
/* 416 */     return fieldSet;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized boolean hasNorms(String field) {
/* 421 */     ensureOpen();
/* 422 */     return this.norms.containsKey(field);
/*     */   }
/*     */   
/*     */   static byte[] createFakeNorms(int size) {
/* 426 */     byte[] ones = new byte[size];
/* 427 */     Arrays.fill(ones, DefaultSimilarity.encodeNorm(1.0F));
/* 428 */     return ones;
/*     */   }
/*     */ 
/*     */   
/*     */   private byte[] fakeNorms() {
/* 433 */     if (this.ones == null) this.ones = createFakeNorms(maxDoc()); 
/* 434 */     return this.ones;
/*     */   }
/*     */ 
/*     */   
/*     */   protected synchronized byte[] getNorms(String field) throws IOException {
/* 439 */     Norm norm = (Norm)this.norms.get(field);
/* 440 */     if (norm == null) return null; 
/* 441 */     if (norm.bytes == null) {
/* 442 */       byte[] bytes = new byte[maxDoc()];
/* 443 */       norms(field, bytes, 0);
/* 444 */       norm.bytes = bytes;
/*     */ 
/*     */       
/* 447 */       norm.close();
/*     */     } 
/* 449 */     return norm.bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized byte[] norms(String field) throws IOException {
/* 454 */     ensureOpen();
/* 455 */     byte[] bytes = getNorms(field);
/* 456 */     if (bytes == null) bytes = fakeNorms(); 
/* 457 */     return bytes;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void doSetNorm(int doc, String field, byte value) throws IOException {
/* 462 */     Norm norm = (Norm)this.norms.get(field);
/* 463 */     if (norm == null) {
/*     */       return;
/*     */     }
/* 466 */     norm.dirty = true;
/* 467 */     this.normsDirty = true;
/*     */     
/* 469 */     norms(field)[doc] = value;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void norms(String field, byte[] bytes, int offset) throws IOException {
/* 476 */     ensureOpen();
/* 477 */     Norm norm = (Norm)this.norms.get(field);
/* 478 */     if (norm == null) {
/* 479 */       System.arraycopy(fakeNorms(), 0, bytes, offset, maxDoc());
/*     */       
/*     */       return;
/*     */     } 
/* 483 */     if (norm.bytes != null) {
/* 484 */       System.arraycopy(norm.bytes, 0, bytes, offset, maxDoc());
/*     */ 
/*     */       
/*     */       return;
/*     */     } 
/*     */     
/* 490 */     norm.in.seek(norm.normSeek);
/* 491 */     norm.in.readBytes(bytes, offset, maxDoc());
/*     */   }
/*     */ 
/*     */   
/*     */   private void openNorms(Directory cfsDir, int readBufferSize) throws IOException {
/* 496 */     long nextNormSeek = SegmentMerger.NORMS_HEADER.length;
/* 497 */     int maxDoc = maxDoc();
/* 498 */     for (int i = 0; i < this.fieldInfos.size(); i++) {
/* 499 */       FieldInfo fi = this.fieldInfos.fieldInfo(i);
/* 500 */       if (fi.isIndexed && !fi.omitNorms) {
/* 501 */         long normSeek; Directory d = directory();
/* 502 */         String fileName = this.si.getNormFileName(fi.number);
/* 503 */         if (!this.si.hasSeparateNorms(fi.number)) {
/* 504 */           d = cfsDir;
/*     */         }
/*     */ 
/*     */         
/* 508 */         boolean singleNormFile = fileName.endsWith("".nrm"");
/* 509 */         IndexInput normInput = null;
/*     */ 
/*     */         
/* 512 */         if (singleNormFile) {
/* 513 */           normSeek = nextNormSeek;
/* 514 */           if (this.singleNormStream == null) {
/* 515 */             this.singleNormStream = d.openInput(fileName, readBufferSize);
/*     */           }
/*     */ 
/*     */ 
/*     */           
/* 520 */           normInput = this.singleNormStream;
/*     */         } else {
/* 522 */           normSeek = 0L;
/* 523 */           normInput = d.openInput(fileName);
/*     */         } 
/*     */         
/* 526 */         this.norms.put(fi.name, new Norm(normInput, fi.number, normSeek));
/* 527 */         nextNormSeek += maxDoc;
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void closeNorms() throws IOException {
/* 533 */     synchronized (this.norms) {
/* 534 */       Enumeration enumerator = this.norms.elements();
/* 535 */       while (enumerator.hasMoreElements()) {
/* 536 */         Norm norm = enumerator.nextElement();
/* 537 */         norm.close();
/*     */       } 
/* 539 */       if (this.singleNormStream != null) {
/* 540 */         this.singleNormStream.close();
/* 541 */         this.singleNormStream = null;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private TermVectorsReader getTermVectorsReader() {
/* 551 */     TermVectorsReader tvReader = this.termVectorsLocal.get();
/* 552 */     if (tvReader == null) {
/* 553 */       tvReader = (TermVectorsReader)this.termVectorsReaderOrig.clone();
/* 554 */       this.termVectorsLocal.set(tvReader);
/*     */     } 
/* 556 */     return tvReader;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector getTermFreqVector(int docNumber, String field) throws IOException {
/* 567 */     ensureOpen();
/* 568 */     FieldInfo fi = this.fieldInfos.fieldInfo(field);
/* 569 */     if (fi == null || !fi.storeTermVector || this.termVectorsReaderOrig == null) {
/* 570 */       return null;
/*     */     }
/* 572 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 573 */     if (termVectorsReader == null) {
/* 574 */       return null;
/*     */     }
/* 576 */     return termVectorsReader.get(docNumber, field);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermFreqVector[] getTermFreqVectors(int docNumber) throws IOException {
/* 588 */     ensureOpen();
/* 589 */     if (this.termVectorsReaderOrig == null) {
/* 590 */       return null;
/*     */     }
/* 592 */     TermVectorsReader termVectorsReader = getTermVectorsReader();
/* 593 */     if (termVectorsReader == null) {
/* 594 */       return null;
/*     */     }
/* 596 */     return termVectorsReader.get(docNumber);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 601 */   FieldInfos fieldInfos() { return this.fieldInfos; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 608 */   String getSegmentName() { return this.segment; }
/*     */ 
/*     */ 
/*     */   
/* 612 */   void setSegmentInfo(SegmentInfo info) { this.si = info; }
/*     */ 
/*     */   
/*     */   void startCommit() {
/* 616 */     super.startCommit();
/* 617 */     this.rollbackDeletedDocsDirty = this.deletedDocsDirty;
/* 618 */     this.rollbackNormsDirty = this.normsDirty;
/* 619 */     this.rollbackUndeleteAll = this.undeleteAll;
/* 620 */     Enumeration values = this.norms.elements();
/* 621 */     while (values.hasMoreElements()) {
/* 622 */       Norm norm = values.nextElement();
/* 623 */       norm.rollbackDirty = norm.dirty;
/*     */     } 
/*     */   }
/*     */   
/*     */   void rollbackCommit() {
/* 628 */     super.rollbackCommit();
/* 629 */     this.deletedDocsDirty = this.rollbackDeletedDocsDirty;
/* 630 */     this.normsDirty = this.rollbackNormsDirty;
/* 631 */     this.undeleteAll = this.rollbackUndeleteAll;
/* 632 */     Enumeration values = this.norms.elements();
/* 633 */     while (values.hasMoreElements()) {
/* 634 */       Norm norm = values.nextElement();
/* 635 */       norm.dirty = norm.rollbackDirty;
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermDocs,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.util.BitVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SegmentTermDocs
/*     */   implements TermDocs
/*     */ {
/*     */   protected SegmentReader parent;
/*     */   protected IndexInput freqStream;
/*     */   protected int count;
/*     */   protected int df;
/*     */   protected BitVector deletedDocs;
/*  30 */   int doc = 0;
/*     */   
/*     */   int freq;
/*     */   
/*     */   private int skipInterval;
/*     */   
/*     */   private int maxSkipLevels;
/*     */   
/*     */   private DefaultSkipListReader skipListReader;
/*     */   private long freqBasePointer;
/*     */   private long proxBasePointer;
/*     */   private long skipPointer;
/*     */   private boolean haveSkipped;
/*     */   protected boolean currentFieldStoresPayloads;
/*     */   
/*     */   protected SegmentTermDocs(SegmentReader parent) {
/*  46 */     this.parent = parent;
/*  47 */     this.freqStream = (IndexInput)parent.freqStream.clone();
/*  48 */     this.deletedDocs = parent.deletedDocs;
/*  49 */     this.skipInterval = parent.tis.getSkipInterval();
/*  50 */     this.maxSkipLevels = parent.tis.getMaxSkipLevels();
/*     */   }
/*     */   
/*     */   public void seek(Term term) throws IOException {
/*  54 */     TermInfo ti = this.parent.tis.get(term);
/*  55 */     seek(ti, term);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(TermEnum termEnum) throws IOException {
/*     */     Term term;
/*     */     TermInfo ti;
/*  63 */     if (termEnum instanceof SegmentTermEnum && ((SegmentTermEnum)termEnum).fieldInfos == this.parent.fieldInfos) {
/*  64 */       SegmentTermEnum segmentTermEnum = (SegmentTermEnum)termEnum;
/*  65 */       term = segmentTermEnum.term();
/*  66 */       ti = segmentTermEnum.termInfo();
/*     */     } else {
/*  68 */       term = termEnum.term();
/*  69 */       ti = this.parent.tis.get(term);
/*     */     } 
/*     */     
/*  72 */     seek(ti, term);
/*     */   }
/*     */   
/*     */   void seek(TermInfo ti, Term term) throws IOException {
/*  76 */     this.count = 0;
/*  77 */     FieldInfo fi = this.parent.fieldInfos.fieldInfo(term.field);
/*  78 */     this.currentFieldStoresPayloads = (fi != null) ? fi.storePayloads : false;
/*  79 */     if (ti == null) {
/*  80 */       this.df = 0;
/*     */     } else {
/*  82 */       this.df = ti.docFreq;
/*  83 */       this.doc = 0;
/*  84 */       this.freqBasePointer = ti.freqPointer;
/*  85 */       this.proxBasePointer = ti.proxPointer;
/*  86 */       this.skipPointer = this.freqBasePointer + ti.skipOffset;
/*  87 */       this.freqStream.seek(this.freqBasePointer);
/*  88 */       this.haveSkipped = false;
/*     */     } 
/*     */   }
/*     */   
/*     */   public void close() throws IOException {
/*  93 */     this.freqStream.close();
/*  94 */     if (this.skipListReader != null)
/*  95 */       this.skipListReader.close(); 
/*     */   }
/*     */   
/*  98 */   public final int doc() { return this.doc; }
/*  99 */   public final int freq() { return this.freq; }
/*     */ 
/*     */   
/*     */   protected void skippingDoc() throws IOException {}
/*     */   
/*     */   public boolean next() throws IOException {
/*     */     while (true) {
/* 106 */       if (this.count == this.df) {
/* 107 */         return false;
/*     */       }
/* 109 */       int docCode = this.freqStream.readVInt();
/* 110 */       this.doc += docCode >>> 1;
/* 111 */       if ((docCode & 0x1) != 0) {
/* 112 */         this.freq = 1;
/*     */       } else {
/* 114 */         this.freq = this.freqStream.readVInt();
/*     */       } 
/* 116 */       this.count++;
/*     */       
/* 118 */       if (this.deletedDocs == null || !this.deletedDocs.get(this.doc))
/*     */         break; 
/* 120 */       skippingDoc();
/*     */     } 
/* 122 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int read(int[] docs, int[] freqs) throws IOException {
/* 128 */     int length = docs.length;
/* 129 */     int i = 0;
/* 130 */     while (i < length && this.count < this.df) {
/*     */ 
/*     */       
/* 133 */       int docCode = this.freqStream.readVInt();
/* 134 */       this.doc += docCode >>> 1;
/* 135 */       if ((docCode & 0x1) != 0) {
/* 136 */         this.freq = 1;
/*     */       } else {
/* 138 */         this.freq = this.freqStream.readVInt();
/* 139 */       }  this.count++;
/*     */       
/* 141 */       if (this.deletedDocs == null || !this.deletedDocs.get(this.doc)) {
/* 142 */         docs[i] = this.doc;
/* 143 */         freqs[i] = this.freq;
/* 144 */         i++;
/*     */       } 
/*     */     } 
/* 147 */     return i;
/*     */   }
/*     */ 
/*     */   
/*     */   protected void skipProx(long proxPointer, int payloadLength) throws IOException {}
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 155 */     if (this.df >= this.skipInterval) {
/* 156 */       if (this.skipListReader == null) {
/* 157 */         this.skipListReader = new DefaultSkipListReader((IndexInput)this.freqStream.clone(), this.maxSkipLevels, this.skipInterval);
/*     */       }
/* 159 */       if (!this.haveSkipped) {
/* 160 */         this.skipListReader.init(this.skipPointer, this.freqBasePointer, this.proxBasePointer, this.df, this.currentFieldStoresPayloads);
/* 161 */         this.haveSkipped = true;
/*     */       } 
/*     */       
/* 164 */       int newCount = this.skipListReader.skipTo(target);
/* 165 */       if (newCount > this.count) {
/* 166 */         this.freqStream.seek(this.skipListReader.getFreqPointer());
/* 167 */         skipProx(this.skipListReader.getProxPointer(), this.skipListReader.getPayloadLength());
/*     */         
/* 169 */         this.doc = this.skipListReader.getDoc();
/* 170 */         this.count = newCount;
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/*     */     do {
/* 176 */       if (!next())
/* 177 */         return false; 
/* 178 */     } while (target > this.doc);
/* 179 */     return true;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentTermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermEnum,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentTermEnum
/*     */   extends TermEnum
/*     */   implements Cloneable
/*     */ {
/*     */   private IndexInput input;
/*     */   FieldInfos fieldInfos;
/*     */   long size;
/*  27 */   long position = -1L;
/*     */   
/*  29 */   private TermBuffer termBuffer = new TermBuffer();
/*  30 */   private TermBuffer prevBuffer = new TermBuffer();
/*     */   
/*     */   private TermBuffer scratch;
/*  33 */   private TermInfo termInfo = new TermInfo();
/*     */   
/*     */   private int format;
/*     */   private boolean isIndex = false;
/*  37 */   long indexPointer = 0L;
/*     */   
/*     */   int indexInterval;
/*     */   int skipInterval;
/*     */   int maxSkipLevels;
/*     */   private int formatM1SkipInterval;
/*     */   
/*     */   SegmentTermEnum(IndexInput i, FieldInfos fis, boolean isi) throws CorruptIndexException, IOException {
/*  45 */     this.input = i;
/*  46 */     this.fieldInfos = fis;
/*  47 */     this.isIndex = isi;
/*  48 */     this.maxSkipLevels = 1;
/*     */     
/*  50 */     int firstInt = this.input.readInt();
/*  51 */     if (firstInt >= 0) {
/*     */       
/*  53 */       this.format = 0;
/*  54 */       this.size = firstInt;
/*     */ 
/*     */       
/*  57 */       this.indexInterval = 128;
/*  58 */       this.skipInterval = Integer.MAX_VALUE;
/*     */     } else {
/*     */       
/*  61 */       this.format = firstInt;
/*     */ 
/*     */       
/*  64 */       if (this.format < -3) {
/*  65 */         throw new CorruptIndexException(""Unknown format version:"" + this.format);
/*     */       }
/*  67 */       this.size = this.input.readLong();
/*     */       
/*  69 */       if (this.format == -1) {
/*  70 */         if (!this.isIndex) {
/*  71 */           this.indexInterval = this.input.readInt();
/*  72 */           this.formatM1SkipInterval = this.input.readInt();
/*     */         } 
/*     */ 
/*     */         
/*  76 */         this.skipInterval = Integer.MAX_VALUE;
/*     */       } else {
/*  78 */         this.indexInterval = this.input.readInt();
/*  79 */         this.skipInterval = this.input.readInt();
/*  80 */         if (this.format == -3)
/*     */         {
/*  82 */           this.maxSkipLevels = this.input.readInt();
/*     */         }
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   protected Object clone() {
/*  90 */     SegmentTermEnum clone = null;
/*     */     try {
/*  92 */       clone = (SegmentTermEnum)super.clone();
/*  93 */     } catch (CloneNotSupportedException e) {}
/*     */     
/*  95 */     clone.input = (IndexInput)this.input.clone();
/*  96 */     clone.termInfo = new TermInfo(this.termInfo);
/*     */     
/*  98 */     clone.termBuffer = (TermBuffer)this.termBuffer.clone();
/*  99 */     clone.prevBuffer = (TermBuffer)this.prevBuffer.clone();
/* 100 */     clone.scratch = null;
/*     */     
/* 102 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   final void seek(long pointer, int p, Term t, TermInfo ti) throws IOException {
/* 107 */     this.input.seek(pointer);
/* 108 */     this.position = p;
/* 109 */     this.termBuffer.set(t);
/* 110 */     this.prevBuffer.reset();
/* 111 */     this.termInfo.set(ti);
/*     */   }
/*     */ 
/*     */   
/*     */   public final boolean next() throws IOException {
/* 116 */     if (this.position++ >= this.size - 1L) {
/* 117 */       this.termBuffer.reset();
/* 118 */       return false;
/*     */     } 
/*     */     
/* 121 */     this.prevBuffer.set(this.termBuffer);
/* 122 */     this.termBuffer.read(this.input, this.fieldInfos);
/*     */     
/* 124 */     this.termInfo.docFreq = this.input.readVInt();
/* 125 */     this.termInfo.freqPointer += this.input.readVLong();
/* 126 */     this.termInfo.proxPointer += this.input.readVLong();
/*     */     
/* 128 */     if (this.format == -1) {
/*     */ 
/*     */       
/* 131 */       if (!this.isIndex && 
/* 132 */         this.termInfo.docFreq > this.formatM1SkipInterval) {
/* 133 */         this.termInfo.skipOffset = this.input.readVInt();
/*     */       
/*     */       }
/*     */     
/*     */     }
/* 138 */     else if (this.termInfo.docFreq >= this.skipInterval) {
/* 139 */       this.termInfo.skipOffset = this.input.readVInt();
/*     */     } 
/*     */     
/* 142 */     if (this.isIndex) {
/* 143 */       this.indexPointer += this.input.readVLong();
/*     */     }
/* 145 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   final void scanTo(Term term) throws IOException {
/* 150 */     if (this.scratch == null)
/* 151 */       this.scratch = new TermBuffer(); 
/* 152 */     this.scratch.set(term);
/* 153 */     while (this.scratch.compareTo(this.termBuffer) > 0 && next());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 159 */   public final Term term() { return this.termBuffer.toTerm(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 164 */   final Term prev() { return this.prevBuffer.toTerm(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 170 */   final TermInfo termInfo() { return new TermInfo(this.termInfo); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 176 */   final void termInfo(TermInfo ti) { ti.set(this.termInfo); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 182 */   public final int docFreq() { return this.termInfo.docFreq; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 188 */   final long freqPointer() { return this.termInfo.freqPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 194 */   final long proxPointer() { return this.termInfo.proxPointer; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 199 */   public final void close() throws IOException { this.input.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermPositions,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SegmentTermPositions
/*     */   extends SegmentTermDocs
/*     */   implements TermPositions
/*     */ {
/*     */   private IndexInput proxStream;
/*     */   private int proxCount;
/*     */   private int position;
/*     */   private int payloadLength;
/*     */   private boolean needToLoadPayload;
/*  38 */   private long lazySkipPointer = 0L;
/*  39 */   private int lazySkipProxCount = 0;
/*     */   
/*     */   SegmentTermPositions(SegmentReader p) {
/*  42 */     super(p);
/*  43 */     this.proxStream = null;
/*     */   }
/*     */   
/*     */   final void seek(TermInfo ti, Term term) throws IOException {
/*  47 */     super.seek(ti, term);
/*  48 */     if (ti != null) {
/*  49 */       this.lazySkipPointer = ti.proxPointer;
/*     */     }
/*  51 */     this.lazySkipProxCount = 0;
/*  52 */     this.proxCount = 0;
/*  53 */     this.payloadLength = 0;
/*  54 */     this.needToLoadPayload = false;
/*     */   }
/*     */   
/*     */   public final void close() throws IOException {
/*  58 */     super.close();
/*  59 */     if (this.proxStream != null) this.proxStream.close();
/*     */   
/*     */   }
/*     */   
/*     */   public final int nextPosition() throws IOException {
/*  64 */     lazySkip();
/*  65 */     this.proxCount--;
/*  66 */     return this.position += readDeltaPosition();
/*     */   }
/*     */   
/*     */   private final int readDeltaPosition() throws IOException {
/*  70 */     int delta = this.proxStream.readVInt();
/*  71 */     if (this.currentFieldStoresPayloads) {
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  76 */       if ((delta & 0x1) != 0) {
/*  77 */         this.payloadLength = this.proxStream.readVInt();
/*     */       }
/*  79 */       delta >>>= 1;
/*  80 */       this.needToLoadPayload = true;
/*     */     } else {
/*  82 */       this.payloadLength = 0;
/*  83 */       this.needToLoadPayload = false;
/*     */     } 
/*  85 */     return delta;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  90 */   protected final void skippingDoc() throws IOException { this.lazySkipProxCount += this.freq; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean next() throws IOException {
/*  96 */     this.lazySkipProxCount += this.proxCount;
/*     */     
/*  98 */     if (super.next()) {
/*  99 */       this.proxCount = this.freq;
/* 100 */       this.position = 0;
/* 101 */       return true;
/*     */     } 
/* 103 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 107 */   public final int read(int[] docs, int[] freqs) { throw new UnsupportedOperationException(""TermPositions does not support processing multiple documents in one call. Use TermDocs instead.""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected void skipProx(long proxPointer, int payloadLength) throws IOException {
/* 114 */     this.lazySkipPointer = proxPointer;
/* 115 */     this.lazySkipProxCount = 0;
/* 116 */     this.proxCount = 0;
/* 117 */     this.payloadLength = payloadLength;
/* 118 */     this.needToLoadPayload = false;
/*     */   }
/*     */   
/*     */   private void skipPositions(int n) throws IOException {
/* 122 */     for (int f = n; f > 0; f--) {
/* 123 */       readDeltaPosition();
/* 124 */       skipPayload();
/*     */     } 
/*     */   }
/*     */   
/*     */   private void skipPayload() throws IOException {
/* 129 */     if (this.needToLoadPayload && this.payloadLength > 0) {
/* 130 */       this.proxStream.seek(this.proxStream.getFilePointer() + this.payloadLength);
/*     */     }
/* 132 */     this.needToLoadPayload = false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void lazySkip() throws IOException {
/* 146 */     if (this.proxStream == null)
/*     */     {
/* 148 */       this.proxStream = (IndexInput)this.parent.proxStream.clone();
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 153 */     skipPayload();
/*     */     
/* 155 */     if (this.lazySkipPointer != 0L) {
/* 156 */       this.proxStream.seek(this.lazySkipPointer);
/* 157 */       this.lazySkipPointer = 0L;
/*     */     } 
/*     */     
/* 160 */     if (this.lazySkipProxCount != 0) {
/* 161 */       skipPositions(this.lazySkipProxCount);
/* 162 */       this.lazySkipProxCount = 0;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 167 */   public int getPayloadLength() { return this.payloadLength; }
/*     */   public byte[] getPayload(byte[] data, int offset) throws IOException {
/*     */     int retOffset;
/*     */     byte[] retArray;
/* 171 */     if (!this.needToLoadPayload) {
/* 172 */       throw new IOException(""Payload cannot be loaded more than once for the same term position."");
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 178 */     if (data == null || data.length - offset < this.payloadLength) {
/*     */ 
/*     */       
/* 181 */       retArray = new byte[this.payloadLength];
/* 182 */       retOffset = 0;
/*     */     } else {
/* 184 */       retArray = data;
/* 185 */       retOffset = offset;
/*     */     } 
/* 187 */     this.proxStream.readBytes(retArray, retOffset, this.payloadLength);
/* 188 */     this.needToLoadPayload = false;
/* 189 */     return retArray;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 194 */   public boolean isPayloadAvailable() { return (this.needToLoadPayload && this.payloadLength > 0); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentTermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermPositionVector,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class SegmentTermPositionVector
/*    */   extends SegmentTermVector
/*    */   implements TermPositionVector
/*    */ {
/*    */   protected int[][] positions;
/*    */   protected TermVectorOffsetInfo[][] offsets;
/* 23 */   public static final int[] EMPTY_TERM_POS = new int[0];
/*    */   
/*    */   public SegmentTermPositionVector(String field, String[] terms, int[] termFreqs, int[][] positions, TermVectorOffsetInfo[][] offsets) {
/* 26 */     super(field, terms, termFreqs);
/* 27 */     this.offsets = offsets;
/* 28 */     this.positions = positions;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public TermVectorOffsetInfo[] getOffsets(int index) {
/* 39 */     TermVectorOffsetInfo[] result = TermVectorOffsetInfo.EMPTY_OFFSET_INFO;
/* 40 */     if (this.offsets == null)
/* 41 */       return null; 
/* 42 */     if (index >= 0 && index < this.offsets.length)
/*    */     {
/* 44 */       result = this.offsets[index];
/*    */     }
/* 46 */     return result;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int[] getTermPositions(int index) {
/* 55 */     int[] result = EMPTY_TERM_POS;
/* 56 */     if (this.positions == null)
/* 57 */       return null; 
/* 58 */     if (index >= 0 && index < this.positions.length)
/*    */     {
/* 60 */       result = this.positions[index];
/*    */     }
/*    */     
/* 63 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentTermPositionVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.SegmentTermVector,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.util.Arrays;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class SegmentTermVector
/*    */   implements TermFreqVector
/*    */ {
/*    */   private String field;
/*    */   private String[] terms;
/*    */   private int[] termFreqs;
/*    */   
/*    */   SegmentTermVector(String field, String[] terms, int[] termFreqs) {
/* 30 */     this.field = field;
/* 31 */     this.terms = terms;
/* 32 */     this.termFreqs = termFreqs;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 40 */   public String getField() { return this.field; }
/*    */ 
/*    */   
/*    */   public String toString() {
/* 44 */     StringBuffer sb = new StringBuffer();
/* 45 */     sb.append('{');
/* 46 */     sb.append(this.field).append("": "");
/* 47 */     if (this.terms != null) {
/* 48 */       for (int i = 0; i < this.terms.length; i++) {
/* 49 */         if (i > 0) sb.append("", ""); 
/* 50 */         sb.append(this.terms[i]).append('/').append(this.termFreqs[i]);
/*    */       } 
/*    */     }
/* 53 */     sb.append('}');
/*    */     
/* 55 */     return sb.toString();
/*    */   }
/*    */ 
/*    */   
/* 59 */   public int size() { return (this.terms == null) ? 0 : this.terms.length; }
/*    */ 
/*    */ 
/*    */   
/* 63 */   public String[] getTerms() { return this.terms; }
/*    */ 
/*    */ 
/*    */   
/* 67 */   public int[] getTermFrequencies() { return this.termFreqs; }
/*    */ 
/*    */   
/*    */   public int indexOf(String termText) {
/* 71 */     if (this.terms == null)
/* 72 */       return -1; 
/* 73 */     int res = Arrays.binarySearch((Object[])this.terms, termText);
/* 74 */     return (res >= 0) ? res : -1;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int[] indexesOf(String[] termNumbers, int start, int len) {
/* 83 */     int[] res = new int[len];
/*    */     
/* 85 */     for (int i = 0; i < len; i++) {
/* 86 */       res[i] = indexOf(termNumbers[start + i]);
/*    */     }
/* 88 */     return res;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\SegmentTermVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.StaleReaderException,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class StaleReaderException
/*    */   extends IOException
/*    */ {
/* 34 */   public StaleReaderException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\StaleReaderException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.Term,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.ObjectInputStream;
/*     */ import java.io.Serializable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Term
/*     */   implements Comparable, Serializable
/*     */ {
/*     */   String field;
/*     */   String text;
/*     */   
/*  36 */   public Term(String fld, String txt) { this(fld, txt, true); }
/*     */   
/*     */   Term(String fld, String txt, boolean intern) {
/*  39 */     this.field = intern ? fld.intern() : fld;
/*  40 */     this.text = txt;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  45 */   public final String field() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public final String text() { return this.text; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public Term createTerm(String text) { return new Term(this.field, text, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean equals(Object o) {
/*  66 */     if (o == this)
/*  67 */       return true; 
/*  68 */     if (o == null)
/*  69 */       return false; 
/*  70 */     if (!(o instanceof Term))
/*  71 */       return false; 
/*  72 */     Term other = (Term)o;
/*  73 */     return (this.field == other.field && this.text.equals(other.text));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  78 */   public final int hashCode() { return this.field.hashCode() + this.text.hashCode(); }
/*     */ 
/*     */ 
/*     */   
/*  82 */   public int compareTo(Object other) { return compareTo((Term)other); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int compareTo(Term other) {
/*  91 */     if (this.field == other.field) {
/*  92 */       return this.text.compareTo(other.text);
/*     */     }
/*  94 */     return this.field.compareTo(other.field);
/*     */   }
/*     */ 
/*     */   
/*     */   final void set(String fld, String txt) {
/*  99 */     this.field = fld;
/* 100 */     this.text = txt;
/*     */   }
/*     */   
/* 103 */   public final String toString() { return this.field + "":"" + this.text; }
/*     */ 
/*     */ 
/*     */   
/*     */   private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
/* 108 */     in.defaultReadObject();
/* 109 */     this.field = this.field.intern();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\Term.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermBuffer,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermBuffer
/*     */   implements Cloneable
/*     */ {
/*  24 */   private static final char[] NO_CHARS = new char[0];
/*     */   
/*     */   private String field;
/*  27 */   private char[] text = NO_CHARS;
/*     */   private int textLength;
/*     */   private Term term;
/*     */   
/*     */   public final int compareTo(TermBuffer other) {
/*  32 */     if (this.field == other.field) {
/*  33 */       return compareChars(this.text, this.textLength, other.text, other.textLength);
/*     */     }
/*  35 */     return this.field.compareTo(other.field);
/*     */   }
/*     */ 
/*     */   
/*     */   private static final int compareChars(char[] v1, int len1, char[] v2, int len2) {
/*  40 */     int end = Math.min(len1, len2);
/*  41 */     for (int k = 0; k < end; k++) {
/*  42 */       char c1 = v1[k];
/*  43 */       char c2 = v2[k];
/*  44 */       if (c1 != c2) {
/*  45 */         return c1 - c2;
/*     */       }
/*     */     } 
/*  48 */     return len1 - len2;
/*     */   }
/*     */   
/*     */   private final void setTextLength(int newLength) {
/*  52 */     if (this.text.length < newLength) {
/*  53 */       char[] newText = new char[newLength];
/*  54 */       System.arraycopy(this.text, 0, newText, 0, this.textLength);
/*  55 */       this.text = newText;
/*     */     } 
/*  57 */     this.textLength = newLength;
/*     */   }
/*     */ 
/*     */   
/*     */   public final void read(IndexInput input, FieldInfos fieldInfos) throws IOException {
/*  62 */     this.term = null;
/*  63 */     int start = input.readVInt();
/*  64 */     int length = input.readVInt();
/*  65 */     int totalLength = start + length;
/*  66 */     setTextLength(totalLength);
/*  67 */     input.readChars(this.text, start, length);
/*  68 */     this.field = fieldInfos.fieldName(input.readVInt());
/*     */   }
/*     */   
/*     */   public final void set(Term term) {
/*  72 */     if (term == null) {
/*  73 */       reset();
/*     */       
/*     */       return;
/*     */     } 
/*     */     
/*  78 */     setTextLength(term.text().length());
/*  79 */     term.text().getChars(0, term.text().length(), this.text, 0);
/*     */     
/*  81 */     this.field = term.field();
/*  82 */     this.term = term;
/*     */   }
/*     */   
/*     */   public final void set(TermBuffer other) {
/*  86 */     setTextLength(other.textLength);
/*  87 */     System.arraycopy(other.text, 0, this.text, 0, this.textLength);
/*     */     
/*  89 */     this.field = other.field;
/*  90 */     this.term = other.term;
/*     */   }
/*     */   
/*     */   public void reset() {
/*  94 */     this.field = null;
/*  95 */     this.textLength = 0;
/*  96 */     this.term = null;
/*     */   }
/*     */   
/*     */   public Term toTerm() {
/* 100 */     if (this.field == null) {
/* 101 */       return null;
/*     */     }
/* 103 */     if (this.term == null) {
/* 104 */       this.term = new Term(this.field, new String(this.text, 0, this.textLength), false);
/*     */     }
/* 106 */     return this.term;
/*     */   }
/*     */   
/*     */   protected Object clone() {
/* 110 */     TermBuffer clone = null;
/*     */     try {
/* 112 */       clone = (TermBuffer)super.clone();
/* 113 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 115 */     clone.text = new char[this.text.length];
/* 116 */     System.arraycopy(this.text, 0, clone.text, 0, this.textLength);
/*     */     
/* 118 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermBuffer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermDocs,"package org.apache.lucene.index;
import java.io.IOException;
public interface TermDocs {
  void seek(Term paramTerm) throws IOException;
  void seek(TermEnum paramTermEnum) throws IOException;
  int doc();
  int freq();
  boolean next() throws IOException;
  int read(int[] paramArrayOfint1, int[] paramArrayOfint2) throws IOException;
  boolean skipTo(int paramInt) throws IOException;
  void close() throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermEnum,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class TermEnum
/*    */ {
/*    */   public abstract boolean next() throws IOException;
/*    */   
/*    */   public abstract Term term();
/*    */   
/*    */   public abstract int docFreq();
/*    */   
/*    */   public abstract void close() throws IOException;
/*    */   
/*    */   public boolean skipTo(Term target) throws IOException {
/*    */     do {
/* 57 */       if (!next())
/* 58 */         return false; 
/* 59 */     } while (target.compareTo(term()) > 0);
/* 60 */     return true;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermFreqVector,"package org.apache.lucene.index;
public interface TermFreqVector {
  String getField();
  int size();
  String[] getTerms();
  int[] getTermFrequencies();
  int indexOf(String paramString);
  int[] indexesOf(String[] paramArrayOfString, int paramInt1, int paramInt2);
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermFreqVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class TermInfo
/*    */ {
/* 24 */   int docFreq = 0;
/*    */   
/* 26 */   long freqPointer = 0L;
/* 27 */   long proxPointer = 0L;
/*    */   int skipOffset;
/*    */   
/*    */   TermInfo() {}
/*    */   
/*    */   TermInfo(int df, long fp, long pp) {
/* 33 */     this.docFreq = df;
/* 34 */     this.freqPointer = fp;
/* 35 */     this.proxPointer = pp;
/*    */   }
/*    */   
/*    */   TermInfo(TermInfo ti) {
/* 39 */     this.docFreq = ti.docFreq;
/* 40 */     this.freqPointer = ti.freqPointer;
/* 41 */     this.proxPointer = ti.proxPointer;
/* 42 */     this.skipOffset = ti.skipOffset;
/*    */   }
/*    */ 
/*    */   
/*    */   final void set(int docFreq, long freqPointer, long proxPointer, int skipOffset) {
/* 47 */     this.docFreq = docFreq;
/* 48 */     this.freqPointer = freqPointer;
/* 49 */     this.proxPointer = proxPointer;
/* 50 */     this.skipOffset = skipOffset;
/*    */   }
/*    */   
/*    */   final void set(TermInfo ti) {
/* 54 */     this.docFreq = ti.docFreq;
/* 55 */     this.freqPointer = ti.freqPointer;
/* 56 */     this.proxPointer = ti.proxPointer;
/* 57 */     this.skipOffset = ti.skipOffset;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfosReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermInfosReader
/*     */ {
/*     */   private Directory directory;
/*     */   private String segment;
/*     */   private FieldInfos fieldInfos;
/*  34 */   private ThreadLocal enumerators = new ThreadLocal();
/*     */   
/*     */   private SegmentTermEnum origEnum;
/*     */   private long size;
/*  38 */   private Term[] indexTerms = null;
/*     */   
/*     */   private TermInfo[] indexInfos;
/*     */   
/*     */   private long[] indexPointers;
/*     */   
/*     */   private SegmentTermEnum indexEnum;
/*     */   
/*  46 */   TermInfosReader(Directory dir, String seg, FieldInfos fis) throws CorruptIndexException, IOException { this(dir, seg, fis, 1024); }
/*     */ 
/*     */ 
/*     */   
/*     */   TermInfosReader(Directory dir, String seg, FieldInfos fis, int readBufferSize) throws CorruptIndexException, IOException {
/*  51 */     this.directory = dir;
/*  52 */     this.segment = seg;
/*  53 */     this.fieldInfos = fis;
/*     */     
/*  55 */     this.origEnum = new SegmentTermEnum(this.directory.openInput(this.segment + "".tis"", readBufferSize), this.fieldInfos, false);
/*     */     
/*  57 */     this.size = this.origEnum.size;
/*     */     
/*  59 */     this.indexEnum = new SegmentTermEnum(this.directory.openInput(this.segment + "".tii"", readBufferSize), this.fieldInfos, true);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  65 */   public int getSkipInterval() { return this.origEnum.skipInterval; }
/*     */ 
/*     */ 
/*     */   
/*  69 */   public int getMaxSkipLevels() { return this.origEnum.maxSkipLevels; }
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/*  73 */     if (this.origEnum != null)
/*  74 */       this.origEnum.close(); 
/*  75 */     if (this.indexEnum != null)
/*  76 */       this.indexEnum.close(); 
/*  77 */     this.enumerators.set(null);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  82 */   final long size() { return this.size; }
/*     */ 
/*     */   
/*     */   private SegmentTermEnum getEnum() {
/*  86 */     SegmentTermEnum termEnum = this.enumerators.get();
/*  87 */     if (termEnum == null) {
/*  88 */       termEnum = terms();
/*  89 */       this.enumerators.set(termEnum);
/*     */     } 
/*  91 */     return termEnum;
/*     */   }
/*     */   
/*     */   private synchronized void ensureIndexIsRead() throws IOException {
/*  95 */     if (this.indexTerms != null)
/*     */       return; 
/*     */     try {
/*  98 */       int indexSize = (int)this.indexEnum.size;
/*     */       
/* 100 */       this.indexTerms = new Term[indexSize];
/* 101 */       this.indexInfos = new TermInfo[indexSize];
/* 102 */       this.indexPointers = new long[indexSize];
/*     */       
/* 104 */       for (int i = 0; this.indexEnum.next(); i++) {
/* 105 */         this.indexTerms[i] = this.indexEnum.term();
/* 106 */         this.indexInfos[i] = this.indexEnum.termInfo();
/* 107 */         this.indexPointers[i] = this.indexEnum.indexPointer;
/*     */       } 
/*     */     } finally {
/* 110 */       this.indexEnum.close();
/* 111 */       this.indexEnum = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private final int getIndexOffset(Term term) {
/* 117 */     int lo = 0;
/* 118 */     int hi = this.indexTerms.length - 1;
/*     */     
/* 120 */     while (hi >= lo) {
/* 121 */       int mid = lo + hi >> 1;
/* 122 */       int delta = term.compareTo(this.indexTerms[mid]);
/* 123 */       if (delta < 0) {
/* 124 */         hi = mid - 1; continue;
/* 125 */       }  if (delta > 0) {
/* 126 */         lo = mid + 1; continue;
/*     */       } 
/* 128 */       return mid;
/*     */     } 
/* 130 */     return hi;
/*     */   }
/*     */ 
/*     */   
/* 134 */   private final void seekEnum(int indexOffset) throws IOException { getEnum().seek(this.indexPointers[indexOffset], indexOffset * (getEnum()).indexInterval - 1, this.indexTerms[indexOffset], this.indexInfos[indexOffset]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermInfo get(Term term) throws IOException {
/* 141 */     if (this.size == 0L) return null;
/*     */     
/* 143 */     ensureIndexIsRead();
/*     */ 
/*     */     
/* 146 */     SegmentTermEnum enumerator = getEnum();
/* 147 */     if (enumerator.term() != null && ((enumerator.prev() != null && term.compareTo(enumerator.prev()) > 0) || term.compareTo(enumerator.term()) >= 0)) {
/*     */ 
/*     */       
/* 150 */       int enumOffset = (int)(enumerator.position / enumerator.indexInterval) + 1;
/* 151 */       if (this.indexTerms.length == enumOffset || term.compareTo(this.indexTerms[enumOffset]) < 0)
/*     */       {
/* 153 */         return scanEnum(term);
/*     */       }
/*     */     } 
/*     */     
/* 157 */     seekEnum(getIndexOffset(term));
/* 158 */     return scanEnum(term);
/*     */   }
/*     */ 
/*     */   
/*     */   private final TermInfo scanEnum(Term term) throws IOException {
/* 163 */     SegmentTermEnum enumerator = getEnum();
/* 164 */     enumerator.scanTo(term);
/* 165 */     if (enumerator.term() != null && term.compareTo(enumerator.term()) == 0) {
/* 166 */       return enumerator.termInfo();
/*     */     }
/* 168 */     return null;
/*     */   }
/*     */ 
/*     */   
/*     */   final Term get(int position) throws IOException {
/* 173 */     if (this.size == 0L) return null;
/*     */     
/* 175 */     SegmentTermEnum enumerator = getEnum();
/* 176 */     if (enumerator != null && enumerator.term() != null && position >= enumerator.position && position < enumerator.position + enumerator.indexInterval)
/*     */     {
/*     */       
/* 179 */       return scanEnum(position);
/*     */     }
/* 181 */     seekEnum(position / enumerator.indexInterval);
/* 182 */     return scanEnum(position);
/*     */   }
/*     */   
/*     */   private final Term scanEnum(int position) throws IOException {
/* 186 */     SegmentTermEnum enumerator = getEnum();
/* 187 */     while (enumerator.position < position) {
/* 188 */       if (!enumerator.next())
/* 189 */         return null; 
/*     */     } 
/* 191 */     return enumerator.term();
/*     */   }
/*     */ 
/*     */   
/*     */   final long getPosition(Term term) throws IOException {
/* 196 */     if (this.size == 0L) return -1L;
/*     */     
/* 198 */     ensureIndexIsRead();
/* 199 */     int indexOffset = getIndexOffset(term);
/* 200 */     seekEnum(indexOffset);
/*     */     
/* 202 */     SegmentTermEnum enumerator = getEnum();
/* 203 */     while (term.compareTo(enumerator.term()) > 0 && enumerator.next());
/*     */     
/* 205 */     if (term.compareTo(enumerator.term()) == 0) {
/* 206 */       return enumerator.position;
/*     */     }
/* 208 */     return -1L;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 213 */   public SegmentTermEnum terms() { return (SegmentTermEnum)this.origEnum.clone(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public SegmentTermEnum terms(Term term) throws IOException {
/* 218 */     get(term);
/* 219 */     return (SegmentTermEnum)getEnum().clone();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermInfosReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermInfosWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.StringHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermInfosWriter
/*     */ {
/*     */   public static final int FORMAT = -3;
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexOutput output;
/*  35 */   private Term lastTerm = new Term("""", """");
/*  36 */   private TermInfo lastTi = new TermInfo();
/*  37 */   private long size = 0L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  51 */   int indexInterval = 128;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  58 */   int skipInterval = 16;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  63 */   int maxSkipLevels = 10;
/*     */   
/*  65 */   private long lastIndexPointer = 0L;
/*     */   
/*     */   private boolean isIndex = false;
/*  68 */   private TermInfosWriter other = null;
/*     */ 
/*     */ 
/*     */   
/*     */   TermInfosWriter(Directory directory, String segment, FieldInfos fis, int interval) throws IOException {
/*  73 */     initialize(directory, segment, fis, interval, false);
/*  74 */     this.other = new TermInfosWriter(directory, segment, fis, interval, true);
/*  75 */     this.other.other = this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  80 */   private TermInfosWriter(Directory directory, String segment, FieldInfos fis, int interval, boolean isIndex) throws IOException { initialize(directory, segment, fis, interval, isIndex); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void initialize(Directory directory, String segment, FieldInfos fis, int interval, boolean isi) throws IOException {
/*  85 */     this.indexInterval = interval;
/*  86 */     this.fieldInfos = fis;
/*  87 */     this.isIndex = isi;
/*  88 */     this.output = directory.createOutput(segment + (this.isIndex ? "".tii"" : "".tis""));
/*  89 */     this.output.writeInt(-3);
/*  90 */     this.output.writeLong(0L);
/*  91 */     this.output.writeInt(this.indexInterval);
/*  92 */     this.output.writeInt(this.skipInterval);
/*  93 */     this.output.writeInt(this.maxSkipLevels);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void add(Term term, TermInfo ti) throws CorruptIndexException, IOException {
/* 101 */     if (!this.isIndex && term.compareTo(this.lastTerm) <= 0) {
/* 102 */       throw new CorruptIndexException(""term out of order (\"""" + term + ""\"".compareTo(\"""" + this.lastTerm + ""\"") <= 0)"");
/*     */     }
/* 104 */     if (ti.freqPointer < this.lastTi.freqPointer) {
/* 105 */       throw new CorruptIndexException(""freqPointer out of order ("" + ti.freqPointer + "" < "" + this.lastTi.freqPointer + "")"");
/*     */     }
/* 107 */     if (ti.proxPointer < this.lastTi.proxPointer) {
/* 108 */       throw new CorruptIndexException(""proxPointer out of order ("" + ti.proxPointer + "" < "" + this.lastTi.proxPointer + "")"");
/*     */     }
/*     */     
/* 111 */     if (!this.isIndex && this.size % this.indexInterval == 0L) {
/* 112 */       this.other.add(this.lastTerm, this.lastTi);
/*     */     }
/* 114 */     writeTerm(term);
/* 115 */     this.output.writeVInt(ti.docFreq);
/* 116 */     this.output.writeVLong(ti.freqPointer - this.lastTi.freqPointer);
/* 117 */     this.output.writeVLong(ti.proxPointer - this.lastTi.proxPointer);
/*     */     
/* 119 */     if (ti.docFreq >= this.skipInterval) {
/* 120 */       this.output.writeVInt(ti.skipOffset);
/*     */     }
/*     */     
/* 123 */     if (this.isIndex) {
/* 124 */       this.output.writeVLong(this.other.output.getFilePointer() - this.lastIndexPointer);
/* 125 */       this.lastIndexPointer = this.other.output.getFilePointer();
/*     */     } 
/*     */     
/* 128 */     this.lastTi.set(ti);
/* 129 */     this.size++;
/*     */   }
/*     */ 
/*     */   
/*     */   private final void writeTerm(Term term) throws IOException {
/* 134 */     int start = StringHelper.stringDifference(this.lastTerm.text, term.text);
/* 135 */     int length = term.text.length() - start;
/*     */     
/* 137 */     this.output.writeVInt(start);
/* 138 */     this.output.writeVInt(length);
/* 139 */     this.output.writeChars(term.text, start, length);
/*     */     
/* 141 */     this.output.writeVInt(this.fieldInfos.fieldNumber(term.field));
/*     */     
/* 143 */     this.lastTerm = term;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/* 150 */     this.output.seek(4L);
/* 151 */     this.output.writeLong(this.size);
/* 152 */     this.output.close();
/*     */     
/* 154 */     if (!this.isIndex)
/* 155 */       this.other.close(); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermInfosWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermPositions,"package org.apache.lucene.index;
import java.io.IOException;
public interface TermPositions extends TermDocs {
  int nextPosition() throws IOException;
  int getPayloadLength();
  byte[] getPayload(byte[] paramArrayOfbyte, int paramInt) throws IOException;
  boolean isPayloadAvailable();
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermPositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermPositionVector,"package org.apache.lucene.index;
public interface TermPositionVector extends TermFreqVector {
  int[] getTermPositions(int paramInt);
  TermVectorOffsetInfo[] getOffsets(int paramInt);
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermPositionVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorOffsetInfo,"/*    */ package org.apache.lucene.index;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TermVectorOffsetInfo
/*    */ {
/* 29 */   public static final TermVectorOffsetInfo[] EMPTY_OFFSET_INFO = new TermVectorOffsetInfo[0];
/*    */   
/*    */   private int startOffset;
/*    */   private int endOffset;
/*    */   
/*    */   public TermVectorOffsetInfo() {}
/*    */   
/*    */   public TermVectorOffsetInfo(int startOffset, int endOffset) {
/* 37 */     this.endOffset = endOffset;
/* 38 */     this.startOffset = startOffset;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 46 */   public int getEndOffset() { return this.endOffset; }
/*    */ 
/*    */ 
/*    */   
/* 50 */   public void setEndOffset(int endOffset) { this.endOffset = endOffset; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public int getStartOffset() { return this.startOffset; }
/*    */ 
/*    */ 
/*    */   
/* 63 */   public void setStartOffset(int startOffset) { this.startOffset = startOffset; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 72 */     if (this == o) return true; 
/* 73 */     if (!(o instanceof TermVectorOffsetInfo)) return false;
/*    */     
/* 75 */     TermVectorOffsetInfo termVectorOffsetInfo = (TermVectorOffsetInfo)o;
/*    */     
/* 77 */     if (this.endOffset != termVectorOffsetInfo.endOffset) return false; 
/* 78 */     if (this.startOffset != termVectorOffsetInfo.startOffset) return false;
/*    */     
/* 80 */     return true;
/*    */   }
/*    */ 
/*    */   
/*    */   public int hashCode() {
/* 85 */     int result = this.startOffset;
/* 86 */     result = 29 * result + this.endOffset;
/* 87 */     return result;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermVectorOffsetInfo.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsReader,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class TermVectorsReader
/*     */   implements Cloneable
/*     */ {
/*     */   private FieldInfos fieldInfos;
/*     */   private IndexInput tvx;
/*     */   private IndexInput tvd;
/*     */   private IndexInput tvf;
/*     */   private int size;
/*     */   private int tvdFormat;
/*     */   private int tvfFormat;
/*     */   
/*  42 */   TermVectorsReader(Directory d, String segment, FieldInfos fieldInfos) throws CorruptIndexException, IOException { this(d, segment, fieldInfos, 1024); }
/*     */ 
/*     */ 
/*     */   
/*     */   TermVectorsReader(Directory d, String segment, FieldInfos fieldInfos, int readBufferSize) throws CorruptIndexException, IOException {
/*  47 */     if (d.fileExists(segment + "".tvx"")) {
/*  48 */       this.tvx = d.openInput(segment + "".tvx"", readBufferSize);
/*  49 */       checkValidFormat(this.tvx);
/*  50 */       this.tvd = d.openInput(segment + "".tvd"", readBufferSize);
/*  51 */       this.tvdFormat = checkValidFormat(this.tvd);
/*  52 */       this.tvf = d.openInput(segment + "".tvf"", readBufferSize);
/*  53 */       this.tvfFormat = checkValidFormat(this.tvf);
/*  54 */       this.size = (int)this.tvx.length() / 8;
/*     */     } 
/*     */     
/*  57 */     this.fieldInfos = fieldInfos;
/*     */   }
/*     */ 
/*     */   
/*     */   private int checkValidFormat(IndexInput in) throws CorruptIndexException, IOException {
/*  62 */     int format = in.readInt();
/*  63 */     if (format > 2)
/*     */     {
/*  65 */       throw new CorruptIndexException(""Incompatible format version: "" + format + "" expected "" + '\002' + "" or less"");
/*     */     }
/*     */     
/*  68 */     return format;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   void close() throws IOException {
/*  74 */     IOException keep = null;
/*  75 */     if (this.tvx != null) try { this.tvx.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/*  76 */         if (this.tvd != null) try { this.tvd.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/*  77 */         if (this.tvf != null) try { this.tvf.close(); } catch (IOException e) { if (keep == null) keep = e;  }
/*  78 */         if (keep != null) throw (IOException)keep.fillInStackTrace();
/*     */   
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   int size() { return this.size; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermFreqVector get(int docNum, String field) throws IOException {
/*  98 */     int fieldNumber = this.fieldInfos.fieldNumber(field);
/*  99 */     TermFreqVector result = null;
/* 100 */     if (this.tvx != null) {
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 105 */       this.tvx.seek(docNum * 8L + 4L);
/*     */       
/* 107 */       long position = this.tvx.readLong();
/*     */       
/* 109 */       this.tvd.seek(position);
/* 110 */       int fieldCount = this.tvd.readVInt();
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 115 */       int number = 0;
/* 116 */       int found = -1;
/* 117 */       for (int i = 0; i < fieldCount; i++) {
/* 118 */         if (this.tvdFormat == 2) {
/* 119 */           number = this.tvd.readVInt();
/*     */         } else {
/* 121 */           number += this.tvd.readVInt();
/*     */         } 
/* 123 */         if (number == fieldNumber) {
/* 124 */           found = i;
/*     */         }
/*     */       } 
/*     */ 
/*     */       
/* 129 */       if (found != -1) {
/*     */         
/* 131 */         position = 0L;
/* 132 */         for (int i = 0; i <= found; i++) {
/* 133 */           position += this.tvd.readVLong();
/*     */         }
/* 135 */         result = readTermVector(field, position);
/*     */       } 
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 142 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermFreqVector[] get(int docNum) throws IOException {
/* 153 */     Object[] arrayOfObject = null;
/*     */     
/* 155 */     if (this.tvx != null) {
/*     */       
/* 157 */       this.tvx.seek(docNum * 8L + 4L);
/* 158 */       long position = this.tvx.readLong();
/*     */       
/* 160 */       this.tvd.seek(position);
/* 161 */       int fieldCount = this.tvd.readVInt();
/*     */ 
/*     */       
/* 164 */       if (fieldCount != 0) {
/* 165 */         int number = 0;
/* 166 */         String[] fields = new String[fieldCount];
/*     */         
/* 168 */         for (int i = 0; i < fieldCount; i++) {
/* 169 */           if (this.tvdFormat == 2) {
/* 170 */             number = this.tvd.readVInt();
/*     */           } else {
/* 172 */             number += this.tvd.readVInt();
/*     */           } 
/* 174 */           fields[i] = this.fieldInfos.fieldName(number);
/*     */         } 
/*     */ 
/*     */         
/* 178 */         position = 0L;
/* 179 */         long[] tvfPointers = new long[fieldCount];
/* 180 */         for (int i = 0; i < fieldCount; i++) {
/* 181 */           position += this.tvd.readVLong();
/* 182 */           tvfPointers[i] = position;
/*     */         } 
/*     */         
/* 185 */         arrayOfObject = (Object[])readTermVectors(fields, tvfPointers);
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 190 */     return (TermFreqVector[])arrayOfObject;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private SegmentTermVector[] readTermVectors(String[] fields, long[] tvfPointers) throws IOException {
/* 196 */     SegmentTermVector[] res = new SegmentTermVector[fields.length];
/* 197 */     for (int i = 0; i < fields.length; i++) {
/* 198 */       res[i] = readTermVector(fields[i], tvfPointers[i]);
/*     */     }
/* 200 */     return res;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private SegmentTermVector readTermVector(String field, long tvfPointer) throws IOException {
/*     */     SegmentTermVector tv;
/*     */     boolean storeOffsets, storePositions;
/* 215 */     this.tvf.seek(tvfPointer);
/*     */     
/* 217 */     int numTerms = this.tvf.readVInt();
/*     */ 
/*     */     
/* 220 */     if (numTerms == 0) {
/* 221 */       return new SegmentTermVector(field, null, null);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 226 */     if (this.tvfFormat == 2) {
/* 227 */       byte bits = this.tvf.readByte();
/* 228 */       storePositions = ((bits & 0x1) != 0);
/* 229 */       storeOffsets = ((bits & 0x2) != 0);
/*     */     } else {
/*     */       
/* 232 */       this.tvf.readVInt();
/* 233 */       storePositions = false;
/* 234 */       storeOffsets = false;
/*     */     } 
/*     */     
/* 237 */     String[] terms = new String[numTerms];
/* 238 */     int[] termFreqs = new int[numTerms];
/*     */ 
/*     */     
/* 241 */     int[][] positions = (int[][])null;
/* 242 */     TermVectorOffsetInfo[][] offsets = (TermVectorOffsetInfo[][])null;
/* 243 */     if (storePositions)
/* 244 */       positions = new int[numTerms][]; 
/* 245 */     if (storeOffsets) {
/* 246 */       offsets = new TermVectorOffsetInfo[numTerms][];
/*     */     }
/* 248 */     int start = 0;
/* 249 */     int deltaLength = 0;
/* 250 */     int totalLength = 0;
/* 251 */     char[] buffer = new char[10];
/* 252 */     char[] previousBuffer = new char[0];
/*     */     
/* 254 */     for (int i = 0; i < numTerms; i++) {
/* 255 */       start = this.tvf.readVInt();
/* 256 */       deltaLength = this.tvf.readVInt();
/* 257 */       totalLength = start + deltaLength;
/* 258 */       if (buffer.length < totalLength) {
/* 259 */         buffer = null;
/* 260 */         buffer = new char[totalLength];
/*     */         
/* 262 */         if (start > 0) {
/* 263 */           System.arraycopy(previousBuffer, 0, buffer, 0, start);
/*     */         }
/*     */       } 
/* 266 */       this.tvf.readChars(buffer, start, deltaLength);
/* 267 */       terms[i] = new String(buffer, 0, totalLength);
/* 268 */       previousBuffer = buffer;
/* 269 */       int freq = this.tvf.readVInt();
/* 270 */       termFreqs[i] = freq;
/*     */       
/* 272 */       if (storePositions) {
/* 273 */         int[] pos = new int[freq];
/* 274 */         positions[i] = pos;
/* 275 */         int prevPosition = 0;
/* 276 */         for (int j = 0; j < freq; j++) {
/*     */           
/* 278 */           pos[j] = prevPosition + this.tvf.readVInt();
/* 279 */           prevPosition = pos[j];
/*     */         } 
/*     */       } 
/*     */       
/* 283 */       if (storeOffsets) {
/* 284 */         TermVectorOffsetInfo[] offs = new TermVectorOffsetInfo[freq];
/* 285 */         offsets[i] = offs;
/* 286 */         int prevOffset = 0;
/* 287 */         for (int j = 0; j < freq; j++) {
/* 288 */           int startOffset = prevOffset + this.tvf.readVInt();
/* 289 */           int endOffset = startOffset + this.tvf.readVInt();
/* 290 */           offs[j] = new TermVectorOffsetInfo(startOffset, endOffset);
/* 291 */           prevOffset = endOffset;
/*     */         } 
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 297 */     if (storePositions || storeOffsets) {
/* 298 */       tv = new SegmentTermPositionVector(field, terms, termFreqs, positions, offsets);
/*     */     } else {
/*     */       
/* 301 */       tv = new SegmentTermVector(field, terms, termFreqs);
/*     */     } 
/* 303 */     return tv;
/*     */   }
/*     */ 
/*     */   
/*     */   protected Object clone() {
/* 308 */     if (this.tvx == null || this.tvd == null || this.tvf == null) {
/* 309 */       return null;
/*     */     }
/* 311 */     TermVectorsReader clone = null;
/*     */     try {
/* 313 */       clone = (TermVectorsReader)super.clone();
/* 314 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 316 */     clone.tvx = (IndexInput)this.tvx.clone();
/* 317 */     clone.tvd = (IndexInput)this.tvd.clone();
/* 318 */     clone.tvf = (IndexInput)this.tvf.clone();
/*     */     
/* 320 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermVectorsReader.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.index.TermVectorsWriter,"/*     */ package org.apache.lucene.index;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ import org.apache.lucene.util.StringHelper;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermVectorsWriter
/*     */ {
/*     */   static final byte STORE_POSITIONS_WITH_TERMVECTOR = 1;
/*     */   static final byte STORE_OFFSET_WITH_TERMVECTOR = 2;
/*     */   static final int FORMAT_VERSION = 2;
/*     */   static final int FORMAT_SIZE = 4;
/*     */   static final String TVX_EXTENSION = "".tvx"";
/*     */   static final String TVD_EXTENSION = "".tvd"";
/*     */   static final String TVF_EXTENSION = "".tvf"";
/*  65 */   private IndexOutput tvx = null; private IndexOutput tvd = null; private IndexOutput tvf = null;
/*  66 */   private Vector fields = null;
/*  67 */   private Vector terms = null;
/*     */   
/*     */   private FieldInfos fieldInfos;
/*  70 */   private TVField currentField = null;
/*  71 */   private long currentDocPointer = -1L;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TermVectorsWriter(Directory directory, String segment, FieldInfos fieldInfos) throws IOException {
/*  77 */     this.tvx = directory.createOutput(segment + "".tvx"");
/*  78 */     this.tvx.writeInt(2);
/*  79 */     this.tvd = directory.createOutput(segment + "".tvd"");
/*  80 */     this.tvd.writeInt(2);
/*  81 */     this.tvf = directory.createOutput(segment + "".tvf"");
/*  82 */     this.tvf.writeInt(2);
/*     */     
/*  84 */     this.fieldInfos = fieldInfos;
/*  85 */     this.fields = new Vector(fieldInfos.size());
/*  86 */     this.terms = new Vector();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void openDocument() throws IOException {
/*  92 */     closeDocument();
/*  93 */     this.currentDocPointer = this.tvd.getFilePointer();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void closeDocument() throws IOException {
/*  99 */     if (isDocumentOpen()) {
/* 100 */       closeField();
/* 101 */       writeDoc();
/* 102 */       this.fields.clear();
/* 103 */       this.currentDocPointer = -1L;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 109 */   public final boolean isDocumentOpen() { return (this.currentDocPointer != -1L); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void openField(String field) throws IOException {
/* 119 */     FieldInfo fieldInfo = this.fieldInfos.fieldInfo(field);
/* 120 */     openField(fieldInfo.number, fieldInfo.storePositionWithTermVector, fieldInfo.storeOffsetWithTermVector);
/*     */   }
/*     */ 
/*     */   
/*     */   private void openField(int fieldNumber, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) throws IOException {
/* 125 */     if (!isDocumentOpen())
/* 126 */       throw new IllegalStateException(""Cannot open field when no document is open.""); 
/* 127 */     closeField();
/* 128 */     this.currentField = new TVField(fieldNumber, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void closeField() throws IOException {
/* 136 */     if (isFieldOpen()) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 142 */       writeField();
/* 143 */       this.fields.add(this.currentField);
/* 144 */       this.terms.clear();
/* 145 */       this.currentField = null;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 151 */   public final boolean isFieldOpen() { return (this.currentField != null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 162 */   public final void addTerm(String termText, int freq) { addTerm(termText, freq, null, null); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void addTerm(String termText, int freq, int[] positions, TermVectorOffsetInfo[] offsets) {
/* 167 */     if (!isDocumentOpen())
/* 168 */       throw new IllegalStateException(""Cannot add terms when document is not open""); 
/* 169 */     if (!isFieldOpen()) {
/* 170 */       throw new IllegalStateException(""Cannot add terms when field is not open"");
/*     */     }
/* 172 */     addTermInternal(termText, freq, positions, offsets);
/*     */   }
/*     */   
/*     */   private final void addTermInternal(String termText, int freq, int[] positions, TermVectorOffsetInfo[] offsets) {
/* 176 */     TVTerm term = new TVTerm();
/* 177 */     term.termText = termText;
/* 178 */     term.freq = freq;
/* 179 */     term.positions = positions;
/* 180 */     term.offsets = offsets;
/* 181 */     this.terms.add(term);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void addAllDocVectors(TermFreqVector[] vectors) throws IOException {
/* 193 */     openDocument();
/*     */     
/* 195 */     if (vectors != null) {
/* 196 */       for (int i = 0; i < vectors.length; i++) {
/* 197 */         boolean storePositionWithTermVector = false;
/* 198 */         boolean storeOffsetWithTermVector = false;
/*     */ 
/*     */         
/*     */         try {
/* 202 */           TermPositionVector tpVector = (TermPositionVector)vectors[i];
/*     */           
/* 204 */           if (tpVector.size() > 0 && tpVector.getTermPositions(0) != null)
/* 205 */             storePositionWithTermVector = true; 
/* 206 */           if (tpVector.size() > 0 && tpVector.getOffsets(0) != null) {
/* 207 */             storeOffsetWithTermVector = true;
/*     */           }
/* 209 */           FieldInfo fieldInfo = this.fieldInfos.fieldInfo(tpVector.getField());
/* 210 */           openField(fieldInfo.number, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */           
/* 212 */           for (int j = 0; j < tpVector.size(); j++) {
/* 213 */             addTermInternal(tpVector.getTerms()[j], tpVector.getTermFrequencies()[j], tpVector.getTermPositions(j), tpVector.getOffsets(j));
/*     */           }
/*     */           
/* 216 */           closeField();
/*     */         }
/* 218 */         catch (ClassCastException ignore) {
/*     */           
/* 220 */           TermFreqVector tfVector = vectors[i];
/*     */           
/* 222 */           FieldInfo fieldInfo = this.fieldInfos.fieldInfo(tfVector.getField());
/* 223 */           openField(fieldInfo.number, storePositionWithTermVector, storeOffsetWithTermVector);
/*     */           
/* 225 */           for (int j = 0; j < tfVector.size(); j++) {
/* 226 */             addTermInternal(tfVector.getTerms()[j], tfVector.getTermFrequencies()[j], null, null);
/*     */           }
/* 228 */           closeField();
/*     */         } 
/*     */       } 
/*     */     }
/*     */ 
/*     */     
/* 234 */     closeDocument();
/*     */   }
/*     */ 
/*     */   
/*     */   final void close() throws IOException {
/*     */     try {
/* 240 */       closeDocument();
/*     */     }
/*     */     finally {
/*     */       
/* 244 */       IOException keep = null;
/* 245 */       if (this.tvx != null)
/*     */         try {
/* 247 */           this.tvx.close();
/* 248 */         } catch (IOException e) {
/* 249 */           if (keep == null) keep = e; 
/*     */         }  
/* 251 */       if (this.tvd != null)
/*     */         try {
/* 253 */           this.tvd.close();
/* 254 */         } catch (IOException e) {
/* 255 */           if (keep == null) keep = e; 
/*     */         }  
/* 257 */       if (this.tvf != null)
/*     */         try {
/* 259 */           this.tvf.close();
/* 260 */         } catch (IOException e) {
/* 261 */           if (keep == null) keep = e; 
/*     */         }  
/* 263 */       if (keep != null) throw (IOException)keep.fillInStackTrace();
/*     */     
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void writeField() throws IOException {
/* 271 */     this.currentField.tvfPointer = this.tvf.getFilePointer();
/*     */ 
/*     */     
/* 274 */     int size = this.terms.size();
/* 275 */     this.tvf.writeVInt(size);
/*     */     
/* 277 */     boolean storePositions = this.currentField.storePositions;
/* 278 */     boolean storeOffsets = this.currentField.storeOffsets;
/* 279 */     byte bits = 0;
/* 280 */     if (storePositions)
/* 281 */       bits = (byte)(bits | 0x1); 
/* 282 */     if (storeOffsets)
/* 283 */       bits = (byte)(bits | 0x2); 
/* 284 */     this.tvf.writeByte(bits);
/*     */     
/* 286 */     String lastTermText = """";
/* 287 */     for (int i = 0; i < size; i++) {
/* 288 */       TVTerm term = this.terms.elementAt(i);
/* 289 */       int start = StringHelper.stringDifference(lastTermText, term.termText);
/* 290 */       int length = term.termText.length() - start;
/* 291 */       this.tvf.writeVInt(start);
/* 292 */       this.tvf.writeVInt(length);
/* 293 */       this.tvf.writeChars(term.termText, start, length);
/* 294 */       this.tvf.writeVInt(term.freq);
/* 295 */       lastTermText = term.termText;
/*     */       
/* 297 */       if (storePositions) {
/* 298 */         if (term.positions == null) {
/* 299 */           throw new IllegalStateException(""Trying to write positions that are null!"");
/*     */         }
/*     */         
/* 302 */         int position = 0;
/* 303 */         for (int j = 0; j < term.freq; j++) {
/* 304 */           this.tvf.writeVInt(term.positions[j] - position);
/* 305 */           position = term.positions[j];
/*     */         } 
/*     */       } 
/*     */       
/* 309 */       if (storeOffsets) {
/* 310 */         if (term.offsets == null) {
/* 311 */           throw new IllegalStateException(""Trying to write offsets that are null!"");
/*     */         }
/*     */         
/* 314 */         int position = 0;
/* 315 */         for (int j = 0; j < term.freq; j++) {
/* 316 */           this.tvf.writeVInt(term.offsets[j].getStartOffset() - position);
/* 317 */           this.tvf.writeVInt(term.offsets[j].getEndOffset() - term.offsets[j].getStartOffset());
/* 318 */           position = term.offsets[j].getEndOffset();
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void writeDoc() throws IOException {
/* 325 */     if (isFieldOpen()) {
/* 326 */       throw new IllegalStateException(""Field is still open while writing document"");
/*     */     }
/*     */     
/* 329 */     this.tvx.writeLong(this.currentDocPointer);
/*     */ 
/*     */     
/* 332 */     int size = this.fields.size();
/*     */ 
/*     */     
/* 335 */     this.tvd.writeVInt(size);
/*     */ 
/*     */     
/* 338 */     for (int i = 0; i < size; i++) {
/* 339 */       TVField field = this.fields.elementAt(i);
/* 340 */       this.tvd.writeVInt(field.number);
/*     */     } 
/*     */ 
/*     */     
/* 344 */     long lastFieldPointer = 0L;
/* 345 */     for (int i = 0; i < size; i++) {
/* 346 */       TVField field = this.fields.elementAt(i);
/* 347 */       this.tvd.writeVLong(field.tvfPointer - lastFieldPointer);
/* 348 */       lastFieldPointer = field.tvfPointer;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private static class TVField
/*     */   {
/*     */     int number;
/* 356 */     long tvfPointer = 0L; boolean storePositions = false;
/*     */     boolean storeOffsets = false;
/*     */     
/*     */     TVField(int number, boolean storePos, boolean storeOff) {
/* 360 */       this.number = number;
/* 361 */       this.storePositions = storePos;
/* 362 */       this.storeOffsets = storeOff;
/*     */     }
/*     */   }
/*     */   
/*     */   private static class TVTerm {
/*     */     String termText;
/* 368 */     int freq = 0;
/* 369 */     int[] positions = null; private TVTerm() {}
/* 370 */     TermVectorOffsetInfo[] offsets = null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\index\TermVectorsWriter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.CharStream,"package org.apache.lucene.queryParser;
import java.io.IOException;
public interface CharStream {
  char readChar() throws IOException;
  int getColumn();
  int getLine();
  int getEndColumn();
  int getEndLine();
  int getBeginColumn();
  int getBeginLine();
  void backup(int paramInt);
  char BeginToken() throws IOException;
  String GetImage();
  char[] GetSuffix(int paramInt);
  void Done();
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\CharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.FastCharStream,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Reader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FastCharStream
/*     */   implements CharStream
/*     */ {
/*  28 */   char[] buffer = null;
/*     */   
/*  30 */   int bufferLength = 0;
/*  31 */   int bufferPosition = 0;
/*     */   
/*  33 */   int tokenStart = 0;
/*  34 */   int bufferStart = 0;
/*     */ 
/*     */   
/*     */   Reader input;
/*     */ 
/*     */   
/*  40 */   public FastCharStream(Reader r) { this.input = r; }
/*     */ 
/*     */   
/*     */   public final char readChar() throws IOException {
/*  44 */     if (this.bufferPosition >= this.bufferLength)
/*  45 */       refill(); 
/*  46 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */   
/*     */   private final void refill() throws IOException {
/*  50 */     int newPosition = this.bufferLength - this.tokenStart;
/*     */     
/*  52 */     if (this.tokenStart == 0) {
/*  53 */       if (this.buffer == null) {
/*  54 */         this.buffer = new char[2048];
/*  55 */       } else if (this.bufferLength == this.buffer.length) {
/*  56 */         char[] newBuffer = new char[this.buffer.length * 2];
/*  57 */         System.arraycopy(this.buffer, 0, newBuffer, 0, this.bufferLength);
/*  58 */         this.buffer = newBuffer;
/*     */       } 
/*     */     } else {
/*  61 */       System.arraycopy(this.buffer, this.tokenStart, this.buffer, 0, newPosition);
/*     */     } 
/*     */     
/*  64 */     this.bufferLength = newPosition;
/*  65 */     this.bufferPosition = newPosition;
/*  66 */     this.bufferStart += this.tokenStart;
/*  67 */     this.tokenStart = 0;
/*     */     
/*  69 */     int charsRead = this.input.read(this.buffer, newPosition, this.buffer.length - newPosition);
/*     */     
/*  71 */     if (charsRead == -1) {
/*  72 */       throw new IOException(""read past eof"");
/*     */     }
/*  74 */     this.bufferLength += charsRead;
/*     */   }
/*     */   
/*     */   public final char BeginToken() throws IOException {
/*  78 */     this.tokenStart = this.bufferPosition;
/*  79 */     return readChar();
/*     */   }
/*     */ 
/*     */   
/*  83 */   public final void backup(int amount) { this.bufferPosition -= amount; }
/*     */ 
/*     */ 
/*     */   
/*  87 */   public final String GetImage() { return new String(this.buffer, this.tokenStart, this.bufferPosition - this.tokenStart); }
/*     */ 
/*     */   
/*     */   public final char[] GetSuffix(int len) {
/*  91 */     char[] value = new char[len];
/*  92 */     System.arraycopy(this.buffer, this.bufferPosition - len, value, 0, len);
/*  93 */     return value;
/*     */   }
/*     */   
/*     */   public final void Done() {
/*     */     try {
/*  98 */       this.input.close();
/*  99 */     } catch (IOException e) {
/* 100 */       System.err.println(""Caught: "" + e + ""; ignoring."");
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 105 */   public final int getColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 108 */   public final int getLine() { return 1; }
/*     */ 
/*     */   
/* 111 */   public final int getEndColumn() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */   
/* 114 */   public final int getEndLine() { return 1; }
/*     */ 
/*     */   
/* 117 */   public final int getBeginColumn() { return this.bufferStart + this.tokenStart; }
/*     */ 
/*     */   
/* 120 */   public final int getBeginLine() { return 1; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\FastCharStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.MultiFieldQueryParser,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ import java.util.Map;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.search.BooleanClause;
/*     */ import org.apache.lucene.search.BooleanQuery;
/*     */ import org.apache.lucene.search.MultiPhraseQuery;
/*     */ import org.apache.lucene.search.PhraseQuery;
/*     */ import org.apache.lucene.search.Query;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiFieldQueryParser
/*     */   extends QueryParser
/*     */ {
/*     */   protected String[] fields;
/*     */   protected Map boosts;
/*     */   
/*     */   public MultiFieldQueryParser(String[] fields, Analyzer analyzer, Map boosts) {
/*  69 */     this(fields, analyzer);
/*  70 */     this.boosts = boosts;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultiFieldQueryParser(String[] fields, Analyzer analyzer) {
/*  94 */     super(null, analyzer);
/*  95 */     this.fields = fields;
/*     */   }
/*     */   
/*     */   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
/*  99 */     if (field == null) {
/* 100 */       Vector clauses = new Vector();
/* 101 */       for (int i = 0; i < this.fields.length; i++) {
/* 102 */         Query q = getFieldQuery(this.fields[i], queryText);
/* 103 */         if (q != null) {
/*     */           
/* 105 */           if (this.boosts != null) {
/*     */             
/* 107 */             Float boost = (Float)this.boosts.get(this.fields[i]);
/* 108 */             if (boost != null) {
/* 109 */               q.setBoost(boost.floatValue());
/*     */             }
/*     */           } 
/* 112 */           if (q instanceof PhraseQuery) {
/* 113 */             ((PhraseQuery)q).setSlop(slop);
/*     */           }
/* 115 */           if (q instanceof MultiPhraseQuery) {
/* 116 */             ((MultiPhraseQuery)q).setSlop(slop);
/*     */           }
/* 118 */           clauses.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
/*     */         } 
/*     */       } 
/* 121 */       if (clauses.size() == 0)
/* 122 */         return null; 
/* 123 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 125 */     return super.getFieldQuery(field, queryText);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 130 */   protected Query getFieldQuery(String field, String queryText) throws ParseException { return getFieldQuery(field, queryText, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
/* 136 */     if (field == null) {
/* 137 */       Vector clauses = new Vector();
/* 138 */       for (int i = 0; i < this.fields.length; i++) {
/* 139 */         clauses.add(new BooleanClause(getFuzzyQuery(this.fields[i], termStr, minSimilarity), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 142 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 144 */     return super.getFuzzyQuery(field, termStr, minSimilarity);
/*     */   }
/*     */ 
/*     */   
/*     */   protected Query getPrefixQuery(String field, String termStr) throws ParseException {
/* 149 */     if (field == null) {
/* 150 */       Vector clauses = new Vector();
/* 151 */       for (int i = 0; i < this.fields.length; i++) {
/* 152 */         clauses.add(new BooleanClause(getPrefixQuery(this.fields[i], termStr), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 155 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 157 */     return super.getPrefixQuery(field, termStr);
/*     */   }
/*     */   
/*     */   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
/* 161 */     if (field == null) {
/* 162 */       Vector clauses = new Vector();
/* 163 */       for (int i = 0; i < this.fields.length; i++) {
/* 164 */         clauses.add(new BooleanClause(getWildcardQuery(this.fields[i], termStr), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 167 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 169 */     return super.getWildcardQuery(field, termStr);
/*     */   }
/*     */ 
/*     */   
/*     */   protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
/* 174 */     if (field == null) {
/* 175 */       Vector clauses = new Vector();
/* 176 */       for (int i = 0; i < this.fields.length; i++) {
/* 177 */         clauses.add(new BooleanClause(getRangeQuery(this.fields[i], part1, part2, inclusive), BooleanClause.Occur.SHOULD));
/*     */       }
/*     */       
/* 180 */       return getBooleanQuery(clauses, true);
/*     */     } 
/* 182 */     return super.getRangeQuery(field, part1, part2, inclusive);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String[] queries, String[] fields, Analyzer analyzer) throws ParseException {
/* 204 */     if (queries.length != fields.length)
/* 205 */       throw new IllegalArgumentException(""queries.length != fields.length""); 
/* 206 */     BooleanQuery bQuery = new BooleanQuery();
/* 207 */     for (int i = 0; i < fields.length; i++) {
/*     */       
/* 209 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 210 */       Query q = qp.parse(queries[i]);
/* 211 */       bQuery.add(q, BooleanClause.Occur.SHOULD);
/*     */     } 
/* 213 */     return (Query)bQuery;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String query, String[] fields, BooleanClause.Occur[] flags, Analyzer analyzer) throws ParseException {
/* 248 */     if (fields.length != flags.length)
/* 249 */       throw new IllegalArgumentException(""fields.length != flags.length""); 
/* 250 */     BooleanQuery bQuery = new BooleanQuery();
/* 251 */     for (int i = 0; i < fields.length; i++) {
/* 252 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 253 */       Query q = qp.parse(query);
/* 254 */       bQuery.add(q, flags[i]);
/*     */     } 
/* 256 */     return (Query)bQuery;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query parse(String[] queries, String[] fields, BooleanClause.Occur[] flags, Analyzer analyzer) throws ParseException {
/* 293 */     if (queries.length != fields.length || queries.length != flags.length)
/* 294 */       throw new IllegalArgumentException(""queries, fields, and flags array have have different length""); 
/* 295 */     BooleanQuery bQuery = new BooleanQuery();
/* 296 */     for (int i = 0; i < fields.length; i++) {
/*     */       
/* 298 */       QueryParser qp = new QueryParser(fields[i], analyzer);
/* 299 */       Query q = qp.parse(queries[i]);
/* 300 */       bQuery.add(q, flags[i]);
/*     */     } 
/* 302 */     return (Query)bQuery;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\MultiFieldQueryParser.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.ParseException,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParseException
/*     */   extends Exception
/*     */ {
/*     */   protected boolean specialConstructor;
/*     */   public Token currentToken;
/*     */   public int[][] expectedTokenSequences;
/*     */   public String[] tokenImage;
/*     */   protected String eol;
/*     */   
/*     */   public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
/*  32 */     super("""");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 140 */     this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = true; this.currentToken = currentTokenVal; this.expectedTokenSequences = expectedTokenSequencesVal; this.tokenImage = tokenImageVal; } public ParseException() { this.eol = System.getProperty(""line.separator"", ""\n""); this.specialConstructor = false; } public ParseException(String message) { super(message); this.eol = System.getProperty(""line.separator"", ""\n"");
/*     */     this.specialConstructor = false; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected String add_escapes(String str) {
/* 148 */     StringBuffer retval = new StringBuffer();
/*     */     
/* 150 */     for (int i = 0; i < str.length(); i++) {
/* 151 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/* 156 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/* 159 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/* 162 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/* 165 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/* 168 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/* 171 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/* 174 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/* 177 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/* 180 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/* 181 */             String s = ""0000"" + Integer.toString(ch, 16);
/* 182 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/* 184 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/* 189 */     return retval.toString();
/*     */   }
/*     */   
/*     */   public String getMessage() {
/*     */     if (!this.specialConstructor)
/*     */       return super.getMessage(); 
/*     */     String expected = """";
/*     */     int maxSize = 0;
/*     */     for (int i = 0; i < this.expectedTokenSequences.length; i++) {
/*     */       if (maxSize < (this.expectedTokenSequences[i]).length)
/*     */         maxSize = (this.expectedTokenSequences[i]).length; 
/*     */       for (int j = 0; j < (this.expectedTokenSequences[i]).length; j++)
/*     */         expected = expected + this.tokenImage[this.expectedTokenSequences[i][j]] + "" ""; 
/*     */       if (this.expectedTokenSequences[i][(this.expectedTokenSequences[i]).length - 1] != 0)
/*     */         expected = expected + ""...""; 
/*     */       expected = expected + this.eol + ""    "";
/*     */     } 
/*     */     String retval = ""Encountered \"""";
/*     */     Token tok = this.currentToken.next;
/*     */     for (int i = 0; i < maxSize; i++) {
/*     */       if (i != 0)
/*     */         retval = retval + "" ""; 
/*     */       if (tok.kind == 0) {
/*     */         retval = retval + this.tokenImage[0];
/*     */         break;
/*     */       } 
/*     */       retval = retval + add_escapes(tok.image);
/*     */       tok = tok.next;
/*     */     } 
/*     */     retval = retval + ""\"" at line "" + this.currentToken.next.beginLine + "", column "" + this.currentToken.next.beginColumn;
/*     */     retval = retval + ""."" + this.eol;
/*     */     if (this.expectedTokenSequences.length == 1) {
/*     */       retval = retval + ""Was expecting:"" + this.eol + ""    "";
/*     */     } else {
/*     */       retval = retval + ""Was expecting one of:"" + this.eol + ""    "";
/*     */     } 
/*     */     retval = retval + expected;
/*     */     return retval;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\ParseException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParser,"/*      */ package org.apache.lucene.queryParser;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.StringReader;
/*      */ import java.text.DateFormat;
/*      */ import java.util.ArrayList;
/*      */ import java.util.Calendar;
/*      */ import java.util.Date;
/*      */ import java.util.Enumeration;
/*      */ import java.util.HashMap;
/*      */ import java.util.List;
/*      */ import java.util.Locale;
/*      */ import java.util.Map;
/*      */ import java.util.Vector;
/*      */ import org.apache.lucene.analysis.Analyzer;
/*      */ import org.apache.lucene.analysis.SimpleAnalyzer;
/*      */ import org.apache.lucene.analysis.Token;
/*      */ import org.apache.lucene.analysis.TokenStream;
/*      */ import org.apache.lucene.document.DateField;
/*      */ import org.apache.lucene.document.DateTools;
/*      */ import org.apache.lucene.index.Term;
/*      */ import org.apache.lucene.search.BooleanClause;
/*      */ import org.apache.lucene.search.BooleanQuery;
/*      */ import org.apache.lucene.search.ConstantScoreRangeQuery;
/*      */ import org.apache.lucene.search.FuzzyQuery;
/*      */ import org.apache.lucene.search.MatchAllDocsQuery;
/*      */ import org.apache.lucene.search.MultiPhraseQuery;
/*      */ import org.apache.lucene.search.PhraseQuery;
/*      */ import org.apache.lucene.search.PrefixQuery;
/*      */ import org.apache.lucene.search.Query;
/*      */ import org.apache.lucene.search.RangeQuery;
/*      */ import org.apache.lucene.search.TermQuery;
/*      */ import org.apache.lucene.search.WildcardQuery;
/*      */ import org.apache.lucene.util.Parameter;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class QueryParser
/*      */   implements QueryParserConstants
/*      */ {
/*      */   private static final int CONJ_NONE = 0;
/*      */   private static final int CONJ_AND = 1;
/*      */   private static final int CONJ_OR = 2;
/*      */   private static final int MOD_NONE = 0;
/*      */   private static final int MOD_NOT = 10;
/*      */   private static final int MOD_REQ = 11;
/*   93 */   public static final Operator AND_OPERATOR = Operator.AND;
/*      */   
/*   95 */   public static final Operator OR_OPERATOR = Operator.OR;
/*      */ 
/*      */   
/*   98 */   private Operator operator = OR_OPERATOR;
/*      */   
/*      */   boolean lowercaseExpandedTerms = true;
/*      */   
/*      */   boolean useOldRangeQuery = false;
/*      */   boolean allowLeadingWildcard = false;
/*      */   Analyzer analyzer;
/*      */   String field;
/*  106 */   int phraseSlop = 0;
/*  107 */   float fuzzyMinSim = 0.5F;
/*  108 */   int fuzzyPrefixLength = 0;
/*  109 */   Locale locale = Locale.getDefault();
/*      */ 
/*      */   
/*  112 */   DateTools.Resolution dateResolution = null;
/*      */   
/*  114 */   Map fieldToDateResolution = null; public QueryParserTokenManager token_source; public Token token;
/*      */   public Token jj_nt;
/*      */   private int jj_ntk;
/*      */   private Token jj_scanpos;
/*      */   private Token jj_lastpos;
/*      */   private int jj_la;
/*      */   
/*  121 */   public static final class Operator extends Parameter { private Operator(String name) { super(name); }
/*      */     
/*  123 */     public static final Operator OR = new Operator(""OR"");
/*  124 */     public static final Operator AND = new Operator(""AND""); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public QueryParser(String f, Analyzer a) {
/*  133 */     this(new FastCharStream(new StringReader("""")));
/*  134 */     this.analyzer = a;
/*  135 */     this.field = f;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Query parse(String query) throws ParseException {
/*  143 */     ReInit(new FastCharStream(new StringReader(query)));
/*      */     
/*      */     try {
/*  146 */       return TopLevelQuery(this.field);
/*      */     }
/*  148 */     catch (ParseException tme) {
/*      */       
/*  150 */       throw new ParseException(""Cannot parse '"" + query + ""': "" + tme.getMessage());
/*      */     }
/*  152 */     catch (TokenMgrError tme) {
/*  153 */       throw new ParseException(""Cannot parse '"" + query + ""': "" + tme.getMessage());
/*      */     }
/*  155 */     catch (org.apache.lucene.search.BooleanQuery.TooManyClauses tmc) {
/*  156 */       throw new ParseException(""Cannot parse '"" + query + ""': too many boolean clauses"");
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  164 */   public Analyzer getAnalyzer() { return this.analyzer; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  171 */   public String getField() { return this.field; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  178 */   public float getFuzzyMinSim() { return this.fuzzyMinSim; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  186 */   public void setFuzzyMinSim(float fuzzyMinSim) { this.fuzzyMinSim = fuzzyMinSim; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  194 */   public int getFuzzyPrefixLength() { return this.fuzzyPrefixLength; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  202 */   public void setFuzzyPrefixLength(int fuzzyPrefixLength) { this.fuzzyPrefixLength = fuzzyPrefixLength; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  210 */   public void setPhraseSlop(int phraseSlop) { this.phraseSlop = phraseSlop; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  217 */   public int getPhraseSlop() { return this.phraseSlop; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  232 */   public void setAllowLeadingWildcard(boolean allowLeadingWildcard) { this.allowLeadingWildcard = allowLeadingWildcard; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  239 */   public boolean getAllowLeadingWildcard() { return this.allowLeadingWildcard; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  251 */   public void setDefaultOperator(Operator op) { this.operator = op; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  260 */   public Operator getDefaultOperator() { return this.operator; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  269 */   public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) { this.lowercaseExpandedTerms = lowercaseExpandedTerms; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  277 */   public boolean getLowercaseExpandedTerms() { return this.lowercaseExpandedTerms; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  290 */   public void setUseOldRangeQuery(boolean useOldRangeQuery) { this.useOldRangeQuery = useOldRangeQuery; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  298 */   public boolean getUseOldRangeQuery() { return this.useOldRangeQuery; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  306 */   public void setLocale(Locale locale) { this.locale = locale; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  313 */   public Locale getLocale() { return this.locale; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  324 */   public void setDateResolution(DateTools.Resolution dateResolution) { this.dateResolution = dateResolution; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void setDateResolution(String fieldName, DateTools.Resolution dateResolution) {
/*  334 */     if (fieldName == null) {
/*  335 */       throw new IllegalArgumentException(""Field cannot be null."");
/*      */     }
/*      */     
/*  338 */     if (this.fieldToDateResolution == null)
/*      */     {
/*  340 */       this.fieldToDateResolution = new HashMap();
/*      */     }
/*      */     
/*  343 */     this.fieldToDateResolution.put(fieldName, dateResolution);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public DateTools.Resolution getDateResolution(String fieldName) {
/*  353 */     if (fieldName == null) {
/*  354 */       throw new IllegalArgumentException(""Field cannot be null."");
/*      */     }
/*      */     
/*  357 */     if (this.fieldToDateResolution == null)
/*      */     {
/*  359 */       return this.dateResolution;
/*      */     }
/*      */     
/*  362 */     DateTools.Resolution resolution = (DateTools.Resolution)this.fieldToDateResolution.get(fieldName);
/*  363 */     if (resolution == null)
/*      */     {
/*  365 */       resolution = this.dateResolution;
/*      */     }
/*      */     
/*  368 */     return resolution;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   protected void addClause(Vector clauses, int conj, int mods, Query q) {
/*      */     boolean prohibited;
/*      */     boolean required;
/*  376 */     if (clauses.size() > 0 && conj == 1) {
/*  377 */       BooleanClause c = clauses.elementAt(clauses.size() - 1);
/*  378 */       if (!c.isProhibited()) {
/*  379 */         c.setOccur(BooleanClause.Occur.MUST);
/*      */       }
/*      */     } 
/*  382 */     if (clauses.size() > 0 && this.operator == AND_OPERATOR && conj == 2) {
/*      */ 
/*      */ 
/*      */ 
/*      */       
/*  387 */       BooleanClause c = clauses.elementAt(clauses.size() - 1);
/*  388 */       if (!c.isProhibited()) {
/*  389 */         c.setOccur(BooleanClause.Occur.SHOULD);
/*      */       }
/*      */     } 
/*      */ 
/*      */     
/*  394 */     if (q == null) {
/*      */       return;
/*      */     }
/*  397 */     if (this.operator == OR_OPERATOR) {
/*      */ 
/*      */       
/*  400 */       prohibited = (mods == 10);
/*  401 */       required = (mods == 11);
/*  402 */       if (conj == 1 && !prohibited) {
/*  403 */         required = true;
/*      */       }
/*      */     }
/*      */     else {
/*      */       
/*  408 */       prohibited = (mods == 10);
/*  409 */       required = (!prohibited && conj != 2);
/*      */     } 
/*  411 */     if (required && !prohibited) {
/*  412 */       clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));
/*  413 */     } else if (!required && !prohibited) {
/*  414 */       clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));
/*  415 */     } else if (!required && prohibited) {
/*  416 */       clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));
/*      */     } else {
/*  418 */       throw new RuntimeException(""Clause cannot be both required and prohibited"");
/*      */     } 
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFieldQuery(String field, String queryText) throws ParseException {
/*  429 */     TokenStream source = this.analyzer.tokenStream(field, new StringReader(queryText));
/*  430 */     Vector v = new Vector();
/*      */     
/*  432 */     int positionCount = 0;
/*  433 */     boolean severalTokensAtSamePosition = false;
/*      */     while (true) {
/*      */       Token token1;
/*      */       try {
/*  437 */         token1 = source.next();
/*      */       }
/*  439 */       catch (IOException e) {
/*  440 */         token1 = null;
/*      */       } 
/*  442 */       if (token1 == null)
/*      */         break; 
/*  444 */       v.addElement(token1);
/*  445 */       if (token1.getPositionIncrement() != 0) {
/*  446 */         positionCount += token1.getPositionIncrement(); continue;
/*      */       } 
/*  448 */       severalTokensAtSamePosition = true;
/*      */     } 
/*      */     try {
/*  451 */       source.close();
/*      */     }
/*  453 */     catch (IOException e) {}
/*      */ 
/*      */ 
/*      */     
/*  457 */     if (v.size() == 0)
/*  458 */       return null; 
/*  459 */     if (v.size() == 1) {
/*  460 */       Token token1 = (Token)v.elementAt(0);
/*  461 */       return (Query)new TermQuery(new Term(field, token1.termText()));
/*      */     } 
/*  463 */     if (severalTokensAtSamePosition) {
/*  464 */       if (positionCount == 1) {
/*      */         
/*  466 */         BooleanQuery q = new BooleanQuery(true);
/*  467 */         for (int i = 0; i < v.size(); i++) {
/*  468 */           Token token1 = (Token)v.elementAt(i);
/*  469 */           TermQuery currentQuery = new TermQuery(new Term(field, token1.termText()));
/*      */           
/*  471 */           q.add((Query)currentQuery, BooleanClause.Occur.SHOULD);
/*      */         } 
/*  473 */         return (Query)q;
/*      */       } 
/*      */ 
/*      */       
/*  477 */       MultiPhraseQuery mpq = new MultiPhraseQuery();
/*  478 */       mpq.setSlop(this.phraseSlop);
/*  479 */       List multiTerms = new ArrayList();
/*  480 */       for (int i = 0; i < v.size(); i++) {
/*  481 */         Token token1 = (Token)v.elementAt(i);
/*  482 */         if (token1.getPositionIncrement() == 1 && multiTerms.size() > 0) {
/*  483 */           mpq.add((Term[])multiTerms.toArray((Object[])new Term[0]));
/*  484 */           multiTerms.clear();
/*      */         } 
/*  486 */         multiTerms.add(new Term(field, token1.termText()));
/*      */       } 
/*  488 */       mpq.add(multiTerms.toArray(new Term[0]));
/*  489 */       return (Query)mpq;
/*      */     } 
/*      */ 
/*      */     
/*  493 */     PhraseQuery q = new PhraseQuery();
/*  494 */     q.setSlop(this.phraseSlop);
/*  495 */     for (int i = 0; i < v.size(); i++) {
/*  496 */       q.add(new Term(field, ((Token)v.elementAt(i)).termText()));
/*      */     }
/*      */ 
/*      */     
/*  500 */     return (Query)q;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
/*  515 */     Query query = getFieldQuery(field, queryText);
/*      */     
/*  517 */     if (query instanceof PhraseQuery) {
/*  518 */       ((PhraseQuery)query).setSlop(slop);
/*      */     }
/*  520 */     if (query instanceof MultiPhraseQuery) {
/*  521 */       ((MultiPhraseQuery)query).setSlop(slop);
/*      */     }
/*      */     
/*  524 */     return query;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
/*  536 */     if (this.lowercaseExpandedTerms) {
/*  537 */       part1 = part1.toLowerCase();
/*  538 */       part2 = part2.toLowerCase();
/*      */     } 
/*      */     try {
/*  541 */       DateFormat df = DateFormat.getDateInstance(3, this.locale);
/*  542 */       df.setLenient(true);
/*  543 */       Date d1 = df.parse(part1);
/*  544 */       Date d2 = df.parse(part2);
/*  545 */       if (inclusive) {
/*      */ 
/*      */ 
/*      */         
/*  549 */         Calendar cal = Calendar.getInstance(this.locale);
/*  550 */         cal.setTime(d2);
/*  551 */         cal.set(11, 23);
/*  552 */         cal.set(12, 59);
/*  553 */         cal.set(13, 59);
/*  554 */         cal.set(14, 999);
/*  555 */         d2 = cal.getTime();
/*      */       } 
/*  557 */       DateTools.Resolution resolution = getDateResolution(field);
/*  558 */       if (resolution == null) {
/*      */ 
/*      */ 
/*      */         
/*  562 */         part1 = DateField.dateToString(d1);
/*  563 */         part2 = DateField.dateToString(d2);
/*      */       } else {
/*  565 */         part1 = DateTools.dateToString(d1, resolution);
/*  566 */         part2 = DateTools.dateToString(d2, resolution);
/*      */       }
/*      */     
/*  569 */     } catch (Exception e) {}
/*      */     
/*  571 */     if (this.useOldRangeQuery)
/*      */     {
/*  573 */       return (Query)new RangeQuery(new Term(field, part1), new Term(field, part2), inclusive);
/*      */     }
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  579 */     return (Query)new ConstantScoreRangeQuery(field, part1, part2, inclusive, inclusive);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  597 */   protected Query getBooleanQuery(Vector clauses) throws ParseException { return getBooleanQuery(clauses, false); }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getBooleanQuery(Vector clauses, boolean disableCoord) throws ParseException {
/*  617 */     BooleanQuery query = new BooleanQuery(disableCoord);
/*  618 */     for (int i = 0; i < clauses.size(); i++) {
/*  619 */       query.add(clauses.elementAt(i));
/*      */     }
/*  621 */     return (Query)query;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
/*  647 */     if (""*"".equals(field) && 
/*  648 */       ""*"".equals(termStr)) return (Query)new MatchAllDocsQuery();
/*      */     
/*  650 */     if (!this.allowLeadingWildcard && (termStr.startsWith(""*"") || termStr.startsWith(""?"")))
/*  651 */       throw new ParseException(""'*' or '?' not allowed as first character in WildcardQuery""); 
/*  652 */     if (this.lowercaseExpandedTerms) {
/*  653 */       termStr = termStr.toLowerCase();
/*      */     }
/*  655 */     Term t = new Term(field, termStr);
/*  656 */     return (Query)new WildcardQuery(t);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getPrefixQuery(String field, String termStr) throws ParseException {
/*  684 */     if (!this.allowLeadingWildcard && termStr.startsWith(""*""))
/*  685 */       throw new ParseException(""'*' not allowed as first character in PrefixQuery""); 
/*  686 */     if (this.lowercaseExpandedTerms) {
/*  687 */       termStr = termStr.toLowerCase();
/*      */     }
/*  689 */     Term t = new Term(field, termStr);
/*  690 */     return (Query)new PrefixQuery(t);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
/*  707 */     if (this.lowercaseExpandedTerms) {
/*  708 */       termStr = termStr.toLowerCase();
/*      */     }
/*  710 */     Term t = new Term(field, termStr);
/*  711 */     return (Query)new FuzzyQuery(t, minSimilarity, this.fuzzyPrefixLength);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private String discardEscapeChar(String input) throws ParseException {
/*  724 */     char[] output = new char[input.length()];
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  729 */     int length = 0;
/*      */ 
/*      */ 
/*      */     
/*  733 */     boolean lastCharWasEscapeChar = false;
/*      */ 
/*      */ 
/*      */     
/*  737 */     int codePointMultiplier = 0;
/*      */ 
/*      */     
/*  740 */     int codePoint = 0;
/*      */     
/*  742 */     for (int i = 0; i < input.length(); i++) {
/*  743 */       char curChar = input.charAt(i);
/*  744 */       if (codePointMultiplier > 0) {
/*  745 */         codePoint += hexToInt(curChar) * codePointMultiplier;
/*  746 */         codePointMultiplier >>>= 4;
/*  747 */         if (codePointMultiplier == 0) {
/*  748 */           output[length++] = (char)codePoint;
/*  749 */           codePoint = 0;
/*      */         } 
/*  751 */       } else if (lastCharWasEscapeChar) {
/*  752 */         if (curChar == 'u') {
/*      */           
/*  754 */           codePointMultiplier = 4096;
/*      */         } else {
/*      */           
/*  757 */           output[length] = curChar;
/*  758 */           length++;
/*      */         } 
/*  760 */         lastCharWasEscapeChar = false;
/*      */       }
/*  762 */       else if (curChar == '\\') {
/*  763 */         lastCharWasEscapeChar = true;
/*      */       } else {
/*  765 */         output[length] = curChar;
/*  766 */         length++;
/*      */       } 
/*      */     } 
/*      */ 
/*      */     
/*  771 */     if (codePointMultiplier > 0) {
/*  772 */       throw new ParseException(""Truncated unicode escape sequence."");
/*      */     }
/*      */     
/*  775 */     if (lastCharWasEscapeChar) {
/*  776 */       throw new ParseException(""Term can not end with escape character."");
/*      */     }
/*      */     
/*  779 */     return new String(output, 0, length);
/*      */   }
/*      */ 
/*      */   
/*      */   private static final int hexToInt(char c) throws ParseException {
/*  784 */     if ('0' <= c && c <= '9')
/*  785 */       return c - 48; 
/*  786 */     if ('a' <= c && c <= 'f')
/*  787 */       return c - 97 + 10; 
/*  788 */     if ('A' <= c && c <= 'F') {
/*  789 */       return c - 65 + 10;
/*      */     }
/*  791 */     throw new ParseException(""None-hex character in unicode escape sequence: "" + c);
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static String escape(String s) {
/*  800 */     StringBuffer sb = new StringBuffer();
/*  801 */     for (int i = 0; i < s.length(); i++) {
/*  802 */       char c = s.charAt(i);
/*      */       
/*  804 */       if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':' || c == '^' || c == '[' || c == ']' || c == '""' || c == '{' || c == '}' || c == '~' || c == '*' || c == '?' || c == '|' || c == '&')
/*      */       {
/*      */         
/*  807 */         sb.append('\\');
/*      */       }
/*  809 */       sb.append(c);
/*      */     } 
/*  811 */     return sb.toString();
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public static void main(String[] args) throws Exception {
/*  820 */     if (args.length == 0) {
/*  821 */       System.out.println(""Usage: java org.apache.lucene.queryParser.QueryParser <input>"");
/*  822 */       System.exit(0);
/*      */     } 
/*  824 */     QueryParser qp = new QueryParser(""field"", (Analyzer)new SimpleAnalyzer());
/*      */     
/*  826 */     Query q = qp.parse(args[0]);
/*  827 */     System.out.println(q.toString(""field""));
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public final int Conjunction() throws ParseException {
/*  833 */     int ret = 0;
/*  834 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */     { case 7:
/*      */       case 8:
/*  837 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */         { case 7:
/*  839 */             jj_consume_token(7);
/*  840 */             ret = 1;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */             
/*  856 */             return ret;case 8: jj_consume_token(8); ret = 2; return ret; }  this.jj_la1[0] = this.jj_gen; jj_consume_token(-1); throw new ParseException(); }  this.jj_la1[1] = this.jj_gen; return ret;
/*      */   }
/*      */ 
/*      */   
/*      */   public final int Modifiers() throws ParseException {
/*  861 */     int ret = 0;
/*  862 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */     { case 9:
/*      */       case 10:
/*      */       case 11:
/*  866 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk)
/*      */         { case 10:
/*  868 */             jj_consume_token(10);
/*  869 */             ret = 11;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */             
/*  889 */             return ret;case 11: jj_consume_token(11); ret = 10; return ret;case 9: jj_consume_token(9); ret = 10; return ret; }  this.jj_la1[2] = this.jj_gen; jj_consume_token(-1); throw new ParseException(); }  this.jj_la1[3] = this.jj_gen; return ret;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final Query TopLevelQuery(String field) throws ParseException {
/*  896 */     Query q = Query(field);
/*  897 */     jj_consume_token(0);
/*  898 */     return q;
/*      */   }
/*      */ 
/*      */   
/*      */   public final Query Query(String field) throws ParseException {
/*  903 */     Vector clauses = new Vector();
/*  904 */     Query firstQuery = null;
/*      */     
/*  906 */     int mods = Modifiers();
/*  907 */     Query q = Clause(field);
/*  908 */     addClause(clauses, 0, mods, q);
/*  909 */     if (mods == 0) {
/*  910 */       firstQuery = q;
/*      */     }
/*      */     while (true) {
/*  913 */       switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */         case 7:
/*      */         case 8:
/*      */         case 9:
/*      */         case 10:
/*      */         case 11:
/*      */         case 12:
/*      */         case 15:
/*      */         case 17:
/*      */         case 18:
/*      */         case 20:
/*      */         case 21:
/*      */         case 22:
/*      */         case 23:
/*      */         case 24:
/*      */           break;
/*      */         
/*      */         default:
/*  931 */           this.jj_la1[4] = this.jj_gen;
/*      */           break;
/*      */       } 
/*  934 */       int conj = Conjunction();
/*  935 */       mods = Modifiers();
/*  936 */       q = Clause(field);
/*  937 */       addClause(clauses, conj, mods, q);
/*      */     } 
/*  939 */     if (clauses.size() == 1 && firstQuery != null) {
/*  940 */       return firstQuery;
/*      */     }
/*  942 */     return getBooleanQuery(clauses);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public final Query Clause(String field) throws ParseException {
/*      */     Query q;
/*  949 */     Token fieldToken = null, boost = null;
/*  950 */     if (jj_2_1(2)) {
/*  951 */       switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */         case 18:
/*  953 */           fieldToken = jj_consume_token(18);
/*  954 */           jj_consume_token(14);
/*  955 */           field = discardEscapeChar(fieldToken.image);
/*      */           break;
/*      */         case 15:
/*  958 */           jj_consume_token(15);
/*  959 */           jj_consume_token(14);
/*  960 */           field = ""*"";
/*      */           break;
/*      */         default:
/*  963 */           this.jj_la1[5] = this.jj_gen;
/*  964 */           jj_consume_token(-1);
/*  965 */           throw new ParseException();
/*      */       } 
/*      */ 
/*      */     
/*      */     }
/*  970 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */       case 15:
/*      */       case 17:
/*      */       case 18:
/*      */       case 20:
/*      */       case 21:
/*      */       case 22:
/*      */       case 23:
/*      */       case 24:
/*  979 */         q = Term(field);
/*      */         break;
/*      */       case 12:
/*  982 */         jj_consume_token(12);
/*  983 */         q = Query(field);
/*  984 */         jj_consume_token(13);
/*  985 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 16:
/*  987 */             jj_consume_token(16);
/*  988 */             boost = jj_consume_token(24);
/*      */             break;
/*      */         } 
/*  991 */         this.jj_la1[6] = this.jj_gen;
/*      */         break;
/*      */ 
/*      */       
/*      */       default:
/*  996 */         this.jj_la1[7] = this.jj_gen;
/*  997 */         jj_consume_token(-1);
/*  998 */         throw new ParseException();
/*      */     } 
/* 1000 */     if (boost != null) {
/* 1001 */       float f = 1.0F;
/*      */       try {
/* 1003 */         f = Float.valueOf(boost.image).floatValue();
/* 1004 */         q.setBoost(f);
/* 1005 */       } catch (Exception ignored) {}
/*      */     } 
/* 1007 */     return q;
/*      */   } public final Query Term(String field) throws ParseException {
/*      */     int s;
/*      */     String termImage;
/*      */     Query q;
/* 1012 */     Token goop2, goop1, term, boost = null, fuzzySlop = null;
/* 1013 */     boolean prefix = false;
/* 1014 */     boolean wildcard = false;
/* 1015 */     boolean fuzzy = false;
/* 1016 */     boolean rangein = false;
/*      */     
/* 1018 */     switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */       case 15:
/*      */       case 18:
/*      */       case 20:
/*      */       case 21:
/*      */       case 24:
/* 1024 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 18:
/* 1026 */             term = jj_consume_token(18);
/*      */             break;
/*      */           case 15:
/* 1029 */             term = jj_consume_token(15);
/* 1030 */             wildcard = true;
/*      */             break;
/*      */           case 20:
/* 1033 */             term = jj_consume_token(20);
/* 1034 */             prefix = true;
/*      */             break;
/*      */           case 21:
/* 1037 */             term = jj_consume_token(21);
/* 1038 */             wildcard = true;
/*      */             break;
/*      */           case 24:
/* 1041 */             term = jj_consume_token(24);
/*      */             break;
/*      */           default:
/* 1044 */             this.jj_la1[8] = this.jj_gen;
/* 1045 */             jj_consume_token(-1);
/* 1046 */             throw new ParseException();
/*      */         } 
/* 1048 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 19:
/* 1050 */             fuzzySlop = jj_consume_token(19);
/* 1051 */             fuzzy = true;
/*      */             break;
/*      */           default:
/* 1054 */             this.jj_la1[9] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1057 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 16:
/* 1059 */             jj_consume_token(16);
/* 1060 */             boost = jj_consume_token(24);
/* 1061 */             switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */               case 19:
/* 1063 */                 fuzzySlop = jj_consume_token(19);
/* 1064 */                 fuzzy = true;
/*      */                 break;
/*      */             } 
/* 1067 */             this.jj_la1[10] = this.jj_gen;
/*      */             break;
/*      */ 
/*      */           
/*      */           default:
/* 1072 */             this.jj_la1[11] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1075 */         termImage = discardEscapeChar(term.image);
/* 1076 */         if (wildcard) {
/* 1077 */           Query q = getWildcardQuery(field, termImage); break;
/* 1078 */         }  if (prefix) {
/* 1079 */           Query q = getPrefixQuery(field, discardEscapeChar(term.image.substring(0, term.image.length() - 1)));
/*      */           break;
/*      */         } 
/* 1082 */         if (fuzzy) {
/* 1083 */           float fms = this.fuzzyMinSim;
/*      */           try {
/* 1085 */             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
/* 1086 */           } catch (Exception ignored) {}
/* 1087 */           if (fms < 0.0F || fms > 1.0F) {
/* 1088 */             throw new ParseException(""Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !"");
/*      */           }
/* 1090 */           Query q = getFuzzyQuery(field, termImage, fms); break;
/*      */         } 
/* 1092 */         q = getFieldQuery(field, termImage);
/*      */         break;
/*      */       
/*      */       case 22:
/* 1096 */         jj_consume_token(22);
/* 1097 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 28:
/* 1099 */             goop1 = jj_consume_token(28);
/*      */             break;
/*      */           case 27:
/* 1102 */             goop1 = jj_consume_token(27);
/*      */             break;
/*      */           default:
/* 1105 */             this.jj_la1[12] = this.jj_gen;
/* 1106 */             jj_consume_token(-1);
/* 1107 */             throw new ParseException();
/*      */         } 
/* 1109 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 25:
/* 1111 */             jj_consume_token(25);
/*      */             break;
/*      */           default:
/* 1114 */             this.jj_la1[13] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1117 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 28:
/* 1119 */             goop2 = jj_consume_token(28);
/*      */             break;
/*      */           case 27:
/* 1122 */             goop2 = jj_consume_token(27);
/*      */             break;
/*      */           default:
/* 1125 */             this.jj_la1[14] = this.jj_gen;
/* 1126 */             jj_consume_token(-1);
/* 1127 */             throw new ParseException();
/*      */         } 
/* 1129 */         jj_consume_token(26);
/* 1130 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 16:
/* 1132 */             jj_consume_token(16);
/* 1133 */             boost = jj_consume_token(24);
/*      */             break;
/*      */           default:
/* 1136 */             this.jj_la1[15] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1139 */         if (goop1.kind == 27) {
/* 1140 */           goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
/*      */         }
/* 1142 */         if (goop2.kind == 27) {
/* 1143 */           goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
/*      */         }
/* 1145 */         q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true);
/*      */         break;
/*      */       case 23:
/* 1148 */         jj_consume_token(23);
/* 1149 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 32:
/* 1151 */             goop1 = jj_consume_token(32);
/*      */             break;
/*      */           case 31:
/* 1154 */             goop1 = jj_consume_token(31);
/*      */             break;
/*      */           default:
/* 1157 */             this.jj_la1[16] = this.jj_gen;
/* 1158 */             jj_consume_token(-1);
/* 1159 */             throw new ParseException();
/*      */         } 
/* 1161 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 29:
/* 1163 */             jj_consume_token(29);
/*      */             break;
/*      */           default:
/* 1166 */             this.jj_la1[17] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1169 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 32:
/* 1171 */             goop2 = jj_consume_token(32);
/*      */             break;
/*      */           case 31:
/* 1174 */             goop2 = jj_consume_token(31);
/*      */             break;
/*      */           default:
/* 1177 */             this.jj_la1[18] = this.jj_gen;
/* 1178 */             jj_consume_token(-1);
/* 1179 */             throw new ParseException();
/*      */         } 
/* 1181 */         jj_consume_token(30);
/* 1182 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 16:
/* 1184 */             jj_consume_token(16);
/* 1185 */             boost = jj_consume_token(24);
/*      */             break;
/*      */           default:
/* 1188 */             this.jj_la1[19] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1191 */         if (goop1.kind == 31) {
/* 1192 */           goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
/*      */         }
/* 1194 */         if (goop2.kind == 31) {
/* 1195 */           goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
/*      */         }
/*      */         
/* 1198 */         q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false);
/*      */         break;
/*      */       case 17:
/* 1201 */         term = jj_consume_token(17);
/* 1202 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 19:
/* 1204 */             fuzzySlop = jj_consume_token(19);
/*      */             break;
/*      */           default:
/* 1207 */             this.jj_la1[20] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1210 */         switch ((this.jj_ntk == -1) ? jj_ntk() : this.jj_ntk) {
/*      */           case 16:
/* 1212 */             jj_consume_token(16);
/* 1213 */             boost = jj_consume_token(24);
/*      */             break;
/*      */           default:
/* 1216 */             this.jj_la1[21] = this.jj_gen;
/*      */             break;
/*      */         } 
/* 1219 */         s = this.phraseSlop;
/*      */         
/* 1221 */         if (fuzzySlop != null) {
/*      */           try {
/* 1223 */             s = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
/*      */           }
/* 1225 */           catch (Exception ignored) {}
/*      */         }
/* 1227 */         q = getFieldQuery(field, discardEscapeChar(term.image.substring(1, term.image.length() - 1)), s);
/*      */         break;
/*      */       default:
/* 1230 */         this.jj_la1[22] = this.jj_gen;
/* 1231 */         jj_consume_token(-1);
/* 1232 */         throw new ParseException();
/*      */     } 
/* 1234 */     if (boost != null) {
/* 1235 */       float f = 1.0F;
/*      */       try {
/* 1237 */         f = Float.valueOf(boost.image).floatValue();
/*      */       }
/* 1239 */       catch (Exception ignored) {}
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */       
/* 1246 */       if (q != null) {
/* 1247 */         q.setBoost(f);
/*      */       }
/*      */     } 
/* 1250 */     return q;
/*      */   }
/*      */ 
/*      */   
/*      */   private final boolean jj_2_1(int xla) {
/* 1255 */     this.jj_la = xla; this.jj_lastpos = this.jj_scanpos = this.token; 
/* 1256 */     try { return !jj_3_1(); }
/* 1257 */     catch (LookaheadSuccess ls) { return true; }
/* 1258 */     finally { jj_save(0, xla); }
/*      */   
/*      */   }
/*      */   
/*      */   private final boolean jj_3_1() {
/* 1263 */     Token xsp = this.jj_scanpos;
/* 1264 */     if (jj_3R_2()) {
/* 1265 */       this.jj_scanpos = xsp;
/* 1266 */       if (jj_3R_3()) return true; 
/*      */     } 
/* 1268 */     return false;
/*      */   }
/*      */   
/*      */   private final boolean jj_3R_3() {
/* 1272 */     if (jj_scan_token(15)) return true; 
/* 1273 */     if (jj_scan_token(14)) return true; 
/* 1274 */     return false;
/*      */   }
/*      */   
/*      */   private final boolean jj_3R_2() {
/* 1278 */     if (jj_scan_token(18)) return true; 
/* 1279 */     if (jj_scan_token(14)) return true; 
/* 1280 */     return false;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public boolean lookingAhead = false;
/*      */   
/*      */   private boolean jj_semLA;
/*      */   
/*      */   private int jj_gen;
/*      */   
/* 1291 */   private final int[] jj_la1 = new int[23]; private static int[] jj_la1_0;
/*      */   private static int[] jj_la1_1;
/*      */   
/*      */   static  {
/* 1295 */     jj_la1_0();
/* 1296 */     jj_la1_1();
/*      */   }
/*      */   
/* 1299 */   private static void jj_la1_0() { jj_la1_0 = new int[] { 384, 384, 3584, 3584, 32939904, 294912, 65536, 32935936, 20217856, 524288, 524288, 65536, 402653184, 33554432, 402653184, 65536, Integer.MIN_VALUE, 536870912, Integer.MIN_VALUE, 65536, 524288, 65536, 32931840 }; }
/*      */ 
/*      */   
/* 1302 */   private static void jj_la1_1() { jj_la1_1 = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0 }; }
/*      */   
/* 1304 */   private final JJCalls[] jj_2_rtns = new JJCalls[1];
/*      */   private boolean jj_rescan = false;
/* 1306 */   private int jj_gc = 0;
/*      */   
/*      */   private final LookaheadSuccess jj_ls;
/*      */   
/*      */   private Vector jj_expentries;
/*      */   
/*      */   private int[] jj_expentry;
/*      */   private int jj_kind;
/*      */   private int[] jj_lasttokens;
/*      */   private int jj_endpos;
/*      */   
/*      */   public void ReInit(CharStream stream) {
/* 1318 */     this.token_source.ReInit(stream);
/* 1319 */     this.token = new Token();
/* 1320 */     this.jj_ntk = -1;
/* 1321 */     this.jj_gen = 0;
/* 1322 */     for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }
/* 1323 */      for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }
/*      */   
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public void ReInit(QueryParserTokenManager tm) {
/* 1336 */     this.token_source = tm;
/* 1337 */     this.token = new Token();
/* 1338 */     this.jj_ntk = -1;
/* 1339 */     this.jj_gen = 0;
/* 1340 */     for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }
/* 1341 */      for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }
/*      */   
/*      */   }
/*      */   private final Token jj_consume_token(int kind) throws ParseException {
/*      */     Token oldToken;
/* 1346 */     if ((oldToken = this.token).next != null) { this.token = this.token.next; }
/* 1347 */     else { this.token = this.token.next = this.token_source.getNextToken(); }
/* 1348 */      this.jj_ntk = -1;
/* 1349 */     if (this.token.kind == kind) {
/* 1350 */       this.jj_gen++;
/* 1351 */       if (++this.jj_gc > 100) {
/* 1352 */         this.jj_gc = 0;
/* 1353 */         for (int i = 0; i < this.jj_2_rtns.length; i++) {
/* 1354 */           JJCalls c = this.jj_2_rtns[i];
/* 1355 */           while (c != null) {
/* 1356 */             if (c.gen < this.jj_gen) c.first = null; 
/* 1357 */             c = c.next;
/*      */           } 
/*      */         } 
/*      */       } 
/* 1361 */       return this.token;
/*      */     } 
/* 1363 */     this.token = oldToken;
/* 1364 */     this.jj_kind = kind;
/* 1365 */     throw generateParseException();
/*      */   }
/*      */   private static final class LookaheadSuccess extends Error {
/*      */     private LookaheadSuccess() {} }
/* 1369 */   public QueryParser(CharStream stream) { this.jj_ls = new LookaheadSuccess();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 1415 */     this.jj_expentries = new Vector();
/*      */     
/* 1417 */     this.jj_kind = -1;
/* 1418 */     this.jj_lasttokens = new int[100]; this.token_source = new QueryParserTokenManager(stream); this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }  for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }  } public QueryParser(QueryParserTokenManager tm) { this.jj_ls = new LookaheadSuccess(); this.jj_expentries = new Vector(); this.jj_kind = -1; this.jj_lasttokens = new int[100]; this.token_source = tm; this.token = new Token(); this.jj_ntk = -1; this.jj_gen = 0; for (int i = 0; i < 23; ) { this.jj_la1[i] = -1; i++; }  for (int i = 0; i < this.jj_2_rtns.length; ) { this.jj_2_rtns[i] = new JJCalls(); i++; }  }
/*      */   private final boolean jj_scan_token(int kind) { if (this.jj_scanpos == this.jj_lastpos) { this.jj_la--; if (this.jj_scanpos.next == null) { this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next = this.token_source.getNextToken(); } else { this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next; }  } else { this.jj_scanpos = this.jj_scanpos.next; }  if (this.jj_rescan) { int i = 0; Token tok = this.token; while (tok != null && tok != this.jj_scanpos) { i++; tok = tok.next; }  if (tok != null) jj_add_error_token(kind, i);  }  if (this.jj_scanpos.kind != kind)
/*      */       return true;  if (this.jj_la == 0 && this.jj_scanpos == this.jj_lastpos)
/*      */       throw this.jj_ls;  return false; }
/* 1422 */   public final Token getNextToken() { if (this.token.next != null) { this.token = this.token.next; } else { this.token = this.token.next = this.token_source.getNextToken(); }  this.jj_ntk = -1; this.jj_gen++; return this.token; } private void jj_add_error_token(int kind, int pos) { if (pos >= 100)
/* 1423 */       return;  if (pos == this.jj_endpos + 1)
/* 1424 */     { this.jj_lasttokens[this.jj_endpos++] = kind; }
/* 1425 */     else if (this.jj_endpos != 0)
/* 1426 */     { this.jj_expentry = new int[this.jj_endpos];
/* 1427 */       for (int i = 0; i < this.jj_endpos; i++) {
/* 1428 */         this.jj_expentry[i] = this.jj_lasttokens[i];
/*      */       }
/* 1430 */       boolean exists = false;
/* 1431 */       for (Enumeration e = this.jj_expentries.elements(); e.hasMoreElements(); ) {
/* 1432 */         int[] oldentry = e.nextElement();
/* 1433 */         if (oldentry.length == this.jj_expentry.length) {
/* 1434 */           exists = true;
/* 1435 */           for (int i = 0; i < this.jj_expentry.length; i++) {
/* 1436 */             if (oldentry[i] != this.jj_expentry[i]) {
/* 1437 */               exists = false;
/*      */               break;
/*      */             } 
/*      */           } 
/* 1441 */           if (exists)
/*      */             break; 
/*      */         } 
/* 1444 */       }  if (!exists) this.jj_expentries.addElement(this.jj_expentry); 
/* 1445 */       if (pos != 0) this.jj_lasttokens[(this.jj_endpos = pos) - 1] = kind;  }  }
/*      */   public final Token getToken(int index) { Token t = this.lookingAhead ? this.jj_scanpos : this.token; for (int i = 0; i < index; i++) { if (t.next != null) { t = t.next; } else { t = t.next = this.token_source.getNextToken(); }
/*      */        }
/*      */      return t; }
/*      */   private final int jj_ntk() { if ((this.jj_nt = this.token.next) == null)
/* 1450 */       return this.jj_ntk = (this.token.next = this.token_source.getNextToken()).kind;  return this.jj_ntk = this.jj_nt.kind; } public ParseException generateParseException() { this.jj_expentries.removeAllElements();
/* 1451 */     boolean[] la1tokens = new boolean[33];
/* 1452 */     for (int i = 0; i < 33; i++) {
/* 1453 */       la1tokens[i] = false;
/*      */     }
/* 1455 */     if (this.jj_kind >= 0) {
/* 1456 */       la1tokens[this.jj_kind] = true;
/* 1457 */       this.jj_kind = -1;
/*      */     } 
/* 1459 */     for (int i = 0; i < 23; i++) {
/* 1460 */       if (this.jj_la1[i] == this.jj_gen) {
/* 1461 */         for (int j = 0; j < 32; j++) {
/* 1462 */           if ((jj_la1_0[i] & 1 << j) != 0) {
/* 1463 */             la1tokens[j] = true;
/*      */           }
/* 1465 */           if ((jj_la1_1[i] & 1 << j) != 0) {
/* 1466 */             la1tokens[32 + j] = true;
/*      */           }
/*      */         } 
/*      */       }
/*      */     } 
/* 1471 */     for (int i = 0; i < 33; i++) {
/* 1472 */       if (la1tokens[i]) {
/* 1473 */         this.jj_expentry = new int[1];
/* 1474 */         this.jj_expentry[0] = i;
/* 1475 */         this.jj_expentries.addElement(this.jj_expentry);
/*      */       } 
/*      */     } 
/* 1478 */     this.jj_endpos = 0;
/* 1479 */     jj_rescan_token();
/* 1480 */     jj_add_error_token(0, 0);
/* 1481 */     int[][] exptokseq = new int[this.jj_expentries.size()][];
/* 1482 */     for (int i = 0; i < this.jj_expentries.size(); i++) {
/* 1483 */       exptokseq[i] = this.jj_expentries.elementAt(i);
/*      */     }
/* 1485 */     return new ParseException(this.token, exptokseq, tokenImage); }
/*      */ 
/*      */ 
/*      */   
/*      */   public final void enable_tracing() {}
/*      */ 
/*      */   
/*      */   public final void disable_tracing() {}
/*      */   
/*      */   private final void jj_rescan_token() {
/* 1495 */     this.jj_rescan = true;
/* 1496 */     for (int i = 0; i < 1; i++) {
/* 1497 */       JJCalls p = this.jj_2_rtns[i];
/*      */       do {
/* 1499 */         if (p.gen > this.jj_gen) {
/* 1500 */           this.jj_la = p.arg; this.jj_lastpos = this.jj_scanpos = p.first;
/* 1501 */           switch (i) { case 0:
/* 1502 */               jj_3_1(); break; }
/*      */         
/*      */         } 
/* 1505 */         p = p.next;
/* 1506 */       } while (p != null);
/*      */     } 
/* 1508 */     this.jj_rescan = false;
/*      */   }
/*      */   
/*      */   private final void jj_save(int index, int xla) {
/* 1512 */     JJCalls p = this.jj_2_rtns[index];
/* 1513 */     while (p.gen > this.jj_gen) {
/* 1514 */       if (p.next == null) { p = p.next = new JJCalls(); break; }
/* 1515 */        p = p.next;
/*      */     } 
/* 1517 */     p.gen = this.jj_gen + xla - this.jj_la; p.first = this.token; p.arg = xla;
/*      */   }
/*      */   
/*      */   static final class JJCalls {
/*      */     int gen;
/*      */     Token first;
/*      */     int arg;
/*      */     JJCalls next;
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\QueryParser.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParserConstants,"/*    */ package org.apache.lucene.queryParser;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface QueryParserConstants
/*    */ {
/*    */   public static final int EOF = 0;
/*    */   public static final int _NUM_CHAR = 1;
/*    */   public static final int _ESCAPED_CHAR = 2;
/*    */   public static final int _TERM_START_CHAR = 3;
/*    */   public static final int _TERM_CHAR = 4;
/*    */   public static final int _WHITESPACE = 5;
/*    */   public static final int AND = 7;
/*    */   public static final int OR = 8;
/*    */   public static final int NOT = 9;
/*    */   public static final int PLUS = 10;
/*    */   public static final int MINUS = 11;
/*    */   public static final int LPAREN = 12;
/*    */   public static final int RPAREN = 13;
/*    */   public static final int COLON = 14;
/*    */   public static final int STAR = 15;
/*    */   public static final int CARAT = 16;
/*    */   public static final int QUOTED = 17;
/*    */   public static final int TERM = 18;
/*    */   public static final int FUZZY_SLOP = 19;
/*    */   public static final int PREFIXTERM = 20;
/*    */   public static final int WILDTERM = 21;
/*    */   public static final int RANGEIN_START = 22;
/*    */   public static final int RANGEEX_START = 23;
/*    */   public static final int NUMBER = 24;
/*    */   public static final int RANGEIN_TO = 25;
/*    */   public static final int RANGEIN_END = 26;
/*    */   public static final int RANGEIN_QUOTED = 27;
/*    */   public static final int RANGEIN_GOOP = 28;
/*    */   public static final int RANGEEX_TO = 29;
/*    */   public static final int RANGEEX_END = 30;
/*    */   public static final int RANGEEX_QUOTED = 31;
/*    */   public static final int RANGEEX_GOOP = 32;
/*    */   public static final int Boost = 0;
/*    */   public static final int RangeEx = 1;
/*    */   public static final int RangeIn = 2;
/*    */   public static final int DEFAULT = 3;
/* 44 */   public static final String[] tokenImage = new String[] { ""<EOF>"", ""<_NUM_CHAR>"", ""<_ESCAPED_CHAR>"", ""<_TERM_START_CHAR>"", ""<_TERM_CHAR>"", ""<_WHITESPACE>"", ""<token of kind 6>"", ""<AND>"", ""<OR>"", ""<NOT>"", ""\""+\"""", ""\""-\"""", ""\""(\"""", ""\"")\"""", ""\"":\"""", ""\""*\"""", ""\""^\"""", ""<QUOTED>"", ""<TERM>"", ""<FUZZY_SLOP>"", ""<PREFIXTERM>"", ""<WILDTERM>"", ""\""[\"""", ""\""{\"""", ""<NUMBER>"", ""\""TO\"""", ""\""]\"""", ""<RANGEIN_QUOTED>"", ""<RANGEIN_GOOP>"", ""\""TO\"""", ""\""}\"""", ""<RANGEEX_QUOTED>"", ""<RANGEEX_GOOP>"" };
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\QueryParserConstants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.QueryParserTokenManager,"/*      */ package org.apache.lucene.queryParser;
/*      */ 
/*      */ import java.io.IOException;
/*      */ import java.io.PrintStream;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ public class QueryParserTokenManager
/*      */   implements QueryParserConstants
/*      */ {
/*   15 */   public PrintStream debugStream = System.out;
/*   16 */   public void setDebugStream(PrintStream ds) { this.debugStream = ds; }
/*      */   
/*      */   private final int jjStopStringLiteralDfa_3(int pos, long active0) {
/*   19 */     switch (pos) {
/*      */     
/*      */     } 
/*   22 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*   27 */   private final int jjStartNfa_3(int pos, long active0) { return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private final int jjStopAtPos(int pos, int kind) {
/*   31 */     this.jjmatchedKind = kind;
/*   32 */     this.jjmatchedPos = pos;
/*   33 */     return pos + 1;
/*      */   }
/*      */   
/*      */   private final int jjStartNfaWithStates_3(int pos, int kind, int state) {
/*   37 */     this.jjmatchedKind = kind;
/*   38 */     this.jjmatchedPos = pos; 
/*   39 */     try { this.curChar = this.input_stream.readChar(); }
/*   40 */     catch (IOException e) { return pos + 1; }
/*   41 */      return jjMoveNfa_3(state, pos + 1);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa0_3() {
/*   45 */     switch (this.curChar) {
/*      */       
/*      */       case '(':
/*   48 */         return jjStopAtPos(0, 12);
/*      */       case ')':
/*   50 */         return jjStopAtPos(0, 13);
/*      */       case '*':
/*   52 */         return jjStartNfaWithStates_3(0, 15, 36);
/*      */       case '+':
/*   54 */         return jjStopAtPos(0, 10);
/*      */       case '-':
/*   56 */         return jjStopAtPos(0, 11);
/*      */       case ':':
/*   58 */         return jjStopAtPos(0, 14);
/*      */       case '[':
/*   60 */         return jjStopAtPos(0, 22);
/*      */       case '^':
/*   62 */         return jjStopAtPos(0, 16);
/*      */       case '{':
/*   64 */         return jjStopAtPos(0, 23);
/*      */     } 
/*   66 */     return jjMoveNfa_3(0, 0);
/*      */   }
/*      */ 
/*      */   
/*      */   private final void jjCheckNAdd(int state) {
/*   71 */     if (this.jjrounds[state] != this.jjround) {
/*      */       
/*   73 */       this.jjstateSet[this.jjnewStateCnt++] = state;
/*   74 */       this.jjrounds[state] = this.jjround;
/*      */     } 
/*      */   }
/*      */   
/*      */   private final void jjAddStates(int start, int end) {
/*      */     do {
/*   80 */       this.jjstateSet[this.jjnewStateCnt++] = jjnextStates[start];
/*   81 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddTwoStates(int state1, int state2) {
/*   85 */     jjCheckNAdd(state1);
/*   86 */     jjCheckNAdd(state2);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start, int end) {
/*      */     do {
/*   91 */       jjCheckNAdd(jjnextStates[start]);
/*   92 */     } while (start++ != end);
/*      */   }
/*      */   
/*      */   private final void jjCheckNAddStates(int start) {
/*   96 */     jjCheckNAdd(jjnextStates[start]);
/*   97 */     jjCheckNAdd(jjnextStates[start + 1]);
/*      */   }
/*   99 */   static final long[] jjbitVec0 = new long[] { -2L, -1L, -1L, -1L };
/*      */ 
/*      */   
/*  102 */   static final long[] jjbitVec2 = new long[] { 0L, 0L, -1L, -1L };
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_3(int startState, int curPos) {
/*  108 */     int startsAt = 0;
/*  109 */     this.jjnewStateCnt = 36;
/*  110 */     int i = 1;
/*  111 */     this.jjstateSet[0] = startState;
/*  112 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  115 */       if (++this.jjround == Integer.MAX_VALUE)
/*  116 */         ReInitRounds(); 
/*  117 */       if (this.curChar < '@') {
/*      */         
/*  119 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  122 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 25:
/*      */             case 36:
/*  126 */               if ((0xFBFFFCF8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  128 */               if (kind > 21)
/*  129 */                 kind = 21; 
/*  130 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 0:
/*  133 */               if ((0xFBFFD4F8FFFFD9FFL & l) != 0L) {
/*      */                 
/*  135 */                 if (kind > 21)
/*  136 */                   kind = 21; 
/*  137 */                 jjCheckNAddTwoStates(25, 26);
/*      */               }
/*  139 */               else if ((0x100002600L & l) != 0L) {
/*      */                 
/*  141 */                 if (kind > 6) {
/*  142 */                   kind = 6;
/*      */                 }
/*  144 */               } else if (this.curChar == '""') {
/*  145 */                 jjCheckNAddTwoStates(15, 17);
/*  146 */               } else if (this.curChar == '!') {
/*      */                 
/*  148 */                 if (kind > 9)
/*  149 */                   kind = 9; 
/*      */               } 
/*  151 */               if ((0x7BFFD0F8FFFFD9FFL & l) != 0L) {
/*      */                 
/*  153 */                 if (kind > 18)
/*  154 */                   kind = 18; 
/*  155 */                 jjCheckNAddStates(0, 4);
/*      */               }
/*  157 */               else if (this.curChar == '*') {
/*      */                 
/*  159 */                 if (kind > 20)
/*  160 */                   kind = 20; 
/*      */               } 
/*  162 */               if (this.curChar == '&')
/*  163 */                 this.jjstateSet[this.jjnewStateCnt++] = 4; 
/*      */               break;
/*      */             case 4:
/*  166 */               if (this.curChar == '&' && kind > 7)
/*  167 */                 kind = 7; 
/*      */               break;
/*      */             case 5:
/*  170 */               if (this.curChar == '&')
/*  171 */                 this.jjstateSet[this.jjnewStateCnt++] = 4; 
/*      */               break;
/*      */             case 13:
/*  174 */               if (this.curChar == '!' && kind > 9)
/*  175 */                 kind = 9; 
/*      */               break;
/*      */             case 14:
/*  178 */               if (this.curChar == '""')
/*  179 */                 jjCheckNAddTwoStates(15, 17); 
/*      */               break;
/*      */             case 15:
/*  182 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  183 */                 jjCheckNAddStates(5, 7); 
/*      */               break;
/*      */             case 16:
/*  186 */               if (this.curChar == '""')
/*  187 */                 jjCheckNAddStates(5, 7); 
/*      */               break;
/*      */             case 18:
/*  190 */               if (this.curChar == '""' && kind > 17)
/*  191 */                 kind = 17; 
/*      */               break;
/*      */             case 20:
/*  194 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  196 */               if (kind > 19)
/*  197 */                 kind = 19; 
/*  198 */               jjAddStates(8, 9);
/*      */               break;
/*      */             case 21:
/*  201 */               if (this.curChar == '.')
/*  202 */                 jjCheckNAdd(22); 
/*      */               break;
/*      */             case 22:
/*  205 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  207 */               if (kind > 19)
/*  208 */                 kind = 19; 
/*  209 */               jjCheckNAdd(22);
/*      */               break;
/*      */             case 23:
/*  212 */               if (this.curChar == '*' && kind > 20)
/*  213 */                 kind = 20; 
/*      */               break;
/*      */             case 24:
/*  216 */               if ((0xFBFFD4F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  218 */               if (kind > 21)
/*  219 */                 kind = 21; 
/*  220 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 27:
/*  223 */               if (kind > 21)
/*  224 */                 kind = 21; 
/*  225 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 28:
/*  228 */               if ((0x7BFFD0F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  230 */               if (kind > 18)
/*  231 */                 kind = 18; 
/*  232 */               jjCheckNAddStates(0, 4);
/*      */               break;
/*      */             case 29:
/*  235 */               if ((0x7BFFF8F8FFFFD9FFL & l) == 0L)
/*      */                 break; 
/*  237 */               if (kind > 18)
/*  238 */                 kind = 18; 
/*  239 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 31:
/*  242 */               if (kind > 18)
/*  243 */                 kind = 18; 
/*  244 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 32:
/*  247 */               if ((0x7BFFF8F8FFFFD9FFL & l) != 0L)
/*  248 */                 jjCheckNAddStates(10, 12); 
/*      */               break;
/*      */             case 34:
/*  251 */               jjCheckNAddStates(10, 12);
/*      */               break;
/*      */           } 
/*      */         
/*  255 */         } while (i != startsAt);
/*      */       }
/*  257 */       else if (this.curChar < '') {
/*      */         
/*  259 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  262 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 36:
/*  265 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L) {
/*      */                 
/*  267 */                 if (kind > 21)
/*  268 */                   kind = 21; 
/*  269 */                 jjCheckNAddTwoStates(25, 26); break;
/*      */               } 
/*  271 */               if (this.curChar == '\\')
/*  272 */                 jjCheckNAddTwoStates(27, 27); 
/*      */               break;
/*      */             case 0:
/*  275 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L) {
/*      */                 
/*  277 */                 if (kind > 18)
/*  278 */                   kind = 18; 
/*  279 */                 jjCheckNAddStates(0, 4);
/*      */               }
/*  281 */               else if (this.curChar == '\\') {
/*  282 */                 jjCheckNAddStates(13, 15);
/*  283 */               } else if (this.curChar == '~') {
/*      */                 
/*  285 */                 if (kind > 19)
/*  286 */                   kind = 19; 
/*  287 */                 this.jjstateSet[this.jjnewStateCnt++] = 20;
/*      */               } 
/*  289 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L) {
/*      */                 
/*  291 */                 if (kind > 21)
/*  292 */                   kind = 21; 
/*  293 */                 jjCheckNAddTwoStates(25, 26);
/*      */               } 
/*  295 */               if (this.curChar == 'N') {
/*  296 */                 this.jjstateSet[this.jjnewStateCnt++] = 11; break;
/*  297 */               }  if (this.curChar == '|') {
/*  298 */                 this.jjstateSet[this.jjnewStateCnt++] = 8; break;
/*  299 */               }  if (this.curChar == 'O') {
/*  300 */                 this.jjstateSet[this.jjnewStateCnt++] = 6; break;
/*  301 */               }  if (this.curChar == 'A')
/*  302 */                 this.jjstateSet[this.jjnewStateCnt++] = 2; 
/*      */               break;
/*      */             case 1:
/*  305 */               if (this.curChar == 'D' && kind > 7)
/*  306 */                 kind = 7; 
/*      */               break;
/*      */             case 2:
/*  309 */               if (this.curChar == 'N')
/*  310 */                 this.jjstateSet[this.jjnewStateCnt++] = 1; 
/*      */               break;
/*      */             case 3:
/*  313 */               if (this.curChar == 'A')
/*  314 */                 this.jjstateSet[this.jjnewStateCnt++] = 2; 
/*      */               break;
/*      */             case 6:
/*  317 */               if (this.curChar == 'R' && kind > 8)
/*  318 */                 kind = 8; 
/*      */               break;
/*      */             case 7:
/*  321 */               if (this.curChar == 'O')
/*  322 */                 this.jjstateSet[this.jjnewStateCnt++] = 6; 
/*      */               break;
/*      */             case 8:
/*  325 */               if (this.curChar == '|' && kind > 8)
/*  326 */                 kind = 8; 
/*      */               break;
/*      */             case 9:
/*  329 */               if (this.curChar == '|')
/*  330 */                 this.jjstateSet[this.jjnewStateCnt++] = 8; 
/*      */               break;
/*      */             case 10:
/*  333 */               if (this.curChar == 'T' && kind > 9)
/*  334 */                 kind = 9; 
/*      */               break;
/*      */             case 11:
/*  337 */               if (this.curChar == 'O')
/*  338 */                 this.jjstateSet[this.jjnewStateCnt++] = 10; 
/*      */               break;
/*      */             case 12:
/*  341 */               if (this.curChar == 'N')
/*  342 */                 this.jjstateSet[this.jjnewStateCnt++] = 11; 
/*      */               break;
/*      */             case 15:
/*  345 */               jjAddStates(5, 7);
/*      */               break;
/*      */             case 17:
/*  348 */               if (this.curChar == '\\')
/*  349 */                 this.jjstateSet[this.jjnewStateCnt++] = 16; 
/*      */               break;
/*      */             case 19:
/*  352 */               if (this.curChar != '~')
/*      */                 break; 
/*  354 */               if (kind > 19)
/*  355 */                 kind = 19; 
/*  356 */               this.jjstateSet[this.jjnewStateCnt++] = 20;
/*      */               break;
/*      */             case 24:
/*  359 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  361 */               if (kind > 21)
/*  362 */                 kind = 21; 
/*  363 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 25:
/*  366 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  368 */               if (kind > 21)
/*  369 */                 kind = 21; 
/*  370 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 26:
/*  373 */               if (this.curChar == '\\')
/*  374 */                 jjCheckNAddTwoStates(27, 27); 
/*      */               break;
/*      */             case 27:
/*  377 */               if (kind > 21)
/*  378 */                 kind = 21; 
/*  379 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 28:
/*  382 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  384 */               if (kind > 18)
/*  385 */                 kind = 18; 
/*  386 */               jjCheckNAddStates(0, 4);
/*      */               break;
/*      */             case 29:
/*  389 */               if ((0x97FFFFFF87FFFFFFL & l) == 0L)
/*      */                 break; 
/*  391 */               if (kind > 18)
/*  392 */                 kind = 18; 
/*  393 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 30:
/*  396 */               if (this.curChar == '\\')
/*  397 */                 jjCheckNAddTwoStates(31, 31); 
/*      */               break;
/*      */             case 31:
/*  400 */               if (kind > 18)
/*  401 */                 kind = 18; 
/*  402 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 32:
/*  405 */               if ((0x97FFFFFF87FFFFFFL & l) != 0L)
/*  406 */                 jjCheckNAddStates(10, 12); 
/*      */               break;
/*      */             case 33:
/*  409 */               if (this.curChar == '\\')
/*  410 */                 jjCheckNAddTwoStates(34, 34); 
/*      */               break;
/*      */             case 34:
/*  413 */               jjCheckNAddStates(10, 12);
/*      */               break;
/*      */             case 35:
/*  416 */               if (this.curChar == '\\') {
/*  417 */                 jjCheckNAddStates(13, 15);
/*      */               }
/*      */               break;
/*      */           } 
/*  421 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  425 */         int hiByte = this.curChar >> 8;
/*  426 */         int i1 = hiByte >> 6;
/*  427 */         long l1 = 1L << (hiByte & 0x3F);
/*  428 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  429 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  432 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 25:
/*      */             case 27:
/*      */             case 36:
/*  437 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  439 */               if (kind > 21)
/*  440 */                 kind = 21; 
/*  441 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 0:
/*  444 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*      */                 
/*  446 */                 if (kind > 21)
/*  447 */                   kind = 21; 
/*  448 */                 jjCheckNAddTwoStates(25, 26);
/*      */               } 
/*  450 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*      */                 
/*  452 */                 if (kind > 18)
/*  453 */                   kind = 18; 
/*  454 */                 jjCheckNAddStates(0, 4);
/*      */               } 
/*      */               break;
/*      */             case 15:
/*  458 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2))
/*  459 */                 jjAddStates(5, 7); 
/*      */               break;
/*      */             case 24:
/*  462 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  464 */               if (kind > 21)
/*  465 */                 kind = 21; 
/*  466 */               jjCheckNAddTwoStates(25, 26);
/*      */               break;
/*      */             case 28:
/*  469 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  471 */               if (kind > 18)
/*  472 */                 kind = 18; 
/*  473 */               jjCheckNAddStates(0, 4);
/*      */               break;
/*      */             case 29:
/*      */             case 31:
/*  477 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  479 */               if (kind > 18)
/*  480 */                 kind = 18; 
/*  481 */               jjCheckNAddTwoStates(29, 30);
/*      */               break;
/*      */             case 32:
/*      */             case 34:
/*  485 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  486 */                 jjCheckNAddStates(10, 12);
/*      */               }
/*      */               break;
/*      */           } 
/*  490 */         } while (i != startsAt);
/*      */       } 
/*  492 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  494 */         this.jjmatchedKind = kind;
/*  495 */         this.jjmatchedPos = curPos;
/*  496 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  498 */       curPos++;
/*  499 */       if ((i = this.jjnewStateCnt) == (startsAt = 36 - (this.jjnewStateCnt = startsAt)))
/*  500 */         return curPos;  
/*  501 */       try { this.curChar = this.input_stream.readChar(); }
/*  502 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   private final int jjStopStringLiteralDfa_1(int pos, long active0) {
/*  507 */     switch (pos) {
/*      */       
/*      */       case 0:
/*  510 */         if ((active0 & 0x20000000L) != 0L) {
/*      */           
/*  512 */           this.jjmatchedKind = 32;
/*  513 */           return 6;
/*      */         } 
/*  515 */         return -1;
/*      */     } 
/*  517 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  522 */   private final int jjStartNfa_1(int pos, long active0) { return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private final int jjStartNfaWithStates_1(int pos, int kind, int state) {
/*  526 */     this.jjmatchedKind = kind;
/*  527 */     this.jjmatchedPos = pos; 
/*  528 */     try { this.curChar = this.input_stream.readChar(); }
/*  529 */     catch (IOException e) { return pos + 1; }
/*  530 */      return jjMoveNfa_1(state, pos + 1);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa0_1() {
/*  534 */     switch (this.curChar) {
/*      */       
/*      */       case 'T':
/*  537 */         return jjMoveStringLiteralDfa1_1(536870912L);
/*      */       case '}':
/*  539 */         return jjStopAtPos(0, 30);
/*      */     } 
/*  541 */     return jjMoveNfa_1(0, 0);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa1_1(long active0) {
/*      */     try {
/*  546 */       this.curChar = this.input_stream.readChar();
/*  547 */     } catch (IOException e) {
/*  548 */       jjStopStringLiteralDfa_1(0, active0);
/*  549 */       return 1;
/*      */     } 
/*  551 */     switch (this.curChar) {
/*      */       
/*      */       case 'O':
/*  554 */         if ((active0 & 0x20000000L) != 0L) {
/*  555 */           return jjStartNfaWithStates_1(1, 29, 6);
/*      */         }
/*      */         break;
/*      */     } 
/*      */     
/*  560 */     return jjStartNfa_1(0, active0);
/*      */   }
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_1(int startState, int curPos) {
/*  565 */     int startsAt = 0;
/*  566 */     this.jjnewStateCnt = 7;
/*  567 */     int i = 1;
/*  568 */     this.jjstateSet[0] = startState;
/*  569 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  572 */       if (++this.jjround == Integer.MAX_VALUE)
/*  573 */         ReInitRounds(); 
/*  574 */       if (this.curChar < '@') {
/*      */         
/*  576 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  579 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  582 */               if ((0xFFFFFFFEFFFFFFFFL & l) != 0L) {
/*      */                 
/*  584 */                 if (kind > 32)
/*  585 */                   kind = 32; 
/*  586 */                 jjCheckNAdd(6);
/*      */               } 
/*  588 */               if ((0x100002600L & l) != 0L) {
/*      */                 
/*  590 */                 if (kind > 6)
/*  591 */                   kind = 6;  break;
/*      */               } 
/*  593 */               if (this.curChar == '""')
/*  594 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 1:
/*  597 */               if (this.curChar == '""')
/*  598 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 2:
/*  601 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  602 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 3:
/*  605 */               if (this.curChar == '""')
/*  606 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 5:
/*  609 */               if (this.curChar == '""' && kind > 31)
/*  610 */                 kind = 31; 
/*      */               break;
/*      */             case 6:
/*  613 */               if ((0xFFFFFFFEFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  615 */               if (kind > 32)
/*  616 */                 kind = 32; 
/*  617 */               jjCheckNAdd(6);
/*      */               break;
/*      */           } 
/*      */         
/*  621 */         } while (i != startsAt);
/*      */       }
/*  623 */       else if (this.curChar < '') {
/*      */         
/*  625 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  628 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  632 */               if ((0xDFFFFFFFFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  634 */               if (kind > 32)
/*  635 */                 kind = 32; 
/*  636 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  639 */               jjAddStates(16, 18);
/*      */               break;
/*      */             case 4:
/*  642 */               if (this.curChar == '\\') {
/*  643 */                 this.jjstateSet[this.jjnewStateCnt++] = 3;
/*      */               }
/*      */               break;
/*      */           } 
/*  647 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  651 */         int hiByte = this.curChar >> 8;
/*  652 */         int i1 = hiByte >> 6;
/*  653 */         long l1 = 1L << (hiByte & 0x3F);
/*  654 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  655 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  658 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  662 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  664 */               if (kind > 32)
/*  665 */                 kind = 32; 
/*  666 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  669 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  670 */                 jjAddStates(16, 18);
/*      */               }
/*      */               break;
/*      */           } 
/*  674 */         } while (i != startsAt);
/*      */       } 
/*  676 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  678 */         this.jjmatchedKind = kind;
/*  679 */         this.jjmatchedPos = curPos;
/*  680 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  682 */       curPos++;
/*  683 */       if ((i = this.jjnewStateCnt) == (startsAt = 7 - (this.jjnewStateCnt = startsAt)))
/*  684 */         return curPos;  
/*  685 */       try { this.curChar = this.input_stream.readChar(); }
/*  686 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   
/*  691 */   private final int jjMoveStringLiteralDfa0_0() { return jjMoveNfa_0(0, 0); }
/*      */ 
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_0(int startState, int curPos) {
/*  696 */     int startsAt = 0;
/*  697 */     this.jjnewStateCnt = 3;
/*  698 */     int i = 1;
/*  699 */     this.jjstateSet[0] = startState;
/*  700 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  703 */       if (++this.jjround == Integer.MAX_VALUE)
/*  704 */         ReInitRounds(); 
/*  705 */       if (this.curChar < '@') {
/*      */         
/*  707 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  710 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  713 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  715 */               if (kind > 24)
/*  716 */                 kind = 24; 
/*  717 */               jjAddStates(19, 20);
/*      */               break;
/*      */             case 1:
/*  720 */               if (this.curChar == '.')
/*  721 */                 jjCheckNAdd(2); 
/*      */               break;
/*      */             case 2:
/*  724 */               if ((0x3FF000000000000L & l) == 0L)
/*      */                 break; 
/*  726 */               if (kind > 24)
/*  727 */                 kind = 24; 
/*  728 */               jjCheckNAdd(2);
/*      */               break;
/*      */           } 
/*      */         
/*  732 */         } while (i != startsAt);
/*      */       }
/*  734 */       else if (this.curChar < '') {
/*      */         
/*  736 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  739 */           switch (this.jjstateSet[--i]) {
/*      */           
/*      */           } 
/*      */         
/*  743 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  747 */         int hiByte = this.curChar >> 8;
/*  748 */         int i1 = hiByte >> 6;
/*  749 */         long l1 = 1L << (hiByte & 0x3F);
/*  750 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  751 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  754 */           switch (this.jjstateSet[--i]) {
/*      */           
/*      */           } 
/*      */         
/*  758 */         } while (i != startsAt);
/*      */       } 
/*  760 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  762 */         this.jjmatchedKind = kind;
/*  763 */         this.jjmatchedPos = curPos;
/*  764 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  766 */       curPos++;
/*  767 */       if ((i = this.jjnewStateCnt) == (startsAt = 3 - (this.jjnewStateCnt = startsAt)))
/*  768 */         return curPos;  
/*  769 */       try { this.curChar = this.input_stream.readChar(); }
/*  770 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*      */   }
/*      */   private final int jjStopStringLiteralDfa_2(int pos, long active0) {
/*  775 */     switch (pos) {
/*      */       
/*      */       case 0:
/*  778 */         if ((active0 & 0x2000000L) != 0L) {
/*      */           
/*  780 */           this.jjmatchedKind = 28;
/*  781 */           return 6;
/*      */         } 
/*  783 */         return -1;
/*      */     } 
/*  785 */     return -1;
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  790 */   private final int jjStartNfa_2(int pos, long active0) { return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1); }
/*      */ 
/*      */   
/*      */   private final int jjStartNfaWithStates_2(int pos, int kind, int state) {
/*  794 */     this.jjmatchedKind = kind;
/*  795 */     this.jjmatchedPos = pos; 
/*  796 */     try { this.curChar = this.input_stream.readChar(); }
/*  797 */     catch (IOException e) { return pos + 1; }
/*  798 */      return jjMoveNfa_2(state, pos + 1);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa0_2() {
/*  802 */     switch (this.curChar) {
/*      */       
/*      */       case 'T':
/*  805 */         return jjMoveStringLiteralDfa1_2(33554432L);
/*      */       case ']':
/*  807 */         return jjStopAtPos(0, 26);
/*      */     } 
/*  809 */     return jjMoveNfa_2(0, 0);
/*      */   }
/*      */   
/*      */   private final int jjMoveStringLiteralDfa1_2(long active0) {
/*      */     try {
/*  814 */       this.curChar = this.input_stream.readChar();
/*  815 */     } catch (IOException e) {
/*  816 */       jjStopStringLiteralDfa_2(0, active0);
/*  817 */       return 1;
/*      */     } 
/*  819 */     switch (this.curChar) {
/*      */       
/*      */       case 'O':
/*  822 */         if ((active0 & 0x2000000L) != 0L) {
/*  823 */           return jjStartNfaWithStates_2(1, 25, 6);
/*      */         }
/*      */         break;
/*      */     } 
/*      */     
/*  828 */     return jjStartNfa_2(0, active0);
/*      */   }
/*      */ 
/*      */   
/*      */   private final int jjMoveNfa_2(int startState, int curPos) {
/*  833 */     int startsAt = 0;
/*  834 */     this.jjnewStateCnt = 7;
/*  835 */     int i = 1;
/*  836 */     this.jjstateSet[0] = startState;
/*  837 */     int kind = Integer.MAX_VALUE;
/*      */     
/*      */     while (true) {
/*  840 */       if (++this.jjround == Integer.MAX_VALUE)
/*  841 */         ReInitRounds(); 
/*  842 */       if (this.curChar < '@') {
/*      */         
/*  844 */         long l = 1L << this.curChar;
/*      */         
/*      */         do {
/*  847 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*  850 */               if ((0xFFFFFFFEFFFFFFFFL & l) != 0L) {
/*      */                 
/*  852 */                 if (kind > 28)
/*  853 */                   kind = 28; 
/*  854 */                 jjCheckNAdd(6);
/*      */               } 
/*  856 */               if ((0x100002600L & l) != 0L) {
/*      */                 
/*  858 */                 if (kind > 6)
/*  859 */                   kind = 6;  break;
/*      */               } 
/*  861 */               if (this.curChar == '""')
/*  862 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 1:
/*  865 */               if (this.curChar == '""')
/*  866 */                 jjCheckNAddTwoStates(2, 4); 
/*      */               break;
/*      */             case 2:
/*  869 */               if ((0xFFFFFFFBFFFFFFFFL & l) != 0L)
/*  870 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 3:
/*  873 */               if (this.curChar == '""')
/*  874 */                 jjCheckNAddStates(16, 18); 
/*      */               break;
/*      */             case 5:
/*  877 */               if (this.curChar == '""' && kind > 27)
/*  878 */                 kind = 27; 
/*      */               break;
/*      */             case 6:
/*  881 */               if ((0xFFFFFFFEFFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  883 */               if (kind > 28)
/*  884 */                 kind = 28; 
/*  885 */               jjCheckNAdd(6);
/*      */               break;
/*      */           } 
/*      */         
/*  889 */         } while (i != startsAt);
/*      */       }
/*  891 */       else if (this.curChar < '') {
/*      */         
/*  893 */         long l = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  896 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  900 */               if ((0xFFFFFFFFDFFFFFFFL & l) == 0L)
/*      */                 break; 
/*  902 */               if (kind > 28)
/*  903 */                 kind = 28; 
/*  904 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  907 */               jjAddStates(16, 18);
/*      */               break;
/*      */             case 4:
/*  910 */               if (this.curChar == '\\') {
/*  911 */                 this.jjstateSet[this.jjnewStateCnt++] = 3;
/*      */               }
/*      */               break;
/*      */           } 
/*  915 */         } while (i != startsAt);
/*      */       }
/*      */       else {
/*      */         
/*  919 */         int hiByte = this.curChar >> 8;
/*  920 */         int i1 = hiByte >> 6;
/*  921 */         long l1 = 1L << (hiByte & 0x3F);
/*  922 */         int i2 = (this.curChar & 0xFF) >> 6;
/*  923 */         long l2 = 1L << (this.curChar & 0x3F);
/*      */         
/*      */         do {
/*  926 */           switch (this.jjstateSet[--i]) {
/*      */             
/*      */             case 0:
/*      */             case 6:
/*  930 */               if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
/*      */                 break; 
/*  932 */               if (kind > 28)
/*  933 */                 kind = 28; 
/*  934 */               jjCheckNAdd(6);
/*      */               break;
/*      */             case 2:
/*  937 */               if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
/*  938 */                 jjAddStates(16, 18);
/*      */               }
/*      */               break;
/*      */           } 
/*  942 */         } while (i != startsAt);
/*      */       } 
/*  944 */       if (kind != Integer.MAX_VALUE) {
/*      */         
/*  946 */         this.jjmatchedKind = kind;
/*  947 */         this.jjmatchedPos = curPos;
/*  948 */         kind = Integer.MAX_VALUE;
/*      */       } 
/*  950 */       curPos++;
/*  951 */       if ((i = this.jjnewStateCnt) == (startsAt = 7 - (this.jjnewStateCnt = startsAt)))
/*  952 */         return curPos;  
/*  953 */       try { this.curChar = this.input_stream.readChar(); }
/*  954 */       catch (IOException e) { return curPos; }
/*      */     
/*      */     } 
/*  957 */   } static final int[] jjnextStates = new int[] { 29, 32, 23, 33, 30, 15, 17, 18, 20, 21, 32, 23, 33, 31, 34, 27, 2, 4, 5, 0, 1 };
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
/*  963 */     switch (hiByte) {
/*      */       
/*      */       case 0:
/*  966 */         return ((jjbitVec2[i2] & l2) != 0L);
/*      */     } 
/*  968 */     if ((jjbitVec0[i1] & l1) != 0L)
/*  969 */       return true; 
/*  970 */     return false;
/*      */   }
/*      */   
/*  973 */   public static final String[] jjstrLiteralImages = new String[] { """", null, null, null, null, null, null, null, null, null, ""+"", ""-"", ""("", "")"", "":"", ""*"", ""^"", null, null, null, null, null, ""["", ""{"", null, ""TO"", ""]"", null, null, ""TO"", ""}"", null, null };
/*      */ 
/*      */ 
/*      */   
/*  977 */   public static final String[] lexStateNames = new String[] { ""Boost"", ""RangeEx"", ""RangeIn"", ""DEFAULT"" };
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  983 */   public static final int[] jjnewLexState = new int[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 3, -1, 3, -1, -1, -1, 3, -1, -1 };
/*      */ 
/*      */ 
/*      */   
/*  987 */   static final long[] jjtoToken = new long[] { 8589934465L };
/*      */ 
/*      */   
/*  990 */   static final long[] jjtoSkip = new long[] { 64L };
/*      */   
/*      */   protected CharStream input_stream;
/*      */   
/*  994 */   private final int[] jjrounds = new int[36];
/*  995 */   private final int[] jjstateSet = new int[72]; protected char curChar; int curLexState;
/*      */   int defaultLexState;
/*      */   int jjnewStateCnt;
/*      */   int jjround;
/*      */   int jjmatchedPos;
/*      */   int jjmatchedKind;
/*      */   
/*      */   public QueryParserTokenManager(CharStream stream, int lexState) {
/* 1003 */     this(stream);
/* 1004 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream) {
/* 1008 */     this.jjmatchedPos = this.jjnewStateCnt = 0;
/* 1009 */     this.curLexState = this.defaultLexState;
/* 1010 */     this.input_stream = stream;
/* 1011 */     ReInitRounds();
/*      */   }
/*      */ 
/*      */   
/*      */   private final void ReInitRounds() {
/* 1016 */     this.jjround = -2147483647;
/* 1017 */     for (int i = 36; i-- > 0;)
/* 1018 */       this.jjrounds[i] = Integer.MIN_VALUE; 
/*      */   }
/*      */   
/*      */   public void ReInit(CharStream stream, int lexState) {
/* 1022 */     ReInit(stream);
/* 1023 */     SwitchTo(lexState);
/*      */   }
/*      */   
/*      */   public void SwitchTo(int lexState) {
/* 1027 */     if (lexState >= 4 || lexState < 0) {
/* 1028 */       throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", 2);
/*      */     }
/* 1030 */     this.curLexState = lexState;
/*      */   }
/*      */ 
/*      */   
/*      */   protected Token jjFillToken() {
/* 1035 */     Token t = Token.newToken(this.jjmatchedKind);
/* 1036 */     t.kind = this.jjmatchedKind;
/* 1037 */     String im = jjstrLiteralImages[this.jjmatchedKind];
/* 1038 */     t.image = (im == null) ? this.input_stream.GetImage() : im;
/* 1039 */     t.beginLine = this.input_stream.getBeginLine();
/* 1040 */     t.beginColumn = this.input_stream.getBeginColumn();
/* 1041 */     t.endLine = this.input_stream.getEndLine();
/* 1042 */     t.endColumn = this.input_stream.getEndColumn();
/* 1043 */     return t;
/*      */   }
/*      */   public QueryParserTokenManager(CharStream stream) {
/* 1046 */     this.curLexState = 3;
/* 1047 */     this.defaultLexState = 3;
/*      */     this.input_stream = stream;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public Token getNextToken() {
/* 1056 */     Token specialToken = null;
/*      */     
/* 1058 */     int curPos = 0;
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*      */     while (true) {
/*      */       try {
/* 1065 */         this.curChar = this.input_stream.BeginToken();
/*      */       }
/* 1067 */       catch (IOException e) {
/*      */         
/* 1069 */         this.jjmatchedKind = 0;
/* 1070 */         Token matchedToken = jjFillToken();
/* 1071 */         return matchedToken;
/*      */       } 
/*      */       
/* 1074 */       switch (this.curLexState) {
/*      */         
/*      */         case 0:
/* 1077 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1078 */           this.jjmatchedPos = 0;
/* 1079 */           curPos = jjMoveStringLiteralDfa0_0();
/*      */           break;
/*      */         case 1:
/* 1082 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1083 */           this.jjmatchedPos = 0;
/* 1084 */           curPos = jjMoveStringLiteralDfa0_1();
/*      */           break;
/*      */         case 2:
/* 1087 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1088 */           this.jjmatchedPos = 0;
/* 1089 */           curPos = jjMoveStringLiteralDfa0_2();
/*      */           break;
/*      */         case 3:
/* 1092 */           this.jjmatchedKind = Integer.MAX_VALUE;
/* 1093 */           this.jjmatchedPos = 0;
/* 1094 */           curPos = jjMoveStringLiteralDfa0_3();
/*      */           break;
/*      */       } 
/* 1097 */       if (this.jjmatchedKind != Integer.MAX_VALUE) {
/*      */         
/* 1099 */         if (this.jjmatchedPos + 1 < curPos)
/* 1100 */           this.input_stream.backup(curPos - this.jjmatchedPos - 1); 
/* 1101 */         if ((jjtoToken[this.jjmatchedKind >> 6] & 1L << (this.jjmatchedKind & 0x3F)) != 0L) {
/*      */           
/* 1103 */           Token matchedToken = jjFillToken();
/* 1104 */           if (jjnewLexState[this.jjmatchedKind] != -1)
/* 1105 */             this.curLexState = jjnewLexState[this.jjmatchedKind]; 
/* 1106 */           return matchedToken;
/*      */         } 
/*      */ 
/*      */         
/* 1110 */         if (jjnewLexState[this.jjmatchedKind] != -1)
/* 1111 */           this.curLexState = jjnewLexState[this.jjmatchedKind];  continue;
/*      */       } 
/*      */       break;
/*      */     } 
/* 1115 */     int error_line = this.input_stream.getEndLine();
/* 1116 */     int error_column = this.input_stream.getEndColumn();
/* 1117 */     String error_after = null;
/* 1118 */     boolean EOFSeen = false; try {
/* 1119 */       this.input_stream.readChar(); this.input_stream.backup(1);
/* 1120 */     } catch (IOException e1) {
/* 1121 */       EOFSeen = true;
/* 1122 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/* 1123 */       if (this.curChar == '\n' || this.curChar == '\r') {
/* 1124 */         error_line++;
/* 1125 */         error_column = 0;
/*      */       } else {
/*      */         
/* 1128 */         error_column++;
/*      */       } 
/* 1130 */     }  if (!EOFSeen) {
/* 1131 */       this.input_stream.backup(1);
/* 1132 */       error_after = (curPos <= 1) ? """" : this.input_stream.GetImage();
/*      */     } 
/* 1134 */     throw new TokenMgrError(EOFSeen, this.curLexState, error_line, error_column, error_after, this.curChar, 0);
/*      */   }
/*      */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\QueryParserTokenManager.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.Token,"/*    */ package org.apache.lucene.queryParser;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class Token
/*    */ {
/*    */   public int kind;
/*    */   public int beginLine;
/*    */   public int beginColumn;
/*    */   public int endLine;
/*    */   public int endColumn;
/*    */   public String image;
/*    */   public Token next;
/*    */   public Token specialToken;
/*    */   
/* 58 */   public String toString() { return this.image; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public static final Token newToken(int ofKind) {
/* 75 */     switch (ofKind) {
/*    */     
/* 77 */     }  return new Token();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\Token.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.queryParser.TokenMgrError,"/*     */ package org.apache.lucene.queryParser;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TokenMgrError
/*     */   extends Error
/*     */ {
/*     */   static final int LEXICAL_ERROR = 0;
/*     */   static final int STATIC_LEXER_ERROR = 1;
/*     */   static final int INVALID_LEXICAL_STATE = 2;
/*     */   static final int LOOP_DETECTED = 3;
/*     */   int errorCode;
/*     */   
/*     */   protected static final String addEscapes(String str) {
/*  41 */     StringBuffer retval = new StringBuffer();
/*     */     
/*  43 */     for (int i = 0; i < str.length(); i++) {
/*  44 */       char ch; switch (str.charAt(i)) {
/*     */         case '\000':
/*     */           break;
/*     */         
/*     */         case '\b':
/*  49 */           retval.append(""\\b"");
/*     */           break;
/*     */         case '\t':
/*  52 */           retval.append(""\\t"");
/*     */           break;
/*     */         case '\n':
/*  55 */           retval.append(""\\n"");
/*     */           break;
/*     */         case '\f':
/*  58 */           retval.append(""\\f"");
/*     */           break;
/*     */         case '\r':
/*  61 */           retval.append(""\\r"");
/*     */           break;
/*     */         case '""':
/*  64 */           retval.append(""\\\"""");
/*     */           break;
/*     */         case '\'':
/*  67 */           retval.append(""\\'"");
/*     */           break;
/*     */         case '\\':
/*  70 */           retval.append(""\\\\"");
/*     */           break;
/*     */         default:
/*  73 */           if ((ch = str.charAt(i)) < ' ' || ch > '~') {
/*  74 */             String s = ""0000"" + Integer.toString(ch, 16);
/*  75 */             retval.append(""\\u"" + s.substring(s.length() - 4, s.length())); break;
/*     */           } 
/*  77 */           retval.append(ch);
/*     */           break;
/*     */       } 
/*     */     
/*     */     } 
/*  82 */     return retval.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) { return ""Lexical error at line "" + errorLine + "", column "" + errorColumn + "".  Encountered: "" + (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""" + "" ("" + curChar + ""), "")) + ""after : \"""" + addEscapes(errorAfter) + ""\""""; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public String getMessage() { return super.getMessage(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError() {}
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TokenMgrError(String message, int reason) {
/* 126 */     super(message);
/* 127 */     this.errorCode = reason;
/*     */   }
/*     */ 
/*     */   
/* 131 */   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) { this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\queryParser\TokenMgrError.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanClause,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.util.Parameter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BooleanClause
/*     */   implements Serializable
/*     */ {
/*     */   private Query query;
/*     */   private Occur occur;
/*     */   
/*     */   public static final class Occur
/*     */     extends Parameter
/*     */     implements Serializable
/*     */   {
/*  30 */     private Occur(String name) { super(name); }
/*     */ 
/*     */     
/*     */     public String toString() {
/*  34 */       if (this == MUST) return ""+""; 
/*  35 */       if (this == MUST_NOT) return ""-""; 
/*  36 */       return """";
/*     */     }
/*     */ 
/*     */     
/*  40 */     public static final Occur MUST = new Occur(""MUST"");
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  47 */     public static final Occur SHOULD = new Occur(""SHOULD"");
/*     */ 
/*     */ 
/*     */     
/*  51 */     public static final Occur MUST_NOT = new Occur(""MUST_NOT"");
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BooleanClause(Query query, Occur occur) {
/*  65 */     this.query = query;
/*  66 */     this.occur = occur;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public Occur getOccur() { return this.occur; }
/*     */ 
/*     */ 
/*     */   
/*  75 */   public void setOccur(Occur occur) { this.occur = occur; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   public Query getQuery() { return this.query; }
/*     */ 
/*     */ 
/*     */   
/*  84 */   public void setQuery(Query query) { this.query = query; }
/*     */ 
/*     */ 
/*     */   
/*  88 */   public boolean isProhibited() { return Occur.MUST_NOT.equals(this.occur); }
/*     */ 
/*     */ 
/*     */   
/*  92 */   public boolean isRequired() { return Occur.MUST.equals(this.occur); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*  99 */     if (!(o instanceof BooleanClause))
/* 100 */       return false; 
/* 101 */     BooleanClause other = (BooleanClause)o;
/* 102 */     return (this.query.equals(other.query) && this.occur.equals(other.occur));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 108 */   public int hashCode() { return this.query.hashCode() ^ (Occur.MUST.equals(this.occur) ? 1 : 0) ^ (Occur.MUST_NOT.equals(this.occur) ? 2 : 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 113 */   public String toString() { return this.occur.toString() + this.query.toString(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\BooleanClause.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BooleanQuery
/*     */   extends Query
/*     */ {
/*  36 */   private static int maxClauseCount = 1024;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static class TooManyClauses
/*     */     extends RuntimeException
/*     */   {
/*  46 */     public String getMessage() { return ""maxClauseCount is set to "" + maxClauseCount; }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public static int getMaxClauseCount() { return maxClauseCount; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void setMaxClauseCount(int maxClauseCount) {
/*  71 */     if (maxClauseCount < 1)
/*  72 */       throw new IllegalArgumentException(""maxClauseCount must be >= 1""); 
/*  73 */     BooleanQuery.maxClauseCount = maxClauseCount;
/*     */   }
/*     */   
/*  76 */   private ArrayList clauses = new ArrayList();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean disableCoord;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected int minNrShouldMatch;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  99 */   public boolean isCoordDisabled() { return this.disableCoord; }
/*     */ 
/*     */ 
/*     */   
/*     */   public Similarity getSimilarity(Searcher searcher) {
/* 104 */     Similarity result = super.getSimilarity(searcher);
/* 105 */     if (this.disableCoord) {
/* 106 */       result = new SimilarityDelegator(result) { private final BooleanQuery this$0;
/*     */           
/* 108 */           public float coord(int overlap, int maxOverlap) { return 1.0F; }
/*     */            }
/*     */         ;
/*     */     }
/* 112 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 138 */   public void setMinimumNumberShouldMatch(int min) { this.minNrShouldMatch = min; }
/*     */   
/* 140 */   public BooleanQuery() { this.minNrShouldMatch = 0; } public BooleanQuery(boolean disableCoord) { this.minNrShouldMatch = 0;
/*     */     this.disableCoord = disableCoord; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 147 */   public int getMinimumNumberShouldMatch() { return this.minNrShouldMatch; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 156 */   public void add(Query query, BooleanClause.Occur occur) { add(new BooleanClause(query, occur)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(BooleanClause clause) {
/* 164 */     if (this.clauses.size() >= maxClauseCount) {
/* 165 */       throw new TooManyClauses();
/*     */     }
/* 167 */     this.clauses.add(clause);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 172 */   public BooleanClause[] getClauses() { return (BooleanClause[])this.clauses.toArray((Object[])new BooleanClause[this.clauses.size()]); }
/*     */ 
/*     */ 
/*     */   
/* 176 */   public List clauses() { return this.clauses; }
/*     */   
/*     */   private class BooleanWeight implements Weight {
/*     */     protected Similarity similarity;
/* 180 */     protected Vector weights = new Vector();
/*     */     private final BooleanQuery this$0;
/*     */     
/*     */     public BooleanWeight(Searcher searcher) throws IOException {
/* 184 */       this.similarity = BooleanQuery.this.getSimilarity(searcher);
/* 185 */       for (int i = 0; i < BooleanQuery.this.clauses.size(); i++) {
/* 186 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 187 */         this.weights.add(c.getQuery().createWeight(searcher));
/*     */       } 
/*     */     }
/*     */     
/* 191 */     public Query getQuery() { return BooleanQuery.this; }
/* 192 */     public float getValue() { return BooleanQuery.this.getBoost(); }
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 195 */       float sum = 0.0F;
/* 196 */       for (int i = 0; i < this.weights.size(); i++) {
/* 197 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 198 */         Weight w = this.weights.elementAt(i);
/*     */         
/* 200 */         float s = w.sumOfSquaredWeights();
/* 201 */         if (!c.isProhibited())
/*     */         {
/* 203 */           sum += s;
/*     */         }
/*     */       } 
/* 206 */       sum *= BooleanQuery.this.getBoost() * BooleanQuery.this.getBoost();
/*     */       
/* 208 */       return sum;
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 213 */       norm *= BooleanQuery.this.getBoost();
/* 214 */       for (int i = 0; i < this.weights.size(); i++) {
/* 215 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 216 */         Weight w = this.weights.elementAt(i);
/*     */         
/* 218 */         w.normalize(norm);
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 226 */       BooleanScorer2 result = new BooleanScorer2(this.similarity, BooleanQuery.this.minNrShouldMatch, allowDocsOutOfOrder);
/*     */ 
/*     */ 
/*     */       
/* 230 */       for (int i = 0; i < this.weights.size(); i++) {
/* 231 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 232 */         Weight w = this.weights.elementAt(i);
/* 233 */         Scorer subScorer = w.scorer(reader);
/* 234 */         if (subScorer != null) {
/* 235 */           result.add(subScorer, c.isRequired(), c.isProhibited());
/* 236 */         } else if (c.isRequired()) {
/* 237 */           return null;
/*     */         } 
/*     */       } 
/* 240 */       return result;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 245 */       int minShouldMatch = BooleanQuery.this.getMinimumNumberShouldMatch();
/*     */       
/* 247 */       ComplexExplanation sumExpl = new ComplexExplanation();
/* 248 */       sumExpl.setDescription(""sum of:"");
/* 249 */       int coord = 0;
/* 250 */       int maxCoord = 0;
/* 251 */       float sum = 0.0F;
/* 252 */       boolean fail = false;
/* 253 */       int shouldMatchCount = 0;
/* 254 */       for (int i = 0; i < this.weights.size(); i++) {
/* 255 */         BooleanClause c = BooleanQuery.this.clauses.get(i);
/* 256 */         Weight w = this.weights.elementAt(i);
/* 257 */         Explanation e = w.explain(reader, doc);
/* 258 */         if (!c.isProhibited()) maxCoord++; 
/* 259 */         if (e.isMatch()) {
/* 260 */           if (!c.isProhibited()) {
/* 261 */             sumExpl.addDetail(e);
/* 262 */             sum += e.getValue();
/* 263 */             coord++;
/*     */           } else {
/* 265 */             Explanation r = new Explanation(0.0F, ""match on prohibited clause ("" + c.getQuery().toString() + "")"");
/*     */             
/* 267 */             r.addDetail(e);
/* 268 */             sumExpl.addDetail(r);
/* 269 */             fail = true;
/*     */           } 
/* 271 */           if (c.getOccur().equals(BooleanClause.Occur.SHOULD))
/* 272 */             shouldMatchCount++; 
/* 273 */         } else if (c.isRequired()) {
/* 274 */           Explanation r = new Explanation(0.0F, ""no match on required clause ("" + c.getQuery().toString() + "")"");
/* 275 */           r.addDetail(e);
/* 276 */           sumExpl.addDetail(r);
/* 277 */           fail = true;
/*     */         } 
/*     */       } 
/* 280 */       if (fail) {
/* 281 */         sumExpl.setMatch(Boolean.FALSE);
/* 282 */         sumExpl.setValue(0.0F);
/* 283 */         sumExpl.setDescription(""Failure to meet condition(s) of required/prohibited clause(s)"");
/*     */         
/* 285 */         return sumExpl;
/* 286 */       }  if (shouldMatchCount < minShouldMatch) {
/* 287 */         sumExpl.setMatch(Boolean.FALSE);
/* 288 */         sumExpl.setValue(0.0F);
/* 289 */         sumExpl.setDescription(""Failure to match minimum number of optional clauses: "" + minShouldMatch);
/*     */         
/* 291 */         return sumExpl;
/*     */       } 
/*     */       
/* 294 */       sumExpl.setMatch((0 < coord) ? Boolean.TRUE : Boolean.FALSE);
/* 295 */       sumExpl.setValue(sum);
/*     */       
/* 297 */       float coordFactor = this.similarity.coord(coord, maxCoord);
/* 298 */       if (coordFactor == 1.0F) {
/* 299 */         return sumExpl;
/*     */       }
/* 301 */       ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(), sum * coordFactor, ""product of:"");
/*     */ 
/*     */       
/* 304 */       result.addDetail(sumExpl);
/* 305 */       result.addDetail(new Explanation(coordFactor, ""coord("" + coord + ""/"" + maxCoord + "")""));
/*     */       
/* 307 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static boolean allowDocsOutOfOrder = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 327 */   public static void setAllowDocsOutOfOrder(boolean allow) { allowDocsOutOfOrder = allow; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 335 */   public static boolean getAllowDocsOutOfOrder() { return allowDocsOutOfOrder; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 342 */   public static void setUseScorer14(boolean use14) { setAllowDocsOutOfOrder(use14); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 349 */   public static boolean getUseScorer14() { return getAllowDocsOutOfOrder(); }
/*     */ 
/*     */ 
/*     */   
/* 353 */   protected Weight createWeight(Searcher searcher) throws IOException { return new BooleanWeight(searcher); }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 357 */     if (this.clauses.size() == 1) {
/* 358 */       BooleanClause c = this.clauses.get(0);
/* 359 */       if (!c.isProhibited()) {
/*     */         
/* 361 */         Query query = c.getQuery().rewrite(reader);
/*     */         
/* 363 */         if (getBoost() != 1.0F) {
/* 364 */           if (query == c.getQuery())
/* 365 */             query = (Query)query.clone(); 
/* 366 */           query.setBoost(getBoost() * query.getBoost());
/*     */         } 
/*     */         
/* 369 */         return query;
/*     */       } 
/*     */     } 
/*     */     
/* 373 */     BooleanQuery clone = null;
/* 374 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 375 */       BooleanClause c = this.clauses.get(i);
/* 376 */       Query query = c.getQuery().rewrite(reader);
/* 377 */       if (query != c.getQuery()) {
/* 378 */         if (clone == null)
/* 379 */           clone = (BooleanQuery)clone(); 
/* 380 */         clone.clauses.set(i, new BooleanClause(query, c.getOccur()));
/*     */       } 
/*     */     } 
/* 383 */     if (clone != null) {
/* 384 */       return clone;
/*     */     }
/* 386 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 391 */     for (Iterator i = this.clauses.iterator(); i.hasNext(); ) {
/* 392 */       BooleanClause clause = i.next();
/* 393 */       clause.getQuery().extractTerms(terms);
/*     */     } 
/*     */   }
/*     */   
/*     */   public Object clone() {
/* 398 */     BooleanQuery clone = (BooleanQuery)super.clone();
/* 399 */     clone.clauses = (ArrayList)this.clauses.clone();
/* 400 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 405 */     StringBuffer buffer = new StringBuffer();
/* 406 */     boolean needParens = (getBoost() != 1.0D || getMinimumNumberShouldMatch() > 0);
/* 407 */     if (needParens) {
/* 408 */       buffer.append(""("");
/*     */     }
/*     */     
/* 411 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 412 */       BooleanClause c = this.clauses.get(i);
/* 413 */       if (c.isProhibited()) {
/* 414 */         buffer.append(""-"");
/* 415 */       } else if (c.isRequired()) {
/* 416 */         buffer.append(""+"");
/*     */       } 
/* 418 */       Query subQuery = c.getQuery();
/* 419 */       if (subQuery instanceof BooleanQuery) {
/* 420 */         buffer.append(""("");
/* 421 */         buffer.append(c.getQuery().toString(field));
/* 422 */         buffer.append("")"");
/*     */       } else {
/* 424 */         buffer.append(c.getQuery().toString(field));
/*     */       } 
/* 426 */       if (i != this.clauses.size() - 1) {
/* 427 */         buffer.append("" "");
/*     */       }
/*     */     } 
/* 430 */     if (needParens) {
/* 431 */       buffer.append("")"");
/*     */     }
/*     */     
/* 434 */     if (getMinimumNumberShouldMatch() > 0) {
/* 435 */       buffer.append('~');
/* 436 */       buffer.append(getMinimumNumberShouldMatch());
/*     */     } 
/*     */     
/* 439 */     if (getBoost() != 1.0F)
/*     */     {
/* 441 */       buffer.append(ToStringUtils.boost(getBoost()));
/*     */     }
/*     */     
/* 444 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 449 */     if (!(o instanceof BooleanQuery))
/* 450 */       return false; 
/* 451 */     BooleanQuery other = (BooleanQuery)o;
/* 452 */     return (getBoost() == other.getBoost() && this.clauses.equals(other.clauses) && getMinimumNumberShouldMatch() == other.getMinimumNumberShouldMatch());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 459 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.clauses.hashCode() + getMinimumNumberShouldMatch(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\BooleanQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class BooleanScorer
/*     */   extends Scorer
/*     */ {
/*  23 */   private SubScorer scorers = null;
/*  24 */   private BucketTable bucketTable = new BucketTable();
/*     */   
/*  26 */   private int maxCoord = 1;
/*  27 */   private float[] coordFactors = null;
/*     */   
/*  29 */   private int requiredMask = 0;
/*  30 */   private int prohibitedMask = 0;
/*  31 */   private int nextMask = 1;
/*     */   private final int minNrShouldMatch;
/*     */   private int end;
/*     */   private Bucket current;
/*     */   
/*  36 */   BooleanScorer(Similarity similarity) { this(similarity, 1); }
/*     */ 
/*     */   
/*     */   BooleanScorer(Similarity similarity, int minNrShouldMatch) {
/*  40 */     super(similarity);
/*  41 */     this.minNrShouldMatch = minNrShouldMatch;
/*     */   }
/*     */ 
/*     */   
/*     */   static final class SubScorer
/*     */   {
/*     */     public Scorer scorer;
/*     */     public boolean done;
/*     */     public boolean required = false;
/*     */     public boolean prohibited = false;
/*     */     public HitCollector collector;
/*     */     public SubScorer next;
/*     */     
/*     */     public SubScorer(Scorer scorer, boolean required, boolean prohibited, HitCollector collector, SubScorer next) throws IOException {
/*  55 */       this.scorer = scorer;
/*  56 */       this.done = !scorer.next();
/*  57 */       this.required = required;
/*  58 */       this.prohibited = prohibited;
/*  59 */       this.collector = collector;
/*  60 */       this.next = next;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   final void add(Scorer scorer, boolean required, boolean prohibited) throws IOException {
/*  66 */     int mask = 0;
/*  67 */     if (required || prohibited) {
/*  68 */       if (this.nextMask == 0) {
/*  69 */         throw new IndexOutOfBoundsException(""More than 32 required/prohibited clauses in query."");
/*     */       }
/*  71 */       mask = this.nextMask;
/*  72 */       this.nextMask <<= 1;
/*     */     } else {
/*  74 */       mask = 0;
/*     */     } 
/*  76 */     if (!prohibited) {
/*  77 */       this.maxCoord++;
/*     */     }
/*  79 */     if (prohibited) {
/*  80 */       this.prohibitedMask |= mask;
/*  81 */     } else if (required) {
/*  82 */       this.requiredMask |= mask;
/*     */     } 
/*  84 */     this.scorers = new SubScorer(scorer, required, prohibited, this.bucketTable.newCollector(mask), this.scorers);
/*     */   }
/*     */ 
/*     */   
/*     */   private final void computeCoordFactors() {
/*  89 */     this.coordFactors = new float[this.maxCoord];
/*  90 */     for (int i = 0; i < this.maxCoord; i++) {
/*  91 */       this.coordFactors[i] = getSimilarity().coord(i, this.maxCoord - 1);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/*  98 */     next();
/*  99 */     score(hc, 2147483647);
/*     */   }
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/*     */     boolean more;
/* 103 */     if (this.coordFactors == null) {
/* 104 */       computeCoordFactors();
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     do {
/* 110 */       this.bucketTable.first = null;
/*     */       
/* 112 */       while (this.current != null) {
/*     */ 
/*     */         
/* 115 */         if ((this.current.bits & this.prohibitedMask) == 0 && (this.current.bits & this.requiredMask) == this.requiredMask) {
/*     */ 
/*     */           
/* 118 */           if (this.current.doc >= max) {
/* 119 */             Bucket tmp = this.current;
/* 120 */             this.current = this.current.next;
/* 121 */             tmp.next = this.bucketTable.first;
/* 122 */             this.bucketTable.first = tmp;
/*     */             
/*     */             continue;
/*     */           } 
/* 126 */           if (this.current.coord >= this.minNrShouldMatch) {
/* 127 */             hc.collect(this.current.doc, this.current.score * this.coordFactors[this.current.coord]);
/*     */           }
/*     */         } 
/*     */         
/* 131 */         this.current = this.current.next;
/*     */       } 
/*     */       
/* 134 */       if (this.bucketTable.first != null) {
/* 135 */         this.current = this.bucketTable.first;
/* 136 */         this.bucketTable.first = this.current.next;
/* 137 */         return true;
/*     */       } 
/*     */ 
/*     */       
/* 141 */       more = false;
/* 142 */       this.end += 2048;
/* 143 */       for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 144 */         if (!sub.done) {
/* 145 */           sub.done = !sub.scorer.score(sub.collector, this.end);
/* 146 */           if (!sub.done)
/* 147 */             more = true; 
/*     */         } 
/*     */       } 
/* 150 */       this.current = this.bucketTable.first;
/*     */     }
/* 152 */     while (this.current != null || more);
/*     */     
/* 154 */     return false;
/*     */   }
/*     */   
/* 157 */   public int doc() { return this.current.doc; }
/*     */   
/*     */   public boolean next() throws IOException {
/*     */     boolean more;
/*     */     do {
/* 162 */       while (this.bucketTable.first != null) {
/* 163 */         this.current = this.bucketTable.first;
/* 164 */         this.bucketTable.first = this.current.next;
/*     */ 
/*     */         
/* 167 */         if ((this.current.bits & this.prohibitedMask) == 0 && (this.current.bits & this.requiredMask) == this.requiredMask && this.current.coord >= this.minNrShouldMatch)
/*     */         {
/*     */           
/* 170 */           return true;
/*     */         }
/*     */       } 
/*     */ 
/*     */       
/* 175 */       more = false;
/* 176 */       this.end += 2048;
/* 177 */       for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 178 */         Scorer scorer = sub.scorer;
/* 179 */         while (!sub.done && scorer.doc() < this.end) {
/* 180 */           sub.collector.collect(scorer.doc(), scorer.score());
/* 181 */           sub.done = !scorer.next();
/*     */         } 
/* 183 */         if (!sub.done) {
/* 184 */           more = true;
/*     */         }
/*     */       } 
/* 187 */     } while (this.bucketTable.first != null || more);
/*     */     
/* 189 */     return false;
/*     */   }
/*     */   
/*     */   public float score() {
/* 193 */     if (this.coordFactors == null)
/* 194 */       computeCoordFactors(); 
/* 195 */     return this.current.score * this.coordFactors[this.current.coord];
/*     */   }
/*     */   
/*     */   static final class Bucket {
/* 199 */     int doc = -1;
/*     */     
/*     */     float score;
/*     */     int bits;
/*     */     int coord;
/*     */     Bucket next;
/*     */   }
/*     */   
/*     */   static final class BucketTable
/*     */   {
/*     */     public static final int SIZE = 2048;
/*     */     public static final int MASK = 2047;
/* 211 */     final BooleanScorer.Bucket[] buckets = new BooleanScorer.Bucket[2048];
/* 212 */     BooleanScorer.Bucket first = null;
/*     */ 
/*     */ 
/*     */     
/* 216 */     public final int size() { return 2048; }
/*     */ 
/*     */     
/* 219 */     public HitCollector newCollector(int mask) { return new BooleanScorer.Collector(mask, this); }
/*     */   }
/*     */   
/*     */   static final class Collector extends HitCollector {
/*     */     private BooleanScorer.BucketTable bucketTable;
/*     */     private int mask;
/*     */     
/*     */     public Collector(int mask, BooleanScorer.BucketTable bucketTable) {
/* 227 */       this.mask = mask;
/* 228 */       this.bucketTable = bucketTable;
/*     */     }
/*     */     public final void collect(int doc, float score) {
/* 231 */       BooleanScorer.BucketTable table = this.bucketTable;
/* 232 */       int i = doc & 0x7FF;
/* 233 */       BooleanScorer.Bucket bucket = table.buckets[i];
/* 234 */       if (bucket == null) {
/* 235 */         table.buckets[i] = bucket = new BooleanScorer.Bucket();
/*     */       }
/* 237 */       if (bucket.doc != doc) {
/* 238 */         bucket.doc = doc;
/* 239 */         bucket.score = score;
/* 240 */         bucket.bits = this.mask;
/* 241 */         bucket.coord = 1;
/*     */         
/* 243 */         bucket.next = table.first;
/* 244 */         table.first = bucket;
/*     */       } else {
/* 246 */         bucket.score += score;
/* 247 */         bucket.bits |= this.mask;
/* 248 */         bucket.coord++;
/*     */       } 
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 254 */   public boolean skipTo(int target) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/* 258 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 262 */     StringBuffer buffer = new StringBuffer();
/* 263 */     buffer.append(""boolean("");
/* 264 */     for (SubScorer sub = this.scorers; sub != null; sub = sub.next) {
/* 265 */       buffer.append(sub.scorer.toString());
/* 266 */       buffer.append("" "");
/*     */     } 
/* 268 */     buffer.append("")"");
/* 269 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\BooleanScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.BooleanScorer2,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class BooleanScorer2
/*     */   extends Scorer
/*     */ {
/*  31 */   private ArrayList requiredScorers = new ArrayList();
/*  32 */   private ArrayList optionalScorers = new ArrayList();
/*  33 */   private ArrayList prohibitedScorers = new ArrayList();
/*     */   private final Coordinator coordinator;
/*     */   
/*  36 */   private class Coordinator { int maxCoord = 0;
/*     */     
/*  38 */     private float[] coordFactors = null; int nrMatchers;
/*     */     
/*     */     void init() {
/*  41 */       this.coordFactors = new float[this.maxCoord + 1];
/*  42 */       Similarity sim = BooleanScorer2.this.getSimilarity();
/*  43 */       for (int i = 0; i <= this.maxCoord; i++) {
/*  44 */         this.coordFactors[i] = sim.coord(i, this.maxCoord);
/*     */       }
/*     */     }
/*     */ 
/*     */     
/*     */     private final BooleanScorer2 this$0;
/*     */     
/*  51 */     void initDoc() { this.nrMatchers = 0; }
/*     */ 
/*     */ 
/*     */     
/*  55 */     float coordFactor() { return this.coordFactors[this.nrMatchers]; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     private Coordinator() {} }
/*     */ 
/*     */ 
/*     */   
/*  64 */   private Scorer countingSumScorer = null;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final int minNrShouldMatch;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean allowDocsOutOfOrder;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BooleanScorer2(Similarity similarity, int minNrShouldMatch, boolean allowDocsOutOfOrder) {
/*  86 */     super(similarity);
/*  87 */     if (minNrShouldMatch < 0) {
/*  88 */       throw new IllegalArgumentException(""Minimum number of optional scorers should not be negative"");
/*     */     }
/*  90 */     this.coordinator = new Coordinator();
/*  91 */     this.minNrShouldMatch = minNrShouldMatch;
/*  92 */     this.allowDocsOutOfOrder = allowDocsOutOfOrder;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public BooleanScorer2(Similarity similarity, int minNrShouldMatch) { this(similarity, minNrShouldMatch, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   public BooleanScorer2(Similarity similarity) { this(similarity, 0, false); }
/*     */ 
/*     */   
/*     */   public void add(Scorer scorer, boolean required, boolean prohibited) {
/* 119 */     if (!prohibited) {
/* 120 */       this.coordinator.maxCoord++;
/*     */     }
/*     */     
/* 123 */     if (required) {
/* 124 */       if (prohibited) {
/* 125 */         throw new IllegalArgumentException(""scorer cannot be required and prohibited"");
/*     */       }
/* 127 */       this.requiredScorers.add(scorer);
/* 128 */     } else if (prohibited) {
/* 129 */       this.prohibitedScorers.add(scorer);
/*     */     } else {
/* 131 */       this.optionalScorers.add(scorer);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void initCountingSumScorer() {
/* 143 */     this.coordinator.init();
/* 144 */     this.countingSumScorer = makeCountingSumScorer();
/*     */   }
/*     */   
/*     */   private class SingleMatchScorer
/*     */     extends Scorer {
/*     */     private Scorer scorer;
/* 150 */     private int lastScoredDoc = -1; private final BooleanScorer2 this$0;
/*     */     
/*     */     SingleMatchScorer(Scorer scorer) {
/* 153 */       super(scorer.getSimilarity());
/* 154 */       this.scorer = scorer;
/*     */     }
/*     */     public float score() throws IOException {
/* 157 */       if (doc() >= this.lastScoredDoc) {
/* 158 */         this.lastScoredDoc = doc();
/* 159 */         BooleanScorer2.this.coordinator.nrMatchers++;
/*     */       } 
/* 161 */       return this.scorer.score();
/*     */     }
/*     */     
/* 164 */     public int doc() { return this.scorer.doc(); }
/*     */ 
/*     */     
/* 167 */     public boolean next() throws IOException { return this.scorer.next(); }
/*     */ 
/*     */     
/* 170 */     public boolean skipTo(int docNr) throws IOException { return this.scorer.skipTo(docNr); }
/*     */ 
/*     */     
/* 173 */     public Explanation explain(int docNr) throws IOException { return this.scorer.explain(docNr); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer countingDisjunctionSumScorer(List scorers, int minNrShouldMatch) {
/* 181 */     return new DisjunctionSumScorer(scorers, minNrShouldMatch) {
/* 182 */         private int lastScoredDoc = -1;
/*     */         public float score() throws IOException {
/* 184 */           if (doc() >= this.lastScoredDoc) {
/* 185 */             this.lastScoredDoc = doc();
/* 186 */             BooleanScorer2.this.coordinator.nrMatchers += this.nrMatchers;
/*     */           } 
/* 188 */           return super.score();
/*     */         }
/*     */         private final BooleanScorer2 this$0;
/*     */       };
/*     */   }
/* 193 */   private static Similarity defaultSimilarity = new DefaultSimilarity();
/*     */ 
/*     */   
/*     */   private Scorer countingConjunctionSumScorer(List requiredScorers) {
/* 197 */     final int requiredNrMatchers = requiredScorers.size();
/* 198 */     ConjunctionScorer cs = new ConjunctionScorer(defaultSimilarity) {
/* 199 */         private int lastScoredDoc = -1; private final int val$requiredNrMatchers; private final BooleanScorer2 this$0;
/*     */         
/*     */         public float score() throws IOException {
/* 202 */           if (doc() >= this.lastScoredDoc) {
/* 203 */             this.lastScoredDoc = doc();
/* 204 */             BooleanScorer2.this.coordinator.nrMatchers += requiredNrMatchers;
/*     */           } 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 210 */           return super.score();
/*     */         }
/*     */       };
/* 213 */     Iterator rsi = requiredScorers.iterator();
/* 214 */     while (rsi.hasNext()) {
/* 215 */       cs.add(rsi.next());
/*     */     }
/* 217 */     return cs;
/*     */   }
/*     */   
/*     */   private Scorer dualConjunctionSumScorer(Scorer req1, Scorer req2) {
/* 221 */     ConjunctionScorer cs = new ConjunctionScorer(defaultSimilarity);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 226 */     cs.add(req1);
/* 227 */     cs.add(req2);
/* 228 */     return cs;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 235 */   private Scorer makeCountingSumScorer() { return (this.requiredScorers.size() == 0) ? makeCountingSumScorerNoReq() : makeCountingSumScorerSomeReq(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer makeCountingSumScorerNoReq() {
/* 241 */     if (this.optionalScorers.size() == 0) {
/* 242 */       return new NonMatchingScorer();
/*     */     }
/*     */     
/* 245 */     int nrOptRequired = (this.minNrShouldMatch < 1) ? 1 : this.minNrShouldMatch;
/* 246 */     if (this.optionalScorers.size() < nrOptRequired) {
/* 247 */       return new NonMatchingScorer();
/*     */     }
/* 249 */     Scorer requiredCountingSumScorer = (this.optionalScorers.size() > nrOptRequired) ? countingDisjunctionSumScorer(this.optionalScorers, nrOptRequired) : ((this.optionalScorers.size() == 1) ? new SingleMatchScorer(this.optionalScorers.get(0)) : countingConjunctionSumScorer(this.optionalScorers));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 256 */     return addProhibitedScorers(requiredCountingSumScorer);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private Scorer makeCountingSumScorerSomeReq() {
/* 262 */     if (this.optionalScorers.size() < this.minNrShouldMatch)
/* 263 */       return new NonMatchingScorer(); 
/* 264 */     if (this.optionalScorers.size() == this.minNrShouldMatch) {
/* 265 */       ArrayList allReq = new ArrayList(this.requiredScorers);
/* 266 */       allReq.addAll(this.optionalScorers);
/* 267 */       return addProhibitedScorers(countingConjunctionSumScorer(allReq));
/*     */     } 
/* 269 */     Scorer requiredCountingSumScorer = (this.requiredScorers.size() == 1) ? new SingleMatchScorer(this.requiredScorers.get(0)) : countingConjunctionSumScorer(this.requiredScorers);
/*     */ 
/*     */ 
/*     */     
/* 273 */     if (this.minNrShouldMatch > 0) {
/* 274 */       return addProhibitedScorers(dualConjunctionSumScorer(requiredCountingSumScorer, countingDisjunctionSumScorer(this.optionalScorers, this.minNrShouldMatch)));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 281 */     return new ReqOptSumScorer(addProhibitedScorers(requiredCountingSumScorer), (this.optionalScorers.size() == 1) ? new SingleMatchScorer(this.optionalScorers.get(0)) : countingDisjunctionSumScorer(this.optionalScorers, 1));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 296 */   private Scorer addProhibitedScorers(Scorer requiredCountingSumScorer) { return (this.prohibitedScorers.size() == 0) ? requiredCountingSumScorer : new ReqExclScorer(requiredCountingSumScorer, (this.prohibitedScorers.size() == 1) ? this.prohibitedScorers.get(0) : new DisjunctionSumScorer(this.prohibitedScorers)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/* 310 */     if (this.allowDocsOutOfOrder && this.requiredScorers.size() == 0 && this.prohibitedScorers.size() < 32) {
/*     */ 
/*     */       
/* 313 */       BooleanScorer bs = new BooleanScorer(getSimilarity(), this.minNrShouldMatch);
/* 314 */       Iterator si = this.optionalScorers.iterator();
/* 315 */       while (si.hasNext()) {
/* 316 */         bs.add(si.next(), false, false);
/*     */       }
/* 318 */       si = this.prohibitedScorers.iterator();
/* 319 */       while (si.hasNext()) {
/* 320 */         bs.add(si.next(), false, true);
/*     */       }
/* 322 */       bs.score(hc);
/*     */     } else {
/* 324 */       if (this.countingSumScorer == null) {
/* 325 */         initCountingSumScorer();
/*     */       }
/* 327 */       while (this.countingSumScorer.next()) {
/* 328 */         hc.collect(this.countingSumScorer.doc(), score());
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 343 */     int docNr = this.countingSumScorer.doc();
/* 344 */     while (docNr < max) {
/* 345 */       hc.collect(docNr, score());
/* 346 */       if (!this.countingSumScorer.next()) {
/* 347 */         return false;
/*     */       }
/* 349 */       docNr = this.countingSumScorer.doc();
/*     */     } 
/* 351 */     return true;
/*     */   }
/*     */   
/* 354 */   public int doc() { return this.countingSumScorer.doc(); }
/*     */   
/*     */   public boolean next() throws IOException {
/* 357 */     if (this.countingSumScorer == null) {
/* 358 */       initCountingSumScorer();
/*     */     }
/* 360 */     return this.countingSumScorer.next();
/*     */   }
/*     */   
/*     */   public float score() throws IOException {
/* 364 */     this.coordinator.initDoc();
/* 365 */     float sum = this.countingSumScorer.score();
/* 366 */     return sum * this.coordinator.coordFactor();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 378 */     if (this.countingSumScorer == null) {
/* 379 */       initCountingSumScorer();
/*     */     }
/* 381 */     return this.countingSumScorer.skipTo(target);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 390 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\BooleanScorer2.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.CachingWrapperFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import java.util.Map;
/*    */ import java.util.WeakHashMap;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class CachingWrapperFilter
/*    */   extends Filter
/*    */ {
/*    */   protected Filter filter;
/*    */   protected transient Map cache;
/*    */   
/* 43 */   public CachingWrapperFilter(Filter filter) { this.filter = filter; }
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 47 */     if (this.cache == null) {
/* 48 */       this.cache = new WeakHashMap();
/*    */     }
/*    */     
/* 51 */     synchronized (this.cache) {
/* 52 */       BitSet cached = (BitSet)this.cache.get(reader);
/* 53 */       if (cached != null) {
/* 54 */         return cached;
/*    */       }
/*    */     } 
/*    */     
/* 58 */     BitSet bits = this.filter.bits(reader);
/*    */     
/* 60 */     synchronized (this.cache) {
/* 61 */       this.cache.put(reader, bits);
/*    */     } 
/*    */     
/* 64 */     return bits;
/*    */   }
/*    */ 
/*    */   
/* 68 */   public String toString() { return ""CachingWrapperFilter("" + this.filter + "")""; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 72 */     if (!(o instanceof CachingWrapperFilter)) return false; 
/* 73 */     return this.filter.equals(((CachingWrapperFilter)o).filter);
/*    */   }
/*    */ 
/*    */   
/* 77 */   public int hashCode() { return this.filter.hashCode() ^ 0x1117BF25; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\CachingWrapperFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ComplexExplanation,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ComplexExplanation
/*    */   extends Explanation
/*    */ {
/*    */   private Boolean match;
/*    */   
/*    */   public ComplexExplanation() {}
/*    */   
/*    */   public ComplexExplanation(boolean match, float value, String description) {
/* 33 */     super(value, description);
/* 34 */     this.match = Boolean.valueOf(match);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 41 */   public Boolean getMatch() { return this.match; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 46 */   public void setMatch(Boolean match) { this.match = match; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean isMatch() {
/* 57 */     Boolean m = getMatch();
/* 58 */     return (null != m) ? m.booleanValue() : super.isMatch();
/*    */   }
/*    */   
/*    */   protected String getSummary() {
/* 62 */     if (null == getMatch()) {
/* 63 */       return super.getSummary();
/*    */     }
/* 65 */     return getValue() + "" = "" + (isMatch() ? ""(MATCH) "" : ""(NON-MATCH) "") + getDescription();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ComplexExplanation.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConjunctionScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Comparator;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class ConjunctionScorer
/*     */   extends Scorer
/*     */ {
/*  26 */   private Scorer[] scorers = new Scorer[2];
/*  27 */   private int length = 0;
/*  28 */   private int first = 0;
/*  29 */   private int last = -1;
/*     */   
/*     */   private boolean firstTime = true;
/*     */   private boolean more = true;
/*     */   private float coord;
/*     */   
/*  35 */   public ConjunctionScorer(Similarity similarity) { super(similarity); }
/*     */ 
/*     */   
/*     */   final void add(Scorer scorer) {
/*  39 */     if (this.length >= this.scorers.length) {
/*     */       
/*  41 */       Scorer[] temps = new Scorer[this.scorers.length * 2];
/*  42 */       System.arraycopy(this.scorers, 0, temps, 0, this.length);
/*  43 */       this.scorers = temps;
/*     */     } 
/*  45 */     this.last++;
/*  46 */     this.length++;
/*  47 */     this.scorers[this.last] = scorer;
/*     */   }
/*     */   
/*  50 */   public int doc() { return this.scorers[this.first].doc(); }
/*     */   
/*     */   public boolean next() throws IOException {
/*  53 */     if (this.firstTime) {
/*  54 */       init(true);
/*  55 */     } else if (this.more) {
/*  56 */       this.more = this.scorers[this.last].next();
/*     */     } 
/*  58 */     return doNext();
/*     */   }
/*     */   
/*     */   private boolean doNext() throws IOException {
/*  62 */     while (this.more && this.scorers[this.first].doc() < this.scorers[this.last].doc()) {
/*  63 */       this.more = this.scorers[this.first].skipTo(this.scorers[this.last].doc());
/*  64 */       this.last = this.first;
/*  65 */       this.first = (this.first == this.length - 1) ? 0 : (this.first + 1);
/*     */     } 
/*  67 */     return this.more;
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  71 */     if (this.firstTime) {
/*  72 */       init(false);
/*     */     }
/*     */     
/*  75 */     for (int i = 0, pos = this.first; i < this.length && 
/*  76 */       this.more; i++) {
/*  77 */       this.more = this.scorers[pos].skipTo(target);
/*  78 */       pos = (pos == this.length - 1) ? 0 : (pos + 1);
/*     */     } 
/*     */     
/*  81 */     if (this.more) {
/*  82 */       sortScorers();
/*     */     }
/*  84 */     return doNext();
/*     */   }
/*     */   
/*     */   public float score() throws IOException {
/*  88 */     float sum = 0.0F;
/*  89 */     for (int i = 0; i < this.length; i++) {
/*  90 */       sum += this.scorers[i].score();
/*     */     }
/*  92 */     return sum * this.coord;
/*     */   }
/*     */ 
/*     */   
/*     */   private void init(boolean initScorers) throws IOException {
/*  97 */     this.coord = getSimilarity().coord(this.length, this.length);
/*     */     
/*  99 */     this.more = (this.length > 0);
/*     */     
/* 101 */     if (initScorers) {
/*     */       
/* 103 */       for (int i = 0, pos = this.first; i < this.length && 
/* 104 */         this.more; i++) {
/* 105 */         this.more = this.scorers[pos].next();
/* 106 */         pos = (pos == this.length - 1) ? 0 : (pos + 1);
/*     */       } 
/*     */       
/* 109 */       if (this.more) {
/* 110 */         sortScorers();
/*     */       }
/*     */     } 
/* 113 */     this.firstTime = false;
/*     */   }
/*     */ 
/*     */   
/*     */   private void sortScorers() {
/* 118 */     if (this.length != this.scorers.length) {
/* 119 */       Scorer[] temps = new Scorer[this.length];
/* 120 */       System.arraycopy(this.scorers, 0, temps, 0, this.length);
/* 121 */       this.scorers = temps;
/*     */     } 
/*     */ 
/*     */     
/* 125 */     Arrays.sort(this.scorers, new Comparator()
/*     */         {
/* 127 */           public int compare(Object o1, Object o2) { return ((Scorer)o1).doc() - ((Scorer)o2).doc(); }
/*     */           
/*     */           private final ConjunctionScorer this$0;
/*     */         });
/* 131 */     this.first = 0;
/* 132 */     this.last = this.length - 1;
/*     */   }
/*     */ 
/*     */   
/* 136 */   public Explanation explain(int doc) { throw new UnsupportedOperationException(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ConjunctionScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConstantScoreQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ConstantScoreQuery
/*     */   extends Query
/*     */ {
/*     */   protected final Filter filter;
/*     */   
/*  37 */   public ConstantScoreQuery(Filter filter) { this.filter = filter; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  42 */   public Filter getFilter() { return this.filter; }
/*     */ 
/*     */ 
/*     */   
/*  46 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   protected class ConstantWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final ConstantScoreQuery this$0;
/*     */     
/*  60 */     public ConstantWeight(Searcher searcher) { this.similarity = ConstantScoreQuery.this.getSimilarity(searcher); }
/*     */ 
/*     */ 
/*     */     
/*  64 */     public Query getQuery() { return ConstantScoreQuery.this; }
/*     */ 
/*     */ 
/*     */     
/*  68 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/*  72 */       this.queryWeight = ConstantScoreQuery.this.getBoost();
/*  73 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float norm) {
/*  77 */       this.queryNorm = norm;
/*  78 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */     
/*  82 */     public Scorer scorer(IndexReader reader) throws IOException { return new ConstantScoreQuery.ConstantScorer(this.similarity, reader, this); }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  87 */       ConstantScoreQuery.ConstantScorer cs = (ConstantScoreQuery.ConstantScorer)scorer(reader);
/*  88 */       boolean exists = cs.bits.get(doc);
/*     */       
/*  90 */       ComplexExplanation result = new ComplexExplanation();
/*     */       
/*  92 */       if (exists) {
/*  93 */         result.setDescription(""ConstantScoreQuery("" + ConstantScoreQuery.this.filter + ""), product of:"");
/*     */         
/*  95 */         result.setValue(this.queryWeight);
/*  96 */         result.setMatch(Boolean.TRUE);
/*  97 */         result.addDetail(new Explanation(ConstantScoreQuery.this.getBoost(), ""boost""));
/*  98 */         result.addDetail(new Explanation(this.queryNorm, ""queryNorm""));
/*     */       } else {
/* 100 */         result.setDescription(""ConstantScoreQuery("" + ConstantScoreQuery.this.filter + "") doesn't match id "" + doc);
/*     */         
/* 102 */         result.setValue(0.0F);
/* 103 */         result.setMatch(Boolean.FALSE);
/*     */       } 
/* 105 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   protected class ConstantScorer extends Scorer {
/*     */     final BitSet bits;
/*     */     final float theScore;
/* 112 */     int doc = -1;
/*     */     
/*     */     public ConstantScorer(Similarity similarity, IndexReader reader, Weight w) throws IOException {
/* 115 */       super(similarity);
/* 116 */       this.theScore = w.getValue();
/* 117 */       this.bits = ConstantScoreQuery.this.filter.bits(reader);
/*     */     }
/*     */     private final ConstantScoreQuery this$0;
/*     */     public boolean next() throws IOException {
/* 121 */       this.doc = this.bits.nextSetBit(this.doc + 1);
/* 122 */       return (this.doc >= 0);
/*     */     }
/*     */ 
/*     */     
/* 126 */     public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */     
/* 130 */     public float score() throws IOException { return this.theScore; }
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 134 */       this.doc = this.bits.nextSetBit(target);
/* 135 */       return (this.doc >= 0);
/*     */     }
/*     */ 
/*     */     
/* 139 */     public Explanation explain(int doc) throws IOException { throw new UnsupportedOperationException(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   protected Weight createWeight(Searcher searcher) { return new ConstantWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 152 */   public String toString(String field) { return ""ConstantScore("" + this.filter.toString() + ((getBoost() == 1.0D) ? "")"" : (""^"" + getBoost())); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 158 */     if (this == o) return true; 
/* 159 */     if (!(o instanceof ConstantScoreQuery)) return false; 
/* 160 */     ConstantScoreQuery other = (ConstantScoreQuery)o;
/* 161 */     return (getBoost() == other.getBoost() && this.filter.equals(other.filter));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 167 */   public int hashCode() { return this.filter.hashCode() + Float.floatToIntBits(getBoost()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ConstantScoreQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ConstantScoreRangeQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ConstantScoreRangeQuery
/*     */   extends Query
/*     */ {
/*     */   private final String fieldName;
/*     */   private final String lowerVal;
/*     */   private final String upperVal;
/*     */   private final boolean includeLower;
/*     */   private final boolean includeUpper;
/*     */   
/*     */   public ConstantScoreRangeQuery(String fieldName, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
/*  51 */     if (lowerVal == null) {
/*  52 */       includeLower = true;
/*  53 */     } else if (includeLower && lowerVal.equals("""")) {
/*  54 */       lowerVal = null;
/*     */     } 
/*  56 */     if (upperVal == null) {
/*  57 */       includeUpper = true;
/*     */     }
/*     */ 
/*     */     
/*  61 */     this.fieldName = fieldName.intern();
/*  62 */     this.lowerVal = lowerVal;
/*  63 */     this.upperVal = upperVal;
/*  64 */     this.includeLower = includeLower;
/*  65 */     this.includeUpper = includeUpper;
/*     */   }
/*     */ 
/*     */   
/*  69 */   public String getField() { return this.fieldName; }
/*     */   
/*  71 */   public String getLowerVal() { return this.lowerVal; }
/*     */   
/*  73 */   public String getUpperVal() { return this.upperVal; }
/*     */   
/*  75 */   public boolean includesLower() { return this.includeLower; }
/*     */   
/*  77 */   public boolean includesUpper() { return this.includeUpper; }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  81 */     RangeFilter rangeFilt = new RangeFilter(this.fieldName, (this.lowerVal != null) ? this.lowerVal : """", this.upperVal, (this.lowerVal == """") ? false : this.includeLower, (this.upperVal == null) ? false : this.includeUpper);
/*     */ 
/*     */     
/*  84 */     Query q = new ConstantScoreQuery(rangeFilt);
/*  85 */     q.setBoost(getBoost());
/*  86 */     return q;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/*  92 */     StringBuffer buffer = new StringBuffer();
/*  93 */     if (!getField().equals(field)) {
/*     */       
/*  95 */       buffer.append(getField());
/*  96 */       buffer.append("":"");
/*     */     } 
/*  98 */     buffer.append(this.includeLower ? 91 : 123);
/*  99 */     buffer.append((this.lowerVal != null) ? this.lowerVal : ""*"");
/* 100 */     buffer.append("" TO "");
/* 101 */     buffer.append((this.upperVal != null) ? this.upperVal : ""*"");
/* 102 */     buffer.append(this.includeUpper ? 93 : 125);
/* 103 */     if (getBoost() != 1.0F) {
/*     */       
/* 105 */       buffer.append(""^"");
/* 106 */       buffer.append(Float.toString(getBoost()));
/*     */     } 
/* 108 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 113 */     if (this == o) return true; 
/* 114 */     if (!(o instanceof ConstantScoreRangeQuery)) return false; 
/* 115 */     ConstantScoreRangeQuery other = (ConstantScoreRangeQuery)o;
/*     */     
/* 117 */     if (this.fieldName != other.fieldName || this.includeLower != other.includeLower || this.includeUpper != other.includeUpper)
/*     */     {
/*     */       
/* 120 */       return false; } 
/* 121 */     if ((this.lowerVal != null) ? !this.lowerVal.equals(other.lowerVal) : (other.lowerVal != null)) return false; 
/* 122 */     if ((this.upperVal != null) ? !this.upperVal.equals(other.upperVal) : (other.upperVal != null)) return false; 
/* 123 */     return (getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 128 */     int h = Float.floatToIntBits(getBoost()) ^ this.fieldName.hashCode();
/*     */     
/* 130 */     h ^= (this.lowerVal != null) ? this.lowerVal.hashCode() : -1772448166;
/*     */ 
/*     */     
/* 133 */     h ^= h << 17 | h >>> 16;
/* 134 */     h ^= (this.upperVal != null) ? this.upperVal.hashCode() : 1516853865;
/* 135 */     h ^= (this.includeLower ? 1716885930 : 0) ^ (this.includeUpper ? -1716890266 : 0);
/*     */     
/* 137 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ConstantScoreRangeQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DefaultSimilarity,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class DefaultSimilarity
/*    */   extends Similarity
/*    */ {
/* 24 */   public float lengthNorm(String fieldName, int numTerms) { return (float)(1.0D / Math.sqrt(numTerms)); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 29 */   public float queryNorm(float sumOfSquaredWeights) { return (float)(1.0D / Math.sqrt(sumOfSquaredWeights)); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 34 */   public float tf(float freq) { return (float)Math.sqrt(freq); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 39 */   public float sloppyFreq(int distance) { return 1.0F / (distance + 1); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 44 */   public float idf(int docFreq, int numDocs) { return (float)(Math.log(numDocs / (docFreq + 1)) + 1.0D); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 49 */   public float coord(int overlap, int maxOverlap) { return overlap / maxOverlap; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\DefaultSimilarity.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionMaxQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class DisjunctionMaxQuery
/*     */   extends Query
/*     */ {
/*  45 */   private ArrayList disjuncts = new ArrayList();
/*     */ 
/*     */   
/*  48 */   private float tieBreakerMultiplier = 0.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  57 */   public DisjunctionMaxQuery(float tieBreakerMultiplier) { this.tieBreakerMultiplier = tieBreakerMultiplier; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DisjunctionMaxQuery(Collection disjuncts, float tieBreakerMultiplier) {
/*  66 */     this.tieBreakerMultiplier = tieBreakerMultiplier;
/*  67 */     add(disjuncts);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  74 */   public void add(Query query) { this.disjuncts.add(query); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  81 */   public void add(Collection disjuncts) { this.disjuncts.addAll(disjuncts); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  86 */   public Iterator iterator() { return this.disjuncts.iterator(); }
/*     */ 
/*     */   
/*     */   private class DisjunctionMaxWeight
/*     */     implements Weight
/*     */   {
/*     */     private Searcher searcher;
/*  93 */     private ArrayList weights = new ArrayList();
/*     */     private final DisjunctionMaxQuery this$0;
/*     */     
/*     */     public DisjunctionMaxWeight(Searcher searcher) throws IOException {
/*  97 */       this.searcher = searcher;
/*  98 */       for (int i = 0; i < DisjunctionMaxQuery.this.disjuncts.size(); i++) {
/*  99 */         this.weights.add(((Query)DisjunctionMaxQuery.this.disjuncts.get(i)).createWeight(searcher));
/*     */       }
/*     */     }
/*     */     
/* 103 */     public Query getQuery() { return DisjunctionMaxQuery.this; }
/*     */ 
/*     */     
/* 106 */     public float getValue() { return DisjunctionMaxQuery.this.getBoost(); }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 110 */       float max = 0.0F, sum = 0.0F;
/* 111 */       for (int i = 0; i < this.weights.size(); i++) {
/* 112 */         float sub = ((Weight)this.weights.get(i)).sumOfSquaredWeights();
/* 113 */         sum += sub;
/* 114 */         max = Math.max(max, sub);
/*     */       } 
/* 116 */       return ((sum - max) * DisjunctionMaxQuery.this.tieBreakerMultiplier * DisjunctionMaxQuery.this.tieBreakerMultiplier + max) * DisjunctionMaxQuery.this.getBoost() * DisjunctionMaxQuery.this.getBoost();
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 121 */       norm *= DisjunctionMaxQuery.this.getBoost();
/* 122 */       for (int i = 0; i < this.weights.size(); i++) {
/* 123 */         ((Weight)this.weights.get(i)).normalize(norm);
/*     */       }
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 128 */       DisjunctionMaxScorer result = new DisjunctionMaxScorer(DisjunctionMaxQuery.this.tieBreakerMultiplier, DisjunctionMaxQuery.this.getSimilarity(this.searcher));
/* 129 */       for (int i = 0; i < this.weights.size(); i++) {
/* 130 */         Weight w = this.weights.get(i);
/* 131 */         Scorer subScorer = w.scorer(reader);
/* 132 */         if (subScorer == null) return null; 
/* 133 */         result.add(subScorer);
/*     */       } 
/* 135 */       return result;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 140 */       if (DisjunctionMaxQuery.this.disjuncts.size() == 1) return ((Weight)this.weights.get(0)).explain(reader, doc); 
/* 141 */       ComplexExplanation result = new ComplexExplanation();
/* 142 */       float max = 0.0F, sum = 0.0F;
/* 143 */       result.setDescription((DisjunctionMaxQuery.this.tieBreakerMultiplier == 0.0F) ? ""max of:"" : (""max plus "" + DisjunctionMaxQuery.this.tieBreakerMultiplier + "" times others of:""));
/* 144 */       for (int i = 0; i < this.weights.size(); i++) {
/* 145 */         Explanation e = ((Weight)this.weights.get(i)).explain(reader, doc);
/* 146 */         if (e.isMatch()) {
/* 147 */           result.setMatch(Boolean.TRUE);
/* 148 */           result.addDetail(e);
/* 149 */           sum += e.getValue();
/* 150 */           max = Math.max(max, e.getValue());
/*     */         } 
/*     */       } 
/* 153 */       result.setValue(max + (sum - max) * DisjunctionMaxQuery.this.tieBreakerMultiplier);
/* 154 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 161 */   protected Weight createWeight(Searcher searcher) throws IOException { return new DisjunctionMaxWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 168 */     if (this.disjuncts.size() == 1) {
/* 169 */       Query singleton = this.disjuncts.get(0);
/* 170 */       Query result = singleton.rewrite(reader);
/* 171 */       if (getBoost() != 1.0F) {
/* 172 */         if (result == singleton) result = (Query)result.clone(); 
/* 173 */         result.setBoost(getBoost() * result.getBoost());
/*     */       } 
/* 175 */       return result;
/*     */     } 
/* 177 */     DisjunctionMaxQuery clone = null;
/* 178 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 179 */       Query clause = this.disjuncts.get(i);
/* 180 */       Query rewrite = clause.rewrite(reader);
/* 181 */       if (rewrite != clause) {
/* 182 */         if (clone == null) clone = (DisjunctionMaxQuery)clone(); 
/* 183 */         clone.disjuncts.set(i, rewrite);
/*     */       } 
/*     */     } 
/* 186 */     if (clone != null) return clone; 
/* 187 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 193 */     DisjunctionMaxQuery clone = (DisjunctionMaxQuery)super.clone();
/* 194 */     clone.disjuncts = (ArrayList)this.disjuncts.clone();
/* 195 */     return clone;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 201 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 202 */       ((Query)this.disjuncts.get(i)).extractTerms(terms);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 212 */     StringBuffer buffer = new StringBuffer();
/* 213 */     buffer.append(""("");
/* 214 */     for (int i = 0; i < this.disjuncts.size(); i++) {
/* 215 */       Query subquery = this.disjuncts.get(i);
/* 216 */       if (subquery instanceof BooleanQuery) {
/* 217 */         buffer.append(""("");
/* 218 */         buffer.append(subquery.toString(field));
/* 219 */         buffer.append("")"");
/*     */       } else {
/* 221 */         buffer.append(subquery.toString(field));
/* 222 */       }  if (i != this.disjuncts.size() - 1) buffer.append("" | ""); 
/*     */     } 
/* 224 */     buffer.append("")"");
/* 225 */     if (this.tieBreakerMultiplier != 0.0F) {
/* 226 */       buffer.append(""~"");
/* 227 */       buffer.append(this.tieBreakerMultiplier);
/*     */     } 
/* 229 */     if (getBoost() != 1.0D) {
/* 230 */       buffer.append(""^"");
/* 231 */       buffer.append(getBoost());
/*     */     } 
/* 233 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 241 */     if (!(o instanceof DisjunctionMaxQuery)) return false; 
/* 242 */     DisjunctionMaxQuery other = (DisjunctionMaxQuery)o;
/* 243 */     return (getBoost() == other.getBoost() && this.tieBreakerMultiplier == other.tieBreakerMultiplier && this.disjuncts.equals(other.disjuncts));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 252 */   public int hashCode() { return Float.floatToIntBits(getBoost()) + Float.floatToIntBits(this.tieBreakerMultiplier) + this.disjuncts.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\DisjunctionMaxQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionMaxScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DisjunctionMaxScorer
/*     */   extends Scorer
/*     */ {
/*  32 */   private ArrayList subScorers = new ArrayList();
/*     */ 
/*     */   
/*     */   private float tieBreakerMultiplier;
/*     */ 
/*     */   
/*     */   private boolean more = false;
/*     */   
/*     */   private boolean firstTime = true;
/*     */ 
/*     */   
/*     */   public DisjunctionMaxScorer(float tieBreakerMultiplier, Similarity similarity) {
/*  44 */     super(similarity);
/*  45 */     this.tieBreakerMultiplier = tieBreakerMultiplier;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Scorer scorer) throws IOException {
/*  52 */     if (scorer.next()) {
/*  53 */       this.subScorers.add(scorer);
/*  54 */       this.more = true;
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/*  62 */     if (!this.more) return false; 
/*  63 */     if (this.firstTime) {
/*  64 */       heapify();
/*  65 */       this.firstTime = false;
/*  66 */       return true;
/*     */     } 
/*     */     
/*  69 */     int lastdoc = ((Scorer)this.subScorers.get(0)).doc();
/*     */     do {
/*  71 */       if (((Scorer)this.subScorers.get(0)).next()) {
/*  72 */         heapAdjust(0);
/*     */       } else {
/*  74 */         heapRemoveRoot();
/*  75 */         if (this.subScorers.isEmpty()) return this.more = false; 
/*     */       } 
/*  77 */     } while (((Scorer)this.subScorers.get(0)).doc() == lastdoc);
/*  78 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public int doc() { return ((Scorer)this.subScorers.get(0)).doc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float score() throws IOException {
/*  92 */     int doc = ((Scorer)this.subScorers.get(0)).doc();
/*  93 */     float[] sum = { ((Scorer)this.subScorers.get(0)).score() }, max = { sum[0] };
/*  94 */     int size = this.subScorers.size();
/*  95 */     scoreAll(1, size, doc, sum, max);
/*  96 */     scoreAll(2, size, doc, sum, max);
/*  97 */     return max[0] + (sum[0] - max[0]) * this.tieBreakerMultiplier;
/*     */   }
/*     */ 
/*     */   
/*     */   private void scoreAll(int root, int size, int doc, float[] sum, float[] max) throws IOException {
/* 102 */     if (root < size && ((Scorer)this.subScorers.get(root)).doc() == doc) {
/* 103 */       float sub = ((Scorer)this.subScorers.get(root)).score();
/* 104 */       sum[0] = sum[0] + sub;
/* 105 */       max[0] = Math.max(max[0], sub);
/* 106 */       scoreAll((root << 1) + 1, size, doc, sum, max);
/* 107 */       scoreAll((root << 1) + 2, size, doc, sum, max);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 116 */     if (this.firstTime) {
/* 117 */       if (!this.more) return false; 
/* 118 */       heapify();
/* 119 */       this.firstTime = false;
/*     */     } 
/*     */     
/* 122 */     while (this.subScorers.size() > 0 && ((Scorer)this.subScorers.get(0)).doc() < target) {
/* 123 */       if (((Scorer)this.subScorers.get(0)).skipTo(target)) {
/* 124 */         heapAdjust(0); continue;
/*     */       } 
/* 126 */       heapRemoveRoot();
/*     */     } 
/* 128 */     if (this.subScorers.size() == 0)
/* 129 */       return this.more = false; 
/* 130 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 138 */   public Explanation explain(int doc) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void heapify() {
/* 143 */     int size = this.subScorers.size();
/* 144 */     for (int i = (size >> 1) - 1; i >= 0; i--) {
/* 145 */       heapAdjust(i);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private void heapAdjust(int root) {
/* 152 */     Scorer scorer = this.subScorers.get(root);
/* 153 */     int doc = scorer.doc();
/* 154 */     int i = root, size = this.subScorers.size();
/* 155 */     while (i <= (size >> 1) - 1) {
/* 156 */       int lchild = (i << 1) + 1;
/* 157 */       Scorer lscorer = this.subScorers.get(lchild);
/* 158 */       int ldoc = lscorer.doc();
/* 159 */       int rdoc = Integer.MAX_VALUE, rchild = (i << 1) + 2;
/* 160 */       Scorer rscorer = null;
/* 161 */       if (rchild < size) {
/* 162 */         rscorer = this.subScorers.get(rchild);
/* 163 */         rdoc = rscorer.doc();
/*     */       } 
/* 165 */       if (ldoc < doc) {
/* 166 */         if (rdoc < ldoc) {
/* 167 */           this.subScorers.set(i, rscorer);
/* 168 */           this.subScorers.set(rchild, scorer);
/* 169 */           i = rchild; continue;
/*     */         } 
/* 171 */         this.subScorers.set(i, lscorer);
/* 172 */         this.subScorers.set(lchild, scorer);
/* 173 */         i = lchild; continue;
/*     */       } 
/* 175 */       if (rdoc < doc) {
/* 176 */         this.subScorers.set(i, rscorer);
/* 177 */         this.subScorers.set(rchild, scorer);
/* 178 */         i = rchild;
/*     */         continue;
/*     */       } 
/*     */       return;
/*     */     } 
/*     */   }
/*     */   private void heapRemoveRoot() {
/* 185 */     int size = this.subScorers.size();
/* 186 */     if (size == 1) {
/* 187 */       this.subScorers.remove(0);
/*     */     } else {
/* 189 */       this.subScorers.set(0, this.subScorers.get(size - 1));
/* 190 */       this.subScorers.remove(size - 1);
/* 191 */       heapAdjust(0);
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\DisjunctionMaxScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.DisjunctionSumScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.util.ScorerDocQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class DisjunctionSumScorer
/*     */   extends Scorer
/*     */ {
/*     */   private final int nrScorers;
/*     */   protected final List subScorers;
/*     */   private final int minimumNrMatchers;
/*  52 */   private ScorerDocQueue scorerDocQueue = null;
/*  53 */   private int queueSize = -1;
/*     */ 
/*     */   
/*  56 */   private int currentDoc = -1;
/*     */ 
/*     */   
/*  59 */   protected int nrMatchers = -1;
/*     */   
/*  61 */   private float currentScore = NaNF;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public DisjunctionSumScorer(List subScorers, int minimumNrMatchers) {
/*  74 */     super(null);
/*     */     
/*  76 */     this.nrScorers = subScorers.size();
/*     */     
/*  78 */     if (minimumNrMatchers <= 0) {
/*  79 */       throw new IllegalArgumentException(""Minimum nr of matchers must be positive"");
/*     */     }
/*  81 */     if (this.nrScorers <= 1) {
/*  82 */       throw new IllegalArgumentException(""There must be at least 2 subScorers"");
/*     */     }
/*     */     
/*  85 */     this.minimumNrMatchers = minimumNrMatchers;
/*  86 */     this.subScorers = subScorers;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  93 */   public DisjunctionSumScorer(List subScorers) { this(subScorers, 1); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void initScorerDocQueue() throws IOException {
/* 100 */     Iterator si = this.subScorers.iterator();
/* 101 */     this.scorerDocQueue = new ScorerDocQueue(this.nrScorers);
/* 102 */     this.queueSize = 0;
/* 103 */     while (si.hasNext()) {
/* 104 */       Scorer se = si.next();
/* 105 */       if (se.next() && 
/* 106 */         this.scorerDocQueue.insert(se)) {
/* 107 */         this.queueSize++;
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/* 119 */     while (next()) {
/* 120 */       hc.collect(this.currentDoc, this.currentScore);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 133 */     while (this.currentDoc < max) {
/* 134 */       hc.collect(this.currentDoc, this.currentScore);
/* 135 */       if (!next()) {
/* 136 */         return false;
/*     */       }
/*     */     } 
/* 139 */     return true;
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/* 143 */     if (this.scorerDocQueue == null) {
/* 144 */       initScorerDocQueue();
/*     */     }
/* 146 */     return (this.scorerDocQueue.size() >= this.minimumNrMatchers && advanceAfterCurrent());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean advanceAfterCurrent() throws IOException {
/*     */     do {
/* 171 */       this.currentDoc = this.scorerDocQueue.topDoc();
/* 172 */       this.currentScore = this.scorerDocQueue.topScore();
/* 173 */       this.nrMatchers = 1;
/*     */       
/* 175 */       while (this.scorerDocQueue.topNextAndAdjustElsePop() || 
/* 176 */         --this.queueSize != 0) {
/*     */ 
/*     */ 
/*     */         
/* 180 */         if (this.scorerDocQueue.topDoc() != this.currentDoc) {
/*     */           break;
/*     */         }
/* 183 */         this.currentScore += this.scorerDocQueue.topScore();
/* 184 */         this.nrMatchers++;
/*     */       } 
/*     */       
/* 187 */       if (this.nrMatchers >= this.minimumNrMatchers)
/* 188 */         return true; 
/* 189 */     } while (this.queueSize >= this.minimumNrMatchers);
/* 190 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 198 */   public float score() throws IOException { return this.currentScore; }
/*     */   
/* 200 */   public int doc() { return this.currentDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 206 */   public int nrMatchers() { return this.nrMatchers; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 217 */     if (this.scorerDocQueue == null) {
/* 218 */       initScorerDocQueue();
/*     */     }
/* 220 */     if (this.queueSize < this.minimumNrMatchers) {
/* 221 */       return false;
/*     */     }
/* 223 */     if (target <= this.currentDoc) {
/* 224 */       return true;
/*     */     }
/*     */     do {
/* 227 */       if (this.scorerDocQueue.topDoc() >= target)
/* 228 */         return advanceAfterCurrent(); 
/* 229 */     } while (this.scorerDocQueue.topSkipToAndAdjustElsePop(target) || 
/* 230 */       --this.queueSize >= this.minimumNrMatchers);
/* 231 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 239 */     Explanation res = new Explanation();
/* 240 */     Iterator ssi = this.subScorers.iterator();
/* 241 */     float sumScore = 0.0F;
/* 242 */     int nrMatches = 0;
/* 243 */     while (ssi.hasNext()) {
/* 244 */       Explanation es = ((Scorer)ssi.next()).explain(doc);
/* 245 */       if (es.getValue() > 0.0F) {
/* 246 */         sumScore += es.getValue();
/* 247 */         nrMatches++;
/*     */       } 
/* 249 */       res.addDetail(es);
/*     */     } 
/* 251 */     if (this.nrMatchers >= this.minimumNrMatchers) {
/* 252 */       res.setValue(sumScore);
/* 253 */       res.setDescription(""sum over at least "" + this.minimumNrMatchers + "" of "" + this.subScorers.size() + "":"");
/*     */     } else {
/*     */       
/* 256 */       res.setValue(0.0F);
/* 257 */       res.setDescription(nrMatches + "" match(es) but at least "" + this.minimumNrMatchers + "" of "" + this.subScorers.size() + "" needed"");
/*     */     } 
/*     */ 
/*     */     
/* 261 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\DisjunctionSumScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ExactPhraseScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class ExactPhraseScorer
/*    */   extends PhraseScorer
/*    */ {
/* 27 */   ExactPhraseScorer(Weight weight, TermPositions[] tps, int[] offsets, Similarity similarity, byte[] norms) { super(weight, tps, offsets, similarity, norms); }
/*    */ 
/*    */ 
/*    */   
/*    */   protected final float phraseFreq() throws IOException {
/* 32 */     this.pq.clear();
/* 33 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 34 */       pp.firstPosition();
/* 35 */       this.pq.put(pp);
/*    */     } 
/* 37 */     pqToList();
/*    */ 
/*    */ 
/*    */     
/* 41 */     int freq = 0;
/*    */     do {
/* 43 */       while (this.first.position < this.last.position) {
/*    */         do {
/* 45 */           if (!this.first.nextPosition())
/* 46 */             return freq; 
/* 47 */         } while (this.first.position < this.last.position);
/* 48 */         firstToLast();
/*    */       } 
/* 50 */       freq++;
/* 51 */     } while (this.last.nextPosition());
/*    */     
/* 53 */     return freq;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ExactPhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Explanation,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.ArrayList;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Explanation
/*     */   implements Serializable
/*     */ {
/*     */   private float value;
/*     */   private String description;
/*     */   private ArrayList details;
/*     */   
/*     */   public Explanation() {}
/*     */   
/*     */   public Explanation(float value, String description) {
/*  31 */     this.value = value;
/*  32 */     this.description = description;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  44 */   public boolean isMatch() { return (0.0F < getValue()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  50 */   public float getValue() { return this.value; }
/*     */   
/*  52 */   public void setValue(float value) { this.value = value; }
/*     */ 
/*     */   
/*  55 */   public String getDescription() { return this.description; }
/*     */ 
/*     */   
/*  58 */   public void setDescription(String description) { this.description = description; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  66 */   protected String getSummary() { return getValue() + "" = "" + getDescription(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation[] getDetails() {
/*  71 */     if (this.details == null)
/*  72 */       return null; 
/*  73 */     return (Explanation[])this.details.toArray((Object[])new Explanation[0]);
/*     */   }
/*     */ 
/*     */   
/*     */   public void addDetail(Explanation detail) {
/*  78 */     if (this.details == null)
/*  79 */       this.details = new ArrayList(); 
/*  80 */     this.details.add(detail);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  85 */   public String toString() { return toString(0); }
/*     */   
/*     */   protected String toString(int depth) {
/*  88 */     StringBuffer buffer = new StringBuffer();
/*  89 */     for (int i = 0; i < depth; i++) {
/*  90 */       buffer.append(""  "");
/*     */     }
/*  92 */     buffer.append(getSummary());
/*  93 */     buffer.append(""\n"");
/*     */     
/*  95 */     Explanation[] details = getDetails();
/*  96 */     if (details != null) {
/*  97 */       for (int i = 0; i < details.length; i++) {
/*  98 */         buffer.append(details[i].toString(depth + 1));
/*     */       }
/*     */     }
/*     */     
/* 102 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toHtml() {
/* 108 */     StringBuffer buffer = new StringBuffer();
/* 109 */     buffer.append(""<ul>\n"");
/*     */     
/* 111 */     buffer.append(""<li>"");
/* 112 */     buffer.append(getSummary());
/* 113 */     buffer.append(""<br />\n"");
/*     */     
/* 115 */     Explanation[] details = getDetails();
/* 116 */     if (details != null) {
/* 117 */       for (int i = 0; i < details.length; i++) {
/* 118 */         buffer.append(details[i].toHtml());
/*     */       }
/*     */     }
/*     */     
/* 122 */     buffer.append(""</li>\n"");
/* 123 */     buffer.append(""</ul>\n"");
/*     */     
/* 125 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Explanation.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldCache,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface FieldCache
/*    */ {
/*    */   public static final int STRING_INDEX = -1;
/*    */   
/*    */   public static interface FloatParser
/*    */   {
/*    */     float parseFloat(String param1String);
/*    */   }
/*    */   
/*    */   public static interface IntParser
/*    */   {
/*    */     int parseInt(String param1String);
/*    */   }
/*    */   
/*    */   public static interface ShortParser
/*    */   {
/*    */     short parseShort(String param1String);
/*    */   }
/*    */   
/*    */   public static interface ByteParser
/*    */   {
/*    */     byte parseByte(String param1String);
/*    */   }
/*    */   
/*    */   public static class StringIndex
/*    */   {
/*    */     public final String[] lookup;
/*    */     public final int[] order;
/*    */     
/*    */     public StringIndex(int[] values, String[] lookup) {
/* 51 */       this.order = values;
/* 52 */       this.lookup = lookup;
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 89 */   public static final FieldCache DEFAULT = new FieldCacheImpl();
/*    */   
/*    */   byte[] getBytes(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   byte[] getBytes(IndexReader paramIndexReader, String paramString, ByteParser paramByteParser) throws IOException;
/*    */   
/*    */   short[] getShorts(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   short[] getShorts(IndexReader paramIndexReader, String paramString, ShortParser paramShortParser) throws IOException;
/*    */   
/*    */   int[] getInts(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   int[] getInts(IndexReader paramIndexReader, String paramString, IntParser paramIntParser) throws IOException;
/*    */   
/*    */   float[] getFloats(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   float[] getFloats(IndexReader paramIndexReader, String paramString, FloatParser paramFloatParser) throws IOException;
/*    */   
/*    */   String[] getStrings(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   StringIndex getStringIndex(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   Object getAuto(IndexReader paramIndexReader, String paramString) throws IOException;
/*    */   
/*    */   Comparable[] getCustom(IndexReader paramIndexReader, String paramString, SortComparator paramSortComparator) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FieldCache.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldCacheImpl,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import java.util.Locale;
/*     */ import java.util.Map;
/*     */ import java.util.WeakHashMap;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FieldCacheImpl
/*     */   implements FieldCache
/*     */ {
/*     */   static abstract class Cache
/*     */   {
/*  46 */     private final Map readerCache = new WeakHashMap();
/*     */ 
/*     */     
/*     */     protected abstract Object createValue(IndexReader param1IndexReader, Object param1Object) throws IOException;
/*     */     
/*     */     public Object get(IndexReader reader, Object key) throws IOException {
/*     */       Object value;
/*     */       Map innerCache;
/*  54 */       synchronized (this.readerCache) {
/*  55 */         innerCache = (Map)this.readerCache.get(reader);
/*  56 */         if (innerCache == null) {
/*  57 */           innerCache = new HashMap();
/*  58 */           this.readerCache.put(reader, innerCache);
/*  59 */           value = null;
/*     */         } else {
/*  61 */           value = innerCache.get(key);
/*     */         } 
/*  63 */         if (value == null) {
/*  64 */           value = new FieldCacheImpl.CreationPlaceholder();
/*  65 */           innerCache.put(key, value);
/*     */         } 
/*     */       } 
/*  68 */       if (value instanceof FieldCacheImpl.CreationPlaceholder) {
/*  69 */         synchronized (value) {
/*  70 */           FieldCacheImpl.CreationPlaceholder progress = (FieldCacheImpl.CreationPlaceholder)value;
/*  71 */           if (progress.value == null) {
/*  72 */             progress.value = createValue(reader, key);
/*  73 */             synchronized (this.readerCache) {
/*  74 */               innerCache.put(key, progress.value);
/*     */             } 
/*     */           } 
/*  77 */           return progress.value;
/*     */         } 
/*     */       }
/*  80 */       return value;
/*     */     }
/*     */   }
/*     */   
/*     */   static final class CreationPlaceholder
/*     */   {
/*     */     Object value;
/*     */   }
/*     */   
/*     */   static class Entry
/*     */   {
/*     */     final String field;
/*     */     final int type;
/*     */     final Object custom;
/*     */     final Locale locale;
/*     */     
/*     */     Entry(String field, int type, Locale locale) {
/*  97 */       this.field = field.intern();
/*  98 */       this.type = type;
/*  99 */       this.custom = null;
/* 100 */       this.locale = locale;
/*     */     }
/*     */ 
/*     */     
/*     */     Entry(String field, Object custom) {
/* 105 */       this.field = field.intern();
/* 106 */       this.type = 9;
/* 107 */       this.custom = custom;
/* 108 */       this.locale = null;
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean equals(Object o) {
/* 113 */       if (o instanceof Entry) {
/* 114 */         Entry other = (Entry)o;
/* 115 */         if (other.field == this.field && other.type == this.type && (
/* 116 */           (other.locale == null) ? (this.locale == null) : other.locale.equals(this.locale))) {
/* 117 */           if (other.custom == null) {
/* 118 */             if (this.custom == null) return true; 
/* 119 */           } else if (other.custom.equals(this.custom)) {
/* 120 */             return true;
/*     */           } 
/*     */         }
/*     */       } 
/*     */       
/* 125 */       return false;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 130 */     public int hashCode() { return this.field.hashCode() ^ this.type ^ ((this.custom == null) ? 0 : this.custom.hashCode()) ^ ((this.locale == null) ? 0 : this.locale.hashCode()); }
/*     */   }
/*     */ 
/*     */   
/* 134 */   private static final FieldCache.ByteParser BYTE_PARSER = new FieldCache.ByteParser()
/*     */     {
/* 136 */       public byte parseByte(String value) { return Byte.parseByte(value); }
/*     */     };
/*     */ 
/*     */   
/* 140 */   private static final FieldCache.ShortParser SHORT_PARSER = new FieldCache.ShortParser()
/*     */     {
/* 142 */       public short parseShort(String value) { return Short.parseShort(value); }
/*     */     };
/*     */ 
/*     */   
/* 146 */   private static final FieldCache.IntParser INT_PARSER = new FieldCache.IntParser()
/*     */     {
/* 148 */       public int parseInt(String value) { return Integer.parseInt(value); }
/*     */     };
/*     */ 
/*     */   
/* 152 */   private static final FieldCache.FloatParser FLOAT_PARSER = new FieldCache.FloatParser()
/*     */     {
/* 154 */       public float parseFloat(String value) { return Float.parseFloat(value); }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public byte[] getBytes(IndexReader reader, String field) throws IOException { return getBytes(reader, field, BYTE_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 166 */   public byte[] getBytes(IndexReader reader, String field, FieldCache.ByteParser parser) throws IOException { return (byte[])this.bytesCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 169 */   Cache bytesCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 173 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 174 */         String field = entry.field;
/* 175 */         FieldCache.ByteParser parser = (FieldCache.ByteParser)entry.custom;
/* 176 */         byte[] retArray = new byte[reader.maxDoc()];
/* 177 */         TermDocs termDocs = reader.termDocs();
/* 178 */         TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */         try {
/*     */           do {
/* 181 */             Term term = termEnum.term();
/* 182 */             if (term == null || term.field() != field)
/* 183 */               break;  byte termval = parser.parseByte(term.text());
/* 184 */             termDocs.seek(termEnum);
/* 185 */             while (termDocs.next()) {
/* 186 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 188 */           } while (termEnum.next());
/*     */         } finally {
/* 190 */           termDocs.close();
/* 191 */           termEnum.close();
/*     */         } 
/* 193 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */   
/* 199 */   public short[] getShorts(IndexReader reader, String field) throws IOException { return getShorts(reader, field, SHORT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 205 */   public short[] getShorts(IndexReader reader, String field, FieldCache.ShortParser parser) throws IOException { return (short[])this.shortsCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 208 */   Cache shortsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 212 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 213 */         String field = entry.field;
/* 214 */         FieldCache.ShortParser parser = (FieldCache.ShortParser)entry.custom;
/* 215 */         short[] retArray = new short[reader.maxDoc()];
/* 216 */         TermDocs termDocs = reader.termDocs();
/* 217 */         TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */         try {
/*     */           do {
/* 220 */             Term term = termEnum.term();
/* 221 */             if (term == null || term.field() != field)
/* 222 */               break;  short termval = parser.parseShort(term.text());
/* 223 */             termDocs.seek(termEnum);
/* 224 */             while (termDocs.next()) {
/* 225 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 227 */           } while (termEnum.next());
/*     */         } finally {
/* 229 */           termDocs.close();
/* 230 */           termEnum.close();
/*     */         } 
/* 232 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */   
/* 238 */   public int[] getInts(IndexReader reader, String field) throws IOException { return getInts(reader, field, INT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 244 */   public int[] getInts(IndexReader reader, String field, FieldCache.IntParser parser) throws IOException { return (int[])this.intsCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 247 */   Cache intsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 251 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 252 */         String field = entry.field;
/* 253 */         FieldCache.IntParser parser = (FieldCache.IntParser)entry.custom;
/* 254 */         int[] retArray = new int[reader.maxDoc()];
/* 255 */         TermDocs termDocs = reader.termDocs();
/* 256 */         TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */         try {
/*     */           do {
/* 259 */             Term term = termEnum.term();
/* 260 */             if (term == null || term.field() != field)
/* 261 */               break;  int termval = parser.parseInt(term.text());
/* 262 */             termDocs.seek(termEnum);
/* 263 */             while (termDocs.next()) {
/* 264 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 266 */           } while (termEnum.next());
/*     */         } finally {
/* 268 */           termDocs.close();
/* 269 */           termEnum.close();
/*     */         } 
/* 271 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 278 */   public float[] getFloats(IndexReader reader, String field) throws IOException { return getFloats(reader, field, FLOAT_PARSER); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 284 */   public float[] getFloats(IndexReader reader, String field, FieldCache.FloatParser parser) throws IOException { return (float[])this.floatsCache.get(reader, new Entry(field, parser)); }
/*     */ 
/*     */   
/* 287 */   Cache floatsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 291 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 292 */         String field = entry.field;
/* 293 */         FieldCache.FloatParser parser = (FieldCache.FloatParser)entry.custom;
/* 294 */         float[] retArray = new float[reader.maxDoc()];
/* 295 */         TermDocs termDocs = reader.termDocs();
/* 296 */         TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */         try {
/*     */           do {
/* 299 */             Term term = termEnum.term();
/* 300 */             if (term == null || term.field() != field)
/* 301 */               break;  float termval = parser.parseFloat(term.text());
/* 302 */             termDocs.seek(termEnum);
/* 303 */             while (termDocs.next()) {
/* 304 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 306 */           } while (termEnum.next());
/*     */         } finally {
/* 308 */           termDocs.close();
/* 309 */           termEnum.close();
/*     */         } 
/* 311 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 318 */   public String[] getStrings(IndexReader reader, String field) throws IOException { return (String[])this.stringsCache.get(reader, field); }
/*     */ 
/*     */   
/* 321 */   Cache stringsCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object fieldKey) throws IOException {
/* 325 */         String field = ((String)fieldKey).intern();
/* 326 */         String[] retArray = new String[reader.maxDoc()];
/* 327 */         TermDocs termDocs = reader.termDocs();
/* 328 */         TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */         try {
/*     */           do {
/* 331 */             Term term = termEnum.term();
/* 332 */             if (term == null || term.field() != field)
/* 333 */               break;  String termval = term.text();
/* 334 */             termDocs.seek(termEnum);
/* 335 */             while (termDocs.next()) {
/* 336 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 338 */           } while (termEnum.next());
/*     */         } finally {
/* 340 */           termDocs.close();
/* 341 */           termEnum.close();
/*     */         } 
/* 343 */         return retArray;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 350 */   public FieldCache.StringIndex getStringIndex(IndexReader reader, String field) throws IOException { return (FieldCache.StringIndex)this.stringsIndexCache.get(reader, field); }
/*     */ 
/*     */   
/* 353 */   Cache stringsIndexCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object fieldKey) throws IOException {
/* 357 */         String field = ((String)fieldKey).intern();
/* 358 */         int[] retArray = new int[reader.maxDoc()];
/* 359 */         String[] mterms = new String[reader.maxDoc() + 1];
/* 360 */         TermDocs termDocs = reader.termDocs();
/* 361 */         TermEnum termEnum = reader.terms(new Term(field, """"));
/* 362 */         int t = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 368 */         mterms[t++] = null;
/*     */         
/*     */         try {
/*     */           do {
/* 372 */             Term term = termEnum.term();
/* 373 */             if (term == null || term.field() != field) {
/*     */               break;
/*     */             }
/*     */             
/* 377 */             if (t >= mterms.length) throw new RuntimeException(""there are more terms than documents in field \"""" + field + ""\"", but it's impossible to sort on "" + ""tokenized fields"");
/*     */ 
/*     */             
/* 380 */             mterms[t] = term.text();
/*     */             
/* 382 */             termDocs.seek(termEnum);
/* 383 */             while (termDocs.next()) {
/* 384 */               retArray[termDocs.doc()] = t;
/*     */             }
/*     */             
/* 387 */             t++;
/* 388 */           } while (termEnum.next());
/*     */         } finally {
/* 390 */           termDocs.close();
/* 391 */           termEnum.close();
/*     */         } 
/*     */         
/* 394 */         if (t == 0) {
/*     */ 
/*     */           
/* 397 */           mterms = new String[1];
/* 398 */         } else if (t < mterms.length) {
/*     */ 
/*     */           
/* 401 */           String[] terms = new String[t];
/* 402 */           System.arraycopy(mterms, 0, terms, 0, t);
/* 403 */           mterms = terms;
/*     */         } 
/*     */         
/* 406 */         FieldCache.StringIndex value = new FieldCache.StringIndex(retArray, mterms);
/* 407 */         return value;
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 424 */   public Object getAuto(IndexReader reader, String field) throws IOException { return this.autoCache.get(reader, field); }
/*     */ 
/*     */   
/* 427 */   Cache autoCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object fieldKey) throws IOException {
/* 431 */         String field = ((String)fieldKey).intern();
/* 432 */         TermEnum enumerator = reader.terms(new Term(field, """"));
/*     */         try {
/* 434 */           Term term = enumerator.term();
/* 435 */           if (term == null) {
/* 436 */             throw new RuntimeException(""no terms in field "" + field + "" - cannot determine sort type"");
/*     */           }
/* 438 */           Object ret = null;
/* 439 */           if (term.field() == field) {
/* 440 */             String termtext = term.text().trim();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/*     */             try {
/* 454 */               Integer.parseInt(termtext);
/* 455 */               ret = FieldCacheImpl.this.getInts(reader, field);
/* 456 */             } catch (NumberFormatException nfe1) {
/*     */               try {
/* 458 */                 Float.parseFloat(termtext);
/* 459 */                 ret = FieldCacheImpl.this.getFloats(reader, field);
/* 460 */               } catch (NumberFormatException nfe2) {
/* 461 */                 ret = FieldCacheImpl.this.getStringIndex(reader, field);
/*     */               } 
/*     */             } 
/*     */           } else {
/* 465 */             throw new RuntimeException(""field \"""" + field + ""\"" does not appear to be indexed"");
/*     */           } 
/* 467 */           return ret;
/*     */         } finally {
/* 469 */           enumerator.close();
/*     */         } 
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 477 */   public Comparable[] getCustom(IndexReader reader, String field, SortComparator comparator) throws IOException { return (Comparable[])this.customCache.get(reader, new Entry(field, comparator)); }
/*     */ 
/*     */   
/* 480 */   Cache customCache = new Cache() {
/*     */       private final FieldCacheImpl this$0;
/*     */       
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/* 484 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 485 */         String field = entry.field;
/* 486 */         SortComparator comparator = (SortComparator)entry.custom;
/* 487 */         Comparable[] retArray = new Comparable[reader.maxDoc()];
/* 488 */         TermDocs termDocs = reader.termDocs();
/* 489 */         TermEnum termEnum = reader.terms(new Term(field, """"));
/*     */         try {
/*     */           do {
/* 492 */             Term term = termEnum.term();
/* 493 */             if (term == null || term.field() != field)
/* 494 */               break;  Comparable termval = comparator.getComparable(term.text());
/* 495 */             termDocs.seek(termEnum);
/* 496 */             while (termDocs.next()) {
/* 497 */               retArray[termDocs.doc()] = termval;
/*     */             }
/* 499 */           } while (termEnum.next());
/*     */         } finally {
/* 501 */           termDocs.close();
/* 502 */           termEnum.close();
/*     */         } 
/* 504 */         return retArray;
/*     */       }
/*     */     };
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FieldCacheImpl.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldDoc,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FieldDoc
/*    */   extends ScoreDoc
/*    */ {
/*    */   public Comparable[] fields;
/*    */   
/* 56 */   public FieldDoc(int doc, float score) { super(doc, score); }
/*    */ 
/*    */ 
/*    */   
/*    */   public FieldDoc(int doc, float score, Comparable[] fields) {
/* 61 */     super(doc, score);
/* 62 */     this.fields = fields;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FieldDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldDocSortedHitQueue,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.text.Collator;
/*     */ import java.util.Locale;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class FieldDocSortedHitQueue
/*     */   extends PriorityQueue
/*     */ {
/*     */   volatile SortField[] fields;
/*     */   volatile Collator[] collators;
/*     */   
/*     */   FieldDocSortedHitQueue(SortField[] fields, int size) {
/*  53 */     this.fields = fields;
/*  54 */     this.collators = hasCollators(fields);
/*  55 */     initialize(size);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   synchronized void setFields(SortField[] fields) {
/*  68 */     if (this.fields == null) {
/*  69 */       this.fields = fields;
/*  70 */       this.collators = hasCollators(fields);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   SortField[] getFields() { return this.fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private Collator[] hasCollators(SortField[] fields) {
/*  87 */     if (fields == null) return null; 
/*  88 */     Collator[] ret = new Collator[fields.length];
/*  89 */     for (int i = 0; i < fields.length; i++) {
/*  90 */       Locale locale = fields[i].getLocale();
/*  91 */       if (locale != null)
/*  92 */         ret[i] = Collator.getInstance(locale); 
/*     */     } 
/*  94 */     return ret;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final boolean lessThan(Object a, Object b) {
/* 105 */     FieldDoc docA = (FieldDoc)a;
/* 106 */     FieldDoc docB = (FieldDoc)b;
/* 107 */     int n = this.fields.length;
/* 108 */     int c = 0;
/* 109 */     for (int i = 0; i < n && c == 0; i++) {
/* 110 */       float f2, f1; String s2, s1; int i2, i1; float r2, r1; int type = this.fields[i].getType();
/* 111 */       switch (type) {
/*     */         case 0:
/* 113 */           r1 = ((Float)docA.fields[i]).floatValue();
/* 114 */           r2 = ((Float)docB.fields[i]).floatValue();
/* 115 */           if (r1 > r2) c = -1; 
/* 116 */           if (r1 < r2) c = 1; 
/*     */           break;
/*     */         case 1:
/*     */         case 4:
/* 120 */           i1 = ((Integer)docA.fields[i]).intValue();
/* 121 */           i2 = ((Integer)docB.fields[i]).intValue();
/* 122 */           if (i1 < i2) c = -1; 
/* 123 */           if (i1 > i2) c = 1; 
/*     */           break;
/*     */         case 3:
/* 126 */           s1 = (String)docA.fields[i];
/* 127 */           s2 = (String)docB.fields[i];
/*     */ 
/*     */ 
/*     */           
/* 131 */           if (s1 == null) { c = (s2 == null) ? 0 : -1; break; }
/* 132 */            if (s2 == null) { c = 1; break; }
/* 133 */            if (this.fields[i].getLocale() == null) {
/* 134 */             c = s1.compareTo(s2); break;
/*     */           } 
/* 136 */           c = this.collators[i].compare(s1, s2);
/*     */           break;
/*     */         
/*     */         case 5:
/* 140 */           f1 = ((Float)docA.fields[i]).floatValue();
/* 141 */           f2 = ((Float)docB.fields[i]).floatValue();
/* 142 */           if (f1 < f2) c = -1; 
/* 143 */           if (f1 > f2) c = 1; 
/*     */           break;
/*     */         case 9:
/* 146 */           c = docA.fields[i].compareTo(docB.fields[i]);
/*     */           break;
/*     */ 
/*     */ 
/*     */ 
/*     */         
/*     */         case 2:
/* 153 */           throw new RuntimeException(""FieldDocSortedHitQueue cannot use an AUTO SortField"");
/*     */         default:
/* 155 */           throw new RuntimeException(""invalid SortField type: "" + type);
/*     */       } 
/* 157 */       if (this.fields[i].getReverse()) {
/* 158 */         c = -c;
/*     */       }
/*     */     } 
/*     */ 
/*     */     
/* 163 */     if (c == 0) {
/* 164 */       return (docA.doc > docB.doc);
/*     */     }
/* 166 */     return (c > 0);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FieldDocSortedHitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FieldSortedHitQueue,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.text.Collator;
/*     */ import java.util.Locale;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FieldSortedHitQueue
/*     */   extends PriorityQueue
/*     */ {
/*     */   protected ScoreDocComparator[] comparators;
/*     */   protected SortField[] fields;
/*     */   
/*     */   public FieldSortedHitQueue(IndexReader reader, SortField[] fields, int size) throws IOException {
/*  51 */     int n = fields.length;
/*  52 */     this.comparators = new ScoreDocComparator[n];
/*  53 */     this.fields = new SortField[n];
/*  54 */     for (int i = 0; i < n; i++) {
/*  55 */       String fieldname = fields[i].getField();
/*  56 */       this.comparators[i] = getCachedComparator(reader, fieldname, fields[i].getType(), fields[i].getLocale(), fields[i].getFactory());
/*     */       
/*  58 */       if (this.comparators[i].sortType() == 3) {
/*  59 */         this.fields[i] = new SortField(fieldname, fields[i].getLocale(), fields[i].getReverse());
/*     */       } else {
/*  61 */         this.fields[i] = new SortField(fieldname, this.comparators[i].sortType(), fields[i].getReverse());
/*     */       } 
/*     */     } 
/*  64 */     initialize(size);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  75 */   protected float maxscore = Float.NEGATIVE_INFINITY;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   public float getMaxScore() { return this.maxscore; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean insert(FieldDoc fdoc) {
/*  87 */     this.maxscore = Math.max(this.maxscore, fdoc.score);
/*  88 */     return super.insert(fdoc);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public boolean insert(Object fdoc) { return insert((FieldDoc)fdoc); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected boolean lessThan(Object a, Object b) {
/* 105 */     ScoreDoc docA = (ScoreDoc)a;
/* 106 */     ScoreDoc docB = (ScoreDoc)b;
/*     */ 
/*     */     
/* 109 */     int n = this.comparators.length;
/* 110 */     int c = 0;
/* 111 */     for (int i = 0; i < n && c == 0; i++) {
/* 112 */       c = (this.fields[i]).reverse ? this.comparators[i].compare(docB, docA) : this.comparators[i].compare(docA, docB);
/*     */     }
/*     */ 
/*     */     
/* 116 */     if (c == 0)
/* 117 */       return (docA.doc > docB.doc); 
/* 118 */     return (c > 0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   FieldDoc fillFields(FieldDoc doc) {
/* 133 */     int n = this.comparators.length;
/* 134 */     Comparable[] fields = new Comparable[n];
/* 135 */     for (int i = 0; i < n; i++)
/* 136 */       fields[i] = this.comparators[i].sortValue(doc); 
/* 137 */     doc.fields = fields;
/*     */     
/* 139 */     return doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   SortField[] getFields() { return this.fields; }
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator getCachedComparator(IndexReader reader, String field, int type, Locale locale, SortComparatorSource factory) throws IOException {
/* 150 */     if (type == 1) return ScoreDocComparator.INDEXORDER; 
/* 151 */     if (type == 0) return ScoreDocComparator.RELEVANCE; 
/* 152 */     FieldCacheImpl.Entry entry = (factory != null) ? new FieldCacheImpl.Entry(field, factory) : new FieldCacheImpl.Entry(field, type, locale);
/*     */ 
/*     */     
/* 155 */     return (ScoreDocComparator)Comparators.get(reader, entry);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 160 */   static final FieldCacheImpl.Cache Comparators = new FieldCacheImpl.Cache()
/*     */     {
/*     */       protected Object createValue(IndexReader reader, Object entryKey) throws IOException {
/*     */         ScoreDocComparator comparator;
/* 164 */         FieldCacheImpl.Entry entry = (FieldCacheImpl.Entry)entryKey;
/* 165 */         String fieldname = entry.field;
/* 166 */         int type = entry.type;
/* 167 */         Locale locale = entry.locale;
/* 168 */         SortComparatorSource factory = (SortComparatorSource)entry.custom;
/*     */         
/* 170 */         switch (type) {
/*     */           case 2:
/* 172 */             comparator = FieldSortedHitQueue.comparatorAuto(reader, fieldname);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 190 */             return comparator;case 4: comparator = FieldSortedHitQueue.comparatorInt(reader, fieldname); return comparator;case 5: comparator = FieldSortedHitQueue.comparatorFloat(reader, fieldname); return comparator;case 3: if (locale != null) { comparator = FieldSortedHitQueue.comparatorStringLocale(reader, fieldname, locale); } else { comparator = FieldSortedHitQueue.comparatorString(reader, fieldname); }  return comparator;case 9: comparator = factory.newComparator(reader, fieldname); return comparator;
/*     */         } 
/*     */         throw new RuntimeException(""unknown field type: "" + type);
/*     */       }
/*     */     };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorInt(IndexReader reader, String fieldname) throws IOException {
/* 203 */     String field = fieldname.intern();
/* 204 */     final int[] fieldOrder = FieldCache.DEFAULT.getInts(reader, field);
/* 205 */     return new ScoreDocComparator() { private final int[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 208 */           int fi = fieldOrder[i.doc];
/* 209 */           int fj = fieldOrder[j.doc];
/* 210 */           if (fi < fj) return -1; 
/* 211 */           if (fi > fj) return 1; 
/* 212 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 216 */         public Comparable sortValue(ScoreDoc i) { return new Integer(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 220 */         public int sortType() { return 4; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorFloat(IndexReader reader, String fieldname) throws IOException {
/* 234 */     String field = fieldname.intern();
/* 235 */     final float[] fieldOrder = FieldCache.DEFAULT.getFloats(reader, field);
/* 236 */     return new ScoreDocComparator() { private final float[] val$fieldOrder;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 239 */           float fi = fieldOrder[i.doc];
/* 240 */           float fj = fieldOrder[j.doc];
/* 241 */           if (fi < fj) return -1; 
/* 242 */           if (fi > fj) return 1; 
/* 243 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 247 */         public Comparable sortValue(ScoreDoc i) { return new Float(fieldOrder[i.doc]); }
/*     */ 
/*     */ 
/*     */         
/* 251 */         public int sortType() { return 5; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorString(IndexReader reader, String fieldname) throws IOException {
/* 265 */     String field = fieldname.intern();
/* 266 */     final FieldCache.StringIndex index = FieldCache.DEFAULT.getStringIndex(reader, field);
/* 267 */     return new ScoreDocComparator() { private final FieldCache.StringIndex val$index;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 270 */           int fi = index.order[i.doc];
/* 271 */           int fj = index.order[j.doc];
/* 272 */           if (fi < fj) return -1; 
/* 273 */           if (fi > fj) return 1; 
/* 274 */           return 0;
/*     */         }
/*     */ 
/*     */         
/* 278 */         public Comparable sortValue(ScoreDoc i) { return index.lookup[index.order[i.doc]]; }
/*     */ 
/*     */ 
/*     */         
/* 282 */         public int sortType() { return 3; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorStringLocale(IndexReader reader, String fieldname, Locale locale) throws IOException {
/* 296 */     final Collator collator = Collator.getInstance(locale);
/* 297 */     String field = fieldname.intern();
/* 298 */     final String[] index = FieldCache.DEFAULT.getStrings(reader, field);
/* 299 */     return new ScoreDocComparator() { private final String[] val$index; private final Collator val$collator;
/*     */         
/*     */         public final int compare(ScoreDoc i, ScoreDoc j) {
/* 302 */           String is = index[i.doc];
/* 303 */           String js = index[j.doc];
/* 304 */           if (is == js)
/* 305 */             return 0; 
/* 306 */           if (is == null)
/* 307 */             return -1; 
/* 308 */           if (js == null) {
/* 309 */             return 1;
/*     */           }
/* 311 */           return collator.compare(is, js);
/*     */         }
/*     */ 
/*     */ 
/*     */         
/* 316 */         public Comparable sortValue(ScoreDoc i) { return index[i.doc]; }
/*     */ 
/*     */ 
/*     */         
/* 320 */         public int sortType() { return 3; } }
/*     */       ;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static ScoreDocComparator comparatorAuto(IndexReader reader, String fieldname) throws IOException {
/* 337 */     String field = fieldname.intern();
/* 338 */     Object lookupArray = FieldCache.DEFAULT.getAuto(reader, field);
/* 339 */     if (lookupArray instanceof FieldCache.StringIndex)
/* 340 */       return comparatorString(reader, field); 
/* 341 */     if (lookupArray instanceof int[])
/* 342 */       return comparatorInt(reader, field); 
/* 343 */     if (lookupArray instanceof float[])
/* 344 */       return comparatorFloat(reader, field); 
/* 345 */     if (lookupArray instanceof String[]) {
/* 346 */       return comparatorString(reader, field);
/*     */     }
/* 348 */     throw new RuntimeException(""unknown data type in field '"" + field + ""'"");
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FieldSortedHitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Filter,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import java.util.BitSet;
import org.apache.lucene.index.IndexReader;
public abstract class Filter implements Serializable {
  public abstract BitSet bits(IndexReader paramIndexReader) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Filter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilteredQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilteredQuery
/*     */   extends Query
/*     */ {
/*     */   Query query;
/*     */   Filter filter;
/*     */   
/*     */   public FilteredQuery(Query query, Filter filter) {
/*  55 */     this.query = query;
/*  56 */     this.filter = filter;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Weight createWeight(Searcher searcher) throws IOException {
/*  66 */     final Weight weight = this.query.createWeight(searcher);
/*  67 */     final Similarity similarity = this.query.getSimilarity(searcher);
/*  68 */     return new Weight() { private float value; private final Weight val$weight;
/*     */         private final Similarity val$similarity;
/*     */         private final FilteredQuery this$0;
/*     */         
/*  72 */         public float getValue() { return this.value; }
/*     */         
/*  74 */         public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights() * FilteredQuery.this.getBoost() * FilteredQuery.this.getBoost(); }
/*     */         
/*     */         public void normalize(float v) {
/*  77 */           weight.normalize(v);
/*  78 */           this.value = weight.getValue() * FilteredQuery.this.getBoost();
/*     */         }
/*     */         public Explanation explain(IndexReader ir, int i) throws IOException {
/*  81 */           Explanation inner = weight.explain(ir, i);
/*  82 */           if (FilteredQuery.this.getBoost() != 1.0F) {
/*  83 */             Explanation preBoost = inner;
/*  84 */             inner = new Explanation(inner.getValue() * FilteredQuery.this.getBoost(), ""product of:"");
/*  85 */             inner.addDetail(new Explanation(FilteredQuery.this.getBoost(), ""boost""));
/*  86 */             inner.addDetail(preBoost);
/*     */           } 
/*  88 */           Filter f = FilteredQuery.this.filter;
/*  89 */           BitSet matches = f.bits(ir);
/*  90 */           if (matches.get(i))
/*  91 */             return inner; 
/*  92 */           Explanation result = new Explanation(0.0F, ""failure to match filter: "" + f.toString());
/*     */           
/*  94 */           result.addDetail(inner);
/*  95 */           return result;
/*     */         }
/*     */ 
/*     */         
/*  99 */         public Query getQuery() { return FilteredQuery.this; }
/*     */ 
/*     */         
/*     */         public Scorer scorer(IndexReader indexReader) throws IOException {
/* 103 */           final Scorer scorer = weight.scorer(indexReader);
/* 104 */           final BitSet bitset = FilteredQuery.this.filter.bits(indexReader);
/* 105 */           return new Scorer(similarity) { private final Scorer val$scorer;
/*     */               
/*     */               public boolean next() throws IOException {
/*     */                 do {
/* 109 */                   if (!scorer.next()) {
/* 110 */                     return false;
/*     */                   }
/* 112 */                 } while (!bitset.get(scorer.doc()));
/*     */ 
/*     */ 
/*     */ 
/*     */                 
/* 117 */                 return true;
/*     */               } private final BitSet val$bitset; private final FilteredQuery.null this$1;
/* 119 */               public int doc() { return scorer.doc(); }
/*     */               
/*     */               public boolean skipTo(int i) throws IOException {
/* 122 */                 if (!scorer.skipTo(i)) {
/* 123 */                   return false;
/*     */                 }
/* 125 */                 while (!bitset.get(scorer.doc())) {
/* 126 */                   int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);
/* 127 */                   if (nextFiltered == -1)
/* 128 */                     return false; 
/* 129 */                   if (!scorer.skipTo(nextFiltered)) {
/* 130 */                     return false;
/*     */                   }
/*     */                 } 
/* 133 */                 return true;
/*     */               }
/*     */               
/* 136 */               public float score() throws IOException { return FilteredQuery.null.access$000(FilteredQuery.null.this).getBoost() * scorer.score(); }
/*     */ 
/*     */               
/*     */               public Explanation explain(int i) throws IOException {
/* 140 */                 Explanation exp = scorer.explain(i);
/* 141 */                 exp.setValue(FilteredQuery.null.access$000(FilteredQuery.null.this).getBoost() * exp.getValue());
/*     */                 
/* 143 */                 if (bitset.get(i)) {
/* 144 */                   exp.setDescription(""allowed by filter: "" + exp.getDescription());
/*     */                 } else {
/* 146 */                   exp.setDescription(""removed by filter: "" + exp.getDescription());
/* 147 */                 }  return exp;
/*     */               } }
/*     */             ;
/*     */         } }
/*     */       ;
/*     */   }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 156 */     Query rewritten = this.query.rewrite(reader);
/* 157 */     if (rewritten != this.query) {
/* 158 */       FilteredQuery clone = (FilteredQuery)clone();
/* 159 */       clone.query = rewritten;
/* 160 */       return clone;
/*     */     } 
/* 162 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 167 */   public Query getQuery() { return this.query; }
/*     */ 
/*     */ 
/*     */   
/* 171 */   public Filter getFilter() { return this.filter; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 176 */   public void extractTerms(Set terms) { getQuery().extractTerms(terms); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String s) {
/* 181 */     StringBuffer buffer = new StringBuffer();
/* 182 */     buffer.append(""filtered("");
/* 183 */     buffer.append(this.query.toString(s));
/* 184 */     buffer.append("")->"");
/* 185 */     buffer.append(this.filter);
/* 186 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 187 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 192 */     if (o instanceof FilteredQuery) {
/* 193 */       FilteredQuery fq = (FilteredQuery)o;
/* 194 */       return (this.query.equals(fq.query) && this.filter.equals(fq.filter) && getBoost() == fq.getBoost());
/*     */     } 
/* 196 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 201 */   public int hashCode() { return this.query.hashCode() ^ this.filter.hashCode() + Float.floatToRawIntBits(getBoost()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FilteredQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilteredTermEnum,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.index.TermEnum;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class FilteredTermEnum
/*    */   extends TermEnum
/*    */ {
/* 29 */   private Term currentTerm = null;
/* 30 */   private TermEnum actualEnum = null;
/*    */ 
/*    */ 
/*    */   
/*    */   protected abstract boolean termCompare(Term paramTerm);
/*    */ 
/*    */   
/*    */   public abstract float difference();
/*    */ 
/*    */   
/*    */   protected abstract boolean endEnum();
/*    */ 
/*    */   
/*    */   protected void setEnum(TermEnum actualEnum) throws IOException {
/* 44 */     this.actualEnum = actualEnum;
/*    */     
/* 46 */     Term term = actualEnum.term();
/* 47 */     if (term != null && termCompare(term))
/* 48 */     { this.currentTerm = term; }
/* 49 */     else { next(); }
/*    */   
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public int docFreq() {
/* 57 */     if (this.actualEnum == null) return -1; 
/* 58 */     return this.actualEnum.docFreq();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean next() throws IOException {
/* 63 */     if (this.actualEnum == null) return false; 
/* 64 */     this.currentTerm = null;
/* 65 */     while (this.currentTerm == null) {
/* 66 */       if (endEnum()) return false; 
/* 67 */       if (this.actualEnum.next()) {
/* 68 */         Term term = this.actualEnum.term();
/* 69 */         if (termCompare(term)) {
/* 70 */           this.currentTerm = term;
/* 71 */           return true;
/*    */         }  continue;
/*    */       } 
/* 74 */       return false;
/*    */     } 
/* 76 */     this.currentTerm = null;
/* 77 */     return false;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 83 */   public Term term() { return this.currentTerm; }
/*    */ 
/*    */ 
/*    */   
/*    */   public void close() throws IOException {
/* 88 */     this.actualEnum.close();
/* 89 */     this.currentTerm = null;
/* 90 */     this.actualEnum = null;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FilteredTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FilterManager,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.util.Comparator;
/*     */ import java.util.Date;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.Map;
/*     */ import java.util.TreeSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FilterManager
/*     */ {
/*     */   protected static FilterManager manager;
/*     */   protected static final int DEFAULT_CACHE_CLEAN_SIZE = 100;
/*     */   protected static final long DEFAULT_CACHE_SLEEP_TIME = 600000L;
/*     */   protected Map cache;
/*     */   protected int cacheCleanSize;
/*     */   protected long cleanSleepTime;
/*     */   protected FilterCleaner filterCleaner;
/*     */   
/*     */   public static synchronized FilterManager getInstance() {
/*  59 */     if (manager == null) {
/*  60 */       manager = new FilterManager();
/*     */     }
/*  62 */     return manager;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected FilterManager() {
/*  69 */     this.cache = new HashMap();
/*  70 */     this.cacheCleanSize = 100;
/*  71 */     this.cleanSleepTime = 600000L;
/*     */     
/*  73 */     this.filterCleaner = new FilterCleaner();
/*  74 */     Thread fcThread = new Thread(this.filterCleaner);
/*     */     
/*  76 */     fcThread.setDaemon(true);
/*  77 */     fcThread.start();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  85 */   public void setCacheSize(int cacheCleanSize) { this.cacheCleanSize = cacheCleanSize; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  93 */   public void setCleanThreadSleepTime(long cleanSleepTime) { this.cleanSleepTime = cleanSleepTime; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Filter getFilter(Filter filter) {
/* 105 */     synchronized (this.cache) {
/* 106 */       FilterItem fi = null;
/* 107 */       fi = (FilterItem)this.cache.get(new Integer(filter.hashCode()));
/* 108 */       if (fi != null) {
/* 109 */         fi.timestamp = (new Date()).getTime();
/* 110 */         return fi.filter;
/*     */       } 
/* 112 */       this.cache.put(new Integer(filter.hashCode()), new FilterItem(filter));
/* 113 */       return filter;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   protected class FilterItem
/*     */   {
/*     */     public Filter filter;
/*     */     
/*     */     public long timestamp;
/*     */     
/*     */     private final FilterManager this$0;
/*     */     
/*     */     public FilterItem(Filter filter) {
/* 127 */       this.filter = filter;
/* 128 */       this.timestamp = (new Date()).getTime();
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected class FilterCleaner
/*     */     implements Runnable
/*     */   {
/*     */     private boolean running = true;
/*     */ 
/*     */ 
/*     */     
/*     */     private TreeSet sortedFilterItems;
/*     */ 
/*     */ 
/*     */     
/*     */     private final FilterManager this$0;
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public FilterCleaner() {
/* 153 */       this.sortedFilterItems = new TreeSet(new Comparator() { private final FilterManager val$this$0;
/*     */             public int compare(Object a, Object b) {
/* 155 */               if (a instanceof Map.Entry && b instanceof Map.Entry) {
/* 156 */                 FilterManager.FilterItem fia = (FilterManager.FilterItem)((Map.Entry)a).getValue();
/* 157 */                 FilterManager.FilterItem fib = (FilterManager.FilterItem)((Map.Entry)b).getValue();
/* 158 */                 if (fia.timestamp == fib.timestamp) {
/* 159 */                   return 0;
/*     */                 }
/*     */                 
/* 162 */                 if (fia.timestamp < fib.timestamp) {
/* 163 */                   return -1;
/*     */                 }
/*     */                 
/* 166 */                 return 1;
/*     */               } 
/* 168 */               throw new ClassCastException(""Objects are not Map.Entry"");
/*     */             }
/*     */             private final FilterManager.FilterCleaner this$1; }
/*     */         );
/*     */     }
/*     */     
/*     */     public void run() {
/* 175 */       while (this.running) {
/*     */ 
/*     */ 
/*     */         
/* 179 */         if (FilterManager.this.cache.size() > FilterManager.this.cacheCleanSize) {
/*     */           
/* 181 */           this.sortedFilterItems.clear();
/* 182 */           synchronized (FilterManager.this.cache) {
/* 183 */             this.sortedFilterItems.addAll(FilterManager.this.cache.entrySet());
/* 184 */             Iterator it = this.sortedFilterItems.iterator();
/* 185 */             int numToDelete = (int)((FilterManager.this.cache.size() - FilterManager.this.cacheCleanSize) * 1.5D);
/* 186 */             int counter = 0;
/*     */             
/* 188 */             while (it.hasNext() && counter++ < numToDelete) {
/* 189 */               Map.Entry entry = it.next();
/* 190 */               FilterManager.this.cache.remove(entry.getKey());
/*     */             } 
/*     */           } 
/*     */           
/* 194 */           this.sortedFilterItems.clear();
/*     */         } 
/*     */         
/*     */         try {
/* 198 */           Thread.sleep(FilterManager.this.cleanSleepTime);
/* 199 */         } catch (InterruptedException e) {}
/*     */       } 
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FilterManager.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FuzzyQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FuzzyQuery
/*     */   extends MultiTermQuery
/*     */ {
/*     */   public static final float defaultMinSimilarity = 0.5F;
/*     */   public static final int defaultPrefixLength = 0;
/*     */   private float minimumSimilarity;
/*     */   private int prefixLength;
/*     */   
/*     */   public FuzzyQuery(Term term, float minimumSimilarity, int prefixLength) throws IllegalArgumentException {
/*  55 */     super(term);
/*     */     
/*  57 */     if (minimumSimilarity >= 1.0F)
/*  58 */       throw new IllegalArgumentException(""minimumSimilarity >= 1""); 
/*  59 */     if (minimumSimilarity < 0.0F)
/*  60 */       throw new IllegalArgumentException(""minimumSimilarity < 0""); 
/*  61 */     if (prefixLength < 0) {
/*  62 */       throw new IllegalArgumentException(""prefixLength < 0"");
/*     */     }
/*  64 */     this.minimumSimilarity = minimumSimilarity;
/*  65 */     this.prefixLength = prefixLength;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  72 */   public FuzzyQuery(Term term, float minimumSimilarity) throws IllegalArgumentException { this(term, minimumSimilarity, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  79 */   public FuzzyQuery(Term term) { this(term, 0.5F, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  87 */   public float getMinSimilarity() { return this.minimumSimilarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   public int getPrefixLength() { return this.prefixLength; }
/*     */ 
/*     */ 
/*     */   
/* 100 */   protected FilteredTermEnum getEnum(IndexReader reader) throws IOException { return new FuzzyTermEnum(reader, getTerm(), this.minimumSimilarity, this.prefixLength); }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 104 */     FilteredTermEnum enumerator = getEnum(reader);
/* 105 */     int maxClauseCount = BooleanQuery.getMaxClauseCount();
/* 106 */     ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);
/*     */     
/*     */     try {
/*     */       do {
/* 110 */         float minScore = 0.0F;
/* 111 */         float score = 0.0F;
/* 112 */         Term t = enumerator.term();
/* 113 */         if (t == null)
/* 114 */           continue;  score = enumerator.difference();
/*     */ 
/*     */         
/* 117 */         if (stQueue.size() >= maxClauseCount && score <= minScore)
/* 118 */           continue;  stQueue.insert(new ScoreTerm(t, score));
/* 119 */         minScore = ((ScoreTerm)stQueue.top()).score;
/*     */       
/*     */       }
/* 122 */       while (enumerator.next());
/*     */     } finally {
/* 124 */       enumerator.close();
/*     */     } 
/*     */     
/* 127 */     BooleanQuery query = new BooleanQuery(true);
/* 128 */     int size = stQueue.size();
/* 129 */     for (int i = 0; i < size; i++) {
/* 130 */       ScoreTerm st = (ScoreTerm)stQueue.pop();
/* 131 */       TermQuery tq = new TermQuery(st.term);
/* 132 */       tq.setBoost(getBoost() * st.score);
/* 133 */       query.add(tq, BooleanClause.Occur.SHOULD);
/*     */     } 
/*     */     
/* 136 */     return query;
/*     */   }
/*     */   
/*     */   public String toString(String field) {
/* 140 */     StringBuffer buffer = new StringBuffer();
/* 141 */     Term term = getTerm();
/* 142 */     if (!term.field().equals(field)) {
/* 143 */       buffer.append(term.field());
/* 144 */       buffer.append("":"");
/*     */     } 
/* 146 */     buffer.append(term.text());
/* 147 */     buffer.append('~');
/* 148 */     buffer.append(Float.toString(this.minimumSimilarity));
/* 149 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 150 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   protected static class ScoreTerm {
/*     */     public Term term;
/*     */     public float score;
/*     */     
/*     */     public ScoreTerm(Term term, float score) {
/* 158 */       this.term = term;
/* 159 */       this.score = score;
/*     */     }
/*     */   }
/*     */   
/*     */   protected static class ScoreTermQueue
/*     */     extends PriorityQueue
/*     */   {
/* 166 */     public ScoreTermQueue(int size) { initialize(size); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected boolean lessThan(Object a, Object b) {
/* 173 */       FuzzyQuery.ScoreTerm termA = (FuzzyQuery.ScoreTerm)a;
/* 174 */       FuzzyQuery.ScoreTerm termB = (FuzzyQuery.ScoreTerm)b;
/* 175 */       if (termA.score == termB.score) {
/* 176 */         return (termA.term.compareTo(termB.term) > 0);
/*     */       }
/* 178 */       return (termA.score < termB.score);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 184 */     if (this == o) return true; 
/* 185 */     if (!(o instanceof FuzzyQuery)) return false; 
/* 186 */     if (!super.equals(o)) return false;
/*     */     
/* 188 */     FuzzyQuery fuzzyQuery = (FuzzyQuery)o;
/*     */     
/* 190 */     if (this.minimumSimilarity != fuzzyQuery.minimumSimilarity) return false; 
/* 191 */     if (this.prefixLength != fuzzyQuery.prefixLength) return false;
/*     */     
/* 193 */     return true;
/*     */   }
/*     */   
/*     */   public int hashCode() {
/* 197 */     int result = super.hashCode();
/* 198 */     result = ((29 * result) + this.minimumSimilarity != 0.0F) ? Float.floatToIntBits(this.minimumSimilarity) : 0;
/* 199 */     result = 29 * result + this.prefixLength;
/* 200 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FuzzyQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.FuzzyTermEnum,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class FuzzyTermEnum
/*     */   extends FilteredTermEnum
/*     */ {
/*     */   private static final int TYPICAL_LONGEST_WORD_IN_INDEX = 19;
/*     */   private int[][] d;
/*     */   private float similarity;
/*     */   private boolean endEnum = false;
/*  47 */   private Term searchTerm = null;
/*     */   
/*     */   private final String field;
/*     */   private final String text;
/*     */   private final String prefix;
/*     */   private final float minimumSimilarity;
/*     */   private final float scale_factor;
/*  54 */   private final int[] maxDistances = new int[19];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public FuzzyTermEnum(IndexReader reader, Term term) throws IOException { this(reader, term, 0.5F, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity) throws IOException { this(reader, term, minSimilarity, 0); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity, int prefixLength) throws IOException {
/* 104 */     if (minSimilarity >= 1.0F)
/* 105 */       throw new IllegalArgumentException(""minimumSimilarity cannot be greater than or equal to 1""); 
/* 106 */     if (minSimilarity < 0.0F)
/* 107 */       throw new IllegalArgumentException(""minimumSimilarity cannot be less than 0""); 
/* 108 */     if (prefixLength < 0) {
/* 109 */       throw new IllegalArgumentException(""prefixLength cannot be less than 0"");
/*     */     }
/* 111 */     this.minimumSimilarity = minSimilarity;
/* 112 */     this.scale_factor = 1.0F / (1.0F - this.minimumSimilarity);
/* 113 */     this.searchTerm = term;
/* 114 */     this.field = this.searchTerm.field();
/*     */ 
/*     */ 
/*     */     
/* 118 */     int fullSearchTermLength = this.searchTerm.text().length();
/* 119 */     int realPrefixLength = (prefixLength > fullSearchTermLength) ? fullSearchTermLength : prefixLength;
/*     */     
/* 121 */     this.text = this.searchTerm.text().substring(realPrefixLength);
/* 122 */     this.prefix = this.searchTerm.text().substring(0, realPrefixLength);
/*     */     
/* 124 */     initializeMaxDistances();
/* 125 */     this.d = initDistanceArray();
/*     */     
/* 127 */     setEnum(reader.terms(new Term(this.searchTerm.field(), this.prefix)));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final boolean termCompare(Term term) {
/* 135 */     if (this.field == term.field() && term.text().startsWith(this.prefix)) {
/* 136 */       String target = term.text().substring(this.prefix.length());
/* 137 */       this.similarity = similarity(target);
/* 138 */       return (this.similarity > this.minimumSimilarity);
/*     */     } 
/* 140 */     this.endEnum = true;
/* 141 */     return false;
/*     */   }
/*     */ 
/*     */   
/* 145 */   public final float difference() { return (this.similarity - this.minimumSimilarity) * this.scale_factor; }
/*     */ 
/*     */ 
/*     */   
/* 149 */   public final boolean endEnum() { return this.endEnum; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static final int min(int a, int b, int c) {
/* 160 */     int t = (a < b) ? a : b;
/* 161 */     return (t < c) ? t : c;
/*     */   }
/*     */ 
/*     */   
/* 165 */   private final int[][] initDistanceArray() { return new int[this.text.length() + 1][19]; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final synchronized float similarity(String target) {
/* 206 */     int m = target.length();
/* 207 */     int n = this.text.length();
/* 208 */     if (n == 0)
/*     */     {
/*     */       
/* 211 */       return (this.prefix.length() == 0) ? 0.0F : (1.0F - m / this.prefix.length());
/*     */     }
/* 213 */     if (m == 0) {
/* 214 */       return (this.prefix.length() == 0) ? 0.0F : (1.0F - n / this.prefix.length());
/*     */     }
/*     */     
/* 217 */     int maxDistance = getMaxDistance(m);
/*     */     
/* 219 */     if (maxDistance < Math.abs(m - n))
/*     */     {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 227 */       return 0.0F;
/*     */     }
/*     */ 
/*     */     
/* 231 */     if ((this.d[0]).length <= m) {
/* 232 */       growDistanceArray(m);
/*     */     }
/*     */ 
/*     */     
/* 236 */     for (int i = 0; i <= n; ) { this.d[i][0] = i; i++; }
/* 237 */      for (int j = 0; j <= m; ) { this.d[0][j] = j; j++; }
/*     */ 
/*     */     
/* 240 */     for (int i = 1; i <= n; i++) {
/* 241 */       int bestPossibleEditDistance = m;
/* 242 */       char s_i = this.text.charAt(i - 1);
/* 243 */       for (int j = 1; j <= m; j++) {
/* 244 */         if (s_i != target.charAt(j - 1)) {
/* 245 */           this.d[i][j] = min(this.d[i - 1][j], this.d[i][j - 1], this.d[i - 1][j - 1]) + 1;
/*     */         } else {
/*     */           
/* 248 */           this.d[i][j] = min(this.d[i - 1][j] + 1, this.d[i][j - 1] + 1, this.d[i - 1][j - 1]);
/*     */         } 
/* 250 */         bestPossibleEditDistance = Math.min(bestPossibleEditDistance, this.d[i][j]);
/*     */       } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 257 */       if (i > maxDistance && bestPossibleEditDistance > maxDistance)
/*     */       {
/*     */         
/* 260 */         return 0.0F;
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 269 */     return 1.0F - this.d[n][m] / (this.prefix.length() + Math.min(n, m));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void growDistanceArray(int m) {
/* 277 */     for (int i = 0; i < this.d.length; i++) {
/* 278 */       this.d[i] = new int[m + 1];
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 290 */   private final int getMaxDistance(int m) { return (m < this.maxDistances.length) ? this.maxDistances[m] : calculateMaxDistance(m); }
/*     */ 
/*     */   
/*     */   private void initializeMaxDistances() {
/* 294 */     for (int i = 0; i < this.maxDistances.length; i++) {
/* 295 */       this.maxDistances[i] = calculateMaxDistance(i);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 300 */   private int calculateMaxDistance(int m) { return (int)((1.0F - this.minimumSimilarity) * (Math.min(this.text.length(), m) + this.prefix.length())); }
/*     */ 
/*     */ 
/*     */   
/* 304 */   public void close() throws IOException { super.close(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\FuzzyTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Hit,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Hit
/*     */   implements Serializable
/*     */ {
/*  33 */   private Document doc = null;
/*     */   
/*     */   private boolean resolved = false;
/*     */   
/*  37 */   private Hits hits = null;
/*     */ 
/*     */ 
/*     */   
/*     */   private int hitNumber;
/*     */ 
/*     */ 
/*     */   
/*     */   Hit(Hits hits, int hitNumber) {
/*  46 */     this.hits = hits;
/*  47 */     this.hitNumber = hitNumber;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Document getDocument() throws CorruptIndexException, IOException {
/*  58 */     if (!this.resolved) fetchTheHit(); 
/*  59 */     return this.doc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public float getScore() throws IOException { return this.hits.score(this.hitNumber); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  77 */   public int getId() throws IOException { return this.hits.id(this.hitNumber); }
/*     */ 
/*     */   
/*     */   private void fetchTheHit() throws CorruptIndexException, IOException {
/*  81 */     this.doc = this.hits.doc(this.hitNumber);
/*  82 */     this.resolved = true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public float getBoost() throws CorruptIndexException, IOException { return getDocument().getBoost(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public String get(String name) throws CorruptIndexException, IOException { return getDocument().get(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString() {
/* 116 */     StringBuffer buffer = new StringBuffer();
/* 117 */     buffer.append(""Hit<"");
/* 118 */     buffer.append(this.hits.toString());
/* 119 */     buffer.append("" ["");
/* 120 */     buffer.append(this.hitNumber);
/* 121 */     buffer.append(""] "");
/* 122 */     if (this.resolved) {
/* 123 */       buffer.append(""resolved"");
/*     */     } else {
/* 125 */       buffer.append(""unresolved"");
/*     */     } 
/* 127 */     buffer.append("">"");
/* 128 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Hit.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitCollector,"package org.apache.lucene.search;
public abstract class HitCollector {
  public abstract void collect(int paramInt, float paramFloat);
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\HitCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitDoc,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import org.apache.lucene.document.Document;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class HitDoc
/*     */ {
/*     */   float score;
/*     */   int id;
/* 198 */   Document doc = null;
/*     */   
/*     */   HitDoc next;
/*     */   HitDoc prev;
/*     */   
/*     */   HitDoc(float s, int i) {
/* 204 */     this.score = s;
/* 205 */     this.id = i;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\HitDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitIterator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.util.Iterator;
/*    */ import java.util.NoSuchElementException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class HitIterator
/*    */   implements Iterator
/*    */ {
/*    */   private Hits hits;
/* 32 */   private int hitNumber = 0;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 38 */   HitIterator(Hits hits) { this.hits = hits; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 45 */   public boolean hasNext() { return (this.hitNumber < this.hits.length()); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Object next() {
/* 54 */     if (this.hitNumber == this.hits.length()) {
/* 55 */       throw new NoSuchElementException();
/*    */     }
/* 57 */     Object next = new Hit(this.hits, this.hitNumber);
/* 58 */     this.hitNumber++;
/* 59 */     return next;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 68 */   public void remove() { throw new UnsupportedOperationException(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 75 */   public int length() { return this.hits.length(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\HitIterator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.HitQueue,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class HitQueue
/*    */   extends PriorityQueue
/*    */ {
/* 24 */   HitQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object a, Object b) {
/* 28 */     ScoreDoc hitA = (ScoreDoc)a;
/* 29 */     ScoreDoc hitB = (ScoreDoc)b;
/* 30 */     if (hitA.score == hitB.score) {
/* 31 */       return (hitA.doc > hitB.doc);
/*    */     }
/* 33 */     return (hitA.score < hitB.score);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\HitQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Hits,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Iterator;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class Hits
/*     */ {
/*     */   private Weight weight;
/*     */   private Searcher searcher;
/*  38 */   private Filter filter = null;
/*  39 */   private Sort sort = null;
/*     */   
/*     */   private int length;
/*  42 */   private Vector hitDocs = new Vector();
/*     */   
/*     */   private HitDoc first;
/*     */   private HitDoc last;
/*  46 */   private int numDocs = 0;
/*  47 */   private int maxDocs = 200;
/*     */   
/*     */   Hits(Searcher s, Query q, Filter f) throws IOException {
/*  50 */     this.weight = q.weight(s);
/*  51 */     this.searcher = s;
/*  52 */     this.filter = f;
/*  53 */     getMoreDocs(50);
/*     */   }
/*     */   
/*     */   Hits(Searcher s, Query q, Filter f, Sort o) throws IOException {
/*  57 */     this.weight = q.weight(s);
/*  58 */     this.searcher = s;
/*  59 */     this.filter = f;
/*  60 */     this.sort = o;
/*  61 */     getMoreDocs(50);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void getMoreDocs(int min) throws IOException {
/*  69 */     if (this.hitDocs.size() > min) {
/*  70 */       min = this.hitDocs.size();
/*     */     }
/*     */     
/*  73 */     int n = min * 2;
/*  74 */     TopDocs topDocs = (this.sort == null) ? this.searcher.search(this.weight, this.filter, n) : this.searcher.search(this.weight, this.filter, n, this.sort);
/*  75 */     this.length = topDocs.totalHits;
/*  76 */     ScoreDoc[] scoreDocs = topDocs.scoreDocs;
/*     */     
/*  78 */     float scoreNorm = 1.0F;
/*     */     
/*  80 */     if (this.length > 0 && topDocs.getMaxScore() > 1.0F) {
/*  81 */       scoreNorm = 1.0F / topDocs.getMaxScore();
/*     */     }
/*     */     
/*  84 */     int end = (scoreDocs.length < this.length) ? scoreDocs.length : this.length;
/*  85 */     for (int i = this.hitDocs.size(); i < end; i++) {
/*  86 */       this.hitDocs.addElement(new HitDoc((scoreDocs[i]).score * scoreNorm, (scoreDocs[i]).doc));
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  93 */   public final int length() { return this.length; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Document doc(int n) throws CorruptIndexException, IOException {
/* 103 */     HitDoc hitDoc = hitDoc(n);
/*     */ 
/*     */     
/* 106 */     remove(hitDoc);
/* 107 */     addToFront(hitDoc);
/* 108 */     if (this.numDocs > this.maxDocs) {
/* 109 */       HitDoc oldLast = this.last;
/* 110 */       remove(this.last);
/* 111 */       oldLast.doc = null;
/*     */     } 
/*     */     
/* 114 */     if (hitDoc.doc == null) {
/* 115 */       hitDoc.doc = this.searcher.doc(hitDoc.id);
/*     */     }
/*     */     
/* 118 */     return hitDoc.doc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 123 */   public final float score(int n) throws IOException { return (hitDoc(n)).score; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 131 */   public final int id(int n) throws IOException { return (hitDoc(n)).id; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public Iterator iterator() { return new HitIterator(this); }
/*     */ 
/*     */   
/*     */   private final HitDoc hitDoc(int n) throws IOException {
/* 149 */     if (n >= this.length) {
/* 150 */       throw new IndexOutOfBoundsException(""Not a valid hit number: "" + n);
/*     */     }
/*     */     
/* 153 */     if (n >= this.hitDocs.size()) {
/* 154 */       getMoreDocs(n);
/*     */     }
/*     */     
/* 157 */     return this.hitDocs.elementAt(n);
/*     */   }
/*     */   
/*     */   private final void addToFront(HitDoc hitDoc) {
/* 161 */     if (this.first == null) {
/* 162 */       this.last = hitDoc;
/*     */     } else {
/* 164 */       this.first.prev = hitDoc;
/*     */     } 
/*     */     
/* 167 */     hitDoc.next = this.first;
/* 168 */     this.first = hitDoc;
/* 169 */     hitDoc.prev = null;
/*     */     
/* 171 */     this.numDocs++;
/*     */   }
/*     */   
/*     */   private final void remove(HitDoc hitDoc) {
/* 175 */     if (hitDoc.doc == null) {
/*     */       return;
/*     */     }
/*     */     
/* 179 */     if (hitDoc.next == null) {
/* 180 */       this.last = hitDoc.prev;
/*     */     } else {
/* 182 */       hitDoc.next.prev = hitDoc.prev;
/*     */     } 
/*     */     
/* 185 */     if (hitDoc.prev == null) {
/* 186 */       this.first = hitDoc.next;
/*     */     } else {
/* 188 */       hitDoc.prev.next = hitDoc.next;
/*     */     } 
/*     */     
/* 191 */     this.numDocs--;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Hits.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.IdGenerator,"package org.apache.lucene.search;
import java.io.IOException;
import org.apache.lucene.index.IndexReader;
interface IdGenerator {
  void generate(IndexReader paramIndexReader) throws IOException;
  void handleDoc(int paramInt);
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\IdGenerator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.IndexSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.store.Directory;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IndexSearcher
/*     */   extends Searcher
/*     */ {
/*     */   IndexReader reader;
/*     */   private boolean closeReader;
/*     */   
/*  48 */   public IndexSearcher(String path) throws CorruptIndexException, IOException { this(IndexReader.open(path), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   public IndexSearcher(Directory directory) throws CorruptIndexException, IOException { this(IndexReader.open(directory), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  61 */   public IndexSearcher(IndexReader r) { this(r, false); }
/*     */ 
/*     */   
/*     */   private IndexSearcher(IndexReader r, boolean closeReader) {
/*  65 */     this.reader = r;
/*  66 */     this.closeReader = closeReader;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public IndexReader getIndexReader() { return this.reader; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/*  81 */     if (this.closeReader) {
/*  82 */       this.reader.close();
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*  87 */   public int docFreq(Term term) throws IOException { return this.reader.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  92 */   public Document doc(int i) throws CorruptIndexException, IOException { return this.reader.document(i); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public Document doc(int i, FieldSelector fieldSelector) throws CorruptIndexException, IOException { return this.reader.document(i, fieldSelector); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 102 */   public int maxDoc() throws IOException { return this.reader.maxDoc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/* 109 */     if (nDocs <= 0) {
/* 110 */       throw new IllegalArgumentException(""nDocs must be > 0"");
/*     */     }
/* 112 */     TopDocCollector collector = new TopDocCollector(nDocs);
/* 113 */     search(weight, filter, collector);
/* 114 */     return collector.topDocs();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int nDocs, Sort sort) throws IOException {
/* 122 */     TopFieldDocCollector collector = new TopFieldDocCollector(this.reader, sort, nDocs);
/*     */     
/* 124 */     search(weight, filter, collector);
/* 125 */     return (TopFieldDocs)collector.topDocs();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 131 */     HitCollector collector = results;
/* 132 */     if (filter != null) {
/* 133 */       final BitSet bits = filter.bits(this.reader);
/* 134 */       collector = new HitCollector() { private final BitSet val$bits; private final HitCollector val$results;
/*     */           public final void collect(int doc, float score) {
/* 136 */             if (bits.get(doc))
/* 137 */               results.collect(doc, score); 
/*     */           }
/*     */           
/*     */           private final IndexSearcher this$0; }
/*     */         ;
/*     */     } 
/* 143 */     Scorer scorer = weight.scorer(this.reader);
/* 144 */     if (scorer == null)
/*     */       return; 
/* 146 */     scorer.score(collector);
/*     */   }
/*     */   
/*     */   public Query rewrite(Query original) throws IOException {
/* 150 */     Query query = original;
/* 151 */     for (Query rewrittenQuery = query.rewrite(this.reader); rewrittenQuery != query; 
/* 152 */       rewrittenQuery = query.rewrite(this.reader)) {
/* 153 */       query = rewrittenQuery;
/*     */     }
/* 155 */     return query;
/*     */   }
/*     */ 
/*     */   
/* 159 */   public Explanation explain(Weight weight, int doc) throws IOException { return weight.explain(this.reader, doc); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\IndexSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MatchAllDocsQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MatchAllDocsQuery
/*     */   extends Query
/*     */ {
/*     */   private class MatchAllScorer
/*     */     extends Scorer
/*     */   {
/*     */     final IndexReader reader;
/*     */     int id;
/*     */     final int maxId;
/*     */     final float score;
/*     */     private final MatchAllDocsQuery this$0;
/*     */     
/*     */     MatchAllScorer(IndexReader reader, Similarity similarity, Weight w) {
/*  49 */       super(similarity);
/*  50 */       this.reader = reader;
/*  51 */       this.id = -1;
/*  52 */       this.maxId = reader.maxDoc() - 1;
/*  53 */       this.score = w.getValue();
/*     */     }
/*     */ 
/*     */     
/*  57 */     public Explanation explain(int doc) { return null; }
/*     */ 
/*     */ 
/*     */     
/*  61 */     public int doc() { return this.id; }
/*     */ 
/*     */     
/*     */     public boolean next() {
/*  65 */       while (this.id < this.maxId) {
/*  66 */         this.id++;
/*  67 */         if (!this.reader.isDeleted(this.id)) {
/*  68 */           return true;
/*     */         }
/*     */       } 
/*  71 */       return false;
/*     */     }
/*     */ 
/*     */     
/*  75 */     public float score() { return this.score; }
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) {
/*  79 */       this.id = target - 1;
/*  80 */       return next();
/*     */     }
/*     */   }
/*     */   
/*     */   private class MatchAllDocsWeight
/*     */     implements Weight {
/*     */     private Similarity similarity;
/*     */     private float queryWeight;
/*     */     private float queryNorm;
/*     */     private final MatchAllDocsQuery this$0;
/*     */     
/*  91 */     public MatchAllDocsWeight(Searcher searcher) { this.similarity = searcher.getSimilarity(); }
/*     */ 
/*     */ 
/*     */     
/*  95 */     public String toString() { return ""weight("" + MatchAllDocsQuery.this + "")""; }
/*     */ 
/*     */ 
/*     */     
/*  99 */     public Query getQuery() { return MatchAllDocsQuery.this; }
/*     */ 
/*     */ 
/*     */     
/* 103 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 107 */       this.queryWeight = MatchAllDocsQuery.this.getBoost();
/* 108 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 112 */       this.queryNorm = queryNorm;
/* 113 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */     
/* 117 */     public Scorer scorer(IndexReader reader) { return new MatchAllDocsQuery.MatchAllScorer(reader, this.similarity, this); }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) {
/* 122 */       Explanation queryExpl = new ComplexExplanation(true, getValue(), ""MatchAllDocsQuery, product of:"");
/*     */       
/* 124 */       if (MatchAllDocsQuery.this.getBoost() != 1.0F) {
/* 125 */         queryExpl.addDetail(new Explanation(MatchAllDocsQuery.this.getBoost(), ""boost""));
/*     */       }
/* 127 */       queryExpl.addDetail(new Explanation(this.queryNorm, ""queryNorm""));
/*     */       
/* 129 */       return queryExpl;
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 134 */   protected Weight createWeight(Searcher searcher) { return new MatchAllDocsWeight(searcher); }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 141 */     StringBuffer buffer = new StringBuffer();
/* 142 */     buffer.append(""MatchAllDocsQuery"");
/* 143 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 144 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public boolean equals(Object o) {
/* 148 */     if (!(o instanceof MatchAllDocsQuery))
/* 149 */       return false; 
/* 150 */     MatchAllDocsQuery other = (MatchAllDocsQuery)o;
/* 151 */     return (getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */   
/* 155 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ 0x1AA71190; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\MatchAllDocsQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiPhraseQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collections;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.MultipleTermPositions;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiPhraseQuery
/*     */   extends Query
/*     */ {
/*     */   private String field;
/*  43 */   private ArrayList termArrays = new ArrayList();
/*  44 */   private Vector positions = new Vector();
/*     */   
/*  46 */   private int slop = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  51 */   public void setSlop(int s) { this.slop = s; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  61 */   public void add(Term term) { add(new Term[] { term }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term[] terms) {
/*  69 */     int position = 0;
/*  70 */     if (this.positions.size() > 0) {
/*  71 */       position = ((Integer)this.positions.lastElement()).intValue() + 1;
/*     */     }
/*  73 */     add(terms, position);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term[] terms, int position) {
/*  84 */     if (this.termArrays.size() == 0) {
/*  85 */       this.field = terms[0].field();
/*     */     }
/*  87 */     for (int i = 0; i < terms.length; i++) {
/*  88 */       if (terms[i].field() != this.field) {
/*  89 */         throw new IllegalArgumentException(""All phrase terms must be in the same field ("" + this.field + ""): "" + terms[i]);
/*     */       }
/*     */     } 
/*     */ 
/*     */ 
/*     */     
/*  95 */     this.termArrays.add(terms);
/*  96 */     this.positions.addElement(new Integer(position));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 104 */   public List getTermArrays() { return Collections.unmodifiableList(this.termArrays); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] getPositions() {
/* 111 */     int[] result = new int[this.positions.size()];
/* 112 */     for (int i = 0; i < this.positions.size(); i++)
/* 113 */       result[i] = ((Integer)this.positions.elementAt(i)).intValue(); 
/* 114 */     return result;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/* 119 */     for (Iterator iter = this.termArrays.iterator(); iter.hasNext(); ) {
/* 120 */       Term[] arr = iter.next();
/* 121 */       for (int i = 0; i < arr.length; i++)
/* 122 */         terms.add(arr[i]); 
/*     */     } 
/*     */   }
/*     */   
/*     */   private class MultiPhraseWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final MultiPhraseQuery this$0;
/*     */     
/*     */     public MultiPhraseWeight(Searcher searcher) throws IOException {
/* 137 */       this.similarity = MultiPhraseQuery.this.getSimilarity(searcher);
/*     */ 
/*     */       
/* 140 */       Iterator i = MultiPhraseQuery.this.termArrays.iterator();
/* 141 */       while (i.hasNext()) {
/* 142 */         Term[] terms = i.next();
/* 143 */         for (int j = 0; j < terms.length; j++) {
/* 144 */           this.idf += MultiPhraseQuery.this.getSimilarity(searcher).idf(terms[j], searcher);
/*     */         }
/*     */       } 
/*     */     }
/*     */     
/* 149 */     public Query getQuery() { return MultiPhraseQuery.this; }
/* 150 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 153 */       this.queryWeight = this.idf * MultiPhraseQuery.this.getBoost();
/* 154 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 158 */       this.queryNorm = queryNorm;
/* 159 */       this.queryWeight *= queryNorm;
/* 160 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 164 */       if (MultiPhraseQuery.this.termArrays.size() == 0) {
/* 165 */         return null;
/*     */       }
/* 167 */       TermPositions[] tps = new TermPositions[MultiPhraseQuery.this.termArrays.size()];
/* 168 */       for (int i = 0; i < tps.length; i++) {
/* 169 */         Object p; Term[] terms = MultiPhraseQuery.this.termArrays.get(i);
/*     */ 
/*     */         
/* 172 */         if (terms.length > 1) {
/* 173 */           p = new MultipleTermPositions(reader, terms);
/*     */         } else {
/* 175 */           p = reader.termPositions(terms[0]);
/*     */         } 
/* 177 */         if (p == null) {
/* 178 */           return null;
/*     */         }
/* 180 */         tps[i] = (TermPositions)p;
/*     */       } 
/*     */       
/* 183 */       if (MultiPhraseQuery.this.slop == 0) {
/* 184 */         return new ExactPhraseScorer(this, tps, MultiPhraseQuery.this.getPositions(), this.similarity, reader.norms(MultiPhraseQuery.this.field));
/*     */       }
/*     */       
/* 187 */       return new SloppyPhraseScorer(this, tps, MultiPhraseQuery.this.getPositions(), this.similarity, MultiPhraseQuery.this.slop, reader.norms(MultiPhraseQuery.this.field));
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 193 */       ComplexExplanation result = new ComplexExplanation();
/* 194 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/* 196 */       Explanation idfExpl = new Explanation(this.idf, ""idf("" + getQuery() + "")"");
/*     */ 
/*     */       
/* 199 */       Explanation queryExpl = new Explanation();
/* 200 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/* 202 */       Explanation boostExpl = new Explanation(MultiPhraseQuery.this.getBoost(), ""boost"");
/* 203 */       if (MultiPhraseQuery.this.getBoost() != 1.0F) {
/* 204 */         queryExpl.addDetail(boostExpl);
/*     */       }
/* 206 */       queryExpl.addDetail(idfExpl);
/*     */       
/* 208 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 209 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/* 211 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 215 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 218 */       ComplexExplanation fieldExpl = new ComplexExplanation();
/* 219 */       fieldExpl.setDescription(""fieldWeight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 222 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 223 */       fieldExpl.addDetail(tfExpl);
/* 224 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 226 */       Explanation fieldNormExpl = new Explanation();
/* 227 */       byte[] fieldNorms = reader.norms(MultiPhraseQuery.this.field);
/* 228 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 230 */       fieldNormExpl.setValue(fieldNorm);
/* 231 */       fieldNormExpl.setDescription(""fieldNorm(field="" + MultiPhraseQuery.this.field + "", doc="" + doc + "")"");
/* 232 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 234 */       fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
/* 235 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 239 */       result.addDetail(fieldExpl);
/* 240 */       result.setMatch(fieldExpl.getMatch());
/*     */ 
/*     */       
/* 243 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 245 */       if (queryExpl.getValue() == 1.0F) {
/* 246 */         return fieldExpl;
/*     */       }
/* 248 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) {
/* 253 */     if (this.termArrays.size() == 1) {
/* 254 */       Term[] terms = this.termArrays.get(0);
/* 255 */       BooleanQuery boq = new BooleanQuery(true);
/* 256 */       for (int i = 0; i < terms.length; i++) {
/* 257 */         boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
/*     */       }
/* 259 */       boq.setBoost(getBoost());
/* 260 */       return boq;
/*     */     } 
/* 262 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 267 */   protected Weight createWeight(Searcher searcher) throws IOException { return new MultiPhraseWeight(searcher); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final String toString(String f) {
/* 272 */     StringBuffer buffer = new StringBuffer();
/* 273 */     if (!this.field.equals(f)) {
/* 274 */       buffer.append(this.field);
/* 275 */       buffer.append("":"");
/*     */     } 
/*     */     
/* 278 */     buffer.append(""\"""");
/* 279 */     Iterator i = this.termArrays.iterator();
/* 280 */     while (i.hasNext()) {
/* 281 */       Term[] terms = i.next();
/* 282 */       if (terms.length > 1) {
/* 283 */         buffer.append(""("");
/* 284 */         for (int j = 0; j < terms.length; j++) {
/* 285 */           buffer.append(terms[j].text());
/* 286 */           if (j < terms.length - 1)
/* 287 */             buffer.append("" ""); 
/*     */         } 
/* 289 */         buffer.append("")"");
/*     */       } else {
/* 291 */         buffer.append(terms[0].text());
/*     */       } 
/* 293 */       if (i.hasNext())
/* 294 */         buffer.append("" ""); 
/*     */     } 
/* 296 */     buffer.append(""\"""");
/*     */     
/* 298 */     if (this.slop != 0) {
/* 299 */       buffer.append(""~"");
/* 300 */       buffer.append(this.slop);
/*     */     } 
/*     */     
/* 303 */     buffer.append(ToStringUtils.boost(getBoost()));
/*     */     
/* 305 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 311 */     if (!(o instanceof MultiPhraseQuery)) return false; 
/* 312 */     MultiPhraseQuery other = (MultiPhraseQuery)o;
/* 313 */     return (getBoost() == other.getBoost() && this.slop == other.slop && this.termArrays.equals(other.termArrays) && this.positions.equals(other.positions));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 321 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.slop ^ this.termArrays.hashCode() ^ this.positions.hashCode() ^ 0x4AC65113; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\MultiPhraseQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashMap;
/*     */ import java.util.HashSet;
/*     */ import java.util.Map;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MultiSearcher
/*     */   extends Searcher
/*     */ {
/*     */   private Searchable[] searchables;
/*     */   private int[] starts;
/*     */   
/*     */   private static class CachedDfSource
/*     */     extends Searcher
/*     */   {
/*     */     private Map dfMap;
/*     */     private int maxDoc;
/*     */     
/*     */     public CachedDfSource(Map dfMap, int maxDoc, Similarity similarity) {
/*  47 */       this.dfMap = dfMap;
/*  48 */       this.maxDoc = maxDoc;
/*  49 */       setSimilarity(similarity);
/*     */     }
/*     */     
/*     */     public int docFreq(Term term) {
/*     */       int df;
/*     */       try {
/*  55 */         df = ((Integer)this.dfMap.get(term)).intValue();
/*  56 */       } catch (NullPointerException e) {
/*  57 */         throw new IllegalArgumentException(""df for term "" + term.text() + "" not available"");
/*     */       } 
/*     */       
/*  60 */       return df;
/*     */     }
/*     */     
/*     */     public int[] docFreqs(Term[] terms) {
/*  64 */       int[] result = new int[terms.length];
/*  65 */       for (int i = 0; i < terms.length; i++) {
/*  66 */         result[i] = docFreq(terms[i]);
/*     */       }
/*  68 */       return result;
/*     */     }
/*     */ 
/*     */     
/*  72 */     public int maxDoc() { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  80 */     public Query rewrite(Query query) { return query; }
/*     */ 
/*     */ 
/*     */     
/*  84 */     public void close() { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  88 */     public Document doc(int i) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  92 */     public Document doc(int i, FieldSelector fieldSelector) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/*  96 */     public Explanation explain(Weight weight, int doc) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/* 100 */     public void search(Weight weight, Filter filter, HitCollector results) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/* 104 */     public TopDocs search(Weight weight, Filter filter, int n) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */     
/* 108 */     public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) { throw new UnsupportedOperationException(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 115 */   private int maxDoc = 0;
/*     */ 
/*     */   
/*     */   public MultiSearcher(Searchable[] searchables) throws IOException {
/* 119 */     this.searchables = searchables;
/*     */     
/* 121 */     this.starts = new int[searchables.length + 1];
/* 122 */     for (int i = 0; i < searchables.length; i++) {
/* 123 */       this.starts[i] = this.maxDoc;
/* 124 */       this.maxDoc += searchables[i].maxDoc();
/*     */     } 
/* 126 */     this.starts[searchables.length] = this.maxDoc;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 131 */   public Searchable[] getSearchables() { return this.searchables; }
/*     */ 
/*     */ 
/*     */   
/* 135 */   protected int[] getStarts() { return this.starts; }
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 140 */     for (int i = 0; i < this.searchables.length; i++)
/* 141 */       this.searchables[i].close(); 
/*     */   }
/*     */   
/*     */   public int docFreq(Term term) throws IOException {
/* 145 */     int docFreq = 0;
/* 146 */     for (int i = 0; i < this.searchables.length; i++)
/* 147 */       docFreq += this.searchables[i].docFreq(term); 
/* 148 */     return docFreq;
/*     */   }
/*     */ 
/*     */   
/*     */   public Document doc(int n) throws CorruptIndexException, IOException {
/* 153 */     int i = subSearcher(n);
/* 154 */     return this.searchables[i].doc(n - this.starts[i]);
/*     */   }
/*     */ 
/*     */   
/*     */   public Document doc(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
/* 159 */     int i = subSearcher(n);
/* 160 */     return this.searchables[i].doc(n - this.starts[i], fieldSelector);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int subSearcher(int n) {
/* 167 */     int lo = 0;
/* 168 */     int hi = this.searchables.length - 1;
/*     */     
/* 170 */     while (hi >= lo) {
/* 171 */       int mid = lo + hi >> 1;
/* 172 */       int midValue = this.starts[mid];
/* 173 */       if (n < midValue) {
/* 174 */         hi = mid - 1; continue;
/* 175 */       }  if (n > midValue) {
/* 176 */         lo = mid + 1; continue;
/*     */       } 
/* 178 */       while (mid + 1 < this.searchables.length && this.starts[mid + 1] == midValue) {
/* 179 */         mid++;
/*     */       }
/* 181 */       return mid;
/*     */     } 
/*     */     
/* 184 */     return hi;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 190 */   public int subDoc(int n) { return n - this.starts[subSearcher(n)]; }
/*     */ 
/*     */ 
/*     */   
/* 194 */   public int maxDoc() throws IOException { return this.maxDoc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/* 200 */     HitQueue hq = new HitQueue(nDocs);
/* 201 */     int totalHits = 0;
/*     */     
/* 203 */     for (int i = 0; i < this.searchables.length; i++) {
/* 204 */       TopDocs docs = this.searchables[i].search(weight, filter, nDocs);
/* 205 */       totalHits += docs.totalHits;
/* 206 */       ScoreDoc[] scoreDocs = docs.scoreDocs;
/* 207 */       for (int j = 0; j < scoreDocs.length; j++) {
/* 208 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 209 */         scoreDoc.doc += this.starts[i];
/* 210 */         if (!hq.insert(scoreDoc)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 215 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 216 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 217 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 219 */     float maxScore = (totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*     */     
/* 221 */     return new TopDocs(totalHits, scoreDocs, maxScore);
/*     */   }
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) throws IOException {
/* 226 */     FieldDocSortedHitQueue hq = null;
/* 227 */     int totalHits = 0;
/*     */     
/* 229 */     float maxScore = Float.NEGATIVE_INFINITY;
/*     */     
/* 231 */     for (int i = 0; i < this.searchables.length; i++) {
/* 232 */       TopFieldDocs docs = this.searchables[i].search(weight, filter, n, sort);
/*     */       
/* 234 */       if (hq == null) hq = new FieldDocSortedHitQueue(docs.fields, n); 
/* 235 */       totalHits += docs.totalHits;
/* 236 */       maxScore = Math.max(maxScore, docs.getMaxScore());
/* 237 */       ScoreDoc[] scoreDocs = docs.scoreDocs;
/* 238 */       for (int j = 0; j < scoreDocs.length; j++) {
/* 239 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 240 */         scoreDoc.doc += this.starts[i];
/* 241 */         if (!hq.insert(scoreDoc)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 246 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 247 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 248 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 250 */     return new TopFieldDocs(totalHits, scoreDocs, hq.getFields(), maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 257 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 259 */       final int start = this.starts[i];
/*     */       
/* 261 */       this.searchables[i].search(weight, filter, new HitCollector() { private final HitCollector val$results;
/*     */             
/* 263 */             public void collect(int doc, float score) { results.collect(doc + start, score); }
/*     */             private final int val$start;
/*     */             private final MultiSearcher this$0; }
/*     */         );
/*     */     } 
/*     */   }
/*     */   
/*     */   public Query rewrite(Query original) throws IOException {
/* 271 */     Query[] queries = new Query[this.searchables.length];
/* 272 */     for (int i = 0; i < this.searchables.length; i++) {
/* 273 */       queries[i] = this.searchables[i].rewrite(original);
/*     */     }
/* 275 */     return queries[0].combine(queries);
/*     */   }
/*     */   
/*     */   public Explanation explain(Weight weight, int doc) throws IOException {
/* 279 */     int i = subSearcher(doc);
/* 280 */     return this.searchables[i].explain(weight, doc - this.starts[i]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Weight createWeight(Query original) throws IOException {
/* 300 */     Query rewrittenQuery = rewrite(original);
/*     */ 
/*     */     
/* 303 */     Set terms = new HashSet();
/* 304 */     rewrittenQuery.extractTerms(terms);
/*     */ 
/*     */     
/* 307 */     Term[] allTermsArray = new Term[terms.size()];
/* 308 */     terms.toArray((Object[])allTermsArray);
/* 309 */     int[] aggregatedDfs = new int[terms.size()];
/* 310 */     for (int i = 0; i < this.searchables.length; i++) {
/* 311 */       int[] dfs = this.searchables[i].docFreqs(allTermsArray);
/* 312 */       for (int j = 0; j < aggregatedDfs.length; j++) {
/* 313 */         aggregatedDfs[j] = aggregatedDfs[j] + dfs[j];
/*     */       }
/*     */     } 
/*     */     
/* 317 */     HashMap dfMap = new HashMap();
/* 318 */     for (int i = 0; i < allTermsArray.length; i++) {
/* 319 */       dfMap.put(allTermsArray[i], new Integer(aggregatedDfs[i]));
/*     */     }
/*     */ 
/*     */     
/* 323 */     int numDocs = maxDoc();
/* 324 */     CachedDfSource cacheSim = new CachedDfSource(dfMap, numDocs, getSimilarity());
/*     */     
/* 326 */     return rewrittenQuery.weight(cacheSim);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\MultiSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiSearcherThread,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class MultiSearcherThread
/*     */   extends Thread
/*     */ {
/*     */   private Searchable searchable;
/*     */   private Weight weight;
/*     */   private Filter filter;
/*     */   private int nDocs;
/*     */   private TopDocs docs;
/*     */   private int i;
/*     */   private PriorityQueue hq;
/*     */   private int[] starts;
/*     */   private IOException ioe;
/*     */   private Sort sort;
/*     */   
/*     */   public MultiSearcherThread(Searchable searchable, Weight weight, Filter filter, int nDocs, HitQueue hq, int i, int[] starts, String name) {
/* 217 */     super(name);
/* 218 */     this.searchable = searchable;
/* 219 */     this.weight = weight;
/* 220 */     this.filter = filter;
/* 221 */     this.nDocs = nDocs;
/* 222 */     this.hq = hq;
/* 223 */     this.i = i;
/* 224 */     this.starts = starts;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public MultiSearcherThread(Searchable searchable, Weight weight, Filter filter, int nDocs, FieldDocSortedHitQueue hq, Sort sort, int i, int[] starts, String name) {
/* 237 */     super(name);
/* 238 */     this.searchable = searchable;
/* 239 */     this.weight = weight;
/* 240 */     this.filter = filter;
/* 241 */     this.nDocs = nDocs;
/* 242 */     this.hq = hq;
/* 243 */     this.i = i;
/* 244 */     this.starts = starts;
/* 245 */     this.sort = sort;
/*     */   }
/*     */   
/*     */   public void run() {
/*     */     try {
/* 250 */       this.docs = (this.sort == null) ? this.searchable.search(this.weight, this.filter, this.nDocs) : this.searchable.search(this.weight, this.filter, this.nDocs, this.sort);
/*     */ 
/*     */     
/*     */     }
/* 254 */     catch (IOException ioe) {
/* 255 */       this.ioe = ioe;
/*     */     } 
/* 257 */     if (this.ioe == null) {
/*     */ 
/*     */ 
/*     */       
/* 261 */       if (this.sort != null) {
/* 262 */         ((FieldDocSortedHitQueue)this.hq).setFields(((TopFieldDocs)this.docs).fields);
/*     */       }
/* 264 */       ScoreDoc[] scoreDocs = this.docs.scoreDocs;
/* 265 */       int j = 0;
/* 266 */       for (; j < scoreDocs.length; 
/* 267 */         j++) {
/* 268 */         ScoreDoc scoreDoc = scoreDocs[j];
/* 269 */         scoreDoc.doc += this.starts[this.i];
/*     */         
/* 271 */         synchronized (this.hq) {
/* 272 */           if (!this.hq.insert(scoreDoc)) {
/*     */             break;
/*     */           }
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/* 280 */   public int hits() { return this.docs.totalHits; }
/*     */ 
/*     */ 
/*     */   
/* 284 */   public float getMaxScore() { return this.docs.getMaxScore(); }
/*     */ 
/*     */ 
/*     */   
/* 288 */   public IOException getIOException() { return this.ioe; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\MultiSearcherThread.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.MultiTermQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class MultiTermQuery
/*    */   extends Query
/*    */ {
/*    */   private Term term;
/*    */   
/* 44 */   public MultiTermQuery(Term term) { this.term = term; }
/*    */ 
/*    */ 
/*    */   
/* 48 */   public Term getTerm() { return this.term; }
/*    */ 
/*    */   
/*    */   protected abstract FilteredTermEnum getEnum(IndexReader paramIndexReader) throws IOException;
/*    */ 
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 55 */     FilteredTermEnum enumerator = getEnum(reader);
/* 56 */     BooleanQuery query = new BooleanQuery(true);
/*    */     try {
/*    */       do {
/* 59 */         Term t = enumerator.term();
/* 60 */         if (t == null)
/* 61 */           continue;  TermQuery tq = new TermQuery(t);
/* 62 */         tq.setBoost(getBoost() * enumerator.difference());
/* 63 */         query.add(tq, BooleanClause.Occur.SHOULD);
/*    */       }
/* 65 */       while (enumerator.next());
/*    */     } finally {
/* 67 */       enumerator.close();
/*    */     } 
/* 69 */     return query;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 74 */     StringBuffer buffer = new StringBuffer();
/* 75 */     if (!this.term.field().equals(field)) {
/* 76 */       buffer.append(this.term.field());
/* 77 */       buffer.append("":"");
/*    */     } 
/* 79 */     buffer.append(this.term.text());
/* 80 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 81 */     return buffer.toString();
/*    */   }
/*    */   
/*    */   public boolean equals(Object o) {
/* 85 */     if (this == o) return true; 
/* 86 */     if (!(o instanceof MultiTermQuery)) return false;
/*    */     
/* 88 */     MultiTermQuery multiTermQuery = (MultiTermQuery)o;
/*    */     
/* 90 */     if (!this.term.equals(multiTermQuery.term)) return false;
/*    */     
/* 92 */     return (getBoost() == multiTermQuery.getBoost());
/*    */   }
/*    */ 
/*    */   
/* 96 */   public int hashCode() { return this.term.hashCode() + Float.floatToRawIntBits(getBoost()); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\MultiTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.NonMatchingScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class NonMatchingScorer
/*    */   extends Scorer
/*    */ {
/* 24 */   public NonMatchingScorer() { super(null); }
/*    */   
/* 26 */   public int doc() { throw new UnsupportedOperationException(); }
/*    */   
/* 28 */   public boolean next() throws IOException { return false; }
/*    */   
/* 30 */   public float score() { throw new UnsupportedOperationException(); }
/*    */   
/* 32 */   public boolean skipTo(int target) { return false; }
/*    */   
/*    */   public Explanation explain(int doc) {
/* 35 */     Explanation e = new Explanation();
/* 36 */     e.setDescription(""No document matches."");
/* 37 */     return e;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\NonMatchingScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ParallelMultiSearcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ParallelMultiSearcher
/*     */   extends MultiSearcher
/*     */ {
/*     */   private Searchable[] searchables;
/*     */   private int[] starts;
/*     */   
/*     */   public ParallelMultiSearcher(Searchable[] searchables) throws IOException {
/*  37 */     super(searchables);
/*  38 */     this.searchables = searchables;
/*  39 */     this.starts = getStarts();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  46 */   public int docFreq(Term term) throws IOException { return super.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {
/*  56 */     HitQueue hq = new HitQueue(nDocs);
/*  57 */     int totalHits = 0;
/*  58 */     MultiSearcherThread[] msta = new MultiSearcherThread[this.searchables.length];
/*     */     
/*  60 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/*  62 */       msta[i] = new MultiSearcherThread(this.searchables[i], weight, filter, nDocs, hq, i, this.starts, ""MultiSearcher thread #"" + (i + 1));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  72 */       msta[i].start();
/*     */     } 
/*     */     
/*  75 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       try {
/*  77 */         msta[i].join();
/*  78 */       } catch (InterruptedException ie) {}
/*     */ 
/*     */       
/*  81 */       IOException ioe = msta[i].getIOException();
/*  82 */       if (ioe == null) {
/*  83 */         totalHits += msta[i].hits();
/*     */       } else {
/*     */         
/*  86 */         throw ioe;
/*     */       } 
/*     */     } 
/*     */     
/*  90 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/*  91 */     for (int i = hq.size() - 1; i >= 0; i--) {
/*  92 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/*  94 */     float maxScore = (totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*     */     
/*  96 */     return new TopDocs(totalHits, scoreDocs, maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public TopFieldDocs search(Weight weight, Filter filter, int nDocs, Sort sort) throws IOException {
/* 107 */     FieldDocSortedHitQueue hq = new FieldDocSortedHitQueue(null, nDocs);
/* 108 */     int totalHits = 0;
/* 109 */     MultiSearcherThread[] msta = new MultiSearcherThread[this.searchables.length];
/* 110 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 112 */       msta[i] = new MultiSearcherThread(this.searchables[i], weight, filter, nDocs, hq, sort, i, this.starts, ""MultiSearcher thread #"" + (i + 1));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 123 */       msta[i].start();
/*     */     } 
/*     */     
/* 126 */     float maxScore = Float.NEGATIVE_INFINITY;
/*     */     
/* 128 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       try {
/* 130 */         msta[i].join();
/* 131 */       } catch (InterruptedException ie) {}
/*     */ 
/*     */       
/* 134 */       IOException ioe = msta[i].getIOException();
/* 135 */       if (ioe == null) {
/* 136 */         totalHits += msta[i].hits();
/* 137 */         maxScore = Math.max(maxScore, msta[i].getMaxScore());
/*     */       } else {
/*     */         
/* 140 */         throw ioe;
/*     */       } 
/*     */     } 
/*     */     
/* 144 */     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
/* 145 */     for (int i = hq.size() - 1; i >= 0; i--) {
/* 146 */       scoreDocs[i] = (ScoreDoc)hq.pop();
/*     */     }
/* 148 */     return new TopFieldDocs(totalHits, scoreDocs, hq.getFields(), maxScore);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void search(Weight weight, Filter filter, final HitCollector results) throws IOException {
/* 169 */     for (int i = 0; i < this.searchables.length; i++) {
/*     */       
/* 171 */       final int start = this.starts[i];
/*     */       
/* 173 */       this.searchables[i].search(weight, filter, new HitCollector()
/*     */           {
/* 175 */             public void collect(int doc, float score) { results.collect(doc + start, score); }
/*     */ 
/*     */             
/*     */             private final HitCollector val$results;
/*     */             
/*     */             private final int val$start;
/*     */             
/*     */             private final ParallelMultiSearcher this$0;
/*     */           });
/*     */     } 
/*     */   }
/*     */   
/* 187 */   public Query rewrite(Query original) throws IOException { return super.rewrite(original); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ParallelMultiSearcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhrasePositions,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class PhrasePositions
/*    */ {
/*    */   int doc;
/*    */   int position;
/*    */   int count;
/*    */   int offset;
/*    */   TermPositions tp;
/*    */   PhrasePositions next;
/*    */   boolean repeats;
/*    */   
/*    */   PhrasePositions(TermPositions t, int o) {
/* 36 */     this.tp = t;
/* 37 */     this.offset = o;
/*    */   }
/*    */   
/*    */   final boolean next() throws IOException {
/* 41 */     if (!this.tp.next()) {
/* 42 */       this.tp.close();
/* 43 */       this.doc = Integer.MAX_VALUE;
/* 44 */       return false;
/*    */     } 
/* 46 */     this.doc = this.tp.doc();
/* 47 */     this.position = 0;
/* 48 */     return true;
/*    */   }
/*    */   
/*    */   final boolean skipTo(int target) throws IOException {
/* 52 */     if (!this.tp.skipTo(target)) {
/* 53 */       this.tp.close();
/* 54 */       this.doc = Integer.MAX_VALUE;
/* 55 */       return false;
/*    */     } 
/* 57 */     this.doc = this.tp.doc();
/* 58 */     this.position = 0;
/* 59 */     return true;
/*    */   }
/*    */ 
/*    */   
/*    */   final void firstPosition() throws IOException {
/* 64 */     this.count = this.tp.freq();
/* 65 */     nextPosition();
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   final boolean nextPosition() throws IOException {
/* 75 */     if (this.count-- > 0) {
/* 76 */       this.position = this.tp.nextPosition() - this.offset;
/* 77 */       return true;
/*    */     } 
/* 79 */     return false;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\PhrasePositions.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import java.util.Vector;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class PhraseQuery
/*     */   extends Query
/*     */ {
/*     */   private String field;
/*  36 */   private Vector terms = new Vector();
/*  37 */   private Vector positions = new Vector();
/*  38 */   private int slop = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  57 */   public void setSlop(int s) { this.slop = s; }
/*     */   
/*  59 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term term) {
/*  66 */     int position = 0;
/*  67 */     if (this.positions.size() > 0) {
/*  68 */       position = ((Integer)this.positions.lastElement()).intValue() + 1;
/*     */     }
/*  70 */     add(term, position);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void add(Term term, int position) {
/*  83 */     if (this.terms.size() == 0) {
/*  84 */       this.field = term.field();
/*  85 */     } else if (term.field() != this.field) {
/*  86 */       throw new IllegalArgumentException(""All phrase terms must be in the same field: "" + term);
/*     */     } 
/*  88 */     this.terms.addElement(term);
/*  89 */     this.positions.addElement(new Integer(position));
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  94 */   public Term[] getTerms() { return (Term[])this.terms.toArray((Object[])new Term[0]); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] getPositions() {
/* 101 */     int[] result = new int[this.positions.size()];
/* 102 */     for (int i = 0; i < this.positions.size(); i++)
/* 103 */       result[i] = ((Integer)this.positions.elementAt(i)).intValue(); 
/* 104 */     return result;
/*     */   }
/*     */   
/*     */   private class PhraseWeight implements Weight {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final PhraseQuery this$0;
/*     */     
/*     */     public PhraseWeight(Searcher searcher) throws IOException {
/* 116 */       this.similarity = PhraseQuery.this.getSimilarity(searcher);
/*     */       
/* 118 */       this.idf = this.similarity.idf(PhraseQuery.this.terms, searcher);
/*     */     }
/*     */     
/* 121 */     public String toString() { return ""weight("" + PhraseQuery.this + "")""; }
/*     */     
/* 123 */     public Query getQuery() { return PhraseQuery.this; }
/* 124 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/* 127 */       this.queryWeight = this.idf * PhraseQuery.this.getBoost();
/* 128 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/* 132 */       this.queryNorm = queryNorm;
/* 133 */       this.queryWeight *= queryNorm;
/* 134 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 138 */       if (PhraseQuery.this.terms.size() == 0) {
/* 139 */         return null;
/*     */       }
/* 141 */       TermPositions[] tps = new TermPositions[PhraseQuery.this.terms.size()];
/* 142 */       for (int i = 0; i < PhraseQuery.this.terms.size(); i++) {
/* 143 */         TermPositions p = reader.termPositions(PhraseQuery.this.terms.elementAt(i));
/* 144 */         if (p == null)
/* 145 */           return null; 
/* 146 */         tps[i] = p;
/*     */       } 
/*     */       
/* 149 */       if (PhraseQuery.this.slop == 0) {
/* 150 */         return new ExactPhraseScorer(this, tps, PhraseQuery.this.getPositions(), this.similarity, reader.norms(PhraseQuery.this.field));
/*     */       }
/*     */       
/* 153 */       return new SloppyPhraseScorer(this, tps, PhraseQuery.this.getPositions(), this.similarity, PhraseQuery.this.slop, reader.norms(PhraseQuery.this.field));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/* 162 */       Explanation result = new Explanation();
/* 163 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/* 165 */       StringBuffer docFreqs = new StringBuffer();
/* 166 */       StringBuffer query = new StringBuffer();
/* 167 */       query.append('""');
/* 168 */       for (int i = 0; i < PhraseQuery.this.terms.size(); i++) {
/* 169 */         if (i != 0) {
/* 170 */           docFreqs.append("" "");
/* 171 */           query.append("" "");
/*     */         } 
/*     */         
/* 174 */         Term term = PhraseQuery.this.terms.elementAt(i);
/*     */         
/* 176 */         docFreqs.append(term.text());
/* 177 */         docFreqs.append(""="");
/* 178 */         docFreqs.append(reader.docFreq(term));
/*     */         
/* 180 */         query.append(term.text());
/*     */       } 
/* 182 */       query.append('""');
/*     */       
/* 184 */       Explanation idfExpl = new Explanation(this.idf, ""idf("" + PhraseQuery.this.field + "": "" + docFreqs + "")"");
/*     */ 
/*     */ 
/*     */       
/* 188 */       Explanation queryExpl = new Explanation();
/* 189 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/* 191 */       Explanation boostExpl = new Explanation(PhraseQuery.this.getBoost(), ""boost"");
/* 192 */       if (PhraseQuery.this.getBoost() != 1.0F)
/* 193 */         queryExpl.addDetail(boostExpl); 
/* 194 */       queryExpl.addDetail(idfExpl);
/*     */       
/* 196 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 197 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/* 199 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 203 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 206 */       Explanation fieldExpl = new Explanation();
/* 207 */       fieldExpl.setDescription(""fieldWeight("" + PhraseQuery.this.field + "":"" + query + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 210 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 211 */       fieldExpl.addDetail(tfExpl);
/* 212 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 214 */       Explanation fieldNormExpl = new Explanation();
/* 215 */       byte[] fieldNorms = reader.norms(PhraseQuery.this.field);
/* 216 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 218 */       fieldNormExpl.setValue(fieldNorm);
/* 219 */       fieldNormExpl.setDescription(""fieldNorm(field="" + PhraseQuery.this.field + "", doc="" + doc + "")"");
/* 220 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 222 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 226 */       result.addDetail(fieldExpl);
/*     */ 
/*     */       
/* 229 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 231 */       if (queryExpl.getValue() == 1.0F) {
/* 232 */         return fieldExpl;
/*     */       }
/* 234 */       return result;
/*     */     }
/*     */   }
/*     */   
/*     */   protected Weight createWeight(Searcher searcher) throws IOException {
/* 239 */     if (this.terms.size() == 1) {
/* 240 */       Term term = this.terms.elementAt(0);
/* 241 */       Query termQuery = new TermQuery(term);
/* 242 */       termQuery.setBoost(getBoost());
/* 243 */       return termQuery.createWeight(searcher);
/*     */     } 
/* 245 */     return new PhraseWeight(searcher);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 252 */   public void extractTerms(Set queryTerms) { queryTerms.addAll(this.terms); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String f) {
/* 257 */     StringBuffer buffer = new StringBuffer();
/* 258 */     if (!this.field.equals(f)) {
/* 259 */       buffer.append(this.field);
/* 260 */       buffer.append("":"");
/*     */     } 
/*     */     
/* 263 */     buffer.append(""\"""");
/* 264 */     for (int i = 0; i < this.terms.size(); i++) {
/* 265 */       buffer.append(((Term)this.terms.elementAt(i)).text());
/* 266 */       if (i != this.terms.size() - 1)
/* 267 */         buffer.append("" ""); 
/*     */     } 
/* 269 */     buffer.append(""\"""");
/*     */     
/* 271 */     if (this.slop != 0) {
/* 272 */       buffer.append(""~"");
/* 273 */       buffer.append(this.slop);
/*     */     } 
/*     */     
/* 276 */     buffer.append(ToStringUtils.boost(getBoost()));
/*     */     
/* 278 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 283 */     if (!(o instanceof PhraseQuery))
/* 284 */       return false; 
/* 285 */     PhraseQuery other = (PhraseQuery)o;
/* 286 */     return (getBoost() == other.getBoost() && this.slop == other.slop && this.terms.equals(other.terms) && this.positions.equals(other.positions));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 294 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.slop ^ this.terms.hashCode() ^ this.positions.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\PhraseQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseQueue,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ final class PhraseQueue
/*    */   extends PriorityQueue
/*    */ {
/* 24 */   PhraseQueue(int size) { initialize(size); }
/*    */ 
/*    */   
/*    */   protected final boolean lessThan(Object o1, Object o2) {
/* 28 */     PhrasePositions pp1 = (PhrasePositions)o1;
/* 29 */     PhrasePositions pp2 = (PhrasePositions)o2;
/* 30 */     if (pp1.doc == pp2.doc) {
/* 31 */       if (pp1.position == pp2.position)
/*    */       {
/*    */         
/* 34 */         return (pp1.offset < pp2.offset);
/*    */       }
/* 36 */       return (pp1.position < pp2.position);
/*    */     } 
/* 38 */     return (pp1.doc < pp2.doc);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\PhraseQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PhraseScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class PhraseScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Weight weight;
/*     */   protected byte[] norms;
/*     */   protected float value;
/*     */   private boolean firstTime = true;
/*     */   private boolean more = true;
/*     */   protected PhraseQueue pq;
/*     */   protected PhrasePositions first;
/*     */   protected PhrasePositions last;
/*     */   private float freq;
/*     */   
/*     */   PhraseScorer(Weight weight, TermPositions[] tps, int[] offsets, Similarity similarity, byte[] norms) {
/*  49 */     super(similarity);
/*  50 */     this.norms = norms;
/*  51 */     this.weight = weight;
/*  52 */     this.value = weight.getValue();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  59 */     for (int i = 0; i < tps.length; i++) {
/*  60 */       PhrasePositions pp = new PhrasePositions(tps[i], offsets[i]);
/*  61 */       if (this.last != null) {
/*  62 */         this.last.next = pp;
/*     */       } else {
/*  64 */         this.first = pp;
/*  65 */       }  this.last = pp;
/*     */     } 
/*     */     
/*  68 */     this.pq = new PhraseQueue(tps.length);
/*     */   }
/*     */ 
/*     */   
/*  72 */   public int doc() { return this.first.doc; }
/*     */   
/*     */   public boolean next() throws IOException {
/*  75 */     if (this.firstTime) {
/*  76 */       init();
/*  77 */       this.firstTime = false;
/*  78 */     } else if (this.more) {
/*  79 */       this.more = this.last.next();
/*     */     } 
/*  81 */     return doNext();
/*     */   }
/*     */ 
/*     */   
/*     */   private boolean doNext() throws IOException {
/*  86 */     while (this.more) {
/*  87 */       while (this.more && this.first.doc < this.last.doc) {
/*  88 */         this.more = this.first.skipTo(this.last.doc);
/*  89 */         firstToLast();
/*     */       } 
/*     */       
/*  92 */       if (this.more) {
/*     */         
/*  94 */         this.freq = phraseFreq();
/*  95 */         if (this.freq == 0.0F) {
/*  96 */           this.more = this.last.next(); continue;
/*     */         } 
/*  98 */         return true;
/*     */       } 
/*     */     } 
/* 101 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public float score() throws IOException {
/* 106 */     float raw = getSimilarity().tf(this.freq) * this.value;
/* 107 */     return raw * Similarity.decodeNorm(this.norms[this.first.doc]);
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 111 */     this.firstTime = false;
/* 112 */     for (PhrasePositions pp = this.first; this.more && pp != null; pp = pp.next) {
/* 113 */       this.more = pp.skipTo(target);
/*     */     }
/* 115 */     if (this.more)
/* 116 */       sort(); 
/* 117 */     return doNext();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract float phraseFreq() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private void init() throws IOException {
/* 130 */     for (PhrasePositions pp = this.first; this.more && pp != null; pp = pp.next)
/* 131 */       this.more = pp.next(); 
/* 132 */     if (this.more)
/* 133 */       sort(); 
/*     */   }
/*     */   
/*     */   private void sort() {
/* 137 */     this.pq.clear();
/* 138 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next)
/* 139 */       this.pq.put(pp); 
/* 140 */     pqToList();
/*     */   }
/*     */   
/*     */   protected final void pqToList() {
/* 144 */     this.last = this.first = null;
/* 145 */     while (this.pq.top() != null) {
/* 146 */       PhrasePositions pp = (PhrasePositions)this.pq.pop();
/* 147 */       if (this.last != null) {
/* 148 */         this.last.next = pp;
/*     */       } else {
/* 150 */         this.first = pp;
/* 151 */       }  this.last = pp;
/* 152 */       pp.next = null;
/*     */     } 
/*     */   }
/*     */   
/*     */   protected final void firstToLast() {
/* 157 */     this.last.next = this.first;
/* 158 */     this.last = this.first;
/* 159 */     this.first = this.first.next;
/* 160 */     this.last.next = null;
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 164 */     Explanation tfExplanation = new Explanation();
/*     */     
/* 166 */     while (next() && doc() < doc);
/*     */     
/* 168 */     float phraseFreq = (doc() == doc) ? this.freq : 0.0F;
/* 169 */     tfExplanation.setValue(getSimilarity().tf(phraseFreq));
/* 170 */     tfExplanation.setDescription(""tf(phraseFreq="" + phraseFreq + "")"");
/*     */     
/* 172 */     return tfExplanation;
/*     */   }
/*     */   
/* 175 */   public String toString() { return ""scorer("" + this.weight + "")""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\PhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PrefixFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PrefixFilter
/*    */   extends Filter
/*    */ {
/*    */   protected final Term prefix;
/*    */   
/* 37 */   public PrefixFilter(Term prefix) { this.prefix = prefix; }
/*    */ 
/*    */   
/* 40 */   public Term getPrefix() { return this.prefix; }
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 43 */     final BitSet bitSet = new BitSet(reader.maxDoc());
/* 44 */     (new PrefixGenerator(this.prefix) { private final BitSet val$bitSet;
/*    */         
/* 46 */         public void handleDoc(int doc) { bitSet.set(doc); }
/*    */         private final PrefixFilter this$0; }
/*    */       ).generate(reader);
/* 49 */     return bitSet;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString() {
/* 54 */     StringBuffer buffer = new StringBuffer();
/* 55 */     buffer.append(""PrefixFilter("");
/* 56 */     buffer.append(this.prefix.toString());
/* 57 */     buffer.append("")"");
/* 58 */     return buffer.toString();
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\PrefixFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PrefixGenerator,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ abstract class PrefixGenerator
/*     */   implements IdGenerator
/*     */ {
/*     */   protected final Term prefix;
/*     */   
/*  75 */   PrefixGenerator(Term prefix) { this.prefix = prefix; }
/*     */ 
/*     */   
/*     */   public void generate(IndexReader reader) throws IOException {
/*  79 */     TermEnum enumerator = reader.terms(this.prefix);
/*  80 */     TermDocs termDocs = reader.termDocs();
/*     */ 
/*     */ 
/*     */     
/*  84 */     try { String prefixText = this.prefix.text();
/*  85 */       String prefixField = this.prefix.field();
/*     */       while (true)
/*  87 */       { Term term = enumerator.term();
/*  88 */         if (term != null && term.text().startsWith(prefixText) && term.field() == prefixField)
/*     */         
/*     */         { 
/*     */           
/*  92 */           termDocs.seek(term);
/*  93 */           while (termDocs.next()) {
/*  94 */             handleDoc(termDocs.doc());
/*     */           }
/*     */ 
/*     */ 
/*     */           
/*  99 */           if (!enumerator.next())
/*     */             break;  continue; }  break; }  }
/* 101 */     finally { termDocs.close();
/* 102 */       enumerator.close(); }
/*     */   
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\PrefixGenerator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.PrefixQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.index.TermEnum;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class PrefixQuery
/*    */   extends Query
/*    */ {
/*    */   private Term prefix;
/*    */   
/* 34 */   public PrefixQuery(Term prefix) { this.prefix = prefix; }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public Term getPrefix() { return this.prefix; }
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 41 */     BooleanQuery query = new BooleanQuery(true);
/* 42 */     TermEnum enumerator = reader.terms(this.prefix);
/*    */     
/* 44 */     try { String prefixText = this.prefix.text();
/* 45 */       String prefixField = this.prefix.field();
/*    */       while (true)
/* 47 */       { Term term = enumerator.term();
/* 48 */         if (term != null && term.text().startsWith(prefixText) && term.field() == prefixField)
/*    */         
/*    */         { 
/*    */           
/* 52 */           TermQuery tq = new TermQuery(term);
/* 53 */           tq.setBoost(getBoost());
/* 54 */           query.add(tq, BooleanClause.Occur.SHOULD);
/*    */ 
/*    */ 
/*    */ 
/*    */           
/* 59 */           if (!enumerator.next())
/*    */             break;  continue; }  break; }  }
/* 61 */     finally { enumerator.close(); }
/*    */     
/* 63 */     return query;
/*    */   }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 68 */     StringBuffer buffer = new StringBuffer();
/* 69 */     if (!this.prefix.field().equals(field)) {
/* 70 */       buffer.append(this.prefix.field());
/* 71 */       buffer.append("":"");
/*    */     } 
/* 73 */     buffer.append(this.prefix.text());
/* 74 */     buffer.append('*');
/* 75 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 76 */     return buffer.toString();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 81 */     if (!(o instanceof PrefixQuery))
/* 82 */       return false; 
/* 83 */     PrefixQuery other = (PrefixQuery)o;
/* 84 */     return (getBoost() == other.getBoost() && this.prefix.equals(other.prefix));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 90 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.prefix.hashCode() ^ 0x6634D93C; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\PrefixQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Query,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Query
/*     */   implements Serializable, Cloneable
/*     */ {
/*  48 */   private float boost = 1.0F;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  54 */   public void setBoost(float b) { this.boost = b; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  60 */   public float getBoost() { return this.boost; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract String toString(String paramString);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   public String toString() { return toString(""""); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  88 */   protected Weight createWeight(Searcher searcher) throws IOException { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Weight weight(Searcher searcher) throws IOException {
/*  94 */     Query query = searcher.rewrite(this);
/*  95 */     Weight weight = query.createWeight(searcher);
/*  96 */     float sum = weight.sumOfSquaredWeights();
/*  97 */     float norm = getSimilarity(searcher).queryNorm(sum);
/*  98 */     weight.normalize(norm);
/*  99 */     return weight;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Query combine(Query[] queries) {
/* 122 */     HashSet uniques = new HashSet();
/* 123 */     for (int i = 0; i < queries.length; i++) {
/* 124 */       Query query = queries[i];
/* 125 */       BooleanClause[] clauses = null;
/*     */       
/* 127 */       boolean splittable = query instanceof BooleanQuery;
/* 128 */       if (splittable) {
/* 129 */         BooleanQuery bq = (BooleanQuery)query;
/* 130 */         splittable = bq.isCoordDisabled();
/* 131 */         clauses = bq.getClauses();
/* 132 */         for (int j = 0; splittable && j < clauses.length; j++) {
/* 133 */           splittable = (clauses[j].getOccur() == BooleanClause.Occur.SHOULD);
/*     */         }
/*     */       } 
/* 136 */       if (splittable) {
/* 137 */         for (int j = 0; j < clauses.length; j++) {
/* 138 */           uniques.add(clauses[j].getQuery());
/*     */         }
/*     */       } else {
/* 141 */         uniques.add(query);
/*     */       } 
/*     */     } 
/*     */     
/* 145 */     if (uniques.size() == 1) {
/* 146 */       return uniques.iterator().next();
/*     */     }
/* 148 */     Iterator it = uniques.iterator();
/* 149 */     BooleanQuery result = new BooleanQuery(true);
/* 150 */     while (it.hasNext())
/* 151 */       result.add(it.next(), BooleanClause.Occur.SHOULD); 
/* 152 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 163 */   public void extractTerms(Set terms) { throw new UnsupportedOperationException(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static Query mergeBooleanQueries(Query[] queries) {
/* 173 */     HashSet allClauses = new HashSet();
/* 174 */     for (int i = 0; i < queries.length; i++) {
/* 175 */       BooleanClause[] clauses = ((BooleanQuery)queries[i]).getClauses();
/* 176 */       for (int j = 0; j < clauses.length; j++) {
/* 177 */         allClauses.add(clauses[j]);
/*     */       }
/*     */     } 
/*     */     
/* 181 */     boolean coordDisabled = (queries.length == 0) ? false : ((BooleanQuery)queries[0]).isCoordDisabled();
/*     */     
/* 183 */     BooleanQuery result = new BooleanQuery(coordDisabled);
/* 184 */     Iterator i = allClauses.iterator();
/* 185 */     while (i.hasNext()) {
/* 186 */       result.add(i.next());
/*     */     }
/* 188 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 196 */   public Similarity getSimilarity(Searcher searcher) { return searcher.getSimilarity(); }
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/*     */     try {
/* 202 */       return super.clone();
/* 203 */     } catch (CloneNotSupportedException e) {
/* 204 */       throw new RuntimeException(""Clone not supported: "" + e.getMessage());
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Query.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueryFilter
/*    */   extends CachingWrapperFilter
/*    */ {
/* 34 */   public QueryFilter(Query query) { super(new QueryWrapperFilter(query)); }
/*    */ 
/*    */ 
/*    */   
/* 38 */   public boolean equals(Object o) { return super.equals(o); }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public int hashCode() { return super.hashCode() ^ 0x923F64B9; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\QueryFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryTermVector,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.StringReader;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Arrays;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Map;
/*     */ import org.apache.lucene.analysis.Analyzer;
/*     */ import org.apache.lucene.analysis.Token;
/*     */ import org.apache.lucene.analysis.TokenStream;
/*     */ import org.apache.lucene.index.TermFreqVector;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class QueryTermVector
/*     */   implements TermFreqVector
/*     */ {
/*  34 */   private String[] terms = new String[0];
/*  35 */   private int[] termFreqs = new int[0];
/*     */   
/*  37 */   public String getField() { return null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  45 */   public QueryTermVector(String[] queryTerms) { processTerms(queryTerms); }
/*     */ 
/*     */   
/*     */   public QueryTermVector(String queryString, Analyzer analyzer) {
/*  49 */     if (analyzer != null) {
/*     */       
/*  51 */       TokenStream stream = analyzer.tokenStream("""", new StringReader(queryString));
/*  52 */       if (stream != null) {
/*     */         
/*  54 */         Token next = null;
/*  55 */         List terms = new ArrayList();
/*     */         try {
/*  57 */           while ((next = stream.next()) != null)
/*     */           {
/*  59 */             terms.add(next.termText());
/*     */           }
/*  61 */           processTerms(terms.toArray(new String[terms.size()]));
/*  62 */         } catch (IOException e) {}
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void processTerms(String[] queryTerms) {
/*  69 */     if (queryTerms != null) {
/*  70 */       Arrays.sort((Object[])queryTerms);
/*  71 */       Map tmpSet = new HashMap(queryTerms.length);
/*     */       
/*  73 */       List tmpList = new ArrayList(queryTerms.length);
/*  74 */       List tmpFreqs = new ArrayList(queryTerms.length);
/*  75 */       int j = 0;
/*  76 */       for (int i = 0; i < queryTerms.length; i++) {
/*  77 */         String term = queryTerms[i];
/*  78 */         Integer position = (Integer)tmpSet.get(term);
/*  79 */         if (position == null) {
/*  80 */           tmpSet.put(term, new Integer(j++));
/*  81 */           tmpList.add(term);
/*  82 */           tmpFreqs.add(new Integer(1));
/*     */         } else {
/*     */           
/*  85 */           Integer integer = tmpFreqs.get(position.intValue());
/*  86 */           tmpFreqs.set(position.intValue(), new Integer(integer.intValue() + 1));
/*     */         } 
/*     */       } 
/*  89 */       this.terms = tmpList.toArray(this.terms);
/*     */       
/*  91 */       this.termFreqs = new int[tmpFreqs.size()];
/*  92 */       int i = 0;
/*  93 */       for (Iterator iter = tmpFreqs.iterator(); iter.hasNext(); ) {
/*  94 */         Integer integer = iter.next();
/*  95 */         this.termFreqs[i++] = integer.intValue();
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public final String toString() {
/* 101 */     StringBuffer sb = new StringBuffer();
/* 102 */     sb.append('{');
/* 103 */     for (int i = 0; i < this.terms.length; i++) {
/* 104 */       if (i > 0) sb.append("", ""); 
/* 105 */       sb.append(this.terms[i]).append('/').append(this.termFreqs[i]);
/*     */     } 
/* 107 */     sb.append('}');
/* 108 */     return sb.toString();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 113 */   public int size() { return this.terms.length; }
/*     */ 
/*     */ 
/*     */   
/* 117 */   public String[] getTerms() { return this.terms; }
/*     */ 
/*     */ 
/*     */   
/* 121 */   public int[] getTermFrequencies() { return this.termFreqs; }
/*     */ 
/*     */   
/*     */   public int indexOf(String term) {
/* 125 */     int res = Arrays.binarySearch((Object[])this.terms, term);
/* 126 */     return (res >= 0) ? res : -1;
/*     */   }
/*     */   
/*     */   public int[] indexesOf(String[] terms, int start, int len) {
/* 130 */     int[] res = new int[len];
/*     */     
/* 132 */     for (int i = 0; i < len; i++) {
/* 133 */       res[i] = indexOf(terms[i]);
/*     */     }
/* 135 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\QueryTermVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.QueryWrapperFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class QueryWrapperFilter
/*    */   extends Filter
/*    */ {
/*    */   private Query query;
/*    */   
/* 44 */   public QueryWrapperFilter(Query query) { this.query = query; }
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 48 */     final BitSet bits = new BitSet(reader.maxDoc());
/*    */     
/* 50 */     (new IndexSearcher(reader)).search(this.query, new HitCollector() { private final BitSet val$bits;
/*    */           
/* 52 */           public final void collect(int doc, float score) { bits.set(doc); }
/*    */           private final QueryWrapperFilter this$0; }
/*    */       );
/* 55 */     return bits;
/*    */   }
/*    */ 
/*    */   
/* 59 */   public String toString() { return ""QueryWrapperFilter("" + this.query + "")""; }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 63 */     if (!(o instanceof QueryWrapperFilter))
/* 64 */       return false; 
/* 65 */     return this.query.equals(((QueryWrapperFilter)o).query);
/*    */   }
/*    */ 
/*    */   
/* 69 */   public int hashCode() { return this.query.hashCode() ^ 0x923F64B9; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\QueryWrapperFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RangeFilter,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.BitSet;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RangeFilter
/*     */   extends Filter
/*     */ {
/*     */   private String fieldName;
/*     */   private String lowerTerm;
/*     */   private String upperTerm;
/*     */   private boolean includeLower;
/*     */   private boolean includeUpper;
/*     */   
/*     */   public RangeFilter(String fieldName, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
/*  57 */     this.fieldName = fieldName;
/*  58 */     this.lowerTerm = lowerTerm;
/*  59 */     this.upperTerm = upperTerm;
/*  60 */     this.includeLower = includeLower;
/*  61 */     this.includeUpper = includeUpper;
/*     */     
/*  63 */     if (null == lowerTerm && null == upperTerm) {
/*  64 */       throw new IllegalArgumentException(""At least one value must be non-null"");
/*     */     }
/*     */     
/*  67 */     if (includeLower && null == lowerTerm) {
/*  68 */       throw new IllegalArgumentException(""The lower bound must be non-null to be inclusive"");
/*     */     }
/*     */     
/*  71 */     if (includeUpper && null == upperTerm) {
/*  72 */       throw new IllegalArgumentException(""The upper bound must be non-null to be inclusive"");
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  82 */   public static RangeFilter Less(String fieldName, String upperTerm) { return new RangeFilter(fieldName, null, upperTerm, false, true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  90 */   public static RangeFilter More(String fieldName, String lowerTerm) { return new RangeFilter(fieldName, lowerTerm, null, true, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BitSet bits(IndexReader reader) throws IOException {
/*  99 */     BitSet bits = new BitSet(reader.maxDoc());
/* 100 */     TermEnum enumerator = (null != this.lowerTerm) ? reader.terms(new Term(this.fieldName, this.lowerTerm)) : reader.terms(new Term(this.fieldName, """"));
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 107 */       if (enumerator.term() == null) {
/* 108 */         return bits;
/*     */       }
/*     */       
/* 111 */       boolean checkLower = false;
/* 112 */       if (!this.includeLower) {
/* 113 */         checkLower = true;
/*     */       }
/* 115 */       TermDocs termDocs = reader.termDocs();
/*     */ 
/*     */       
/*     */       try { while (true) {
/* 119 */           Term term = enumerator.term();
/* 120 */           if (term != null && term.field().equals(this.fieldName))
/* 121 */           { if (!checkLower || null == this.lowerTerm || term.text().compareTo(this.lowerTerm) > 0) {
/* 122 */               checkLower = false;
/* 123 */               if (this.upperTerm != null) {
/* 124 */                 int compare = this.upperTerm.compareTo(term.text());
/*     */ 
/*     */                 
/* 127 */                 if (compare < 0 || (!this.includeUpper && compare == 0)) {
/*     */                   break;
/*     */                 }
/*     */               } 
/*     */ 
/*     */ 
/*     */               
/* 134 */               termDocs.seek(enumerator.term());
/* 135 */               while (termDocs.next()) {
/* 136 */                 bits.set(termDocs.doc());
/*     */               }
/*     */             } 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 143 */             if (!enumerator.next())
/*     */               break;  continue; }  break;
/*     */         }  }
/* 146 */       finally { termDocs.close(); }
/*     */     
/*     */     } finally {
/* 149 */       enumerator.close();
/*     */     } 
/*     */     
/* 152 */     return bits;
/*     */   }
/*     */   
/*     */   public String toString() {
/* 156 */     StringBuffer buffer = new StringBuffer();
/* 157 */     buffer.append(this.fieldName);
/* 158 */     buffer.append("":"");
/* 159 */     buffer.append(this.includeLower ? ""["" : ""{"");
/* 160 */     if (null != this.lowerTerm) {
/* 161 */       buffer.append(this.lowerTerm);
/*     */     }
/* 163 */     buffer.append(""-"");
/* 164 */     if (null != this.upperTerm) {
/* 165 */       buffer.append(this.upperTerm);
/*     */     }
/* 167 */     buffer.append(this.includeUpper ? ""]"" : ""}"");
/* 168 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 173 */     if (this == o) return true; 
/* 174 */     if (!(o instanceof RangeFilter)) return false; 
/* 175 */     RangeFilter other = (RangeFilter)o;
/*     */     
/* 177 */     if (!this.fieldName.equals(other.fieldName) || this.includeLower != other.includeLower || this.includeUpper != other.includeUpper)
/*     */     {
/*     */       
/* 180 */       return false; } 
/* 181 */     if ((this.lowerTerm != null) ? !this.lowerTerm.equals(other.lowerTerm) : (other.lowerTerm != null)) return false; 
/* 182 */     if ((this.upperTerm != null) ? !this.upperTerm.equals(other.upperTerm) : (other.upperTerm != null)) return false; 
/* 183 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 188 */     int h = this.fieldName.hashCode();
/* 189 */     h ^= (this.lowerTerm != null) ? this.lowerTerm.hashCode() : -1225987966;
/* 190 */     h = h << 1 | h >>> 31;
/* 191 */     h ^= (this.upperTerm != null) ? this.upperTerm.hashCode() : -1849769278;
/* 192 */     h ^= (this.includeLower ? -729499341 : 0) ^ (this.includeUpper ? 1793336236 : 0);
/*     */     
/* 194 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\RangeFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RangeQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermEnum;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RangeQuery
/*     */   extends Query
/*     */ {
/*     */   private Term lowerTerm;
/*     */   private Term upperTerm;
/*     */   private boolean inclusive;
/*     */   
/*     */   public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
/*  58 */     if (lowerTerm == null && upperTerm == null)
/*     */     {
/*  60 */       throw new IllegalArgumentException(""At least one term must be non-null"");
/*     */     }
/*  62 */     if (lowerTerm != null && upperTerm != null && lowerTerm.field() != upperTerm.field())
/*     */     {
/*  64 */       throw new IllegalArgumentException(""Both terms must be for the same field"");
/*     */     }
/*     */ 
/*     */     
/*  68 */     if (lowerTerm != null) {
/*  69 */       this.lowerTerm = lowerTerm;
/*     */     } else {
/*     */       
/*  72 */       this.lowerTerm = new Term(upperTerm.field(), """");
/*     */     } 
/*     */     
/*  75 */     this.upperTerm = upperTerm;
/*  76 */     this.inclusive = inclusive;
/*     */   }
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  81 */     BooleanQuery query = new BooleanQuery(true);
/*  82 */     TermEnum enumerator = reader.terms(this.lowerTerm);
/*     */ 
/*     */ 
/*     */     
/*  86 */     try { boolean checkLower = false;
/*  87 */       if (!this.inclusive) {
/*  88 */         checkLower = true;
/*     */       }
/*  90 */       String testField = getField();
/*     */       
/*     */       while (true) {
/*  93 */         Term term = enumerator.term();
/*  94 */         if (term != null && term.field() == testField)
/*  95 */         { if (!checkLower || term.text().compareTo(this.lowerTerm.text()) > 0) {
/*  96 */             checkLower = false;
/*  97 */             if (this.upperTerm != null) {
/*  98 */               int compare = this.upperTerm.text().compareTo(term.text());
/*     */ 
/*     */               
/* 101 */               if (compare < 0 || (!this.inclusive && compare == 0))
/*     */                 break; 
/*     */             } 
/* 104 */             TermQuery tq = new TermQuery(term);
/* 105 */             tq.setBoost(getBoost());
/* 106 */             query.add(tq, BooleanClause.Occur.SHOULD);
/*     */           } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */           
/* 113 */           if (!enumerator.next())
/*     */             break;  continue; }  break;
/*     */       }  }
/* 116 */     finally { enumerator.close(); }
/*     */     
/* 118 */     return query;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 123 */   public String getField() { return (this.lowerTerm != null) ? this.lowerTerm.field() : this.upperTerm.field(); }
/*     */ 
/*     */ 
/*     */   
/* 127 */   public Term getLowerTerm() { return this.lowerTerm; }
/*     */ 
/*     */   
/* 130 */   public Term getUpperTerm() { return this.upperTerm; }
/*     */ 
/*     */   
/* 133 */   public boolean isInclusive() { return this.inclusive; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 139 */     StringBuffer buffer = new StringBuffer();
/* 140 */     if (!getField().equals(field)) {
/*     */       
/* 142 */       buffer.append(getField());
/* 143 */       buffer.append("":"");
/*     */     } 
/* 145 */     buffer.append(this.inclusive ? ""["" : ""{"");
/* 146 */     buffer.append((this.lowerTerm != null) ? this.lowerTerm.text() : ""null"");
/* 147 */     buffer.append("" TO "");
/* 148 */     buffer.append((this.upperTerm != null) ? this.upperTerm.text() : ""null"");
/* 149 */     buffer.append(this.inclusive ? ""]"" : ""}"");
/* 150 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 151 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 156 */     if (this == o) return true; 
/* 157 */     if (!(o instanceof RangeQuery)) return false;
/*     */     
/* 159 */     RangeQuery other = (RangeQuery)o;
/* 160 */     if (getBoost() != other.getBoost()) return false; 
/* 161 */     if (this.inclusive != other.inclusive) return false;
/*     */     
/* 163 */     if ((this.lowerTerm != null) ? !this.lowerTerm.equals(other.lowerTerm) : (other.lowerTerm != null)) return false; 
/* 164 */     if ((this.upperTerm != null) ? !this.upperTerm.equals(other.upperTerm) : (other.upperTerm != null)) return false; 
/* 165 */     return true;
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 170 */     int h = Float.floatToIntBits(getBoost());
/* 171 */     h ^= (this.lowerTerm != null) ? this.lowerTerm.hashCode() : 0;
/*     */ 
/*     */     
/* 174 */     h ^= h << 25 | h >>> 8;
/* 175 */     h ^= (this.upperTerm != null) ? this.upperTerm.hashCode() : 0;
/* 176 */     h ^= this.inclusive ? 658696010 : 0;
/* 177 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\RangeQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteCachingWrapperFilter,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.BitSet;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class RemoteCachingWrapperFilter
/*    */   extends Filter
/*    */ {
/*    */   protected Filter filter;
/*    */   
/* 45 */   public RemoteCachingWrapperFilter(Filter filter) { this.filter = filter; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public BitSet bits(IndexReader reader) throws IOException {
/* 55 */     Filter cachedFilter = FilterManager.getInstance().getFilter(this.filter);
/* 56 */     return cachedFilter.bits(reader);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\RemoteCachingWrapperFilter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteSearchable,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.rmi.Naming;
/*     */ import java.rmi.RMISecurityManager;
/*     */ import java.rmi.RemoteException;
/*     */ import java.rmi.server.UnicastRemoteObject;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.document.FieldSelector;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RemoteSearchable
/*     */   extends UnicastRemoteObject
/*     */   implements Searchable
/*     */ {
/*     */   private Searchable local;
/*     */   
/*  45 */   public RemoteSearchable(Searchable local) throws RemoteException { this.local = local; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  51 */   public void search(Weight weight, Filter filter, HitCollector results) throws IOException { this.local.search(weight, filter, results); }
/*     */ 
/*     */ 
/*     */   
/*  55 */   public void close() throws IOException { this.local.close(); }
/*     */ 
/*     */ 
/*     */   
/*  59 */   public int docFreq(Term term) throws IOException { return this.local.docFreq(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   public int[] docFreqs(Term[] terms) throws IOException { return this.local.docFreqs(terms); }
/*     */ 
/*     */ 
/*     */   
/*  68 */   public int maxDoc() throws IOException { return this.local.maxDoc(); }
/*     */ 
/*     */ 
/*     */   
/*  72 */   public TopDocs search(Weight weight, Filter filter, int n) throws IOException { return this.local.search(weight, filter, n); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  78 */   public TopFieldDocs search(Weight weight, Filter filter, int n, Sort sort) throws IOException { return this.local.search(weight, filter, n, sort); }
/*     */ 
/*     */ 
/*     */   
/*  82 */   public Document doc(int i) throws CorruptIndexException, IOException { return this.local.doc(i); }
/*     */ 
/*     */ 
/*     */   
/*  86 */   public Document doc(int i, FieldSelector fieldSelector) throws CorruptIndexException, IOException { return this.local.doc(i, fieldSelector); }
/*     */ 
/*     */ 
/*     */   
/*  90 */   public Query rewrite(Query original) throws IOException { return this.local.rewrite(original); }
/*     */ 
/*     */ 
/*     */   
/*  94 */   public Explanation explain(Weight weight, int doc) throws IOException { return this.local.explain(weight, doc); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void main(String[] args) throws Exception {
/* 100 */     String indexName = null;
/*     */     
/* 102 */     if (args != null && args.length == 1) {
/* 103 */       indexName = args[0];
/*     */     }
/* 105 */     if (indexName == null) {
/* 106 */       System.out.println(""Usage: org.apache.lucene.search.RemoteSearchable <index>"");
/*     */       
/*     */       return;
/*     */     } 
/*     */     
/* 111 */     if (System.getSecurityManager() == null) {
/* 112 */       System.setSecurityManager(new RMISecurityManager());
/*     */     }
/*     */     
/* 115 */     Searchable local = new IndexSearcher(indexName);
/* 116 */     RemoteSearchable impl = new RemoteSearchable(local);
/*     */ 
/*     */     
/* 119 */     Naming.rebind(""//localhost/Searchable"", impl);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\RemoteSearchable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.RemoteSearchable_Stub,"package org.apache.lucene.search;
import java.io.IOException;
import java.lang.reflect.Method;
import java.rmi.Remote;
import java.rmi.UnexpectedException;
import java.rmi.server.RemoteRef;
import java.rmi.server.RemoteStub;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.FieldSelector;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.Term;
public final class RemoteSearchable_Stub extends RemoteStub implements Searchable, Remote {
  private static final long serialVersionUID = 2L;
  private static Method $method_close_0;
  private static Method $method_doc_1;
  private static Method $method_doc_2;
  private static Method $method_docFreq_3;
  private static Method $method_docFreqs_4;
  private static Method $method_explain_5;
  private static Method $method_maxDoc_6;
  private static Method $method_rewrite_7;
  private static Method $method_search_8;
  private static Method $method_search_9;
  private static Method $method_search_10;
  static Class array$Lorg$apache$lucene$index$Term;
  static  {
    try {
      $method_close_0 = Searchable.class.getMethod(""close"", new Class[0]);
      $method_doc_1 = Searchable.class.getMethod(""doc"", new Class[] { int.class });
      $method_doc_2 = Searchable.class.getMethod(""doc"", new Class[] { int.class, FieldSelector.class });
      $method_docFreq_3 = Searchable.class.getMethod(""docFreq"", new Class[] { Term.class });
      $method_docFreqs_4 = Searchable.class.getMethod(""docFreqs"", new Class[] { (array$Lorg$apache$lucene$index$Term != null) ? array$Lorg$apache$lucene$index$Term : (array$Lorg$apache$lucene$index$Term = class$(""[Lorg.apache.lucene.index.Term;"")) });
      $method_explain_5 = Searchable.class.getMethod(""explain"", new Class[] { Weight.class, int.class });
      $method_maxDoc_6 = Searchable.class.getMethod(""maxDoc"", new Class[0]);
      $method_rewrite_7 = Searchable.class.getMethod(""rewrite"", new Class[] { Query.class });
      $method_search_8 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, int.class });
      $method_search_9 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, int.class, Sort.class });
      $method_search_10 = Searchable.class.getMethod(""search"", new Class[] { Weight.class, Filter.class, HitCollector.class });
    } catch (NoSuchMethodException noSuchMethodException) {
      throw new NoSuchMethodError(""stub class initialization failed"");
    } 
  }
  public RemoteSearchable_Stub(RemoteRef paramRemoteRef) { super(paramRemoteRef); }
  public void close() throws IOException {
    try {
      this.ref.invoke(this, $method_close_0, null, -4742752445160157748L);
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Document doc(int paramInt) throws IOException, CorruptIndexException {
    try {
      Object object = this.ref.invoke(this, $method_doc_1, new Object[] { new Integer(paramInt) }, -3205250690722925732L);
      return (Document)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Document doc(int paramInt, FieldSelector paramFieldSelector) throws IOException, CorruptIndexException {
    try {
      Object object = this.ref.invoke(this, $method_doc_2, new Object[] { new Integer(paramInt), paramFieldSelector }, 7307006286330810481L);
      return (Document)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int docFreq(Term paramTerm) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_docFreq_3, new Object[] { paramTerm }, -7822449680410044026L);
      return ((Integer)object).intValue();
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int[] docFreqs(Term[] paramArrayOfTerm) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_docFreqs_4, new Object[] { paramArrayOfTerm }, -6962924314824234139L);
      return (int[])object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Explanation explain(Weight paramWeight, int paramInt) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_explain_5, new Object[] { paramWeight, new Integer(paramInt) }, -5828411204312880318L);
      return (Explanation)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public int maxDoc() throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_maxDoc_6, null, -2054052621300804366L);
      return ((Integer)object).intValue();
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public Query rewrite(Query paramQuery) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_rewrite_7, new Object[] { paramQuery }, 6327992687997160630L);
      return (Query)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_search_8, new Object[] { paramWeight, paramFilter, new Integer(paramInt) }, -851074451725023257L);
      return (TopDocs)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException {
    try {
      Object object = this.ref.invoke(this, $method_search_9, new Object[] { paramWeight, paramFilter, new Integer(paramInt), paramSort }, 587843085215608570L);
      return (TopFieldDocs)object;
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
  public void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException {
    try {
      this.ref.invoke(this, $method_search_10, new Object[] { paramWeight, paramFilter, paramHitCollector }, -5970991905374566433L);
    } catch (RuntimeException runtimeException) {
      throw runtimeException;
    } catch (IOException iOException) {
      throw iOException;
    } catch (Exception exception) {
      throw new UnexpectedException(""undeclared checked exception"", exception);
    } 
  }
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\RemoteSearchable_Stub.class
 * Java compiler version: 1 (45.3)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ReqExclScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ReqExclScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Scorer reqScorer;
/*     */   private Scorer exclScorer;
/*     */   private boolean firstTime;
/*     */   
/*     */   public ReqExclScorer(Scorer reqScorer, Scorer exclScorer) {
/*  38 */     super(null);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  43 */     this.firstTime = true;
/*     */     this.reqScorer = reqScorer;
/*     */     this.exclScorer = exclScorer; } public boolean next() throws IOException {
/*  46 */     if (this.firstTime) {
/*  47 */       if (!this.exclScorer.next()) {
/*  48 */         this.exclScorer = null;
/*     */       }
/*  50 */       this.firstTime = false;
/*     */     } 
/*  52 */     if (this.reqScorer == null) {
/*  53 */       return false;
/*     */     }
/*  55 */     if (!this.reqScorer.next()) {
/*  56 */       this.reqScorer = null;
/*  57 */       return false;
/*     */     } 
/*  59 */     if (this.exclScorer == null) {
/*  60 */       return true;
/*     */     }
/*  62 */     return toNonExcluded();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean toNonExcluded() throws IOException {
/*  77 */     int exclDoc = this.exclScorer.doc();
/*     */     do {
/*  79 */       int reqDoc = this.reqScorer.doc();
/*  80 */       if (reqDoc < exclDoc)
/*  81 */         return true; 
/*  82 */       if (reqDoc <= exclDoc)
/*  83 */         continue;  if (!this.exclScorer.skipTo(reqDoc)) {
/*  84 */         this.exclScorer = null;
/*  85 */         return true;
/*     */       } 
/*  87 */       exclDoc = this.exclScorer.doc();
/*  88 */       if (exclDoc > reqDoc) {
/*  89 */         return true;
/*     */       }
/*     */     }
/*  92 */     while (this.reqScorer.next());
/*  93 */     this.reqScorer = null;
/*  94 */     return false;
/*     */   }
/*     */ 
/*     */   
/*  98 */   public int doc() { return this.reqScorer.doc(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public float score() throws IOException { return this.reqScorer.score(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 116 */     if (this.firstTime) {
/* 117 */       this.firstTime = false;
/* 118 */       if (!this.exclScorer.skipTo(target)) {
/* 119 */         this.exclScorer = null;
/*     */       }
/*     */     } 
/* 122 */     if (this.reqScorer == null) {
/* 123 */       return false;
/*     */     }
/* 125 */     if (this.exclScorer == null) {
/* 126 */       return this.reqScorer.skipTo(target);
/*     */     }
/* 128 */     if (!this.reqScorer.skipTo(target)) {
/* 129 */       this.reqScorer = null;
/* 130 */       return false;
/*     */     } 
/* 132 */     return toNonExcluded();
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 136 */     Explanation res = new Explanation();
/* 137 */     if (this.exclScorer.skipTo(doc) && this.exclScorer.doc() == doc) {
/* 138 */       res.setDescription(""excluded"");
/*     */     } else {
/* 140 */       res.setDescription(""not excluded"");
/* 141 */       res.addDetail(this.reqScorer.explain(doc));
/*     */     } 
/* 143 */     return res;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ReqExclScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ReqOptSumScorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ReqOptSumScorer
/*    */   extends Scorer
/*    */ {
/*    */   private Scorer reqScorer;
/*    */   private Scorer optScorer;
/*    */   private boolean firstTimeOptScorer;
/*    */   
/*    */   public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer) {
/* 41 */     super(null);
/*    */ 
/*    */ 
/*    */ 
/*    */     
/* 46 */     this.firstTimeOptScorer = true;
/*    */     this.reqScorer = reqScorer;
/*    */     this.optScorer = optScorer;
/* 49 */   } public boolean next() throws IOException { return this.reqScorer.next(); }
/*    */ 
/*    */ 
/*    */   
/* 53 */   public boolean skipTo(int target) throws IOException { return this.reqScorer.skipTo(target); }
/*    */ 
/*    */ 
/*    */   
/* 57 */   public int doc() { return this.reqScorer.doc(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public float score() throws IOException {
/* 66 */     int curDoc = this.reqScorer.doc();
/* 67 */     float reqScore = this.reqScorer.score();
/* 68 */     if (this.firstTimeOptScorer)
/* 69 */     { this.firstTimeOptScorer = false;
/* 70 */       if (!this.optScorer.skipTo(curDoc)) {
/* 71 */         this.optScorer = null;
/* 72 */         return reqScore;
/*    */       }  }
/* 74 */     else { if (this.optScorer == null)
/* 75 */         return reqScore; 
/* 76 */       if (this.optScorer.doc() < curDoc && !this.optScorer.skipTo(curDoc)) {
/* 77 */         this.optScorer = null;
/* 78 */         return reqScore;
/*    */       }  }
/*    */     
/* 81 */     return (this.optScorer.doc() == curDoc) ? (reqScore + this.optScorer.score()) : reqScore;
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Explanation explain(int doc) throws IOException {
/* 91 */     Explanation res = new Explanation();
/* 92 */     res.setDescription(""required, optional"");
/* 93 */     res.addDetail(this.reqScorer.explain(doc));
/* 94 */     res.addDetail(this.optScorer.explain(doc));
/* 95 */     return res;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ReqOptSumScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ScoreDoc,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ScoreDoc
/*    */   implements Serializable
/*    */ {
/*    */   public float score;
/*    */   public int doc;
/*    */   
/*    */   public ScoreDoc(int doc, float score) {
/* 33 */     this.doc = doc;
/* 34 */     this.score = score;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ScoreDoc.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.ScoreDocComparator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public interface ScoreDocComparator
/*    */ {
/* 33 */   public static final ScoreDocComparator RELEVANCE = new ScoreDocComparator() {
/*    */       public int compare(ScoreDoc i, ScoreDoc j) {
/* 35 */         if (i.score > j.score) return -1; 
/* 36 */         if (i.score < j.score) return 1; 
/* 37 */         return 0;
/*    */       }
/*    */       
/* 40 */       public Comparable sortValue(ScoreDoc i) { return new Float(i.score); }
/*    */ 
/*    */       
/* 43 */       public int sortType() { return 0; }
/*    */     };
/*    */ 
/*    */ 
/*    */   
/* 48 */   public static final ScoreDocComparator INDEXORDER = new ScoreDocComparator() {
/*    */       public int compare(ScoreDoc i, ScoreDoc j) {
/* 50 */         if (i.doc < j.doc) return -1; 
/* 51 */         if (i.doc > j.doc) return 1; 
/* 52 */         return 0;
/*    */       }
/*    */       
/* 55 */       public Comparable sortValue(ScoreDoc i) { return new Integer(i.doc); }
/*    */ 
/*    */       
/* 58 */       public int sortType() { return 1; }
/*    */     };
/*    */   
/*    */   int compare(ScoreDoc paramScoreDoc1, ScoreDoc paramScoreDoc2);
/*    */   
/*    */   Comparable sortValue(ScoreDoc paramScoreDoc);
/*    */   
/*    */   int sortType();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\ScoreDocComparator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Scorer,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Scorer
/*    */ {
/*    */   private Similarity similarity;
/*    */   
/* 34 */   protected Scorer(Similarity similarity) { this.similarity = similarity; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 39 */   public Similarity getSimilarity() { return this.similarity; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public void score(HitCollector hc) throws IOException {
/* 48 */     while (next()) {
/* 49 */       hc.collect(doc(), score());
/*    */     }
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected boolean score(HitCollector hc, int max) throws IOException {
/* 62 */     while (doc() < max) {
/* 63 */       hc.collect(doc(), score());
/* 64 */       if (!next())
/* 65 */         return false; 
/*    */     } 
/* 67 */     return true;
/*    */   }
/*    */   
/*    */   public abstract boolean next() throws IOException;
/*    */   
/*    */   public abstract int doc();
/*    */   
/*    */   public abstract float score() throws IOException;
/*    */   
/*    */   public abstract boolean skipTo(int paramInt) throws IOException;
/*    */   
/*    */   public abstract Explanation explain(int paramInt) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Scorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Searchable,"package org.apache.lucene.search;
import java.io.IOException;
import java.rmi.Remote;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.FieldSelector;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.Term;
public interface Searchable extends Remote {
  void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException;
  void close() throws IOException;
  int docFreq(Term paramTerm) throws IOException;
  int[] docFreqs(Term[] paramArrayOfTerm) throws IOException;
  int maxDoc() throws IOException;
  TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException;
  Document doc(int paramInt) throws CorruptIndexException, IOException;
  Document doc(int paramInt, FieldSelector paramFieldSelector) throws CorruptIndexException, IOException;
  Query rewrite(Query paramQuery) throws IOException;
  Explanation explain(Weight paramWeight, int paramInt) throws IOException;
  TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Searchable.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Searcher,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.document.Document;
/*     */ import org.apache.lucene.index.CorruptIndexException;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Searcher
/*     */   implements Searchable
/*     */ {
/*  38 */   public final Hits search(Query query) throws IOException { return search(query, (Filter)null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  46 */   public Hits search(Query query, Filter filter) throws IOException { return new Hits(this, query, filter); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  55 */   public Hits search(Query query, Sort sort) throws IOException { return new Hits(this, query, null, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   public Hits search(Query query, Filter filter, Sort sort) throws IOException { return new Hits(this, query, filter, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  78 */   public TopFieldDocs search(Query query, Filter filter, int n, Sort sort) throws IOException { return search(createWeight(query), filter, n, sort); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   public void search(Query query, HitCollector results) throws IOException { search(query, (Filter)null, results); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 118 */   public void search(Query query, Filter filter, HitCollector results) throws IOException { search(createWeight(query), filter, results); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 132 */   public TopDocs search(Query query, Filter filter, int n) throws IOException { return search(createWeight(query), filter, n); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 144 */   public Explanation explain(Query query, int doc) throws IOException { return explain(createWeight(query), doc); }
/*     */ 
/*     */ 
/*     */   
/* 148 */   private Similarity similarity = Similarity.getDefault();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public void setSimilarity(Similarity similarity) { this.similarity = similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 163 */   public Similarity getSimilarity() { return this.similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 171 */   protected Weight createWeight(Query query) throws IOException { return query.weight(this); }
/*     */ 
/*     */ 
/*     */   
/*     */   public int[] docFreqs(Term[] terms) throws IOException {
/* 176 */     int[] result = new int[terms.length];
/* 177 */     for (int i = 0; i < terms.length; i++) {
/* 178 */       result[i] = docFreq(terms[i]);
/*     */     }
/* 180 */     return result;
/*     */   }
/*     */   
/*     */   public abstract void search(Weight paramWeight, Filter paramFilter, HitCollector paramHitCollector) throws IOException;
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */   
/*     */   public abstract int docFreq(Term paramTerm) throws IOException;
/*     */   
/*     */   public abstract int maxDoc() throws IOException;
/*     */   
/*     */   public abstract TopDocs search(Weight paramWeight, Filter paramFilter, int paramInt) throws IOException;
/*     */   
/*     */   public abstract Document doc(int paramInt) throws CorruptIndexException, IOException;
/*     */   
/*     */   public abstract Query rewrite(Query paramQuery) throws IOException;
/*     */   
/*     */   public abstract Explanation explain(Weight paramWeight, int paramInt) throws IOException;
/*     */   
/*     */   public abstract TopFieldDocs search(Weight paramWeight, Filter paramFilter, int paramInt, Sort paramSort) throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Searcher.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Similarity,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.util.SmallFloat;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Similarity
/*     */   implements Serializable
/*     */ {
/* 292 */   private static Similarity defaultImpl = new DefaultSimilarity();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 301 */   public static void setDefault(Similarity similarity) { defaultImpl = similarity; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 313 */   public static Similarity getDefault() { return defaultImpl; }
/*     */ 
/*     */ 
/*     */   
/* 317 */   private static final float[] NORM_TABLE = new float[256];
/*     */   
/*     */   static  {
/* 320 */     for (int i = 0; i < 256; i++) {
/* 321 */       NORM_TABLE[i] = SmallFloat.byte315ToFloat((byte)i);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 328 */   public static float decodeNorm(byte b) { return NORM_TABLE[b & 0xFF]; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 335 */   public static float[] getNormDecoder() { return NORM_TABLE; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 390 */   public static byte encodeNorm(float f) { return SmallFloat.floatToByte315(f); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 410 */   public float tf(int freq) { return tf(freq); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 459 */   public float idf(Term term, Searcher searcher) throws IOException { return idf(searcher.docFreq(term), searcher.maxDoc()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float idf(Collection terms, Searcher searcher) throws IOException {
/* 472 */     float idf = 0.0F;
/* 473 */     Iterator i = terms.iterator();
/* 474 */     while (i.hasNext()) {
/* 475 */       idf += idf(i.next(), searcher);
/*     */     }
/* 477 */     return idf;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 531 */   public float scorePayload(byte[] payload, int offset, int length) { return 1.0F; }
/*     */   
/*     */   public abstract float lengthNorm(String paramString, int paramInt);
/*     */   
/*     */   public abstract float queryNorm(float paramFloat);
/*     */   
/*     */   public abstract float sloppyFreq(int paramInt);
/*     */   
/*     */   public abstract float tf(float paramFloat);
/*     */   
/*     */   public abstract float idf(int paramInt1, int paramInt2);
/*     */   
/*     */   public abstract float coord(int paramInt1, int paramInt2);
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Similarity.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SimilarityDelegator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SimilarityDelegator
/*    */   extends Similarity
/*    */ {
/*    */   private Similarity delegee;
/*    */   
/* 32 */   public SimilarityDelegator(Similarity delegee) { this.delegee = delegee; }
/*    */ 
/*    */ 
/*    */   
/* 36 */   public float lengthNorm(String fieldName, int numTerms) { return this.delegee.lengthNorm(fieldName, numTerms); }
/*    */ 
/*    */ 
/*    */   
/* 40 */   public float queryNorm(float sumOfSquaredWeights) { return this.delegee.queryNorm(sumOfSquaredWeights); }
/*    */ 
/*    */ 
/*    */   
/* 44 */   public float tf(float freq) { return this.delegee.tf(freq); }
/*    */ 
/*    */ 
/*    */   
/* 48 */   public float sloppyFreq(int distance) { return this.delegee.sloppyFreq(distance); }
/*    */ 
/*    */ 
/*    */   
/* 52 */   public float idf(int docFreq, int numDocs) { return this.delegee.idf(docFreq, numDocs); }
/*    */ 
/*    */ 
/*    */   
/* 56 */   public float coord(int overlap, int maxOverlap) { return this.delegee.coord(overlap, maxOverlap); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\SimilarityDelegator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SloppyPhraseScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Comparator;
/*     */ import java.util.HashMap;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class SloppyPhraseScorer
/*     */   extends PhraseScorer
/*     */ {
/*     */   private int slop;
/*     */   private PhrasePositions[] repeats;
/*     */   private boolean checkedRepeats;
/*     */   
/*     */   SloppyPhraseScorer(Weight weight, TermPositions[] tps, int[] offsets, Similarity similarity, int slop, byte[] norms) {
/*  34 */     super(weight, tps, offsets, similarity, norms);
/*  35 */     this.slop = slop;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final float phraseFreq() throws IOException {
/*  57 */     int end = initPhrasePositions();
/*     */     
/*  59 */     float freq = 0.0F;
/*  60 */     boolean done = (end < 0);
/*  61 */     while (!done) {
/*  62 */       PhrasePositions pp = (PhrasePositions)this.pq.pop();
/*  63 */       int start = pp.position;
/*  64 */       int next = ((PhrasePositions)this.pq.top()).position;
/*     */       
/*  66 */       boolean tpsDiffer = true; int pos;
/*  67 */       for (pos = start; pos <= next || !tpsDiffer; pos = pp.position) {
/*  68 */         if (pos <= next && tpsDiffer)
/*  69 */           start = pos; 
/*  70 */         if (!pp.nextPosition()) {
/*  71 */           done = true;
/*     */           break;
/*     */         } 
/*  74 */         tpsDiffer = (!pp.repeats || termPositionsDiffer(pp));
/*     */       } 
/*     */       
/*  77 */       int matchLength = end - start;
/*  78 */       if (matchLength <= this.slop) {
/*  79 */         freq += getSimilarity().sloppyFreq(matchLength);
/*     */       }
/*  81 */       if (pp.position > end)
/*  82 */         end = pp.position; 
/*  83 */       this.pq.put(pp);
/*     */     } 
/*     */     
/*  86 */     return freq;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private int initPhrasePositions() throws IOException {
/* 105 */     int end = 0;
/*     */ 
/*     */     
/* 108 */     if (this.checkedRepeats && this.repeats == null) {
/*     */       
/* 110 */       this.pq.clear();
/* 111 */       for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 112 */         pp.firstPosition();
/* 113 */         if (pp.position > end)
/* 114 */           end = pp.position; 
/* 115 */         this.pq.put(pp);
/*     */       } 
/* 117 */       return end;
/*     */     } 
/*     */ 
/*     */     
/* 121 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 122 */       pp.firstPosition();
/*     */     }
/*     */     
/* 125 */     if (!this.checkedRepeats) {
/* 126 */       this.checkedRepeats = true;
/*     */       
/* 128 */       HashMap m = null;
/* 129 */       for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 130 */         int tpPos = pp.position + pp.offset;
/* 131 */         for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {
/* 132 */           int tpPos2 = pp2.position + pp2.offset;
/* 133 */           if (tpPos2 == tpPos) {
/* 134 */             if (m == null)
/* 135 */               m = new HashMap(); 
/* 136 */             pp.repeats = true;
/* 137 */             pp2.repeats = true;
/* 138 */             m.put(pp, null);
/* 139 */             m.put(pp2, null);
/*     */           } 
/*     */         } 
/*     */       } 
/* 143 */       if (m != null) {
/* 144 */         this.repeats = (PhrasePositions[])m.keySet().toArray((Object[])new PhrasePositions[0]);
/*     */       }
/*     */     } 
/*     */     
/* 148 */     if (this.repeats != null) {
/*     */       
/* 150 */       Arrays.sort(this.repeats, new Comparator() { private final SloppyPhraseScorer this$0;
/*     */             
/* 152 */             public int compare(Object x, Object y) { return ((PhrasePositions)y).offset - ((PhrasePositions)x).offset; }
/*     */              }
/*     */         );
/* 155 */       for (int i = 0; i < this.repeats.length; i++) {
/* 156 */         PhrasePositions pp = this.repeats[i];
/* 157 */         while (!termPositionsDiffer(pp)) {
/* 158 */           if (!pp.nextPosition()) {
/* 159 */             return -1;
/*     */           }
/*     */         } 
/*     */       } 
/*     */     } 
/*     */     
/* 165 */     this.pq.clear();
/* 166 */     for (PhrasePositions pp = this.first; pp != null; pp = pp.next) {
/* 167 */       if (pp.position > end)
/* 168 */         end = pp.position; 
/* 169 */       this.pq.put(pp);
/*     */     } 
/*     */     
/* 172 */     return end;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean termPositionsDiffer(PhrasePositions pp) {
/* 182 */     int tpPos = pp.position + pp.offset;
/* 183 */     for (int i = 0; i < this.repeats.length; i++) {
/* 184 */       PhrasePositions pp2 = this.repeats[i];
/* 185 */       if (pp2 != pp) {
/*     */         
/* 187 */         int tpPos2 = pp2.position + pp2.offset;
/* 188 */         if (tpPos2 == tpPos)
/* 189 */           return false; 
/*     */       } 
/* 191 */     }  return true;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\SloppyPhraseScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Sort,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class Sort
/*     */   implements Serializable
/*     */ {
/* 104 */   public static final Sort RELEVANCE = new Sort();
/*     */ 
/*     */   
/* 107 */   public static final Sort INDEXORDER = new Sort(SortField.FIELD_DOC);
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   SortField[] fields;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 118 */   public Sort() { this(new SortField[] { SortField.FIELD_SCORE, SortField.FIELD_DOC }); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 129 */   public Sort(String field) { setSort(field, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 140 */   public Sort(String field, boolean reverse) { setSort(field, reverse); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 150 */   public Sort(String[] fields) { setSort(fields); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 155 */   public Sort(SortField field) { setSort(field); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 160 */   public Sort(SortField[] fields) { setSort(fields); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 168 */   public final void setSort(String field) { setSort(field, false); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setSort(String field, boolean reverse) {
/* 176 */     SortField[] nfields = { new SortField(field, 2, reverse), SortField.FIELD_DOC };
/*     */     
/* 178 */     this.fields = nfields;
/*     */   }
/*     */ 
/*     */   
/*     */   public void setSort(String[] fieldnames) {
/* 183 */     int n = fieldnames.length;
/* 184 */     SortField[] nfields = new SortField[n];
/* 185 */     for (int i = 0; i < n; i++) {
/* 186 */       nfields[i] = new SortField(fieldnames[i], 2);
/*     */     }
/* 188 */     this.fields = nfields;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 193 */   public void setSort(SortField field) { this.fields = new SortField[] { field }; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 198 */   public void setSort(SortField[] fields) { this.fields = fields; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 206 */   public SortField[] getSort() { return this.fields; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 210 */     StringBuffer buffer = new StringBuffer();
/*     */     
/* 212 */     for (int i = 0; i < this.fields.length; i++) {
/* 213 */       buffer.append(this.fields[i].toString());
/* 214 */       if (i + 1 < this.fields.length) {
/* 215 */         buffer.append(',');
/*     */       }
/*     */     } 
/* 218 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Sort.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortComparator,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class SortComparator
/*    */   implements SortComparatorSource
/*    */ {
/*    */   public ScoreDocComparator newComparator(IndexReader reader, String fieldname) throws IOException {
/* 48 */     String field = fieldname.intern();
/* 49 */     final Comparable[] cachedValues = FieldCache.DEFAULT.getCustom(reader, field, this);
/*    */     
/* 51 */     return new ScoreDocComparator() {
/*    */         private final Comparable[] val$cachedValues;
/*    */         
/* 54 */         public int compare(ScoreDoc i, ScoreDoc j) { return cachedValues[i.doc].compareTo(cachedValues[j.doc]); }
/*    */         
/*    */         private final SortComparator this$0;
/*    */         
/* 58 */         public Comparable sortValue(ScoreDoc i) { return cachedValues[i.doc]; }
/*    */ 
/*    */ 
/*    */         
/* 62 */         public int sortType() { return 9; }
/*    */       };
/*    */   }
/*    */   
/*    */   protected abstract Comparable getComparable(String paramString);
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\SortComparator.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortComparatorSource,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import org.apache.lucene.index.IndexReader;
public interface SortComparatorSource extends Serializable {
  ScoreDocComparator newComparator(IndexReader paramIndexReader, String paramString) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\SortComparatorSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.SortField,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.Serializable;
/*     */ import java.util.Locale;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SortField
/*     */   implements Serializable
/*     */ {
/*     */   public static final int SCORE = 0;
/*     */   public static final int DOC = 1;
/*     */   public static final int AUTO = 2;
/*     */   public static final int STRING = 3;
/*     */   public static final int INT = 4;
/*     */   public static final int FLOAT = 5;
/*     */   public static final int CUSTOM = 9;
/*  73 */   public static final SortField FIELD_SCORE = new SortField(null, 0);
/*     */ 
/*     */   
/*  76 */   public static final SortField FIELD_DOC = new SortField(null, 1);
/*     */   
/*     */   private String field;
/*     */   
/*  80 */   private int type = 2;
/*     */ 
/*     */   
/*     */   private Locale locale;
/*     */   
/*     */   boolean reverse = false;
/*     */   
/*     */   private SortComparatorSource factory;
/*     */ 
/*     */   
/*  90 */   public SortField(String field) { this.field = field.intern(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, boolean reverse) {
/*  99 */     this.field = field.intern();
/* 100 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, int type) {
/* 110 */     this.field = (field != null) ? field.intern() : field;
/* 111 */     this.type = type;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, int type, boolean reverse) {
/* 122 */     this.field = (field != null) ? field.intern() : field;
/* 123 */     this.type = type;
/* 124 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, Locale locale) {
/* 133 */     this.field = field.intern();
/* 134 */     this.type = 3;
/* 135 */     this.locale = locale;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, Locale locale, boolean reverse) {
/* 144 */     this.field = field.intern();
/* 145 */     this.type = 3;
/* 146 */     this.locale = locale;
/* 147 */     this.reverse = reverse;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, SortComparatorSource comparator) {
/* 155 */     this.field = (field != null) ? field.intern() : field;
/* 156 */     this.type = 9;
/* 157 */     this.factory = comparator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public SortField(String field, SortComparatorSource comparator, boolean reverse) {
/* 166 */     this.field = (field != null) ? field.intern() : field;
/* 167 */     this.type = 9;
/* 168 */     this.reverse = reverse;
/* 169 */     this.factory = comparator;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 177 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 184 */   public int getType() { return this.type; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 192 */   public Locale getLocale() { return this.locale; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 199 */   public boolean getReverse() { return this.reverse; }
/*     */ 
/*     */ 
/*     */   
/* 203 */   public SortComparatorSource getFactory() { return this.factory; }
/*     */ 
/*     */   
/*     */   public String toString() {
/* 207 */     StringBuffer buffer = new StringBuffer();
/* 208 */     switch (this.type) { case 0:
/* 209 */         buffer.append(""<score>"");
/*     */         break;
/*     */       case 1:
/* 212 */         buffer.append(""<doc>"");
/*     */         break;
/*     */       case 9:
/* 215 */         buffer.append(""<custom:\"""" + this.field + ""\"": "" + this.factory + "">"");
/*     */         break;
/*     */       
/*     */       default:
/* 219 */         buffer.append(""\"""" + this.field + ""\"""");
/*     */         break; }
/*     */ 
/*     */     
/* 223 */     if (this.locale != null) buffer.append(""("" + this.locale + "")""); 
/* 224 */     if (this.reverse) buffer.append('!');
/*     */     
/* 226 */     return buffer.toString();
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\SortField.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TermQuery,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class TermQuery
/*     */   extends Query
/*     */ {
/*     */   private Term term;
/*     */   
/*     */   private class TermWeight
/*     */     implements Weight
/*     */   {
/*     */     private Similarity similarity;
/*     */     private float value;
/*     */     private float idf;
/*     */     private float queryNorm;
/*     */     private float queryWeight;
/*     */     private final TermQuery this$0;
/*     */     
/*     */     public TermWeight(Searcher searcher) throws IOException {
/*  43 */       this.similarity = TermQuery.this.getSimilarity(searcher);
/*  44 */       this.idf = this.similarity.idf(TermQuery.this.term, searcher);
/*     */     }
/*     */     
/*  47 */     public String toString() { return ""weight("" + TermQuery.this + "")""; }
/*     */     
/*  49 */     public Query getQuery() { return TermQuery.this; }
/*  50 */     public float getValue() { return this.value; }
/*     */     
/*     */     public float sumOfSquaredWeights() {
/*  53 */       this.queryWeight = this.idf * TermQuery.this.getBoost();
/*  54 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */     
/*     */     public void normalize(float queryNorm) {
/*  58 */       this.queryNorm = queryNorm;
/*  59 */       this.queryWeight *= queryNorm;
/*  60 */       this.value = this.queryWeight * this.idf;
/*     */     }
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/*  64 */       TermDocs termDocs = reader.termDocs(TermQuery.this.term);
/*     */       
/*  66 */       if (termDocs == null) {
/*  67 */         return null;
/*     */       }
/*  69 */       return new TermScorer(this, termDocs, this.similarity, reader.norms(TermQuery.this.term.field()));
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  76 */       ComplexExplanation result = new ComplexExplanation();
/*  77 */       result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*     */       
/*  79 */       Explanation idfExpl = new Explanation(this.idf, ""idf(docFreq="" + reader.docFreq(TermQuery.this.term) + "")"");
/*     */ 
/*     */ 
/*     */       
/*  83 */       Explanation queryExpl = new Explanation();
/*  84 */       queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */       
/*  86 */       Explanation boostExpl = new Explanation(TermQuery.this.getBoost(), ""boost"");
/*  87 */       if (TermQuery.this.getBoost() != 1.0F)
/*  88 */         queryExpl.addDetail(boostExpl); 
/*  89 */       queryExpl.addDetail(idfExpl);
/*     */       
/*  91 */       Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/*  92 */       queryExpl.addDetail(queryNormExpl);
/*     */       
/*  94 */       queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/*  98 */       result.addDetail(queryExpl);
/*     */ 
/*     */       
/* 101 */       String field = TermQuery.this.term.field();
/* 102 */       ComplexExplanation fieldExpl = new ComplexExplanation();
/* 103 */       fieldExpl.setDescription(""fieldWeight("" + TermQuery.this.term + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */       
/* 106 */       Explanation tfExpl = scorer(reader).explain(doc);
/* 107 */       fieldExpl.addDetail(tfExpl);
/* 108 */       fieldExpl.addDetail(idfExpl);
/*     */       
/* 110 */       Explanation fieldNormExpl = new Explanation();
/* 111 */       byte[] fieldNorms = reader.norms(field);
/* 112 */       float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */       
/* 114 */       fieldNormExpl.setValue(fieldNorm);
/* 115 */       fieldNormExpl.setDescription(""fieldNorm(field="" + field + "", doc="" + doc + "")"");
/* 116 */       fieldExpl.addDetail(fieldNormExpl);
/*     */       
/* 118 */       fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
/* 119 */       fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */       
/* 123 */       result.addDetail(fieldExpl);
/* 124 */       result.setMatch(fieldExpl.getMatch());
/*     */ 
/*     */       
/* 127 */       result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */       
/* 129 */       if (queryExpl.getValue() == 1.0F) {
/* 130 */         return fieldExpl;
/*     */       }
/* 132 */       return result;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 138 */   public TermQuery(Term t) { this.term = t; }
/*     */ 
/*     */ 
/*     */   
/* 142 */   public Term getTerm() { return this.term; }
/*     */ 
/*     */   
/* 145 */   protected Weight createWeight(Searcher searcher) throws IOException { return new TermWeight(searcher); }
/*     */ 
/*     */ 
/*     */   
/* 149 */   public void extractTerms(Set terms) { terms.add(getTerm()); }
/*     */ 
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 154 */     StringBuffer buffer = new StringBuffer();
/* 155 */     if (!this.term.field().equals(field)) {
/* 156 */       buffer.append(this.term.field());
/* 157 */       buffer.append("":"");
/*     */     } 
/* 159 */     buffer.append(this.term.text());
/* 160 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 161 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 166 */     if (!(o instanceof TermQuery))
/* 167 */       return false; 
/* 168 */     TermQuery other = (TermQuery)o;
/* 169 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 175 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.term.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\TermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TermScorer,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.TermDocs;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ final class TermScorer
/*     */   extends Scorer
/*     */ {
/*     */   private Weight weight;
/*     */   private TermDocs termDocs;
/*     */   private byte[] norms;
/*     */   private float weightValue;
/*     */   private int doc;
/*  33 */   private final int[] docs = new int[32];
/*  34 */   private final int[] freqs = new int[32];
/*     */   
/*     */   private int pointer;
/*     */   private int pointerMax;
/*     */   private static final int SCORE_CACHE_SIZE = 32;
/*  39 */   private float[] scoreCache = new float[32];
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   TermScorer(Weight weight, TermDocs td, Similarity similarity, byte[] norms) {
/*  49 */     super(similarity);
/*  50 */     this.weight = weight;
/*  51 */     this.termDocs = td;
/*  52 */     this.norms = norms;
/*  53 */     this.weightValue = weight.getValue();
/*     */     
/*  55 */     for (int i = 0; i < 32; i++)
/*  56 */       this.scoreCache[i] = getSimilarity().tf(i) * this.weightValue; 
/*     */   }
/*     */   
/*     */   public void score(HitCollector hc) throws IOException {
/*  60 */     next();
/*  61 */     score(hc, 2147483647);
/*     */   }
/*     */   
/*     */   protected boolean score(HitCollector c, int end) throws IOException {
/*  65 */     Similarity similarity = getSimilarity();
/*  66 */     float[] normDecoder = Similarity.getNormDecoder();
/*  67 */     while (this.doc < end) {
/*  68 */       int f = this.freqs[this.pointer];
/*  69 */       float score = (f < 32) ? this.scoreCache[f] : (similarity.tf(f) * this.weightValue);
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*  74 */       score *= normDecoder[this.norms[this.doc] & 0xFF];
/*     */       
/*  76 */       c.collect(this.doc, score);
/*     */       
/*  78 */       if (++this.pointer >= this.pointerMax) {
/*  79 */         this.pointerMax = this.termDocs.read(this.docs, this.freqs);
/*  80 */         if (this.pointerMax != 0) {
/*  81 */           this.pointer = 0;
/*     */         } else {
/*  83 */           this.termDocs.close();
/*  84 */           this.doc = Integer.MAX_VALUE;
/*  85 */           return false;
/*     */         } 
/*     */       } 
/*  88 */       this.doc = this.docs[this.pointer];
/*     */     } 
/*  90 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/* 104 */     this.pointer++;
/* 105 */     if (this.pointer >= this.pointerMax) {
/* 106 */       this.pointerMax = this.termDocs.read(this.docs, this.freqs);
/* 107 */       if (this.pointerMax != 0) {
/* 108 */         this.pointer = 0;
/*     */       } else {
/* 110 */         this.termDocs.close();
/* 111 */         this.doc = Integer.MAX_VALUE;
/* 112 */         return false;
/*     */       } 
/*     */     } 
/* 115 */     this.doc = this.docs[this.pointer];
/* 116 */     return true;
/*     */   }
/*     */   
/*     */   public float score() {
/* 120 */     int f = this.freqs[this.pointer];
/* 121 */     float raw = (f < 32) ? this.scoreCache[f] : (getSimilarity().tf(f) * this.weightValue);
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 126 */     return raw * Similarity.decodeNorm(this.norms[this.doc]);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 137 */     this.pointer++; for (; this.pointer < this.pointerMax; this.pointer++) {
/* 138 */       if (this.docs[this.pointer] >= target) {
/* 139 */         this.doc = this.docs[this.pointer];
/* 140 */         return true;
/*     */       } 
/*     */     } 
/*     */ 
/*     */     
/* 145 */     boolean result = this.termDocs.skipTo(target);
/* 146 */     if (result) {
/* 147 */       this.pointerMax = 1;
/* 148 */       this.pointer = 0;
/* 149 */       this.docs[this.pointer] = this.doc = this.termDocs.doc();
/* 150 */       this.freqs[this.pointer] = this.termDocs.freq();
/*     */     } else {
/* 152 */       this.doc = Integer.MAX_VALUE;
/*     */     } 
/* 154 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/* 163 */     TermQuery query = (TermQuery)this.weight.getQuery();
/* 164 */     Explanation tfExplanation = new Explanation();
/* 165 */     int tf = 0;
/* 166 */     while (this.pointer < this.pointerMax) {
/* 167 */       if (this.docs[this.pointer] == doc)
/* 168 */         tf = this.freqs[this.pointer]; 
/* 169 */       this.pointer++;
/*     */     } 
/* 171 */     if (tf == 0 && 
/* 172 */       this.termDocs.skipTo(doc))
/*     */     {
/* 174 */       if (this.termDocs.doc() == doc)
/*     */       {
/* 176 */         tf = this.termDocs.freq();
/*     */       }
/*     */     }
/*     */     
/* 180 */     this.termDocs.close();
/* 181 */     tfExplanation.setValue(getSimilarity().tf(tf));
/* 182 */     tfExplanation.setDescription(""tf(termFreq("" + query.getTerm() + "")="" + tf + "")"");
/*     */     
/* 184 */     return tfExplanation;
/*     */   }
/*     */ 
/*     */   
/* 188 */   public String toString() { return ""scorer("" + this.weight + "")""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\TermScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopDocCollector,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import org.apache.lucene.util.PriorityQueue;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopDocCollector
/*    */   extends HitCollector
/*    */ {
/*    */   private int numHits;
/* 32 */   private float minScore = 0.0F;
/*    */ 
/*    */   
/*    */   int totalHits;
/*    */ 
/*    */   
/*    */   PriorityQueue hq;
/*    */ 
/*    */   
/* 41 */   public TopDocCollector(int numHits) { this(numHits, new HitQueue(numHits)); }
/*    */ 
/*    */   
/*    */   TopDocCollector(int numHits, PriorityQueue hq) {
/* 45 */     this.numHits = numHits;
/* 46 */     this.hq = hq;
/*    */   }
/*    */ 
/*    */   
/*    */   public void collect(int doc, float score) {
/* 51 */     if (score > 0.0F) {
/* 52 */       this.totalHits++;
/* 53 */       if (this.hq.size() < this.numHits || score >= this.minScore) {
/* 54 */         this.hq.insert(new ScoreDoc(doc, score));
/* 55 */         this.minScore = ((ScoreDoc)this.hq.top()).score;
/*    */       } 
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 61 */   public int getTotalHits() { return this.totalHits; }
/*    */ 
/*    */   
/*    */   public TopDocs topDocs() {
/* 65 */     ScoreDoc[] scoreDocs = new ScoreDoc[this.hq.size()];
/* 66 */     for (int i = this.hq.size() - 1; i >= 0; i--) {
/* 67 */       scoreDocs[i] = (ScoreDoc)this.hq.pop();
/*    */     }
/* 69 */     float maxScore = (this.totalHits == 0) ? Float.NEGATIVE_INFINITY : (scoreDocs[0]).score;
/*    */ 
/*    */ 
/*    */     
/* 73 */     return new TopDocs(this.totalHits, scoreDocs, maxScore);
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\TopDocCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopDocs,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopDocs
/*    */   implements Serializable
/*    */ {
/*    */   public int totalHits;
/*    */   public ScoreDoc[] scoreDocs;
/*    */   private float maxScore;
/*    */   
/* 34 */   public float getMaxScore() { return this.maxScore; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 39 */   public void setMaxScore(float maxScore) { this.maxScore = maxScore; }
/*    */ 
/*    */ 
/*    */   
/*    */   TopDocs(int totalHits, ScoreDoc[] scoreDocs, float maxScore) {
/* 44 */     this.totalHits = totalHits;
/* 45 */     this.scoreDocs = scoreDocs;
/* 46 */     this.maxScore = maxScore;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\TopDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopFieldDocCollector,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopFieldDocCollector
/*    */   extends TopDocCollector
/*    */ {
/* 41 */   public TopFieldDocCollector(IndexReader reader, Sort sort, int numHits) throws IOException { super(numHits, new FieldSortedHitQueue(reader, sort.fields, numHits)); }
/*    */ 
/*    */ 
/*    */   
/*    */   public void collect(int doc, float score) {
/* 46 */     if (score > 0.0F) {
/* 47 */       this.totalHits++;
/* 48 */       this.hq.insert(new FieldDoc(doc, score));
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/*    */   public TopDocs topDocs() {
/* 54 */     FieldSortedHitQueue fshq = (FieldSortedHitQueue)this.hq;
/* 55 */     ScoreDoc[] scoreDocs = new ScoreDoc[fshq.size()];
/* 56 */     for (int i = fshq.size() - 1; i >= 0; i--) {
/* 57 */       scoreDocs[i] = fshq.fillFields((FieldDoc)fshq.pop());
/*    */     }
/* 59 */     return new TopFieldDocs(this.totalHits, scoreDocs, fshq.getFields(), fshq.getMaxScore());
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\TopFieldDocCollector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.TopFieldDocs,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TopFieldDocs
/*    */   extends TopDocs
/*    */ {
/*    */   public SortField[] fields;
/*    */   
/*    */   TopFieldDocs(int totalHits, ScoreDoc[] scoreDocs, SortField[] fields, float maxScore) {
/* 44 */     super(totalHits, scoreDocs, maxScore);
/* 45 */     this.fields = fields;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\TopFieldDocs.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.Weight,"package org.apache.lucene.search;
import java.io.IOException;
import java.io.Serializable;
import org.apache.lucene.index.IndexReader;
public interface Weight extends Serializable {
  Query getQuery();
  float getValue();
  float sumOfSquaredWeights() throws IOException;
  void normalize(float paramFloat);
  Scorer scorer(IndexReader paramIndexReader) throws IOException;
  Explanation explain(IndexReader paramIndexReader, int paramInt) throws IOException;
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\Weight.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.WildcardQuery,"/*    */ package org.apache.lucene.search;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class WildcardQuery
/*    */   extends MultiTermQuery
/*    */ {
/*    */   private boolean termContainsWildcard;
/*    */   
/*    */   public WildcardQuery(Term term) {
/* 37 */     super(term);
/* 38 */     this.termContainsWildcard = (term.text().indexOf('*') != -1 || term.text().indexOf('?') != -1);
/*    */   }
/*    */ 
/*    */   
/* 42 */   protected FilteredTermEnum getEnum(IndexReader reader) throws IOException { return new WildcardTermEnum(reader, getTerm()); }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 46 */     if (o instanceof WildcardQuery) {
/* 47 */       return super.equals(o);
/*    */     }
/* 49 */     return false;
/*    */   }
/*    */   
/*    */   public Query rewrite(IndexReader reader) throws IOException {
/* 53 */     if (this.termContainsWildcard) {
/* 54 */       return super.rewrite(reader);
/*    */     }
/*    */     
/* 57 */     return new TermQuery(getTerm());
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\WildcardQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.WildcardTermEnum,"/*     */ package org.apache.lucene.search;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class WildcardTermEnum
/*     */   extends FilteredTermEnum
/*     */ {
/*     */   Term searchTerm;
/*  36 */   String field = """";
/*  37 */   String text = """";
/*  38 */   String pre = """";
/*  39 */   int preLen = 0;
/*     */ 
/*     */   
/*     */   boolean endEnum = false;
/*     */ 
/*     */   
/*     */   public static final char WILDCARD_STRING = '*';
/*     */ 
/*     */   
/*     */   public static final char WILDCARD_CHAR = '?';
/*     */ 
/*     */   
/*     */   public WildcardTermEnum(IndexReader reader, Term term) throws IOException {
/*  52 */     this.searchTerm = term;
/*  53 */     this.field = this.searchTerm.field();
/*  54 */     this.text = this.searchTerm.text();
/*     */     
/*  56 */     int sidx = this.text.indexOf('*');
/*  57 */     int cidx = this.text.indexOf('?');
/*  58 */     int idx = sidx;
/*  59 */     if (idx == -1) {
/*  60 */       idx = cidx;
/*     */     }
/*  62 */     else if (cidx >= 0) {
/*  63 */       idx = Math.min(idx, cidx);
/*     */     } 
/*     */     
/*  66 */     this.pre = this.searchTerm.text().substring(0, idx);
/*  67 */     this.preLen = this.pre.length();
/*  68 */     this.text = this.text.substring(this.preLen);
/*  69 */     setEnum(reader.terms(new Term(this.searchTerm.field(), this.pre)));
/*     */   }
/*     */   
/*     */   protected final boolean termCompare(Term term) {
/*  73 */     if (this.field == term.field()) {
/*  74 */       String searchText = term.text();
/*  75 */       if (searchText.startsWith(this.pre)) {
/*  76 */         return wildcardEquals(this.text, 0, searchText, this.preLen);
/*     */       }
/*     */     } 
/*  79 */     this.endEnum = true;
/*  80 */     return false;
/*     */   }
/*     */ 
/*     */   
/*  84 */   public final float difference() { return 1.0F; }
/*     */ 
/*     */ 
/*     */   
/*  88 */   public final boolean endEnum() { return this.endEnum; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static final boolean wildcardEquals(String pattern, int patternIdx, String string, int stringIdx) {
/* 106 */     int p = patternIdx;
/*     */     
/* 108 */     for (int s = stringIdx;; p++, s++) {
/*     */ 
/*     */       
/* 111 */       boolean sEnd = (s >= string.length());
/*     */       
/* 113 */       boolean pEnd = (p >= pattern.length());
/*     */ 
/*     */       
/* 116 */       if (sEnd) {
/*     */ 
/*     */         
/* 119 */         boolean justWildcardsLeft = true;
/*     */ 
/*     */         
/* 122 */         int wildcardSearchPos = p;
/*     */ 
/*     */         
/* 125 */         while (wildcardSearchPos < pattern.length() && justWildcardsLeft) {
/*     */ 
/*     */           
/* 128 */           char wildchar = pattern.charAt(wildcardSearchPos);
/*     */ 
/*     */ 
/*     */           
/* 132 */           if (wildchar != '?' && wildchar != '*') {
/*     */             
/* 134 */             justWildcardsLeft = false;
/*     */             
/*     */             continue;
/*     */           } 
/*     */           
/* 139 */           if (wildchar == '?') {
/* 140 */             return false;
/*     */           }
/*     */ 
/*     */           
/* 144 */           wildcardSearchPos++;
/*     */         } 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 150 */         if (justWildcardsLeft)
/*     */         {
/* 152 */           return true;
/*     */         }
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 158 */       if (sEnd || pEnd) {
/*     */         break;
/*     */       }
/*     */ 
/*     */ 
/*     */       
/* 164 */       if (pattern.charAt(p) != '?') {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 170 */         if (pattern.charAt(p) == '*') {
/*     */ 
/*     */           
/* 173 */           p++;
/*     */           
/* 175 */           for (int i = string.length(); i >= s; i--) {
/*     */             
/* 177 */             if (wildcardEquals(pattern, p, string, i))
/*     */             {
/* 179 */               return true;
/*     */             }
/*     */           } 
/*     */           break;
/*     */         } 
/* 184 */         if (pattern.charAt(p) != string.charAt(s)) {
/*     */           break;
/*     */         }
/*     */       } 
/*     */     } 
/* 189 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public void close() throws IOException {
/* 194 */     super.close();
/* 195 */     this.searchTerm = null;
/* 196 */     this.field = null;
/* 197 */     this.text = null;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\WildcardTermEnum.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ByteFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ByteFieldSource
/*     */   extends FieldCacheSource
/*     */ {
/*     */   private FieldCache.ByteParser parser;
/*     */   
/*  47 */   public ByteFieldSource(String field) { this(field, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public ByteFieldSource(String field, FieldCache.ByteParser parser) {
/*  54 */     super(field);
/*  55 */     this.parser = parser;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  60 */   public String description() { return ""byte("" + super.description() + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/*  65 */     final byte[] arr = (this.parser == null) ? cache.getBytes(reader, field) : cache.getBytes(reader, field, this.parser);
/*     */ 
/*     */     
/*  68 */     return new DocValues(reader.maxDoc()) {
/*     */         private final byte[] val$arr;
/*     */         
/*  71 */         public float floatVal(int doc) { return arr[doc]; }
/*     */         
/*     */         private final ByteFieldSource this$0;
/*     */         
/*  75 */         public int intVal(int doc) { return arr[doc]; }
/*     */ 
/*     */ 
/*     */         
/*  79 */         public String toString(int doc) { return ByteFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  83 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/*  90 */     if (o.getClass() != ByteFieldSource.class) {
/*  91 */       return false;
/*     */     }
/*  93 */     ByteFieldSource other = (ByteFieldSource)o;
/*  94 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Byte.class.hashCode() : this.parser.getClass().hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\ByteFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.CustomScoreQuery,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.ComplexExplanation;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class CustomScoreQuery
/*     */   extends Query
/*     */ {
/*     */   private Query subQuery;
/*     */   private ValueSourceQuery valSrcQuery;
/*     */   private boolean strict = false;
/*     */   
/*  59 */   public CustomScoreQuery(Query subQuery) { this(subQuery, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public CustomScoreQuery(Query subQuery, ValueSourceQuery valSrcQuery) {
/*  72 */     this.subQuery = subQuery;
/*  73 */     this.valSrcQuery = valSrcQuery;
/*  74 */     if (subQuery == null) throw new IllegalArgumentException(""<subqyery> must not be null!"");
/*     */   
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  79 */     this.subQuery = this.subQuery.rewrite(reader);
/*  80 */     if (this.valSrcQuery != null) {
/*  81 */       this.valSrcQuery = (ValueSourceQuery)this.valSrcQuery.rewrite(reader);
/*     */     }
/*  83 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {
/*  88 */     this.subQuery.extractTerms(terms);
/*  89 */     if (this.valSrcQuery != null) {
/*  90 */       this.valSrcQuery.extractTerms(terms);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   public Object clone() {
/*  96 */     CustomScoreQuery clone = (CustomScoreQuery)super.clone();
/*  97 */     clone.subQuery = (Query)this.subQuery.clone();
/*  98 */     if (this.valSrcQuery != null) {
/*  99 */       clone.valSrcQuery = (ValueSourceQuery)this.valSrcQuery.clone();
/*     */     }
/* 101 */     return clone;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 106 */     StringBuffer sb = (new StringBuffer(name())).append(""("");
/* 107 */     sb.append(this.subQuery.toString(field));
/* 108 */     if (this.valSrcQuery != null) {
/* 109 */       sb.append("", "").append(this.valSrcQuery.toString(field));
/*     */     }
/* 111 */     sb.append("")"");
/* 112 */     sb.append(this.strict ? "" STRICT"" : """");
/* 113 */     return sb.toString() + ToStringUtils.boost(getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 118 */     if (getClass() != o.getClass()) {
/* 119 */       return false;
/*     */     }
/* 121 */     CustomScoreQuery other = (CustomScoreQuery)o;
/* 122 */     return (getBoost() == other.getBoost() && this.subQuery.equals(other.subQuery) && ((this.valSrcQuery == null) ? (other.valSrcQuery == null) : this.valSrcQuery.equals(other.valSrcQuery)));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 130 */     int valSrcHash = (this.valSrcQuery == null) ? 0 : this.valSrcQuery.hashCode();
/* 131 */     return getClass().hashCode() + this.subQuery.hashCode() + valSrcHash ^ Float.floatToIntBits(getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 150 */   public float customScore(int doc, float subQueryScore, float valSrcScore) { return valSrcScore * subQueryScore; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
/* 164 */     float valSrcScore = (valSrcExpl == null) ? 1.0F : valSrcExpl.getValue();
/* 165 */     Explanation exp = new Explanation(valSrcScore * subQueryExpl.getValue(), ""custom score: product of:"");
/* 166 */     exp.addDetail(subQueryExpl);
/* 167 */     if (valSrcExpl != null) {
/* 168 */       exp.addDetail(valSrcExpl);
/*     */     }
/* 170 */     return exp;
/*     */   }
/*     */   
/*     */   private class CustomWeight implements Weight {
/*     */     Searcher searcher;
/*     */     Weight subQueryWeight;
/*     */     Weight valSrcWeight;
/*     */     boolean qStrict;
/*     */     private final CustomScoreQuery this$0;
/*     */     
/*     */     public CustomWeight(Searcher searcher) throws IOException {
/* 181 */       this.searcher = searcher;
/* 182 */       this.subQueryWeight = CustomScoreQuery.this.subQuery.weight(searcher);
/* 183 */       if (CustomScoreQuery.this.valSrcQuery != null) {
/* 184 */         this.valSrcWeight = CustomScoreQuery.this.valSrcQuery.createWeight(searcher);
/*     */       }
/* 186 */       this.qStrict = CustomScoreQuery.this.strict;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 191 */     public Query getQuery() { return CustomScoreQuery.this; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 196 */     public float getValue() { return CustomScoreQuery.this.getBoost(); }
/*     */ 
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/* 201 */       float sum = this.subQueryWeight.sumOfSquaredWeights();
/* 202 */       if (this.valSrcWeight != null) {
/* 203 */         if (this.qStrict) {
/* 204 */           this.valSrcWeight.sumOfSquaredWeights();
/*     */         } else {
/* 206 */           sum += this.valSrcWeight.sumOfSquaredWeights();
/*     */         } 
/*     */       }
/* 209 */       sum *= CustomScoreQuery.this.getBoost() * CustomScoreQuery.this.getBoost();
/* 210 */       return sum;
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/* 215 */       norm *= CustomScoreQuery.this.getBoost();
/* 216 */       this.subQueryWeight.normalize(norm);
/* 217 */       if (this.valSrcWeight != null) {
/* 218 */         if (this.qStrict) {
/* 219 */           this.valSrcWeight.normalize(1.0F);
/*     */         } else {
/* 221 */           this.valSrcWeight.normalize(norm);
/*     */         } 
/*     */       }
/*     */     }
/*     */ 
/*     */     
/*     */     public Scorer scorer(IndexReader reader) throws IOException {
/* 228 */       Scorer subQueryScorer = this.subQueryWeight.scorer(reader);
/* 229 */       Scorer valSrcScorer = (this.valSrcWeight == null) ? null : this.valSrcWeight.scorer(reader);
/* 230 */       return new CustomScoreQuery.CustomScorer(CustomScoreQuery.this.getSimilarity(this.searcher), reader, this, subQueryScorer, valSrcScorer);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 235 */     public Explanation explain(IndexReader reader, int doc) throws IOException { return scorer(reader).explain(doc); }
/*     */   }
/*     */ 
/*     */   
/*     */   private class CustomScorer
/*     */     extends Scorer
/*     */   {
/*     */     private final CustomScoreQuery.CustomWeight weight;
/*     */     
/*     */     private final float qWeight;
/*     */     
/*     */     private Scorer subQueryScorer;
/*     */     
/*     */     private Scorer valSrcScorer;
/*     */     
/*     */     private IndexReader reader;
/*     */     
/*     */     private final CustomScoreQuery this$0;
/*     */     
/*     */     private CustomScorer(Similarity similarity, IndexReader reader, CustomScoreQuery.CustomWeight w, Scorer subQueryScorer, Scorer valSrcScorer) throws IOException {
/* 255 */       super(similarity);
/* 256 */       this.weight = w;
/* 257 */       this.qWeight = w.getValue();
/* 258 */       this.subQueryScorer = subQueryScorer;
/* 259 */       this.valSrcScorer = valSrcScorer;
/* 260 */       this.reader = reader;
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/* 265 */       boolean hasNext = this.subQueryScorer.next();
/* 266 */       if (this.valSrcScorer != null && hasNext) {
/* 267 */         this.valSrcScorer.skipTo(this.subQueryScorer.doc());
/*     */       }
/* 269 */       return hasNext;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 274 */     public int doc() { return this.subQueryScorer.doc(); }
/*     */ 
/*     */ 
/*     */     
/*     */     public float score() throws IOException {
/* 279 */       float valSrcScore = (this.valSrcScorer == null) ? 1.0F : this.valSrcScorer.score();
/* 280 */       return this.qWeight * CustomScoreQuery.this.customScore(this.subQueryScorer.doc(), this.subQueryScorer.score(), valSrcScore);
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 285 */       boolean hasNext = this.subQueryScorer.skipTo(target);
/* 286 */       if (this.valSrcScorer != null && hasNext) {
/* 287 */         this.valSrcScorer.skipTo(this.subQueryScorer.doc());
/*     */       }
/* 289 */       return hasNext;
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(int doc) throws IOException {
/* 294 */       Explanation subQueryExpl = this.weight.subQueryWeight.explain(this.reader, doc);
/* 295 */       if (!subQueryExpl.isMatch()) {
/* 296 */         return subQueryExpl;
/*     */       }
/*     */       
/* 299 */       Explanation valSrcExpl = (this.valSrcScorer == null) ? null : this.valSrcScorer.explain(doc);
/* 300 */       Explanation customExp = CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpl);
/* 301 */       float sc = this.qWeight * customExp.getValue();
/* 302 */       ComplexExplanation complexExplanation = new ComplexExplanation(true, sc, CustomScoreQuery.this.toString() + "", product of:"");
/*     */       
/* 304 */       complexExplanation.addDetail(customExp);
/* 305 */       complexExplanation.addDetail(new Explanation(this.qWeight, ""queryBoost""));
/* 306 */       return (Explanation)complexExplanation;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 312 */   protected Weight createWeight(Searcher searcher) throws IOException { return new CustomWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 325 */   public boolean isStrict() { return this.strict; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 334 */   public void setStrict(boolean strict) { this.strict = strict; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 341 */   public String name() { return ""custom""; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\CustomScoreQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.DocValues,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import org.apache.lucene.search.Explanation;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class DocValues
/*     */ {
/*     */   private int nVals;
/*     */   private float minVal;
/*     */   private float maxVal;
/*     */   private float avgVal;
/*     */   private boolean computed;
/*     */   
/*     */   public DocValues(int nVals) {
/* 132 */     this.computed = false; this.nVals = nVals; } public abstract float floatVal(int paramInt); public int intVal(int doc) { return (int)floatVal(doc); } private DocValues() { this.computed = false; } public long longVal(int doc) { return (long)floatVal(doc); }
/*     */   public double doubleVal(int doc) { return floatVal(doc); }
/*     */   private void compute() {
/* 135 */     if (this.computed) {
/*     */       return;
/*     */     }
/* 138 */     this.minVal = Float.MAX_VALUE;
/* 139 */     this.maxVal = 0.0F;
/* 140 */     float sum = 0.0F;
/* 141 */     for (int i = 0; i < this.nVals; i++) {
/* 142 */       float val = floatVal(i);
/* 143 */       sum += val;
/* 144 */       this.minVal = Math.min(this.minVal, val);
/* 145 */       this.maxVal = Math.max(this.maxVal, val);
/*     */     } 
/* 147 */     this.avgVal = sum / this.nVals;
/* 148 */     this.computed = true;
/*     */   }
/*     */   public String strVal(int doc) { return Float.toString(floatVal(doc)); }
/*     */   public abstract String toString(int paramInt);
/*     */   public Explanation explain(int doc) { return new Explanation(floatVal(doc), toString(doc)); }
/*     */   Object getInnerArray() { return new Object[0]; }
/*     */   public float getMinValue() {
/* 155 */     compute();
/* 156 */     return this.minVal;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float getMaxValue() {
/* 164 */     compute();
/* 165 */     return this.maxVal;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public float getAverageValue() {
/* 172 */     compute();
/* 173 */     return this.avgVal;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\DocValues.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.FieldCacheSource,"/*    */ package org.apache.lucene.search.function;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.FieldCache;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class FieldCacheSource
/*    */   extends ValueSource
/*    */ {
/*    */   private String field;
/* 46 */   private FieldCache cache = FieldCache.DEFAULT;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 52 */   public FieldCacheSource(String field) { this.field = field; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 57 */   public final DocValues getValues(IndexReader reader) throws IOException { return getCachedFieldValues(this.cache, this.field, reader); }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 62 */   public String description() { return this.field; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public abstract DocValues getCachedFieldValues(FieldCache paramFieldCache, String paramString, IndexReader paramIndexReader) throws IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public final boolean equals(Object o) {
/* 75 */     if (!(o instanceof FieldCacheSource)) {
/* 76 */       return false;
/*    */     }
/* 78 */     FieldCacheSource other = (FieldCacheSource)o;
/* 79 */     return (this.cache == other.cache && this.field.equals(other.field) && cachedFieldSourceEquals(other));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 87 */   public final int hashCode() { return this.cache.hashCode() + this.field.hashCode() + cachedFieldSourceHashCode(); }
/*    */   
/*    */   public abstract boolean cachedFieldSourceEquals(FieldCacheSource paramFieldCacheSource);
/*    */   
/*    */   public abstract int cachedFieldSourceHashCode();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\FieldCacheSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.FieldScoreQuery,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FieldScoreQuery
/*     */   extends ValueSourceQuery
/*     */ {
/*     */   public static class Type
/*     */   {
/*  77 */     public static final Type BYTE = new Type(""byte"");
/*     */ 
/*     */     
/*  80 */     public static final Type SHORT = new Type(""short"");
/*     */ 
/*     */     
/*  83 */     public static final Type INT = new Type(""int"");
/*     */ 
/*     */     
/*  86 */     public static final Type FLOAT = new Type(""float"");
/*     */     
/*     */     private String typeName;
/*     */     
/*  90 */     private Type(String name) { this.typeName = name; }
/*     */ 
/*     */ 
/*     */     
/*  94 */     public String toString() { return getClass().getName() + ""::"" + this.typeName; }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public FieldScoreQuery(String field, Type type) { super(getValueSource(field, type)); }
/*     */ 
/*     */ 
/*     */   
/*     */   private static ValueSource getValueSource(String field, Type type) {
/* 112 */     if (type == Type.BYTE) {
/* 113 */       return new ByteFieldSource(field);
/*     */     }
/* 115 */     if (type == Type.SHORT) {
/* 116 */       return new ShortFieldSource(field);
/*     */     }
/* 118 */     if (type == Type.INT) {
/* 119 */       return new IntFieldSource(field);
/*     */     }
/* 121 */     if (type == Type.FLOAT) {
/* 122 */       return new FloatFieldSource(field);
/*     */     }
/* 124 */     throw new IllegalArgumentException(type + "" is not a known Field Score Query Type!"");
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\FieldScoreQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.FloatFieldSource,"/*    */ package org.apache.lucene.search.function;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.FieldCache;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class FloatFieldSource
/*    */   extends FieldCacheSource
/*    */ {
/*    */   private FieldCache.FloatParser parser;
/*    */   
/* 49 */   public FloatFieldSource(String field) { this(field, null); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public FloatFieldSource(String field, FieldCache.FloatParser parser) {
/* 56 */     super(field);
/* 57 */     this.parser = parser;
/*    */   }
/*    */ 
/*    */ 
/*    */   
/* 62 */   public String description() { return ""float("" + super.description() + ')'; }
/*    */ 
/*    */ 
/*    */   
/*    */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/* 67 */     final float[] arr = (this.parser == null) ? cache.getFloats(reader, field) : cache.getFloats(reader, field, this.parser);
/*    */ 
/*    */     
/* 70 */     return new DocValues(reader.maxDoc()) {
/*    */         private final float[] val$arr;
/*    */         
/* 73 */         public float floatVal(int doc) { return arr[doc]; }
/*    */         
/*    */         private final FloatFieldSource this$0;
/*    */         
/* 77 */         public String toString(int doc) { return FloatFieldSource.this.description() + '=' + arr[doc]; }
/*    */ 
/*    */ 
/*    */         
/* 81 */         Object getInnerArray() { return arr; }
/*    */       };
/*    */   }
/*    */ 
/*    */ 
/*    */   
/*    */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/* 88 */     if (o.getClass() != FloatFieldSource.class) {
/* 89 */       return false;
/*    */     }
/* 91 */     FloatFieldSource other = (FloatFieldSource)o;
/* 92 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 99 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Float.class.hashCode() : this.parser.getClass().hashCode(); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\FloatFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.IntFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class IntFieldSource
/*     */   extends FieldCacheSource
/*     */ {
/*     */   private FieldCache.IntParser parser;
/*     */   
/*  49 */   public IntFieldSource(String field) { this(field, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public IntFieldSource(String field, FieldCache.IntParser parser) {
/*  56 */     super(field);
/*  57 */     this.parser = parser;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  62 */   public String description() { return ""int("" + super.description() + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/*  67 */     final int[] arr = (this.parser == null) ? cache.getInts(reader, field) : cache.getInts(reader, field, this.parser);
/*     */ 
/*     */     
/*  70 */     return new DocValues(reader.maxDoc()) {
/*     */         private final int[] val$arr;
/*     */         
/*  73 */         public float floatVal(int doc) { return arr[doc]; }
/*     */         
/*     */         private final IntFieldSource this$0;
/*     */         
/*  77 */         public int intVal(int doc) { return arr[doc]; }
/*     */ 
/*     */ 
/*     */         
/*  81 */         public String toString(int doc) { return IntFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  85 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/*  92 */     if (o.getClass() != IntFieldSource.class) {
/*  93 */       return false;
/*     */     }
/*  95 */     IntFieldSource other = (IntFieldSource)o;
/*  96 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 103 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Integer.class.hashCode() : this.parser.getClass().hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\IntFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.OrdFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class OrdFieldSource
/*     */   extends ValueSource
/*     */ {
/*     */   protected String field;
/*     */   
/*  58 */   public OrdFieldSource(String field) { this.field = field; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  63 */   public String description() { return ""ord("" + this.field + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getValues(IndexReader reader) throws IOException {
/*  68 */     final int[] arr = (FieldCache.DEFAULT.getStringIndex(reader, this.field)).order;
/*  69 */     return new DocValues(arr.length) {
/*     */         private final int[] val$arr;
/*     */         
/*  72 */         public float floatVal(int doc) { return arr[doc]; }
/*     */ 
/*     */         
/*     */         private final OrdFieldSource this$0;
/*     */         
/*  77 */         public String strVal(int doc) { return Integer.toString(arr[doc]); }
/*     */ 
/*     */ 
/*     */         
/*  81 */         public String toString(int doc) { return OrdFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  85 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/*  92 */     if (o.getClass() != OrdFieldSource.class) return false; 
/*  93 */     OrdFieldSource other = (OrdFieldSource)o;
/*  94 */     return this.field.equals(other.field);
/*     */   }
/*     */   
/*  97 */   private static final int hcode = OrdFieldSource.class.hashCode();
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int hashCode() { return hcode + this.field.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\OrdFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ReverseOrdFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ReverseOrdFieldSource
/*     */   extends ValueSource
/*     */ {
/*     */   public String field;
/*     */   
/*  59 */   public ReverseOrdFieldSource(String field) { this.field = field; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  64 */   public String description() { return ""rord("" + this.field + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getValues(IndexReader reader) throws IOException {
/*  69 */     FieldCache.StringIndex sindex = FieldCache.DEFAULT.getStringIndex(reader, this.field);
/*     */     
/*  71 */     final int[] arr = sindex.order;
/*  72 */     final int end = sindex.lookup.length;
/*     */     
/*  74 */     return new DocValues(arr.length) {
/*     */         private final int val$end;
/*     */         
/*  77 */         public float floatVal(int doc) { return (end - arr[doc]); }
/*     */         
/*     */         private final int[] val$arr;
/*     */         
/*  81 */         public int intVal(int doc) { return end - arr[doc]; }
/*     */ 
/*     */         
/*     */         private final ReverseOrdFieldSource this$0;
/*     */         
/*  86 */         public String strVal(int doc) { return Integer.toString(intVal(doc)); }
/*     */ 
/*     */ 
/*     */         
/*  90 */         public String toString(int doc) { return ReverseOrdFieldSource.this.description() + '=' + strVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  94 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 101 */     if (o.getClass() != ReverseOrdFieldSource.class) return false; 
/* 102 */     ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
/* 103 */     return this.field.equals(other.field);
/*     */   }
/*     */   
/* 106 */   private static final int hcode = ReverseOrdFieldSource.class.hashCode();
/*     */ 
/*     */ 
/*     */   
/* 110 */   public int hashCode() { return hcode + this.field.hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\ReverseOrdFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ShortFieldSource,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.FieldCache;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ShortFieldSource
/*     */   extends FieldCacheSource
/*     */ {
/*     */   private FieldCache.ShortParser parser;
/*     */   
/*  47 */   public ShortFieldSource(String field) { this(field, null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public ShortFieldSource(String field, FieldCache.ShortParser parser) {
/*  54 */     super(field);
/*  55 */     this.parser = parser;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  60 */   public String description() { return ""short("" + super.description() + ')'; }
/*     */ 
/*     */ 
/*     */   
/*     */   public DocValues getCachedFieldValues(FieldCache cache, String field, IndexReader reader) throws IOException {
/*  65 */     final short[] arr = (this.parser == null) ? cache.getShorts(reader, field) : cache.getShorts(reader, field, this.parser);
/*     */ 
/*     */     
/*  68 */     return new DocValues(reader.maxDoc()) {
/*     */         private final short[] val$arr;
/*     */         
/*  71 */         public float floatVal(int doc) { return arr[doc]; }
/*     */         
/*     */         private final ShortFieldSource this$0;
/*     */         
/*  75 */         public int intVal(int doc) { return arr[doc]; }
/*     */ 
/*     */ 
/*     */         
/*  79 */         public String toString(int doc) { return ShortFieldSource.this.description() + '=' + intVal(doc); }
/*     */ 
/*     */ 
/*     */         
/*  83 */         Object getInnerArray() { return arr; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean cachedFieldSourceEquals(FieldCacheSource o) {
/*  90 */     if (o.getClass() != ShortFieldSource.class) {
/*  91 */       return false;
/*     */     }
/*  93 */     ShortFieldSource other = (ShortFieldSource)o;
/*  94 */     return (this.parser == null) ? ((other.parser == null)) : ((this.parser.getClass() == other.parser.getClass()));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public int cachedFieldSourceHashCode() { return (this.parser == null) ? Short.class.hashCode() : this.parser.getClass().hashCode(); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\ShortFieldSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ValueSource,"/*    */ package org.apache.lucene.search.function;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.io.Serializable;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class ValueSource
/*    */   implements Serializable
/*    */ {
/*    */   public abstract DocValues getValues(IndexReader paramIndexReader) throws IOException;
/*    */   
/*    */   public abstract String description();
/*    */   
/* 59 */   public String toString() { return description(); }
/*    */   
/*    */   public abstract boolean equals(Object paramObject);
/*    */   
/*    */   public abstract int hashCode();
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\ValueSource.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.function.ValueSourceQuery,"/*     */ package org.apache.lucene.search.function;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.ComplexExplanation;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ValueSourceQuery
/*     */   extends Query
/*     */ {
/*     */   ValueSource valSrc;
/*     */   
/*  51 */   public ValueSourceQuery(ValueSource valSrc) { this.valSrc = valSrc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   public Query rewrite(IndexReader reader) throws IOException { return this; }
/*     */ 
/*     */   
/*     */   public void extractTerms(Set terms) {}
/*     */ 
/*     */   
/*     */   private class ValueSourceWeight
/*     */     implements Weight
/*     */   {
/*     */     Searcher searcher;
/*     */     float queryNorm;
/*     */     float queryWeight;
/*     */     private final ValueSourceQuery this$0;
/*     */     
/*  70 */     public ValueSourceWeight(Searcher searcher) { this.searcher = searcher; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  75 */     public Query getQuery() { return ValueSourceQuery.this; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  80 */     public float getValue() { return this.queryWeight; }
/*     */ 
/*     */ 
/*     */     
/*     */     public float sumOfSquaredWeights() throws IOException {
/*  85 */       this.queryWeight = ValueSourceQuery.this.getBoost();
/*  86 */       return this.queryWeight * this.queryWeight;
/*     */     }
/*     */ 
/*     */     
/*     */     public void normalize(float norm) {
/*  91 */       this.queryNorm = norm;
/*  92 */       this.queryWeight *= this.queryNorm;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*  97 */     public Scorer scorer(IndexReader reader) throws IOException { return new ValueSourceQuery.ValueSourceScorer(ValueSourceQuery.this.getSimilarity(this.searcher), reader, this); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 102 */     public Explanation explain(IndexReader reader, int doc) throws IOException { return scorer(reader).explain(doc); }
/*     */   }
/*     */ 
/*     */   
/*     */   private class ValueSourceScorer
/*     */     extends Scorer
/*     */   {
/*     */     private final IndexReader reader;
/*     */     
/*     */     private final ValueSourceQuery.ValueSourceWeight weight;
/*     */     
/*     */     private final int maxDoc;
/*     */     
/*     */     private final float qWeight;
/*     */     
/* 117 */     private int doc = -1;
/*     */     private final DocValues vals;
/*     */     private final ValueSourceQuery this$0;
/*     */     
/*     */     private ValueSourceScorer(Similarity similarity, IndexReader reader, ValueSourceQuery.ValueSourceWeight w) throws IOException {
/* 122 */       super(similarity);
/* 123 */       this.weight = w;
/* 124 */       this.qWeight = w.getValue();
/* 125 */       this.reader = reader;
/* 126 */       this.maxDoc = reader.maxDoc();
/*     */       
/* 128 */       this.vals = ValueSourceQuery.this.valSrc.getValues(reader);
/*     */     }
/*     */ 
/*     */     
/*     */     public boolean next() throws IOException {
/*     */       while (true) {
/* 134 */         this.doc++;
/* 135 */         if (this.doc >= this.maxDoc) {
/* 136 */           return false;
/*     */         }
/* 138 */         if (this.reader.isDeleted(this.doc))
/*     */           continue;  break;
/*     */       } 
/* 141 */       return true;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 148 */     public int doc() { return this.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 153 */     public float score() throws IOException { return this.qWeight * this.vals.floatVal(this.doc); }
/*     */ 
/*     */ 
/*     */     
/*     */     public boolean skipTo(int target) throws IOException {
/* 158 */       this.doc = target - 1;
/* 159 */       return next();
/*     */     }
/*     */ 
/*     */     
/*     */     public Explanation explain(int doc) throws IOException {
/* 164 */       float sc = this.qWeight * this.vals.floatVal(doc);
/*     */       
/* 166 */       ComplexExplanation complexExplanation = new ComplexExplanation(true, sc, ValueSourceQuery.this.toString() + "", product of:"");
/*     */ 
/*     */       
/* 169 */       complexExplanation.addDetail(this.vals.explain(doc));
/* 170 */       complexExplanation.addDetail(new Explanation(ValueSourceQuery.this.getBoost(), ""boost""));
/* 171 */       complexExplanation.addDetail(new Explanation(this.weight.queryNorm, ""queryNorm""));
/* 172 */       return (Explanation)complexExplanation;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 178 */   protected Weight createWeight(Searcher searcher) { return new ValueSourceWeight(searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 183 */   public String toString(String field) { return this.valSrc.toString() + ToStringUtils.boost(getBoost()); }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 188 */     if (getClass() != o.getClass()) {
/* 189 */       return false;
/*     */     }
/* 191 */     ValueSourceQuery other = (ValueSourceQuery)o;
/* 192 */     return (getBoost() == other.getBoost() && this.valSrc.equals(other.valSrc));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 198 */   public int hashCode() { return getClass().hashCode() + this.valSrc.hashCode() ^ Float.floatToIntBits(getBoost()); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\function\ValueSourceQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.payloads.BoostingTermQuery,"/*     */ package org.apache.lucene.search.payloads;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.index.TermPositions;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ import org.apache.lucene.search.spans.SpanQuery;
/*     */ import org.apache.lucene.search.spans.SpanScorer;
/*     */ import org.apache.lucene.search.spans.SpanTermQuery;
/*     */ import org.apache.lucene.search.spans.SpanWeight;
/*     */ import org.apache.lucene.search.spans.Spans;
/*     */ import org.apache.lucene.search.spans.TermSpans;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class BoostingTermQuery
/*     */   extends SpanTermQuery
/*     */ {
/*  51 */   public BoostingTermQuery(Term term) { super(term); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   protected Weight createWeight(Searcher searcher) throws IOException { return new BoostingTermWeight(this, searcher); }
/*     */   
/*     */   protected class BoostingTermWeight
/*     */     extends SpanWeight
/*     */     implements Weight {
/*     */     private final BoostingTermQuery this$0;
/*     */     
/*  63 */     public BoostingTermWeight(BoostingTermQuery query, Searcher searcher) throws IOException { super((SpanQuery)query, searcher); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  70 */     public Scorer scorer(IndexReader reader) throws IOException { return (Scorer)new BoostingSpanScorer((TermSpans)this.query.getSpans(reader), this, this.similarity, reader.norms(this.query.getField())); }
/*     */ 
/*     */ 
/*     */     
/*     */     class BoostingSpanScorer
/*     */       extends SpanScorer
/*     */     {
/*  77 */       byte[] payload = new byte[256];
/*     */       private TermPositions positions;
/*     */       protected float payloadScore;
/*     */       private int payloadsSeen;
/*     */       private final BoostingTermQuery.BoostingTermWeight this$1;
/*     */       
/*     */       public BoostingSpanScorer(TermSpans spans, Weight weight, Similarity similarity, byte[] norms) throws IOException {
/*  84 */         super((Spans)spans, weight, similarity, norms);
/*  85 */         this.positions = spans.getPositions();
/*     */       }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/*     */       protected boolean setFreqCurrentDoc() throws IOException {
/* 116 */         if (!this.more) {
/* 117 */           return false;
/*     */         }
/* 119 */         this.doc = this.spans.doc();
/* 120 */         this.freq = 0.0F;
/* 121 */         this.payloadScore = 0.0F;
/* 122 */         this.payloadsSeen = 0;
/* 123 */         Similarity similarity1 = getSimilarity();
/* 124 */         while (this.more && this.doc == this.spans.doc()) {
/* 125 */           int matchLength = this.spans.end() - this.spans.start();
/*     */           
/* 127 */           this.freq += similarity1.sloppyFreq(matchLength);
/* 128 */           processPayload(similarity1);
/*     */           
/* 130 */           this.more = this.spans.next();
/*     */         } 
/* 132 */         return (this.more || this.freq != 0.0F);
/*     */       }
/*     */ 
/*     */       
/*     */       protected void processPayload(Similarity similarity) throws IOException {
/* 137 */         if (this.positions.isPayloadAvailable()) {
/* 138 */           this.payload = this.positions.getPayload(this.payload, 0);
/* 139 */           this.payloadScore += similarity.scorePayload(this.payload, 0, this.positions.getPayloadLength());
/* 140 */           this.payloadsSeen++;
/*     */         } 
/*     */       }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */       
/* 150 */       public float score() throws IOException { return super.score() * ((this.payloadsSeen > 0) ? (this.payloadScore / this.payloadsSeen) : 1.0F); }
/*     */ 
/*     */ 
/*     */       
/*     */       public Explanation explain(int doc) throws IOException {
/* 155 */         Explanation result = new Explanation();
/* 156 */         Explanation nonPayloadExpl = super.explain(doc);
/* 157 */         result.addDetail(nonPayloadExpl);
/*     */ 
/*     */         
/* 160 */         Explanation payloadBoost = new Explanation();
/* 161 */         result.addDetail(payloadBoost);
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 168 */         float avgPayloadScore = this.payloadScore / this.payloadsSeen;
/* 169 */         payloadBoost.setValue(avgPayloadScore);
/*     */         
/* 171 */         payloadBoost.setDescription(""scorePayload(...)"");
/* 172 */         result.setValue(nonPayloadExpl.getValue() * avgPayloadScore);
/* 173 */         result.setDescription(""btq, product of:"");
/* 174 */         return result;
/*     */       }
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 182 */     if (!(o instanceof BoostingTermQuery))
/* 183 */       return false; 
/* 184 */     BoostingTermQuery other = (BoostingTermQuery)o;
/* 185 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\payloads\BoostingTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.NearSpansOrdered,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Arrays;
/*     */ import java.util.Comparator;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class NearSpansOrdered
/*     */   implements Spans
/*     */ {
/*     */   private final int allowedSlop;
/*     */   private boolean firstTime = true;
/*     */   private boolean more = false;
/*     */   private final Spans[] subSpans;
/*     */   private boolean inSameDoc = false;
/*  56 */   private int matchDoc = -1;
/*  57 */   private int matchStart = -1;
/*  58 */   private int matchEnd = -1;
/*     */   private final Spans[] subSpansByDoc;
/*     */   
/*  61 */   private final Comparator spanDocComparator = new Comparator()
/*     */     {
/*  63 */       public int compare(Object o1, Object o2) { return ((Spans)o1).doc() - ((Spans)o2).doc(); }
/*     */       private final NearSpansOrdered this$0;
/*     */     };
/*     */   
/*     */   private SpanNearQuery query;
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public NearSpansOrdered(SpanNearQuery spanNearQuery, IndexReader reader) throws IOException {
/*  71 */     if ((spanNearQuery.getClauses()).length < 2) {
/*  72 */       throw new IllegalArgumentException(""Less than 2 clauses: "" + spanNearQuery);
/*     */     }
/*     */     
/*  75 */     this.allowedSlop = spanNearQuery.getSlop();
/*  76 */     SpanQuery[] clauses = spanNearQuery.getClauses();
/*  77 */     this.subSpans = new Spans[clauses.length];
/*  78 */     this.subSpansByDoc = new Spans[clauses.length];
/*  79 */     for (int i = 0; i < clauses.length; i++) {
/*  80 */       this.subSpans[i] = clauses[i].getSpans(reader);
/*  81 */       this.subSpansByDoc[i] = this.subSpans[i];
/*     */     } 
/*  83 */     this.query = spanNearQuery;
/*     */   }
/*     */ 
/*     */   
/*  87 */   public int doc() { return this.matchDoc; }
/*     */ 
/*     */   
/*  90 */   public int start() { return this.matchStart; }
/*     */ 
/*     */   
/*  93 */   public int end() { return this.matchEnd; }
/*     */ 
/*     */   
/*     */   public boolean next() throws IOException {
/*  97 */     if (this.firstTime) {
/*  98 */       this.firstTime = false;
/*  99 */       for (int i = 0; i < this.subSpans.length; i++) {
/* 100 */         if (!this.subSpans[i].next()) {
/* 101 */           this.more = false;
/* 102 */           return false;
/*     */         } 
/*     */       } 
/* 105 */       this.more = true;
/*     */     } 
/* 107 */     return advanceAfterOrdered();
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 112 */     if (this.firstTime) {
/* 113 */       this.firstTime = false;
/* 114 */       for (int i = 0; i < this.subSpans.length; i++) {
/* 115 */         if (!this.subSpans[i].skipTo(target)) {
/* 116 */           this.more = false;
/* 117 */           return false;
/*     */         } 
/*     */       } 
/* 120 */       this.more = true;
/* 121 */     } else if (this.more && this.subSpans[0].doc() < target) {
/* 122 */       if (this.subSpans[0].skipTo(target)) {
/* 123 */         this.inSameDoc = false;
/*     */       } else {
/* 125 */         this.more = false;
/* 126 */         return false;
/*     */       } 
/*     */     } 
/* 129 */     return advanceAfterOrdered();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean advanceAfterOrdered() throws IOException {
/* 137 */     while (this.more && (this.inSameDoc || toSameDoc())) {
/* 138 */       if (stretchToOrder() && shrinkToAfterShortestMatch()) {
/* 139 */         return true;
/*     */       }
/*     */     } 
/* 142 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean toSameDoc() throws IOException {
/* 148 */     Arrays.sort(this.subSpansByDoc, this.spanDocComparator);
/* 149 */     int firstIndex = 0;
/* 150 */     int maxDoc = this.subSpansByDoc[this.subSpansByDoc.length - 1].doc();
/* 151 */     while (this.subSpansByDoc[firstIndex].doc() != maxDoc) {
/* 152 */       if (!this.subSpansByDoc[firstIndex].skipTo(maxDoc)) {
/* 153 */         this.more = false;
/* 154 */         this.inSameDoc = false;
/* 155 */         return false;
/*     */       } 
/* 157 */       maxDoc = this.subSpansByDoc[firstIndex].doc();
/* 158 */       if (++firstIndex == this.subSpansByDoc.length) {
/* 159 */         firstIndex = 0;
/*     */       }
/*     */     } 
/* 162 */     for (int i = 0; i < this.subSpansByDoc.length; i++)
/*     */     {
/*     */ 
/*     */       
/* 166 */       assert this.subSpansByDoc[i].doc() == maxDoc : "" NearSpansOrdered.toSameDoc() spans "" + this.subSpansByDoc[false] + ""\n at doc "" + this.subSpansByDoc[i].doc() + "", but should be at "" + maxDoc;
/*     */     }
/* 168 */     this.inSameDoc = true;
/* 169 */     return true;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   static final boolean docSpansOrdered(Spans spans1, Spans spans2) {
/* 180 */     assert spans1.doc() == spans2.doc() : ""doc1 "" + spans1.doc() + "" != doc2 "" + spans2.doc();
/* 181 */     int start1 = spans1.start();
/* 182 */     int start2 = spans2.start();
/*     */     
/* 184 */     return (start1 == start2) ? ((spans1.end() < spans2.end())) : ((start1 < start2));
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 191 */   private static final boolean docSpansOrdered(int start1, int end1, int start2, int end2) { return (start1 == start2) ? ((end1 < end2)) : ((start1 < start2)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean stretchToOrder() throws IOException {
/* 198 */     this.matchDoc = this.subSpans[0].doc();
/* 199 */     for (int i = 1; this.inSameDoc && i < this.subSpans.length; i++) {
/* 200 */       while (!docSpansOrdered(this.subSpans[i - 1], this.subSpans[i])) {
/* 201 */         if (!this.subSpans[i].next()) {
/* 202 */           this.inSameDoc = false;
/* 203 */           this.more = false; break;
/*     */         } 
/* 205 */         if (this.matchDoc != this.subSpans[i].doc()) {
/* 206 */           this.inSameDoc = false;
/*     */           break;
/*     */         } 
/*     */       } 
/*     */     } 
/* 211 */     return this.inSameDoc;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean shrinkToAfterShortestMatch() throws IOException {
/* 219 */     this.matchStart = this.subSpans[this.subSpans.length - 1].start();
/* 220 */     this.matchEnd = this.subSpans[this.subSpans.length - 1].end();
/* 221 */     int matchSlop = 0;
/* 222 */     int lastStart = this.matchStart;
/* 223 */     int lastEnd = this.matchEnd;
/* 224 */     for (int i = this.subSpans.length - 2; i >= 0; i--) {
/* 225 */       Spans prevSpans = this.subSpans[i];
/* 226 */       int prevStart = prevSpans.start();
/* 227 */       int prevEnd = prevSpans.end();
/*     */       while (true) {
/* 229 */         if (!prevSpans.next()) {
/* 230 */           this.inSameDoc = false;
/* 231 */           this.more = false; break;
/*     */         } 
/* 233 */         if (this.matchDoc != prevSpans.doc()) {
/* 234 */           this.inSameDoc = false;
/*     */           break;
/*     */         } 
/* 237 */         int ppStart = prevSpans.start();
/* 238 */         int ppEnd = prevSpans.end();
/* 239 */         if (!docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {
/*     */           break;
/*     */         }
/* 242 */         prevStart = ppStart;
/* 243 */         prevEnd = ppEnd;
/*     */       } 
/*     */ 
/*     */       
/* 247 */       assert prevStart <= this.matchStart;
/* 248 */       if (this.matchStart > prevEnd) {
/* 249 */         matchSlop += this.matchStart - prevEnd;
/*     */       }
/*     */ 
/*     */ 
/*     */       
/* 254 */       this.matchStart = prevStart;
/* 255 */       lastStart = prevStart;
/* 256 */       lastEnd = prevEnd;
/*     */     } 
/* 258 */     return (matchSlop <= this.allowedSlop);
/*     */   }
/*     */ 
/*     */   
/* 262 */   public String toString() { return getClass().getName() + ""("" + this.query.toString() + "")@"" + (this.firstTime ? ""START"" : (this.more ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\NearSpansOrdered.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.NearSpansUnordered,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.List;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class NearSpansUnordered
/*     */   implements Spans
/*     */ {
/*     */   private SpanNearQuery query;
/*  31 */   private List ordered = new ArrayList();
/*     */   
/*     */   private int slop;
/*     */   private SpansCell first;
/*     */   private SpansCell last;
/*     */   private int totalLength;
/*     */   private CellQueue queue;
/*     */   private SpansCell max;
/*     */   private boolean more = true;
/*     */   private boolean firstTime = true;
/*     */   
/*     */   private class CellQueue
/*     */     extends PriorityQueue
/*     */   {
/*     */     private final NearSpansUnordered this$0;
/*     */     
/*  47 */     public CellQueue(int size) { initialize(size); }
/*     */ 
/*     */     
/*     */     protected final boolean lessThan(Object o1, Object o2) {
/*  51 */       NearSpansUnordered.SpansCell spans1 = (NearSpansUnordered.SpansCell)o1;
/*  52 */       NearSpansUnordered.SpansCell spans2 = (NearSpansUnordered.SpansCell)o2;
/*  53 */       if (spans1.doc() == spans2.doc()) {
/*  54 */         return NearSpansOrdered.docSpansOrdered(spans1, spans2);
/*     */       }
/*  56 */       return (spans1.doc() < spans2.doc());
/*     */     }
/*     */   }
/*     */ 
/*     */   
/*     */   private class SpansCell
/*     */     implements Spans
/*     */   {
/*     */     private Spans spans;
/*     */     private SpansCell next;
/*  66 */     private int length = -1;
/*     */     private int index;
/*     */     
/*     */     public SpansCell(Spans spans, int index) {
/*  70 */       this.spans = spans;
/*  71 */       this.index = index;
/*     */     }
/*     */     private final NearSpansUnordered this$0;
/*     */     
/*  75 */     public boolean next() throws IOException { return adjust(this.spans.next()); }
/*     */ 
/*     */ 
/*     */     
/*  79 */     public boolean skipTo(int target) throws IOException { return adjust(this.spans.skipTo(target)); }
/*     */ 
/*     */     
/*     */     private boolean adjust(boolean condition) {
/*  83 */       if (this.length != -1) {
/*  84 */         NearSpansUnordered.this.totalLength -= this.length;
/*     */       }
/*  86 */       if (condition) {
/*  87 */         this.length = end() - start();
/*  88 */         NearSpansUnordered.this.totalLength += this.length;
/*     */         
/*  90 */         if (NearSpansUnordered.this.max == null || doc() > NearSpansUnordered.this.max.doc() || (doc() == NearSpansUnordered.this.max.doc() && end() > NearSpansUnordered.this.max.end()))
/*     */         {
/*  92 */           NearSpansUnordered.this.max = this;
/*     */         }
/*     */       } 
/*  95 */       NearSpansUnordered.this.more = condition;
/*  96 */       return condition;
/*     */     }
/*     */     
/*  99 */     public int doc() { return this.spans.doc(); }
/* 100 */     public int start() { return this.spans.start(); }
/* 101 */     public int end() { return this.spans.end(); }
/*     */     
/* 103 */     public String toString() { return this.spans.toString() + ""#"" + this.index; }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public NearSpansUnordered(SpanNearQuery query, IndexReader reader) throws IOException {
/* 109 */     this.query = query;
/* 110 */     this.slop = query.getSlop();
/*     */     
/* 112 */     SpanQuery[] clauses = query.getClauses();
/* 113 */     this.queue = new CellQueue(clauses.length);
/* 114 */     for (int i = 0; i < clauses.length; i++) {
/* 115 */       SpansCell cell = new SpansCell(clauses[i].getSpans(reader), i);
/*     */       
/* 117 */       this.ordered.add(cell);
/*     */     } 
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/* 122 */     if (this.firstTime) {
/* 123 */       initList(true);
/* 124 */       listToQueue();
/* 125 */       this.firstTime = false;
/* 126 */     } else if (this.more) {
/* 127 */       if (min().next()) {
/* 128 */         this.queue.adjustTop();
/*     */       } else {
/* 130 */         this.more = false;
/*     */       } 
/*     */     } 
/*     */     
/* 134 */     while (this.more) {
/*     */       
/* 136 */       boolean queueStale = false;
/*     */       
/* 138 */       if (min().doc() != this.max.doc()) {
/* 139 */         queueToList();
/* 140 */         queueStale = true;
/*     */       } 
/*     */ 
/*     */ 
/*     */       
/* 145 */       while (this.more && this.first.doc() < this.last.doc()) {
/* 146 */         this.more = this.first.skipTo(this.last.doc());
/* 147 */         firstToLast();
/* 148 */         queueStale = true;
/*     */       } 
/*     */       
/* 151 */       if (!this.more) return false;
/*     */ 
/*     */ 
/*     */       
/* 155 */       if (queueStale) {
/* 156 */         listToQueue();
/* 157 */         queueStale = false;
/*     */       } 
/*     */       
/* 160 */       if (atMatch()) {
/* 161 */         return true;
/*     */       }
/*     */       
/* 164 */       this.more = min().next();
/* 165 */       if (this.more) {
/* 166 */         this.queue.adjustTop();
/*     */       }
/*     */     } 
/* 169 */     return false;
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/* 173 */     if (this.firstTime) {
/* 174 */       initList(false);
/* 175 */       for (SpansCell cell = this.first; this.more && cell != null; cell = cell.next) {
/* 176 */         this.more = cell.skipTo(target);
/*     */       }
/* 178 */       if (this.more) {
/* 179 */         listToQueue();
/*     */       }
/* 181 */       this.firstTime = false;
/*     */     } else {
/* 183 */       while (this.more && min().doc() < target) {
/* 184 */         if (min().skipTo(target)) {
/* 185 */           this.queue.adjustTop(); continue;
/*     */         } 
/* 187 */         this.more = false;
/*     */       } 
/*     */     } 
/*     */     
/* 191 */     return (this.more && (atMatch() || next()));
/*     */   }
/*     */   
/* 194 */   private SpansCell min() { return (SpansCell)this.queue.top(); }
/*     */   
/* 196 */   public int doc() { return min().doc(); }
/* 197 */   public int start() { return min().start(); }
/* 198 */   public int end() { return this.max.end(); }
/*     */ 
/*     */ 
/*     */   
/* 202 */   public String toString() { return getClass().getName() + ""("" + this.query.toString() + "")@"" + (this.firstTime ? ""START"" : (this.more ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */ 
/*     */ 
/*     */   
/*     */   private void initList(boolean next) throws IOException {
/* 207 */     for (int i = 0; this.more && i < this.ordered.size(); i++) {
/* 208 */       SpansCell cell = this.ordered.get(i);
/* 209 */       if (next)
/* 210 */         this.more = cell.next(); 
/* 211 */       if (this.more) {
/* 212 */         addToList(cell);
/*     */       }
/*     */     } 
/*     */   }
/*     */   
/*     */   private void addToList(SpansCell cell) {
/* 218 */     if (this.last != null) {
/* 219 */       this.last.next = cell;
/*     */     } else {
/* 221 */       this.first = cell;
/* 222 */     }  this.last = cell;
/* 223 */     cell.next = null;
/*     */   }
/*     */   
/*     */   private void firstToLast() {
/* 227 */     this.last.next = this.first;
/* 228 */     this.last = this.first;
/* 229 */     this.first = this.first.next;
/* 230 */     this.last.next = null;
/*     */   }
/*     */   
/*     */   private void queueToList() {
/* 234 */     this.last = this.first = null;
/* 235 */     while (this.queue.top() != null) {
/* 236 */       addToList((SpansCell)this.queue.pop());
/*     */     }
/*     */   }
/*     */   
/*     */   private void listToQueue() {
/* 241 */     this.queue.clear();
/* 242 */     for (SpansCell cell = this.first; cell != null; cell = cell.next) {
/* 243 */       this.queue.put(cell);
/*     */     }
/*     */   }
/*     */ 
/*     */   
/* 248 */   private boolean atMatch() { return (min().doc() == this.max.doc() && this.max.end() - min().start() - this.totalLength <= this.slop); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\NearSpansUnordered.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanFirstQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanFirstQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private SpanQuery match;
/*     */   private int end;
/*     */   
/*     */   public SpanFirstQuery(SpanQuery match, int end) {
/*  37 */     this.match = match;
/*  38 */     this.end = end;
/*     */   }
/*     */ 
/*     */   
/*  42 */   public SpanQuery getMatch() { return this.match; }
/*     */ 
/*     */   
/*  45 */   public int getEnd() { return this.end; }
/*     */   
/*  47 */   public String getField() { return this.match.getField(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  53 */   public Collection getTerms() { return this.match.getTerms(); }
/*     */   
/*     */   public String toString(String field) {
/*  56 */     StringBuffer buffer = new StringBuffer();
/*  57 */     buffer.append(""spanFirst("");
/*  58 */     buffer.append(this.match.toString(field));
/*  59 */     buffer.append("", "");
/*  60 */     buffer.append(this.end);
/*  61 */     buffer.append("")"");
/*  62 */     buffer.append(ToStringUtils.boost(getBoost()));
/*  63 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*  67 */   public void extractTerms(Set terms) { this.match.extractTerms(terms); }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/*  71 */     return new Spans() {
/*  72 */         private Spans spans = SpanFirstQuery.this.match.getSpans(reader); private final IndexReader val$reader;
/*     */         
/*     */         public boolean next() throws IOException {
/*  75 */           while (this.spans.next()) {
/*  76 */             if (end() <= SpanFirstQuery.this.end)
/*  77 */               return true; 
/*     */           } 
/*  79 */           return false;
/*     */         }
/*     */         private final SpanFirstQuery this$0;
/*     */         public boolean skipTo(int target) throws IOException {
/*  83 */           if (!this.spans.skipTo(target)) {
/*  84 */             return false;
/*     */           }
/*  86 */           if (this.spans.end() <= SpanFirstQuery.this.end) {
/*  87 */             return true;
/*     */           }
/*  89 */           return next();
/*     */         }
/*     */         
/*  92 */         public int doc() { return this.spans.doc(); }
/*  93 */         public int start() { return this.spans.start(); }
/*  94 */         public int end() { return this.spans.end(); }
/*     */ 
/*     */         
/*  97 */         public String toString() { return ""spans("" + SpanFirstQuery.this.toString() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 104 */     SpanFirstQuery clone = null;
/*     */     
/* 106 */     SpanQuery rewritten = (SpanQuery)this.match.rewrite(reader);
/* 107 */     if (rewritten != this.match) {
/* 108 */       clone = (SpanFirstQuery)clone();
/* 109 */       clone.match = rewritten;
/*     */     } 
/*     */     
/* 112 */     if (clone != null) {
/* 113 */       return clone;
/*     */     }
/* 115 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 120 */     if (this == o) return true; 
/* 121 */     if (!(o instanceof SpanFirstQuery)) return false;
/*     */     
/* 123 */     SpanFirstQuery other = (SpanFirstQuery)o;
/* 124 */     return (this.end == other.end && this.match.equals(other.match) && getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 130 */     int h = this.match.hashCode();
/* 131 */     h ^= h << 8 | h >>> 25;
/* 132 */     h ^= Float.floatToRawIntBits(getBoost()) ^ this.end;
/* 133 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanFirstQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanNearQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanNearQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private List clauses;
/*     */   private int slop;
/*     */   private boolean inOrder;
/*     */   private String field;
/*     */   
/*     */   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder) {
/*  50 */     this.clauses = new ArrayList(clauses.length);
/*  51 */     for (int i = 0; i < clauses.length; i++) {
/*  52 */       SpanQuery clause = clauses[i];
/*  53 */       if (i == 0) {
/*  54 */         this.field = clause.getField();
/*  55 */       } else if (!clause.getField().equals(this.field)) {
/*  56 */         throw new IllegalArgumentException(""Clauses must have same field."");
/*     */       } 
/*  58 */       this.clauses.add(clause);
/*     */     } 
/*     */     
/*  61 */     this.slop = slop;
/*  62 */     this.inOrder = inOrder;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  67 */   public SpanQuery[] getClauses() { return (SpanQuery[])this.clauses.toArray((Object[])new SpanQuery[this.clauses.size()]); }
/*     */ 
/*     */ 
/*     */   
/*  71 */   public int getSlop() { return this.slop; }
/*     */ 
/*     */   
/*  74 */   public boolean isInOrder() { return this.inOrder; }
/*     */   
/*  76 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getTerms() {
/*  83 */     Collection terms = new ArrayList();
/*  84 */     Iterator i = this.clauses.iterator();
/*  85 */     while (i.hasNext()) {
/*  86 */       SpanQuery clause = i.next();
/*  87 */       terms.addAll(clause.getTerms());
/*     */     } 
/*  89 */     return terms;
/*     */   }
/*     */   
/*     */   public void extractTerms(Set terms) {
/*  93 */     Iterator i = this.clauses.iterator();
/*  94 */     while (i.hasNext()) {
/*  95 */       SpanQuery clause = i.next();
/*  96 */       clause.extractTerms(terms);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 102 */     StringBuffer buffer = new StringBuffer();
/* 103 */     buffer.append(""spanNear(["");
/* 104 */     Iterator i = this.clauses.iterator();
/* 105 */     while (i.hasNext()) {
/* 106 */       SpanQuery clause = i.next();
/* 107 */       buffer.append(clause.toString(field));
/* 108 */       if (i.hasNext()) {
/* 109 */         buffer.append("", "");
/*     */       }
/*     */     } 
/* 112 */     buffer.append(""], "");
/* 113 */     buffer.append(this.slop);
/* 114 */     buffer.append("", "");
/* 115 */     buffer.append(this.inOrder);
/* 116 */     buffer.append("")"");
/* 117 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 118 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public Spans getSpans(IndexReader reader) throws IOException {
/* 122 */     if (this.clauses.size() == 0) {
/* 123 */       return (new SpanOrQuery(getClauses())).getSpans(reader);
/*     */     }
/* 125 */     if (this.clauses.size() == 1) {
/* 126 */       return ((SpanQuery)this.clauses.get(0)).getSpans(reader);
/*     */     }
/* 128 */     return this.inOrder ? new NearSpansOrdered(this, reader) : new NearSpansUnordered(this, reader);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 134 */     SpanNearQuery clone = null;
/* 135 */     for (int i = 0; i < this.clauses.size(); i++) {
/* 136 */       SpanQuery c = this.clauses.get(i);
/* 137 */       SpanQuery query = (SpanQuery)c.rewrite(reader);
/* 138 */       if (query != c) {
/* 139 */         if (clone == null)
/* 140 */           clone = (SpanNearQuery)clone(); 
/* 141 */         clone.clauses.set(i, query);
/*     */       } 
/*     */     } 
/* 144 */     if (clone != null) {
/* 145 */       return clone;
/*     */     }
/* 147 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 153 */     if (this == o) return true; 
/* 154 */     if (!(o instanceof SpanNearQuery)) return false;
/*     */     
/* 156 */     SpanNearQuery spanNearQuery = (SpanNearQuery)o;
/*     */     
/* 158 */     if (this.inOrder != spanNearQuery.inOrder) return false; 
/* 159 */     if (this.slop != spanNearQuery.slop) return false; 
/* 160 */     if (!this.clauses.equals(spanNearQuery.clauses)) return false;
/*     */     
/* 162 */     return (getBoost() == spanNearQuery.getBoost());
/*     */   }
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 167 */     int result = this.clauses.hashCode();
/*     */ 
/*     */ 
/*     */     
/* 171 */     result ^= result << 14 | result >>> 19;
/* 172 */     result += Float.floatToRawIntBits(getBoost());
/* 173 */     result += this.slop;
/* 174 */     result ^= this.inOrder ? -1716530243 : 0;
/* 175 */     return result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanNearQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanNotQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.Collection;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanNotQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private SpanQuery include;
/*     */   private SpanQuery exclude;
/*     */   
/*     */   public SpanNotQuery(SpanQuery include, SpanQuery exclude) {
/*  37 */     this.include = include;
/*  38 */     this.exclude = exclude;
/*     */     
/*  40 */     if (!include.getField().equals(exclude.getField())) {
/*  41 */       throw new IllegalArgumentException(""Clauses must have same field."");
/*     */     }
/*     */   }
/*     */   
/*  45 */   public SpanQuery getInclude() { return this.include; }
/*     */ 
/*     */   
/*  48 */   public SpanQuery getExclude() { return this.exclude; }
/*     */   
/*  50 */   public String getField() { return this.include.getField(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  56 */   public Collection getTerms() { return this.include.getTerms(); }
/*     */   
/*  58 */   public void extractTerms(Set terms) { this.include.extractTerms(terms); }
/*     */   
/*     */   public String toString(String field) {
/*  61 */     StringBuffer buffer = new StringBuffer();
/*  62 */     buffer.append(""spanNot("");
/*  63 */     buffer.append(this.include.toString(field));
/*  64 */     buffer.append("", "");
/*  65 */     buffer.append(this.exclude.toString(field));
/*  66 */     buffer.append("")"");
/*  67 */     buffer.append(ToStringUtils.boost(getBoost()));
/*  68 */     return buffer.toString();
/*     */   }
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/*  73 */     return new Spans() {
/*  74 */         private Spans includeSpans = SpanNotQuery.this.include.getSpans(reader);
/*     */         
/*     */         private boolean moreInclude = true;
/*  77 */         private Spans excludeSpans = SpanNotQuery.this.exclude.getSpans(reader);
/*  78 */         private boolean moreExclude = this.excludeSpans.next(); private final IndexReader val$reader;
/*     */         
/*     */         public boolean next() throws IOException {
/*  81 */           if (this.moreInclude) {
/*  82 */             this.moreInclude = this.includeSpans.next();
/*     */           }
/*  84 */           while (this.moreInclude && this.moreExclude) {
/*     */             
/*  86 */             if (this.includeSpans.doc() > this.excludeSpans.doc()) {
/*  87 */               this.moreExclude = this.excludeSpans.skipTo(this.includeSpans.doc());
/*     */             }
/*     */ 
/*     */             
/*  91 */             while (this.moreExclude && this.includeSpans.doc() == this.excludeSpans.doc() && this.excludeSpans.end() <= this.includeSpans.start()) {
/*  92 */               this.moreExclude = this.excludeSpans.next();
/*     */             }
/*     */             
/*  95 */             if (!this.moreExclude || this.includeSpans.doc() != this.excludeSpans.doc() || this.includeSpans.end() <= this.excludeSpans.start()) {
/*     */               break;
/*     */             }
/*     */ 
/*     */             
/* 100 */             this.moreInclude = this.includeSpans.next();
/*     */           } 
/* 102 */           return this.moreInclude;
/*     */         }
/*     */         private final SpanNotQuery this$0;
/*     */         public boolean skipTo(int target) throws IOException {
/* 106 */           if (this.moreInclude) {
/* 107 */             this.moreInclude = this.includeSpans.skipTo(target);
/*     */           }
/* 109 */           if (!this.moreInclude) {
/* 110 */             return false;
/*     */           }
/* 112 */           if (this.moreExclude && this.includeSpans.doc() > this.excludeSpans.doc())
/*     */           {
/* 114 */             this.moreExclude = this.excludeSpans.skipTo(this.includeSpans.doc());
/*     */           }
/*     */ 
/*     */           
/* 118 */           while (this.moreExclude && this.includeSpans.doc() == this.excludeSpans.doc() && this.excludeSpans.end() <= this.includeSpans.start()) {
/* 119 */             this.moreExclude = this.excludeSpans.next();
/*     */           }
/*     */           
/* 122 */           if (!this.moreExclude || this.includeSpans.doc() != this.excludeSpans.doc() || this.includeSpans.end() <= this.excludeSpans.start())
/*     */           {
/*     */             
/* 125 */             return true;
/*     */           }
/* 127 */           return next();
/*     */         }
/*     */         
/* 130 */         public int doc() { return this.includeSpans.doc(); }
/* 131 */         public int start() { return this.includeSpans.start(); }
/* 132 */         public int end() { return this.includeSpans.end(); }
/*     */ 
/*     */         
/* 135 */         public String toString() { return ""spans("" + SpanNotQuery.this.toString() + "")""; }
/*     */       };
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/* 142 */     SpanNotQuery clone = null;
/*     */     
/* 144 */     SpanQuery rewrittenInclude = (SpanQuery)this.include.rewrite(reader);
/* 145 */     if (rewrittenInclude != this.include) {
/* 146 */       clone = (SpanNotQuery)clone();
/* 147 */       clone.include = rewrittenInclude;
/*     */     } 
/* 149 */     SpanQuery rewrittenExclude = (SpanQuery)this.exclude.rewrite(reader);
/* 150 */     if (rewrittenExclude != this.exclude) {
/* 151 */       if (clone == null) clone = (SpanNotQuery)clone(); 
/* 152 */       clone.exclude = rewrittenExclude;
/*     */     } 
/*     */     
/* 155 */     if (clone != null) {
/* 156 */       return clone;
/*     */     }
/* 158 */     return this;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean equals(Object o) {
/* 164 */     if (this == o) return true; 
/* 165 */     if (!(o instanceof SpanNotQuery)) return false;
/*     */     
/* 167 */     SpanNotQuery other = (SpanNotQuery)o;
/* 168 */     return (this.include.equals(other.include) && this.exclude.equals(other.exclude) && getBoost() == other.getBoost());
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public int hashCode() {
/* 174 */     int h = this.include.hashCode();
/* 175 */     h = h << 1 | h >>> 31;
/* 176 */     h ^= this.exclude.hashCode();
/* 177 */     h = h << 1 | h >>> 31;
/* 178 */     h ^= Float.floatToRawIntBits(getBoost());
/* 179 */     return h;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanNotQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanOrQuery,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.ArrayList;
/*     */ import java.util.Collection;
/*     */ import java.util.Iterator;
/*     */ import java.util.List;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.util.PriorityQueue;
/*     */ import org.apache.lucene.util.ToStringUtils;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanOrQuery
/*     */   extends SpanQuery
/*     */ {
/*     */   private List clauses;
/*     */   private String field;
/*     */   
/*     */   public SpanOrQuery(SpanQuery[] clauses) {
/*  42 */     this.clauses = new ArrayList(clauses.length);
/*  43 */     for (int i = 0; i < clauses.length; i++) {
/*  44 */       SpanQuery clause = clauses[i];
/*  45 */       if (i == 0) {
/*  46 */         this.field = clause.getField();
/*  47 */       } else if (!clause.getField().equals(this.field)) {
/*  48 */         throw new IllegalArgumentException(""Clauses must have same field."");
/*     */       } 
/*  50 */       this.clauses.add(clause);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  56 */   public SpanQuery[] getClauses() { return (SpanQuery[])this.clauses.toArray((Object[])new SpanQuery[this.clauses.size()]); }
/*     */ 
/*     */   
/*  59 */   public String getField() { return this.field; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Collection getTerms() {
/*  66 */     Collection terms = new ArrayList();
/*  67 */     Iterator i = this.clauses.iterator();
/*  68 */     while (i.hasNext()) {
/*  69 */       SpanQuery clause = i.next();
/*  70 */       terms.addAll(clause.getTerms());
/*     */     } 
/*  72 */     return terms;
/*     */   }
/*     */   
/*     */   public void extractTerms(Set terms) {
/*  76 */     Iterator i = this.clauses.iterator();
/*  77 */     while (i.hasNext()) {
/*  78 */       SpanQuery clause = i.next();
/*  79 */       clause.extractTerms(terms);
/*     */     } 
/*     */   }
/*     */   
/*     */   public Query rewrite(IndexReader reader) throws IOException {
/*  84 */     SpanOrQuery clone = null;
/*  85 */     for (int i = 0; i < this.clauses.size(); i++) {
/*  86 */       SpanQuery c = this.clauses.get(i);
/*  87 */       SpanQuery query = (SpanQuery)c.rewrite(reader);
/*  88 */       if (query != c) {
/*  89 */         if (clone == null)
/*  90 */           clone = (SpanOrQuery)clone(); 
/*  91 */         clone.clauses.set(i, query);
/*     */       } 
/*     */     } 
/*  94 */     if (clone != null) {
/*  95 */       return clone;
/*     */     }
/*  97 */     return this;
/*     */   }
/*     */ 
/*     */   
/*     */   public String toString(String field) {
/* 102 */     StringBuffer buffer = new StringBuffer();
/* 103 */     buffer.append(""spanOr(["");
/* 104 */     Iterator i = this.clauses.iterator();
/* 105 */     while (i.hasNext()) {
/* 106 */       SpanQuery clause = i.next();
/* 107 */       buffer.append(clause.toString(field));
/* 108 */       if (i.hasNext()) {
/* 109 */         buffer.append("", "");
/*     */       }
/*     */     } 
/* 112 */     buffer.append(""])"");
/* 113 */     buffer.append(ToStringUtils.boost(getBoost()));
/* 114 */     return buffer.toString();
/*     */   }
/*     */   
/*     */   public boolean equals(Object o) {
/* 118 */     if (this == o) return true; 
/* 119 */     if (o == null || getClass() != o.getClass()) return false;
/*     */     
/* 121 */     SpanOrQuery that = (SpanOrQuery)o;
/*     */     
/* 123 */     if (!this.clauses.equals(that.clauses)) return false; 
/* 124 */     if (!this.field.equals(that.field)) return false;
/*     */     
/* 126 */     return (getBoost() == that.getBoost());
/*     */   }
/*     */   
/*     */   public int hashCode() {
/* 130 */     int h = this.clauses.hashCode();
/* 131 */     h ^= h << 10 | h >>> 23;
/* 132 */     h ^= Float.floatToRawIntBits(getBoost());
/* 133 */     return h;
/*     */   }
/*     */   
/*     */   private class SpanQueue extends PriorityQueue {
/*     */     private final SpanOrQuery this$0;
/*     */     
/* 139 */     public SpanQueue(int size) { initialize(size); }
/*     */ 
/*     */     
/*     */     protected final boolean lessThan(Object o1, Object o2) {
/* 143 */       Spans spans1 = (Spans)o1;
/* 144 */       Spans spans2 = (Spans)o2;
/* 145 */       if (spans1.doc() == spans2.doc()) {
/* 146 */         if (spans1.start() == spans2.start()) {
/* 147 */           return (spans1.end() < spans2.end());
/*     */         }
/* 149 */         return (spans1.start() < spans2.start());
/*     */       } 
/*     */       
/* 152 */       return (spans1.doc() < spans2.doc());
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public Spans getSpans(final IndexReader reader) throws IOException {
/* 159 */     if (this.clauses.size() == 1) {
/* 160 */       return ((SpanQuery)this.clauses.get(0)).getSpans(reader);
/*     */     }
/* 162 */     return new Spans() {
/* 163 */         private SpanOrQuery.SpanQueue queue = null; private final IndexReader val$reader;
/*     */         
/*     */         private boolean initSpanQueue(int target) throws IOException {
/* 166 */           this.queue = new SpanOrQuery.SpanQueue(SpanOrQuery.this.clauses.size());
/* 167 */           Iterator i = SpanOrQuery.this.clauses.iterator();
/* 168 */           while (i.hasNext()) {
/* 169 */             Spans spans = ((SpanQuery)i.next()).getSpans(reader);
/* 170 */             if ((target == -1 && spans.next()) || (target != -1 && spans.skipTo(target)))
/*     */             {
/* 172 */               this.queue.put(spans);
/*     */             }
/*     */           } 
/* 175 */           return (this.queue.size() != 0);
/*     */         }
/*     */         private final SpanOrQuery this$0;
/*     */         public boolean next() throws IOException {
/* 179 */           if (this.queue == null) {
/* 180 */             return initSpanQueue(-1);
/*     */           }
/*     */           
/* 183 */           if (this.queue.size() == 0) {
/* 184 */             return false;
/*     */           }
/*     */           
/* 187 */           if (top().next()) {
/* 188 */             this.queue.adjustTop();
/* 189 */             return true;
/*     */           } 
/*     */           
/* 192 */           this.queue.pop();
/* 193 */           return (this.queue.size() != 0);
/*     */         }
/*     */         
/* 196 */         private Spans top() { return (Spans)this.queue.top(); }
/*     */         
/*     */         public boolean skipTo(int target) throws IOException {
/* 199 */           if (this.queue == null) {
/* 200 */             return initSpanQueue(target);
/*     */           }
/*     */           
/* 203 */           while (this.queue.size() != 0 && top().doc() < target) {
/* 204 */             if (top().skipTo(target)) {
/* 205 */               this.queue.adjustTop(); continue;
/*     */             } 
/* 207 */             this.queue.pop();
/*     */           } 
/*     */ 
/*     */           
/* 211 */           return (this.queue.size() != 0);
/*     */         }
/*     */         
/* 214 */         public int doc() { return top().doc(); }
/* 215 */         public int start() { return top().start(); }
/* 216 */         public int end() { return top().end(); }
/*     */ 
/*     */         
/* 219 */         public String toString() { return ""spans("" + SpanOrQuery.this + "")@"" + ((this.queue == null) ? ""START"" : ((this.queue.size() > 0) ? (doc() + "":"" + start() + ""-"" + end()) : ""END"")); }
/*     */       };
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanOrQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanQuery,"/*    */ package org.apache.lucene.search.spans;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.Collection;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.search.Query;
/*    */ import org.apache.lucene.search.Searcher;
/*    */ import org.apache.lucene.search.Weight;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class SpanQuery
/*    */   extends Query
/*    */ {
/*    */   public abstract Spans getSpans(IndexReader paramIndexReader) throws IOException;
/*    */   
/*    */   public abstract String getField();
/*    */   
/*    */   public abstract Collection getTerms();
/*    */   
/* 46 */   protected Weight createWeight(Searcher searcher) throws IOException { return new SpanWeight(this, searcher); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.Spans,"package org.apache.lucene.search.spans;
import java.io.IOException;
public interface Spans {
  boolean next() throws IOException;
  boolean skipTo(int paramInt) throws IOException;
  int doc();
  int start();
  int end();
}
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\Spans.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanScorer,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanScorer
/*     */   extends Scorer
/*     */ {
/*     */   protected Spans spans;
/*     */   protected Weight weight;
/*     */   protected byte[] norms;
/*     */   protected float value;
/*     */   protected boolean firstTime = true;
/*     */   protected boolean more = true;
/*     */   protected int doc;
/*     */   protected float freq;
/*     */   
/*     */   protected SpanScorer(Spans spans, Weight weight, Similarity similarity, byte[] norms) throws IOException {
/*  44 */     super(similarity);
/*  45 */     this.spans = spans;
/*  46 */     this.norms = norms;
/*  47 */     this.weight = weight;
/*  48 */     this.value = weight.getValue();
/*  49 */     this.doc = -1;
/*     */   }
/*     */   
/*     */   public boolean next() throws IOException {
/*  53 */     if (this.firstTime) {
/*  54 */       this.more = this.spans.next();
/*  55 */       this.firstTime = false;
/*     */     } 
/*  57 */     return setFreqCurrentDoc();
/*     */   }
/*     */   
/*     */   public boolean skipTo(int target) throws IOException {
/*  61 */     if (this.firstTime) {
/*  62 */       this.more = this.spans.skipTo(target);
/*  63 */       this.firstTime = false;
/*     */     } 
/*  65 */     if (!this.more) {
/*  66 */       return false;
/*     */     }
/*  68 */     if (this.spans.doc() < target) {
/*  69 */       this.more = this.spans.skipTo(target);
/*     */     }
/*  71 */     return setFreqCurrentDoc();
/*     */   }
/*     */   
/*     */   protected boolean setFreqCurrentDoc() throws IOException {
/*  75 */     if (!this.more) {
/*  76 */       return false;
/*     */     }
/*  78 */     this.doc = this.spans.doc();
/*  79 */     this.freq = 0.0F;
/*  80 */     while (this.more && this.doc == this.spans.doc()) {
/*  81 */       int matchLength = this.spans.end() - this.spans.start();
/*  82 */       this.freq += getSimilarity().sloppyFreq(matchLength);
/*  83 */       this.more = this.spans.next();
/*     */     } 
/*  85 */     return (this.more || this.freq != 0.0F);
/*     */   }
/*     */   
/*  88 */   public int doc() { return this.doc; }
/*     */   
/*     */   public float score() throws IOException {
/*  91 */     float raw = getSimilarity().tf(this.freq) * this.value;
/*  92 */     return raw * Similarity.decodeNorm(this.norms[this.doc]);
/*     */   }
/*     */   
/*     */   public Explanation explain(int doc) throws IOException {
/*  96 */     Explanation tfExplanation = new Explanation();
/*     */     
/*  98 */     skipTo(doc);
/*     */     
/* 100 */     float phraseFreq = (doc() == doc) ? this.freq : 0.0F;
/* 101 */     tfExplanation.setValue(getSimilarity().tf(phraseFreq));
/* 102 */     tfExplanation.setDescription(""tf(phraseFreq="" + phraseFreq + "")"");
/*     */     
/* 104 */     return tfExplanation;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanScorer.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanTermQuery,"/*    */ package org.apache.lucene.search.spans;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.ArrayList;
/*    */ import java.util.Collection;
/*    */ import java.util.Set;
/*    */ import org.apache.lucene.index.IndexReader;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.util.ToStringUtils;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SpanTermQuery
/*    */   extends SpanQuery
/*    */ {
/*    */   protected Term term;
/*    */   
/* 34 */   public SpanTermQuery(Term term) { this.term = term; }
/*    */ 
/*    */   
/* 37 */   public Term getTerm() { return this.term; }
/*    */   
/* 39 */   public String getField() { return this.term.field(); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public Collection getTerms() {
/* 46 */     Collection terms = new ArrayList();
/* 47 */     terms.add(this.term);
/* 48 */     return terms;
/*    */   }
/*    */   
/* 51 */   public void extractTerms(Set terms) { terms.add(this.term); }
/*    */ 
/*    */   
/*    */   public String toString(String field) {
/* 55 */     StringBuffer buffer = new StringBuffer();
/* 56 */     if (this.term.field().equals(field)) {
/* 57 */       buffer.append(this.term.text());
/*    */     } else {
/* 59 */       buffer.append(this.term.toString());
/* 60 */     }  buffer.append(ToStringUtils.boost(getBoost()));
/* 61 */     return buffer.toString();
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean equals(Object o) {
/* 66 */     if (!(o instanceof SpanTermQuery))
/* 67 */       return false; 
/* 68 */     SpanTermQuery other = (SpanTermQuery)o;
/* 69 */     return (getBoost() == other.getBoost() && this.term.equals(other.term));
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 75 */   public int hashCode() { return Float.floatToIntBits(getBoost()) ^ this.term.hashCode() ^ 0xD23FE494; }
/*    */ 
/*    */ 
/*    */   
/* 79 */   public Spans getSpans(IndexReader reader) throws IOException { return new TermSpans(reader.termPositions(this.term), this.term); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanTermQuery.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.SpanWeight,"/*     */ package org.apache.lucene.search.spans;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import java.util.HashSet;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ import org.apache.lucene.index.IndexReader;
/*     */ import org.apache.lucene.index.Term;
/*     */ import org.apache.lucene.search.ComplexExplanation;
/*     */ import org.apache.lucene.search.Explanation;
/*     */ import org.apache.lucene.search.Query;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ import org.apache.lucene.search.Searcher;
/*     */ import org.apache.lucene.search.Similarity;
/*     */ import org.apache.lucene.search.Weight;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SpanWeight
/*     */   implements Weight
/*     */ {
/*     */   protected Similarity similarity;
/*     */   protected float value;
/*     */   protected float idf;
/*     */   protected float queryNorm;
/*     */   protected float queryWeight;
/*     */   protected Set terms;
/*     */   protected SpanQuery query;
/*     */   
/*     */   public SpanWeight(SpanQuery query, Searcher searcher) throws IOException {
/*  44 */     this.similarity = query.getSimilarity(searcher);
/*  45 */     this.query = query;
/*  46 */     this.terms = new HashSet();
/*  47 */     query.extractTerms(this.terms);
/*     */     
/*  49 */     this.idf = this.query.getSimilarity(searcher).idf(this.terms, searcher);
/*     */   }
/*     */   
/*  52 */   public Query getQuery() { return this.query; }
/*  53 */   public float getValue() { return this.value; }
/*     */   
/*     */   public float sumOfSquaredWeights() throws IOException {
/*  56 */     this.queryWeight = this.idf * this.query.getBoost();
/*  57 */     return this.queryWeight * this.queryWeight;
/*     */   }
/*     */   
/*     */   public void normalize(float queryNorm) {
/*  61 */     this.queryNorm = queryNorm;
/*  62 */     this.queryWeight *= queryNorm;
/*  63 */     this.value = this.queryWeight * this.idf;
/*     */   }
/*     */ 
/*     */   
/*  67 */   public Scorer scorer(IndexReader reader) throws IOException { return new SpanScorer(this.query.getSpans(reader), this, this.similarity, reader.norms(this.query.getField())); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Explanation explain(IndexReader reader, int doc) throws IOException {
/*  75 */     ComplexExplanation result = new ComplexExplanation();
/*  76 */     result.setDescription(""weight("" + getQuery() + "" in "" + doc + ""), product of:"");
/*  77 */     String field = ((SpanQuery)getQuery()).getField();
/*     */     
/*  79 */     StringBuffer docFreqs = new StringBuffer();
/*  80 */     Iterator i = this.terms.iterator();
/*  81 */     while (i.hasNext()) {
/*  82 */       Term term = i.next();
/*  83 */       docFreqs.append(term.text());
/*  84 */       docFreqs.append(""="");
/*  85 */       docFreqs.append(reader.docFreq(term));
/*     */       
/*  87 */       if (i.hasNext()) {
/*  88 */         docFreqs.append("" "");
/*     */       }
/*     */     } 
/*     */     
/*  92 */     Explanation idfExpl = new Explanation(this.idf, ""idf("" + field + "": "" + docFreqs + "")"");
/*     */ 
/*     */ 
/*     */     
/*  96 */     Explanation queryExpl = new Explanation();
/*  97 */     queryExpl.setDescription(""queryWeight("" + getQuery() + ""), product of:"");
/*     */     
/*  99 */     Explanation boostExpl = new Explanation(getQuery().getBoost(), ""boost"");
/* 100 */     if (getQuery().getBoost() != 1.0F)
/* 101 */       queryExpl.addDetail(boostExpl); 
/* 102 */     queryExpl.addDetail(idfExpl);
/*     */     
/* 104 */     Explanation queryNormExpl = new Explanation(this.queryNorm, ""queryNorm"");
/* 105 */     queryExpl.addDetail(queryNormExpl);
/*     */     
/* 107 */     queryExpl.setValue(boostExpl.getValue() * idfExpl.getValue() * queryNormExpl.getValue());
/*     */ 
/*     */ 
/*     */     
/* 111 */     result.addDetail(queryExpl);
/*     */ 
/*     */     
/* 114 */     ComplexExplanation fieldExpl = new ComplexExplanation();
/* 115 */     fieldExpl.setDescription(""fieldWeight("" + field + "":"" + this.query.toString(field) + "" in "" + doc + ""), product of:"");
/*     */ 
/*     */     
/* 118 */     Explanation tfExpl = scorer(reader).explain(doc);
/* 119 */     fieldExpl.addDetail(tfExpl);
/* 120 */     fieldExpl.addDetail(idfExpl);
/*     */     
/* 122 */     Explanation fieldNormExpl = new Explanation();
/* 123 */     byte[] fieldNorms = reader.norms(field);
/* 124 */     float fieldNorm = (fieldNorms != null) ? Similarity.decodeNorm(fieldNorms[doc]) : 0.0F;
/*     */     
/* 126 */     fieldNormExpl.setValue(fieldNorm);
/* 127 */     fieldNormExpl.setDescription(""fieldNorm(field="" + field + "", doc="" + doc + "")"");
/* 128 */     fieldExpl.addDetail(fieldNormExpl);
/*     */     
/* 130 */     fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
/* 131 */     fieldExpl.setValue(tfExpl.getValue() * idfExpl.getValue() * fieldNormExpl.getValue());
/*     */ 
/*     */ 
/*     */     
/* 135 */     result.addDetail((Explanation)fieldExpl);
/* 136 */     result.setMatch(fieldExpl.getMatch());
/*     */ 
/*     */     
/* 139 */     result.setValue(queryExpl.getValue() * fieldExpl.getValue());
/*     */     
/* 141 */     if (queryExpl.getValue() == 1.0F) {
/* 142 */       return (Explanation)fieldExpl;
/*     */     }
/* 144 */     return (Explanation)result;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\SpanWeight.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.search.spans.TermSpans,"/*    */ package org.apache.lucene.search.spans;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import org.apache.lucene.index.Term;
/*    */ import org.apache.lucene.index.TermPositions;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TermSpans
/*    */   implements Spans
/*    */ {
/*    */   protected TermPositions positions;
/*    */   protected Term term;
/*    */   protected int doc;
/*    */   protected int freq;
/*    */   protected int count;
/*    */   protected int position;
/*    */   
/*    */   public TermSpans(TermPositions positions, Term term) throws IOException {
/* 39 */     this.positions = positions;
/* 40 */     this.term = term;
/* 41 */     this.doc = -1;
/*    */   }
/*    */   
/*    */   public boolean next() throws IOException {
/* 45 */     if (this.count == this.freq) {
/* 46 */       if (!this.positions.next()) {
/* 47 */         this.doc = Integer.MAX_VALUE;
/* 48 */         return false;
/*    */       } 
/* 50 */       this.doc = this.positions.doc();
/* 51 */       this.freq = this.positions.freq();
/* 52 */       this.count = 0;
/*    */     } 
/* 54 */     this.position = this.positions.nextPosition();
/* 55 */     this.count++;
/* 56 */     return true;
/*    */   }
/*    */ 
/*    */   
/*    */   public boolean skipTo(int target) throws IOException {
/* 61 */     if (this.doc >= target) {
/* 62 */       return true;
/*    */     }
/*    */     
/* 65 */     if (!this.positions.skipTo(target)) {
/* 66 */       this.doc = Integer.MAX_VALUE;
/* 67 */       return false;
/*    */     } 
/*    */     
/* 70 */     this.doc = this.positions.doc();
/* 71 */     this.freq = this.positions.freq();
/* 72 */     this.count = 0;
/*    */     
/* 74 */     this.position = this.positions.nextPosition();
/* 75 */     this.count++;
/*    */     
/* 77 */     return true;
/*    */   }
/*    */ 
/*    */   
/* 81 */   public int doc() { return this.doc; }
/*    */ 
/*    */ 
/*    */   
/* 85 */   public int start() { return this.position; }
/*    */ 
/*    */ 
/*    */   
/* 89 */   public int end() { return this.position + 1; }
/*    */ 
/*    */ 
/*    */   
/* 93 */   public String toString() { return ""spans("" + this.term.toString() + "")@"" + ((this.doc == -1) ? ""START"" : ((this.doc == Integer.MAX_VALUE) ? ""END"" : (this.doc + ""-"" + this.position))); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 99 */   public TermPositions getPositions() { return this.positions; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\search\spans\TermSpans.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.AlreadyClosedException,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class AlreadyClosedException
/*    */   extends IllegalStateException
/*    */ {
/* 26 */   public AlreadyClosedException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\AlreadyClosedException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.BufferedIndexInput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class BufferedIndexInput
/*     */   extends IndexInput
/*     */ {
/*     */   public static final int BUFFER_SIZE = 1024;
/*  28 */   private int bufferSize = 1024;
/*     */   
/*     */   private byte[] buffer;
/*     */   
/*  32 */   private long bufferStart = 0L;
/*  33 */   private int bufferLength = 0;
/*  34 */   private int bufferPosition = 0;
/*     */   
/*     */   public byte readByte() throws IOException {
/*  37 */     if (this.bufferPosition >= this.bufferLength)
/*  38 */       refill(); 
/*  39 */     return this.buffer[this.bufferPosition++];
/*     */   }
/*     */ 
/*     */   
/*     */   static final boolean $assertionsDisabled;
/*     */   
/*     */   public BufferedIndexInput(int bufferSize) {
/*  46 */     checkBufferSize(bufferSize);
/*  47 */     this.bufferSize = bufferSize;
/*     */   }
/*     */ 
/*     */   
/*     */   public void setBufferSize(int newSize) {
/*  52 */     assert this.buffer == null || this.bufferSize == this.buffer.length;
/*  53 */     if (newSize != this.bufferSize) {
/*  54 */       checkBufferSize(newSize);
/*  55 */       this.bufferSize = newSize;
/*  56 */       if (this.buffer != null) {
/*     */         int numToCopy;
/*     */ 
/*     */         
/*  60 */         byte[] newBuffer = new byte[newSize];
/*  61 */         int leftInBuffer = this.bufferLength - this.bufferPosition;
/*     */         
/*  63 */         if (leftInBuffer > newSize) {
/*  64 */           numToCopy = newSize;
/*     */         } else {
/*  66 */           numToCopy = leftInBuffer;
/*  67 */         }  System.arraycopy(this.buffer, this.bufferPosition, newBuffer, 0, numToCopy);
/*  68 */         this.bufferStart += this.bufferPosition;
/*  69 */         this.bufferPosition = 0;
/*  70 */         this.bufferLength = numToCopy;
/*  71 */         this.buffer = newBuffer;
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  78 */   public int getBufferSize() { return this.bufferSize; }
/*     */ 
/*     */   
/*     */   private void checkBufferSize(int bufferSize) {
/*  82 */     if (bufferSize <= 0)
/*  83 */       throw new IllegalArgumentException(""bufferSize must be greater than 0 (got "" + bufferSize + "")""); 
/*     */   }
/*     */   
/*     */   public void readBytes(byte[] b, int offset, int len) throws IOException {
/*  87 */     if (len <= this.bufferLength - this.bufferPosition) {
/*     */       
/*  89 */       if (len > 0)
/*  90 */         System.arraycopy(this.buffer, this.bufferPosition, b, offset, len); 
/*  91 */       this.bufferPosition += len;
/*     */     } else {
/*     */       
/*  94 */       int available = this.bufferLength - this.bufferPosition;
/*  95 */       if (available > 0) {
/*  96 */         System.arraycopy(this.buffer, this.bufferPosition, b, offset, available);
/*  97 */         offset += available;
/*  98 */         len -= available;
/*  99 */         this.bufferPosition += available;
/*     */       } 
/*     */       
/* 102 */       if (len < this.bufferSize) {
/*     */ 
/*     */         
/* 105 */         refill();
/* 106 */         if (this.bufferLength < len) {
/*     */           
/* 108 */           System.arraycopy(this.buffer, 0, b, offset, this.bufferLength);
/* 109 */           throw new IOException(""read past EOF"");
/*     */         } 
/* 111 */         System.arraycopy(this.buffer, 0, b, offset, len);
/* 112 */         this.bufferPosition = len;
/*     */ 
/*     */       
/*     */       }
/*     */       else {
/*     */ 
/*     */         
/* 119 */         long after = this.bufferStart + this.bufferPosition + len;
/* 120 */         if (after > length())
/* 121 */           throw new IOException(""read past EOF""); 
/* 122 */         readInternal(b, offset, len);
/* 123 */         this.bufferStart = after;
/* 124 */         this.bufferPosition = 0;
/* 125 */         this.bufferLength = 0;
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   private void refill() throws IOException {
/* 131 */     long start = this.bufferStart + this.bufferPosition;
/* 132 */     long end = start + this.bufferSize;
/* 133 */     if (end > length())
/* 134 */       end = length(); 
/* 135 */     this.bufferLength = (int)(end - start);
/* 136 */     if (this.bufferLength <= 0) {
/* 137 */       throw new IOException(""read past EOF"");
/*     */     }
/* 139 */     if (this.buffer == null) {
/* 140 */       this.buffer = new byte[this.bufferSize];
/* 141 */       seekInternal(this.bufferStart);
/*     */     } 
/* 143 */     readInternal(this.buffer, 0, this.bufferLength);
/*     */     
/* 145 */     this.bufferStart = start;
/* 146 */     this.bufferPosition = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 158 */   public long getFilePointer() { return this.bufferStart + this.bufferPosition; }
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 161 */     if (pos >= this.bufferStart && pos < this.bufferStart + this.bufferLength) {
/* 162 */       this.bufferPosition = (int)(pos - this.bufferStart);
/*     */     } else {
/* 164 */       this.bufferStart = pos;
/* 165 */       this.bufferPosition = 0;
/* 166 */       this.bufferLength = 0;
/* 167 */       seekInternal(pos);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 178 */     BufferedIndexInput clone = (BufferedIndexInput)super.clone();
/*     */     
/* 180 */     clone.buffer = null;
/* 181 */     clone.bufferLength = 0;
/* 182 */     clone.bufferPosition = 0;
/* 183 */     clone.bufferStart = getFilePointer();
/*     */     
/* 185 */     return clone;
/*     */   }
/*     */   
/*     */   public BufferedIndexInput() {}
/*     */   
/*     */   protected abstract void readInternal(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */   
/*     */   protected abstract void seekInternal(long paramLong) throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\BufferedIndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.BufferedIndexOutput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class BufferedIndexOutput
/*     */   extends IndexOutput
/*     */ {
/*     */   static final int BUFFER_SIZE = 16384;
/*  26 */   private final byte[] buffer = new byte[16384];
/*  27 */   private long bufferStart = 0L;
/*  28 */   private int bufferPosition = 0;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeByte(byte b) throws IOException {
/*  34 */     if (this.bufferPosition >= 16384)
/*  35 */       flush(); 
/*  36 */     this.buffer[this.bufferPosition++] = b;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeBytes(byte[] b, int offset, int length) throws IOException {
/*  45 */     int bytesLeft = 16384 - this.bufferPosition;
/*     */     
/*  47 */     if (bytesLeft >= length) {
/*     */       
/*  49 */       System.arraycopy(b, offset, this.buffer, this.bufferPosition, length);
/*  50 */       this.bufferPosition += length;
/*     */       
/*  52 */       if (16384 - this.bufferPosition == 0) {
/*  53 */         flush();
/*     */       }
/*     */     }
/*  56 */     else if (length > 16384) {
/*     */       
/*  58 */       if (this.bufferPosition > 0) {
/*  59 */         flush();
/*     */       }
/*  61 */       flushBuffer(b, offset, length);
/*  62 */       this.bufferStart += length;
/*     */     } else {
/*     */       
/*  65 */       int pos = 0;
/*     */       
/*  67 */       while (pos < length) {
/*  68 */         int pieceLength = (length - pos < bytesLeft) ? (length - pos) : bytesLeft;
/*  69 */         System.arraycopy(b, pos + offset, this.buffer, this.bufferPosition, pieceLength);
/*  70 */         pos += pieceLength;
/*  71 */         this.bufferPosition += pieceLength;
/*     */         
/*  73 */         bytesLeft = 16384 - this.bufferPosition;
/*  74 */         if (bytesLeft == 0) {
/*  75 */           flush();
/*  76 */           bytesLeft = 16384;
/*     */         } 
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void flush() throws IOException {
/*  85 */     flushBuffer(this.buffer, this.bufferPosition);
/*  86 */     this.bufferStart += this.bufferPosition;
/*  87 */     this.bufferPosition = 0;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  96 */   private void flushBuffer(byte[] b, int len) throws IOException { flushBuffer(b, 0, len); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected abstract void flushBuffer(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 109 */   public void close() throws IOException { flush(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 117 */   public long getFilePointer() { return this.bufferStart + this.bufferPosition; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 124 */     flush();
/* 125 */     this.bufferStart = pos;
/*     */   }
/*     */   
/*     */   public abstract long length() throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\BufferedIndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.Directory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Directory
/*     */ {
/*     */   protected LockFactory lockFactory;
/*     */   
/*     */   public abstract String[] list() throws IOException;
/*     */   
/*     */   public abstract boolean fileExists(String paramString) throws IOException;
/*     */   
/*     */   public abstract long fileModified(String paramString) throws IOException;
/*     */   
/*     */   public abstract void touchFile(String paramString) throws IOException;
/*     */   
/*     */   public abstract void deleteFile(String paramString) throws IOException;
/*     */   
/*     */   public abstract void renameFile(String paramString1, String paramString2) throws IOException;
/*     */   
/*     */   public abstract long fileLength(String paramString) throws IOException;
/*     */   
/*     */   public abstract IndexOutput createOutput(String paramString) throws IOException;
/*     */   
/*     */   public abstract IndexInput openInput(String paramString) throws IOException;
/*     */   
/*  99 */   public IndexInput openInput(String name, int bufferSize) throws IOException { return openInput(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 106 */   public Lock makeLock(String name) { return this.lockFactory.makeLock(name); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void clearLock(String name) throws IOException {
/* 115 */     if (this.lockFactory != null) {
/* 116 */       this.lockFactory.clearLock(name);
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void setLockFactory(LockFactory lockFactory) {
/* 134 */     this.lockFactory = lockFactory;
/* 135 */     lockFactory.setLockPrefix(getLockID());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 145 */   public LockFactory getLockFactory() { return this.lockFactory; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 157 */   public String getLockID() { return toString(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static void copy(Directory src, Directory dest, boolean closeDirSrc) throws IOException {
/* 171 */     String[] files = src.list();
/*     */     
/* 173 */     if (files == null) {
/* 174 */       throw new IOException(""cannot read directory "" + src + "": list() returned null"");
/*     */     }
/* 176 */     byte[] buf = new byte[16384];
/* 177 */     for (int i = 0; i < files.length; i++) {
/* 178 */       IndexOutput os = null;
/* 179 */       IndexInput is = null;
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 205 */     if (closeDirSrc)
/* 206 */       src.close(); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\Directory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.FSDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileInputStream;
/*     */ import java.io.FileOutputStream;
/*     */ import java.io.FilenameFilter;
/*     */ import java.io.IOException;
/*     */ import java.io.InputStream;
/*     */ import java.io.OutputStream;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.security.MessageDigest;
/*     */ import java.security.NoSuchAlgorithmException;
/*     */ import java.util.Hashtable;
/*     */ import org.apache.lucene.index.IndexFileNameFilter;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class FSDirectory
/*     */   extends Directory
/*     */ {
/*  61 */   private static final Hashtable DIRECTORIES = new Hashtable();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private static boolean disableLocks = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  74 */   public static void setDisableLocks(boolean doDisableLocks) { disableLocks = doDisableLocks; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  82 */   public static boolean getDisableLocks() { return disableLocks; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  99 */   public static final String LOCK_DIR = System.getProperty(""org.apache.lucene.lockDir"", System.getProperty(""java.io.tmpdir"")); private static Class IMPL; private static MessageDigest DIGESTER; private byte[] buffer = null; public static FSDirectory getDirectory(String path) throws IOException { return getDirectory(new File(path), null); } public static FSDirectory getDirectory(String path, LockFactory lockFactory) throws IOException { return getDirectory(new File(path), lockFactory); } public static FSDirectory getDirectory(File file) throws IOException { return getDirectory(file, null); } public static FSDirectory getDirectory(File file, LockFactory lockFactory) throws IOException { FSDirectory dir; file = new File(file.getCanonicalPath()); if (file.exists() && !file.isDirectory())
/*     */       throw new IOException(file + "" not a directory"");  if (!file.exists() && !file.mkdirs())
/*     */       throw new IOException(""Cannot create directory: "" + file);  synchronized (DIRECTORIES) { dir = (FSDirectory)DIRECTORIES.get(file); if (dir == null) { try { dir = IMPL.newInstance(); } catch (Exception e) { throw new RuntimeException(""cannot load FSDirectory class: "" + e.toString(), e); }  dir.init(file, lockFactory); DIRECTORIES.put(file, dir); }
/*     */       else if (lockFactory != null && lockFactory != dir.getLockFactory()) { throw new IOException(""Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it""); }
/*     */        }
/*     */      synchronized (dir) { dir.refCount++; }
/*     */      return dir; } public static FSDirectory getDirectory(String path, boolean create) throws IOException { return getDirectory(new File(path), create); }
/* 106 */   static  { try { String name = System.getProperty(""org.apache.lucene.FSDirectory.class"", FSDirectory.class.getName());
/*     */ 
/*     */       
/* 109 */       IMPL = Class.forName(name); }
/* 110 */     catch (ClassNotFoundException e)
/* 111 */     { throw new RuntimeException(""cannot load FSDirectory class: "" + e.toString(), e); }
/* 112 */     catch (SecurityException se)
/*     */     { try {
/* 114 */         IMPL = Class.forName(FSDirectory.class.getName());
/* 115 */       } catch (ClassNotFoundException e) {
/* 116 */         throw new RuntimeException(""cannot load default FSDirectory class: "" + e.toString(), e);
/*     */       }  }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 125 */       DIGESTER = MessageDigest.getInstance(""MD5"");
/* 126 */     } catch (NoSuchAlgorithmException e) {
/* 127 */       throw new RuntimeException(e.toString(), e);
/*     */     } 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 451 */     HEX_DIGITS = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; } public static FSDirectory getDirectory(File file, boolean create) throws IOException { FSDirectory dir = getDirectory(file, null); if (create)
/*     */       dir.create();  return dir; } private void create() throws IOException { if (this.directory.exists()) { String[] files = this.directory.list((FilenameFilter)IndexFileNameFilter.getFilter()); if (files == null)
/*     */         throw new IOException(""cannot read directory "" + this.directory.getAbsolutePath() + "": list() returned null"");  for (int i = 0; i < files.length; i++) { File file = new File(this.directory, files[i]); if (!file.delete())
/*     */           throw new IOException(""Cannot delete "" + file);  }
/*     */        }
/*     */      this.lockFactory.clearLock(""write.lock""); }
/*     */   private File directory = null; private int refCount; private static final char[] HEX_DIGITS;
/*     */   private void init(File path, LockFactory lockFactory) throws IOException { this.directory = path; boolean doClearLockID = false; if (lockFactory == null)
/*     */       if (disableLocks) { lockFactory = NoLockFactory.getNoLockFactory(); }
/*     */       else { String lockClassName = System.getProperty(""org.apache.lucene.store.FSDirectoryLockFactoryClass""); if (lockClassName != null && !lockClassName.equals("""")) { Class c; try { c = Class.forName(lockClassName); }
/*     */           catch (ClassNotFoundException e) { throw new IOException(""unable to find LockClass "" + lockClassName); }
/*     */            try {
/*     */             lockFactory = (LockFactory)c.newInstance();
/*     */           } catch (IllegalAccessException e) {
/*     */             throw new IOException(""IllegalAccessException when instantiating LockClass "" + lockClassName);
/*     */           } catch (InstantiationException e) {
/*     */             throw new IOException(""InstantiationException when instantiating LockClass "" + lockClassName);
/*     */           } catch (ClassCastException e) {
/*     */             throw new IOException(""unable to cast LockClass "" + lockClassName + "" instance to a LockFactory"");
/*     */           }  if (lockFactory instanceof NativeFSLockFactory) {
/*     */             ((NativeFSLockFactory)lockFactory).setLockDir(path);
/*     */           } else if (lockFactory instanceof SimpleFSLockFactory) {
/*     */             ((SimpleFSLockFactory)lockFactory).setLockDir(path);
/*     */           }  }
/*     */         else
/*     */         { lockFactory = new SimpleFSLockFactory(path); doClearLockID = true; }
/*     */          }
/*     */         setLockFactory(lockFactory); if (doClearLockID)
/*     */       lockFactory.setLockPrefix(null);  }
/* 480 */   public synchronized void close() { if (--this.refCount <= 0)
/* 481 */       synchronized (DIRECTORIES) {
/* 482 */         DIRECTORIES.remove(this.directory);
/*     */       }   } public String[] list() { return this.directory.list((FilenameFilter)IndexFileNameFilter.getFilter()); } public boolean fileExists(String name) { File file = new File(this.directory, name); return file.exists(); }
/*     */   public long fileModified(String name) { File file = new File(this.directory, name); return file.lastModified(); }
/*     */   public static long fileModified(File directory, String name) { File file = new File(directory, name); return file.lastModified(); }
/*     */   public void touchFile(String name) { File file = new File(this.directory, name); file.setLastModified(System.currentTimeMillis()); }
/*     */   public long fileLength(String name) { File file = new File(this.directory, name); return file.length(); }
/* 488 */   public File getFile() { return this.directory; } public void deleteFile(String name) throws IOException {
/*     */     File file = new File(this.directory, name);
/*     */     if (!file.delete())
/*     */       throw new IOException(""Cannot delete "" + file); 
/*     */   }
/* 493 */   public String toString() { return getClass().getName() + ""@"" + this.directory; } public synchronized void renameFile(String from, String to) throws IOException { File old = new File(this.directory, from); File nu = new File(this.directory, to); if (nu.exists() && !nu.delete())
/*     */       throw new IOException(""Cannot delete "" + nu);  if (!old.renameTo(nu)) { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(old); out = new FileOutputStream(nu); if (this.buffer == null)
/*     */           this.buffer = new byte[1024];  int len; while ((len = in.read(this.buffer)) >= 0)
/*     */           out.write(this.buffer, 0, len);  old.delete(); } catch (IOException ioe) { IOException newExc = new IOException(""Cannot rename "" + old + "" to "" + nu); newExc.initCause(ioe); throw newExc; } finally { try { if (in != null)
/*     */             try { in.close(); } catch (IOException e) { throw new RuntimeException(""Cannot close input stream: "" + e.toString(), e); }   } finally { if (out != null)
/*     */             try { out.close(); }
/*     */             catch (IOException e) { throw new RuntimeException(""Cannot close output stream: "" + e.toString(), e); }
/*     */               }
/*     */          }
/*     */        }
/*     */      } public IndexOutput createOutput(String name) throws IOException { File file = new File(this.directory, name); if (file.exists() && !file.delete())
/*     */       throw new IOException(""Cannot overwrite: "" + file);  return new FSIndexOutput(file); } public IndexInput openInput(String name) throws IOException { return new FSIndexInput(new File(this.directory, name)); } public IndexInput openInput(String name, int bufferSize) throws IOException { return new FSIndexInput(new File(this.directory, name), bufferSize); } public String getLockID() { // Byte code:
/*     */     //   0: aload_0
/*     */     //   1: getfield directory : Ljava/io/File;
/*     */     //   4: invokevirtual getCanonicalPath : ()Ljava/lang/String;
/*     */     //   7: astore_1
/*     */     //   8: goto -> 25
/*     */     //   11: astore_2
/*     */     //   12: new java/lang/RuntimeException
/*     */     //   15: dup
/*     */     //   16: aload_2
/*     */     //   17: invokevirtual toString : ()Ljava/lang/String;
/*     */     //   20: aload_2
/*     */     //   21: invokespecial <init> : (Ljava/lang/String;Ljava/lang/Throwable;)V
/*     */     //   24: athrow
/*     */     //   25: getstatic org/apache/lucene/store/FSDirectory.DIGESTER : Ljava/security/MessageDigest;
/*     */     //   28: dup
/*     */     //   29: astore_3
/*     */     //   30: monitorenter
/*     */     //   31: getstatic org/apache/lucene/store/FSDirectory.DIGESTER : Ljava/security/MessageDigest;
/*     */     //   34: aload_1
/*     */     //   35: invokevirtual getBytes : ()[B
/*     */     //   38: invokevirtual digest : ([B)[B
/*     */     //   41: astore_2
/*     */     //   42: aload_3
/*     */     //   43: monitorexit
/*     */     //   44: goto -> 54
/*     */     //   47: astore #4
/*     */     //   49: aload_3
/*     */     //   50: monitorexit
/*     */     //   51: aload #4
/*     */     //   53: athrow
/*     */     //   54: new java/lang/StringBuffer
/*     */     //   57: dup
/*     */     //   58: invokespecial <init> : ()V
/*     */     //   61: astore_3
/*     */     //   62: aload_3
/*     */     //   63: ldc 'lucene-'
/*     */     //   65: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
/*     */     //   68: pop
/*     */     //   69: iconst_0
/*     */     //   70: istore #4
/*     */     //   72: iload #4
/*     */     //   74: aload_2
/*     */     //   75: arraylength
/*     */     //   76: if_icmpge -> 121
/*     */     //   79: aload_2
/*     */     //   80: iload #4
/*     */     //   82: baload
/*     */     //   83: istore #5
/*     */     //   85: aload_3
/*     */     //   86: getstatic org/apache/lucene/store/FSDirectory.HEX_DIGITS : [C
/*     */     //   89: iload #5
/*     */     //   91: iconst_4
/*     */     //   92: ishr
/*     */     //   93: bipush #15
/*     */     //   95: iand
/*     */     //   96: caload
/*     */     //   97: invokevirtual append : (C)Ljava/lang/StringBuffer;
/*     */     //   100: pop
/*     */     //   101: aload_3
/*     */     //   102: getstatic org/apache/lucene/store/FSDirectory.HEX_DIGITS : [C
/*     */     //   105: iload #5
/*     */     //   107: bipush #15
/*     */     //   109: iand
/*     */     //   110: caload
/*     */     //   111: invokevirtual append : (C)Ljava/lang/StringBuffer;
/*     */     //   114: pop
/*     */     //   115: iinc #4, 1
/*     */     //   118: goto -> 72
/*     */     //   121: aload_3
/*     */     //   122: invokevirtual toString : ()Ljava/lang/String;
/*     */     //   125: areturn
/*     */     // Line number table:
/*     */     //   Java source line number -> byte code offset
/*     */     //   #458	-> 0
/*     */     //   #461	-> 8
/*     */     //   #459	-> 11
/*     */     //   #460	-> 12
/*     */     //   #464	-> 25
/*     */     //   #465	-> 31
/*     */     //   #466	-> 42
/*     */     //   #467	-> 54
/*     */     //   #468	-> 62
/*     */     //   #469	-> 69
/*     */     //   #470	-> 79
/*     */     //   #471	-> 85
/*     */     //   #472	-> 101
/*     */     //   #469	-> 115
/*     */     //   #475	-> 121
/*     */     // Local variable table:
/*     */     //   start	length	slot	name	descriptor
/*     */     //   12	13	2	e	Ljava/io/IOException;
/*     */     //   85	30	5	b	I
/*     */     //   72	49	4	i	I
/*     */     //   0	126	0	this	Lorg/apache/lucene/store/FSDirectory;
/*     */     //   8	118	1	dirName	Ljava/lang/String;
/*     */     //   42	84	2	digest	[B
/*     */     //   62	64	3	buf	Ljava/lang/StringBuffer;
/*     */     // Exception table:
/*     */     //   from	to	target	type
/*     */     //   0	8	11	java/io/IOException
/*     */     //   31	44	47	finally
/*     */     //   47	51	47	finally } protected static class FSIndexInput extends BufferedIndexInput {
/*     */     private final Descriptor file; boolean isClone; private static class Descriptor extends RandomAccessFile {
/* 506 */       private boolean isOpen; long position; final long length; public Descriptor(File file, String mode) throws IOException { super(file, mode);
/* 507 */         this.isOpen = true;
/* 508 */         this.length = length(); }
/*     */ 
/*     */       
/*     */       public void close() throws IOException {
/* 512 */         if (this.isOpen) {
/* 513 */           this.isOpen = false;
/* 514 */           super.close();
/*     */         } 
/*     */       }
/*     */       
/*     */       protected void finalize() throws Throwable {
/*     */         try {
/* 520 */           close();
/*     */         } finally {
/* 522 */           super.finalize();
/*     */         } 
/*     */       }
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 531 */     public FSIndexInput(File path) throws IOException { this(path, 1024); }
/*     */ 
/*     */     
/*     */     public FSIndexInput(File path, int bufferSize) throws IOException {
/* 535 */       super(bufferSize);
/* 536 */       this.file = new Descriptor(path, ""r"");
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     protected void readInternal(byte[] b, int offset, int len) throws IOException {
/* 542 */       synchronized (this.file) {
/* 543 */         long position = getFilePointer();
/* 544 */         if (position != this.file.position) {
/* 545 */           this.file.seek(position);
/* 546 */           this.file.position = position;
/*     */         } 
/* 548 */         int total = 0;
/*     */         do {
/* 550 */           int i = this.file.read(b, offset + total, len - total);
/* 551 */           if (i == -1)
/* 552 */             throw new IOException(""read past EOF""); 
/* 553 */           this.file.position += i;
/* 554 */           total += i;
/* 555 */         } while (total < len);
/*     */       } 
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 561 */     public void close() throws IOException { if (!this.isClone) this.file.close();
/*     */        }
/*     */ 
/*     */     
/*     */     protected void seekInternal(long position) {}
/*     */ 
/*     */     
/* 568 */     public long length() { return this.file.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/* 572 */       FSIndexInput clone = (FSIndexInput)super.clone();
/* 573 */       clone.isClone = true;
/* 574 */       return clone;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/* 581 */     boolean isFDValid() throws IOException { return this.file.getFD().valid(); }
/*     */   }
/*     */   
/*     */   protected static class FSIndexOutput
/*     */     extends BufferedIndexOutput {
/* 586 */     RandomAccessFile file = null;
/*     */ 
/*     */     
/*     */     private boolean isOpen;
/*     */ 
/*     */     
/*     */     public FSIndexOutput(File path) throws IOException {
/* 593 */       this.file = new RandomAccessFile(path, ""rw"");
/* 594 */       this.isOpen = true;
/*     */     }
/*     */ 
/*     */ 
/*     */     
/* 599 */     public void flushBuffer(byte[] b, int offset, int size) throws IOException { this.file.write(b, offset, size); }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {
/* 603 */       if (this.isOpen) {
/* 604 */         super.close();
/* 605 */         this.file.close();
/* 606 */         this.isOpen = false;
/*     */       } 
/*     */     }
/*     */ 
/*     */     
/*     */     public void seek(long pos) throws IOException {
/* 612 */       super.seek(pos);
/* 613 */       this.file.seek(pos);
/*     */     }
/*     */     
/* 616 */     public long length() throws IOException { return this.file.length(); }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\FSDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.IndexInput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexInput
/*     */   implements Cloneable
/*     */ {
/*     */   private char[] chars;
/*     */   
/*     */   public abstract byte readByte() throws IOException;
/*     */   
/*     */   public abstract void readBytes(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */   
/*  47 */   public int readInt() throws IOException { return (readByte() & 0xFF) << 24 | (readByte() & 0xFF) << 16 | (readByte() & 0xFF) << 8 | readByte() & 0xFF; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public int readVInt() throws IOException {
/*  57 */     byte b = readByte();
/*  58 */     int i = b & Byte.MAX_VALUE;
/*  59 */     for (int shift = 7; (b & 0x80) != 0; shift += 7) {
/*  60 */       b = readByte();
/*  61 */       i |= (b & Byte.MAX_VALUE) << shift;
/*     */     } 
/*  63 */     return i;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  70 */   public long readLong() throws IOException { return readInt() << 32L | readInt() & 0xFFFFFFFFL; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public long readVLong() throws IOException {
/*  77 */     byte b = readByte();
/*  78 */     long i = (b & Byte.MAX_VALUE);
/*  79 */     for (int shift = 7; (b & 0x80) != 0; shift += 7) {
/*  80 */       b = readByte();
/*  81 */       i |= (b & 0x7FL) << shift;
/*     */     } 
/*  83 */     return i;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public String readString() throws IOException {
/*  90 */     int length = readVInt();
/*  91 */     if (this.chars == null || length > this.chars.length)
/*  92 */       this.chars = new char[length]; 
/*  93 */     readChars(this.chars, 0, length);
/*  94 */     return new String(this.chars, 0, length);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void readChars(char[] buffer, int start, int length) throws IOException {
/* 105 */     int end = start + length;
/* 106 */     for (int i = start; i < end; i++) {
/* 107 */       byte b = readByte();
/* 108 */       if ((b & 0x80) == 0) {
/* 109 */         buffer[i] = (char)(b & Byte.MAX_VALUE);
/* 110 */       } else if ((b & 0xE0) != 224) {
/* 111 */         buffer[i] = (char)((b & 0x1F) << 6 | readByte() & 0x3F);
/*     */       } else {
/*     */         
/* 114 */         buffer[i] = (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | readByte() & 0x3F);
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void skipChars(int length) throws IOException {
/* 130 */     for (int i = 0; i < length; i++) {
/* 131 */       byte b = readByte();
/* 132 */       if ((b & 0x80) != 0)
/*     */       {
/*     */         
/* 135 */         if ((b & 0xE0) != 224) {
/* 136 */           readByte();
/*     */         } else {
/*     */           
/* 139 */           readByte();
/* 140 */           readByte();
/*     */         } 
/*     */       }
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract long getFilePointer();
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void seek(long paramLong) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract long length();
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public Object clone() {
/* 173 */     IndexInput clone = null;
/*     */     try {
/* 175 */       clone = (IndexInput)super.clone();
/* 176 */     } catch (CloneNotSupportedException e) {}
/*     */     
/* 178 */     clone.chars = null;
/*     */     
/* 180 */     return clone;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\IndexInput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.IndexOutput,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class IndexOutput
/*     */ {
/*     */   public abstract void writeByte(byte paramByte) throws IOException;
/*     */   
/*  40 */   public void writeBytes(byte[] b, int length) throws IOException { writeBytes(b, 0, length); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void writeBytes(byte[] paramArrayOfbyte, int paramInt1, int paramInt2) throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeInt(int i) throws IOException {
/*  55 */     writeByte((byte)(i >> 24));
/*  56 */     writeByte((byte)(i >> 16));
/*  57 */     writeByte((byte)(i >> 8));
/*  58 */     writeByte((byte)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeVInt(int i) throws IOException {
/*  67 */     while ((i & 0xFFFFFF80) != 0) {
/*  68 */       writeByte((byte)(i & 0x7F | 0x80));
/*  69 */       i >>>= 7;
/*     */     } 
/*  71 */     writeByte((byte)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeLong(long i) throws IOException {
/*  78 */     writeInt((int)(i >> 32L));
/*  79 */     writeInt((int)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeVLong(long i) throws IOException {
/*  88 */     while ((i & 0xFFFFFFFFFFFFFF80L) != 0L) {
/*  89 */       writeByte((byte)(int)(i & 0x7FL | 0x80L));
/*  90 */       i >>>= 7L;
/*     */     } 
/*  92 */     writeByte((byte)(int)i);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeString(String s) throws IOException {
/*  99 */     int length = s.length();
/* 100 */     writeVInt(length);
/* 101 */     writeChars(s, 0, length);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void writeChars(String s, int start, int length) throws IOException {
/* 112 */     int end = start + length;
/* 113 */     for (int i = start; i < end; i++) {
/* 114 */       int code = s.charAt(i);
/* 115 */       if (code >= 1 && code <= 127) {
/* 116 */         writeByte((byte)code);
/* 117 */       } else if ((code >= 128 && code <= 2047) || code == 0) {
/* 118 */         writeByte((byte)(0xC0 | code >> 6));
/* 119 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } else {
/* 121 */         writeByte((byte)(0xE0 | code >>> 12));
/* 122 */         writeByte((byte)(0x80 | code >> 6 & 0x3F));
/* 123 */         writeByte((byte)(0x80 | code & 0x3F));
/*     */       } 
/*     */     } 
/*     */   }
/*     */   
/*     */   public abstract void flush() throws IOException;
/*     */   
/*     */   public abstract void close() throws IOException;
/*     */   
/*     */   public abstract long getFilePointer();
/*     */   
/*     */   public abstract void seek(long paramLong) throws IOException;
/*     */   
/*     */   public abstract long length() throws IOException;
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\IndexOutput.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.Lock,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class Lock
/*     */ {
/*  36 */   public static long LOCK_POLL_INTERVAL = 1000L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected Throwable failureReason;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract boolean obtain() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {
/*  60 */     this.failureReason = null;
/*  61 */     boolean locked = obtain();
/*  62 */     int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);
/*  63 */     int sleepCount = 0;
/*  64 */     while (!locked) {
/*  65 */       if (sleepCount++ == maxSleepCount) {
/*  66 */         String reason = ""Lock obtain timed out: "" + toString();
/*  67 */         if (this.failureReason != null) {
/*  68 */           reason = reason + "": "" + this.failureReason;
/*     */         }
/*  70 */         LockObtainFailedException e = new LockObtainFailedException(reason);
/*  71 */         if (this.failureReason != null) {
/*  72 */           e.initCause(this.failureReason);
/*     */         }
/*  74 */         throw e;
/*     */       } 
/*     */       try {
/*  77 */         Thread.sleep(LOCK_POLL_INTERVAL);
/*  78 */       } catch (InterruptedException e) {
/*  79 */         throw new IOException(e.toString());
/*     */       } 
/*  81 */       locked = obtain();
/*     */     } 
/*  83 */     return locked;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public abstract void release();
/*     */ 
/*     */   
/*     */   public abstract boolean isLocked();
/*     */ 
/*     */   
/*     */   public static abstract class With
/*     */   {
/*     */     private Lock lock;
/*     */     
/*     */     private long lockWaitTimeout;
/*     */ 
/*     */     
/*     */     public With(Lock lock, long lockWaitTimeout) {
/* 102 */       this.lock = lock;
/* 103 */       this.lockWaitTimeout = lockWaitTimeout;
/*     */     }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     protected abstract Object doBody() throws IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     public Object run() throws LockObtainFailedException, IOException {
/* 118 */       boolean locked = false;
/*     */       try {
/* 120 */         locked = this.lock.obtain(this.lockWaitTimeout);
/* 121 */         return doBody();
/*     */       } finally {
/* 123 */         if (locked)
/* 124 */           this.lock.release(); 
/*     */       } 
/*     */     }
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\Lock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.LockFactory,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class LockFactory
/*    */ {
/* 29 */   protected String lockPrefix = """";
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 42 */   public void setLockPrefix(String lockPrefix) { this.lockPrefix = lockPrefix; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 49 */   public String getLockPrefix() { return this.lockPrefix; }
/*    */   
/*    */   public abstract Lock makeLock(String paramString);
/*    */   
/*    */   public abstract void clearLock(String paramString) throws IOException;
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\LockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.LockObtainFailedException,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class LockObtainFailedException
/*    */   extends IOException
/*    */ {
/* 31 */   public LockObtainFailedException(String message) { super(message); }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\LockObtainFailedException.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.MMapDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.nio.ByteBuffer;
/*     */ import java.nio.channels.FileChannel;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class MMapDirectory
/*     */   extends FSDirectory
/*     */ {
/*     */   private static class MMapIndexInput
/*     */     extends IndexInput
/*     */   {
/*     */     private ByteBuffer buffer;
/*     */     private final long length;
/*     */     
/*     */     private MMapIndexInput(RandomAccessFile raf) throws IOException {
/*  42 */       this.length = raf.length();
/*  43 */       this.buffer = raf.getChannel().map(FileChannel.MapMode.READ_ONLY, 0L, this.length);
/*     */     }
/*     */ 
/*     */     
/*  47 */     public byte readByte() throws IOException { return this.buffer.get(); }
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*  52 */     public void readBytes(byte[] b, int offset, int len) throws IOException { this.buffer.get(b, offset, len); }
/*     */ 
/*     */ 
/*     */     
/*  56 */     public long getFilePointer() { return this.buffer.position(); }
/*     */ 
/*     */ 
/*     */     
/*  60 */     public void seek(long pos) throws IOException { this.buffer.position((int)pos); }
/*     */ 
/*     */ 
/*     */     
/*  64 */     public long length() { return this.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/*  68 */       MMapIndexInput clone = (MMapIndexInput)super.clone();
/*  69 */       clone.buffer = this.buffer.duplicate();
/*  70 */       return clone;
/*     */     }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {}
/*     */   }
/*     */ 
/*     */   
/*     */   private static class MultiMMapIndexInput
/*     */     extends IndexInput
/*     */   {
/*     */     private ByteBuffer[] buffers;
/*     */     
/*     */     private int[] bufSizes;
/*     */     
/*     */     private final long length;
/*     */     private int curBufIndex;
/*     */     private final int maxBufSize;
/*     */     private ByteBuffer curBuf;
/*     */     private int curAvail;
/*     */     
/*     */     public MultiMMapIndexInput(RandomAccessFile raf, int maxBufSize) throws IOException {
/*  92 */       this.length = raf.length();
/*  93 */       this.maxBufSize = maxBufSize;
/*     */       
/*  95 */       if (maxBufSize <= 0) {
/*  96 */         throw new IllegalArgumentException(""Non positive maxBufSize: "" + maxBufSize);
/*     */       }
/*     */       
/*  99 */       if (this.length / maxBufSize > 2147483647L) {
/* 100 */         throw new IllegalArgumentException(""RandomAccessFile too big for maximum buffer size: "" + raf.toString());
/*     */       }
/*     */ 
/*     */       
/* 104 */       int nrBuffers = (int)(this.length / maxBufSize);
/* 105 */       if ((nrBuffers * maxBufSize) < this.length) nrBuffers++;
/*     */       
/* 107 */       this.buffers = new ByteBuffer[nrBuffers];
/* 108 */       this.bufSizes = new int[nrBuffers];
/*     */       
/* 110 */       long bufferStart = 0L;
/* 111 */       FileChannel rafc = raf.getChannel();
/* 112 */       for (int bufNr = 0; bufNr < nrBuffers; bufNr++) {
/* 113 */         int bufSize = (this.length > bufferStart + maxBufSize) ? maxBufSize : (int)(this.length - bufferStart);
/*     */ 
/*     */         
/* 116 */         this.buffers[bufNr] = rafc.map(FileChannel.MapMode.READ_ONLY, bufferStart, bufSize);
/* 117 */         this.bufSizes[bufNr] = bufSize;
/* 118 */         bufferStart += bufSize;
/*     */       } 
/* 120 */       seek(0L);
/*     */     }
/*     */ 
/*     */ 
/*     */     
/*     */     public byte readByte() throws IOException {
/* 126 */       if (this.curAvail == 0) {
/* 127 */         this.curBufIndex++;
/* 128 */         this.curBuf = this.buffers[this.curBufIndex];
/* 129 */         this.curBuf.position(0);
/* 130 */         this.curAvail = this.bufSizes[this.curBufIndex];
/*     */       } 
/* 132 */       this.curAvail--;
/* 133 */       return this.curBuf.get();
/*     */     }
/*     */     
/*     */     public void readBytes(byte[] b, int offset, int len) throws IOException {
/* 137 */       while (len > this.curAvail) {
/* 138 */         this.curBuf.get(b, offset, this.curAvail);
/* 139 */         len -= this.curAvail;
/* 140 */         offset += this.curAvail;
/* 141 */         this.curBufIndex++;
/* 142 */         this.curBuf = this.buffers[this.curBufIndex];
/* 143 */         this.curBuf.position(0);
/* 144 */         this.curAvail = this.bufSizes[this.curBufIndex];
/*     */       } 
/* 146 */       this.curBuf.get(b, offset, len);
/* 147 */       this.curAvail -= len;
/*     */     }
/*     */ 
/*     */     
/* 151 */     public long getFilePointer() { return this.curBufIndex * this.maxBufSize + this.curBuf.position(); }
/*     */ 
/*     */     
/*     */     public void seek(long pos) throws IOException {
/* 155 */       this.curBufIndex = (int)(pos / this.maxBufSize);
/* 156 */       this.curBuf = this.buffers[this.curBufIndex];
/* 157 */       int bufOffset = (int)(pos - (this.curBufIndex * this.maxBufSize));
/* 158 */       this.curBuf.position(bufOffset);
/* 159 */       this.curAvail = this.bufSizes[this.curBufIndex] - bufOffset;
/*     */     }
/*     */ 
/*     */     
/* 163 */     public long length() { return this.length; }
/*     */ 
/*     */     
/*     */     public Object clone() {
/* 167 */       MultiMMapIndexInput clone = (MultiMMapIndexInput)super.clone();
/* 168 */       clone.buffers = new ByteBuffer[this.buffers.length];
/*     */ 
/*     */ 
/*     */       
/* 172 */       for (int bufNr = 0; bufNr < this.buffers.length; bufNr++) {
/* 173 */         clone.buffers[bufNr] = this.buffers[bufNr].duplicate();
/*     */       }
/*     */       try {
/* 176 */         clone.seek(getFilePointer());
/* 177 */       } catch (IOException ioe) {
/* 178 */         RuntimeException newException = new RuntimeException(ioe);
/* 179 */         newException.initCause(ioe);
/* 180 */         throw newException;
/*     */       } 
/* 182 */       return clone;
/*     */     }
/*     */ 
/*     */     
/*     */     public void close() throws IOException {}
/*     */   }
/* 188 */   private final int MAX_BBUF = Integer.MAX_VALUE;
/*     */   
/*     */   public IndexInput openInput(String name) throws IOException {
/* 191 */     File f = new File(getFile(), name);
/* 192 */     RandomAccessFile raf = new RandomAccessFile(f, ""r"");
/*     */     try {
/* 194 */       return (IndexInput)((raf.length() <= 2147483647L) ? new MMapIndexInput(raf) : new MultiMMapIndexInput(raf, 2147483647));
/*     */     }
/*     */     finally {
/*     */       
/* 198 */       raf.close();
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\MMapDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NativeFSLock,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.RandomAccessFile;
/*     */ import java.nio.channels.FileChannel;
/*     */ import java.nio.channels.FileLock;
/*     */ import java.util.HashSet;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class NativeFSLock
/*     */   extends Lock
/*     */ {
/*     */   private RandomAccessFile f;
/*     */   private FileChannel channel;
/*     */   private FileLock lock;
/*     */   private File path;
/*     */   private File lockDir;
/* 184 */   private static HashSet LOCK_HELD = new HashSet();
/*     */   
/*     */   public NativeFSLock(File lockDir, String lockFileName) {
/* 187 */     this.lockDir = lockDir;
/* 188 */     this.path = new File(lockDir, lockFileName);
/*     */   }
/*     */ 
/*     */   
/*     */   public synchronized boolean obtain() throws IOException {
/* 193 */     if (isLocked())
/*     */     {
/* 195 */       return false;
/*     */     }
/*     */ 
/*     */     
/* 199 */     if (!this.lockDir.exists()) {
/* 200 */       if (!this.lockDir.mkdirs()) {
/* 201 */         throw new IOException(""Cannot create directory: "" + this.lockDir.getAbsolutePath());
/*     */       }
/* 203 */     } else if (!this.lockDir.isDirectory()) {
/* 204 */       throw new IOException(""Found regular file where directory expected: "" + this.lockDir.getAbsolutePath());
/*     */     } 
/*     */ 
/*     */     
/* 208 */     String canonicalPath = this.path.getCanonicalPath();
/*     */     
/* 210 */     boolean markedHeld = false;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */     
/*     */     try {
/* 217 */       synchronized (LOCK_HELD) {
/* 218 */         if (LOCK_HELD.contains(canonicalPath))
/*     */         {
/* 220 */           return false;
/*     */         }
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 226 */         LOCK_HELD.add(canonicalPath);
/* 227 */         markedHeld = true;
/*     */       } 
/*     */ 
/*     */       
/*     */       try {
/* 232 */         this.f = new RandomAccessFile(this.path, ""rw"");
/* 233 */       } catch (IOException e) {
/*     */ 
/*     */ 
/*     */ 
/*     */         
/* 238 */         this.failureReason = e;
/* 239 */         this.f = null;
/*     */       } 
/*     */       
/* 242 */       if (this.f != null) {
/*     */         try {
/* 244 */           this.channel = this.f.getChannel();
/*     */           try {
/* 246 */             this.lock = this.channel.tryLock();
/* 247 */           } catch (IOException e) {
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */             
/* 257 */             this.failureReason = e;
/*     */           } finally {
/* 259 */             if (this.lock == null) {
/*     */               try {
/* 261 */                 this.channel.close();
/*     */               } finally {
/* 263 */                 this.channel = null;
/*     */               } 
/*     */             }
/*     */           } 
/*     */         } finally {
/* 268 */           if (this.channel == null) {
/*     */             try {
/* 270 */               this.f.close();
/*     */             } finally {
/* 272 */               this.f = null;
/*     */             } 
/*     */           }
/*     */         } 
/*     */       }
/*     */     } finally {
/*     */       
/* 279 */       if (markedHeld && !isLocked()) {
/* 280 */         synchronized (LOCK_HELD) {
/* 281 */           if (LOCK_HELD.contains(canonicalPath)) {
/* 282 */             LOCK_HELD.remove(canonicalPath);
/*     */           }
/*     */         } 
/*     */       }
/*     */     } 
/* 287 */     return isLocked();
/*     */   }
/*     */   
/*     */   public synchronized void release() {
/*     */     try {
/* 292 */       if (isLocked()) {
/*     */         try {
/* 294 */           this.lock.release();
/*     */         } finally {
/* 296 */           this.lock = null;
/*     */           try {
/* 298 */             this.channel.close();
/*     */           } finally {
/* 300 */             this.channel = null;
/*     */             try {
/* 302 */               this.f.close();
/*     */             } finally {
/* 304 */               this.f = null;
/* 305 */               synchronized (LOCK_HELD) {
/* 306 */                 LOCK_HELD.remove(this.path.getCanonicalPath());
/*     */               } 
/*     */             } 
/*     */           } 
/*     */         } 
/* 311 */         this.path.delete();
/*     */       } 
/* 313 */     } catch (IOException e) {
/*     */ 
/*     */       
/* 316 */       throw new RuntimeException(e);
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/* 321 */   public boolean isLocked() { return (this.lock != null); }
/*     */ 
/*     */ 
/*     */   
/* 325 */   public String toString() { return ""NativeFSLock@"" + this.path; }
/*     */ 
/*     */   
/*     */   public void finalize() throws Throwable {
/*     */     try {
/* 330 */       if (isLocked()) {
/* 331 */         release();
/*     */       }
/*     */     } finally {
/* 334 */       super.finalize();
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\NativeFSLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NativeFSLockFactory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.util.Random;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class NativeFSLockFactory
/*     */   extends LockFactory
/*     */ {
/*     */   private File lockDir;
/*     */   
/*     */   private void acquireTestLock() throws IOException {
/*  75 */     String randomLockName = ""lucene-"" + Long.toString((new Random()).nextInt(), 36) + ""-test.lock"";
/*     */     
/*  77 */     Lock l = makeLock(randomLockName);
/*     */     try {
/*  79 */       l.obtain();
/*  80 */     } catch (IOException e) {
/*  81 */       IOException e2 = new IOException(""Failed to acquire random test lock; please verify filesystem for lock directory '"" + this.lockDir + ""' supports locking"");
/*  82 */       e2.initCause(e);
/*  83 */       throw e2;
/*     */     } 
/*     */     
/*  86 */     l.release();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  97 */   NativeFSLockFactory() throws IOException { this((File)null); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public NativeFSLockFactory(String lockDirName) throws IOException { this(new File(lockDirName)); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 117 */   public NativeFSLockFactory(File lockDir) throws IOException { setLockDir(lockDir); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   void setLockDir(File lockDir) throws IOException {
/* 127 */     this.lockDir = lockDir;
/* 128 */     if (lockDir != null) {
/*     */       
/* 130 */       if (!lockDir.exists()) {
/* 131 */         if (!lockDir.mkdirs()) {
/* 132 */           throw new IOException(""Cannot create directory: "" + lockDir.getAbsolutePath());
/*     */         }
/* 134 */       } else if (!lockDir.isDirectory()) {
/* 135 */         throw new IOException(""Found regular file where directory expected: "" + lockDir.getAbsolutePath());
/*     */       } 
/*     */ 
/*     */       
/* 139 */       acquireTestLock();
/*     */     } 
/*     */   }
/*     */   
/*     */   public synchronized Lock makeLock(String lockName) {
/* 144 */     if (this.lockPrefix != null)
/* 145 */       lockName = this.lockPrefix + ""-n-"" + lockName; 
/* 146 */     return new NativeFSLock(this.lockDir, lockName);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void clearLock(String lockName) throws IOException {
/* 154 */     if (this.lockDir.exists()) {
/* 155 */       if (this.lockPrefix != null) {
/* 156 */         lockName = this.lockPrefix + ""-n-"" + lockName;
/*     */       }
/* 158 */       File lockFile = new File(this.lockDir, lockName);
/* 159 */       if (lockFile.exists() && !lockFile.delete())
/* 160 */         throw new IOException(""Cannot delete "" + lockFile); 
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\NativeFSLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NoLock,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class NoLock
/*    */   extends Lock
/*    */ {
/* 50 */   public boolean obtain() throws IOException { return true; }
/*    */ 
/*    */ 
/*    */   
/*    */   public void release() {}
/*    */ 
/*    */   
/* 57 */   public boolean isLocked() { return false; }
/*    */ 
/*    */ 
/*    */   
/* 61 */   public String toString() { return ""NoLock""; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\NoLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.NoLockFactory,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class NoLockFactory
/*    */   extends LockFactory
/*    */ {
/* 34 */   private static NoLock singletonLock = new NoLock();
/* 35 */   private static NoLockFactory singleton = new NoLockFactory();
/*    */ 
/*    */   
/* 38 */   public static NoLockFactory getNoLockFactory() { return singleton; }
/*    */ 
/*    */ 
/*    */   
/* 42 */   public Lock makeLock(String lockName) { return singletonLock; }
/*    */   
/*    */   public void clearLock(String lockName) {}
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\NoLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMDirectory,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.FileNotFoundException;
/*     */ import java.io.IOException;
/*     */ import java.io.Serializable;
/*     */ import java.util.HashMap;
/*     */ import java.util.Iterator;
/*     */ import java.util.Set;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RAMDirectory
/*     */   extends Directory
/*     */   implements Serializable
/*     */ {
/*     */   private static final long serialVersionUID = 1L;
/*  39 */   HashMap fileMap = new HashMap();
/*  40 */   long sizeInBytes = 0L;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  48 */   public RAMDirectory() { setLockFactory(new SingleInstanceLockFactory()); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  68 */   public RAMDirectory(Directory dir) throws IOException { this(dir, false); }
/*     */ 
/*     */   
/*     */   private RAMDirectory(Directory dir, boolean closeDir) throws IOException {
/*  72 */     this();
/*  73 */     Directory.copy(dir, this, closeDir);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  84 */   public RAMDirectory(File dir) throws IOException { this(FSDirectory.getDirectory(dir), true); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  95 */   public RAMDirectory(String dir) throws IOException { this(FSDirectory.getDirectory(dir), true); }
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized String[] list() {
/* 100 */     ensureOpen();
/* 101 */     Set fileNames = this.fileMap.keySet();
/* 102 */     String[] result = new String[fileNames.size()];
/* 103 */     int i = 0;
/* 104 */     Iterator it = fileNames.iterator();
/* 105 */     while (it.hasNext())
/* 106 */       result[i++] = it.next(); 
/* 107 */     return result;
/*     */   }
/*     */   
/*     */   public final boolean fileExists(String name) {
/*     */     RAMFile file;
/* 112 */     ensureOpen();
/*     */     
/* 114 */     synchronized (this) {
/* 115 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 117 */     return (file != null);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final long fileModified(String name) throws IOException {
/*     */     RAMFile file;
/* 124 */     ensureOpen();
/*     */     
/* 126 */     synchronized (this) {
/* 127 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 129 */     if (file == null)
/* 130 */       throw new FileNotFoundException(name); 
/* 131 */     return file.getLastModified();
/*     */   }
/*     */ 
/*     */   
/*     */   public void touchFile(String name) throws IOException {
/*     */     long ts2;
/*     */     RAMFile file;
/* 138 */     ensureOpen();
/*     */     
/* 140 */     synchronized (this) {
/* 141 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 143 */     if (file == null) {
/* 144 */       throw new FileNotFoundException(name);
/*     */     }
/* 146 */     long ts1 = System.currentTimeMillis();
/*     */     do {
/*     */       try {
/* 149 */         Thread.sleep(0L, 1);
/* 150 */       } catch (InterruptedException e) {}
/* 151 */       ts2 = System.currentTimeMillis();
/* 152 */     } while (ts1 == ts2);
/*     */     
/* 154 */     file.setLastModified(ts2);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final long fileLength(String name) throws IOException {
/*     */     RAMFile file;
/* 161 */     ensureOpen();
/*     */     
/* 163 */     synchronized (this) {
/* 164 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 166 */     if (file == null)
/* 167 */       throw new FileNotFoundException(name); 
/* 168 */     return file.getLength();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized long sizeInBytes() {
/* 175 */     ensureOpen();
/* 176 */     return this.sizeInBytes;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public synchronized void deleteFile(String name) throws IOException {
/* 183 */     ensureOpen();
/* 184 */     RAMFile file = (RAMFile)this.fileMap.get(name);
/* 185 */     if (file != null) {
/* 186 */       this.fileMap.remove(name);
/* 187 */       file.directory = null;
/* 188 */       this.sizeInBytes -= file.sizeInBytes;
/*     */     } else {
/* 190 */       throw new FileNotFoundException(name);
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final synchronized void renameFile(String from, String to) throws IOException {
/* 198 */     ensureOpen();
/* 199 */     RAMFile fromFile = (RAMFile)this.fileMap.get(from);
/* 200 */     if (fromFile == null)
/* 201 */       throw new FileNotFoundException(from); 
/* 202 */     RAMFile toFile = (RAMFile)this.fileMap.get(to);
/* 203 */     if (toFile != null) {
/* 204 */       this.sizeInBytes -= toFile.sizeInBytes;
/* 205 */       toFile.directory = null;
/*     */     } 
/* 207 */     this.fileMap.remove(from);
/* 208 */     this.fileMap.put(to, fromFile);
/*     */   }
/*     */ 
/*     */   
/*     */   public IndexOutput createOutput(String name) {
/* 213 */     ensureOpen();
/* 214 */     RAMFile file = new RAMFile(this);
/* 215 */     synchronized (this) {
/* 216 */       RAMFile existing = (RAMFile)this.fileMap.get(name);
/* 217 */       if (existing != null) {
/* 218 */         this.sizeInBytes -= existing.sizeInBytes;
/* 219 */         existing.directory = null;
/*     */       } 
/* 221 */       this.fileMap.put(name, file);
/*     */     } 
/* 223 */     return new RAMOutputStream(file);
/*     */   }
/*     */   
/*     */   public IndexInput openInput(String name) throws IOException {
/*     */     RAMFile file;
/* 228 */     ensureOpen();
/*     */     
/* 230 */     synchronized (this) {
/* 231 */       file = (RAMFile)this.fileMap.get(name);
/*     */     } 
/* 233 */     if (file == null)
/* 234 */       throw new FileNotFoundException(name); 
/* 235 */     return new RAMInputStream(file);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 240 */   public void close() { this.fileMap = null; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   protected final void ensureOpen() throws AlreadyClosedException {
/* 247 */     if (this.fileMap == null)
/* 248 */       throw new AlreadyClosedException(""this RAMDirectory is closed""); 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\RAMDirectory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMFile,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.Serializable;
/*    */ import java.util.ArrayList;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class RAMFile
/*    */   implements Serializable
/*    */ {
/*    */   private static final long serialVersionUID = 1L;
/* 28 */   ArrayList buffers = new ArrayList();
/*    */   
/*    */   long length;
/*    */   
/*    */   RAMDirectory directory;
/*    */   long sizeInBytes;
/* 34 */   private long lastModified = System.currentTimeMillis();
/*    */ 
/*    */   
/*    */   RAMFile() {}
/*    */ 
/*    */   
/* 40 */   RAMFile(RAMDirectory directory) { this.directory = directory; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 45 */   synchronized long getLength() { return this.length; }
/*    */ 
/*    */ 
/*    */   
/* 49 */   synchronized void setLength(long length) { this.length = length; }
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 54 */   synchronized long getLastModified() { return this.lastModified; }
/*    */ 
/*    */ 
/*    */   
/* 58 */   synchronized void setLastModified(long lastModified) { this.lastModified = lastModified; }
/*    */ 
/*    */ 
/*    */   
/*    */   final byte[] addBuffer(int size) {
/* 63 */     byte[] buffer = new byte[size];
/* 64 */     if (this.directory != null) {
/* 65 */       synchronized (this.directory) {
/* 66 */         this.buffers.add(buffer);
/* 67 */         this.directory.sizeInBytes += size;
/* 68 */         this.sizeInBytes += size;
/*    */       } 
/*    */     } else {
/* 71 */       this.buffers.add(buffer);
/* 72 */     }  return buffer;
/*    */   }
/*    */ 
/*    */   
/*    */   long getSizeInBytes() {
/* 77 */     synchronized (this.directory) {
/* 78 */       return this.sizeInBytes;
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\RAMFile.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMInputStream,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class RAMInputStream
/*     */   extends IndexInput
/*     */   implements Cloneable
/*     */ {
/*     */   static final int BUFFER_SIZE = 1024;
/*     */   private RAMFile file;
/*     */   private long length;
/*     */   private byte[] currentBuffer;
/*     */   private int currentBufferIndex;
/*     */   private int bufferPosition;
/*     */   private long bufferStart;
/*     */   private int bufferLength;
/*     */   
/*     */   public RAMInputStream(RAMFile f) {
/*  42 */     this.file = f;
/*  43 */     this.length = this.file.length;
/*     */ 
/*     */ 
/*     */     
/*  47 */     this.currentBufferIndex = -1;
/*  48 */     this.currentBuffer = null;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public void close() {}
/*     */ 
/*     */   
/*  56 */   public long length() { return this.length; }
/*     */ 
/*     */   
/*     */   public byte readByte() throws IOException {
/*  60 */     if (this.bufferPosition >= this.bufferLength) {
/*  61 */       this.currentBufferIndex++;
/*  62 */       switchCurrentBuffer();
/*     */     } 
/*  64 */     return this.currentBuffer[this.bufferPosition++];
/*     */   }
/*     */   
/*     */   public void readBytes(byte[] b, int offset, int len) throws IOException {
/*  68 */     while (len > 0) {
/*  69 */       if (this.bufferPosition >= this.bufferLength) {
/*  70 */         this.currentBufferIndex++;
/*  71 */         switchCurrentBuffer();
/*     */       } 
/*     */       
/*  74 */       int remainInBuffer = this.bufferLength - this.bufferPosition;
/*  75 */       int bytesToCopy = (len < remainInBuffer) ? len : remainInBuffer;
/*  76 */       System.arraycopy(this.currentBuffer, this.bufferPosition, b, offset, bytesToCopy);
/*  77 */       offset += bytesToCopy;
/*  78 */       len -= bytesToCopy;
/*  79 */       this.bufferPosition += bytesToCopy;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void switchCurrentBuffer() throws IOException {
/*  84 */     if (this.currentBufferIndex >= this.file.buffers.size())
/*     */     {
/*  86 */       throw new IOException(""Read past EOF"");
/*     */     }
/*  88 */     this.currentBuffer = this.file.buffers.get(this.currentBufferIndex);
/*  89 */     this.bufferPosition = 0;
/*  90 */     this.bufferStart = (1024 * this.currentBufferIndex);
/*  91 */     this.bufferLength = (int)(this.length - this.bufferStart);
/*  92 */     if (this.bufferLength > 1024) {
/*  93 */       this.bufferLength = 1024;
/*     */     }
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*  99 */   public long getFilePointer() { return (this.currentBufferIndex < 0) ? 0L : (this.bufferStart + this.bufferPosition); }
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/* 103 */     long bufferStart = (this.currentBufferIndex * 1024);
/* 104 */     if (pos < bufferStart || pos >= bufferStart + 1024L) {
/* 105 */       this.currentBufferIndex = (int)(pos / 1024L);
/* 106 */       switchCurrentBuffer();
/*     */     } 
/* 108 */     this.bufferPosition = (int)(pos % 1024L);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\RAMInputStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.RAMOutputStream,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class RAMOutputStream
/*     */   extends IndexOutput
/*     */ {
/*     */   static final int BUFFER_SIZE = 1024;
/*     */   private RAMFile file;
/*     */   private byte[] currentBuffer;
/*     */   private int currentBufferIndex;
/*     */   private int bufferPosition;
/*     */   private long bufferStart;
/*     */   private int bufferLength;
/*     */   
/*  42 */   public RAMOutputStream() { this(new RAMFile()); }
/*     */ 
/*     */   
/*     */   RAMOutputStream(RAMFile f) {
/*  46 */     this.file = f;
/*     */ 
/*     */ 
/*     */     
/*  50 */     this.currentBufferIndex = -1;
/*  51 */     this.currentBuffer = null;
/*     */   }
/*     */ 
/*     */   
/*     */   public void writeTo(IndexOutput out) throws IOException {
/*  56 */     flush();
/*  57 */     long end = this.file.length;
/*  58 */     long pos = 0L;
/*  59 */     int buffer = 0;
/*  60 */     while (pos < end) {
/*  61 */       int length = 1024;
/*  62 */       long nextPos = pos + length;
/*  63 */       if (nextPos > end) {
/*  64 */         length = (int)(end - pos);
/*     */       }
/*  66 */       out.writeBytes(this.file.buffers.get(buffer++), length);
/*  67 */       pos = nextPos;
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   public void reset() {
/*     */     try {
/*  74 */       seek(0L);
/*  75 */     } catch (IOException e) {
/*  76 */       throw new RuntimeException(e.toString());
/*     */     } 
/*     */     
/*  79 */     this.file.setLength(0L);
/*     */   }
/*     */ 
/*     */   
/*  83 */   public void close() throws IOException { flush(); }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public void seek(long pos) throws IOException {
/*  89 */     setFileLength();
/*  90 */     if (pos < this.bufferStart || pos >= this.bufferStart + this.bufferLength) {
/*  91 */       this.currentBufferIndex = (int)(pos / 1024L);
/*  92 */       switchCurrentBuffer();
/*     */     } 
/*     */     
/*  95 */     this.bufferPosition = (int)(pos % 1024L);
/*     */   }
/*     */ 
/*     */   
/*  99 */   public long length() { return this.file.length; }
/*     */ 
/*     */   
/*     */   public void writeByte(byte b) throws IOException {
/* 103 */     if (this.bufferPosition == this.bufferLength) {
/* 104 */       this.currentBufferIndex++;
/* 105 */       switchCurrentBuffer();
/*     */     } 
/* 107 */     this.currentBuffer[this.bufferPosition++] = b;
/*     */   }
/*     */   
/*     */   public void writeBytes(byte[] b, int offset, int len) throws IOException {
/* 111 */     while (len > 0) {
/* 112 */       if (this.bufferPosition == this.bufferLength) {
/* 113 */         this.currentBufferIndex++;
/* 114 */         switchCurrentBuffer();
/*     */       } 
/*     */       
/* 117 */       int remainInBuffer = this.currentBuffer.length - this.bufferPosition;
/* 118 */       int bytesToCopy = (len < remainInBuffer) ? len : remainInBuffer;
/* 119 */       System.arraycopy(b, offset, this.currentBuffer, this.bufferPosition, bytesToCopy);
/* 120 */       offset += bytesToCopy;
/* 121 */       len -= bytesToCopy;
/* 122 */       this.bufferPosition += bytesToCopy;
/*     */     } 
/*     */   }
/*     */   
/*     */   private final void switchCurrentBuffer() throws IOException {
/* 127 */     if (this.currentBufferIndex == this.file.buffers.size()) {
/* 128 */       this.currentBuffer = this.file.addBuffer(1024);
/*     */     } else {
/* 130 */       this.currentBuffer = this.file.buffers.get(this.currentBufferIndex);
/*     */     } 
/* 132 */     this.bufferPosition = 0;
/* 133 */     this.bufferStart = (1024 * this.currentBufferIndex);
/* 134 */     this.bufferLength = this.currentBuffer.length;
/*     */   }
/*     */   
/*     */   private void setFileLength() {
/* 138 */     long pointer = this.bufferStart + this.bufferPosition;
/* 139 */     if (pointer > this.file.length) {
/* 140 */       this.file.setLength(pointer);
/*     */     }
/*     */   }
/*     */   
/*     */   public void flush() throws IOException {
/* 145 */     this.file.setLastModified(System.currentTimeMillis());
/* 146 */     setFileLength();
/*     */   }
/*     */ 
/*     */   
/* 150 */   public long getFilePointer() { return (this.currentBufferIndex < 0) ? 0L : (this.bufferStart + this.bufferPosition); }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\RAMOutputStream.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SimpleFSLock,"/*     */ package org.apache.lucene.store;
/*     */ 
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ class SimpleFSLock
/*     */   extends Lock
/*     */ {
/*     */   File lockFile;
/*     */   File lockDir;
/*     */   
/*     */   public SimpleFSLock(File lockDir, String lockFileName) {
/* 107 */     this.lockDir = lockDir;
/* 108 */     this.lockFile = new File(lockDir, lockFileName);
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean obtain() throws IOException {
/* 114 */     if (!this.lockDir.exists()) {
/* 115 */       if (!this.lockDir.mkdirs()) {
/* 116 */         throw new IOException(""Cannot create directory: "" + this.lockDir.getAbsolutePath());
/*     */       }
/* 118 */     } else if (!this.lockDir.isDirectory()) {
/* 119 */       throw new IOException(""Found regular file where directory expected: "" + this.lockDir.getAbsolutePath());
/*     */     } 
/*     */     
/* 122 */     return this.lockFile.createNewFile();
/*     */   }
/*     */ 
/*     */   
/* 126 */   public void release() { this.lockFile.delete(); }
/*     */ 
/*     */ 
/*     */   
/* 130 */   public boolean isLocked() { return this.lockFile.exists(); }
/*     */ 
/*     */ 
/*     */   
/* 134 */   public String toString() { return ""SimpleFSLock@"" + this.lockFile; }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\SimpleFSLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SimpleFSLockFactory,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.File;
/*    */ import java.io.IOException;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SimpleFSLockFactory
/*    */   extends LockFactory
/*    */ {
/*    */   private File lockDir;
/*    */   
/* 51 */   SimpleFSLockFactory() throws IOException { this((File)null); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 59 */   public SimpleFSLockFactory(File lockDir) throws IOException { setLockDir(lockDir); }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   public SimpleFSLockFactory(String lockDirName) throws IOException {
/* 67 */     this.lockDir = new File(lockDirName);
/* 68 */     setLockDir(this.lockDir);
/*    */   }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 78 */   void setLockDir(File lockDir) throws IOException { this.lockDir = lockDir; }
/*    */ 
/*    */   
/*    */   public Lock makeLock(String lockName) {
/* 82 */     if (this.lockPrefix != null) {
/* 83 */       lockName = this.lockPrefix + ""-"" + lockName;
/*    */     }
/* 85 */     return new SimpleFSLock(this.lockDir, lockName);
/*    */   }
/*    */   
/*    */   public void clearLock(String lockName) throws IOException {
/* 89 */     if (this.lockDir.exists()) {
/* 90 */       if (this.lockPrefix != null) {
/* 91 */         lockName = this.lockPrefix + ""-"" + lockName;
/*    */       }
/* 93 */       File lockFile = new File(this.lockDir, lockName);
/* 94 */       if (lockFile.exists() && !lockFile.delete())
/* 95 */         throw new IOException(""Cannot delete "" + lockFile); 
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\SimpleFSLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SingleInstanceLock,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.HashSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ class SingleInstanceLock
/*    */   extends Lock
/*    */ {
/*    */   String lockName;
/*    */   private HashSet locks;
/*    */   
/*    */   public SingleInstanceLock(HashSet locks, String lockName) {
/* 61 */     this.locks = locks;
/* 62 */     this.lockName = lockName;
/*    */   }
/*    */   
/*    */   public boolean obtain() throws IOException {
/* 66 */     synchronized (this.locks) {
/* 67 */       return this.locks.add(this.lockName);
/*    */     } 
/*    */   }
/*    */   
/*    */   public void release() {
/* 72 */     synchronized (this.locks) {
/* 73 */       this.locks.remove(this.lockName);
/*    */     } 
/*    */   }
/*    */   
/*    */   public boolean isLocked() {
/* 78 */     synchronized (this.locks) {
/* 79 */       return this.locks.contains(this.lockName);
/*    */     } 
/*    */   }
/*    */ 
/*    */   
/* 84 */   public String toString() { return ""SingleInstanceLock: "" + this.lockName; }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\SingleInstanceLock.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.store.SingleInstanceLockFactory,"/*    */ package org.apache.lucene.store;
/*    */ 
/*    */ import java.io.IOException;
/*    */ import java.util.HashSet;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class SingleInstanceLockFactory
/*    */   extends LockFactory
/*    */ {
/* 37 */   private HashSet locks = new HashSet();
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/* 43 */   public Lock makeLock(String lockName) { return new SingleInstanceLock(this.locks, lockName); }
/*    */ 
/*    */   
/*    */   public void clearLock(String lockName) throws IOException {
/* 47 */     synchronized (this.locks) {
/* 48 */       if (this.locks.contains(lockName))
/* 49 */         this.locks.remove(lockName); 
/*    */     } 
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucene\store\SingleInstanceLockFactory.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.BitVector,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.store.Directory;
/*     */ import org.apache.lucene.store.IndexInput;
/*     */ import org.apache.lucene.store.IndexOutput;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public final class BitVector
/*     */ {
/*     */   private byte[] bits;
/*     */   private int size;
/*  42 */   private int count = -1;
/*     */ 
/*     */   
/*     */   public BitVector(int n) {
/*  46 */     this.size = n;
/*  47 */     this.bits = new byte[(this.size >> 3) + 1];
/*     */   }
/*     */ 
/*     */   
/*     */   public final void set(int bit) {
/*  52 */     if (bit >= this.size) {
/*  53 */       throw new ArrayIndexOutOfBoundsException(bit);
/*     */     }
/*  55 */     this.bits[bit >> 3] = (byte)(this.bits[bit >> 3] | 1 << (bit & 0x7));
/*  56 */     this.count = -1;
/*     */   }
/*     */ 
/*     */   
/*     */   public final void clear(int bit) {
/*  61 */     if (bit >= this.size) {
/*  62 */       throw new ArrayIndexOutOfBoundsException(bit);
/*     */     }
/*  64 */     this.bits[bit >> 3] = (byte)(this.bits[bit >> 3] & (1 << (bit & 0x7) ^ 0xFFFFFFFF));
/*  65 */     this.count = -1;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final boolean get(int bit) {
/*  71 */     if (bit >= this.size) {
/*  72 */       throw new ArrayIndexOutOfBoundsException(bit);
/*     */     }
/*  74 */     return ((this.bits[bit >> 3] & 1 << (bit & 0x7)) != 0);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  80 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final int count() {
/*  88 */     if (this.count == -1) {
/*  89 */       int c = 0;
/*  90 */       int end = this.bits.length;
/*  91 */       for (int i = 0; i < end; i++)
/*  92 */         c += BYTE_COUNTS[this.bits[i] & 0xFF]; 
/*  93 */       this.count = c;
/*     */     } 
/*  95 */     return this.count;
/*     */   }
/*     */   
/*  98 */   private static final byte[] BYTE_COUNTS = new byte[] { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 };
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void write(Directory d, String name) throws IOException {
/* 122 */     IndexOutput output = d.createOutput(name);
/*     */     try {
/* 124 */       if (isSparse()) {
/* 125 */         writeDgaps(output);
/*     */       } else {
/* 127 */         writeBits(output);
/*     */       } 
/*     */     } finally {
/* 130 */       output.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void writeBits(IndexOutput output) throws IOException {
/* 136 */     output.writeInt(size());
/* 137 */     output.writeInt(count());
/* 138 */     output.writeBytes(this.bits, this.bits.length);
/*     */   }
/*     */ 
/*     */   
/*     */   private void writeDgaps(IndexOutput output) throws IOException {
/* 143 */     output.writeInt(-1);
/* 144 */     output.writeInt(size());
/* 145 */     output.writeInt(count());
/* 146 */     int last = 0;
/* 147 */     int n = count();
/* 148 */     int m = this.bits.length;
/* 149 */     for (int i = 0; i < m && n > 0; i++) {
/* 150 */       if (this.bits[i] != 0) {
/* 151 */         output.writeVInt(i - last);
/* 152 */         output.writeByte(this.bits[i]);
/* 153 */         last = i;
/* 154 */         n -= BYTE_COUNTS[this.bits[i] & 0xFF];
/*     */       } 
/*     */     } 
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private boolean isSparse() {
/* 168 */     int factor = 10;
/* 169 */     if (this.bits.length < 128) return (factor * (4 + 16 * count()) < size()); 
/* 170 */     if (this.bits.length < 16384) return (factor * (4 + 24 * count()) < size()); 
/* 171 */     if (this.bits.length < 2097152) return (factor * (4 + 32 * count()) < size()); 
/* 172 */     if (this.bits.length < 268435456) return (factor * (4 + 40 * count()) < size()); 
/* 173 */     return (factor * (4 + 48 * count()) < size());
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public BitVector(Directory d, String name) throws IOException {
/* 180 */     IndexInput input = d.openInput(name);
/*     */     try {
/* 182 */       this.size = input.readInt();
/* 183 */       if (this.size == -1) {
/* 184 */         readDgaps(input);
/*     */       } else {
/* 186 */         readBits(input);
/*     */       } 
/*     */     } finally {
/* 189 */       input.close();
/*     */     } 
/*     */   }
/*     */ 
/*     */   
/*     */   private void readBits(IndexInput input) throws IOException {
/* 195 */     this.count = input.readInt();
/* 196 */     this.bits = new byte[(this.size >> 3) + 1];
/* 197 */     input.readBytes(this.bits, 0, this.bits.length);
/*     */   }
/*     */ 
/*     */   
/*     */   private void readDgaps(IndexInput input) throws IOException {
/* 202 */     this.size = input.readInt();
/* 203 */     this.count = input.readInt();
/* 204 */     this.bits = new byte[(this.size >> 3) + 1];
/* 205 */     int last = 0;
/* 206 */     int n = count();
/* 207 */     while (n > 0) {
/* 208 */       last += input.readVInt();
/* 209 */       this.bits[last] = input.readByte();
/* 210 */       n -= BYTE_COUNTS[this.bits[last] & 0xFF];
/*     */     } 
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\BitVector.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.Constants,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public final class Constants
/*    */ {
/* 31 */   public static final String JAVA_VERSION = System.getProperty(""java.version"");
/*    */   
/* 33 */   public static final boolean JAVA_1_1 = JAVA_VERSION.startsWith(""1.1."");
/*    */   
/* 35 */   public static final boolean JAVA_1_2 = JAVA_VERSION.startsWith(""1.2."");
/*    */   
/* 37 */   public static final boolean JAVA_1_3 = JAVA_VERSION.startsWith(""1.3."");
/*    */ 
/*    */   
/* 40 */   public static final String OS_NAME = System.getProperty(""os.name"");
/*    */   
/* 42 */   public static final boolean LINUX = OS_NAME.startsWith(""Linux"");
/*    */   
/* 44 */   public static final boolean WINDOWS = OS_NAME.startsWith(""Windows"");
/*    */   
/* 46 */   public static final boolean SUN_OS = OS_NAME.startsWith(""SunOS"");
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\Constants.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.Parameter,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ import java.io.ObjectStreamException;
/*    */ import java.io.Serializable;
/*    */ import java.io.StreamCorruptedException;
/*    */ import java.util.HashMap;
/*    */ import java.util.Map;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class Parameter
/*    */   implements Serializable
/*    */ {
/* 31 */   static Map allParameters = new HashMap();
/*    */ 
/*    */   
/*    */   private String name;
/*    */ 
/*    */   
/*    */   private Parameter() {}
/*    */ 
/*    */   
/*    */   protected Parameter(String name) {
/* 41 */     this.name = name;
/* 42 */     String key = makeKey(name);
/*    */     
/* 44 */     if (allParameters.containsKey(key)) {
/* 45 */       throw new IllegalArgumentException(""Parameter name "" + key + "" already used!"");
/*    */     }
/* 47 */     allParameters.put(key, this);
/*    */   }
/*    */ 
/*    */   
/* 51 */   private String makeKey(String name) { return getClass() + "" "" + name; }
/*    */ 
/*    */ 
/*    */   
/* 55 */   public String toString() { return this.name; }
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */   
/*    */   protected Object readResolve() throws ObjectStreamException {
/* 66 */     Object par = allParameters.get(makeKey(this.name));
/*    */     
/* 68 */     if (par == null) {
/* 69 */       throw new StreamCorruptedException(""Unknown parameter value: "" + this.name);
/*    */     }
/* 71 */     return par;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\Parameter.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.PriorityQueue,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public abstract class PriorityQueue
/*     */ {
/*     */   private Object[] heap;
/*     */   private int size;
/*     */   private int maxSize;
/*     */   
/*     */   protected abstract boolean lessThan(Object paramObject1, Object paramObject2);
/*     */   
/*     */   protected final void initialize(int maxSize) {
/*  34 */     this.size = 0;
/*  35 */     int heapSize = maxSize + 1;
/*  36 */     this.heap = new Object[heapSize];
/*  37 */     this.maxSize = maxSize;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void put(Object element) {
/*  46 */     this.size++;
/*  47 */     this.heap[this.size] = element;
/*  48 */     upHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean insert(Object element) {
/*  58 */     if (this.size < this.maxSize) {
/*  59 */       put(element);
/*  60 */       return true;
/*     */     } 
/*  62 */     if (this.size > 0 && !lessThan(element, top())) {
/*  63 */       this.heap[1] = element;
/*  64 */       adjustTop();
/*  65 */       return true;
/*     */     } 
/*     */     
/*  68 */     return false;
/*     */   }
/*     */ 
/*     */   
/*     */   public final Object top() {
/*  73 */     if (this.size > 0) {
/*  74 */       return this.heap[1];
/*     */     }
/*  76 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */   
/*     */   public final Object pop() {
/*  82 */     if (this.size > 0) {
/*  83 */       Object result = this.heap[1];
/*  84 */       this.heap[1] = this.heap[this.size];
/*  85 */       this.heap[this.size] = null;
/*  86 */       this.size--;
/*  87 */       downHeap();
/*  88 */       return result;
/*     */     } 
/*  90 */     return null;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 101 */   public final void adjustTop() { downHeap(); }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void clear() {
/* 112 */     for (int i = 0; i <= this.size; i++)
/* 113 */       this.heap[i] = null; 
/* 114 */     this.size = 0;
/*     */   }
/*     */   
/*     */   private final void upHeap() {
/* 118 */     int i = this.size;
/* 119 */     Object node = this.heap[i];
/* 120 */     int j = i >>> 1;
/* 121 */     while (j > 0 && lessThan(node, this.heap[j])) {
/* 122 */       this.heap[i] = this.heap[j];
/* 123 */       i = j;
/* 124 */       j >>>= 1;
/*     */     } 
/* 126 */     this.heap[i] = node;
/*     */   }
/*     */   
/*     */   private final void downHeap() {
/* 130 */     int i = 1;
/* 131 */     Object node = this.heap[i];
/* 132 */     int j = i << 1;
/* 133 */     int k = j + 1;
/* 134 */     if (k <= this.size && lessThan(this.heap[k], this.heap[j])) {
/* 135 */       j = k;
/*     */     }
/* 137 */     while (j <= this.size && lessThan(this.heap[j], node)) {
/* 138 */       this.heap[i] = this.heap[j];
/* 139 */       i = j;
/* 140 */       j = i << 1;
/* 141 */       k = j + 1;
/* 142 */       if (k <= this.size && lessThan(this.heap[k], this.heap[j])) {
/* 143 */         j = k;
/*     */       }
/*     */     } 
/* 146 */     this.heap[i] = node;
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\PriorityQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.ScorerDocQueue,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ import java.io.IOException;
/*     */ import org.apache.lucene.search.Scorer;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class ScorerDocQueue
/*     */ {
/*     */   private final HeapedScorerDoc[] heap;
/*     */   private final int maxSize;
/*     */   private int size;
/*     */   private HeapedScorerDoc topHSD;
/*     */   
/*     */   private class HeapedScorerDoc
/*     */   {
/*     */     Scorer scorer;
/*     */     int doc;
/*     */     private final ScorerDocQueue this$0;
/*     */     
/*  38 */     HeapedScorerDoc(Scorer s) { this(s, s.doc()); }
/*     */     
/*     */     HeapedScorerDoc(Scorer scorer, int doc) {
/*  41 */       this.scorer = scorer;
/*  42 */       this.doc = doc;
/*     */     }
/*     */     
/*  45 */     void adjust() { this.doc = this.scorer.doc(); }
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public ScorerDocQueue(int maxSize) {
/*  53 */     this.size = 0;
/*  54 */     int heapSize = maxSize + 1;
/*  55 */     this.heap = new HeapedScorerDoc[heapSize];
/*  56 */     this.maxSize = maxSize;
/*  57 */     this.topHSD = this.heap[1];
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void put(Scorer scorer) {
/*  66 */     this.size++;
/*  67 */     this.heap[this.size] = new HeapedScorerDoc(scorer);
/*  68 */     upHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public boolean insert(Scorer scorer) {
/*  78 */     if (this.size < this.maxSize) {
/*  79 */       put(scorer);
/*  80 */       return true;
/*     */     } 
/*  82 */     int docNr = scorer.doc();
/*  83 */     if (this.size > 0 && docNr >= this.topHSD.doc) {
/*  84 */       this.heap[1] = new HeapedScorerDoc(scorer, docNr);
/*  85 */       downHeap();
/*  86 */       return true;
/*     */     } 
/*  88 */     return false;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*  98 */   public final Scorer top() { return this.topHSD.scorer; }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 107 */   public final int topDoc() { return this.topHSD.doc; }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/* 112 */   public final float topScore() throws IOException { return this.topHSD.scorer.score(); }
/*     */ 
/*     */ 
/*     */   
/* 116 */   public final boolean topNextAndAdjustElsePop() throws IOException { return checkAdjustElsePop(this.topHSD.scorer.next()); }
/*     */ 
/*     */ 
/*     */   
/* 120 */   public final boolean topSkipToAndAdjustElsePop(int target) throws IOException { return checkAdjustElsePop(this.topHSD.scorer.skipTo(target)); }
/*     */ 
/*     */   
/*     */   private boolean checkAdjustElsePop(boolean cond) {
/* 124 */     if (cond) {
/* 125 */       this.topHSD.doc = this.topHSD.scorer.doc();
/*     */     } else {
/* 127 */       this.heap[1] = this.heap[this.size];
/* 128 */       this.heap[this.size] = null;
/* 129 */       this.size--;
/*     */     } 
/* 131 */     downHeap();
/* 132 */     return cond;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final Scorer pop() {
/* 141 */     Scorer result = this.topHSD.scorer;
/* 142 */     popNoResult();
/* 143 */     return result;
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   private final void popNoResult() {
/* 150 */     this.heap[1] = this.heap[this.size];
/* 151 */     this.heap[this.size] = null;
/* 152 */     this.size--;
/* 153 */     downHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public final void adjustTop() {
/* 165 */     this.topHSD.adjust();
/* 166 */     downHeap();
/*     */   }
/*     */ 
/*     */ 
/*     */   
/* 171 */   public final int size() { return this.size; }
/*     */ 
/*     */ 
/*     */   
/*     */   public final void clear() {
/* 176 */     for (int i = 0; i <= this.size; i++) {
/* 177 */       this.heap[i] = null;
/*     */     }
/* 179 */     this.size = 0;
/*     */   }
/*     */   
/*     */   private final void upHeap() {
/* 183 */     int i = this.size;
/* 184 */     HeapedScorerDoc node = this.heap[i];
/* 185 */     int j = i >>> 1;
/* 186 */     while (j > 0 && node.doc < (this.heap[j]).doc) {
/* 187 */       this.heap[i] = this.heap[j];
/* 188 */       i = j;
/* 189 */       j >>>= 1;
/*     */     } 
/* 191 */     this.heap[i] = node;
/* 192 */     this.topHSD = this.heap[1];
/*     */   }
/*     */   
/*     */   private final void downHeap() {
/* 196 */     int i = 1;
/* 197 */     HeapedScorerDoc node = this.heap[i];
/* 198 */     int j = i << 1;
/* 199 */     int k = j + 1;
/* 200 */     if (k <= this.size && (this.heap[k]).doc < (this.heap[j]).doc) {
/* 201 */       j = k;
/*     */     }
/* 203 */     while (j <= this.size && (this.heap[j]).doc < node.doc) {
/* 204 */       this.heap[i] = this.heap[j];
/* 205 */       i = j;
/* 206 */       j = i << 1;
/* 207 */       k = j + 1;
/* 208 */       if (k <= this.size && (this.heap[k]).doc < (this.heap[j]).doc) {
/* 209 */         j = k;
/*     */       }
/*     */     } 
/* 212 */     this.heap[i] = node;
/* 213 */     this.topHSD = this.heap[1];
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\ScorerDocQueue.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.SmallFloat,"/*     */ package org.apache.lucene.util;
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ public class SmallFloat
/*     */ {
/*     */   public static byte floatToByte(float f, int numMantissaBits, int zeroExp) {
/*  40 */     int fzero = 63 - zeroExp << numMantissaBits;
/*  41 */     int bits = Float.floatToRawIntBits(f);
/*  42 */     int smallfloat = bits >> 24 - numMantissaBits;
/*  43 */     if (smallfloat < fzero) {
/*  44 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/*     */     
/*  47 */     if (smallfloat >= fzero + 256) {
/*  48 */       return -1;
/*     */     }
/*  50 */     return (byte)(smallfloat - fzero);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byteToFloat(byte b, int numMantissaBits, int zeroExp) {
/*  58 */     if (b == 0) return 0.0F; 
/*  59 */     int bits = (b & 0xFF) << 24 - numMantissaBits;
/*  60 */     bits += 63 - zeroExp << 24;
/*  61 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static byte floatToByte315(float f) {
/*  77 */     int bits = Float.floatToRawIntBits(f);
/*  78 */     int smallfloat = bits >> 21;
/*  79 */     if (smallfloat < 384) {
/*  80 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/*  82 */     if (smallfloat >= 640) {
/*  83 */       return -1;
/*     */     }
/*  85 */     return (byte)(smallfloat - 384);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byte315ToFloat(byte b) {
/*  92 */     if (b == 0) return 0.0F; 
/*  93 */     int bits = (b & 0xFF) << 21;
/*  94 */     bits += 805306368;
/*  95 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static byte floatToByte52(float f) {
/* 105 */     int bits = Float.floatToRawIntBits(f);
/* 106 */     int smallfloat = bits >> 19;
/* 107 */     if (smallfloat < 1952) {
/* 108 */       return (bits <= 0) ? 0 : 1;
/*     */     }
/* 110 */     if (smallfloat >= 2208) {
/* 111 */       return -1;
/*     */     }
/* 113 */     return (byte)(smallfloat - 1952);
/*     */   }
/*     */ 
/*     */ 
/*     */ 
/*     */   
/*     */   public static float byte52ToFloat(byte b) {
/* 120 */     if (b == 0) return 0.0F; 
/* 121 */     int bits = (b & 0xFF) << 19;
/* 122 */     bits += 1023410176;
/* 123 */     return Float.intBitsToFloat(bits);
/*     */   }
/*     */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\SmallFloat.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.StringHelper,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public abstract class StringHelper
/*    */ {
/*    */   public static final int stringDifference(String s1, String s2) {
/* 37 */     int len1 = s1.length();
/* 38 */     int len2 = s2.length();
/* 39 */     int len = (len1 < len2) ? len1 : len2;
/* 40 */     for (int i = 0; i < len; i++) {
/* 41 */       if (s1.charAt(i) != s2.charAt(i)) {
/* 42 */         return i;
/*    */       }
/*    */     } 
/* 45 */     return len;
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\StringHelper.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
org.apache.lucene.util.ToStringUtils,"/*    */ package org.apache.lucene.util;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class ToStringUtils
/*    */ {
/*    */   public static String boost(float boost) {
/* 23 */     if (boost != 1.0F)
/* 24 */       return ""^"" + Float.toString(boost); 
/* 25 */     return """";
/*    */   }
/*    */ }
/* Location:              D:\资源包\lucene-core-2.2.0.jar!\org\apache\lucen\\util\ToStringUtils.class
 * Java compiler version: 4 (48.0)
 * JD-Core Version:       1.1.2
 */"
